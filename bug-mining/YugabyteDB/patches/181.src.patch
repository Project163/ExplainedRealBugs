diff --git a/managed/src/main/java/com/yugabyte/yw/common/gflags/GFlagsUtil.java b/managed/src/main/java/com/yugabyte/yw/common/gflags/GFlagsUtil.java
index 54fd5f97aa..72bce2412d 100644
--- a/managed/src/main/java/com/yugabyte/yw/common/gflags/GFlagsUtil.java
+++ b/managed/src/main/java/com/yugabyte/yw/common/gflags/GFlagsUtil.java
@@ -660,11 +660,6 @@ public class GFlagsUtil {
           TIMESTAMP_HISTORY_RETENTION_INTERVAL_SEC,
           Long.toString(timestampHistoryRetentionForPITR.toSeconds() + historyRetentionBufferSecs));
     }
-    if (taskParam.ysqlMajorVersionUpgradeState != null
-        && !taskParam.ysqlMajorVersionUpgradeState.equals(YsqlMajorVersionUpgradeState.FINALIZE)) {
-      gflags.put("ysql_enable_db_catalog_version_mode", "false");
-      gflags.put("TEST_online_pg11_to_pg15_upgrade", "true");
-    }
     return gflags;
   }
 
@@ -1027,11 +1022,6 @@ public class GFlagsUtil {
       gflags.put(MASTER_JOIN_EXISTING_UNIVERSE, "true");
       gflags.merge(UNDEFOK, MASTER_JOIN_EXISTING_UNIVERSE, (v1, v2) -> mergeCSVs(v1, v2, false));
     }
-    if (taskParam.ysqlMajorVersionUpgradeState != null
-        && !taskParam.ysqlMajorVersionUpgradeState.equals(YsqlMajorVersionUpgradeState.FINALIZE)) {
-      gflags.put("ysql_enable_db_catalog_version_mode", "false");
-      gflags.put("TEST_online_pg11_to_pg15_upgrade", "true");
-    }
     return gflags;
   }
 
diff --git a/pg15_tests/common_upgrade.sh b/pg15_tests/common_upgrade.sh
index 51d40a79f5..d5046ad2d3 100644
--- a/pg15_tests/common_upgrade.sh
+++ b/pg15_tests/common_upgrade.sh
@@ -52,7 +52,7 @@ run_and_pushd_pg11() {
 upgrade_masters() {
   for i in {1..3}; do
     yb_ctl restart_node $i --master \
-      --master_flags="$ysql_hba_conf_flag,TEST_online_pg11_to_pg15_upgrade=true,master_join_existing_universe=true,$common_pg15_flags"
+      --master_flags="$ysql_hba_conf_flag,master_join_existing_universe=true,$common_pg15_flags"
   done
 }
 
diff --git a/pg15_tests/test_upgrade_double_initdb.sh b/pg15_tests/test_upgrade_double_initdb.sh
deleted file mode 100755
index 45080b8ed7..0000000000
--- a/pg15_tests/test_upgrade_double_initdb.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-
-# Create pre-existing PG11 table
-ysqlsh <<EOT
-CREATE TABLE t (a int);
-INSERT INTO t VALUES (1), (2);
-EOT
-popd
-upgrade_masters_run_ysql_catalog_upgrade
-
-# Run initdb again, make sure it works (idempotent)
-run_ysql_catalog_upgrade
-
-# Verify upgrade after double initdb
-restart_node_2_in_pg15
-
-verify_simple_table_mixed_cluster
-
-# Restart and demo DDLs
-yb_ctl restart
-verify_simple_table_after_finalize
diff --git a/pg15_tests/test_upgrade_prohibited_rpcs.sh b/pg15_tests/test_upgrade_prohibited_rpcs.sh
deleted file mode 100755
index f2632f2bcb..0000000000
--- a/pg15_tests/test_upgrade_prohibited_rpcs.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-
-yb_ctl_destroy_create
-
-# Issue the upgrade initdb RPC and expect it to return an error, because we're not in upgrade mode.
-initdb_output=$(build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 \
-  ysql_major_version_catalog_upgrade 2>&1) && exit 1
-grep -q "Must be in upgrade mode (FLAGS_TEST_online_pg11_to_pg15_upgrade)" <<< "$initdb_output"
-
-# Issue the rollback RPC and expect it to return an error, because we're not in upgrade mode.
-rollback_output=$(build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 \
-  rollback_ysql_major_version_upgrade 2>&1) && exit 1
-grep -q "Must be in upgrade mode (FLAGS_TEST_online_pg11_to_pg15_upgrade)" \
-  <<< "$rollback_output"
-
-exit 0
diff --git a/pg15_tests/test_upgrade_rollback.sh b/pg15_tests/test_upgrade_rollback.sh
deleted file mode 100755
index 6262d94823..0000000000
--- a/pg15_tests/test_upgrade_rollback.sh
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-
-# Create pre-existing PG11 table
-ysqlsh <<EOT
-CREATE TABLE t (a int);
-INSERT INTO t VALUES (1);
-EOT
-
-# Verify no PG15 catalog tables to begin with
-bin/yb-admin --init_master_addrs=127.0.0.200:7100 list_tables include_table_id | grep -c 8001 \
-  && exit 1
-
-popd
-upgrade_masters_run_ysql_catalog_upgrade
-restart_node_2_in_pg15
-
-# Verify there are PG15 catalog tables now
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 list_tables include_table_id \
-  | grep -c 8001
-
-# Roll back
-# Restart node 2 tserver as PG11
-pushd $pg11path
-yb_ctl restart_node 2 --tserver_flags="$common_tserver_flags"
-popd
-# Issue the rollback RPC
-echo rollback starting at $(date +"%r")
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  rollback_ysql_major_version_upgrade
-echo rollback finished at $(date +"%r")
-
-# Verify there are no PG15 catalog tables
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 list_tables include_table_id \
-  | grep -c 8001 && exit 1
-
-# Start PG11 masters to complete the rollback. The whole cluster will be PG11.
-pushd $pg11path
-for i in {1..3}; do
-  yb_ctl restart_node $i --master
-done
-
-# Verify there are no PG15 catalog tables
-bin/yb-admin --init_master_addrs=127.0.0.200:7100 list_tables include_table_id \
-  | grep -c 8001 && exit 1
-
-# Make sure PG11 still works
-echo making sure pg11 still works, starting at $(date +"%r")
-diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (2);
-SELECT * FROM t ORDER BY a;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 110002
-(1 row)
-
-INSERT 0 1
- a
----
- 1
- 2
-(2 rows)
-
-EOT
-
-# Do the upgrade again
-popd
-upgrade_masters_run_ysql_catalog_upgrade
-
-# Make sure PG11 still works (for PG15, only initdb has run)
-echo making sure pg11 still works
-ysqlsh <<EOT
-SHOW server_version;
-SELECT * FROM t;
-EOT
-echo pg11 still works
-
-echo upgrade after rollback starting at $(date +"%r")
-restart_node_2_in_pg15
-echo upgrade after rollback finished at $(date +"%r")
-
-verify_simple_table_mixed_cluster
-
-# Restart and demo DDLs
-yb_ctl restart
-verify_simple_table_after_finalize
diff --git a/pg15_tests/test_upgrade_simultaneous_rpcs.sh b/pg15_tests/test_upgrade_simultaneous_rpcs.sh
deleted file mode 100755
index 00b87450b0..0000000000
--- a/pg15_tests/test_upgrade_simultaneous_rpcs.sh
+++ /dev/null
@@ -1,112 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-# Create pre-existing PG11 table
-ysqlsh <<EOT
-CREATE TABLE t (a int);
-INSERT INTO t VALUES (1), (2);
-EOT
-popd
-
-# Enter the phase where the masters are upgraded to PG15, but initdb hasn't run
-upgrade_masters
-
-# Start initdb twice and roll back twice, all simultaneously. Only one RPC of the 4 should succeed.
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  ysql_major_version_catalog_upgrade &
-pidi1=$!
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  ysql_major_version_catalog_upgrade &
-pidi2=$!
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  rollback_ysql_major_version_upgrade &
-pidr1=$!
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  rollback_ysql_major_version_upgrade &
-pidr2=$!
-
-set +e
-wait $pidi1
-exiti1=$?
-wait $pidi2
-exiti2=$?
-wait $pidr1
-exitr1=$?
-wait $pidr2
-exitr2=$?
-set -e
-
-echo "exiti1=$exiti1, exiti2=$exiti2, exitr1=$exitr1, exitr2=$exitr2"
-# Check that exactly one completed.
-success_count=$(( ((exiti1 == 0)) + ((exiti2 == 0)) + ((exitr1 == 0)) + ((exitr2 == 0)) ))
-test $success_count -eq 1
-
-# Start initdb, and then roll back after a sleep. Only one RPC should succeed. Though this test is
-# timing-dependent, it will succeed with either ordering and its intention is to test rollback
-# blocked by the upgrade, which should happen the vast majority of the time.
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  ysql_major_version_catalog_upgrade &
-pidi1=$!
-sleep 1
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  rollback_ysql_major_version_upgrade &
-pidr1=$!
-
-set +e
-wait $pidi1
-exiti1=$?
-wait $pidr1
-exitr1=$?
-set -e
-
-echo "exiti1=$exiti1, exitr1=$exitr1"
-# Check that exactly one completed
-success_count=$(( ((exiti1 == 0)) + ((exitr1 == 0)) ))
-echo "success count is $success_count"
-test $success_count -eq 1
-
-# Rollback needs to be slow for the next test to work, which requires ysql catalog upgrade to have
-# completed. If the upgrade hasn't run, run it.
-if [ $exiti1 -ne 0 ]; then
-  run_ysql_catalog_upgrade
-fi
-
-# Trigger rollback, wait one second, and then start ysql catalog upgrade. Though this test is
-# timing-dependent, it will succeed with either ordering and its intention is to test ysql catalog
-# upgrade blocked by running rollback, which should happen the vast majority of the time.
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  rollback_ysql_major_version_upgrade &
-pidr1=$!
-sleep 1
-build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-  ysql_major_version_catalog_upgrade &
-pidi1=$!
-
-set +e
-wait $pidr1
-exitr1=$?
-wait $pidi1
-exiti1=$?
-set -e
-
-echo "exiti1=$exiti1, exitr1=$exitr1"
-# Check that exactly one completed
-success_count=$(( ((exiti1 == 0)) + ((exitr1 == 0)) ))
-echo "success count is $success_count"
-test $success_count -eq 1
-
-# The rest of the test script depends on ysql catalog upgrade having completed.
-# If the upgrade hasn't run, run it.
-if [ $exiti1 -ne 0 ]; then
-  run_ysql_catalog_upgrade
-fi
-
-# Verify upgrade still works
-restart_node_2_in_pg15
-verify_simple_table_mixed_cluster
-
-# Restart and demo DDLs
-yb_ctl restart
-verify_simple_table_after_finalize
diff --git a/src/postgres/src/backend/bootstrap/bootparse.y b/src/postgres/src/backend/bootstrap/bootparse.y
index 046c975da8..a150797e5c 100644
--- a/src/postgres/src/backend/bootstrap/bootparse.y
+++ b/src/postgres/src/backend/bootstrap/bootparse.y
@@ -572,7 +572,7 @@ Boot_CheckInitDbDone:
 				 * initdb is already done for the prior version, but we need to run it for the new
 				 * version.
 				 */
-				if (!YBIsTestOnlinePg11ToPg15Upgrade() && YBIsInitDbAlreadyDone())
+				if (!YBIsMajorUpgradeInitDb() && YBIsInitDbAlreadyDone())
 					exit(YB_INITDB_ALREADY_DONE_EXIT_CODE);
 			}
 
diff --git a/src/postgres/src/common/pg_yb_common.c b/src/postgres/src/common/pg_yb_common.c
index 10f4c54714..f981bdbc9a 100644
--- a/src/postgres/src/common/pg_yb_common.c
+++ b/src/postgres/src/common/pg_yb_common.c
@@ -241,9 +241,10 @@ YBColocateDatabaseByDefault()
 }
 
 bool
-YBIsTestOnlinePg11ToPg15Upgrade()
+YBIsMajorUpgradeInitDb()
 {
-	return YBCIsEnvVarTrue("FLAGS_TEST_online_pg11_to_pg15_upgrade");
+	return YBCIsEnvVarTrueWithDefault("YB_PG_MAJOR_UPGRADE_INITDB",
+									  false /* default_value */);
 }
 
 Oid YBGetDatabaseOidFromEnv(const char *database_name)
@@ -261,7 +262,7 @@ Oid YBGetDatabaseOidFromEnv(const char *database_name)
 }
 
 /*
- * Note: This function is used for the test flag only. 
+ * Note: This function is used for the test flag only.
  * Once the associated feature is fully developed and stable, this function will be removed.
  * The flag is defined this way and not in ybc_pggate.cc because it is used in the ipic.c file,
  * which is initialized before the pggate api.
diff --git a/src/postgres/src/include/common/pg_yb_common.h b/src/postgres/src/include/common/pg_yb_common.h
index 7f0f86d42a..a40ab597cb 100644
--- a/src/postgres/src/include/common/pg_yb_common.h
+++ b/src/postgres/src/include/common/pg_yb_common.h
@@ -37,9 +37,8 @@ extern bool YBCIsEnvVarTrue(const char* env_var_name);
  * but with the given default value in case the environment variable is not
  * defined, or is set to an empty string or the string "auto".
  */
-extern bool YBCIsEnvVarTrueWithDefault(
-    const char* env_var_name,
-    bool default_value);
+extern bool YBCIsEnvVarTrueWithDefault(const char *env_var_name,
+									   bool default_value);
 
 /**
  * Checks if the YB_ENABLED_IN_POSTGRES is set. This is different from
@@ -153,9 +152,9 @@ extern const bool kTestOnlyUseOSDefaultCollation;
 extern bool YBColocateDatabaseByDefault();
 
 /**
- * Returns whether we're doing an online upgrade from PG11 to PG15.
+ * Returns whether we're doing an initdb for a ysql major upgrade.
  */
-extern bool YBIsTestOnlinePg11ToPg15Upgrade();
+extern bool YBIsMajorUpgradeInitDb();
 
 /**
  * Returns the OID for database_name from the environment, if it exists and is
@@ -165,7 +164,7 @@ extern bool YBIsTestOnlinePg11ToPg15Upgrade();
 Oid YBGetDatabaseOidFromEnv(const char *database_name);
 
 /**
- * Returns whether the query diagnostics feature is enabled. 
+ * Returns whether the query diagnostics feature is enabled.
  */
 extern bool YBIsQueryDiagnosticsEnabled();
 
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 8db09e429e..4575055460 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -265,6 +265,7 @@ ADD_YB_TEST(retryable_request-test)
 ADD_YB_TEST(upgrade-tests/basic_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade_pgregress-test)
+ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_rpcs-test)
 
 set(YB_TEST_LINK_LIBS_SAVED ${YB_TEST_LINK_LIBS})
 set(YB_TEST_LINK_LIBS ${YB_TEST_LINK_LIBS} cassandra)
diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index eaa3d9974b..64ea2b41f2 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -1630,7 +1630,7 @@ Status ExternalMiniCluster::WaitForTabletServerCount(size_t count, const MonoDel
         return Status::OK();
       }
     }
-    SleepFor(MonoDelta::FromMilliseconds(1));
+    SleepFor(MonoDelta::FromMilliseconds(100));
   }
 }
 
@@ -2194,6 +2194,22 @@ LogWaiter::LogWaiter(ExternalDaemon* daemon, const std::string& string_to_wait)
   daemon_->SetLogListener(this);
 }
 
+Status ExternalMiniCluster::CallYbAdmin(const std::vector<std::string>& args, MonoDelta timeout) {
+  auto command = ToStringVector(
+      GetToolPath("yb-admin"), "-master_addresses", GetMasterAddresses(), "-timeout_ms",
+      timeout.ToMilliseconds());
+  command.insert(command.end(), args.begin(), args.end());
+
+  LOG(INFO) << "Running " << ToString(command);
+  std::string output, error;
+  auto status = Subprocess::Call(command, &output, &error);
+  LOG(INFO) << "yb-admin Output: " << output;
+  if (!error.empty()) {
+    LOG(INFO) << "yb-admin Error: " << error;
+  }
+  return status;
+}
+
 void LogWaiter::Handle(const GStringPiece& s) {
   if (s.contains(string_to_wait_)) {
     event_occurred_ = true;
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index c63aca8840..f5c3957d56 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -578,6 +578,9 @@ class ExternalMiniCluster : public MiniClusterBase {
 
   void SetMaxGracefulShutdownWaitSec(int max_graceful_shutdown_wait_sec);
 
+  Status CallYbAdmin(
+      const std::vector<std::string>& args, MonoDelta timeout = MonoDelta::FromSeconds(60));
+
  protected:
   friend class UpgradeTestBase;
   FRIEND_TEST(MasterFailoverTest, TestKillAnyMaster);
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index 36463649e5..b01f5d04a1 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -16,6 +16,8 @@
 #include "yb/util/backoff_waiter.h"
 #include "yb/yql/pgwrapper/libpq_utils.h"
 
+using namespace std::chrono_literals;
+
 namespace yb {
 
 class Pg15UpgradeTest : public Pg15UpgradeTestBase {
@@ -28,37 +30,6 @@ class Pg15UpgradeTest : public Pg15UpgradeTestBase {
   constexpr static auto kPostgres = "postgres";
   constexpr static auto kSystemPlatform = "system_platform";
 
-  void TestSimpleTableUpgrade() {
-    const size_t kRowCount = 100;
-    // Create a table with 3 tablets and kRowCount rows so that each tablet has at least a few rows.
-    ASSERT_OK(ExecuteStatements(
-        {"CREATE TABLE t (a INT) SPLIT INTO 3 TABLETS",
-         Format("INSERT INTO t VALUES(generate_series(1, $0))", kRowCount)}));
-    static const auto kSelectFromTable = "SELECT * FROM t";
-
-    ASSERT_OK(UpgradeClusterToMixedMode());
-
-    {
-      auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg15));
-      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-      ASSERT_EQ(PQntuples(count.get()), kRowCount);
-    }
-    {
-      auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg11));
-      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-      ASSERT_EQ(PQntuples(count.get()), kRowCount);
-    }
-
-    ASSERT_OK(FinalizeUpgradeFromMixedMode());
-
-    // Verify row count from a random tserver.
-    {
-      auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
-      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-      ASSERT_EQ(PQntuples(count.get()), kRowCount);
-    }
-  }
-
   // Stops the tserver running on the yb-master leader node.
   // The tserver must be restarted before the test completes for it to succeed the shutdown in the
   // success case.
@@ -96,6 +67,9 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
     ASSERT_STR_CONTAINS(version, old_version_info().version);
   }
 
+  auto ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
+  ASSERT_STR_NOT_CONTAINS(ysql_catalog_config, "catalog_version");
+
   ASSERT_OK(UpgradeClusterToMixedMode());
 
   {
@@ -108,6 +82,8 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
     auto version = ASSERT_RESULT(conn.FetchRowAsString(kSelectVersion));
     ASSERT_STR_CONTAINS(version, old_version_info().version);
   }
+  ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
+  ASSERT_STR_NOT_CONTAINS(ysql_catalog_config, "catalog_version");
 
   ASSERT_OK(FinalizeUpgradeFromMixedMode());
 
@@ -116,9 +92,14 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
     auto version = ASSERT_RESULT(conn.FetchRowAsString(kSelectVersion));
     ASSERT_STR_CONTAINS(version, current_version_info().version_number());
   }
+
+  ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
+  ASSERT_STR_CONTAINS(ysql_catalog_config, "catalog_version: 15");
 }
 
-TEST_F(Pg15UpgradeTest, SimpleTable) { ASSERT_NO_FATALS(TestSimpleTableUpgrade()); }
+TEST_F(Pg15UpgradeTest, SimpleTableUpgrade) { ASSERT_OK(TestUpgradeWithSimpleTable()); }
+
+TEST_F(Pg15UpgradeTest, SimpleTableRollback) { ASSERT_OK(TestRollbackWithSimpleTable()); }
 
 TEST_F(Pg15UpgradeTest, BackslashD) {
   ASSERT_OK(ExecuteStatement("CREATE TABLE t (a INT)"));
@@ -994,7 +975,7 @@ TEST_F(Pg15UpgradeTest, NoTserverOnMasterNode) {
 
   auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
 
-  ASSERT_OK(PerformYsqlMajorVersionUpgrade());
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
   ASSERT_OK(master_tserver->Restart());
   ASSERT_OK(WaitForClusterToStabilize());
 
@@ -1009,12 +990,12 @@ TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
 
   auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
 
-  ASSERT_NOK_STR_CONTAINS(PerformYsqlMajorVersionUpgrade(), "Failed to run pg_upgrade");
+  ASSERT_NOK_STR_CONTAINS(PerformYsqlMajorCatalogUpgrade(), "Failed to run pg_upgrade");
   ASSERT_OK(master_tserver->Restart());
 }
 
 TEST_F(Pg15UpgradeTestWithAuth, UpgradeAuthEnabledUniverse) {
-  ASSERT_NO_FATALS(TestSimpleTableUpgrade());
+  ASSERT_OK(TestUpgradeWithSimpleTable());
 }
 
 TEST_F(Pg15UpgradeTest, GlobalBreakingDDL) {
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
index 64faedb9d8..bc4579b206 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
@@ -12,9 +12,17 @@
 //
 
 #include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
+
+#include <chrono>
+
+#include "yb/master/master_admin.pb.h"
+#include "yb/master/master_admin.proxy.h"
+#include "yb/master/master_defaults.h"
 #include "yb/yql/pgwrapper/libpq_utils.h"
 #include "yb/util/env_util.h"
 
+using namespace std::chrono_literals;
+
 namespace yb {
 
 void Pg15UpgradeTestBase::SetUp() {
@@ -35,7 +43,7 @@ Status Pg15UpgradeTestBase::UpgradeClusterToMixedMode() {
       RestartAllMastersInCurrentVersion(no_delay_between_nodes), "Failed to restart masters");
 
   RETURN_NOT_OK_PREPEND(
-      PerformYsqlMajorVersionUpgrade(), "Failed to run ysql major version upgrade");
+      PerformYsqlMajorCatalogUpgrade(), "Failed to run ysql major catalog upgrade");
 
   LOG(INFO) << "Restarting yb-tserver " << kMixedModeTserverPg15 << " in current version";
   auto mixed_mode_pg15_tserver = cluster_->tablet_server(kMixedModeTserverPg15);
@@ -71,7 +79,8 @@ Status Pg15UpgradeTestBase::RollbackUpgradeFromMixedMode() {
   auto first_tserver = cluster_->tablet_server(kMixedModeTserverPg15);
   RETURN_NOT_OK(RestartTServerInOldVersion(*first_tserver, /*wait_for_cluster_to_stabilize=*/true));
 
-  RETURN_NOT_OK_PREPEND(RollbackYsqlMajorVersion(), "Failed to run ysql major version rollback");
+  RETURN_NOT_OK_PREPEND(
+      RollbackYsqlMajorCatalogVersion(), "Failed to run ysql major catalog rollback");
 
   static const MonoDelta no_delay_between_nodes = 0s;
   RETURN_NOT_OK_PREPEND(
@@ -166,4 +175,88 @@ Result<std::string> Pg15UpgradeTestBase::ExecuteViaYsqlsh(const std::string& sql
   return ExecuteViaYsqlshOnTs(sql_statement, node_index, db_name);
 }
 
+Status Pg15UpgradeTestBase::CreateSimpleTable() {
+  simple_tbl_row_count_ = 100;
+  return ExecuteStatements(
+      {Format("CREATE TABLE $0 (a INT) SPLIT INTO 3 TABLETS", kSimpleTableName),
+       Format(
+           "INSERT INTO $0 VALUES(generate_series(1, $1))", kSimpleTableName,
+           simple_tbl_row_count_)});
+}
+
+Status Pg15UpgradeTestBase::InsertRowInSimpleTableAndValidate(const std::optional<size_t> tserver) {
+  auto conn = VERIFY_RESULT(cluster_->ConnectToDB("yugabyte", tserver));
+  RETURN_NOT_OK(conn.Execute(
+      Format("INSERT INTO $0 VALUES ($1)", kSimpleTableName, ++simple_tbl_row_count_)));
+
+  auto actual_row_count =
+      VERIFY_RESULT(conn.FetchRow<int64_t>(Format("SELECT COUNT(*) FROM $0", kSimpleTableName)));
+  SCHECK_EQ(actual_row_count, simple_tbl_row_count_, IllegalState, "Unexpected row count");
+
+  auto sum =
+      VERIFY_RESULT(conn.FetchRow<int64_t>(Format("SELECT SUM(a) FROM $0", kSimpleTableName)));
+  SCHECK_EQ(
+      sum, (simple_tbl_row_count_ * (simple_tbl_row_count_ + 1)) / 2, IllegalState,
+      "Unexpected sum of column a");
+
+  return Status::OK();
+}
+
+Status Pg15UpgradeTestBase::TestUpgradeWithSimpleTable() {
+  // Create a table with 3 tablets and kRowCount rows so that each tablet has at least a few rows.
+  RETURN_NOT_OK(CreateSimpleTable());
+
+  RETURN_NOT_OK(UpgradeClusterToMixedMode());
+
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg15));
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg11));
+
+  RETURN_NOT_OK(FinalizeUpgradeFromMixedMode());
+
+  // Verify row count from a random tserver.
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate());
+
+  return Status::OK();
+}
+
+Status Pg15UpgradeTestBase::TestRollbackWithSimpleTable() {
+  RETURN_NOT_OK(CreateSimpleTable());
+
+  RETURN_NOT_OK(UpgradeClusterToMixedMode());
+
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg15));
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg11));
+
+  RETURN_NOT_OK(RollbackUpgradeFromMixedMode());
+
+  // Verify row count from a random tserver.
+  RETURN_NOT_OK(InsertRowInSimpleTableAndValidate());
+
+  return Status::OK();
+}
+
+Result<std::string> Pg15UpgradeTestBase::DumpYsqlCatalogConfig() {
+  master::DumpSysCatalogEntriesRequestPB req;
+  master::DumpSysCatalogEntriesResponsePB resp;
+  req.set_entry_type(master::SysRowEntryType::SYS_CONFIG);
+  req.set_entity_id_filter(master::kYsqlCatalogConfigType);
+
+  rpc::RpcController rpc;
+  rpc.set_timeout(60s);
+
+  auto master_admin_proxy =
+      master::MasterAdminProxy(cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>());
+  RETURN_NOT_OK(master_admin_proxy.DumpSysCatalogEntries(req, &resp, &rpc));
+
+  LOG(INFO) << "Dumped ysql catalog config: " << resp.DebugString();
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  SCHECK_EQ(resp.entries_size(), 1, IllegalState, "Expected exactly one entry");
+
+  return resp.entries(0).pb_debug_string();
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
index cff11c5a3f..772e1c3a6b 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
@@ -30,8 +30,9 @@ class Pg15UpgradeTestBase : public UpgradeTestBase {
   // helper functions only upgrade one tserver (id=kMixedModeTserverPg15) to the current version and
   // keep the other tservers in the old version, helping us perform validations while in mixed mode.
 
-  const size_t kMixedModeTserverPg15 = 0;
-  const size_t kMixedModeTserverPg11 = 1;
+  static constexpr size_t kMixedModeTserverPg15 = 0;
+  static constexpr size_t kMixedModeTserverPg11 = 1;
+  static constexpr std::optional<size_t> kAnyTserver = std::nullopt;
 
   // Restarts all masters in the current version, runs ysql major version upgrade, and restarts
   // tserver kMixedModeTserverPg15 in the current version. Other tservers are kept in the pg11
@@ -60,6 +61,17 @@ class Pg15UpgradeTestBase : public UpgradeTestBase {
   // Run a ysql statement via ysqlsh against a random tserver.
   Result<std::string> ExecuteViaYsqlsh(const std::string& sql_statement,
                                        const std::string &db_name = "yugabyte");
+
+  Status CreateSimpleTable();
+  Status InsertRowInSimpleTableAndValidate(const std::optional<size_t> tserver = kAnyTserver);
+
+  Status TestUpgradeWithSimpleTable();
+  Status TestRollbackWithSimpleTable();
+
+  Result<std::string> DumpYsqlCatalogConfig();
+
+  constexpr static auto kSimpleTableName = "simple_tbl";
+  uint32 simple_tbl_row_count_ = 0;
 };
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
index d4bf6d2a2c..8b3a2358ce 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
@@ -34,11 +34,13 @@
 
 DECLARE_uint32(auto_flags_apply_delay_ms);
 
+using namespace std::literals;
+
 namespace yb {
 
 namespace {
 
-const MonoDelta kTimeout = 20s * kTimeMultiplier;
+const MonoDelta kRpcTimeout = 20s * kTimeMultiplier;
 
 // Returns the URL for the current build type and os platform. Returns empty string if a valid URL
 // does not exist.
@@ -203,14 +205,6 @@ void AddUnDefOkAndSetFlag(
 
 void WaitForAutoFlagApply() { SleepFor(FLAGS_auto_flags_apply_delay_ms * 1ms + 3s); }
 
-Status SetYsqlMajorUpgradeFlagOnMasters(ExternalMiniCluster& cluster, bool enable) {
-  for (auto* master : cluster.master_daemons()) {
-    RETURN_NOT_OK(
-        cluster.SetFlag(master, "TEST_online_pg11_to_pg15_upgrade", enable ? "true" : "false"));
-  }
-  return Status::OK();
-}
-
 // This is a pg15 version which supports upgrade only from certain versions.
 // Check if the given version is supported for upgrade.
 bool IsUpgradeSupported(const std::string& from_version) {
@@ -322,7 +316,7 @@ Status UpgradeTestBase::StartClusterInOldVersion(const ExternalMiniClusterOption
   server::GetStatusRequestPB req;
   server::GetStatusResponsePB resp;
   rpc::RpcController rpc;
-  rpc.set_timeout(kTimeout);
+  rpc.set_timeout(kRpcTimeout);
   RETURN_NOT_OK(
       cluster_->GetLeaderMasterProxy<server::GenericServiceProxy>().GetStatus(req, &resp, &rpc));
   LOG(INFO) << "From version: " << resp.status().version_info().DebugString();
@@ -346,7 +340,7 @@ Status UpgradeTestBase::UpgradeClusterToCurrentVersion(
       RestartAllMastersInCurrentVersion(delay_between_nodes), "Failed to restart masters");
 
   RETURN_NOT_OK_PREPEND(
-      PerformYsqlMajorVersionUpgrade(), "Failed to run ysql major version upgrade");
+      PerformYsqlMajorCatalogUpgrade(), "Failed to run ysql major catalog upgrade");
 
   RETURN_NOT_OK_PREPEND(
       RestartAllTServersInCurrentVersion(delay_between_nodes), "Failed to restart tservers");
@@ -421,42 +415,43 @@ Status UpgradeTestBase::RestartTServerInCurrentVersion(
   return Status::OK();
 }
 
-Status UpgradeTestBase::PerformYsqlMajorVersionUpgrade() {
+Status UpgradeTestBase::PerformYsqlMajorCatalogUpgrade() {
   if (!is_ysql_major_version_upgrade_) {
     return Status::OK();
   }
 
-  LOG(INFO) << "Running ysql major version upgrade";
-
-  RETURN_NOT_OK(SetYsqlMajorUpgradeFlagOnMasters(*cluster_, true));
+  LOG(INFO) << "Running ysql major catalog version upgrade";
 
-  master::StartYsqlMajorVersionUpgradeInitdbRequestPB req;
-  master::StartYsqlMajorVersionUpgradeInitdbResponsePB resp;
+  master::StartYsqlMajorCatalogUpgradeRequestPB req;
+  master::StartYsqlMajorCatalogUpgradeResponsePB resp;
   rpc::RpcController rpc;
-  rpc.set_timeout(kTimeout);
+  rpc.set_timeout(kRpcTimeout);
   auto master_admin_proxy = cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>();
-  RETURN_NOT_OK(master_admin_proxy.StartYsqlMajorVersionUpgradeInitdb(req, &resp, &rpc));
+  RETURN_NOT_OK(master_admin_proxy.StartYsqlMajorCatalogUpgrade(req, &resp, &rpc));
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   }
 
+  return WaitForYsqlMajorCatalogUpgradeToFinish();
+}
+
+Status UpgradeTestBase::WaitForYsqlMajorCatalogUpgradeToFinish() {
+  auto master_admin_proxy = cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>();
+
   auto is_upgrade_done = [&master_admin_proxy]() -> Result<bool> {
-    master::IsYsqlMajorVersionUpgradeInitdbDoneRequestPB req;
-    master::IsYsqlMajorVersionUpgradeInitdbDoneResponsePB resp;
+    master::IsYsqlMajorCatalogUpgradeDoneRequestPB req;
+    master::IsYsqlMajorCatalogUpgradeDoneResponsePB resp;
     rpc::RpcController rpc;
-    rpc.set_timeout(kTimeout);
-    RETURN_NOT_OK(master_admin_proxy.IsYsqlMajorVersionUpgradeInitdbDone(req, &resp, &rpc));
+    rpc.set_timeout(kRpcTimeout);
+    RETURN_NOT_OK(master_admin_proxy.IsYsqlMajorCatalogUpgradeDone(req, &resp, &rpc));
     if (resp.has_error()) {
       return StatusFromPB(resp.error().status());
     }
-    if (resp.has_initdb_error()) {
-      return StatusFromPB(resp.initdb_error().status());
-    }
     return resp.done();
   };
 
   return LoggedWaitFor(
-      is_upgrade_done, 10min, "Waiting for ysql major version upgrade to complete");
+      is_upgrade_done, 10min, "Waiting for ysql major catalog upgrade to complete");
 }
 
 Status UpgradeTestBase::PromoteAutoFlags(AutoFlagClass flag_class) {
@@ -465,7 +460,7 @@ Status UpgradeTestBase::PromoteAutoFlags(AutoFlagClass flag_class) {
   master::PromoteAutoFlagsRequestPB req;
   master::PromoteAutoFlagsResponsePB resp;
   rpc::RpcController rpc;
-  rpc.set_timeout(kTimeout);
+  rpc.set_timeout(kRpcTimeout);
   req.set_max_flag_class(ToString(flag_class));
   req.set_promote_non_runtime_flags(false);
   req.set_force(false);
@@ -493,14 +488,23 @@ Status UpgradeTestBase::PromoteAutoFlags(AutoFlagClass flag_class) {
   return Status::OK();
 }
 
-Status UpgradeTestBase::FinalizeYsqlMajorVersionUpgrade() {
+Status UpgradeTestBase::FinalizeYsqlMajorCatalogUpgrade() {
   if (!is_ysql_major_version_upgrade_) {
     return Status::OK();
   }
 
-  LOG(INFO) << "Finalizing ysql major version upgrade";
+  LOG(INFO) << "Finalizing ysql major catalog upgrade";
 
-  RETURN_NOT_OK(SetYsqlMajorUpgradeFlagOnMasters(*cluster_, false));
+  master::FinalizeYsqlMajorCatalogUpgradeRequestPB req;
+  master::FinalizeYsqlMajorCatalogUpgradeResponsePB resp;
+  rpc::RpcController rpc;
+  rpc.set_timeout(kRpcTimeout);
+  RETURN_NOT_OK(
+      cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>().FinalizeYsqlMajorCatalogUpgrade(
+          req, &resp, &rpc));
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
 
   return Status::OK();
 }
@@ -527,7 +531,7 @@ Status UpgradeTestBase::FinalizeUpgrade() {
   LOG(INFO) << "Finalizing upgrade";
 
   RETURN_NOT_OK_PREPEND(
-      FinalizeYsqlMajorVersionUpgrade(), "Failed to run ysql major version upgrade");
+      FinalizeYsqlMajorCatalogUpgrade(), "Failed to run ysql major catalog upgrade");
 
   RETURN_NOT_OK_PREPEND(PromoteAutoFlags(), "Failed to promote AutoFlags");
 
@@ -540,27 +544,25 @@ Status UpgradeTestBase::FinalizeUpgrade() {
   return Status::OK();
 }
 
-Status UpgradeTestBase::RollbackYsqlMajorVersion() {
+Status UpgradeTestBase::RollbackYsqlMajorCatalogVersion() {
   if (!is_ysql_major_version_upgrade_) {
     return Status::OK();
   }
 
-  LOG(INFO) << "Running ysql major version rollback";
+  LOG(INFO) << "Running ysql major catalog rollback";
 
-  master::RollbackYsqlMajorVersionUpgradeRequestPB req;
-  master::RollbackYsqlMajorVersionUpgradeResponsePB resp;
+  master::RollbackYsqlMajorCatalogVersionRequestPB req;
+  master::RollbackYsqlMajorCatalogVersionResponsePB resp;
   rpc::RpcController rpc;
   // Rollback RPC is synchronous and can take a while.
   rpc.set_timeout(3min);
   RETURN_NOT_OK(
-      cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>().RollbackYsqlMajorVersionUpgrade(
+      cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>().RollbackYsqlMajorCatalogVersion(
           req, &resp, &rpc));
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   }
 
-  RETURN_NOT_OK(SetYsqlMajorUpgradeFlagOnMasters(*cluster_, false));
-
   return Status::OK();
 }
 
@@ -574,7 +576,7 @@ Status UpgradeTestBase::RollbackVolatileAutoFlags() {
   master::RollbackAutoFlagsRequestPB req;
   master::RollbackAutoFlagsResponsePB resp;
   rpc::RpcController rpc;
-  rpc.set_timeout(kTimeout);
+  rpc.set_timeout(kRpcTimeout);
   req.set_rollback_version(*auto_flags_rollback_version_);
   RETURN_NOT_OK(cluster_->GetLeaderMasterProxy<master::MasterClusterProxy>().RollbackAutoFlags(
       req, &resp, &rpc));
@@ -598,7 +600,8 @@ Status UpgradeTestBase::RollbackClusterToOldVersion(MonoDelta delay_between_node
   RETURN_NOT_OK_PREPEND(
       RestartAllTServersInOldVersion(delay_between_nodes), "Failed to restart tservers");
 
-  RETURN_NOT_OK_PREPEND(RollbackYsqlMajorVersion(), "Failed to run ysql major version rollback");
+  RETURN_NOT_OK_PREPEND(
+      RollbackYsqlMajorCatalogVersion(), "Failed to run ysql major catalog rollback");
 
   RETURN_NOT_OK_PREPEND(
       RestartAllMastersInOldVersion(delay_between_nodes), "Failed to restart masters");
@@ -665,7 +668,7 @@ Status UpgradeTestBase::RestartTServerInOldVersion(
 }
 
 Status UpgradeTestBase::WaitForClusterToStabilize() {
-  RETURN_NOT_OK(cluster_->WaitForTabletServerCount(cluster_->num_tablet_servers(), kTimeout));
+  RETURN_NOT_OK(cluster_->WaitForTabletServerCount(cluster_->num_tablet_servers(), 5min));
 
   return Status::OK();
 }
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
index bc00178c37..ec38b6565c 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
@@ -53,13 +53,14 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
   Status RestartTServerInCurrentVersion(
       ExternalTabletServer& ts, bool wait_for_cluster_to_stabilize = true);
 
-  Status PerformYsqlMajorVersionUpgrade();
+  virtual Status PerformYsqlMajorCatalogUpgrade();
+  Status WaitForYsqlMajorCatalogUpgradeToFinish();
 
   Status FinalizeUpgrade();
 
   Status PromoteAutoFlags(AutoFlagClass flag_class = AutoFlagClass::kExternal);
 
-  Status FinalizeYsqlMajorVersionUpgrade();
+  Status FinalizeYsqlMajorCatalogUpgrade();
 
   Status PerformYsqlUpgrade();
 
@@ -73,13 +74,13 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
   Status RestartTServerInOldVersion(
       ExternalTabletServer& ts, bool wait_for_cluster_to_stabilize = true);
 
-  Status RollbackYsqlMajorVersion();
+  virtual Status RollbackYsqlMajorCatalogVersion();
 
   Status RollbackVolatileAutoFlags();
 
   // Wait for the cluster to stabilize after an upgrade or rollback.
-  // Waits for all tservers to register with the master leader, which happens after all tablets have
-  // been bootstrapped.
+  // Waits for all tservers to register with the master leader, which happens after all tablets
+  // have been bootstrapped.
   Status WaitForClusterToStabilize();
 
   BuildInfo old_version_info() const { return old_version_info_; }
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
new file mode 100644
index 0000000000..da109c6913
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
@@ -0,0 +1,285 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
+
+#include "yb/master/master_admin.proxy.h"
+#include "yb/tools/yb-admin_client.h"
+#include "yb/util/backoff_waiter.h"
+#include "yb/util/sync_point.h"
+#include "yb/yql/pgwrapper/libpq_utils.h"
+
+using namespace std::literals;
+
+namespace yb {
+
+static const MonoDelta kNoDelayBetweenNodes = 0s;
+
+class YsqlMajorUpgradeRpcsTest : public Pg15UpgradeTestBase {
+ public:
+  YsqlMajorUpgradeRpcsTest() = default;
+
+  void SetUp() override {
+    Pg15UpgradeTestBase::SetUp();
+    if (IsTestSkipped()) {
+      return;
+    }
+
+    CHECK_OK(CreateSimpleTable());
+  }
+
+ protected:
+  master::MasterAdminProxy GetMasterAdminProxy() {
+    return master::MasterAdminProxy(cluster_->GetLeaderMasterProxy<master::MasterAdminProxy>());
+  }
+
+  void AsyncStartYsqlMajorUpgrade(
+      master::StartYsqlMajorCatalogUpgradeResponsePB& resp, rpc::RpcController& rpc,
+      CountDownLatch& latch) {
+    LOG_WITH_FUNC(INFO) << "Starting ysql major upgrade";
+
+    master::StartYsqlMajorCatalogUpgradeRequestPB req;
+    GetMasterAdminProxy().StartYsqlMajorCatalogUpgradeAsync(
+        req, &resp, &rpc, [&latch]() { latch.CountDown(); });
+  }
+
+  void AsyncStartYsqlMajorRollback(
+      master::RollbackYsqlMajorCatalogVersionResponsePB& resp, rpc::RpcController& rpc,
+      CountDownLatch& latch) {
+    LOG_WITH_FUNC(INFO) << "Starting ysql major upgrade rollback";
+
+    master::RollbackYsqlMajorCatalogVersionRequestPB req;
+    GetMasterAdminProxy().RollbackYsqlMajorCatalogVersionAsync(
+        req, &resp, &rpc, [&latch]() { latch.CountDown(); });
+  }
+
+  // Waits for the catalog upgrade to finish and completes the rest of the upgrade with validation
+  // checks.
+  // Ysql major upgrade must already be started.
+  Status CompleteUpgradeAndValidate() {
+    RETURN_NOT_OK(WaitForYsqlMajorCatalogUpgradeToFinish());
+
+    LOG(INFO) << "Restarting yb-tserver " << kMixedModeTserverPg15 << " in current version";
+    auto mixed_mode_pg15_tserver = cluster_->tablet_server(kMixedModeTserverPg15);
+    RETURN_NOT_OK(RestartTServerInCurrentVersion(
+        *mixed_mode_pg15_tserver, /*wait_for_cluster_to_stabilize=*/true));
+
+    RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg11));
+    RETURN_NOT_OK(InsertRowInSimpleTableAndValidate(kMixedModeTserverPg15));
+
+    RETURN_NOT_OK(FinalizeUpgradeFromMixedMode());
+
+    return InsertRowInSimpleTableAndValidate();
+  }
+};
+
+// Start multiple ysql major upgrade RPCs simultaneously. Only one RPC should succeed.
+TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousUpgrades) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  const int kNumSimultaneousRpcs = 2;
+
+  rpc::RpcController rpcs[kNumSimultaneousRpcs];
+  CountDownLatch latch(kNumSimultaneousRpcs);
+  master::StartYsqlMajorCatalogUpgradeResponsePB resps[kNumSimultaneousRpcs];
+  for (int i = 0; i < kNumSimultaneousRpcs; i++) {
+    AsyncStartYsqlMajorUpgrade(resps[i], rpcs[i], latch);
+  }
+
+  latch.Wait();
+
+  for (auto& rpc : rpcs) {
+    ASSERT_TRUE(rpc.finished());
+  }
+
+  int num_success = 0;
+  for (auto& resp : resps) {
+    LOG(INFO) << "Start upgrade response: " << resp.DebugString();
+    num_success += !resp.has_error();
+  }
+  ASSERT_EQ(num_success, 1);
+
+  ASSERT_OK(CompleteUpgradeAndValidate());
+
+  ASSERT_NOK_STR_CONTAINS(
+      PerformYsqlMajorCatalogUpgrade(), "Ysql Catalog is already on the current major version");
+}
+
+// Start multiple ysql major upgrade rollback RPCs simultaneously. Only one RPC should succeed.
+TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousRollback) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  // Calling rollback before upgrade should succeed immediately.
+  ASSERT_OK(RollbackYsqlMajorCatalogVersion());
+
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
+
+  const int kNumSimultaneousRpcs = 2;
+
+  rpc::RpcController rpcs[kNumSimultaneousRpcs];
+  CountDownLatch latch(kNumSimultaneousRpcs);
+  master::RollbackYsqlMajorCatalogVersionResponsePB resps[kNumSimultaneousRpcs];
+  for (int i = 0; i < kNumSimultaneousRpcs; i++) {
+    AsyncStartYsqlMajorRollback(resps[i], rpcs[i], latch);
+  }
+
+  latch.Wait();
+
+  for (auto& rpc : rpcs) {
+    ASSERT_TRUE(rpc.finished());
+  }
+
+  int num_success = 0;
+  for (auto& resp : resps) {
+    LOG(INFO) << "Rollback upgrade response: " << resp.DebugString();
+    num_success += !resp.has_error();
+  }
+  ASSERT_EQ(num_success, 1);
+
+  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+}
+
+// Make sure ysql major catalog rollback is blocked while we are running ysql major upgrade.
+TEST_F(YsqlMajorUpgradeRpcsTest, RollbackDuringUpgrade) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  master::StartYsqlMajorCatalogUpgradeResponsePB upgrade_response;
+  master::RollbackYsqlMajorCatalogVersionResponsePB rollback_response;
+
+  rpc::RpcController rpc;
+  CountDownLatch latch(1);
+
+  AsyncStartYsqlMajorUpgrade(upgrade_response, rpc, latch);
+
+  // The upgrade takes longer than 5s in all builds.
+  SleepFor(5s);
+  ASSERT_NOK_STR_CONTAINS(
+      RollbackYsqlMajorCatalogVersion(),
+      "Global initdb or ysql major catalog upgrade/rollback is already in progress");
+
+  latch.Wait();
+  ASSERT_TRUE(rpc.finished());
+
+  ASSERT_FALSE(upgrade_response.has_error()) << upgrade_response.error().ShortDebugString();
+
+  ASSERT_OK(CompleteUpgradeAndValidate());
+}
+
+// Make sure ysql major catalog upgrade is blocked while we are running ysql major upgrade rollback.
+TEST_F(YsqlMajorUpgradeRpcsTest, UpgradeDuringRollback) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
+
+  master::RollbackYsqlMajorCatalogVersionResponsePB rollback_response;
+  rpc::RpcController rpc;
+  CountDownLatch latch(1);
+
+  AsyncStartYsqlMajorRollback(rollback_response, rpc, latch);
+
+  // The rollback takes around 2s in all builds.
+  SleepFor(2s);
+  ASSERT_NOK(PerformYsqlMajorCatalogUpgrade());
+
+  latch.Wait();
+  ASSERT_TRUE(rpc.finished());
+
+  ASSERT_FALSE(rollback_response.has_error()) << rollback_response.ShortDebugString();
+
+  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+}
+
+// Make sure ysql major catalog upgrade works with a master crash during the upgrade.
+// Disabling in debug builds since this test times out on it.
+TEST_F(YsqlMajorUpgradeRpcsTest, YB_DISABLE_TEST_EXCEPT_RELEASE(MasterCrashDuringUpgrade)) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+  auto master_leader = cluster_->GetLeaderMaster();
+
+  // Block the upgrade from finishing.
+  ASSERT_OK(cluster_->SetFlag(
+      master_leader, "TEST_fail_ysql_catalog_upgrade_state_transition_from",
+      "PERFORMING_PG_UPGRADE"));
+
+  rpc::RpcController rpc;
+  CountDownLatch latch(1);
+  master::StartYsqlMajorCatalogUpgradeResponsePB upgrade_response;
+  AsyncStartYsqlMajorUpgrade(upgrade_response, rpc, latch);
+  latch.Wait();
+
+  ASSERT_OK(LoggedWaitFor(
+      [this]() -> Result<bool> {
+        return VERIFY_RESULT(DumpYsqlCatalogConfig()).find("state: PERFORMING_PG_UPGRADE") !=
+               std::string::npos;
+      },
+      5min, "Waiting for pg_upgrade to start"));
+
+  // The pg_upgrade takes longer than 2s in all builds.
+  SleepFor(2s);
+
+  master_leader->Shutdown();
+  ASSERT_OK(WaitForClusterToStabilize());
+
+  auto ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
+  ASSERT_STR_CONTAINS(ysql_catalog_config, "state: FAILED");
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+
+  ASSERT_OK(master_leader->Restart());
+
+  ASSERT_OK(RollbackYsqlMajorCatalogVersion());
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+
+  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+}
+
+// Make sure ysql major catalog upgrade works with a master crash during the upgrade.
+TEST_F(YsqlMajorUpgradeRpcsTest, MasterCrashDuringMonitoring) {
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
+
+  auto master_leader = cluster_->GetLeaderMaster();
+  master_leader->Shutdown();
+  ASSERT_OK(WaitForClusterToStabilize());
+
+  auto ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
+  ASSERT_STR_CONTAINS(ysql_catalog_config, "state: MONITORING");
+
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+
+  ASSERT_OK(master_leader->Restart());
+  ASSERT_OK(CompleteUpgradeAndValidate());
+}
+
+class YsqlMajorUpgradeYbAdminTest : public Pg15UpgradeTestBase {
+ public:
+  YsqlMajorUpgradeYbAdminTest() = default;
+
+ protected:
+  Status PerformYsqlMajorCatalogUpgrade() override {
+    return cluster_->CallYbAdmin({"ysql_major_version_catalog_upgrade"}, 10min);
+  }
+
+  Status RollbackYsqlMajorCatalogVersion() override {
+    return cluster_->CallYbAdmin({"rollback_ysql_major_version_upgrade"}, 10min);
+  }
+};
+
+TEST_F(YsqlMajorUpgradeYbAdminTest, Upgrade) { ASSERT_OK(TestUpgradeWithSimpleTable()); }
+
+TEST_F(YsqlMajorUpgradeYbAdminTest, Rollback) { ASSERT_OK(TestRollbackWithSimpleTable()); }
+
+}  // namespace yb
diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index 24ae58f64f..76179b8089 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -475,6 +475,28 @@ message SysSecurityConfigEntryPB {
   optional bool cassandra_user_created = 2 [default = false];
 }
 
+message YsqlMajorCatalogUpgradeInfoPB {
+  enum State {
+    INVALID = 0;
+    DONE = 1;
+    FAILED = 2;
+    PERFORMING_INIT_DB = 3;
+    PERFORMING_PG_UPGRADE = 4;
+    MONITORING = 5;
+    PERFORMING_ROLLBACK = 6;
+  }
+  optional State state = 1 [ default = DONE ];
+
+  // This is set when the state is FAILED.
+  optional AppStatusPB previous_error = 2;
+
+  // Set to the current version at time of new universe creation.
+  // Updated after the ysql major catalog upgrade is complete.
+  // This field is introduced in version 15. So universes that are upgraded
+  // will have the default value of 11 (the previous version).
+  optional uint32 catalog_version = 3 [ default = 11 ];
+}
+
 // Metadata about the YSQL catalog (current only version).
 message SysYSQLCatalogConfigEntryPB {
   // YSQL catalog version. Every time the catalog tables are changed (i.e. by DDL statements)
@@ -487,15 +509,7 @@ message SysYSQLCatalogConfigEntryPB {
   // If this is set, initdb has failed.
   optional string initdb_error = 5;
 
-  message YsqlMajorUpgradeInfoPB {
-    // This is true if the master ran initdb during a ysql major version upgrade and it finished,
-    // successfully or not.
-    optional bool next_ver_initdb_done = 1;
-
-    // If this is set, initdb during a ysql major version upgrade has failed.
-    optional MasterErrorPB next_ver_initdb_error = 2;
-  }
-  optional YsqlMajorUpgradeInfoPB ysql_major_upgrade_info = 7;
+  optional YsqlMajorCatalogUpgradeInfoPB ysql_major_catalog_upgrade_info = 7;
 
   // true if transactional system catalogs have been enabled on this cluster. This means all
   // YSQL system catalog tables have been made transactional, both in their schema and in the tablet
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 36c11f520a..e61b9ecada 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -587,8 +587,6 @@ DEFINE_RUNTIME_bool(master_join_existing_universe, false,
     "other factors. To create a new universe with a new group of masters, unset this flag. Set "
     "this flag on all new and existing master processes once the universe creation completes.");
 
-DECLARE_bool(TEST_online_pg11_to_pg15_upgrade);
-
 DEFINE_test_flag(bool, disable_set_catalog_version_table_in_perdb_mode, false,
                  "Whether to disable setting the catalog version table in perdb mode.");
 DEFINE_RUNTIME_uint32(initial_tserver_registration_duration_secs,
@@ -1232,7 +1230,7 @@ Status CatalogManager::MaybeRestoreInitialSysCatalogSnapshotAndReloadSysCatalog(
     return Status::OK();
   }
 
-  if (ysql_catalog_config_.IsInitDbDone()) {
+  if (ysql_initdb_and_major_upgrade_helper_->IsInitDbDone()) {
     LOG_WITH_PREFIX(INFO) << "initdb has been run before, no need to restore sys catalog from "
                           << "the initial snapshot";
     return Status::OK();
@@ -1259,7 +1257,7 @@ Status CatalogManager::MaybeRestoreInitialSysCatalogSnapshotAndReloadSysCatalog(
       state->epoch.leader_term, /* recreate = */ true));
 
   LOG_WITH_PREFIX(INFO) << "Restoring snapshot completed, considering initdb finished";
-  RETURN_NOT_OK(ysql_catalog_config_.SetInitDbDone(Status::OK(), state->epoch));
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->SetInitDbDone(state->epoch));
   // TODO(asrivastava): Can we get rid of this Reset() by calling RunLoaders just once
   // instead of calling it here and in VisitSysCatalog?
   state->Reset();
@@ -1683,7 +1681,7 @@ Status CatalogManager::PrepareDefaultSysConfig(int64_t term) {
 }
 
 Result<bool> CatalogManager::StartRunningInitDbIfNeeded(const LeaderEpoch& epoch) {
-  if (ysql_catalog_config_.IsInitDbDone()) {
+  if (ysql_initdb_and_major_upgrade_helper_->IsInitDbDone()) {
     LOG(INFO) << "Cluster configuration indicates that initdb has already completed";
     return false;
   }
@@ -1694,7 +1692,7 @@ Result<bool> CatalogManager::StartRunningInitDbIfNeeded(const LeaderEpoch& epoch
     // We assume pg_proc table means initdb is done.
     // We do NOT handle the case when initdb was terminated mid-run (neither here nor in
     // MakeYsqlSysCatalogTablesTransactional).
-    RETURN_NOT_OK(ysql_catalog_config_.SetInitDbDone(Status::OK(), epoch));
+    RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->SetInitDbDone( epoch));
     return false;
   }
 
@@ -3219,37 +3217,49 @@ Status CatalogManager::DdlLog(
   return sys_catalog_->FetchDdlLog(resp->mutable_entries());
 }
 
-Status CatalogManager::StartYsqlMajorVersionUpgradeInitdb(
-    const StartYsqlMajorVersionUpgradeInitdbRequestPB* req,
-    StartYsqlMajorVersionUpgradeInitdbResponsePB* resp,
+Status CatalogManager::StartYsqlMajorCatalogUpgrade(
+    const StartYsqlMajorCatalogUpgradeRequestPB* req, StartYsqlMajorCatalogUpgradeResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  LOG(INFO) << "Running initdb from RPC call";
-
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartYsqlMajorVersionUpgrade(epoch));
-
-  LOG(INFO) << "Successfully started ysql major upgrade";
+  LOG(INFO) << "Running ysql major upgrade";
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartYsqlMajorCatalogUpgrade(epoch));
 
   return Status::OK();
 }
 
-Status CatalogManager::IsYsqlMajorVersionUpgradeInitdbDone(
-    const IsYsqlMajorVersionUpgradeInitdbDoneRequestPB* req,
-    IsYsqlMajorVersionUpgradeInitdbDoneResponsePB* resp, rpc::RpcContext* rpc) {
-  LOG(INFO) << "Checking if ysql major version upgrade initdb is done";
-  ysql_catalog_config_.IsYsqlMajorVersionUpgradeInitdbDone(*resp);
+Status CatalogManager::IsYsqlMajorCatalogUpgradeDone(
+    const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
+    IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc) {
+  LOG(INFO) << "Checking if ysql major catalog upgrade is done";
+  auto is_operation_done = ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeDone();
+  if (is_operation_done.done()) {
+    resp->set_done(true);
+    if (!is_operation_done.status().ok()) {
+      return is_operation_done.status();
+    }
+  } else {
+    resp->set_done(false);
+  }
   return Status::OK();
 }
 
+Status CatalogManager::FinalizeYsqlMajorCatalogUpgrade(
+    const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
+    FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG(INFO) << "Finalizing ysql major catalog upgrade";
+  return ysql_initdb_and_major_upgrade_helper_->FinalizeYsqlMajorCatalogUpgrade(epoch);
+}
+
 // Note that this function should be able to be called any number of times while in upgrade mode.
-Status CatalogManager::RollbackYsqlMajorVersionUpgrade(
-    const RollbackYsqlMajorVersionUpgradeRequestPB* req,
-    RollbackYsqlMajorVersionUpgradeResponsePB* resp,
-    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  LOG(INFO) << "YSQL major version upgrade rollback initiated";
+Status CatalogManager::RollbackYsqlMajorCatalogVersion(
+    const RollbackYsqlMajorCatalogVersionRequestPB* req,
+    RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG(INFO) << "YSQL major catalog upgrade rollback initiated";
 
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->RollbackYsqlMajorVersionUpgrade(epoch));
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->RollbackYsqlMajorCatalogVersion(epoch));
 
-  LOG(INFO) << "YSQL major version upgrade rollback completed";
+  LOG(INFO) << "YSQL major catalog upgrade rollback completed";
   return Status::OK();
 }
 
@@ -3695,7 +3705,7 @@ Status PrintTableInfoForYsqlMajorVersionUpgrade(const scoped_refptr<TableInfo>&
   Schema existing_schema;
   RETURN_NOT_OK(table->GetSchema(&existing_schema));
   if (!request_schema.Equals(existing_schema)) {
-    // During a ysql major version upgrade, with columns that have been dropped, the master's Schema
+    // During a ysql major catalog upgrade, with columns that have been dropped, the master's Schema
     // object doesn't keep a record. However, PostgreSQL does. To restore ordering properly,
     // pg_restore sends a dummy value for each dropped column in the CreateTable request (see
     // comments about dropped columns in dumpTableSchema in pg_dump.c). We ignore the dummy value
@@ -3707,12 +3717,12 @@ Status PrintTableInfoForYsqlMajorVersionUpgrade(const scoped_refptr<TableInfo>&
     // Here we log the existing and request schemas for debugging purposes.
     SchemaPB existing_schema_pb;
     SchemaToPB(existing_schema, &existing_schema_pb);
-    LOG(INFO) << "During ysql major version upgrade, CreateTable request schema: "
+    LOG(INFO) << "During ysql major catalog upgrade, CreateTable request schema: "
               << request_schema_pb.DebugString()
               << " does not equal existing schema: " << existing_schema_pb.DebugString();
   }
   LOG(INFO) << "Table already exists with id " << table->id()
-            << " during ysql major version upgrade, returning early from CreateTable";
+            << " during ysql major catalog upgrade, returning early from CreateTable";
   return Status::OK();
 }
 
@@ -3784,16 +3794,17 @@ Status CatalogManager::CreateTable(const CreateTableRequestPB* orig_req,
   TRACE("Looking up namespace");
   auto ns = VERIFY_RESULT(FindNamespace(orig_req->namespace_()));
 
-  // If we're doing a ysql major version upgrade, then for a user table, we expect it to already
+  // If we're doing a ysql major catalog upgrade, then for a user table, we expect it to already
   // exist. We will wire the PG15 catalog to it. For a PG catalog table, we expect it to be creating
   // the new version's PG catalog, and so the table must not already exist.
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     LockGuard lock(mutex_);
     auto ns_lock = ns->LockForRead();
     TRACE("Acquired catalog manager lock");
 
-    RSTATUS_DCHECK_EQ(orig_req->table_type(), PGSQL_TABLE_TYPE, IllegalState,
-                      "Creating non-PGSQL table during a ysql major version upgrade");
+    RSTATUS_DCHECK_EQ(
+        orig_req->table_type(), PGSQL_TABLE_TYPE, IllegalState,
+        "Creating non-PGSQL table during a ysql major catalog upgrade");
     scoped_refptr<TableInfo> table = tables_->FindTableOrNull(orig_req->table_id());
     if (table != nullptr && !table->is_deleted()) {
       RSTATUS_DCHECK(!is_pg_catalog_table, IllegalState,
@@ -3803,8 +3814,9 @@ Status CatalogManager::CreateTable(const CreateTableRequestPB* orig_req,
       resp->set_table_id(table->id());
       return Status::OK();
     }
-    RSTATUS_DCHECK(is_pg_catalog_table, IllegalState,
-                   "Trying to create a new user table during a ysql major version upgrade");
+    RSTATUS_DCHECK(
+        is_pg_catalog_table, IllegalState,
+        "Trying to create a new user table during a ysql major catalog upgrade");
   }
 
   RETURN_NOT_OK(CreateGlobalTransactionStatusTableIfNeededForNewTable(*orig_req, rpc, epoch));
@@ -5901,9 +5913,10 @@ Status CatalogManager::BackfillIndex(
     BackfillIndexResponsePB* resp,
     rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
-  // We don't expect to be called for index backfill during a ysql major version upgrade.
-  RSTATUS_DCHECK(!FLAGS_TEST_online_pg11_to_pg15_upgrade, InternalError,
-                 "Attempting to backfill index during ysql major version upgrade");
+  // We don't expect to be called for index backfill during a ysql major catalog upgrade.
+  RSTATUS_DCHECK(
+      !IsYsqlMajorCatalogUpgradeInProgress(), InternalError,
+      "Attempting to backfill index during ysql major catalog upgrade");
   const TableIdentifierPB& index_table_identifier = req->index_identifier();
 
   scoped_refptr<TableInfo> index_table = VERIFY_RESULT(FindTable(index_table_identifier));
@@ -7162,16 +7175,16 @@ Status ApplyAlterSteps(server::Clock* clock,
 // master's schema, and the columns being dropped were dropped previously in PG11. The PG restore
 // process created the table with a dummy column in this column's place, but we returned early from
 // CreateTable, whose existing schema doesn't have the dropped column.
-// For use only during a ysql major version upgrade.
+// For use only during a ysql major catalog upgrade.
 Status VerifyDroppedColumnsForUpgrade(
     const Schema& schema,
     const google::protobuf::RepeatedPtrField<AlterTableRequestPB::Step>& steps) {
   for (const auto& step : steps) {
     const string& col_name = step.drop_column().name();
     if (step.type() != AlterTableRequestPB::DROP_COLUMN) {
-      return STATUS_FORMAT(InvalidArgument,
-                           "Invalid alter table type $0 during ysql major version upgrade",
-                           AlterTableRequestPB::StepType_Name(step.type()));
+      return STATUS_FORMAT(
+          InvalidArgument, "Invalid alter table type $0 during ysql major catalog upgrade",
+          AlterTableRequestPB::StepType_Name(step.type()));
     }
 
     if (schema.find_column(col_name) != Schema::kColumnNotFound) {
@@ -7194,7 +7207,7 @@ Status VerifyDroppedColumnsForUpgrade(
                            "major version upgrade", col_name);
     }
     LOG(INFO) << "Ignoring missing column '" << col_name
-              << "' during ALTER TABLE DROP COLUMN in a ysql major version upgrade";
+              << "' during ALTER TABLE DROP COLUMN in a ysql major catalog upgrade";
   }
 
   return Status::OK();
@@ -7209,9 +7222,9 @@ Status CatalogManager::AlterTable(const AlterTableRequestPB* req,
   LOG_WITH_PREFIX(INFO) << "Servicing " << __func__ << " request from " << RequestorString(rpc)
                         << ": " << req->ShortDebugString();
 
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     // Alter table commands done during the upgrade are catalog changes only.
-    LOG(INFO) << "Ignoring alter table request during ysql major version upgrade";
+    LOG(INFO) << "Ignoring alter table request during ysql major catalog upgrade";
     return Status::OK();
   }
 
@@ -7305,14 +7318,14 @@ Status CatalogManager::AlterTable(const AlterTableRequestPB* req,
   string previous_table_name = l->pb.name();
   ColumnId next_col_id = ColumnId(l->pb.next_column_id());
   if (req->alter_schema_steps_size() || req->has_alter_properties() || req->has_pgschema_name()) {
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-      // In a ysql major version upgrade, to ensure the new version's PG catalog is semantically
+    if (IsYsqlMajorCatalogUpgradeInProgress()) {
+      // In a ysql major catalog upgrade, to ensure the new version's PG catalog is semantically
       // identical to the old version's catalog, pg_restore goes through the motions of creating a
       // table with the dropped columns and then dropping them. However, the catalog manager
       // maintains its own schema state that's invariant across ysql major versions, and from the
       // original drop column request, it has already deleted dropped columns from its own
       // representation of the schema. Since we don't need to make any further changes to the
-      // catalog manager's schema during the pg_restore process, in ysql major version upgrade mode,
+      // catalog manager's schema during the pg_restore process, in ysql major catalog upgrade mode,
       // we simply verify the alter table command and catalog manager state are as expected, and
       // return early.
       return VerifyDroppedColumnsForUpgrade(previous_schema, req->alter_schema_steps());
@@ -8433,11 +8446,13 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
 
     // Validate the user request.
 
-    auto check_ns_errors = [req, resp, db_type](const scoped_refptr<NamespaceInfo>& ns,
-                                                bool by_id) -> Status {
+    const bool is_ysql_major_upgrade_in_progress = IsYsqlMajorCatalogUpgradeInProgress();
+
+    auto check_ns_errors = [req, resp, db_type, is_ysql_major_upgrade_in_progress](
+                               const scoped_refptr<NamespaceInfo>& ns, bool by_id) -> Status {
       Status return_status;
-      if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-        // During a ysql major version upgrade, each system namespace (template1, template0,
+      if (is_ysql_major_upgrade_in_progress) {
+        // During a ysql major catalog upgrade, each system namespace (template1, template0,
         // postgres, yugabyte, and system_platform) is "created" twice: once by initdb, and then
         // once again after a DROP DATABASE that's part of upstream Postgres's dump and restore
         // process. In both cases, the PG11 version of the namespace must already exist, and we re-
@@ -8456,15 +8471,17 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
           } else {
             context = "Namespace is unexpectedly missing from the namespace names mapper";
           }
-          return_status = STATUS(IllegalState,
-                                 StrCat(context, " during a ysql major version upgrade"));
-          return SetupError(resp->mutable_error(), MasterErrorPB::NAMESPACE_NOT_FOUND,
-                            return_status);
+          return_status =
+              STATUS(IllegalState, StrCat(context, " during a ysql major catalog upgrade"));
+          return SetupError(
+              resp->mutable_error(), MasterErrorPB::NAMESPACE_NOT_FOUND, return_status);
         }
-        RSTATUS_DCHECK_EQ(ns->name(), req->name(), InternalError,
-                          Format("Namespace created during a ysql major version upgrade had $0 "
-                                 "that matched a different namespace $1",
-                                 by_id ? "an ID" : "a name", by_id ? "name" : "ID"));
+        RSTATUS_DCHECK_EQ(
+            ns->name(), req->name(), InternalError,
+            Format(
+                "Namespace created during a ysql major catalog upgrade had $0 "
+                "that matched a different namespace $1",
+                by_id ? "an ID" : "a name", by_id ? "name" : "ID"));
       } else if (ns != nullptr) {
         // If this is the by-id case, and PG OID collision happens, use the PG error code:
         // YB_PG_DUPLICATE_DATABASE to signal PG backend to retry CREATE DATABASE using the next
@@ -8474,20 +8491,20 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
         auto pg_createdb_oid_collision_errcode =
             PgsqlError(YBPgErrorCode::YB_PG_DUPLICATE_DATABASE);
         if (by_id) {
-          return_status = STATUS(AlreadyPresent,
-                                 Format("Keyspace with id '$0' already exists",
-                                        req->namespace_id()),
-                                 Slice(),
-                                 db_type == YQL_DATABASE_PGSQL
-                                     ? &pg_createdb_oid_collision_errcode : nullptr);
+          return_status = STATUS(
+              AlreadyPresent, Format("Keyspace with id '$0' already exists", req->namespace_id()),
+              Slice(),
+              db_type == YQL_DATABASE_PGSQL ? &pg_createdb_oid_collision_errcode : nullptr);
         } else {
-          return_status = STATUS_SUBSTITUTE(AlreadyPresent, "Keyspace '$0' already exists",
-                                            req->name());
+          return_status =
+              STATUS_SUBSTITUTE(AlreadyPresent, "Keyspace '$0' already exists", req->name());
         }
-        LOG(WARNING) << "Found keyspace: " << ns->id() << ". Failed creating keyspace with error: "
-                     << return_status.ToString() << " Request:\n" << req->DebugString();
-        return SetupError(resp->mutable_error(), MasterErrorPB::NAMESPACE_ALREADY_PRESENT,
-                          return_status);
+        LOG(WARNING) << "Found keyspace: " << ns->id()
+                     << ". Failed creating keyspace with error: " << return_status.ToString()
+                     << " Request:\n"
+                     << req->DebugString();
+        return SetupError(
+            resp->mutable_error(), MasterErrorPB::NAMESPACE_ALREADY_PRESENT, return_status);
       }
       return Status::OK();
     };
@@ -8507,9 +8524,10 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
 
     // Create unique id for this new namespace, unless it already exists in the online PG11->PG15
     // upgrade case.
-    if (!FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+    if (!IsYsqlMajorCatalogUpgradeInProgress()) {
       NamespaceId new_id = !req->namespace_id().empty()
-          ? req->namespace_id() : GenerateIdUnlocked(SysRowEntryType::NAMESPACE);
+                               ? req->namespace_id()
+                               : GenerateIdUnlocked(SysRowEntryType::NAMESPACE);
       ns = new NamespaceInfo(new_id, tasks_tracker_);
     }
     ns_l = ns->LockForWrite();
@@ -8552,7 +8570,7 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
           // So in case #2, we must accept only PG15 catalog tables.
           const auto& table_id = table->id();
           if (IsPgsqlId(table_id) && CHECK_RESULT(GetPgsqlDatabaseOid(table_id)) == *source_oid) {
-            if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+            if (IsYsqlMajorCatalogUpgradeInProgress()) {
               if (!IsPg15CatalogId(table_id)) {
                 continue;
               }
@@ -8750,7 +8768,7 @@ void CatalogManager::ProcessPendingNamespace(
     if (status.ok()) return;
     TRACE("Handling failed keyspace creation");
     // Do not set on-disk state here. The loader treats the PREPARING state as FAILED.
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+    if (IsYsqlMajorCatalogUpgradeInProgress()) {
       metadata.set_ysql_next_major_version_state(SysNamespaceEntryPB::NEXT_VER_FAILED);
     } else {
       metadata.set_state(SysNamespaceEntryPB::FAILED);
@@ -8956,8 +8974,8 @@ Status CatalogManager::DoDeleteNamespace(const DeleteNamespaceRequestPB* req,
   {
     // Don't allow deletion if the namespace is in a transient state.
     auto cur_state = ns->state();
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-      // Note that during a ysql major version upgrade, deleting a namespace is only done by the
+    if (IsYsqlMajorCatalogUpgradeInProgress()) {
+      // Note that during a ysql major catalog upgrade, deleting a namespace is only done by the
       // upgrade process, and only "deletes" the new major version's namespace. In Yugabyte, we
       // track the deleted state, and delete the new major version's catalog tables, without
       // deleting the namespace itself, or touching the old major version's catalog tables or any
@@ -8967,8 +8985,8 @@ Status CatalogManager::DoDeleteNamespace(const DeleteNamespaceRequestPB* req,
                     "state of the namespace isn't RUNNING. Current state is $0",
                     SysNamespaceEntryPB::State_Name(cur_state));
       // Note that if the ysql next major version state enters state FAILED, we would expect the
-      // user to roll back (deleting all signs of the new ysql major version) before trying
-      // another ysql major version upgrade.
+      // user to roll back (deleting all signs of the new ysql major catalog) before trying
+      // another ysql major catalog upgrade.
       auto cur_ysql_next_major_version_state = ns->ysql_next_major_version_state();
       SCHECK_FORMAT(cur_ysql_next_major_version_state == SysNamespaceEntryPB::NEXT_VER_RUNNING,
                     IllegalState,
@@ -8976,8 +8994,8 @@ Status CatalogManager::DoDeleteNamespace(const DeleteNamespaceRequestPB* req,
                     "state isn't RUNNING. Current upgrade state is $0",
                     SysNamespaceEntryPB::YsqlNextMajorVersionState_Name(
                         cur_ysql_next_major_version_state));
-    } else if (cur_state != SysNamespaceEntryPB::RUNNING &&
-               cur_state != SysNamespaceEntryPB::FAILED) {
+    } else if (
+        cur_state != SysNamespaceEntryPB::RUNNING && cur_state != SysNamespaceEntryPB::FAILED) {
       if (cur_state == SysNamespaceEntryPB::DELETED) {
         return STATUS(NotFound, "Keyspace already deleted", ns->name(),
                       MasterError(MasterErrorPB::NAMESPACE_NOT_FOUND));
@@ -9117,7 +9135,7 @@ Status CatalogManager::DeleteYsqlDatabase(const DeleteNamespaceRequestPB* req,
   TRACE("Locking database");
   auto l = database->LockForWrite();
   SysNamespaceEntryPB& metadata = database->mutable_metadata()->mutable_dirty()->pb;
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     if (metadata.state() != SysNamespaceEntryPB::RUNNING) {
       return STATUS_EC_FORMAT(IllegalState, MasterError(MasterErrorPB::INTERNAL_ERROR),
                               "Keyspace ($0) has invalid state ($1), aborting delete",
@@ -9129,7 +9147,8 @@ Status CatalogManager::DeleteYsqlDatabase(const DeleteNamespaceRequestPB* req,
                               "aborting delete",
                               database->name(), metadata.ysql_next_major_version_state());
     }
-  } else if (metadata.state() != SysNamespaceEntryPB::RUNNING &&
+  } else if (
+      metadata.state() != SysNamespaceEntryPB::RUNNING &&
       metadata.state() != SysNamespaceEntryPB::FAILED) {
     return SetupError(
         resp->mutable_error(), MasterErrorPB::INTERNAL_ERROR,
@@ -9137,8 +9156,8 @@ Status CatalogManager::DeleteYsqlDatabase(const DeleteNamespaceRequestPB* req,
             IllegalState, "Keyspace ($0) has invalid state ($1), aborting delete", database->name(),
             metadata.state()));
   }
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-    // During a ysql major version upgrade, the upstream Postgres mechanism drops and re-creates
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
+    // During a ysql major catalog upgrade, the upstream Postgres mechanism drops and re-creates
     // system namespaces. Therefore, we keep a separate state machine for the status of the new
     // major version's namespace. It starts at RUNNING when called from initdb, and then is later
     // "deleted" and then "re-created" by the upgrade process.
@@ -9157,6 +9176,8 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
     scoped_refptr<NamespaceInfo> database, const LeaderEpoch& epoch) {
   TEST_PAUSE_IF_FLAG(TEST_hang_on_namespace_transition);
 
+  const auto is_ysql_major_upgrade = IsYsqlMajorCatalogUpgradeInProgress();
+
   // Lock database before removing content.
   TRACE("Locking database");
   auto l = database->LockForWrite();
@@ -9172,7 +9193,7 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
     }
   }
 
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (is_ysql_major_upgrade) {
     if (metadata.state() != SysNamespaceEntryPB::RUNNING) {
       LOG(DFATAL) << "Namespace (" << database->name() << ") has invalid state "
                   << SysNamespaceEntryPB::State_Name(metadata.state());
@@ -9191,16 +9212,15 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
     return;
   }
 
-  // Delete all tables in the database. If we're in a ysql major version upgrade, this will delete
+  // Delete all tables in the database. If we're in a ysql major catalog upgrade, this will delete
   // only the new version's tables.
   TRACE("Delete all tables in YSQL database");
-  Status s =
-      DeleteYsqlDBTables(database,
-                         /*is_for_ysql_major_upgrade=*/FLAGS_TEST_online_pg11_to_pg15_upgrade,
-                         epoch);
+  Status s = DeleteYsqlDBTables(
+      database,
+      /*is_for_ysql_major_rollback=*/false, epoch);
   WARN_NOT_OK(s, "DeleteYsqlDBTables failed");
   if (!s.ok()) {
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+    if (is_ysql_major_upgrade) {
       metadata.set_ysql_next_major_version_state(SysNamespaceEntryPB::NEXT_VER_FAILED);
     } else {
       // Move to FAILED so DeleteNamespace can be reissued by the user.
@@ -9211,7 +9231,7 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
   }
 
   // Once all user-facing data has been offlined, move the Namespace to DELETED state.
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (is_ysql_major_upgrade) {
     metadata.set_ysql_next_major_version_state(SysNamespaceEntryPB::NEXT_VER_DELETED);
   } else {
     metadata.set_state(SysNamespaceEntryPB::DELETED);
@@ -9220,7 +9240,7 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
   WARN_NOT_OK(s, "SysCatalog Update for Namespace");
   if (!s.ok()) {
     // Move to FAILED so DeleteNamespace can be reissued by the user.
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+    if (is_ysql_major_upgrade) {
       metadata.set_ysql_next_major_version_state(SysNamespaceEntryPB::NEXT_VER_FAILED);
     } else {
       metadata.set_state(SysNamespaceEntryPB::FAILED);
@@ -9231,8 +9251,8 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
   TRACE("Marked keyspace as deleted in sys-catalog");
 
   // During an upgrade, we skip the actual namespace deletion.
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-    LOG(INFO) << "We're in a ysql major version upgrade, skipping actual namespace deletion";
+  if (is_ysql_major_upgrade) {
+    LOG(INFO) << "We're in a ysql major catalog upgrade, skipping actual namespace deletion";
     l.Commit();
     return;
   }
@@ -9267,12 +9287,14 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
 
 // IMPORTANT: If modifying, consider updating DeleteTable(), the singular deletion API.
 Status CatalogManager::DeleteYsqlDBTables(
-    const scoped_refptr<NamespaceInfo>& database, const bool is_for_ysql_major_upgrade,
+    const scoped_refptr<NamespaceInfo>& database, const bool is_for_ysql_major_rollback,
     const LeaderEpoch& epoch) {
-  if (is_for_ysql_major_upgrade) {
-    RSTATUS_DCHECK(FLAGS_TEST_online_pg11_to_pg15_upgrade, IllegalState,
-                   "DeleteYsqlDBTables called with is_for_ysql_major_upgrade=true but "
-                   "FLAGS_TEST_online_pg11_to_pg15_upgrade is false");
+  const auto is_ysql_major_upgrade = IsYsqlMajorCatalogUpgradeInProgress();
+  if (is_for_ysql_major_rollback) {
+    RSTATUS_DCHECK(
+        is_ysql_major_upgrade, IllegalState,
+        "DeleteYsqlDBTables called with is_for_ysql_major_upgrade when not in a YSQL major catalog "
+        "upgrade");
   }
   TabletInfoPtr sys_tablet_info;
   vector<pair<scoped_refptr<TableInfo>, TableInfo::WriteLock>> tables_and_locks;
@@ -9287,14 +9309,14 @@ Status CatalogManager::DeleteYsqlDBTables(
 
     // Populate tables and sys_table_ids.
     for (const auto& table : tables_->GetAllTables()) {
-      // In ysql major version upgrade mode, there are two possibilities:
+      // In ysql major catalog upgrade mode, there are two possibilities:
       //  * To propagate database-level properties for certain databases in an upgrade, pg_upgrade
       //    drops those databases and recreates them. We pretend to do so, but only delete the PG15
       //    catalog tables, so the restore portion doesn't get confused.
       //  * The rollback deletes all PG15 catalog tables in order to prepare for the next upgrade
       //    attempt.
       // In both cases, we delete only the PG15 catalog tables.
-      if (FLAGS_TEST_online_pg11_to_pg15_upgrade && !IsPg15CatalogId(table->id())) {
+      if (is_ysql_major_upgrade && !IsPg15CatalogId(table->id())) {
         continue;
       }
       if (table->namespace_id() != database->id()) {
@@ -9306,15 +9328,15 @@ Status CatalogManager::DeleteYsqlDBTables(
         continue;
       }
 
-      // During the YSQL major version upgrade, don't drop shared tables for drop database (see the
+      // During the YSQL major catalog upgrade, don't drop shared tables for drop database (see the
       // comment at the beginning of the for loop), because such tables are technically global
       // tables, not contained in template1.
       //
-      // During YSQL major version upgrade rollback, shared PG15 tables hosted in the template1
+      // During YSQL major catalog upgrade rollback, shared PG15 tables hosted in the template1
       // namespace must be deleted so that we return to a clean state. This is safe because DDLs are
       // disabled and there are no PG15 tservers connected.
-      if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
-        if (l->pb.is_pg_shared_table() && is_for_ysql_major_upgrade) {
+      if (is_ysql_major_upgrade) {
+        if (l->pb.is_pg_shared_table() && !is_for_ysql_major_rollback) {
           continue;
         }
       } else {
@@ -9341,14 +9363,14 @@ Status CatalogManager::DeleteYsqlDBTables(
       }
     }
 
-    if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+    if (is_ysql_major_upgrade) {
       DCHECK(colocation_parents.empty());
     }
     tables_and_locks.insert(
         tables_and_locks.end(), std::make_move_iterator(colocation_parents.begin()),
         std::make_move_iterator(colocation_parents.end()));
   }
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (is_ysql_major_upgrade) {
     // Delete all rows from the system tables so that initdb after rollback doesn't have conflicts.
     TRACE("Deleting system table rows");
     vector<TableId> sys_table_ids_vec(sys_table_ids.begin(), sys_table_ids.end());
@@ -9435,7 +9457,7 @@ Status CatalogManager::IsDeleteNamespaceDone(const IsDeleteNamespaceDoneRequestP
   auto& metadata = l->pb;
 
   // First, check if this is a major ysql version upgrade.
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     if (metadata.ysql_next_major_version_state() == SysNamespaceEntryPB::NEXT_VER_DELETED) {
       resp->set_done(true);
       return Status::OK();
@@ -9916,10 +9938,18 @@ Result<uint64_t> CatalogManager::IncrementYsqlCatalogVersion() {
 }
 
 Status CatalogManager::IsInitDbDone(
-    const IsInitDbDoneRequestPB* req,
-    IsInitDbDoneResponsePB* resp) {
+    const IsInitDbDoneRequestPB* req, IsInitDbDoneResponsePB* resp) {
   resp->set_pg_proc_exists(pg_proc_exists_.load(std::memory_order_acquire));
-  ysql_catalog_config_.IsInitDbDone(*resp);
+  auto is_operation_done = ysql_initdb_and_major_upgrade_helper_->IsInitDbDone();
+
+  if (is_operation_done.done()) {
+    resp->set_done(true);
+    if (!is_operation_done.status().ok()) {
+      resp->set_initdb_error(is_operation_done.status().message().ToBuffer());
+    }
+  } else {
+    resp->set_done(false);
+  }
 
   return Status::OK();
 }
@@ -9945,7 +9975,7 @@ Status CatalogManager::GetYsqlDBCatalogVersion(uint32_t db_oid,
   // of upgrade mode, in which case we might need to do a one-time bump of the PG15
   // pg_yb_catalog_version number.
   TableId table_id;
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     table_id = kPgYbCatalogVersionTableIdPg11;
   } else {
     table_id = kPgYbCatalogVersionTableId;
@@ -9981,7 +10011,7 @@ Status CatalogManager::GetYsqlDBCatalogVersion(uint32_t db_oid,
 Status CatalogManager::GetYsqlAllDBCatalogVersionsImpl(DbOidToCatalogVersionMap* versions) {
   // See comment in GetYsqlDBCatalogVersion.
   TableId table_id;
-  if (FLAGS_TEST_online_pg11_to_pg15_upgrade) {
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
     table_id = kPgYbCatalogVersionTableIdPg11;
   } else {
     table_id = kPgYbCatalogVersionTableId;
@@ -12856,6 +12886,8 @@ void CatalogManager::SysCatalogLoaded(SysCatalogLoadingState&& state) {
         "Failed to read all DB catalog versions");
   }
 
+  ysql_initdb_and_major_upgrade_helper_->SysCatalogLoaded(state.epoch);
+
   master_->snapshot_coordinator().SysCatalogLoaded(state.epoch.leader_term);
 
   xcluster_manager_->SysCatalogLoaded(state.epoch);
@@ -13421,5 +13453,18 @@ Result<TSDescriptorPtr> CatalogManager::GetClosestLiveTserver(bool* local_ts) co
   return best_tserver;
 }
 
+bool CatalogManager::IsYsqlMajorCatalogUpgradeInProgress() const {
+  return ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeInProgress();
+}
+
+bool CatalogManager::SkipCatalogVersionChecks() {
+  // Only skip if we are leader and the major catalog upgrade is in progress.
+  SCOPED_LEADER_SHARED_LOCK(l, this);
+  if (l.IsInitializedAndIsLeader()) {
+    return IsYsqlMajorCatalogUpgradeInProgress();
+  }
+  return false;
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 572fab1bd2..803e53379f 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -664,9 +664,9 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   void DeleteYsqlDatabaseAsync(scoped_refptr<NamespaceInfo> database, const LeaderEpoch& epoch);
 
   // Delete all tables in YSQL database.
-  Status DeleteYsqlDBTables(const scoped_refptr<NamespaceInfo>& database,
-                            const bool is_for_ysql_major_upgrade,
-                            const LeaderEpoch& epoch);
+  Status DeleteYsqlDBTables(
+      const scoped_refptr<NamespaceInfo>& database, const bool is_for_ysql_major_rollback,
+      const LeaderEpoch& epoch);
 
   // List all the current namespaces.
   Status ListNamespaces(const ListNamespacesRequestPB* req,
@@ -1136,37 +1136,32 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   Status DdlLog(
       const DdlLogRequestPB* req, DdlLogResponsePB* resp, rpc::RpcContext* rpc);
 
-  // Initiates initdb for the new version of a major YSQL version upgrade. The system must be in
-  // upgrade mode (TEST_online_pg11_to_pg15_upgrade set to true) for this to work.
-  //
-  // Returns immediately. Call IsYsqlMajorVersionUpgradeInitdbDone to wait until it's finished.
-  //
-  // Can be called more than once, but not while it's already running. It internally performs a
-  // rollback before running initdb.
-  Status StartYsqlMajorVersionUpgradeInitdb(const StartYsqlMajorVersionUpgradeInitdbRequestPB* req,
-                                            StartYsqlMajorVersionUpgradeInitdbResponsePB* resp,
-                                            rpc::RpcContext* rpc, const LeaderEpoch& epoch);
-
-  // Checks if initdb has been completed for a YSQL major version upgrade.
-  Status IsYsqlMajorVersionUpgradeInitdbDone(
-      const IsYsqlMajorVersionUpgradeInitdbDoneRequestPB* req,
-      IsYsqlMajorVersionUpgradeInitdbDoneResponsePB* resp, rpc::RpcContext* rpc);
-
-  // Rolls back an in-progress major YSQL version upgrade. Deletes all of the new YSQL version's
-  // catalog tables, and resets all upgrade-related state to initial values. Blocks until the
-  // rollback is finished or fails. The system must have been in upgrade mode
-  // (TEST_online_pg11_to_pg15_upgrade set to true), with no DDLs performed, since the beginning of
-  // the upgrade for this to work.
-  //
-  // Takes a long time to run. Set a timeout of at least 5 minutes when calling.
-  //
-  // Can be called more than once, but not at the same time.
-  //
-  // After the rollback successfully completes, it's safe to restart the masters on the old major
-  // YSQL version.
-  Status RollbackYsqlMajorVersionUpgrade(const RollbackYsqlMajorVersionUpgradeRequestPB* req,
-                                         RollbackYsqlMajorVersionUpgradeResponsePB* resp,
-                                         rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+  // Initiates ysql major catalog upgrade which involves global initdb, pg_upgrade, and catalog
+  // version fixups.
+  // IsYsqlMajorCatalogUpgradeDone must be called to track the completion status of the
+  // operation.
+  Status StartYsqlMajorCatalogUpgrade(
+      const StartYsqlMajorCatalogUpgradeRequestPB* req,
+      StartYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+
+  // Checks if ysql major catalog upgrade has completed.
+  Status IsYsqlMajorCatalogUpgradeDone(
+      const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
+      IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc);
+
+  Status FinalizeYsqlMajorCatalogUpgrade(
+      const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
+      FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
+
+  // Rolls back the major YSQL catalog to the previous version. Deletes all of the new YSQL
+  // version's catalog tables, and resets all upgrade-related state to initial values. Blocks until
+  // the rollback is finished or fails.
+  // Takes a long time to run. Use a timeout of at least 5 minutes when calling.
+  Status RollbackYsqlMajorCatalogVersion(
+      const RollbackYsqlMajorCatalogVersionRequestPB* req,
+      RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
 
   // Test wrapper around protected DoSplitTablet method.
   Status TEST_SplitTablet(
@@ -1690,6 +1685,7 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const CreateSnapshotRequestPB& req, CreateSnapshotResponsePB* resp, CoarseTimePoint deadline);
 
   YsqlCatalogConfig& GetYsqlCatalogConfig() { return ysql_catalog_config_; }
+  const YsqlCatalogConfig& GetYsqlCatalogConfig() const { return ysql_catalog_config_; }
 
   InitialSysCatalogSnapshotWriter& AllocateAndGetInitialSysCatalogSnapshotWriter();
 
@@ -2980,6 +2976,10 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       bool is_colocated_via_database, const NamespaceId& namespace_id,
       const NamespaceName& namespace_name, const TableInfoPtr& indexed_table) REQUIRES(mutex_);
 
+  bool IsYsqlMajorCatalogUpgradeInProgress() const;
+
+  bool SkipCatalogVersionChecks() override;
+
   // Should be bumped up when tablet locations are changed.
   std::atomic<uintptr_t> tablet_locations_version_{0};
 
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index c2524daf24..c82bcc4dd5 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -345,6 +345,8 @@ class CatalogManagerIf {
 
   virtual Result<TSDescriptorPtr> GetClosestLiveTserver(bool* local_ts = nullptr) const = 0;
 
+  virtual bool SkipCatalogVersionChecks() = 0;
+
   virtual ~CatalogManagerIf() = default;
 };
 
diff --git a/src/yb/master/master_admin.proto b/src/yb/master/master_admin.proto
index 15e1ac715a..093c313698 100644
--- a/src/yb/master/master_admin.proto
+++ b/src/yb/master/master_admin.proto
@@ -177,26 +177,28 @@ message DdlLogResponsePB {
   repeated DdlLogEntryPB entries = 2;
 }
 
-message StartYsqlMajorVersionUpgradeInitdbRequestPB {
-}
+message StartYsqlMajorCatalogUpgradeRequestPB {}
 
-message StartYsqlMajorVersionUpgradeInitdbResponsePB {
+message StartYsqlMajorCatalogUpgradeResponsePB {
   optional MasterErrorPB error = 1;
 }
 
-message IsYsqlMajorVersionUpgradeInitdbDoneRequestPB {
-}
+message IsYsqlMajorCatalogUpgradeDoneRequestPB {}
 
-message IsYsqlMajorVersionUpgradeInitdbDoneResponsePB {
+message IsYsqlMajorCatalogUpgradeDoneResponsePB {
   optional MasterErrorPB error = 1;
   optional bool done = 2;
-  optional MasterErrorPB initdb_error = 3;
 }
 
-message RollbackYsqlMajorVersionUpgradeRequestPB {
+message FinalizeYsqlMajorCatalogUpgradeRequestPB {}
+
+message FinalizeYsqlMajorCatalogUpgradeResponsePB {
+  optional MasterErrorPB error = 1;
 }
 
-message RollbackYsqlMajorVersionUpgradeResponsePB {
+message RollbackYsqlMajorCatalogVersionRequestPB {}
+
+message RollbackYsqlMajorCatalogVersionResponsePB {
   optional MasterErrorPB error = 1;
 }
 
@@ -325,12 +327,14 @@ service MasterAdmin {
 
   rpc DdlLog(DdlLogRequestPB) returns (DdlLogResponsePB);
 
-  rpc StartYsqlMajorVersionUpgradeInitdb(StartYsqlMajorVersionUpgradeInitdbRequestPB)
-      returns (StartYsqlMajorVersionUpgradeInitdbResponsePB);
-  rpc IsYsqlMajorVersionUpgradeInitdbDone(IsYsqlMajorVersionUpgradeInitdbDoneRequestPB)
-      returns (IsYsqlMajorVersionUpgradeInitdbDoneResponsePB);
-  rpc RollbackYsqlMajorVersionUpgrade(RollbackYsqlMajorVersionUpgradeRequestPB)
-      returns (RollbackYsqlMajorVersionUpgradeResponsePB);
+  rpc StartYsqlMajorCatalogUpgrade(StartYsqlMajorCatalogUpgradeRequestPB)
+      returns (StartYsqlMajorCatalogUpgradeResponsePB);
+  rpc IsYsqlMajorCatalogUpgradeDone(IsYsqlMajorCatalogUpgradeDoneRequestPB)
+      returns (IsYsqlMajorCatalogUpgradeDoneResponsePB);
+  rpc FinalizeYsqlMajorCatalogUpgrade(FinalizeYsqlMajorCatalogUpgradeRequestPB)
+      returns (FinalizeYsqlMajorCatalogUpgradeResponsePB);
+  rpc RollbackYsqlMajorCatalogVersion(RollbackYsqlMajorCatalogVersionRequestPB)
+      returns (RollbackYsqlMajorCatalogVersionResponsePB);
 
   rpc CheckIfPitrActive(CheckIfPitrActiveRequestPB)
       returns (CheckIfPitrActiveResponsePB);
diff --git a/src/yb/master/master_admin_service.cc b/src/yb/master/master_admin_service.cc
index 97a42d15f3..c5674cc554 100644
--- a/src/yb/master/master_admin_service.cc
+++ b/src/yb/master/master_admin_service.cc
@@ -78,9 +78,10 @@ class MasterAdminServiceImpl : public MasterServiceBase, public MasterAdminIf {
       (GetCompactionStatus)
       (CreateTransactionStatusTable)
       (DdlLog)
-      (StartYsqlMajorVersionUpgradeInitdb)
-      (IsYsqlMajorVersionUpgradeInitdbDone)
-      (RollbackYsqlMajorVersionUpgrade)
+      (StartYsqlMajorCatalogUpgrade)
+      (IsYsqlMajorCatalogUpgradeDone)
+      (FinalizeYsqlMajorCatalogUpgrade)
+      (RollbackYsqlMajorCatalogVersion)
       (DeleteNotServingTablet)
       (FlushSysCatalog)
       (SplitTablet)
diff --git a/src/yb/master/master_tserver.cc b/src/yb/master/master_tserver.cc
index c2e62a20f4..e059c7d9c6 100644
--- a/src/yb/master/master_tserver.cc
+++ b/src/yb/master/master_tserver.cc
@@ -229,5 +229,9 @@ Result<pgwrapper::PGConn> MasterTabletServer::CreateInternalPGConn(
   return STATUS_FORMAT(InternalError, "Unexpected call of CreateInternalPGConn()");
 }
 
+bool MasterTabletServer::SkipCatalogVersionChecks() {
+  return master_->catalog_manager()->SkipCatalogVersionChecks();
+}
+
 } // namespace master
 } // namespace yb
diff --git a/src/yb/master/master_tserver.h b/src/yb/master/master_tserver.h
index 546b6247dd..5a1f9d9ac6 100644
--- a/src/yb/master/master_tserver.h
+++ b/src/yb/master/master_tserver.h
@@ -19,8 +19,6 @@
 #include "yb/tserver/tablet_server_interface.h"
 #include "yb/tserver/ts_local_lock_manager.h"
 
-DECLARE_bool(TEST_online_pg11_to_pg15_upgrade);
-
 namespace yb {
 namespace master {
 
@@ -111,7 +109,7 @@ class MasterTabletServer : public tserver::TabletServerIf,
 
   virtual Result<std::vector<TserverMetricsInfoPB>> GetMetrics() const override;
 
-  bool IsInYsqlMajorUpgrade() override { return FLAGS_TEST_online_pg11_to_pg15_upgrade; }
+  bool SkipCatalogVersionChecks() override;
 
  private:
   Result<pgwrapper::PGConn> CreateInternalPGConn(
diff --git a/src/yb/master/sys_catalog-test.cc b/src/yb/master/sys_catalog-test.cc
index ad6a3a2a7d..81f8e12cf1 100644
--- a/src/yb/master/sys_catalog-test.cc
+++ b/src/yb/master/sys_catalog-test.cc
@@ -51,6 +51,7 @@
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/net/sockaddr.h"
 #include "yb/util/status.h"
+#include "yb/util/version_info.h"
 
 using namespace std::literals;
 
@@ -555,6 +556,10 @@ TEST_F(SysCatalogTest, TestSysCatalogSysConfigOperations) {
     auto& ysql_catalog_config_pb = *l.mutable_data()->pb.mutable_ysql_catalog_config();
     ysql_catalog_config_pb.set_version(0);
     ysql_catalog_config_pb.set_transactional_sys_catalog_enabled(true);
+    VersionInfoPB version_info;
+    VersionInfo::GetVersionInfoPB(&version_info);
+    ysql_catalog_config_pb.mutable_ysql_major_catalog_upgrade_info()->set_catalog_version(
+        version_info.ysql_major_version());
     l.Commit();
   }
   scoped_refptr<SysConfigInfo> transaction_tables_config =
diff --git a/src/yb/master/ysql/ysql_catalog_config.cc b/src/yb/master/ysql/ysql_catalog_config.cc
index 429f338db7..6432cd24b4 100644
--- a/src/yb/master/ysql/ysql_catalog_config.cc
+++ b/src/yb/master/ysql/ysql_catalog_config.cc
@@ -19,11 +19,28 @@
 #include "yb/master/sys_catalog.h"
 
 #include "yb/master/catalog_entity_info.h"
+#include "yb/util/version_info.pb.h"
+#include "yb/util/version_info.h"
+#include "yb/util/is_operation_done_result.h"
 
 DECLARE_bool(log_ysql_catalog_versions);
 
+DEFINE_test_flag(
+    string, fail_ysql_catalog_upgrade_state_transition_from, "",
+    "When set fail the transition to the provided state");
+
 namespace yb::master {
 
+namespace {
+
+uint32 GetMajorVersionOfCurrentBuild() {
+  VersionInfoPB version_info;
+  VersionInfo::GetVersionInfoPB(&version_info);
+  return version_info.ysql_major_version();
+}
+
+}  // namespace
+
 YsqlCatalogConfig::YsqlCatalogConfig(SysCatalogTable& sys_catalog) : sys_catalog_(sys_catalog) {}
 
 Status YsqlCatalogConfig::PrepareDefaultIfNeeded(int64_t term) {
@@ -34,15 +51,13 @@ Status YsqlCatalogConfig::PrepareDefaultIfNeeded(int64_t term) {
 
   SysYSQLCatalogConfigEntryPB ysql_catalog_config;
   ysql_catalog_config.set_version(0);
+  ysql_catalog_config.mutable_ysql_major_catalog_upgrade_info()->set_catalog_version(
+      GetMajorVersionOfCurrentBuild());
 
-  // Create in memory objects.
   config_ = new SysConfigInfo(kYsqlCatalogConfigType);
-
-  // Prepare write.
   auto l = config_->LockForWrite();
   *l.mutable_data()->pb.mutable_ysql_catalog_config() = std::move(ysql_catalog_config);
 
-  // Write to sys_catalog and in memory.
   RETURN_NOT_OK(sys_catalog_.Upsert(term, config_));
   l.Commit();
 
@@ -50,6 +65,20 @@ Status YsqlCatalogConfig::PrepareDefaultIfNeeded(int64_t term) {
 }
 
 void YsqlCatalogConfig::SetConfig(scoped_refptr<SysConfigInfo> config) {
+  {
+    auto l = config->LockForRead();
+    if (l->pb.ysql_catalog_config().has_ysql_major_catalog_upgrade_info()) {
+      const auto persisted_version =
+          l->pb.ysql_catalog_config().ysql_major_catalog_upgrade_info().catalog_version();
+      if (persisted_version > GetMajorVersionOfCurrentBuild()) {
+        LOG(FATAL) << "Persisted major version in YSQL catalog config is not supported. Restart "
+                      "the process in the correct version. Min required major version: "
+                   << persisted_version
+                   << ", Current version: " << VersionInfo::GetShortVersionString();
+      }
+    }
+  }
+
   std::lock_guard m_lock(mutex_);
   LOG_IF(WARNING, config_ != nullptr) << "Multiple Ysql Catalog configs found";
   config_ = std::move(config);
@@ -101,17 +130,15 @@ Result<uint64> YsqlCatalogConfig::IncrementVersion(const LeaderEpoch& epoch) {
   return new_version;
 }
 
-bool YsqlCatalogConfig::IsInitDbDone() const {
-  auto [l, pb] = LockForRead();
-  return pb.initdb_done();
-}
-
-void YsqlCatalogConfig::IsInitDbDone(IsInitDbDoneResponsePB& resp) const {
+IsOperationDoneResult YsqlCatalogConfig::IsInitDbDone() const {
   auto [l, pb] = LockForRead();
-  resp.set_done(pb.initdb_done());
+  if (!pb.initdb_done()) {
+    return IsOperationDoneResult::NotDone();
+  }
   if (pb.has_initdb_error() && !pb.initdb_error().empty()) {
-    resp.set_initdb_error(pb.initdb_error());
+    return IsOperationDoneResult::Done(STATUS(InternalError, pb.initdb_error()));
   }
+  return IsOperationDoneResult::Done();
 }
 
 Status YsqlCatalogConfig::SetInitDbDone(const Status& initdb_status, const LeaderEpoch& epoch) {
@@ -154,50 +181,114 @@ Status YsqlCatalogConfig::SetTransactionalSysCatalogEnabled(const LeaderEpoch& e
   return Status::OK();
 }
 
-void YsqlCatalogConfig::IsYsqlMajorVersionUpgradeInitdbDone(
-    IsYsqlMajorVersionUpgradeInitdbDoneResponsePB& resp) const {
+IsOperationDoneResult YsqlCatalogConfig::IsYsqlMajorCatalogUpgradeDone() const {
   auto [l, pb] = LockForRead();
-  resp.set_done(pb.ysql_major_upgrade_info().next_ver_initdb_done());
-  if (pb.ysql_major_upgrade_info().has_next_ver_initdb_error()) {
-    resp.mutable_initdb_error()->CopyFrom(pb.ysql_major_upgrade_info().next_ver_initdb_error());
+  if (!pb.has_ysql_major_catalog_upgrade_info()) {
+    return IsOperationDoneResult::Done();
   }
-}
 
-Status YsqlCatalogConfig::ResetNextVerInitdbStatus(const LeaderEpoch& epoch) {
-  SharedLock m_lock(mutex_);
-  auto [l, pb] = LockForWrite();
+  const auto state = pb.ysql_major_catalog_upgrade_info().state();
+  if (state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE ||
+      state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB ||
+      state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK) {
+    return IsOperationDoneResult::NotDone();
+  }
 
-  auto* ysql_major_upgrade_info = pb.mutable_ysql_major_upgrade_info();
-  ysql_major_upgrade_info->set_next_ver_initdb_done(false);
-  ysql_major_upgrade_info->clear_next_ver_initdb_error();
-  RETURN_NOT_OK(sys_catalog_.Upsert(epoch, config_));
-  l.Commit();
-  return Status::OK();
+  Status status;
+  if (pb.ysql_major_catalog_upgrade_info().has_previous_error()) {
+    status = StatusFromPB(pb.ysql_major_catalog_upgrade_info().previous_error());
+  }
+
+  return IsOperationDoneResult::Done(status);
 }
 
-Status YsqlCatalogConfig::SetNextVerInitdbDone(
-    const Status& upgrade_status, const LeaderEpoch& epoch) {
-  if (upgrade_status.ok()) {
-    LOG(INFO) << "Ysql major catalog upgrade completed successfully";
-  } else {
-    LOG(ERROR) << "Ysql major catalog upgrade failed: " << upgrade_status;
-  }
+YsqlMajorCatalogUpgradeInfoPB::State YsqlCatalogConfig::GetMajorCatalogUpgradeState() const {
+  auto [l, pb] = LockForRead();
+  return pb.ysql_major_catalog_upgrade_info().state();
+}
+
+const std::unordered_map<
+    YsqlMajorCatalogUpgradeInfoPB::State, std::unordered_set<YsqlMajorCatalogUpgradeInfoPB::State>>
+    kAllowedTransitions = {
+        {YsqlMajorCatalogUpgradeInfoPB::INVALID, {}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::DONE, {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::FAILED,
+         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB,
+         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
+          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
+         {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
+          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
+         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+};
+
+Status YsqlCatalogConfig::TransitionMajorCatalogUpgradeState(
+    const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
+    const Status& failed_status) {
+  DCHECK_EQ(kAllowedTransitions.size(), YsqlMajorCatalogUpgradeInfoPB::State_ARRAYSIZE);
+
+  const auto new_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(new_state);
+
+  RSTATUS_DCHECK_EQ(
+      failed_status.ok(), new_state != YsqlMajorCatalogUpgradeInfoPB::FAILED, IllegalState,
+      Format("Bad status must be set if and only if transitioning to FAILED state", failed_status));
 
   SharedLock m_lock(mutex_);
   auto [l, pb] = LockForWrite();
 
-  auto* ysql_major_upgrade_info = pb.mutable_ysql_major_upgrade_info();
-  ysql_major_upgrade_info->set_next_ver_initdb_done(true);
+  auto* ysql_major_catalog_upgrade_info = pb.mutable_ysql_major_catalog_upgrade_info();
+  const auto current_state = ysql_major_catalog_upgrade_info->state();
+  SCHECK_NE(
+      current_state, new_state, IllegalState,
+      Format("Major upgrade state already set to $0", new_state_str));
+
+  const auto current_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(current_state);
+
+  SCHECK_NE(
+      current_state_str, FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from, IllegalState,
+      "Failed due to FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from");
+
+  auto allowed_states_it = FindOrNull(kAllowedTransitions, current_state);
+  RSTATUS_DCHECK(allowed_states_it, IllegalState, Format("Invalid state $0", current_state_str));
+
+  SCHECK(
+      allowed_states_it->contains(new_state), IllegalState,
+      Format("Invalid state transition from $0 to $1", current_state_str, new_state_str));
+
+  if (current_state == YsqlMajorCatalogUpgradeInfoPB::MONITORING &&
+      new_state == YsqlMajorCatalogUpgradeInfoPB::DONE) {
+    ysql_major_catalog_upgrade_info->set_catalog_version(GetMajorVersionOfCurrentBuild());
+  } else if (current_state == YsqlMajorCatalogUpgradeInfoPB::DONE) {
+    const auto major_version = GetMajorVersionOfCurrentBuild();
+    SCHECK_GT(
+        major_version, ysql_major_catalog_upgrade_info->catalog_version(), IllegalState,
+        "Ysql Catalog is already on the current major version");
+  }
+
+  ysql_major_catalog_upgrade_info->set_state(new_state);
 
-  if (upgrade_status.ok()) {
-    ysql_major_upgrade_info->clear_next_ver_initdb_error();
+  if (!failed_status.ok()) {
+    StatusToPB(failed_status, ysql_major_catalog_upgrade_info->mutable_previous_error());
   } else {
-    ysql_major_upgrade_info->mutable_next_ver_initdb_error()->set_code(
-        MasterErrorPB::INTERNAL_ERROR);
-    StatusToPB(
-        upgrade_status, ysql_major_upgrade_info->mutable_next_ver_initdb_error()->mutable_status());
+    ysql_major_catalog_upgrade_info->clear_previous_error();
   }
 
+  LOG(INFO) << "Transitioned major upgrade state from " << current_state_str << " to "
+            << new_state_str;
+
   RETURN_NOT_OK(sys_catalog_.Upsert(epoch, config_));
   l.Commit();
   return Status::OK();
diff --git a/src/yb/master/ysql/ysql_catalog_config.h b/src/yb/master/ysql/ysql_catalog_config.h
index a2fefd3fce..7a924c8a26 100644
--- a/src/yb/master/ysql/ysql_catalog_config.h
+++ b/src/yb/master/ysql/ysql_catalog_config.h
@@ -20,10 +20,11 @@
 
 namespace yb {
 
+class IsOperationDoneResult;
+
 namespace master {
 
 class IsInitDbDoneResponsePB;
-class IsYsqlMajorVersionUpgradeInitdbDoneResponsePB;
 struct LeaderEpoch;
 struct PersistentSysConfigInfo;
 
@@ -41,19 +42,23 @@ class YsqlCatalogConfig {
   // Increments and return the new version.
   Result<uint64> IncrementVersion(const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
-  bool IsInitDbDone() const EXCLUDES(mutex_);
-  void IsInitDbDone(IsInitDbDoneResponsePB& resp) const EXCLUDES(mutex_);
+  IsOperationDoneResult IsInitDbDone() const EXCLUDES(mutex_);
 
   Status SetInitDbDone(const Status& initdb_status, const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
   bool IsTransactionalSysCatalogEnabled() const EXCLUDES(mutex_);
   Status SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
-  void IsYsqlMajorVersionUpgradeInitdbDone(
-      IsYsqlMajorVersionUpgradeInitdbDoneResponsePB& resp) const EXCLUDES(mutex_);
-  Status ResetNextVerInitdbStatus(const LeaderEpoch& epoch) EXCLUDES(mutex_);
-  Status SetNextVerInitdbDone(const Status& upgrade_status, const LeaderEpoch& epoch)
-      EXCLUDES(mutex_);
+  IsOperationDoneResult IsYsqlMajorCatalogUpgradeDone() const EXCLUDES(mutex_);
+
+  YsqlMajorCatalogUpgradeInfoPB::State GetMajorCatalogUpgradeState() const EXCLUDES(mutex_);
+
+  // Transition the ysql major catalog upgrade to a new state if allowed.
+  // failed_status must be set to a NonOk status if and only if transitioning to FAILED state.
+  // Check kAllowedTransitions for list of allowed transitions.
+  Status TransitionMajorCatalogUpgradeState(
+      const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
+      const Status& failed_status = Status::OK()) EXCLUDES(mutex_);
 
  private:
   std::pair<CowReadLock<PersistentSysConfigInfo>, const SysYSQLCatalogConfigEntryPB&> LockForRead()
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 49d770453a..6545b8ce63 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -20,6 +20,7 @@
 #include "yb/tablet/tablet_peer.h"
 
 #include "yb/util/async_util.h"
+#include "yb/util/is_operation_done_result.h"
 #include "yb/util/net/net_util.h"
 #include "yb/util/pg_util.h"
 #include "yb/util/scope_exit.h"
@@ -27,7 +28,6 @@
 
 #include "yb/yql/pgwrapper/pg_wrapper.h"
 
-DECLARE_bool(TEST_online_pg11_to_pg15_upgrade);
 DECLARE_string(tmp_dir);
 DECLARE_bool(master_join_existing_universe);
 DECLARE_string(rpc_bind_addresses);
@@ -51,6 +51,31 @@ YsqlCatalogConfig& YsqlInitDBAndMajorUpgradeHandler::GetYsqlCatalogConfig() {
   return catalog_manager_.GetYsqlCatalogConfig();
 }
 
+const YsqlCatalogConfig& YsqlInitDBAndMajorUpgradeHandler::GetYsqlCatalogConfig() const {
+  return catalog_manager_.GetYsqlCatalogConfig();
+}
+
+IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsInitDbDone() const {
+  return GetYsqlCatalogConfig().IsInitDbDone();
+}
+
+Status YsqlInitDBAndMajorUpgradeHandler::SetInitDbDone(const LeaderEpoch& epoch) {
+  return GetYsqlCatalogConfig().SetInitDbDone(Status::OK(), epoch);
+}
+
+void YsqlInitDBAndMajorUpgradeHandler::SysCatalogLoaded(const LeaderEpoch& epoch) {
+  // A new yb-master leader has started. If we were in the middle of the ysql major catalog upgrade
+  // (initdb, pg_upgrade, or rollback) then mark the major upgrade as failed. No action is taken if
+  // we are in the monitoring phase.
+  if (IsYsqlMajorCatalogUpgradeInProgress()) {
+    ERROR_NOT_OK(
+        GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+            YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch,
+            STATUS(InternalError, "yb-master restarted during ysql major catalog upgrade")),
+        "Failed to set major version upgrade state to FAILED");
+  }
+}
+
 Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const LeaderEpoch& epoch) {
   SCHECK(
       !FLAGS_master_join_existing_universe, IllegalState,
@@ -60,27 +85,33 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const Leade
   return RunOperationAsync([this, epoch]() { RunNewClusterGlobalInitDB(epoch); });
 }
 
-Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorVersionUpgrade(const LeaderEpoch& epoch) {
-  SCHECK(
-      FLAGS_TEST_online_pg11_to_pg15_upgrade, IllegalState,
-      "Must be in upgrade mode (FLAGS_TEST_online_pg11_to_pg15_upgrade)");
+Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
+  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+      YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB, epoch));
 
-  // Since StartYsqlMajorVersionUpgrade is idempotent, if run again we need to reset the
-  // pg15_initdb flags so that callers that check IsYsqlMajorVersionUpgradeInitdbDone won't get
-  // a false positive, while the new invocation goes through rollback and initdb.
-  RETURN_NOT_OK(GetYsqlCatalogConfig().ResetNextVerInitdbStatus(epoch));
+  auto status = RunOperationAsync([this, epoch]() { RunMajorVersionUpgrade(epoch); });
+  if (!status.ok()) {
+    ERROR_NOT_OK(
+        GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+            YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
+        "Failed to set major version upgrade state");
+  }
 
-  return RunOperationAsync([this, epoch]() { RunMajorVersionUpgrade(epoch); });
+  return status;
 }
 
-Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorVersionUpgrade(const LeaderEpoch& epoch) {
-  // Note that as part of the rollback, we're getting rid of the catalog cache table for pg15, so we
-  // have to be in a mode that ensures that we read from a valid catalog table. Also, for simplicity
-  // it's best for DDLs to be disabled.
-  SCHECK(
-      FLAGS_TEST_online_pg11_to_pg15_upgrade, IllegalState,
-      "Must be in upgrade mode (FLAGS_TEST_online_pg11_to_pg15_upgrade)");
+IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeDone() const {
+  return GetYsqlCatalogConfig().IsYsqlMajorCatalogUpgradeDone();
+}
+
+Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
+  return GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+      YsqlMajorCatalogUpgradeInfoPB::DONE, epoch);
+}
 
+Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch) {
+  // Since Rollback is synchronous, we can perform the state transitions inside the async function.
+  // It also ensures there are no inflight operations when the rollback state transition occurs.
   Synchronizer sync;
   auto cb = sync.AsStdStatusCallback();
 
@@ -94,12 +125,16 @@ Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorVersionUpgrade(const L
   return sync.Wait();
 }
 
+bool YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeInProgress() const {
+  return !IsYsqlMajorCatalogUpgradeDone().done();
+}
+
 Status YsqlInitDBAndMajorUpgradeHandler::RunOperationAsync(std::function<void()> func) {
   bool expected = false;
   if (!is_running_.compare_exchange_strong(expected, true)) {
     return STATUS(
         IllegalState,
-        "Global initdb or ysql major version upgrade rollback is already in progress");
+        "Global initdb or ysql major catalog upgrade/rollback is already in progress");
   }
 
   auto status = thread_pool_.SubmitFunc([this, func = std::move(func)]() mutable {
@@ -115,14 +150,15 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunOperationAsync(std::function<void()>
 }
 
 void YsqlInitDBAndMajorUpgradeHandler::RunNewClusterGlobalInitDB(const LeaderEpoch& epoch) {
-  auto status = InitDBAndSnapshotSysCatalog(/*db_name_to_oid_list=*/{}, epoch);
-  WARN_NOT_OK(
+  auto status =
+      InitDBAndSnapshotSysCatalog(/*db_name_to_oid_list=*/{}, /*is_major_upgrade=*/false, epoch);
+  ERROR_NOT_OK(
       GetYsqlCatalogConfig().SetInitDbDone(status, epoch),
       "Failed to set global initdb as finished in sys catalog");
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::InitDBAndSnapshotSysCatalog(
-    const DbNameToOidList& db_name_to_oid_list, const LeaderEpoch& epoch) {
+    const DbNameToOidList& db_name_to_oid_list, bool is_major_upgrade, const LeaderEpoch& epoch) {
   InitialSysCatalogSnapshotWriter* snapshot_writer = nullptr;
   if (FLAGS_create_initial_sys_catalog_snapshot) {
     snapshot_writer = &catalog_manager_.AllocateAndGetInitialSysCatalogSnapshotWriter();
@@ -133,7 +169,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::InitDBAndSnapshotSysCatalog(
       server::MasterAddressesToString(*master_opts.GetMasterAddresses());
 
   RETURN_NOT_OK(PgWrapper::InitDbForYSQL(
-      master_addresses_str, FLAGS_tmp_dir, master_.GetSharedMemoryFd(), db_name_to_oid_list));
+      master_addresses_str, FLAGS_tmp_dir, master_.GetSharedMemoryFd(), db_name_to_oid_list,
+      is_major_upgrade));
 
   if (!snapshot_writer) {
     return Status::OK();
@@ -148,14 +185,28 @@ Status YsqlInitDBAndMajorUpgradeHandler::InitDBAndSnapshotSysCatalog(
 
 void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch& epoch) {
   auto status = RunMajorVersionUpgradeImpl(epoch);
-  WARN_NOT_OK(
-      GetYsqlCatalogConfig().SetNextVerInitdbDone(status, epoch),
-      "Failed to run major version upgrade");
+  if (status.ok()) {
+    auto update_state_status = GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+        YsqlMajorCatalogUpgradeInfoPB::MONITORING, epoch);
+    if (update_state_status.ok()) {
+      LOG(INFO) << "Ysql major catalog upgrade completed successfully";
+    } else {
+      LOG(ERROR) << "Failed to set major version upgrade state: " << update_state_status;
+    }
+    return;
+  }
+
+  LOG(ERROR) << "Ysql major catalog upgrade failed: " << status;
+  ERROR_NOT_OK(
+      GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+          YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
+      "Failed to set major version upgrade state");
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgradeImpl(const LeaderEpoch& epoch) {
   RETURN_NOT_OK(RunMajorVersionCatalogUpgrade(epoch));
   RETURN_NOT_OK_PREPEND(UpdateCatalogVersions(epoch), "Failed to update catalog versions");
+
   return Status::OK();
 }
 
@@ -170,13 +221,13 @@ Status YsqlInitDBAndMajorUpgradeHandler::UpdateCatalogVersions(const LeaderEpoch
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionCatalogUpgrade(const LeaderEpoch& epoch) {
-  // This process is idempotent, so it needs to roll back the state before re-running. This is a
-  // no-op if this is the first time the upgrade is running.
-  RETURN_NOT_OK_PREPEND(RunRollbackMajorVersionUpgrade(epoch), "Rollback failed");
-
   auto db_name_to_oid_list = VERIFY_RESULT(GetDbNameToOidListForMajorUpgrade());
   RETURN_NOT_OK_PREPEND(
-      InitDBAndSnapshotSysCatalog(db_name_to_oid_list, epoch), "Failed to run initdb");
+      InitDBAndSnapshotSysCatalog(db_name_to_oid_list, /*is_major_upgrade=*/true, epoch),
+      "Failed to run initdb");
+
+  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+      YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE, epoch));
 
   RETURN_NOT_OK_PREPEND(PerformPgUpgrade(epoch), "Failed to run pg_upgrade");
 
@@ -251,6 +302,28 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RunRollbackMajorVersionUpgrade(const LeaderEpoch& epoch) {
+  if (GetYsqlCatalogConfig().GetMajorCatalogUpgradeState() == YsqlMajorCatalogUpgradeInfoPB::DONE) {
+    LOG_WITH_FUNC(INFO)
+        << "No inflight Ysql major catalog upgrade in progress. Nothing to rollback.";
+    return Status::OK();
+  }
+
+  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+      YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK, epoch));
+
+  auto status = RollbackMajorVersionCatalogImpl(epoch);
+  if (status.ok()) {
+    RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+        YsqlMajorCatalogUpgradeInfoPB::DONE, epoch));
+  } else {
+    RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+        YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status));
+  }
+
+  return status;
+}
+
+Status YsqlInitDBAndMajorUpgradeHandler::RollbackMajorVersionCatalogImpl(const LeaderEpoch& epoch) {
   std::vector<scoped_refptr<NamespaceInfo>> namespaces;
   {
     std::vector<scoped_refptr<NamespaceInfo>> all_namespaces;
@@ -268,14 +341,12 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunRollbackMajorVersionUpgrade(const Le
   }
 
   for (const auto& ns_info : namespaces) {
-    LOG(INFO) << "Deleting Ysql major version catalog tables for namespace " << ns_info->name();
-    RETURN_NOT_OK(catalog_manager_.DeleteYsqlDBTables(ns_info,
-                                                      /*is_for_ysql_major_upgrade=*/false,
-                                                      epoch));
+    LOG(INFO) << "Deleting ysql major catalog tables for namespace " << ns_info->name();
+    RETURN_NOT_OK(catalog_manager_.DeleteYsqlDBTables(
+        ns_info,
+        /*is_for_ysql_major_rollback=*/true, epoch));
   }
 
-  RETURN_NOT_OK(GetYsqlCatalogConfig().ResetNextVerInitdbStatus(epoch));
-
   // Reset state machines for all YSQL namespaces.
   {
     for (const auto& ns_info : namespaces) {
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
index 2160058648..46180c0fa8 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
@@ -19,6 +19,8 @@
 #include "yb/yql/pggate/ybc_pg_typedefs.h"
 
 namespace yb {
+
+class IsOperationDoneResult;
 class ThreadPool;
 
 namespace master {
@@ -27,8 +29,6 @@ class YsqlCatalogConfig;
 
 // Helper class to handle global initdb and major version upgrade for YSQL.
 // Only one operation can be run at a time.
-// TODO: Move IsDone functions from CatalogManager to this class after pg15-upgrade merges into
-// master.
 class YsqlInitDBAndMajorUpgradeHandler {
  public:
   YsqlInitDBAndMajorUpgradeHandler(
@@ -37,17 +37,31 @@ class YsqlInitDBAndMajorUpgradeHandler {
 
   ~YsqlInitDBAndMajorUpgradeHandler() = default;
 
+  IsOperationDoneResult IsInitDbDone() const;
+
+  Status SetInitDbDone(const LeaderEpoch& epoch);
+
+  IsOperationDoneResult IsCurrentVersionInitDbDone() const;
+
+  void SysCatalogLoaded(const LeaderEpoch& epoch);
+
   // Starts the global initdb procedure to create the initial universe level ysql sys catalog using
   // the initdb process.
   Status StartNewClusterGlobalInitDB(const LeaderEpoch& epoch);
 
-  // Starts the ysql major version upgrade procedure which will run a major version initdb, and run
+  // Starts the ysql major catalog upgrade procedure which will run a major version initdb, and run
   // pg_upgrade using a temporary major version postgres process.
-  Status StartYsqlMajorVersionUpgrade(const LeaderEpoch& epoch);
+  Status StartYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch);
+
+  IsOperationDoneResult IsYsqlMajorCatalogUpgradeDone() const;
+
+  Status FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch);
 
   // Rolls back the operations performed by major version upgrade procedure and return the cluster
   // to a clean state.
-  Status RollbackYsqlMajorVersionUpgrade(const LeaderEpoch& epoch);
+  Status RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch);
+
+  bool IsYsqlMajorCatalogUpgradeInProgress() const;
 
  private:
   using DbNameToOidList = std::vector<std::pair<std::string, YBCPgOid>>;
@@ -68,10 +82,10 @@ class YsqlInitDBAndMajorUpgradeHandler {
 
   // Runs the initdb process to create the initial ysql sys catalog and snapshot the sys_catalog if
   // needed.
-  // ysql major version upgrade provides db_name_to_oid_list. The clean install initdb process will
+  // ysql major catalog upgrade provides db_name_to_oid_list. The clean install initdb process will
   // choose new OIDs.
   Status InitDBAndSnapshotSysCatalog(
-      const DbNameToOidList& db_name_to_oid_list, const LeaderEpoch& epoch);
+      const DbNameToOidList& db_name_to_oid_list, bool is_major_upgrade, const LeaderEpoch& epoch);
 
   // Starts a new postgres process to run pg_upgrade to migrate the old catalog to the new version
   // catalog.
@@ -83,11 +97,15 @@ class YsqlInitDBAndMajorUpgradeHandler {
 
   Status RunRollbackMajorVersionUpgrade(const LeaderEpoch& epoch);
 
+  Status RollbackMajorVersionCatalogImpl(const LeaderEpoch& epoch);
+
   // Get the address to a live tserver process that is closest to the master.
   Result<std::string> GetClosestLiveTserverAddress();
 
   YsqlCatalogConfig& GetYsqlCatalogConfig();
 
+  const YsqlCatalogConfig& GetYsqlCatalogConfig() const;
+
   Master& master_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index e69e86f5cb..fd29603b95 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -1211,8 +1211,17 @@ Status ysql_major_version_catalog_upgrade_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
   RETURN_NOT_OK(CheckArgumentsCount(args.size(), 0, 0));
   RETURN_NOT_OK_PREPEND(
-      client->StartYsqlMajorVersionUpgradeInitdb(), "Unable to run ysql major version upgrade");
-  RETURN_NOT_OK(client->WaitForYsqlMajorVersionUpgradeInitdb());
+      client->StartYsqlMajorCatalogUpgrade(), "Unable to run ysql major catalog upgrade");
+  RETURN_NOT_OK(client->WaitForYsqlMajorCatalogUpgrade());
+  return Status::OK();
+}
+
+const auto finalize_ysql_major_version_catalog_upgrade_args = "";
+Status finalize_ysql_major_version_catalog_upgrade_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  RETURN_NOT_OK(CheckArgumentsCount(args.size(), 0, 0));
+  RETURN_NOT_OK_PREPEND(
+      client->FinalizeYsqlMajorCatalogUpgrade(), "Unable to finalize ysql major catalog upgrade");
   return Status::OK();
 }
 
@@ -1221,8 +1230,8 @@ const auto rollback_ysql_major_version_upgrade_args = "";
 Status rollback_ysql_major_version_upgrade_action(const ClusterAdminCli::CLIArguments& args,
                                                   ClusterAdminClient* client) {
   RETURN_NOT_OK(CheckArgumentsCount(args.size(), 0, 0));
-  RETURN_NOT_OK_PREPEND(client->RollbackYsqlMajorVersionUpgrade(),
-                        "Unable to roll back ysql major version upgrade");
+  RETURN_NOT_OK_PREPEND(
+      client->RollbackYsqlMajorCatalogVersion(), "Unable to roll back ysql major catalog upgrade");
   return Status::OK();
 }
 
@@ -2892,6 +2901,7 @@ void ClusterAdminCli::RegisterCommandHandlers() {
 
   // PG11 -> PG15 upgrade commands
   REGISTER_COMMAND(ysql_major_version_catalog_upgrade);
+  REGISTER_COMMAND(finalize_ysql_major_version_catalog_upgrade);
   REGISTER_COMMAND(rollback_ysql_major_version_upgrade);
 
   // SysCatalog util commands
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index d3bdf5147a..7b134afc78 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -2326,58 +2326,75 @@ Status ClusterAdminClient::UpgradeYsql(bool use_single_connection) {
   return Status::OK();
 }
 
-Status ClusterAdminClient::StartYsqlMajorVersionUpgradeInitdb() {
+Status ClusterAdminClient::StartYsqlMajorCatalogUpgrade() {
   RpcController rpc;
   rpc.set_timeout(timeout_);
-  master::StartYsqlMajorVersionUpgradeInitdbRequestPB req;
-  master::StartYsqlMajorVersionUpgradeInitdbResponsePB resp;
-  RETURN_NOT_OK(master_admin_proxy_->StartYsqlMajorVersionUpgradeInitdb(req, &resp, &rpc));
+  master::StartYsqlMajorCatalogUpgradeRequestPB req;
+  master::StartYsqlMajorCatalogUpgradeResponsePB resp;
+  RETURN_NOT_OK(master_admin_proxy_->StartYsqlMajorCatalogUpgrade(req, &resp, &rpc));
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   } else {
-    std::cout << "ysql major version catalog upgrade started\n";
+    std::cout << "ysql major catalog upgrade started\n";
   }
   return Status::OK();
 }
 
-Result<master::IsYsqlMajorVersionUpgradeInitdbDoneResponsePB>
-ClusterAdminClient::IsYsqlMajorVersionUpgradeInitdbDone() {
+Result<IsOperationDoneResult> ClusterAdminClient::IsYsqlMajorCatalogUpgradeDone() {
   RpcController rpc;
   rpc.set_timeout(timeout_);
-  master::IsYsqlMajorVersionUpgradeInitdbDoneRequestPB req;
-  master::IsYsqlMajorVersionUpgradeInitdbDoneResponsePB resp;
-  RETURN_NOT_OK(master_admin_proxy_->IsYsqlMajorVersionUpgradeInitdbDone(req, &resp, &rpc));
+  master::IsYsqlMajorCatalogUpgradeDoneRequestPB req;
+  master::IsYsqlMajorCatalogUpgradeDoneResponsePB resp;
+  RETURN_NOT_OK(master_admin_proxy_->IsYsqlMajorCatalogUpgradeDone(req, &resp, &rpc));
+
+  if (!resp.done()) {
+    return IsOperationDoneResult::NotDone();
+  }
+
   if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
+    return IsOperationDoneResult::Done(StatusFromPB(resp.error().status()));
   }
-  return resp;
+  return IsOperationDoneResult::Done();
 }
 
-Status ClusterAdminClient::WaitForYsqlMajorVersionUpgradeInitdb() {
+Status ClusterAdminClient::WaitForYsqlMajorCatalogUpgrade() {
   for (;;) {
-    auto result = IsYsqlMajorVersionUpgradeInitdbDone();
+    auto result = IsYsqlMajorCatalogUpgradeDone();
     if (!result.ok()) {
-      cout << "Failed to check if ysql major version upgrade initdb is done: " << result.status()
+      cout << "Failed to check if ysql major catalog version upgrade is done: " << result.status()
            << std::endl;
     } else if (result->done()) {
-      if (result->has_initdb_error()) {
-        return StatusFromPB(result->initdb_error().status());
-      } else {
-        std::cout << "ysql major version catalog upgrade completed successful\n";
-        return Status::OK();
+      if (!result->status().ok()) {
+        return result->status();
       }
+      std::cout << "ysql major catalog upgrade completed successfully\n";
+      return Status::OK();
     }
 
     std::this_thread::sleep_for(1s);
   }
 }
 
-Status ClusterAdminClient::RollbackYsqlMajorVersionUpgrade() {
+Status ClusterAdminClient::FinalizeYsqlMajorCatalogUpgrade() {
+  RpcController rpc;
+  rpc.set_timeout(timeout_);
+  master::FinalizeYsqlMajorCatalogUpgradeRequestPB req;
+  master::FinalizeYsqlMajorCatalogUpgradeResponsePB resp;
+  RETURN_NOT_OK(master_admin_proxy_->FinalizeYsqlMajorCatalogUpgrade(req, &resp, &rpc));
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  } else {
+    std::cout << "Finalize successful\n";
+  }
+  return Status::OK();
+}
+
+Status ClusterAdminClient::RollbackYsqlMajorCatalogVersion() {
   RpcController rpc;
   rpc.set_timeout(timeout_);
-  master::RollbackYsqlMajorVersionUpgradeRequestPB req;
-  master::RollbackYsqlMajorVersionUpgradeResponsePB resp;
-  RETURN_NOT_OK(master_admin_proxy_->RollbackYsqlMajorVersionUpgrade(req, &resp, &rpc));
+  master::RollbackYsqlMajorCatalogVersionRequestPB req;
+  master::RollbackYsqlMajorCatalogVersionResponsePB resp;
+  RETURN_NOT_OK(master_admin_proxy_->RollbackYsqlMajorCatalogVersion(req, &resp, &rpc));
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   } else {
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index ea93e34dbd..0242c9c1a8 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -63,6 +63,7 @@
 namespace yb {
 
 class HybridTime;
+class IsOperationDoneResult;
 
 namespace consensus {
 class ConsensusServiceProxy;
@@ -318,17 +319,15 @@ class ClusterAdminClient {
   //       look like this workflow is a good fit there.
   Status UpgradeYsql(bool use_single_connection);
 
-  Status StartYsqlMajorVersionUpgradeInitdb();
+  Status StartYsqlMajorCatalogUpgrade();
 
-  // Returns error Result if the RPC failed, otherwise returns the response for the caller to parse
-  // for both whether next version's initdb is done, and whether there is an initdb (non-RPC)
-  // error.
-  Result<master::IsYsqlMajorVersionUpgradeInitdbDoneResponsePB>
-  IsYsqlMajorVersionUpgradeInitdbDone();
+  Result<IsOperationDoneResult> IsYsqlMajorCatalogUpgradeDone();
 
-  Status WaitForYsqlMajorVersionUpgradeInitdb();
+  Status WaitForYsqlMajorCatalogUpgrade();
 
-  Status RollbackYsqlMajorVersionUpgrade();
+  Status FinalizeYsqlMajorCatalogUpgrade();
+
+  Status RollbackYsqlMajorCatalogVersion();
 
   // Set WAL retention time in secs for a table name.
   Status SetWalRetentionSecs(
diff --git a/src/yb/tserver/service_util.h b/src/yb/tserver/service_util.h
index 75e41861bf..6fc9f714f3 100644
--- a/src/yb/tserver/service_util.h
+++ b/src/yb/tserver/service_util.h
@@ -43,7 +43,6 @@
 #include "yb/util/status_format.h"
 
 DECLARE_bool(ysql_enable_db_catalog_version_mode);
-DECLARE_bool(TEST_online_pg11_to_pg15_upgrade);
 
 namespace yb::tserver {
 
@@ -311,8 +310,8 @@ class CatalogVersionChecker {
      * Disable catalog version checks during major version upgrade,
      * as we don't expect the catalog version to be incremented during the upgrade.
      */
-    if (!(request.has_ysql_db_catalog_version() || request.has_ysql_catalog_version())
-        || tablet_server_.IsInYsqlMajorUpgrade()) {
+    if (!(request.has_ysql_db_catalog_version() || request.has_ysql_catalog_version()) ||
+        tablet_server_.SkipCatalogVersionChecks()) {
       return Status::OK();
     }
     SCHECK(!(request.has_ysql_db_catalog_version() && request.has_ysql_catalog_version()),
diff --git a/src/yb/tserver/tablet_server_interface.h b/src/yb/tserver/tablet_server_interface.h
index 8f630efaf2..0077540d8b 100644
--- a/src/yb/tserver/tablet_server_interface.h
+++ b/src/yb/tserver/tablet_server_interface.h
@@ -123,7 +123,7 @@ class TabletServerIf : public LocalTabletServer {
   virtual Result<pgwrapper::PGConn> CreateInternalPGConn(
       const std::string& database_name, const std::optional<CoarseTimePoint>& deadline) = 0;
 
-  virtual bool IsInYsqlMajorUpgrade() { return false; }
+  virtual bool SkipCatalogVersionChecks() { return false; }
 };
 
 } // namespace tserver
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.cc b/src/yb/yql/pgwrapper/pg_wrapper.cc
index 3614ff2223..4fb12c32b8 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.cc
+++ b/src/yb/yql/pgwrapper/pg_wrapper.cc
@@ -140,9 +140,6 @@ DEFINE_NON_RUNTIME_string(ysql_hba_conf, "",
               "Comma separated list of postgres hba rules (in order)");
 TAG_FLAG(ysql_hba_conf, sensitive_info);
 DECLARE_string(tmp_dir);
-DEFINE_test_flag(bool, online_pg11_to_pg15_upgrade, false,
-    "Enter the mode in which the master creates PG15 catalogs alongside PG11 catalogs, leaving "
-    "PG11 catalogs as they are, using pg_restore. This flag is only meaningful on the YB master.");
 
 DEFINE_RUNTIME_PG_FLAG(string, timezone, "",
     "Overrides the default ysql timezone for displaying and interpreting timestamps. If no value "
@@ -877,11 +874,14 @@ Status PgWrapper::InitDb(InitdbParams initdb_params) {
   initdb_subprocess.InheritNonstandardFd(conf_.tserver_shm_fd);
   bool global_initdb = std::holds_alternative<GlobalInitdbParams>(initdb_params);
   SetCommonEnv(&initdb_subprocess, global_initdb);
-  initdb_subprocess.SetEnv(
-      "FLAGS_TEST_online_pg11_to_pg15_upgrade",
-      FLAGS_TEST_online_pg11_to_pg15_upgrade ? "true" : "false");
   if (global_initdb) {
-    for (const auto& [db_name, db_oid] : std::get<GlobalInitdbParams>(initdb_params).db_to_oid) {
+    const auto& global_initdb_params = std::get<GlobalInitdbParams>(initdb_params);
+
+    if (global_initdb_params.is_major_upgrade) {
+      initdb_subprocess.SetEnv("YB_PG_MAJOR_UPGRADE_INITDB", "true");
+    }
+
+    for (const auto& [db_name, db_oid] : global_initdb_params.db_to_oid) {
       initdb_subprocess.SetEnv("YB_DATABASE_OID_" + db_name, std::to_string(db_oid));
     }
   }
@@ -1031,8 +1031,8 @@ Status PgWrapper::InitDbLocalOnlyIfNeeded() {
 }
 
 Status PgWrapper::InitDbForYSQL(
-    const string& master_addresses, const string& tmp_dir_base,
-    int tserver_shm_fd, std::vector<std::pair<string, YBCPgOid>> db_to_oid) {
+    const string& master_addresses, const string& tmp_dir_base, int tserver_shm_fd,
+    std::vector<std::pair<string, YBCPgOid>> db_to_oid, bool is_major_upgrade) {
   LOG(INFO) << "Running initdb to initialize YSQL cluster with master addresses "
             << master_addresses;
   PgProcessConf conf;
@@ -1057,7 +1057,7 @@ Status PgWrapper::InitDbForYSQL(
   });
   PgWrapper pg_wrapper(conf);
   auto start_time = std::chrono::steady_clock::now();
-  Status initdb_status = pg_wrapper.InitDb(GlobalInitdbParams{db_to_oid});
+  Status initdb_status = pg_wrapper.InitDb(GlobalInitdbParams{db_to_oid, is_major_upgrade});
   auto elapsed_time = std::chrono::steady_clock::now() - start_time;
   LOG(INFO)
       << "initdb took "
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.h b/src/yb/yql/pgwrapper/pg_wrapper.h
index 246b5550cf..a50fe981e0 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.h
+++ b/src/yb/yql/pgwrapper/pg_wrapper.h
@@ -90,7 +90,7 @@ class PgWrapper : public ProcessWrapper {
   // create a temporary PostgreSQL directory that is later deleted.
   static Status InitDbForYSQL(
       const std::string& master_addresses, const std::string& tmp_dir_base, int tserver_shm_fd,
-      std::vector<std::pair<std::string, YBCPgOid>> db_to_oid);
+      std::vector<std::pair<std::string, YBCPgOid>> db_to_oid, bool is_major_upgrade);
 
   Status SetYsqlConnManagerStatsShmKey(key_t statsshmkey);
 
@@ -111,6 +111,7 @@ class PgWrapper : public ProcessWrapper {
   };
   struct GlobalInitdbParams {
     std::vector<std::pair<std::string, YBCPgOid>> db_to_oid;
+    bool is_major_upgrade = false;
   };
   using InitdbParams = std::variant<LocalInitdbParams, GlobalInitdbParams>;
 
