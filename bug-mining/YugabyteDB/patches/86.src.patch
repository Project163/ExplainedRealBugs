diff --git a/src/yb/client/CMakeLists.txt b/src/yb/client/CMakeLists.txt
index 4da1ff4186..04b32b439f 100644
--- a/src/yb/client/CMakeLists.txt
+++ b/src/yb/client/CMakeLists.txt
@@ -123,6 +123,7 @@ set(YB_TEST_LINK_LIBS
 ADD_YB_TEST(backup-txn-test)
 ADD_YB_TEST(client-test)
 ADD_YB_TEST(client-unittest)
+ADD_YB_TEST(clone_namespace-test)
 ADD_YB_TEST(ql-dml-test)
 ADD_YB_TEST(ql-dml-ttl-test)
 ADD_YB_TEST(ql-list-test)
@@ -132,6 +133,6 @@ ADD_YB_TEST(ql-transaction-test)
 ADD_YB_TEST(ql-stress-test)
 ADD_YB_TEST(seal-txn-test)
 ADD_YB_TEST(snapshot-txn-test)
-ADD_YB_TEST(snapshot-schedule-test)
+ADD_YB_TEST(snapshot_schedule-test)
 ADD_YB_TEST(serializable-txn-test)
 ADD_YB_TEST(tablet_rpc-test)
diff --git a/src/yb/client/clone_namespace-test.cc b/src/yb/client/clone_namespace-test.cc
new file mode 100644
index 0000000000..7951b066e7
--- /dev/null
+++ b/src/yb/client/clone_namespace-test.cc
@@ -0,0 +1,160 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/client/client-test-util.h"
+#include "yb/client/snapshot_schedule-test.h"
+#include "yb/client/yb_table_name.h"
+
+#include "yb/common/wire_protocol.h"
+
+#include "yb/master/master.h"
+
+#include "yb/util/backoff_waiter.h"
+
+DECLARE_bool(enable_db_clone);
+
+namespace yb {
+namespace client {
+
+class CloneNamespaceTest : public SnapshotScheduleTest {
+  void SetUp() override {
+    SnapshotScheduleTest::SetUp();
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_db_clone) = true;
+  }
+
+ protected:
+  Status CloneAndWait(
+      const std::string& source_namespace_name, YQLDatabase source_namespace_type, HybridTime ht,
+      const std::string& target_namespace_name) {
+    rpc::RpcController controller;
+    controller.set_timeout(60s);
+
+    master::CloneNamespaceRequestPB clone_req;
+    master::CloneNamespaceResponsePB clone_resp;
+
+    // Set request fields.
+    clone_req.mutable_source_namespace()->set_name(source_namespace_name);
+    clone_req.mutable_source_namespace()->set_database_type(source_namespace_type);
+    clone_req.set_restore_ht(ht.ToUint64());
+    clone_req.set_target_namespace_name(target_namespace_name);
+
+    auto backup_proxy = VERIFY_RESULT(snapshot_util_->MakeBackupServiceProxy());
+    RETURN_NOT_OK(backup_proxy.CloneNamespace(clone_req, &clone_resp, &controller));
+    if (clone_resp.has_error()) {
+      return StatusFromPB(clone_resp.error().status());
+    }
+
+    // Wait until clone is done.
+    master::IsCloneDoneRequestPB done_req;
+    master::IsCloneDoneResponsePB done_resp;
+    done_req.set_seq_no(clone_resp.seq_no());
+    done_req.set_source_namespace_id(clone_resp.source_namespace_id());
+    RETURN_NOT_OK(WaitFor([&]() -> Result<bool> {
+      controller.Reset();
+      RETURN_NOT_OK(backup_proxy.IsCloneDone(done_req, &done_resp, &controller));
+      if (done_resp.has_error()) {
+        return StatusFromPB(clone_resp.error().status());
+      }
+      return done_resp.is_done();
+    }, 60s, "Wait for clone to finish"));
+
+    return Status::OK();
+  }
+  const std::string kTargetNamespaceName = "clone_namespace";
+};
+
+TEST_F(CloneNamespaceTest, Clone) {
+  const std::string kTargetNamespaceName2 = "clone_namespace2";
+  auto schedule_id = ASSERT_RESULT(
+    snapshot_util_->CreateSchedule(table_, kTableName.namespace_type(),
+                                   kTableName.namespace_name()));
+  ASSERT_OK(snapshot_util_->WaitScheduleSnapshot(schedule_id));
+
+  // Write two sets of rows.
+  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
+  auto row_count1 = CountTableRows(table_);
+  auto ht1 = cluster_->mini_master()->master()->clock()->Now();
+  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 1) /* transaction */);
+  auto row_count2 = CountTableRows(table_);
+  auto ht2 = cluster_->mini_master()->master()->clock()->Now();
+
+  ASSERT_OK(CloneAndWait(
+      kTableName.namespace_name(), YQLDatabase::YQL_DATABASE_CQL, ht1, kTargetNamespaceName));
+  ASSERT_OK(CloneAndWait(
+      kTableName.namespace_name(), YQLDatabase::YQL_DATABASE_CQL, ht2, kTargetNamespaceName2));
+
+  // First clone should have only the first set of rows.
+  YBTableName clone1(YQL_DATABASE_CQL, kTargetNamespaceName, kTableName.table_name());
+  TableHandle clone1_handle;
+  ASSERT_OK(clone1_handle.Open(clone1, client_.get()));
+  ASSERT_EQ(CountTableRows(clone1_handle), row_count1);
+
+  // Second clone should have all the rows.
+  YBTableName clone2(YQL_DATABASE_CQL, kTargetNamespaceName2, kTableName.table_name());
+  TableHandle clone2_handle;
+  ASSERT_OK(clone2_handle.Open(clone2, client_.get()));
+  ASSERT_EQ(CountTableRows(clone2_handle), row_count2);
+}
+
+TEST_F(CloneNamespaceTest, CloneWithNoSchedule) {
+  // Write one row.
+  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
+  auto ht = cluster_->mini_master()->master()->clock()->Now();
+
+  auto status = CloneAndWait(
+      kTableName.namespace_name(), YQLDatabase::YQL_DATABASE_CQL, ht, kTargetNamespaceName);
+  ASSERT_NOK(status);
+  ASSERT_STR_CONTAINS(status.message().ToBuffer(), "Could not find snapshot schedule");
+}
+
+TEST_F(CloneNamespaceTest, CloneAfterDrop) {
+  auto schedule_id = ASSERT_RESULT(
+    snapshot_util_->CreateSchedule(table_, kTableName.namespace_type(),
+                                   kTableName.namespace_name()));
+  ASSERT_OK(snapshot_util_->WaitScheduleSnapshot(schedule_id));
+
+  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
+  auto row_count = CountTableRows(table_);
+  auto ht = cluster_->mini_master()->master()->clock()->Now();
+
+  ASSERT_OK(client_->DeleteTable(kTableName));
+
+  ASSERT_OK(CloneAndWait(
+      kTableName.namespace_name(), YQLDatabase::YQL_DATABASE_CQL, ht, kTargetNamespaceName));
+
+  YBTableName clone(YQL_DATABASE_CQL, kTargetNamespaceName, kTableName.table_name());
+  TableHandle clone_handle;
+  ASSERT_OK(clone_handle.Open(clone, client_.get()));
+  ASSERT_EQ(CountTableRows(clone_handle), row_count);
+}
+
+TEST_F(CloneNamespaceTest, DropClonedNamespace) {
+  auto schedule_id = ASSERT_RESULT(
+    snapshot_util_->CreateSchedule(table_, kTableName.namespace_type(),
+                                   kTableName.namespace_name()));
+  ASSERT_OK(snapshot_util_->WaitScheduleSnapshot(schedule_id));
+  auto ht = cluster_->mini_master()->master()->clock()->Now();
+
+  ASSERT_OK(CloneAndWait(
+      kTableName.namespace_name(), YQLDatabase::YQL_DATABASE_CQL, ht, kTargetNamespaceName));
+
+  YBTableName clone(YQL_DATABASE_CQL, kTargetNamespaceName, kTableName.table_name());
+  TableHandle clone_handle;
+  ASSERT_OK(clone_handle.Open(clone, client_.get()));
+
+  ASSERT_OK(client_->DeleteTable(clone));
+  ASSERT_OK(client_->DeleteNamespace(kTargetNamespaceName));
+}
+
+} // namespace client
+} // namespace yb
diff --git a/src/yb/client/snapshot-schedule-test.cc b/src/yb/client/snapshot_schedule-test.cc
similarity index 80%
rename from src/yb/client/snapshot-schedule-test.cc
rename to src/yb/client/snapshot_schedule-test.cc
index 9af3a66940..9bba828c6e 100644
--- a/src/yb/client/snapshot-schedule-test.cc
+++ b/src/yb/client/snapshot_schedule-test.cc
@@ -11,6 +11,8 @@
 // under the License.
 //
 
+#include "yb/client/snapshot_schedule-test.h"
+
 #include "yb/client/client-test-util.h"
 #include "yb/client/ql-dml-test-base.h"
 #include "yb/client/schema.h"
@@ -26,13 +28,9 @@
 #include "yb/common/colocated_util.h"
 
 #include "yb/common/wire_protocol.h"
-#include "yb/master/catalog_entity_info.h"
-#include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
 #include "yb/master/master_backup.pb.h"
-#include "yb/master/master_backup.proxy.h"
 #include "yb/master/master_types.pb.h"
-#include "yb/master/master_util.h"
 #include "yb/master/mini_master.h"
 #include "yb/master/sys_catalog.h"
 
@@ -49,10 +47,8 @@
 
 using namespace std::literals;
 
-DECLARE_bool(enable_db_clone);
 DECLARE_bool(enable_fast_pitr);
 DECLARE_bool(enable_history_cutoff_propagation);
-DECLARE_int32(history_cutoff_propagation_interval_ms);
 DECLARE_int32(timestamp_history_retention_interval_sec);
 DECLARE_int32(timestamp_syscatalog_history_retention_interval_sec);
 DECLARE_uint64(snapshot_coordinator_poll_interval_ms);
@@ -61,21 +57,6 @@ DECLARE_uint64(snapshot_coordinator_cleanup_delay_ms);
 namespace yb {
 namespace client {
 
-class SnapshotScheduleTest : public TransactionTestBase<MiniCluster> {
- public:
-  void SetUp() override {
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_history_cutoff_propagation) = true;
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_snapshot_coordinator_poll_interval_ms) = 250;
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_history_cutoff_propagation_interval_ms) = 100;
-    num_tablets_ = 1;
-    TransactionTestBase<MiniCluster>::SetUp();
-    snapshot_util_ = std::make_unique<SnapshotTestUtil>();
-    snapshot_util_->SetProxy(&client_->proxy_cache());
-    snapshot_util_->SetCluster(cluster_.get());
-  }
-  std::unique_ptr<SnapshotTestUtil> snapshot_util_;
-};
-
 TEST_F(SnapshotScheduleTest, Create) {
   std::vector<SnapshotScheduleId> ids;
   for (int i = 0; i != 3; ++i) {
@@ -355,125 +336,6 @@ TEST_F(SnapshotScheduleTest, RestoreSchema) {
   ASSERT_NO_FATALS(VerifyData());
 }
 
-class CloneFromScheduleTest : public SnapshotScheduleTest {
-  void SetUp() override {
-    SnapshotScheduleTest::SetUp();
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_db_clone) = true;
-  }
-
- protected:
-  Status CloneAndWait(const master::CloneNamespaceRequestPB& clone_req) {
-    rpc::RpcController controller;
-    controller.set_timeout(60s);
-    master::CloneNamespaceResponsePB clone_resp;
-    auto backup_proxy = VERIFY_RESULT(snapshot_util_->MakeBackupServiceProxy());
-    RETURN_NOT_OK(backup_proxy.CloneNamespace(clone_req, &clone_resp, &controller));
-    if (clone_resp.has_error()) {
-      return StatusFromPB(clone_resp.error().status());
-    }
-
-    // Wait until clone is done.
-    master::IsCloneDoneRequestPB done_req;
-    master::IsCloneDoneResponsePB done_resp;
-    done_req.set_seq_no(clone_resp.seq_no());
-    done_req.set_source_namespace_id(clone_resp.source_namespace_id());
-    RETURN_NOT_OK(WaitFor([&]() -> Result<bool> {
-      controller.Reset();
-      RETURN_NOT_OK(backup_proxy.IsCloneDone(done_req, &done_resp, &controller));
-      if (done_resp.has_error()) {
-        return StatusFromPB(clone_resp.error().status());
-      }
-      return done_resp.is_done();
-    }, 60s, "Wait for clone to finish"));
-
-    return Status::OK();
-  }
-};
-
-TEST_F(CloneFromScheduleTest, Clone) {
-  auto schedule_id = ASSERT_RESULT(
-    snapshot_util_->CreateSchedule(table_, kTableName.namespace_type(),
-                                   kTableName.namespace_name()));
-  ASSERT_OK(snapshot_util_->WaitScheduleSnapshot(schedule_id));
-
-  // Write two sets of rows.
-  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
-  auto row_count1 = CountTableRows(table_);
-  auto ht1 = cluster_->mini_master()->master()->clock()->Now();
-  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 1) /* transaction */);
-  auto row_count2 = CountTableRows(table_);
-  auto ht2 = cluster_->mini_master()->master()->clock()->Now();
-
-  master::CloneNamespaceRequestPB req;
-  master::NamespaceIdentifierPB source_namespace;
-  source_namespace.set_name(kTableName.namespace_name());
-  source_namespace.set_database_type(YQLDatabase::YQL_DATABASE_CQL);
-  *req.mutable_source_namespace() = source_namespace;
-  req.set_restore_ht(ht1.ToUint64());
-  req.set_target_namespace_name("clone1" /* target_namespace_name */);
-  ASSERT_OK(CloneAndWait(req));
-
-  req.set_restore_ht(ht2.ToUint64());
-  req.set_target_namespace_name("clone2" /* target_namespace_name */);
-  ASSERT_OK(CloneAndWait(req));
-
-  // First clone should have only the first set of rows.
-  YBTableName clone1(YQL_DATABASE_CQL, "clone1", kTableName.table_name());
-  TableHandle clone1_handle;
-  ASSERT_OK(clone1_handle.Open(clone1, client_.get()));
-  ASSERT_EQ(CountTableRows(clone1_handle), row_count1);
-
-  // Second clone should have all the rows.
-  YBTableName clone2(YQL_DATABASE_CQL, "clone2", kTableName.table_name());
-  TableHandle clone2_handle;
-  ASSERT_OK(clone2_handle.Open(clone2, client_.get()));
-  ASSERT_EQ(CountTableRows(clone2_handle), row_count2);
-}
-
-TEST_F(CloneFromScheduleTest, CloneWithNoSchedule) {
-  // Write one row.
-  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
-  auto ht = cluster_->mini_master()->master()->clock()->Now();
-
-  master::CloneNamespaceRequestPB req;
-  master::NamespaceIdentifierPB source_namespace;
-  source_namespace.set_name(kTableName.namespace_name());
-  source_namespace.set_database_type(YQLDatabase::YQL_DATABASE_CQL);
-  *req.mutable_source_namespace() = source_namespace;
-  req.set_restore_ht(ht.ToUint64());
-  req.set_target_namespace_name("clone1" /* target_namespace_name */);
-  auto status = CloneAndWait(req);
-  ASSERT_NOK(status);
-  ASSERT_STR_CONTAINS(status.message().ToBuffer(), "Could not find snapshot schedule");
-}
-
-TEST_F(CloneFromScheduleTest, CloneAfterDrop) {
-  auto schedule_id = ASSERT_RESULT(
-    snapshot_util_->CreateSchedule(table_, kTableName.namespace_type(),
-                                   kTableName.namespace_name()));
-  ASSERT_OK(snapshot_util_->WaitScheduleSnapshot(schedule_id));
-
-  ASSERT_NO_FATALS(WriteData(WriteOpType::INSERT, 0 /* transaction */));
-  auto row_count = CountTableRows(table_);
-  auto ht = cluster_->mini_master()->master()->clock()->Now();
-
-  ASSERT_OK(client_->DeleteTable(kTableName));
-
-  master::CloneNamespaceRequestPB req;
-  master::NamespaceIdentifierPB source_namespace;
-  source_namespace.set_name(kTableName.namespace_name());
-  source_namespace.set_database_type(YQLDatabase::YQL_DATABASE_CQL);
-  *req.mutable_source_namespace() = source_namespace;
-  req.set_restore_ht(ht.ToUint64());
-  req.set_target_namespace_name("clone" /* target_namespace_name */);
-  ASSERT_OK(CloneAndWait(req));
-
-  YBTableName clone(YQL_DATABASE_CQL, "clone", kTableName.table_name());
-  TableHandle clone_handle;
-  ASSERT_OK(clone_handle.Open(clone, client_.get()));
-  ASSERT_EQ(CountTableRows(clone_handle), row_count);
-}
-
 TEST_F(SnapshotScheduleTest, RemoveNewTablets) {
   const auto kInterval = 5s * kTimeMultiplier;
   const auto kRetention = kInterval * 2;
diff --git a/src/yb/client/snapshot_schedule-test.h b/src/yb/client/snapshot_schedule-test.h
new file mode 100644
index 0000000000..676811db4a
--- /dev/null
+++ b/src/yb/client/snapshot_schedule-test.h
@@ -0,0 +1,44 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/client/snapshot_test_util.h"
+#include "yb/client/txn-test-base.h"
+
+#include "yb/integration-tests/mini_cluster.h"
+
+DECLARE_bool(enable_history_cutoff_propagation);
+DECLARE_int32(history_cutoff_propagation_interval_ms);
+DECLARE_uint64(snapshot_coordinator_poll_interval_ms);
+
+namespace yb {
+namespace client {
+
+class SnapshotScheduleTest : public TransactionTestBase<MiniCluster> {
+ public:
+  void SetUp() override {
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_history_cutoff_propagation) = true;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_snapshot_coordinator_poll_interval_ms) = 250;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_history_cutoff_propagation_interval_ms) = 100;
+    num_tablets_ = 1;
+    TransactionTestBase<MiniCluster>::SetUp();
+    snapshot_util_ = std::make_unique<SnapshotTestUtil>();
+    snapshot_util_->SetProxy(&client_->proxy_cache());
+    snapshot_util_->SetCluster(cluster_.get());
+  }
+  std::unique_ptr<SnapshotTestUtil> snapshot_util_;
+};
+
+} // namespace client
+} // namespace yb
diff --git a/src/yb/integration-tests/snapshot-test.cc b/src/yb/integration-tests/snapshot-test.cc
index 14de510ce7..7eb0f89f94 100644
--- a/src/yb/integration-tests/snapshot-test.cc
+++ b/src/yb/integration-tests/snapshot-test.cc
@@ -263,15 +263,20 @@ class SnapshotTest : public YBMiniClusterTestBase<MiniCluster> {
         });
   }
 
-  TxnSnapshotId CreateSnapshot(int32_t retention_duration_hours = 0) {
+  TxnSnapshotId CreateSnapshot(
+      std::optional<int32_t> retention_duration_hours = std::nullopt,
+      std::optional<bool> imported = std::nullopt) {
     CreateSnapshotRequestPB req;
     CreateSnapshotResponsePB resp;
     req.set_transaction_aware(true);
     TableIdentifierPB* const table = req.mutable_tables()->Add();
     table->set_table_name(kTableName.table_name());
     table->mutable_namespace_()->set_name(kTableName.namespace_name());
-    if (retention_duration_hours > 0) {
-      req.set_retention_duration_hours(retention_duration_hours);
+    if (retention_duration_hours) {
+      req.set_retention_duration_hours(*retention_duration_hours);
+    }
+    if (imported) {
+      req.set_imported(*imported);
     }
 
     // Check the request.
@@ -500,7 +505,7 @@ TEST_F(SnapshotTest, CreateSnapshot) {
   ASSERT_OK(cluster_->RestartSync());
 }
 
-// Tests that a snapshot hides a table that is dropped subsequently.
+// Tests that a non-imported snapshot hides a table that is dropped subsequently.
 // Until the snapshot is deleted, the table is hidden and once the
 // snapshot gets deleted, the table is subsequently deleted.
 TEST_F(SnapshotTest, HideTablesCoveredBySnapshot) {
@@ -538,10 +543,38 @@ TEST_F(SnapshotTest, HideTablesCoveredBySnapshot) {
       std::bind(&SnapshotTest::IsTableDropped, this, table->id()), 120s, "IsTableDropped"));
 }
 
+TEST_F(SnapshotTest, ImportedSnapshotsDoNotBlockCleanup) {
+  auto workload = SetupWorkload(); // Used to create table.
+
+  // Get the table id.
+  auto master_leader = ASSERT_RESULT(cluster_->GetLeaderMiniMaster());
+  auto table = master_leader->catalog_manager_impl().GetTableInfoFromNamespaceNameAndTableName(
+      workload.table_name().namespace_type(), workload.table_name().namespace_name(),
+      workload.table_name().table_name());
+
+  // Create imported snapshot.
+  const auto snapshot_id = CreateSnapshot(-1 /* retention_duration_hours */, true /* imported */);
+
+  // Verify the snapshot does not cover the tablets.
+  ASSERT_NOK(SnapshotCoversTablets(snapshot_id, table->id()));
+  // The snapshot should not cover the tablets after a restart either.
+  ASSERT_OK(cluster_->RestartSync());
+  ASSERT_NOK(SnapshotCoversTablets(snapshot_id, table->id()));
+
+  // Drop table and verify table is dropped, not hidden.
+  ASSERT_OK(client_->DeleteTable(workload.table_name(), true /* wait */));
+  ASSERT_TRUE(ASSERT_RESULT(IsTableDropped(table->id())));
+}
+
+YB_STRONGLY_TYPED_BOOL(Imported);
+class SnapshotTestImported : public SnapshotTest, public testing::WithParamInterface<Imported> {};
+INSTANTIATE_TEST_SUITE_P(
+    , SnapshotTestImported, ::testing::Values(Imported::kTrue, Imported::kFalse));
+
 // Tests that snapshot TTL field is set in snapshots.
-TEST_F(SnapshotTest, SnapshotTtlBasic) {
+TEST_P(SnapshotTestImported, SnapshotTtlBasic) {
   SetupWorkload();
-  auto snapshot_id = CreateSnapshot(5 /* retention_duration_hours */);
+  auto snapshot_id = CreateSnapshot(5 /* retention_duration_hours */, GetParam() /* imported */);
   auto expiry_equals_cb = [this](const TxnSnapshotId& snapshot_id, int32_t expiry_hrs) -> Status {
     ListSnapshotsRequestPB list_req;
     ListSnapshotsResponsePB list_resp;
@@ -561,33 +594,36 @@ TEST_F(SnapshotTest, SnapshotTtlBasic) {
   DeleteSnapshot(snapshot_id);
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_default_snapshot_retention_hours) = 12;
   // Default value controlled by gflag should be set.
-  snapshot_id = CreateSnapshot();
+  snapshot_id = CreateSnapshot(
+      std::nullopt /* retention_duration_hours */, GetParam() /* imported */);
   ASSERT_OK(expiry_equals_cb(snapshot_id, FLAGS_default_snapshot_retention_hours));
 }
 
 // Tests that snapshot TTL is honoured and that snapshots get expired.
-TEST_F(SnapshotTest, SnapshotTtl) {
+TEST_P(SnapshotTestImported, SnapshotTtl) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_snapshot_coordinator_cleanup_delay_ms) = 500;
   // To speed up tests.
   ANNOTATE_UNPROTECTED_WRITE(
       FLAGS_TEST_treat_hours_as_milliseconds_for_snapshot_expiry) = true;
   SetupWorkload();
   // This will actually be treated as 1000 ms instead of 1000 hours due to the flag.
-  const auto snapshot_id = CreateSnapshot(1000 /* retention_duration_hours */);
+  const auto snapshot_id =
+      CreateSnapshot(1000 /* retention_duration_hours */, GetParam() /* imported */);
   // Give three cycles to the snapshot coordinator to cleanup the snapshot.
   ASSERT_OK(WaitForSnapshotOpDone(
       "IsSnapshotDeleted", snapshot_id,
       MonoDelta::FromMilliseconds(FLAGS_snapshot_coordinator_poll_interval_ms * 3)));
 }
 
-TEST_F(SnapshotTest, SnapshotTtlWithRestart) {
+TEST_P(SnapshotTestImported, SnapshotTtlWithRestart) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_snapshot_coordinator_cleanup_delay_ms) = 500;
   // To speed up tests.
   ANNOTATE_UNPROTECTED_WRITE(
       FLAGS_TEST_treat_hours_as_milliseconds_for_snapshot_expiry) = true;
   SetupWorkload();
   // This will actually be treated as 5000 ms instead of 5000 hours due to the flag.
-  const auto snapshot_id = CreateSnapshot(5000 /* retention_duration_hours */);
+  const auto snapshot_id =
+      CreateSnapshot(5000 /* retention_duration_hours */, GetParam() /* imported */);
   // Restart.
   ASSERT_OK(cluster_->RestartSync());
   // Give four cycles to the snapshot coordinator to cleanup the snapshot.
@@ -596,6 +632,20 @@ TEST_F(SnapshotTest, SnapshotTtlWithRestart) {
       MonoDelta::FromMilliseconds(FLAGS_snapshot_coordinator_poll_interval_ms * 4)));
 }
 
+// Test that snapshots with retention_duration_hours = -1 are not cleaned up.
+TEST_F(SnapshotTest, InfiniteRetentionDuration) {
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_snapshot_coordinator_cleanup_delay_ms) = 500;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_treat_hours_as_milliseconds_for_snapshot_expiry) = true;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_default_snapshot_retention_hours) = 1;
+
+  SetupWorkload();
+  const auto snapshot_id = CreateSnapshot(-1 /* retention_duration_hours */, Imported::kFalse);
+  // Give three cycles to the snapshot coordinator to try to clean up the snapshot.
+  ASSERT_NOK(WaitForSnapshotOpDone(
+      "IsSnapshotDeleted", snapshot_id,
+      MonoDelta::FromMilliseconds(FLAGS_snapshot_coordinator_poll_interval_ms * 3)));
+}
+
 // Tests that deleted objects are eventually cleaned up even if the client
 // fails to invoke delete snapshot.
 TEST_F(SnapshotTest, EventuallyDeleteTablesCoveredBySnapshot) {
diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index 84cebb2ff9..f2f2788264 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -576,10 +576,22 @@ message SysSnapshotEntryPB {
 
   optional fixed64 previous_snapshot_hybrid_time = 7;
 
-  // Number of hours the snapshot needs to be kept around
-  // before it is deleted. Set to -1 to retain indefinitely until
-  // an explicit delete_snapshot.
+  // This field specifies the TTL of this snapshot.
+  // 1. Not set: the snapshot has no explicit TTL, will be retained until a DeleteSnapshot, and
+  //             does not block object cleanup. This is used to handle a few special cases:
+  //   a. Snapshots which are part of a snapshot schedule do not have this field set. This is
+  //      because their TTL is controlled by the snapshot schedule's retention.
+  //   b. Snapshots created before D28005 (when this field was introduced).
+  // 2. < 0: the snapshot will not be automatically cleaned up until a `DeleteSnapshot`, and might
+  //         block object cleanup until then.
+  // 3. > 0: the snapshot will automatically be cleaned up when
+  //         now() > snapshot_hybrid_time + retention_duration_hours.
+  // 4. 0: explicitly forbidden.
   optional int32 retention_duration_hours = 8;
+
+  // Whether this is an imported snapshot (part of a restore). Default is false to maintain
+  // historical behavior when deciding whether to block object cleanup.
+  optional bool imported = 9 [default = false];
 }
 
 message SysCloneStatePB {
diff --git a/src/yb/master/snapshot_state.cc b/src/yb/master/snapshot_state.cc
index ac957ed4cd..8d9f597931 100644
--- a/src/yb/master/snapshot_state.cc
+++ b/src/yb/master/snapshot_state.cc
@@ -89,7 +89,8 @@ SnapshotState::SnapshotState(
       id_(id), snapshot_hybrid_time_(request.snapshot_hybrid_time()),
       previous_snapshot_hybrid_time_(HybridTime::FromPB(request.previous_snapshot_hybrid_time())),
       schedule_id_(TryFullyDecodeSnapshotScheduleId(request.schedule_id())), version_(1),
-      throttler_(throttle_limit) {
+      throttler_(throttle_limit),
+      imported_(request.imported()) {
   InitTabletIds(request.tablet_id(),
                 request.imported() ? SysSnapshotEntryPB::COMPLETE : SysSnapshotEntryPB::CREATING);
   request.extra_data().UnpackTo(&entries_);
@@ -106,7 +107,7 @@ SnapshotState::SnapshotState(
       id_(id), snapshot_hybrid_time_(entry.snapshot_hybrid_time()),
       previous_snapshot_hybrid_time_(HybridTime::FromPB(entry.previous_snapshot_hybrid_time())),
       schedule_id_(TryFullyDecodeSnapshotScheduleId(entry.schedule_id())),
-      version_(entry.version()) {
+      version_(entry.version()), imported_(entry.imported()) {
   InitTablets(entry.tablet_snapshots());
   *entries_.mutable_entries() = entry.entries();
   if (entry.has_retention_duration_hours()) {
@@ -156,6 +157,7 @@ Status SnapshotState::ToEntryPB(
   }
 
   out->set_version(version_);
+  out->set_imported(imported_);
 
   return Status::OK();
 }
diff --git a/src/yb/master/snapshot_state.h b/src/yb/master/snapshot_state.h
index f3de88fc14..9ac0c50b9d 100644
--- a/src/yb/master/snapshot_state.h
+++ b/src/yb/master/snapshot_state.h
@@ -49,6 +49,7 @@ using TabletSnapshotOperations = std::vector<TabletSnapshotOperation>;
 
 class SnapshotState : public StateWithTablets {
  public:
+  // TODO: Should we throttle per tserver instead of per snapshot?
   SnapshotState(
       SnapshotCoordinatorContext* context, const TxnSnapshotId& id,
       const tserver::TabletSnapshotOpRequestPB& request,
@@ -90,12 +91,19 @@ class SnapshotState : public StateWithTablets {
     return retention_duration_hours_ ? true : false;
   }
 
+  // Whether to block object (table / tablet) cleanup until the retention window specified in
+  // retention_duration_hours (if set) has passed. If true, the objects will be hidden instead
+  // of deleted until retention_duration_hours have passed.
+  bool ShouldBlockObjectCleanup() const {
+    return HasTtl() && !schedule_id() && !imported_;
+  }
+
   bool ShouldAddToCoveringMap() const {
-    return HasTtl() && !schedule_id() && AllInState(SysSnapshotEntryPB::COMPLETE);
+    return ShouldBlockObjectCleanup() && AllInState(SysSnapshotEntryPB::COMPLETE);
   }
 
   bool ShouldRemoveFromCoveringMap() const {
-    return HasTtl() && !schedule_id() && AllInState(SysSnapshotEntryPB::DELETING);
+    return ShouldBlockObjectCleanup() && AllInState(SysSnapshotEntryPB::DELETING);
   }
 
   Result<tablet::CreateSnapshotData> SysCatalogSnapshotData(
@@ -133,7 +141,13 @@ class SnapshotState : public StateWithTablets {
   bool delete_started_ = false;
   AsyncTaskTracker cleanup_tracker_;
   AsyncTaskThrottler throttler_;
+
+  // How long to retain this snapshot. See the comment in SysSnapshotEntryPB for a longer
+  // description.
   std::optional<int32_t> retention_duration_hours_ = std::nullopt;
+
+  // Whether this snapshot is imported. Imported snapshots do not block object cleanup.
+  bool imported_;
 };
 
 Result<dockv::KeyBytes> EncodedSnapshotKey(
