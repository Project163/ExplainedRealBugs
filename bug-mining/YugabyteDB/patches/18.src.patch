diff --git a/src/yb/cdc/cdc_service.cc b/src/yb/cdc/cdc_service.cc
index d747d76da3..9c8532de1b 100644
--- a/src/yb/cdc/cdc_service.cc
+++ b/src/yb/cdc/cdc_service.cc
@@ -187,7 +187,7 @@ DECLARE_int64(cdc_intent_retention_ms);
 DECLARE_bool(TEST_ysql_yb_enable_replication_commands);
 DECLARE_bool(enable_xcluster_auto_flag_validation);
 
-METRIC_DEFINE_entity(cdc);
+METRIC_DEFINE_entity(xcluster);
 
 METRIC_DEFINE_entity(cdcsdk);
 
@@ -328,7 +328,7 @@ Result<std::shared_ptr<T>> GetOrCreateXreplTabletMetrics(
 
     scoped_refptr<MetricEntity> entity;
     if (source_type == XCLUSTER) {
-      entity = METRIC_ENTITY_cdc.Instantiate(
+      entity = METRIC_ENTITY_xcluster.Instantiate(
           metric_registry, metric_id, attrs);
     } else {
       entity = METRIC_ENTITY_cdcsdk.Instantiate(
diff --git a/src/yb/cdc/xrepl_metrics.cc b/src/yb/cdc/xrepl_metrics.cc
index cea8b1d034..8d7bffe259 100644
--- a/src/yb/cdc/xrepl_metrics.cc
+++ b/src/yb/cdc/xrepl_metrics.cc
@@ -35,54 +35,83 @@
 #include "yb/util/trace.h"
 
 
-// CDC Tablet metrics.
+// xCluster Tablet metrics.
 // Todo(Rahul): Figure out appropriate aggregation functions for these metrics.
-METRIC_DEFINE_event_stats(cdc, rpc_payload_bytes_responded, "CDC Bytes Responded",
+METRIC_DEFINE_event_stats(xcluster, rpc_payload_bytes_responded, "xCluster Bytes Responded",
     yb::MetricUnit::kBytes,
-    "Payload size of responses to CDC GetChanges requests (only when records are included)");
+    "Payload size of responses to xCluster GetChanges requests (only when records are included)");
 
-METRIC_DEFINE_counter(cdc, rpc_heartbeats_responded, "CDC Rpc Heartbeat Count",
+METRIC_DEFINE_counter(xcluster, rpc_heartbeats_responded, "xCluster Rpc Heartbeat Count",
     yb::MetricUnit::kRequests,
-    "Number of responses to CDC GetChanges requests without a record payload.");
+    "Number of responses to xCluster GetChanges requests without a record payload.");
 
-METRIC_DEFINE_gauge_int64(cdc, last_read_opid_term, "CDC Last Read OpId (Term)",
+METRIC_DEFINE_gauge_int64(xcluster, last_read_opid_term, "xCluster Last Read OpId (Term)",
     yb::MetricUnit::kOperations,
-    "ID of the Last Read Producer Operation from a CDC GetChanges request. Format = term.index");
+    "ID of the Last Read Producer Operation from a xCluster GetChanges request. Format = "
+    "term.index");
 
-METRIC_DEFINE_gauge_int64(cdc, last_read_opid_index, "CDC Last Read OpId (Index)",
+METRIC_DEFINE_gauge_int64(xcluster, last_read_opid_index, "xCluster Last Read OpId (Index)",
     yb::MetricUnit::kOperations,
-    "ID of the Last Read Producer Operation from a CDC GetChanges request. Format = term.index");
+    "ID of the Last Read Producer Operation from a xCluster GetChanges request. Format = "
+    "term.index");
 
-METRIC_DEFINE_gauge_int64(cdc, last_checkpoint_opid_index, "CDC Last Checkpoint OpId (Index)",
+METRIC_DEFINE_gauge_int64(xcluster, last_checkpoint_opid_index, "xCluster Last Checkpoint OpId "
+"(Index)",
     yb::MetricUnit::kOperations,
-    "ID of the Last Checkpoint Sent by Consumer in a CDC GetChanges request. Format = term.index");
+    "ID of the Last Checkpoint Sent by Consumer in a xCluster GetChanges request. Format = "
+    "term.index");
 
-METRIC_DEFINE_gauge_uint64(cdc, last_read_hybridtime, "CDC Last Read HybridTime.",
+METRIC_DEFINE_gauge_uint64(xcluster, last_read_hybridtime, "xCluster Last Read HybridTime.",
     yb::MetricUnit::kMicroseconds,
-    "HybridTime of the Last Read Operation from a CDC GetChanges request");
+    "HybridTime of the Last Read Operation from a xCluster GetChanges request");
 
-METRIC_DEFINE_gauge_uint64(cdc, last_read_physicaltime, "CDC Last Read Physical TIme.",
+METRIC_DEFINE_gauge_uint64(xcluster, last_read_physicaltime, "xCluster Last Read Physical TIme.",
     yb::MetricUnit::kMicroseconds,
-    "Physical Time of the Last Read Operation from a CDC GetChanges request");
+    "Physical Time of the Last Read Operation from a xCluster GetChanges request");
 
-METRIC_DEFINE_gauge_uint64(cdc, last_checkpoint_physicaltime, "CDC Last Committed Physical Time.",
+METRIC_DEFINE_gauge_uint64(xcluster, last_checkpoint_physicaltime,
+    "xCluster Last Committed Physical Time.",
     yb::MetricUnit::kMicroseconds,
     "Physical Time of the Last Committed Operation on Consumer.");
 
-METRIC_DEFINE_gauge_int64(cdc, last_readable_opid_index, "CDC Last Readable OpId (Index)",
+METRIC_DEFINE_gauge_int64(xcluster, last_readable_opid_index, "xCluster Last Readable OpId (Index)",
     yb::MetricUnit::kOperations,
-    "Index of the Last Producer Operation that a CDC GetChanges request COULD read.");
+    "Index of the Last Producer Operation that a xCluster GetChanges request COULD read.");
 
-METRIC_DEFINE_gauge_int64(cdc, async_replication_sent_lag_micros, "CDC Physical Time Lag Last Sent",
+METRIC_DEFINE_gauge_int64(xcluster, async_replication_sent_lag_micros,
+    "xCluster Physical Time Lag Last Sent",
     yb::MetricUnit::kMicroseconds,
     "Lag between commit time of last record polled and last record applied on producer.",
     {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
 
-METRIC_DEFINE_gauge_int64(cdc, async_replication_committed_lag_micros,
-    "CDC Physical Time Lag Last Committed",
+METRIC_DEFINE_gauge_int64(xcluster, async_replication_committed_lag_micros,
+    "xCluster Physical Time Lag Last Committed",
     yb::MetricUnit::kMicroseconds, "Lag between last record applied on consumer and producer.",
     {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
 
+METRIC_DEFINE_gauge_bool(xcluster, is_bootstrap_required, "Is Bootstrap Required",
+    yb::MetricUnit::kUnits,
+    "Is bootstrap required for the replication universe.");
+
+METRIC_DEFINE_gauge_uint64(xcluster, last_getchanges_time, "xCluster Last GetChanges Physical Time",
+    yb::MetricUnit::kMicroseconds,
+    "Physical time of the last GetChanges request received from the "
+    "consumer.",
+    {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
+
+METRIC_DEFINE_gauge_int64(xcluster, time_since_last_getchanges,
+    "xCluster Physical Time Last GetChanges",
+    yb::MetricUnit::kMicroseconds,
+    "Physical time ellapsed since the last GetChanges request received from "
+    "the consumer.",
+    {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
+
+METRIC_DEFINE_gauge_uint64(xcluster, last_caughtup_physicaltime,
+    "xCluster Last Caught-up Physical Time.",
+    yb::MetricUnit::kMicroseconds,
+    "Physical Time till which consumer has caught-up with producer.");
+
+// CdcSdk Tablet metrics.
 METRIC_DEFINE_gauge_int64(cdcsdk, cdcsdk_sent_lag_micros, "CDCSDK sent Lag",
     yb::MetricUnit::kMicroseconds,
     "Lag between last committed record in the producer and the last sent record.",
@@ -105,32 +134,10 @@ METRIC_DEFINE_gauge_uint64(cdcsdk, cdcsdk_last_sent_physicaltime, "CDCSDK Last R
     "Physical Time of the Last Read Operation from a CDCSDK GetChanges request",
     {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
 
-METRIC_DEFINE_gauge_bool(cdc, is_bootstrap_required, "Is Bootstrap Required",
-    yb::MetricUnit::kUnits,
-    "Is bootstrap required for the replication universe.");
-
-METRIC_DEFINE_gauge_uint64(cdc, last_getchanges_time, "CDC Last GetChanges Physical Time",
-    yb::MetricUnit::kMicroseconds,
-    "Physical time of the last GetChanges request received from the "
-    "consumer.",
-    {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
-
-METRIC_DEFINE_gauge_int64(cdc, time_since_last_getchanges, "CDC Physical Time Last GetChanges",
-    yb::MetricUnit::kMicroseconds,
-    "Physical time ellapsed since the last GetChanges request received from "
-    "the consumer.",
-    {0 /* zero means we don't expose it as counter */, yb::AggregationFunction::kMax});
-
-METRIC_DEFINE_gauge_uint64(cdc, last_caughtup_physicaltime, "CDC Last Caught-up Physical Time.",
-    yb::MetricUnit::kMicroseconds,
-    "Physical Time till which consumer has caught-up with producer.");
-
 // CDC Server Metrics
 METRIC_DEFINE_counter(server, cdc_rpc_proxy_count, "CDC Rpc Proxy Count", yb::MetricUnit::kRequests,
   "Number of CDC GetChanges requests that required proxy forwarding");
 
-
-
 namespace yb {
 namespace xrepl {
 
diff --git a/src/yb/util/metric_entity.cc b/src/yb/util/metric_entity.cc
index b9c4e758aa..a504c7d0ad 100644
--- a/src/yb/util/metric_entity.cc
+++ b/src/yb/util/metric_entity.cc
@@ -295,7 +295,7 @@ Status MetricEntity::WriteForPrometheus(PrometheusWriter* writer,
     // This is tablet_id in the case of tablet, but otherwise names the server type, eg: yb.master
     prometheus_attr["metric_id"] = id_;
     aggregation_levels = kServerLevel;
-  } else if (strcmp(prototype_->name(), kCdcMetricEntityName) == 0) {
+  } else if (strcmp(prototype_->name(), kXClusterMetricEntityName) == 0) {
     prometheus_attr["table_id"] = attrs["table_id"];
     prometheus_attr["table_name"] = attrs["table_name"];
     prometheus_attr["table_type"] = attrs["table_type"];
diff --git a/src/yb/util/metric_entity.h b/src/yb/util/metric_entity.h
index b0cc748a52..f2ee7a6ba9 100644
--- a/src/yb/util/metric_entity.h
+++ b/src/yb/util/metric_entity.h
@@ -32,7 +32,7 @@
 
 namespace yb {
 
-static const char* const kCdcMetricEntityName = "cdc";
+static const char* const kXClusterMetricEntityName = "xcluster";
 static const char* const kCdcsdkMetricEntityName = "cdcsdk";
 
 class JsonWriter;
diff --git a/src/yb/util/metrics-test.cc b/src/yb/util/metrics-test.cc
index 4f4d0c0bc9..8cc182e425 100644
--- a/src/yb/util/metrics-test.cc
+++ b/src/yb/util/metrics-test.cc
@@ -576,7 +576,7 @@ TEST_F(MetricsTest, TestStreamLevelAggregation) {
   attrs[kLabel] = kLabelVal;
   attrs["stream_id"] = "stream_id_1";
   attrs["table_id"] = "table_id_1";
-  attrs["metric_type"] = kCdcMetricEntityName;
+  attrs["metric_type"] = kXClusterMetricEntityName;
 
   MetricEntity::AttributeMap expected_attrs = attrs;
   expected_attrs.erase("table_id");
@@ -614,8 +614,8 @@ int StringOccurence(const string& s, const string& target) {
 
 METRIC_DEFINE_histogram(server, t_hist, "Test Histogram Label",
     MetricUnit::kMilliseconds, "Test histogram description", 100000000L, 2);
-METRIC_DEFINE_entity(cdc);
-METRIC_DEFINE_event_stats(cdc, t_event_stats, "Test EventStats Label",
+METRIC_DEFINE_entity(xcluster);
+METRIC_DEFINE_event_stats(xcluster, t_event_stats, "Test EventStats Label",
     MetricUnit::kMilliseconds, "Test event stats description");
 METRIC_DEFINE_counter(tablet, t_counter, "Test Counter Label", MetricUnit::kMilliseconds,
     "Test counter description");
@@ -635,15 +635,15 @@ TEST_F(MetricsTest, VerifyHelpAndTypeTags) {
       METRIC_ENTITY_tablet.Instantiate(&registry_, "tablet_entity_id_44", entity_attr);
   auto server_entity = METRIC_ENTITY_server.Instantiate(&registry_, "server_entity_id_45");
   entity_attr["stream_id"] = "stream_id_46";
-  auto cdc_entity =
-      METRIC_ENTITY_cdc.Instantiate(&registry_, "cdc_entity_id_47", entity_attr);
+  auto xcluster_entity =
+      METRIC_ENTITY_xcluster.Instantiate(&registry_, "xcluster_entity_id_47", entity_attr);
   auto cdcsdk_entity =
       METRIC_ENTITY_cdcsdk.Instantiate(&registry_, "cdcsdk_entity_id_48", entity_attr);
 
   scoped_refptr<Gauge> gauge = METRIC_t_gauge.Instantiate(tablet_entity, 0);
   scoped_refptr<Counter> counter = METRIC_t_counter.Instantiate(tablet_entity);
   scoped_refptr<Histogram> hist = METRIC_t_hist.Instantiate(server_entity);
-  scoped_refptr<EventStats> event_stats = METRIC_t_event_stats.Instantiate(cdc_entity);
+  scoped_refptr<EventStats> event_stats = METRIC_t_event_stats.Instantiate(xcluster_entity);
   scoped_refptr<MillisLag> lag = METRIC_t_lag.Instantiate(cdcsdk_entity);
 
   MetricPrometheusOptions opts;
diff --git a/src/yb/util/metrics_writer.cc b/src/yb/util/metrics_writer.cc
index 64e3866ea9..edb12a452f 100644
--- a/src/yb/util/metrics_writer.cc
+++ b/src/yb/util/metrics_writer.cc
@@ -118,12 +118,12 @@ Status PrometheusWriter::WriteSingleEntry(
   auto metric_type = metric_type_it->second;
 
   if (aggregation_levels & kStreamLevel) {
-    DCHECK(metric_type == kCdcMetricEntityName || metric_type == kCdcsdkMetricEntityName);
+    DCHECK(metric_type == kXClusterMetricEntityName || metric_type == kCdcsdkMetricEntityName);
     auto stream_id_it = attr.find("stream_id");
     DCHECK(stream_id_it != attr.end());
     AddAggregatedEntry(stream_id_it->second, attr, name, value, aggregation_function,
         type, description);
-    // Metrics from cdc or cdcsdk entity should only be exposed on stream level.
+    // Metrics from xcluster or cdcsdk entity should only be exposed on stream level.
     DCHECK(aggregation_levels == kStreamLevel);
   }
 
