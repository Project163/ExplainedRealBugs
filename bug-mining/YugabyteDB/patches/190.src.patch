diff --git a/src/yb/master/catalog_manager_ext.cc b/src/yb/master/catalog_manager_ext.cc
index 28386ad7ed..f92ba8922a 100644
--- a/src/yb/master/catalog_manager_ext.cc
+++ b/src/yb/master/catalog_manager_ext.cc
@@ -2300,7 +2300,16 @@ Status CatalogManager::ImportTableEntry(const NamespaceMap& namespace_map,
       scoped_refptr<TableInfo> source_table =
           VERIFY_RESULT(FindTableById(table_data->old_table_id));
       auto source_table_lock = source_table->LockForRead();
-      schema_version = source_table_lock->pb.version() + 1;
+      if (source_table_lock->table_type() == TableType::YQL_TABLE_TYPE &&
+          source_table_lock->is_index()) {
+        // CQL index tables as of November 2024 always have schema version 0 because we do not
+        // support dropping or renaming columns yet. CQL index deletes depend on this because they
+        // implicitly use a schema_version of 0 (by not setting the field in the protobuf write
+        // request). This is checked against the table schema_version when applying the write.
+        SCHECK_EQ(meta.version() == 0, true, IllegalState, "CQL index table should have version 0");
+      } else {
+        schema_version = source_table_lock->pb.version() + 1;
+      }
     } else if (meta.version() > table->LockForRead()->pb.version()) {
       schema_version = meta.version();
     }
diff --git a/src/yb/tools/yb-admin-snapshot-schedule-test.cc b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
index c8d8e2b2e9..72aa5d60f8 100644
--- a/src/yb/tools/yb-admin-snapshot-schedule-test.cc
+++ b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
@@ -935,6 +935,44 @@ TEST_F(YbAdminSnapshotScheduleTest, CloneYcql) {
   ASSERT_EQ(target_rows.size(), 2 * rows_per_iter);
 }
 
+TEST_F(YbAdminSnapshotScheduleTest, DeleteRowsFromCloneYcql) {
+  ASSERT_RESULT(PrepareCql());
+  const auto kSourceNamespace = "ycql." + client::kTableName.namespace_name();
+  const auto kTableName = "test_table";
+
+  auto conn = ASSERT_RESULT(CqlConnect(client::kTableName.namespace_name()));
+  ASSERT_OK(conn.ExecuteQueryFormat(
+      "CREATE TABLE $0(key INT PRIMARY KEY, value INT) WITH TRANSACTIONS = {'enabled' : true};",
+      kTableName));
+  ASSERT_OK(conn.ExecuteQueryFormat(
+      "CREATE INDEX idx ON $0(value) WITH TRANSACTIONS = {'enabled' : true};",
+      kTableName));
+  ASSERT_OK(conn.ExecuteQueryFormat("INSERT INTO $0(key, value) VALUES (1, 2)", kTableName));
+
+  // Create a window to restore in (we can only restore with 1s granularity).
+  SleepFor(3s);
+  Timestamp restore_time(ASSERT_RESULT(WallClock()->Now()).time_point);
+  SleepFor(3s);
+
+  ASSERT_OK(conn.ExecuteQueryFormat("DELETE FROM $0 WHERE key=1", kTableName));
+
+  const auto kTargetNamespace = "cloned";
+  ASSERT_OK(cluster_->SetFlagOnMasters("allowed_preview_flags_csv", "enable_db_clone"));
+  ASSERT_OK(cluster_->SetFlagOnMasters("enable_db_clone", "true"));
+  ASSERT_OK(CloneAndWait(
+      kSourceNamespace, kTargetNamespace, 30s /* timeout */,
+      restore_time.ToFormattedString()));
+
+  auto target_conn = ASSERT_RESULT(CqlConnect(kTargetNamespace));
+  auto row_count = ASSERT_RESULT(target_conn.ExecuteWithResult(
+      Format("SELECT COUNT(*) FROM $0", kTableName)));
+  ASSERT_EQ(row_count.RenderToString(), "1");
+  ASSERT_OK(target_conn.ExecuteQueryFormat("DELETE FROM $0 WHERE key=1", kTableName));
+  row_count = ASSERT_RESULT(target_conn.ExecuteWithResult(
+      Format("SELECT COUNT(*) FROM $0", kTableName)));
+  ASSERT_EQ(row_count.RenderToString(), "0");
+}
+
 TEST_F(YbAdminSnapshotScheduleTest, CreateIntervalZero) {
   ASSERT_OK(PrepareCommon());
   ASSERT_OK(client_->CreateNamespaceIfNotExists(
