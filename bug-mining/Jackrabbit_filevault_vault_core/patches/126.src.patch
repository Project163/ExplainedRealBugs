diff --git a/vault-core/pom.xml b/vault-core/pom.xml
index 42e8c4e0..80c26a2e 100644
--- a/vault-core/pom.xml
+++ b/vault-core/pom.xml
@@ -368,6 +368,10 @@
                     <plugin>
                         <artifactId>maven-failsafe-plugin</artifactId>
                         <configuration>
+                            <systemPropertyVariables>
+                                <oak>false</oak>
+                            </systemPropertyVariables>
+                            <argLine>@{jacoco.command} -Xmx1024m</argLine>
                             <reportNameSuffix>JR</reportNameSuffix>
                         </configuration>
                         <executions>
@@ -420,10 +424,14 @@
                                     <goal>integration-test</goal>
                                 </goals>
                                 <configuration>
+                                    <systemPropertyVariables>
+                                        <oak>false</oak>
+                                        <repoIndex>${surefire.forkNumber}</repoIndex>
+                                    </systemPropertyVariables>
                                     <reportNameSuffix>JR</reportNameSuffix>
                                     <summaryFile>${project.build.directory}/failsafe-reports/failsafe-summary-jr.xml</summaryFile>
-                                    <forkCount>4</forkCount>
-                                    <reuseForks>true</reuseForks>
+                                    <!-- <forkCount>4</forkCount>
+                                    <reuseForks>true</reuseForks> -->
                                 </configuration>
                             </execution>
                             <execution>
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportMode.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportMode.java
index e19418b6..6e47c304 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportMode.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportMode.java
@@ -20,6 +20,21 @@ package org.apache.jackrabbit.vault.fs.api;
 /**
  * {@code ImportMode} is used to define how importing content is applied
  * to the existing content in the repository.
+ * 
+ * <table border="1">
+ * <caption>"Import Mode Effects"</caption>
+ * <tr><th rowspan="2">Import Mode</th><th colspan="3">Property/Node (at a specific path)</th></tr>
+ * <tr><th>In Package</th><th>In Repository Before Installation</th><th>In Repository After Installation</th></tr>
+ * <tr><td rowspan="3">{@link #REPLACE}</td><td>non-existing</td><td>existing</td><td>removed</td></tr>
+ * <tr><td>existing</td><td>existing</td><td>replaced</td></tr>
+ * <tr><td>existing</td><td>non-existing</td><td>created</td></tr>
+ * <tr><td rowspan="3">{@link #MERGE_PROPERTIES}</td><td>non-existing</td><td>existing</td><td>not touched</td></tr>
+ * <tr><td>existing</td><td>existing</td><td>not touched</td></tr>
+ * <tr><td>existing</td><td>non-existing</td><td>created</td></tr>
+ * <tr><td rowspan="3">{@link #UPDATE_PROPERTIES}</td><td>non-existing</td><td>existing</td><td>not touched</td></tr>
+ * <tr><td>existing</td><td>existing</td><td>replaced</td></tr>
+ * <tr><td>existing</td><td>non-existing</td><td>created</td></tr>
+ * </table>
  */
 public enum ImportMode {
 
@@ -31,12 +46,43 @@ public enum ImportMode {
 
     /**
      * Existing content is not modified, i.e. only new content is added and
-     * none is deleted or modified.
+     * none is deleted or modified
+     * <p>
+     * <strong>Only considered for</strong>
+     * <ul>
+     * <li>Binaries: they will never be imported if the parent node has this import mode.</li>
+     * <li>Authorizable nodes: only {@code rep:members} of existing authorizables is updated, no other property on those node types is added/modified.</li>
+     * <li>Simple files: i.e. they will never be imported in case the repo has this file already.
+     * <li>Other docview files: It will ignore them in case the docview's root node does already exist in the repo (both full coverage and .content.xml). It skips non-existing child nodes/properties in the docview as well.</li>
+     * </ul>
+     * 
+     * @deprecated As this behaves inconsistently for the different serialization formats, rather use {@link #MERGE_PROPERTIES}.
      */
+    @Deprecated()
     MERGE,
 
     /**
-     * Existing content is updated, new content is added and none is deleted.
+     * Existing properties are replaced (except for {@code jcr:primaryType}), new properties and nodes are added and no existing properties or nodes are deleted. 
+     * <strong>Only affects authorizable nodes (not their child nodes). Other nodes are imported in mode {@link #REPLACE}.</strong>
+     * @deprecated rather use {@link #UPDATE_PROPERTIES}
      */
-    UPDATE
+    @Deprecated()
+    UPDATE,
+
+    /**
+     * Existing properties are not touched, new nodes/properties are added, no existing nodes/properties are deleted
+     * The only existing properties potentially touched is the multi value property {@code jcr:mixinType}. 
+     * As the primary type is never changed
+     * it will skip new properties/nodes which are not allowed by the node type definition of primary + mixin types.
+     * Authorizable nodes: only {@code rep:members} of existing authorizables is updated, no other property on those node types is added/modified.
+     */
+    MERGE_PROPERTIES,
+
+    /**
+     * Existing properties are replaced, new nodes/properties are added, no existing nodes/properties are deleted
+     * Existing multi-value properties are replaced and not extended except for {@code jcr:mixinType} which is extended.
+     * As the primary type is never changed
+     * it will skip new properties/child nodes which are not allowed by the node type definition of primary + mixin types.
+     */
+    UPDATE_PROPERTIES
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/package-info.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/package-info.java
index 39956108..38c42652 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/package-info.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/package-info.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-@Version("2.8.0")
+@Version("2.9.0")
 package org.apache.jackrabbit.vault.fs.api;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/TransactionImpl.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/TransactionImpl.java
index 4d364089..c923e78a 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/TransactionImpl.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/TransactionImpl.java
@@ -46,6 +46,7 @@ import org.apache.jackrabbit.vault.fs.impl.io.InputSourceArtifact;
 import org.apache.jackrabbit.vault.fs.impl.io.XmlAnalyzer;
 import org.apache.jackrabbit.vault.fs.io.AutoSave;
 import org.apache.jackrabbit.vault.fs.io.DocViewAnalyzerListener;
+import org.apache.jackrabbit.vault.fs.io.Importer;
 import org.apache.jackrabbit.vault.util.Constants;
 import org.apache.jackrabbit.vault.util.PathComparator;
 import org.apache.jackrabbit.vault.util.PathUtil;
@@ -56,9 +57,10 @@ import org.slf4j.LoggerFactory;
 
 /**
  * Provides transactional brackets around a write back transaction to
- * the Vault filesystem. a transaction is always needed due to the fact that
+ * the Vault filesystem. A transaction is always needed due to the fact that
  * several jcr files could belong to the same artifact.
- *
+ * This is only used from Vault CLI but not during package import which uses the {@link Importer} instead.
+ * 
  * TODO: check all vault operations!
  *
  */
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
index 383ff90f..57997516 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
@@ -43,7 +43,12 @@ import javax.jcr.RepositoryException;
 import javax.jcr.Session;
 import javax.jcr.Value;
 import javax.jcr.ValueFactory;
+import javax.jcr.ValueFormatException;
+import javax.jcr.lock.LockException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
 import javax.jcr.nodetype.NodeType;
+import javax.jcr.version.VersionException;
 
 import org.apache.jackrabbit.spi.Name;
 import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
@@ -71,6 +76,7 @@ import org.apache.jackrabbit.vault.util.MimeTypes;
 import org.apache.jackrabbit.vault.util.RejectingEntityDefaultHandler;
 import org.apache.jackrabbit.util.Text;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.Attributes;
@@ -106,6 +112,8 @@ import org.xml.sax.helpers.AttributesImpl;
  */
 public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements NamespaceResolver {
 
+    private static final String PROP_OAK_COUNTER = "oak:counter";
+
     /**
      * the default logger
      */
@@ -130,13 +138,13 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
         props.add(JcrConstants.JCR_PREDECESSORS);
         props.add(JcrConstants.JCR_SUCCESSORS);
         props.add(JcrConstants.JCR_VERSIONHISTORY);
-        props.add("oak:counter");
+        props.add(PROP_OAK_COUNTER);
         PROTECTED_PROPERTIES = Collections.unmodifiableSet(props);
     }
 
     static {
         Set<String> props = new HashSet<String>();
-        props.add("oak:counter");
+        props.add(PROP_OAK_COUNTER);
         IGNORED_PROPERTIES = Collections.unmodifiableSet(props);
     }
 
@@ -190,12 +198,12 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
     /**
      * map of hint nodes in the same artifact set
      */
-    private Set<String> hints = new HashSet<String>();
+    private Set<String> hints = new HashSet<>();
 
     /**
      * properties that should not be deleted
      */
-    private Set<String> saveProperties = new HashSet<String>();
+    private Set<String> preserveProperties = new HashSet<>();
 
     /**
      * the default name path resolver
@@ -319,14 +327,14 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
         if (a.getType() == ArtifactType.FILE && a instanceof PropertyValueArtifact) {
             // hack, mark "file" properties just as present
             String parentPath = ((PropertyValueArtifact) a).getProperty().getParent().getPath();
-            saveProperties.add(parentPath + "/" + JcrConstants.JCR_DATA);
-            saveProperties.add(parentPath + "/" + JcrConstants.JCR_LASTMODIFIED);
+            preserveProperties.add(parentPath + "/" + JcrConstants.JCR_DATA);
+            preserveProperties.add(parentPath + "/" + JcrConstants.JCR_LASTMODIFIED);
         } else {
-            saveProperties.add(path);
+            preserveProperties.add(path);
             // hack, mark "file" properties just as present
-            saveProperties.add(path + "/jcr:content/jcr:data");
-            saveProperties.add(path + "/jcr:content/jcr:lastModified");
-            saveProperties.add(path + "/jcr:content/jcr:mimeType");
+            preserveProperties.add(path + "/jcr:content/jcr:data");
+            preserveProperties.add(path + "/jcr:content/jcr:lastModified");
+            preserveProperties.add(path + "/jcr:content/jcr:mimeType");
             String parentPath = Text.getRelativeParent(path, 1);
             String name = Text.getName(path);
             Map<String, DocViewSAXImporter.BlobInfo> infoSet = binaries.get(parentPath);
@@ -642,19 +650,21 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                     log.trace("Skipping ignored element {}", name);
                 }
             } else {
+                final String path = (!node.getPath().equals("/") ? node.getPath() : "")+ "/" + name;
                 if (attributes.getLength() == 0) {
                     // only ordering node. skip
-                    log.trace("Skipping empty node {}", node.getPath() + "/" + name);
+                    log.trace("Skipping empty node {}", path);
                     stack = stack.push();
                 } else if (snsNode) {
                     // skip SNS nodes with index > 1
-                    log.warn("Skipping unsupported SNS node with index > 1. Some content will be missing after import: {}", node.getPath() + "/" + label);
+                    log.warn("Skipping unsupported SNS node with index > 1. Some content will be missing after import: {}", path);
                     stack = stack.push();
                 } else {
                     try {
-                        AccessControlHandling acHandling = getAcHandling(label);
                         DocViewNode ni = new DocViewNode(name, label, attributes, npResolver);
+                        // is policy node?
                         if (aclManagement.isACLNodeType(ni.primary)) {
+                            AccessControlHandling acHandling = getAcHandling(label);
                             if (acHandling != AccessControlHandling.CLEAR && acHandling != AccessControlHandling.IGNORE) {
                                 log.trace("Access control policy element detected. starting special transformation {}/{}", node.getPath(), name);
                                 if (aclManagement.ensureAccessControllable(node, ni.primary)) {
@@ -676,25 +686,28 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                                 stack = stack.push();
                             }
                         } else if (userManagement != null && userManagement.isAuthorizableNodeType(ni.primary)) {
+                            // is authorizable node?
                             handleAuthorizable(node, ni);
                         } else {
+                            // regular node
                             stack = stack.push(addNode(ni));
                         }
-                    } catch (RepositoryException e) {
-                        String errPath = node.getPath();
-                        if (errPath.length() > 1) {
-                            errPath += "/";
+                    } catch (RepositoryException | IOException e) {
+                        if (e instanceof ConstraintViolationException && wspFilter.getImportMode(path) != ImportMode.REPLACE) {
+                            // only warn in case of constraint violations for mode != replace (as best effort is used in that case)
+                            log.warn("Error during processing of {}: {}, skip node due to import mode {}", path, e.toString(), wspFilter.getImportMode(path));
+                            importInfo.onNop(path);
+                        } else {
+                            log.error("Error during processing of {}: {}", path, e.toString());
+                            importInfo.onError(path, e);
                         }
-                        errPath += name;
-                        log.error("Error during processing of {}: {}", errPath, e.toString());
-                        importInfo.onError(errPath, e);
                         stack = stack.push();
                     }
                 }
             }
-        } catch (Exception e) {
-            throw new SAXException(e);
-        }
+        }  catch (RepositoryException e) {
+            throw new SAXException("Fatal exception while parsing", e);
+        } 
     }
 
     /**
@@ -718,7 +731,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             // just import the authorizable node
             log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
             stack = stack.push();
-            stack.adapter = new JcrSysViewTransformer(node);
+            stack.adapter = new JcrSysViewTransformer(node, wspFilter.getImportMode(newPath));
             stack.adapter.startNode(ni);
             importInfo.onCreated(newPath);
             return;
@@ -745,6 +758,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
 
         switch (mode) {
             case MERGE:
+            case MERGE_PROPERTIES:
                 // remember desired memberships.
                 // todo: how to deal with multi-node memberships? see JCRVLT-69
                 DocViewProperty prop = ni.props.get("rep:members");
@@ -761,15 +775,16 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                 // just replace the entire subtree for now.
                 log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
                 stack = stack.push();
-                stack.adapter = new JcrSysViewTransformer(node);
+                stack.adapter = new JcrSysViewTransformer(node, mode);
                 stack.adapter.startNode(ni);
                 importInfo.onReplaced(newPath);
                 break;
 
             case UPDATE:
+            case UPDATE_PROPERTIES:
                 log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
                 stack = stack.push();
-                stack.adapter = new JcrSysViewTransformer(node, oldPath);
+                stack.adapter = new JcrSysViewTransformer(node, oldPath, mode);
                 // we need to tweak the ni.name so that the sysview import does not
                 // rename the authorizable node name
                 String newName = Text.getName(oldPath);
@@ -781,7 +796,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                         ni.mixins,
                         ni.primary
                 );
-                // but we need to be augment with a potential rep:authorizableId
+                // but we need to augment with a potential rep:authorizableId
                 if (authNode.hasProperty("rep:authorizableId")) {
                     DocViewProperty authId = new DocViewProperty(
                             "rep:authorizableId",
@@ -847,12 +862,15 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             oldNode = null;
         }
 
+        // TODO: under which condition do we end up here?
         if (oldNode != null) {
             // check versionable
             new VersioningState(stack, oldNode).ensureCheckedOut();
 
-            ChildNodeStash recovery = new ChildNodeStash(session);
-            recovery.stashChildren(oldNode);
+            String oldNodePath = oldNode.getPath();
+            ImportMode importMode = wspFilter.getImportMode(oldNodePath);
+            NodeStash recovery = new NodeStash(session, oldNodePath, importMode);
+            recovery.stash();
 
             // ensure that existing binaries are not sourced from a property
             // that is about to be removed
@@ -865,10 +883,10 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
 
             oldNode.remove();
             // now create the new node
-            node = createNode(currentNode, ni);
+            node = createNewNode(currentNode, ni);
 
             // move the children back
-            recovery.recoverChildren(node, importInfo);
+            recovery.recover(importInfo);
 
             importInfo.onReplaced(node.getPath());
             return new StackElement(node, false);
@@ -879,8 +897,8 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
         boolean isCheckedIn = coProp != null && "false".equals(coProp.values[0]);
 
         // create or update node
-        boolean isNew = false;
-        if (node == null) {
+        boolean isNew = node == null;
+        if (isNew) {
             // workaround for bug in jcr2spi if mixins are empty
             if (!ni.props.containsKey(JcrConstants.JCR_MIXINTYPES)) {
                 ni.props.put(JcrConstants.JCR_MIXINTYPES,
@@ -888,7 +906,10 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             }
 
             stack.ensureCheckedOut();
-            node = createNode(currentNode, ni);
+            node = createNewNode(currentNode, ni);
+            if (node.getDefinition() == null) {
+                throw new RepositoryException("Child node not allowed.");
+            }
             if (node.isNodeType(JcrConstants.NT_RESOURCE)) {
                 if (!node.hasProperty(JcrConstants.JCR_DATA)) {
                     importInfo.onMissing(node.getPath() + "/" + JcrConstants.JCR_DATA);
@@ -898,53 +919,56 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                 importInfo.registerToVersion(node.getPath());
             }
             importInfo.onCreated(node.getPath());
-            isNew = true;
 
         } else if (isIncluded(node, node.getDepth() - rootDepth)) {
-            boolean modified = false;
-
             if (isCheckedIn) {
                 // don't rely on isVersionable here, since SPI might not have this info yet
                 importInfo.registerToVersion(node.getPath());
             }
-            VersioningState vs = new VersioningState(stack, node);
-
-            // set new primary type (but never set rep:root)
-            if (!"rep:root".equals(ni.primary)) {
-                if (!node.getPrimaryNodeType().getName().equals(ni.primary)) {
-                    vs.ensureCheckedOut();
-                    node.setPrimaryType(ni.primary);
-                    modified = true;
+            ImportMode importMode = wspFilter.getImportMode(node.getPath());
+            if (updateExistingNode(node, ni, importMode)) {
+                if (node.isNodeType(JcrConstants.NT_RESOURCE)) {
+                    if (!node.hasProperty(JcrConstants.JCR_DATA)) {
+                        importInfo.onMissing(node.getPath() + "/" + JcrConstants.JCR_DATA);
+                    }
                 }
+                importInfo.onModified(node.getPath());
+            } else {
+                importInfo.onNop(node.getPath());
             }
+        } else {
+            // remove registered binaries outside of the filter (JCR-126)
+            binaries.remove(node.getPath());
+        }
+        return new StackElement(node, isNew);
+    }
 
-            // remove the 'system' properties from the set
-            ni.props.remove(JcrConstants.JCR_PRIMARYTYPE);
-            ni.props.remove(JcrConstants.JCR_MIXINTYPES);
-            ni.props.remove(JcrConstants.JCR_UUID);
-            ni.props.remove(JcrConstants.JCR_BASEVERSION);
-            ni.props.remove(JcrConstants.JCR_PREDECESSORS);
-            ni.props.remove(JcrConstants.JCR_SUCCESSORS);
-            ni.props.remove(JcrConstants.JCR_VERSIONHISTORY);
-
-            // adjust mixins
-            Set<String> newMixins = new HashSet<String>();
-            boolean isAtomicCounter = false;
-            AccessControlHandling acHandling = getAcHandling(ni.name);
-            if (ni.mixins != null) {
-                for (String mixin : ni.mixins) {
-                    // omit name if mix:AccessControllable and CLEAR
-                    if (!aclManagement.isAccessControllableMixin(mixin)
-                            || acHandling != AccessControlHandling.CLEAR) {
-                        newMixins.add(mixin);
-
-                        if ("mix:atomicCounter".equals(mixin)) {
-                            isAtomicCounter = true;
-                        }
-                    }
+    private boolean updateExistingNode(@NotNull Node node, @NotNull DocViewNode ni, @NotNull ImportMode importMode) throws RepositoryException {
+        VersioningState vs = new VersioningState(stack, node);
+        boolean modified = false;
+        // set new primary type (but never set rep:root)
+        if (importMode == ImportMode.REPLACE && !"rep:root".equals(ni.primary)) {
+            if (!node.getPrimaryNodeType().getName().equals(ni.primary)) {
+                vs.ensureCheckedOut();
+                node.setPrimaryType(ni.primary);
+                modified = true;
+            }
+        }
+
+        // calculate mixins
+        Set<String> newMixins = new HashSet<>();
+        AccessControlHandling acHandling = getAcHandling(ni.name);
+        if (ni.mixins != null) {
+            for (String mixin : ni.mixins) {
+                // omit name if mix:AccessControllable and CLEAR
+                if (!aclManagement.isAccessControllableMixin(mixin)
+                        || acHandling != AccessControlHandling.CLEAR) {
+                    newMixins.add(mixin);
                 }
             }
-            // remove mixin not in package
+        }
+        // remove mixin not in package
+        if (importMode == ImportMode.REPLACE) {
             for (NodeType mix : node.getMixinNodeTypes()) {
                 String name = mix.getName();
                 if (!newMixins.remove(name)) {
@@ -958,22 +982,24 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                     }
                 }
             }
+        }
+        
+        // add remaining mixins (for all import modes)
+        for (String mixin : newMixins) {
+            vs.ensureCheckedOut();
+            node.addMixin(mixin);
+            modified = true;
+        }
 
-            // add remaining mixins
-            for (String mixin : newMixins) {
-                vs.ensureCheckedOut();
-                node.addMixin(mixin);
-                modified = true;
-            }
-
-            // remove properties not in the set
+        // remove properties not in package
+        if (importMode == ImportMode.REPLACE) {
             PropertyIterator pIter = node.getProperties();
             while (pIter.hasNext()) {
                 Property p = pIter.nextProperty();
                 String propName = p.getName();
                 if (!PROTECTED_PROPERTIES.contains(propName)
                         && !ni.props.containsKey(propName)
-                        && !saveProperties.contains(p.getPath())
+                        && !preserveProperties.contains(p.getPath())
                         && wspFilter.includesProperty(p.getPath())) {
                     try {
                         vs.ensureCheckedOut();
@@ -984,56 +1010,19 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                     }
                 }
             }
-            // add properties
-            for (DocViewProperty prop : ni.props.values()) {
-                if (prop != null && !PROTECTED_PROPERTIES.contains(prop.name)) {
-                    try {
-                        modified |= prop.apply(node);
-                    } catch (RepositoryException e) {
-                        try {
-                            // try again with checked out node
-                            vs.ensureCheckedOut();
-                            modified |= prop.apply(node);
-                        } catch (RepositoryException e1) {
-                            log.warn("Error while setting property (ignore): " + e1);
-                        }
-                    }
-                }
-            }
-            // adjust oak atomic counter
-            if (isAtomicCounter) {
-                long previous = 0;
-                if (node.hasProperty("oak:counter")) {
-                    previous = node.getProperty("oak:counter").getLong();
-                }
-                long counter = 0;
-                try {
-                    counter = Long.valueOf(ni.getValue("oak:counter"));
-                } catch (NumberFormatException e) {
-                    // ignore
-                }
-                node.setProperty("oak:increment", counter - previous);
-                modified = true;
-            }
-
-            if (modified) {
-                if (node.isNodeType(JcrConstants.NT_RESOURCE)) {
-                    if (!node.hasProperty(JcrConstants.JCR_DATA)) {
-                        importInfo.onMissing(node.getPath() + "/" + JcrConstants.JCR_DATA);
-                    }
-                }
-                importInfo.onModified(node.getPath());
-            } else {
-                importInfo.onNop(node.getPath());
-            }
-        } else {
-            // remove registered binaries outside of the filter (JCR-126)
-            binaries.remove(node.getPath());
         }
-        return new StackElement(node, isNew);
+        // add/modify properties contained in package
+        modified |= setUnprotectedProperties(node, ni, importMode == ImportMode.REPLACE|| importMode == ImportMode.UPDATE || importMode == ImportMode.UPDATE_PROPERTIES, vs);
+        return modified;
     }
-
-    private Node createNode(Node currentNode, DocViewNode ni)
+    /**
+     * Creates a new node via system view XML and {@link Session#importXML(String, InputStream, int)} to be able to set protected properties as well
+     * @param currentNode
+     * @param ni
+     * @return
+     * @throws RepositoryException
+     */
+    private @NotNull Node createNewNode(Node currentNode, DocViewNode ni)
             throws RepositoryException {
         try {
             String parentPath = currentNode.getPath();
@@ -1049,7 +1038,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             AttributesImpl attrs = new AttributesImpl();
             attrs.addAttribute(Name.NS_SV_URI, "name", "sv:name", "CDATA", ni.name);
             handler.startElement(Name.NS_SV_URI, "node", "sv:node", attrs);
-
+    
             // check if SNS and a helper uuid if needed
             boolean addMixRef = false;
             if (!ni.label.equals(ni.name) && ni.uuid == null) {
@@ -1100,65 +1089,26 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             handler.endDocument();
 
             // retrieve newly created node either by uuid, label or name
-            Node node = null;
-            if (ni.uuid != null) {
-                try {
-                    node = currentNode.getSession().getNodeByUUID(ni.uuid);
-                } catch (RepositoryException e) {
-                    log.warn("Newly created node not found by uuid {}: {}", parentPath + "/" + ni.name, e.toString());
-                }
-            }
-            if (node == null) {
-                try {
-                    node = currentNode.getNode(ni.label);
-                } catch (RepositoryException e) {
-                    log.warn("Newly created node not found by label {}: {}", parentPath + "/" + ni.name, e.toString());
-                }
-            }
-            if (node == null) {
-                try {
-                    node = currentNode.getNode(ni.name);
-                } catch (RepositoryException e) {
-                    log.warn("Newly created node not found by name {}: {}", parentPath + "/" + ni.name, e.toString());
-                    throw e;
-                }
-            }
-
-            // handle non protected properties
-            for (DocViewProperty p : ni.props.values()) {
-                if (p != null && p.values != null) {
-                    if (!PROTECTED_PROPERTIES.contains(p.name)) {
-                        try {
-                            p.apply(node);
-                        } catch (RepositoryException e) {
-                            log.warn("Error while setting property (ignore): " + e);
-                        }
-                    }
-                }
-            }
-
-            // check for atomic counter
-            if (ni.mixins != null) {
-                for (String mixin : ni.mixins) {
-                    if ("mix:atomicCounter".equals(mixin)) {
-                        String counter = ni.getValue("oak:counter");
-                        if (counter != null) {
-                            node.setProperty("oak:increment", counter, PropertyType.LONG);
-                        }
-                        break;
-                    }
-                }
-            }
-
+            Node node = getNodeByUUIDLabelOrName(currentNode, ni);
+            setUnprotectedProperties(node, ni, true, null);
             // remove mix referenceable if it was temporarily added
             if (addMixRef) {
                 node.removeMixin(JcrConstants.MIX_REFERENCEABLE);
             }
             return node;
-
+    
         } catch (SAXException e) {
             Exception root = e.getException();
             if (root instanceof RepositoryException) {
+                if (root instanceof ConstraintViolationException) {
+                    // potentially rollback changes in the transient space (only relevant for Oak, https://issues.apache.org/jira/browse/OAK-9436), as otherwise the same exception is thrown again at Session.save()
+                    try {
+                        Node node = getNodeByUUIDLabelOrName(currentNode, ni);
+                        node.remove();
+                    } catch (RepositoryException re) {
+                        // ignore as no node found when the transient space is clean already
+                    }
+                }
                 throw (RepositoryException) root;
             } else if (root instanceof RuntimeException) {
                 throw (RuntimeException) root;
@@ -1168,6 +1118,85 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
         }
     }
 
+    private Node getNodeByUUIDLabelOrName(@NotNull Node currentNode, @NotNull DocViewNode ni) throws RepositoryException {
+        Node node = null;
+        if (ni.uuid != null) {
+            try {
+                node = currentNode.getSession().getNodeByUUID(ni.uuid);
+            } catch (RepositoryException e) {
+                log.warn("Newly created node not found by uuid {}: {}", currentNode.getPath() + "/" + ni.name, e.toString());
+            }
+        }
+        if (node == null) {
+            try {
+                node = currentNode.getNode(ni.label);
+            } catch (RepositoryException e) {
+                log.warn("Newly created node not found by label {}: {}", currentNode.getPath() + "/" + ni.name, e.toString());
+            }
+        }
+        if (node == null) {
+            try {
+                node = currentNode.getNode(ni.name);
+            } catch (RepositoryException e) {
+                log.warn("Newly created node not found by name {}: {}", currentNode.getPath() + "/" + ni.name, e.toString());
+                throw e;
+            }
+        }
+        return node;
+    }
+
+    private boolean setUnprotectedProperties(@NotNull Node node, @NotNull DocViewNode ni, boolean overwriteExistingProperties, @Nullable VersioningState vs) throws RepositoryException {
+        boolean isAtomicCounter = false;
+        if (ni.mixins != null) {
+            for (String mixin : ni.mixins) {
+                if ("mix:atomicCounter".equals(mixin)) {
+                    isAtomicCounter = true;
+                }
+            }
+        }
+        boolean modified = false;
+        // add properties
+        for (DocViewProperty prop : ni.props.values()) {
+            if (prop != null && !PROTECTED_PROPERTIES.contains(prop.name) && (overwriteExistingProperties || !node.hasProperty(prop.name)) && wspFilter.includesProperty(node.getPath() + "/" + prop.name)) {
+                // check if property is allowed
+                try {
+                    modified |= prop.apply(node);
+                } catch (RepositoryException e) {
+                    if (vs == null) {
+                        throw e;
+                    }
+                    try {
+                        // try again with checked out node
+                        vs.ensureCheckedOut();
+                        modified |= prop.apply(node);
+                    } catch (RepositoryException e1) {
+                        log.warn("Error while setting property (ignore): " + e1);
+                        continue;
+                    }
+                }
+            }
+        }
+
+        // adjust oak atomic counter
+        if (isAtomicCounter && wspFilter.includesProperty(node.getPath() + "/" + PROP_OAK_COUNTER)) {
+            long previous = 0;
+            if (node.hasProperty(PROP_OAK_COUNTER)) {
+                previous = node.getProperty(PROP_OAK_COUNTER).getLong();
+            }
+            long counter = 0;
+            try {
+                counter = Long.valueOf(ni.getValue(PROP_OAK_COUNTER));
+            } catch (NumberFormatException e) {
+                // ignore
+            }
+            if (counter != previous) {
+                node.setProperty("oak:increment", counter - previous);
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FileArtifactHandler.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FileArtifactHandler.java
index 516b08d0..10d57731 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FileArtifactHandler.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FileArtifactHandler.java
@@ -32,6 +32,7 @@ import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
+import org.apache.jackrabbit.util.Text;
 import org.apache.jackrabbit.vault.fs.api.Artifact;
 import org.apache.jackrabbit.vault.fs.api.ArtifactType;
 import org.apache.jackrabbit.vault.fs.api.ImportArtifact;
@@ -44,7 +45,6 @@ import org.apache.jackrabbit.vault.fs.impl.ArtifactSetImpl;
 import org.apache.jackrabbit.vault.util.JcrConstants;
 import org.apache.jackrabbit.vault.util.MimeTypes;
 import org.apache.jackrabbit.vault.util.PathUtil;
-import org.apache.jackrabbit.util.Text;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
@@ -153,6 +153,7 @@ public class FileArtifactHandler extends AbstractArtifactHandler  {
                     mode = wspFilter.getImportMode(path);
                 }
                 // only update if not MERGE (i.e. is REPLACE or UPDATE)
+                // this is for maintaining backwards-compatibility the rest of the import modes are evaluated in DocViewSAXImporter
                 if (mode != ImportMode.MERGE) {
                     InputSource source = primary.getInputSource();
                     if (source != null) {
@@ -179,7 +180,8 @@ public class FileArtifactHandler extends AbstractArtifactHandler  {
                         if (file instanceof ImportArtifact) {
                             Node fileNode = parent.getNode(fileName);
                             // check import mode, only replace if not MERGE
-                            if (wspFilter.getImportMode(fileNode.getPath()) != ImportMode.MERGE) {
+                            ImportMode mode = wspFilter.getImportMode(fileNode.getPath());
+                            if (mode != ImportMode.MERGE && mode != ImportMode.MERGE_PROPERTIES) {
                                 if (!fileNode.hasNode(Node.JCR_CONTENT)) {
                                     // apparently no nt:file, recreate file node
                                     fileNode.remove();
@@ -203,7 +205,8 @@ public class FileArtifactHandler extends AbstractArtifactHandler  {
                         }
                     }
                 } else if (file.getSerializationType() == SerializationType.XML_DOCVIEW) {
-                    // special case for full coverage files below a intermediate node
+                    // special case for full coverage files below an intermediate node
+                    // this is never used from {@link Importer} but only from {@link TransactionImpl}
                     String relPath = Text.getRelativeParent(file.getRelativePath(), 1);
                     String newName = Text.getName(file.getRelativePath());
                     Node newParent = parent;
@@ -256,8 +259,9 @@ public class FileArtifactHandler extends AbstractArtifactHandler  {
                     parentNode = parent.getNode(path.substring(0, idx));
                     path = path.substring(idx + 1);
                 }
-                // only update binary if import mode is not MERGE
-                if (wspFilter.getImportMode(parentNode.getPath()) != ImportMode.MERGE) {
+                // only update binary if import mode is not MERGE (because binaries have only mandatory properties)
+                ImportMode mode = wspFilter.getImportMode(parentNode.getPath());
+                if (mode != ImportMode.MERGE && mode != ImportMode.MERGE_PROPERTIES) {
                     Value value = factory.createValue(binary.getInputStream());
                     if (!parentNode.hasProperty(path)
                             || !value.equals(parentNode.getProperty(path).getValue())) {
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
index 1e637e76..9dd27d0a 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
@@ -23,6 +23,8 @@ import java.util.Set;
 
 import javax.jcr.Node;
 import javax.jcr.NodeIterator;
+import javax.jcr.Property;
+import javax.jcr.PropertyIterator;
 import javax.jcr.RepositoryException;
 
 import org.apache.jackrabbit.vault.fs.api.Artifact;
@@ -104,7 +106,7 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
 
             Node node = parent.getNode(dir.getRelativePath());
             if (wspFilter.contains(node.getPath()) && !nodeType.equals(node.getPrimaryNodeType().getName())) {
-                node = modifyPrimaryType(node, info);
+                modifyPrimaryType(node, info);
             }
             NodeIterator iter = node.getNodes();
             while (iter.hasNext()) {
@@ -138,23 +140,26 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
         return info;
     }
 
-    private Node modifyPrimaryType(Node node, ImportInfoImpl info) throws RepositoryException {
-        String name = node.getName();
-        Node parent = node.getParent();
-
+    /**
+     * This is potentially a destructive operation as it will remove all (non-protected) properties before doing the conversion
+     * @param node
+     * @param info
+     * @throws RepositoryException
+     */
+    private void modifyPrimaryType(Node node, ImportInfoImpl info) throws RepositoryException {
         // check versionable
         ensureCheckedOut(node, info);
 
-        ChildNodeStash recovery = new ChildNodeStash(node.getSession());
-        recovery.stashChildren(node);
-        node.remove();
-        
-        // now create the new node
-        Node newNode = parent.addNode(name, nodeType);
-        info.onReplaced(newNode.getPath());
-        // move the children back
-        recovery.recoverChildren(newNode, info);
-        return newNode;
+        // remove all non-allowed properties
+        PropertyIterator propertyIterator = node.getProperties();
+        while (propertyIterator.hasNext()) {
+            Property property = propertyIterator.nextProperty();
+            if (!property.getDefinition().isProtected()) {
+                property.remove();
+            }
+        }
+        node.setPrimaryType(nodeType);
+       
     }
 
     private void ensureCheckedOut(Node node, ImportInfoImpl info) throws RepositoryException {
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
index cee7bd96..0fce44ee 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
@@ -20,7 +20,6 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.Stack;
 
 import javax.jcr.ImportUUIDBehavior;
 import javax.jcr.Node;
@@ -30,8 +29,11 @@ import javax.jcr.RepositoryException;
 import javax.jcr.Session;
 
 import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.vault.fs.api.ImportMode;
 import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.util.DocViewProperty;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.ContentHandler;
@@ -59,7 +61,7 @@ public class JcrSysViewTransformer implements DocViewAdapter {
     /**
      * temporary recovery helper when 'rescuing' the child nodes
      */
-    private ChildNodeStash recovery;
+    private NodeStash recovery;
 
     private String rootName;
 
@@ -71,11 +73,11 @@ public class JcrSysViewTransformer implements DocViewAdapter {
 
     private long ignoreLevel = 0;
 
-    public JcrSysViewTransformer(Node node) throws SAXException, RepositoryException {
-        this(node, null);
+    public JcrSysViewTransformer(@NotNull Node node, @NotNull ImportMode importMode) throws SAXException, RepositoryException {
+        this(node, null, importMode);
     }
 
-    JcrSysViewTransformer(Node node, String existingPath) throws RepositoryException, SAXException {
+    JcrSysViewTransformer(@NotNull Node node, @Nullable String existingPath, @NotNull ImportMode importMode) throws RepositoryException, SAXException {
         Session session = node.getSession();
         parent = node;
         handler = session.getImportContentHandler(
@@ -94,8 +96,8 @@ public class JcrSysViewTransformer implements DocViewAdapter {
         this.existingPath = existingPath;
         if (existingPath != null) {
             // check if there is an existing node with the name
-            recovery = new ChildNodeStash(session).excludeName("rep:cache");
-            recovery.stashChildren(existingPath);
+            recovery = new NodeStash(session, existingPath, importMode).excludeName("rep:cache");
+            recovery.stash();
         }
         excludeNode("rep:cache");
     }
@@ -118,7 +120,7 @@ public class JcrSysViewTransformer implements DocViewAdapter {
         // check for rescued child nodes
         if (recovery != null) {
             try {
-                recovery.recoverChildren(existingPath);
+                recovery.recover(null);
             } catch (RepositoryException e) {
                 log.error("Error while processing rescued child nodes");
             } finally {
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ChildNodeStash.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/NodeStash.java
similarity index 56%
rename from vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ChildNodeStash.java
rename to vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/NodeStash.java
index bf19c69e..b44c7c0b 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ChildNodeStash.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/NodeStash.java
@@ -21,28 +21,37 @@ import java.util.Set;
 
 import javax.jcr.Node;
 import javax.jcr.NodeIterator;
+import javax.jcr.Property;
+import javax.jcr.PropertyIterator;
 import javax.jcr.RepositoryException;
 import javax.jcr.Session;
 
 import org.apache.jackrabbit.vault.fs.api.ImportInfo;
+import org.apache.jackrabbit.vault.fs.api.ImportMode;
 import org.apache.jackrabbit.vault.util.JcrConstants;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Helper class isolating the task of temporarily moving child nodes to a
+ * Helper class isolating the task of temporarily moving child nodes and properties to a
  * different location in order to be able to recover (and properly merge) them
  * later on.
+ * This is useful when sysview xml is about to be imported, as that clears everything not explicitly mentioned
  */
-public class ChildNodeStash {
+public class NodeStash {
 
-    static final Logger log = LoggerFactory.getLogger(ChildNodeStash.class);
+    static final Logger log = LoggerFactory.getLogger(NodeStash.class);
 
     private final Session session;
 
+    private final String path;
+
+    private final ImportMode importMode;
+
     private Node tmpNode;
 
-    private final Set<String> excludedNodeName = new HashSet<String>();
+    private final Set<String> excludedNodeName = new HashSet<>();
 
     /**
      * List of potential roots where the transient temporary node will be created.
@@ -52,11 +61,13 @@ public class ChildNodeStash {
 
 
     /**
-     * Creates a new child node stash utility class
+     * Creates a new stash utility class which takes care of child nodes and properties in {@code path}
      * @param session session to operate on
      */
-    public ChildNodeStash(Session session) {
+    public NodeStash(Session session, String path, ImportMode importMode) {
         this.session = session;
+        this.path = path;
+        this.importMode  = importMode;
     }
 
     /**
@@ -85,64 +96,61 @@ public class ChildNodeStash {
      * @param name The name of the node to exclude
      * @return "this" suitable for chaining.
      */
-    public ChildNodeStash excludeName(String name) {
+    public NodeStash excludeName(String name) {
         excludedNodeName.add(name);
         return this;
     }
 
     /**
-     * Moves the nodes below the given parent path to a temporary location.
-     * @param parentPath the path of the parent node.
-     * @throws RepositoryException if an error occurrs
-     */
-    public void stashChildren(String parentPath) throws RepositoryException {
-        stashChildren(session.getNode(parentPath));
-    }
-
-    /**
-     * Moves the nodes below the given parent to a temporary location.
-     * @param parent the parent node.
+     * Moves the child nodes and optionally properties of the path to a temporary location.
      */
-    public void stashChildren(Node parent) {
+    public void stash() {
+        if (importMode == ImportMode.REPLACE) {
+            return;
+        }
         try {
-            NodeIterator iter = parent.getNodes();
-            while (iter.hasNext()) {
-                Node child = iter.nextNode();
+            Node parent = session.getNode(path);
+            Node tmp = getOrCreateTemporaryNode();
+            NodeIterator nodeIterator = parent.getNodes();
+            while (nodeIterator.hasNext()) {
+                Node child = nodeIterator.nextNode();
                 String name = child.getName();
                 if (excludedNodeName.contains(name)) {
                     log.debug("skipping excluded child node from stash: {}", child.getPath());
                     continue;
                 }
-                Node tmp = getOrCreateTemporaryNode();
                 try {
                     session.move(child.getPath(), tmp.getPath() + "/" + name);
                 } catch (RepositoryException e) {
                     log.error("Error while moving child node to temporary location. Child will be removed.", e);
                 }
             }
+            // save properties
+            PropertyIterator propIterator = parent.getProperties();
+            while (propIterator.hasNext()) {
+                Property property = propIterator.nextProperty();
+                if (!property.getDefinition().isProtected()) {
+                    if (property.isMultiple()) {
+                        tmp.setProperty(property.getName(), property.getValues(), property.getType());
+                    } else {
+                        tmp.setProperty(property.getName(), property.getValue(), property.getType());
+                    }
+                }
+            }
         } catch (RepositoryException e) {
             log.warn("error while moving child nodes (ignored)", e);
         }
     }
 
     /**
-     * Moves the stashed nodes back below the given parent path.
-     * @param parentPath the path of the new parent node
-     * @throws RepositoryException if an error occurrs
-     */
-    public void recoverChildren(String parentPath) throws RepositoryException {
-        recoverChildren(session.getNode(parentPath), null);
-    }
-
-    /**
-     * Moves the stashed nodes back below the given parent path.
-     * @param parent the new parent node
+     * Moves the stashed nodes/properties back below the original path.
      * @param importInfo the import info to record the changes
-     * @throws RepositoryException if an error occurrs
+     * @throws RepositoryException if an error occurs
      */
-    public void recoverChildren(Node parent, ImportInfo importInfo) throws RepositoryException {
+    public void recover(@Nullable ImportInfo importInfo) throws RepositoryException {
         // move the old child nodes back
         if (tmpNode != null) {
+            Node parent = session.getNode(path);
             NodeIterator iter = tmpNode.getNodes();
             boolean hasErrors = false;
             while (iter.hasNext()) {
@@ -156,16 +164,45 @@ public class ChildNodeStash {
                     }
                 } catch (RepositoryException e) {
                     log.warn("Unable to move child back to new location at {} due to: {}. Node will remain in temporary location: {}",
-                            new Object[]{newPath, e.getMessage(), child.getPath()});
+                            newPath, e.getMessage(), child.getPath());
                     if (importInfo != null) {
                         importInfo.onError(newPath, e);
                         hasErrors = true;
                     }
                 }
             }
+            try {
+                recoverProperties(importMode==ImportMode.MERGE || importMode == ImportMode.MERGE_PROPERTIES);
+            } catch (RepositoryException e) {
+                log.warn("Unable to restore properties at {} due to: {}. Properties will remain in temporary location: {}",
+                        path, e.getMessage(), tmpNode.getPath());
+                if (importInfo != null) {
+                    importInfo.onError(path, e);
+                    hasErrors = true;
+                }
+            }
             if (!hasErrors) {
                 tmpNode.remove();
             }
         }
     }
+    
+    private void recoverProperties(boolean overwriteNewOnes) throws RepositoryException {
+        PropertyIterator propIterator = tmpNode.getProperties();
+        Node destNode = session.getNode(path);
+        while (propIterator.hasNext()) {
+            Property property = propIterator.nextProperty();
+            if (!property.getDefinition().isProtected()) {
+                if (!overwriteNewOnes && destNode.hasProperty(property.getName())) {
+                    log.debug("Skipping restore property {} as it has been updated", property.getPath());
+                    continue;
+                }
+                if (property.isMultiple()) {
+                    destNode.setProperty(property.getName(), property.getValues(), property.getType());
+                } else {
+                    destNode.setProperty(property.getName(), property.getValue(), property.getType());
+                }
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
index 1797b941..4df1459f 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
@@ -88,35 +88,40 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * {@code AbstractImporter}
+ * Imports an {@link Archive} into a repository.
  *
  * file/directory combinations
- *
- * 1. plain files
+ * <ol>
+ * <li>plain file
+ * <pre>
  *    + foo
- *      - test.gif
- *
- * 2. plain files + special folder
+ *      - test.gif</pre>
+ * </li>
+ * <li>plain files + special folder
+ * <pre>
  *    + foo
  *      - .content.xml
  *      + bar
- *        - test.gif
- *
- * 3. special file
+ *        - test.gif</pre>
+ * </li>
+ * <li>special file
+ * <pre>
  *    + foo
  *      - test.gif
  *      - test.gif.dir
- *        - .content.xml
- *
- * 4. special file + sub files
+ *        - .content.xml</pre>
+ * </li>
+ * <li>special file + sub files
+ * <pre>
  *    + foo
  *      - test.gif
  *      - test.gif.dir
  *        - .content.xml
  *        + _jcr_content
- *          - thumbnail.gif
- *
- * 4. special file + sub special files
+ *          - thumbnail.gif</pre>
+ * </li>
+ * <li>special file + sub special files
+ * <pre>
  *    + foo
  *      - test.gif
  *      - test.gif.dir
@@ -124,16 +129,18 @@ import org.slf4j.LoggerFactory;
  *        + _jcr_content
  *          - thumbnail.gif
  *          + thumbnail.gif.dir
- *            - .content.xml
- *
- * 5. file/folder structure
+ *            - .content.xml</pre>
+ * </li>
+ * <li>file/folder structure
+ * <pre>
  *    + foo
  *      + en
  *        - .content.xml
  *        + _cq_content
  *          - thumbnail.gif
  *        + company
- *          - .content.xml
+ *          - .content.xml</pre>
+ * </li>
  */
 public class Importer {
 
@@ -187,6 +194,9 @@ public class Importer {
      */
     private boolean hasErrors = false;
 
+    /** If {@link #hasErrors} = {@code true} this one contains the first exception during package import */
+    private Exception firstException = null;
+
     /**
      * overall handler for importing folder artifacts
      */
@@ -493,6 +503,9 @@ public class Importer {
         } else {
             if (hasErrors) {
                 track("Package imported (with errors, check logs!)", "");
+                if (opts.isStrict(isStrictByDefault)) {
+                    throw new RepositoryException("Some errors occurred while installing packages. Please check the logs for details. First exception is logged as cause.", firstException);
+                }
                 log.error("There were errors during package install. Please check the logs for details.");
             } else {
                 track("Package imported.", "");
@@ -1007,6 +1020,9 @@ public class Importer {
                             track(error, path);
                         }
                         hasErrors = true;
+                        if (firstException == null) {
+                            firstException = error;
+                        }
                         break;
                 }
 
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewNode.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewNode.java
index fa2adb0b..3df4f54a 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewNode.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewNode.java
@@ -27,6 +27,8 @@ import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
 import org.apache.jackrabbit.util.ISO9075;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.xml.sax.Attributes;
 
 /**
@@ -35,14 +37,14 @@ import org.xml.sax.Attributes;
  */
 public class DocViewNode {
 
-    public final String name;
-    public final String label;
-    public final Map<String, DocViewProperty> props = new HashMap<String, DocViewProperty>();
-    public String uuid;
-    public final String[] mixins;
-    public final String primary;
+    public final @NotNull String name;
+    public final @NotNull String label;
+    public final @NotNull Map<String, DocViewProperty> props = new HashMap<>();
+    public @Nullable String uuid;
+    public final @Nullable String[] mixins;
+    public final @Nullable String primary; // may be null for ordering items
 
-    public DocViewNode(String name, String label, String uuid, Map<String, DocViewProperty> props, String[] mixins, String primary) {
+    public DocViewNode(@NotNull String name, @NotNull String label, String uuid, Map<String, DocViewProperty> props, String[] mixins, String primary) {
         this.name = name;
         this.label = label;
         this.uuid = uuid;
@@ -51,7 +53,7 @@ public class DocViewNode {
         this.props.putAll(props);
     }
 
-    public DocViewNode(String name, String label, Attributes attributes, NamePathResolver npResolver)
+    public DocViewNode(@NotNull String name, @NotNull String label, Attributes attributes, NamePathResolver npResolver)
             throws NamespaceException {
         this.name = name;
         this.label = label;
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/ImportModeIT.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/ImportModeIT.java
index 519ecc24..79a085a3 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/ImportModeIT.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/ImportModeIT.java
@@ -17,13 +17,18 @@
 
 package org.apache.jackrabbit.vault.packaging.integration;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Calendar;
 
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
 
+import org.apache.jackrabbit.commons.JcrUtils;
 import org.apache.jackrabbit.vault.packaging.JcrPackage;
 import org.apache.jackrabbit.vault.packaging.PackageException;
+import org.apache.jackrabbit.vault.util.MimeTypes;
 import org.junit.Test;
 
 /**
@@ -38,7 +43,7 @@ public class ImportModeIT extends IntegrationTestBase {
     public void testReplace() throws RepositoryException, IOException, PackageException {
         Node tmp = admin.getRootNode().addNode("tmp");
         Node foo = tmp.addNode("foo");
-        Node old = foo.addNode("old");
+        foo.addNode("old");
         admin.save();
         assertNodeExists("/tmp/foo/old");
         assertNodeMissing("/tmp/foo/bar");
@@ -58,7 +63,7 @@ public class ImportModeIT extends IntegrationTestBase {
     public void testMerge() throws RepositoryException, IOException, PackageException {
         Node tmp = admin.getRootNode().addNode("tmp");
         Node foo = tmp.addNode("foo");
-        Node old = foo.addNode("old");
+        foo.addNode("old");
         Node bar = foo.addNode("bar");
         bar.setProperty("testProperty", "old");
         admin.save();
@@ -81,7 +86,7 @@ public class ImportModeIT extends IntegrationTestBase {
     public void testUpdate() throws RepositoryException, IOException, PackageException {
         Node tmp = admin.getRootNode().addNode("tmp");
         Node foo = tmp.addNode("foo");
-        Node old = foo.addNode("old");
+        foo.addNode("old");
         Node bar = foo.addNode("bar");
         bar.setProperty("testProperty", "old");
         admin.save();
@@ -97,4 +102,214 @@ public class ImportModeIT extends IntegrationTestBase {
         assertProperty("/tmp/foo/bar/testProperty", "new");
     }
 
+    @Test
+    public void testAllImportModesWithGenericArtifactHandler() throws RepositoryException, IOException, PackageException {
+        // initial state
+        Node parent = admin.getRootNode().addNode("testroot");
+        setUpNode(parent, "replace");
+        setUpNode(parent, "merge");
+        setUpNode(parent, "update");
+        setUpNode(parent, "merge_properties");
+        setUpNode(parent, "update_properties");
+        admin.save();
+        
+        assertProperty("/testroot/replace/propertyold", "old");
+        assertProperty("/testroot/replace/propertyupdate", "old");
+        assertNodeExists("/testroot/replace/old");
+        assertProperty("/testroot/replace/existing/propertyold", "old");
+        
+        extractVaultPackage("/test-packages/import_modes_test_generichandler_docview.zip");
+        
+        // test update, creation and deletion of properties and nodes
+        // Replace
+        assertProperty("/testroot/replace/propertyupdate", "new");
+        assertProperty("/testroot/replace/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/propertyold");
+        assertProperty("/testroot/replace/existing/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/existing/propertyold");
+        assertNodeExists("/testroot/replace/new");
+        assertNodeMissing("/testroot/replace/old");
+
+        // Update (neither delete existing nodes nor properties)
+        assertProperty("/testroot/update/propertyupdate", "new");
+        assertProperty("/testroot/update/propertynew", "new");
+        assertProperty("/testroot/update/propertyold", "old");
+        assertProperty("/testroot/update/existing/propertynew", "new");
+        assertProperty("/testroot/update/existing/propertyold", "old");
+        assertNodeExists("/testroot/update/new");
+        assertNodeExists("/testroot/update/old");
+
+        // Merge (don't touch existing nodes, except for adding new children)
+        assertProperty("/testroot/merge/propertyupdate", "old");
+        assertProperty("/testroot/merge/propertynew", "new");
+        assertProperty("/testroot/merge/propertyold", "old");
+        assertProperty("/testroot/merge/existing/propertynew", "new");
+        assertProperty("/testroot/merge/existing/propertyold", "old");
+        assertNodeExists("/testroot/merge/new"); // works, because import mode for testroot (docview root level) is REPLACE
+        assertNodeExists("/testroot/merge/old");
+
+        // Property Update (neither delete existing nodes nor properties, but update them and add new properties/nodes)
+        assertProperty("/testroot/update_properties/propertyupdate", "new");
+        assertProperty("/testroot/update_properties/propertynew", "new");
+        assertProperty("/testroot/update_properties/propertyold", "old");
+        assertProperty("/testroot/update_properties/existing/propertynew", "new");
+        assertProperty("/testroot/update_properties/existing/propertyold", "old");
+        assertNodeExists("/testroot/update_properties/new");
+        assertNodeExists("/testroot/update_properties/old");
+        
+        // Property Merge (don't touch existing nodes nor properties, only add new properties/nodes)
+        assertProperty("/testroot/merge_properties/propertyupdate", "old");
+        assertProperty("/testroot/merge_properties/propertynew", "new");
+        assertProperty("/testroot/merge_properties/propertyold", "old");
+        assertProperty("/testroot/merge_properties/existing/propertynew", "new");
+        assertProperty("/testroot/merge_properties/existing/propertyold", "old");
+        assertNodeExists("/testroot/merge_properties/new");
+        assertNodeExists("/testroot/merge_properties/old");
+    }
+
+    @Test
+    public void testAllImportModesFullCoverageWithGenericArtifactHandler() throws RepositoryException, IOException, PackageException {
+        // initial state
+        Node parent = admin.getRootNode().addNode("testroot");
+        setUpNode(parent, "replace");
+        setUpNode(parent, "merge");
+        setUpNode(parent, "update");
+        setUpNode(parent, "merge_properties");
+        setUpNode(parent, "update_properties");
+        admin.save();
+        
+        assertProperty("/testroot/replace/propertyold", "old");
+        assertProperty("/testroot/replace/propertyupdate", "old");
+        assertNodeExists("/testroot/replace/old");
+        assertProperty("/testroot/replace/existing/propertyold", "old");
+        
+        // full coverage nodes on another level
+        extractVaultPackage("/test-packages/import_modes_test_generichandler2_docview.zip");
+        
+        // test update, creation and deletion of properties and nodes
+        // Replace
+        assertProperty("/testroot/replace/propertyupdate", "new");
+        assertProperty("/testroot/replace/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/propertyold");
+        assertProperty("/testroot/replace/existing/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/existing/propertyold");
+        assertNodeExists("/testroot/replace/new");
+        assertNodeMissing("/testroot/replace/old");
+
+        // Update (neither delete existing nodes nor properties)
+        assertProperty("/testroot/update/propertyupdate", "new");
+        assertProperty("/testroot/update/propertynew", "new");
+        assertProperty("/testroot/update/propertyold", "old");
+        assertProperty("/testroot/update/existing/propertynew", "new");
+        assertProperty("/testroot/update/existing/propertyold", "old");
+        assertNodeExists("/testroot/update/new");
+        assertNodeExists("/testroot/update/old");
+
+        // Merge (don't touch existing nodes, except for adding new children)
+        assertProperty("/testroot/merge/propertyupdate", "old");
+        assertPropertyMissing("/testroot/merge/propertynew"); // not imported as whole docview is skipped
+        assertProperty("/testroot/merge/propertyold", "old");
+        assertPropertyMissing("/testroot/merge/existing/propertynew"); // not imported as whole docview is skipped
+        assertProperty("/testroot/merge/existing/propertyold", "old");
+        assertNodeMissing("/testroot/merge/new"); // not imported as whole docview is skipped
+        assertNodeExists("/testroot/merge/old");
+
+        // Property Update (neither delete existing nodes nor properties, but update them and add new properties/nodes)
+        assertProperty("/testroot/update_properties/propertyupdate", "new");
+        assertProperty("/testroot/update_properties/propertynew", "new");
+        assertProperty("/testroot/update_properties/propertyold", "old");
+        assertProperty("/testroot/update_properties/existing/propertynew", "new");
+        assertProperty("/testroot/update_properties/existing/propertyold", "old");
+        assertNodeExists("/testroot/update_properties/new");
+        assertNodeExists("/testroot/update_properties/old");
+        
+        // Property Merge (don't touch existing nodes nor properties, only add new properties/nodes)
+        assertProperty("/testroot/merge_properties/propertyupdate", "old");
+        assertProperty("/testroot/merge_properties/propertynew", "new");
+        assertProperty("/testroot/merge_properties/propertyold", "old");
+        assertProperty("/testroot/merge_properties/existing/propertynew", "new");
+        assertProperty("/testroot/merge_properties/existing/propertyold", "old");
+        assertNodeExists("/testroot/merge_properties/new");
+        assertNodeExists("/testroot/merge_properties/old");
+    }
+
+    @Test
+    public void testAllImportModesWithFileArtifactHandler() throws RepositoryException, IOException, PackageException {
+     // initial state
+        Node parent = admin.getRootNode().addNode("testroot");
+        setUpFileNode(parent, "replace");
+        setUpFileNode(parent, "merge");
+        setUpFileNode(parent, "update");
+        setUpFileNode(parent, "merge_properties");
+        setUpFileNode(parent, "update_properties");
+        admin.save();
+        
+        assertProperty("/testroot/replace/jcr:content/jcr:data", "test");
+        
+        extractVaultPackage("/test-packages/import_modes_test_filehandler.zip");
+        
+        // test update, creation and deletion of properties and nodes
+        // Replace
+        assertProperty("/testroot/replace/jcr:content/jcr:data", "new");
+
+        // Update (neither delete existing nodes nor properties)
+        assertProperty("/testroot/update/jcr:content/jcr:data", "new");
+
+        // Merge (don't touch existing nodes, except for adding new children)
+        assertProperty("/testroot/merge/jcr:content/jcr:data", "test");
+
+        // Property Update (neither delete existing nodes nor properties, but update them and add new properties/nodes)
+        assertProperty("/testroot/update_properties/jcr:content/jcr:data", "new");
+        
+        // Property Merge (don't touch existing nodes nor properties, only add new properties/nodes)
+        assertProperty("/testroot/merge_properties/jcr:content/jcr:data", "test");
+    }
+
+    @Test
+    public void testMergingUpdatingNewRestrictedProperties() throws RepositoryException, IOException, PackageException {
+        // initial state
+        Node parent = admin.getRootNode().addNode("testroot");
+        // existing nodes are heavily restricted (nt:file)
+        setUpFileNode(parent, "replace");
+        setUpFileNode(parent, "merge_properties");
+        setUpFileNode(parent, "update_properties");
+        admin.save();
+        
+        extractVaultPackageStrict("/test-packages/import_modes_test_generichandler_docview.zip");
+
+        // Replace
+        assertProperty("/testroot/replace/propertyupdate", "new");
+        assertProperty("/testroot/replace/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/propertyold");
+        assertProperty("/testroot/replace/existing/propertynew", "new");
+        assertPropertyMissing("/testroot/replace/existing/propertyold");
+        assertNodeExists("/testroot/replace/new");
+        assertNodeMissing("/testroot/replace/old");
+
+        // Property Update (skip adding new properties and child nodes as incompatible with existing primary type)
+        assertPropertyMissing("/testroot/update_properties/propertynew");
+        assertPropertyExists("/testroot/update_properties/jcr:content/jcr:data");
+        assertNodeExists("/testroot/update_properties/jcr:content");
+
+        // Property Merge (skip adding new properties and child nodes as incompatible with existing primary type)
+        assertPropertyMissing("/testroot/merge_properties/propertynew");
+        assertPropertyExists("/testroot/merge_properties/jcr:content/jcr:data");
+        assertNodeExists("/testroot/merge_properties/jcr:content");
+    }
+
+    private void setUpNode(Node parent, String name) throws RepositoryException {
+        Node node = parent.addNode(name);
+        node.setProperty("propertyold", "old");
+        node.setProperty("propertyupdate", "old");
+        node.addNode("old");
+        Node existing = node.addNode("existing");
+        existing.setProperty("propertyold", "old");
+    }
+
+    private void setUpFileNode(Node parent, String name) throws RepositoryException, IOException {
+        try (ByteArrayInputStream input = new ByteArrayInputStream("test".getBytes(StandardCharsets.US_ASCII))) {
+            JcrUtils.putFile(parent, name, MimeTypes.APPLICATION_OCTET_STREAM, input, Calendar.getInstance());
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/IntegrationTestBase.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/IntegrationTestBase.java
index 01eaf219..6cc4d812 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/IntegrationTestBase.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/IntegrationTestBase.java
@@ -304,7 +304,7 @@ public class IntegrationTestBase  {
     }
 
     public static boolean isOak() {
-        return Boolean.getBoolean("oak");
+        return Boolean.parseBoolean(System.getProperty("oak", "true"));
     }
 
     public void clean(String path) {
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/filter.xml b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/filter.xml
new file mode 100644
index 00000000..572c30b9
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/filter.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<workspaceFilter version="1.0">
+    <filter root="/testroot/replace" mode="replace"/>
+    <filter root="/testroot/merge" mode="merge"/>
+    <filter root="/testroot/update" mode="update"/>
+    <filter root="/testroot/merge_properties" mode="merge_properties"/>
+    <filter root="/testroot/update_properties" mode="update_properties"/>
+</workspaceFilter>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/nodetypes.cnd b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/nodetypes.cnd
new file mode 100644
index 00000000..5afdfb71
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/nodetypes.cnd
@@ -0,0 +1,8 @@
+<'sling'='http://sling.apache.org/jcr/sling/1.0'>
+<'nt'='http://www.jcp.org/jcr/nt/1.0'>
+
+[sling:Folder] > nt:folder
+  - * (undefined)
+  - * (undefined) multiple
+  + * (nt:base) = sling:Folder version
+
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/properties.xml b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/properties.xml
new file mode 100644
index 00000000..c606e192
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/META-INF/vault/properties.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
+<properties>
+<comment>FileVault Package Properties</comment>
+<entry key="createdBy">admin</entry>
+<entry key="name">import-modes-test</entry>
+<entry key="lastModified">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="lastModifiedBy">admin</entry>
+<entry key="created">2011-11-15T09:45:14.685+01:00</entry>
+<entry key="buildCount">1</entry>
+<entry key="version"/>
+<entry key="dependencies"/>
+<entry key="packageFormatVersion">2</entry>
+<entry key="description"/>
+<entry key="lastWrapped">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="group"/>
+<entry key="lastWrappedBy">admin</entry>
+</properties>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/.content.xml
new file mode 100644
index 00000000..e546f292
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/.content.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:mixinTypes="[rep:AccessControllable]"
+    jcr:primaryType="rep:root"
+    sling:resourceType="sling:redirect"
+    sling:target="/index.html">
+    <rep:policy/>
+    <jcr:system/>
+    <var/>
+    <libs/>
+    <etc/>
+    <apps/>
+    <content/>
+    <tmp/>
+    <home/>
+    <testroot/>
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/.content.xml
new file mode 100644
index 00000000..57bca0f5
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/.content.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder">
+</jcr:root>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge
new file mode 100644
index 00000000..3e5126c4
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge
@@ -0,0 +1 @@
+new
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge_properties b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge_properties
new file mode 100644
index 00000000..3e5126c4
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/merge_properties
@@ -0,0 +1 @@
+new
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/replace b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/replace
new file mode 100644
index 00000000..3e5126c4
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/replace
@@ -0,0 +1 @@
+new
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update
new file mode 100644
index 00000000..3e5126c4
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update
@@ -0,0 +1 @@
+new
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update_properties b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update_properties
new file mode 100644
index 00000000..3e5126c4
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_filehandler.zip/jcr_root/testroot/update_properties
@@ -0,0 +1 @@
+new
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/filter.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/filter.xml
new file mode 100644
index 00000000..572c30b9
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/filter.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<workspaceFilter version="1.0">
+    <filter root="/testroot/replace" mode="replace"/>
+    <filter root="/testroot/merge" mode="merge"/>
+    <filter root="/testroot/update" mode="update"/>
+    <filter root="/testroot/merge_properties" mode="merge_properties"/>
+    <filter root="/testroot/update_properties" mode="update_properties"/>
+</workspaceFilter>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/nodetypes.cnd b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/nodetypes.cnd
new file mode 100644
index 00000000..5afdfb71
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/nodetypes.cnd
@@ -0,0 +1,8 @@
+<'sling'='http://sling.apache.org/jcr/sling/1.0'>
+<'nt'='http://www.jcp.org/jcr/nt/1.0'>
+
+[sling:Folder] > nt:folder
+  - * (undefined)
+  - * (undefined) multiple
+  + * (nt:base) = sling:Folder version
+
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/properties.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/properties.xml
new file mode 100644
index 00000000..c606e192
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/META-INF/vault/properties.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
+<properties>
+<comment>FileVault Package Properties</comment>
+<entry key="createdBy">admin</entry>
+<entry key="name">import-modes-test</entry>
+<entry key="lastModified">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="lastModifiedBy">admin</entry>
+<entry key="created">2011-11-15T09:45:14.685+01:00</entry>
+<entry key="buildCount">1</entry>
+<entry key="version"/>
+<entry key="dependencies"/>
+<entry key="packageFormatVersion">2</entry>
+<entry key="description"/>
+<entry key="lastWrapped">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="group"/>
+<entry key="lastWrappedBy">admin</entry>
+</properties>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/.content.xml
new file mode 100644
index 00000000..e546f292
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/.content.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:mixinTypes="[rep:AccessControllable]"
+    jcr:primaryType="rep:root"
+    sling:resourceType="sling:redirect"
+    sling:target="/index.html">
+    <rep:policy/>
+    <jcr:system/>
+    <var/>
+    <libs/>
+    <etc/>
+    <apps/>
+    <content/>
+    <tmp/>
+    <home/>
+    <testroot/>
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/.content.xml
new file mode 100644
index 00000000..57bca0f5
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/.content.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder">
+</jcr:root>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge.xml
new file mode 100644
index 00000000..e9f90d89
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder" propertyupdate="new" propertynew="new">
+    <existing jcr:primaryType="sling:Folder" propertynew="new" />
+    <new jcr:primaryType="sling:Folder" />
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge_properties.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge_properties.xml
new file mode 100644
index 00000000..e9f90d89
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/merge_properties.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder" propertyupdate="new" propertynew="new">
+    <existing jcr:primaryType="sling:Folder" propertynew="new" />
+    <new jcr:primaryType="sling:Folder" />
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/replace.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/replace.xml
new file mode 100644
index 00000000..e9f90d89
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/replace.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder" propertyupdate="new" propertynew="new">
+    <existing jcr:primaryType="sling:Folder" propertynew="new" />
+    <new jcr:primaryType="sling:Folder" />
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update.xml
new file mode 100644
index 00000000..e9f90d89
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder" propertyupdate="new" propertynew="new">
+    <existing jcr:primaryType="sling:Folder" propertynew="new" />
+    <new jcr:primaryType="sling:Folder" />
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update_properties.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update_properties.xml
new file mode 100644
index 00000000..e9f90d89
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler2_docview.zip/jcr_root/testroot/update_properties.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder" propertyupdate="new" propertynew="new">
+    <existing jcr:primaryType="sling:Folder" propertynew="new" />
+    <new jcr:primaryType="sling:Folder" />
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/filter.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/filter.xml
new file mode 100644
index 00000000..572c30b9
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/filter.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<workspaceFilter version="1.0">
+    <filter root="/testroot/replace" mode="replace"/>
+    <filter root="/testroot/merge" mode="merge"/>
+    <filter root="/testroot/update" mode="update"/>
+    <filter root="/testroot/merge_properties" mode="merge_properties"/>
+    <filter root="/testroot/update_properties" mode="update_properties"/>
+</workspaceFilter>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/nodetypes.cnd b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/nodetypes.cnd
new file mode 100644
index 00000000..5afdfb71
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/nodetypes.cnd
@@ -0,0 +1,8 @@
+<'sling'='http://sling.apache.org/jcr/sling/1.0'>
+<'nt'='http://www.jcp.org/jcr/nt/1.0'>
+
+[sling:Folder] > nt:folder
+  - * (undefined)
+  - * (undefined) multiple
+  + * (nt:base) = sling:Folder version
+
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/properties.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/properties.xml
new file mode 100644
index 00000000..c606e192
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/META-INF/vault/properties.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
+<properties>
+<comment>FileVault Package Properties</comment>
+<entry key="createdBy">admin</entry>
+<entry key="name">import-modes-test</entry>
+<entry key="lastModified">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="lastModifiedBy">admin</entry>
+<entry key="created">2011-11-15T09:45:14.685+01:00</entry>
+<entry key="buildCount">1</entry>
+<entry key="version"/>
+<entry key="dependencies"/>
+<entry key="packageFormatVersion">2</entry>
+<entry key="description"/>
+<entry key="lastWrapped">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="group"/>
+<entry key="lastWrappedBy">admin</entry>
+</properties>
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/.content.xml
new file mode 100644
index 00000000..e546f292
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/.content.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:mixinTypes="[rep:AccessControllable]"
+    jcr:primaryType="rep:root"
+    sling:resourceType="sling:redirect"
+    sling:target="/index.html">
+    <rep:policy/>
+    <jcr:system/>
+    <var/>
+    <libs/>
+    <etc/>
+    <apps/>
+    <content/>
+    <tmp/>
+    <home/>
+    <testroot/>
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/testroot/.content.xml b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/testroot/.content.xml
new file mode 100644
index 00000000..da0fa1cf
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/import_modes_test_generichandler_docview.zip/jcr_root/testroot/.content.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:primaryType="sling:Folder">
+    <replace jcr:primaryType="sling:Folder"
+        propertyupdate="new"
+        propertynew="new">
+        <existing jcr:primaryType="sling:Folder" propertynew="new" />
+        <new jcr:primaryType="sling:Folder" />
+    </replace>
+    <merge jcr:primaryType="sling:Folder"
+        propertyupdate="new"
+        propertynew="new">
+        <existing jcr:primaryType="sling:Folder" propertynew="new" />
+        <new jcr:primaryType="sling:Folder" />
+    </merge>
+    <update jcr:primaryType="sling:Folder"
+        propertyupdate="new"
+        propertynew="new">
+        <existing jcr:primaryType="sling:Folder" propertynew="new"/>
+        <new jcr:primaryType="sling:Folder" />
+    </update>
+    <merge_properties jcr:primaryType="sling:Folder"
+        propertyupdate="new"
+        propertynew="new">
+        <existing jcr:primaryType="sling:Folder" propertynew="new" />
+        <new jcr:primaryType="sling:Folder" />
+    </merge_properties>
+    <update_properties jcr:primaryType="sling:Folder"
+        propertyupdate="new"
+        propertynew="new">
+        <existing jcr:primaryType="sling:Folder" propertynew="new"/>
+        <new jcr:primaryType="sling:Folder" />
+    </update_properties>
+</jcr:root>
