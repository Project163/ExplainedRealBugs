diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/MultiPathMapping.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/MultiPathMapping.java
new file mode 100644
index 00000000..16ecffcd
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/MultiPathMapping.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.fs.api;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.jackrabbit.vault.util.Text;
+
+/**
+ * Implements a path mapping that supports multiple synlinks
+ * @since 3.1.10
+ */
+public class MultiPathMapping implements PathMapping {
+
+    private final Map<String, String> links = new HashMap<String, String>();
+
+    private final Map<String, String> reverseLinks = new HashMap<String, String>();
+
+    /**
+     * Creates a new link from the path {@code src} to the path {@code dst}
+     * @param src source path
+     * @param dst destination path
+     * @return this
+     */
+    public MultiPathMapping link(String src, String dst) {
+        links.put(src, dst);
+        reverseLinks.put(dst, src);
+        return this;
+    }
+
+    /**
+     * Merges the links from the given base mapping
+     * @param base base mapping
+     * @return this
+     */
+    public MultiPathMapping merge(MultiPathMapping base) {
+        if (base != null) {
+            this.links.putAll(base.links);
+            this.reverseLinks.putAll(base.reverseLinks);
+        }
+        return this;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String map(String path) {
+        return map(path, false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String map(String path, boolean reverse) {
+        if (path == null || path.length() == 0 || "/".equals(path)) {
+            return path;
+        }
+        Map<String, String> lookup = reverse ? reverseLinks : links;
+        String[] segs = Text.explode(path, '/');
+        String ret = "";
+        for (String name: segs) {
+            ret += "/" + name;
+            String link = lookup.get(ret);
+            if (link != null) {
+                ret = link;
+            }
+        }
+        return ret;
+    }
+}
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/PathMapping.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/PathMapping.java
index 40272718..8a6ef8f6 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/PathMapping.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/PathMapping.java
@@ -27,9 +27,16 @@ public interface PathMapping {
      * Implements an identity mapping
      */
     PathMapping IDENTITY = new PathMapping() {
+
+        @Override
         public String map(String path) {
             return path;
         }
+
+        @Override
+        public String map(String path, boolean reverse) {
+            return path;
+        }
     };
 
     /**
@@ -38,4 +45,14 @@ public interface PathMapping {
      * @return the mapped path.
      */
     String map(String path);
+
+    /**
+     * Maps the given path to a new location.
+     * @param path the path
+     * @param reverse if {@code true} a reverse mapping is applied
+     * @return the mapped path.
+     */
+    String map(String path, boolean reverse);
+
+
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/SimplePathMapping.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/SimplePathMapping.java
index 2e5d5166..d5df13a8 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/SimplePathMapping.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/SimplePathMapping.java
@@ -39,7 +39,18 @@ public class SimplePathMapping implements PathMapping {
     /**
      * {@inheritDoc}
      */
+    @Override
     public String map(String path) {
+        return map(path, false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String map(String path, boolean reverse) {
+        String strip = reverse ? this.root : this.strip;
+        String root = reverse ? this.strip : this.root;
         if (path.startsWith(strip)) {
             StringBuilder b = new StringBuilder(root);
             b.append(path.substring(strip.length()));
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
index 1039e38a..c31b9141 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
@@ -306,7 +306,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
     }
 
     private boolean isIncluded(Item item, int depth) throws RepositoryException {
-        String path = item.getPath();
+        String path = importInfo.getRemapped().map(item.getPath());
         return wspFilter.contains(path) && (depth == 0 || filter.contains(item, path, depth));
     }
 
@@ -676,16 +676,27 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             importInfo.onCreated(newPath);
             return;
         }
+        boolean isIncluded = wspFilter.contains(newPath);
 
         Node authNode = session.getNode(oldPath);
-        ImportMode mode = wspFilter.getImportMode(oldPath);
+        ImportMode mode = wspFilter.getImportMode(newPath);
+
         // if existing path is not the same as this, we need to register this so that further
         // nodes down the line (i.e. profiles, policies) are imported at the correct location
+        // we only follow existing authorizables for non-REPLACE mode and if ignoring this authorizable node
         // todo: check if this also works cross-aggregates
-        if (mode != ImportMode.REPLACE && !oldPath.equals(newPath)) {
+        if (mode != ImportMode.REPLACE || !isIncluded) {
             importInfo.onRemapped(oldPath, newPath);
         }
 
+        if (!isIncluded) {
+            // skip authorizable handling - always follow existing authorizable - regardless of mode
+            // todo: we also need to check any rep:Memberlist subnodes. see JCRVLT-69
+            stack = stack.push(new StackElement(authNode, false));
+            importInfo.onNop(oldPath);
+            return;
+        }
+
         switch (mode) {
             case MERGE:
                 // remember desired memberships.
@@ -697,7 +708,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
 
                 log.info("Skipping import of existing authorizable '{}' due to MERGE import mode.", id);
                 stack = stack.push(new StackElement(authNode, false));
-                importInfo.onNop(oldPath);
+                importInfo.onNop(newPath);
                 break;
 
             case REPLACE:
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
index 28884fe5..e604ad48 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
@@ -32,7 +32,9 @@ import javax.jcr.Session;
 import javax.jcr.version.Version;
 
 import org.apache.jackrabbit.vault.fs.api.ImportInfo;
+import org.apache.jackrabbit.vault.fs.api.MultiPathMapping;
 import org.apache.jackrabbit.vault.fs.api.NodeNameList;
+import org.apache.jackrabbit.vault.fs.api.PathMapping;
 import org.apache.jackrabbit.vault.util.JcrConstants;
 import org.apache.jackrabbit.vault.util.PathComparator;
 import org.slf4j.Logger;
@@ -51,7 +53,7 @@ public class ImportInfoImpl implements ImportInfo {
 
     private final TreeMap<String, Info> infos = new TreeMap<String, Info>(new PathComparator());
 
-    private Map<String, String> remapped;
+    private MultiPathMapping mapping = null;
 
     /**
      * list of uuids of nodes that need to be checked-in after the import
@@ -82,10 +84,10 @@ public class ImportInfoImpl implements ImportInfo {
             numModified +=baseImpl.numModified;
             numErrors += baseImpl.numErrors;
             toVersion.addAll(baseImpl.toVersion);
-            if (remapped == null) {
-                remapped = baseImpl.remapped;
+            if (mapping == null) {
+                mapping = baseImpl.mapping;
             } else {
-                remapped.putAll(baseImpl.getRemapped());
+                mapping.merge(baseImpl.mapping);
             }
             if (memberships == null) {
                 memberships = baseImpl.memberships;
@@ -156,15 +158,24 @@ public class ImportInfoImpl implements ImportInfo {
         numErrors++;
     }
 
-    public void onRemapped(String oldPath, String newPath) {
-        if (remapped == null) {
-            remapped = new HashMap<String, String>();
+    /**
+     * remembers that a package path was remapped during import. e.g. when the importer follows and existing
+     * authorizable for MERGE and UPDATE modes.
+     *
+     * @param packagePath the original path as presented in the package
+     * @param followedPath the followed path during the import
+     */
+    public void onRemapped(String followedPath, String packagePath) {
+        if (!packagePath.equals(followedPath)) {
+            if (mapping == null) {
+                mapping = new MultiPathMapping();
+            }
+            mapping.link(followedPath, packagePath);
         }
-        remapped.put(oldPath, newPath);
     }
 
-    public Map<String, String> getRemapped() {
-        return remapped == null ? Collections.<String, String>emptyMap() : remapped;
+    public PathMapping getRemapped() {
+        return mapping == null ? PathMapping.IDENTITY : mapping;
     }
 
     private void addMod(String path, Type mod, Exception e) {
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
index 45b708d8..27c62714 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
@@ -965,7 +965,7 @@ public class Importer {
             // check if node was remapped. currently we just skip them as it's not clear how the filter should be
             // reapplied or what happens if the remapping links to a tree we already processed.
             // in this case we don't descend in any children and can clear them right away
-            if (imp.getRemapped().containsKey(info.path)) {
+            if (!imp.getRemapped().map(info.path, true).equals(info.path)) {
                 info.children = null;
             }
         }
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/fs/api/PathMappingTest.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/fs/api/PathMappingTest.java
index f770acb4..d8910738 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/fs/api/PathMappingTest.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/fs/api/PathMappingTest.java
@@ -32,4 +32,49 @@ public class PathMappingTest {
         assertEquals("/content/products", map.map("/tmp/products"));
         assertEquals("/foo", map.map("/foo"));
     }
+
+    @Test
+    public void testSimpleReverse() {
+        PathMapping map = new SimplePathMapping("/tmp", "/content");
+        assertEquals("/tmp", map.map("/content", true));
+        assertEquals("/tmp/products", map.map("/content/products", true));
+        assertEquals("/foo", map.map("/foo", true));
+    }
+
+    @Test
+    public void testMulti() {
+        MultiPathMapping map = new MultiPathMapping();
+        map.link("/source/tree/a", "/dest/1");
+        map.link("/source/tree/b", "/dest/2");
+        map.link("/source/foo/a", "/dest/foo/1");
+        map.link("/dest/foo/1/top", "/test");
+
+        assertEquals("", map.map(""));
+        assertEquals("/", map.map("/"));
+        assertEquals("/content", map.map("/content"));
+        assertEquals("/dest/1", map.map("/source/tree/a"));
+        assertEquals("/dest/1/test", map.map("/source/tree/a/test"));
+        assertEquals("/dest/2/test", map.map("/source/tree/b/test"));
+        assertEquals("/dest/foo/1/test", map.map("/source/foo/a/test"));
+        assertEquals("/test/flop", map.map("/source/foo/a/top/flop"));
+   }
+
+    @Test
+    public void testMultiReverse() {
+        MultiPathMapping map = new MultiPathMapping();
+        map.link("/source/tree/a", "/dest/1");
+        map.link("/source/tree/b", "/dest/2");
+        map.link("/source/foo/a", "/dest/foo/1");
+        map.link("/dest/foo/1/top", "/test");
+
+        assertEquals("", map.map(""));
+        assertEquals("/", map.map("/"));
+        assertEquals("/content", map.map("/content"));
+        assertEquals("/source/tree/a", map.map("/dest/1", true));
+        assertEquals("/source/tree/b/test", map.map("/dest/2/test", true));
+        assertEquals("/source/tree/a/a/b/c/d", map.map("/dest/1/a/b/c/d", true));
+        assertEquals("/source/foo/a/test", map.map("/dest/foo/1/test", true));
+        assertEquals("/dest/foo/1/top/flop", map.map("/test/flop", true));
+
+    }
 }
\ No newline at end of file
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestUserContentPackage.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestUserContentPackage.java
index 1c18a212..7102f0b1 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestUserContentPackage.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestUserContentPackage.java
@@ -51,6 +51,7 @@ public class TestUserContentPackage extends IntegrationTestBase {
     private static final String NAME_PROFILE_FULLNAME = "profile/fullname";
     private static final String NAME_PROFILE_PROPERTY = "profile/profileProperty";
     private static final String NAME_PROFILE_NODE = "profile";
+    private static final String NAME_PROFILE_PICTURE_NODE = "profile/picture.txt";
     private static final String NAME_PROFILE_PRIVATE_NODE = "profile_private";
 
     @Override
@@ -110,7 +111,6 @@ public class TestUserContentPackage extends IntegrationTestBase {
     }
 
     @Test
-    @Ignore("JCRVLT-64")
     public void installUserA_Profile() throws RepositoryException, IOException, PackageException {
         // install default user at package path
         User userA = installUserA(ImportMode.REPLACE, true, true);
@@ -128,7 +128,6 @@ public class TestUserContentPackage extends IntegrationTestBase {
     }
 
     @Test
-    @Ignore("JCRVLT-65")
     public void installUserA_Profile_Moved() throws RepositoryException, IOException, PackageException {
         // install default user at package path
         User userA = installUserA(ImportMode.UPDATE, false, false);
@@ -145,6 +144,43 @@ public class TestUserContentPackage extends IntegrationTestBase {
         assertProperty(authPath + "/" + NAME_PROFILE_PROPERTY, "a");
     }
 
+    @Test
+    public void installUserA_Profile_Picture() throws RepositoryException, IOException, PackageException {
+        // install default user at package path
+        User userA = installUserA(ImportMode.REPLACE, true, true);
+        String authPath = userA.getPath();
+
+        assertPropertyMissing(authPath + "/" + NAME_PROFILE_PROPERTY);
+
+        // install updated profile
+        JcrPackage pack = packMgr.upload(getStream("testpackages/test_user_a_profile_picture.zip"), false);
+        assertNotNull(pack);
+        pack.install(getDefaultOptions());
+
+        assertProperty(authPath + "/" + NAME_PROFILE_FULLNAME, "Test User");
+        assertProperty(authPath + "/" + NAME_PROFILE_PROPERTY, "a");
+        assertNodeExists(authPath + "/" + NAME_PROFILE_PICTURE_NODE);
+    }
+
+    @Test
+    @Ignore("JCRVLT-65")
+    public void installUserA_Profile_Picture_Moved() throws RepositoryException, IOException, PackageException {
+        // install default user at package path
+        User userA = installUserA(ImportMode.UPDATE, false, false);
+        String authPath = userA.getPath();
+
+        assertPropertyMissing(authPath + "/" + NAME_PROFILE_PROPERTY);
+
+        // install updated profile
+        JcrPackage pack = packMgr.upload(getStream("testpackages/test_user_a_profile_picture.zip"), false);
+        assertNotNull(pack);
+        pack.install(getDefaultOptions());
+
+        assertProperty(authPath + "/" + NAME_PROFILE_FULLNAME, "Test User");
+        assertProperty(authPath + "/" + NAME_PROFILE_PROPERTY, "a");
+        assertNodeExists(authPath + "/" + NAME_PROFILE_PICTURE_NODE);
+    }
+
     private User installUserA(ImportMode mode, boolean usePkgPath, boolean expectPkgPath) throws RepositoryException, IOException, PackageException {
         UserManager mgr = ((JackrabbitSession) admin).getUserManager();
         assertNull("test-user-a must not exist", mgr.getAuthorizable(ID_TEST_USER_A));
diff --git a/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_user_a_profile_picture.zip b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_user_a_profile_picture.zip
new file mode 100644
index 00000000..cf06361d
Binary files /dev/null and b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_user_a_profile_picture.zip differ
