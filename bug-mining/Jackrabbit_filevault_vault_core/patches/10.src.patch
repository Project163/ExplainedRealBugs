diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportInfo.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportInfo.java
index b7e4dc7b..b2a2081a 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportInfo.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/ImportInfo.java
@@ -18,6 +18,7 @@
 package org.apache.jackrabbit.vault.fs.api;
 
 import java.util.Collection;
+import java.util.Map;
 import java.util.TreeMap;
 
 /**
@@ -25,33 +26,104 @@ import java.util.TreeMap;
  */
 public interface ImportInfo {
 
+    /**
+     * @deprecated since 3.1
+     */
+    @Deprecated
     NodeNameList getNameList();
 
+    /**
+     * Marks that the node at {@code path} was modified.
+     * @param path the path
+     */
     void onModified(String path);
 
+    /**
+     * Marks that nothing changed at {@code path}
+     * @param path the path
+     */
     void onNop(String path);
 
+    /**
+     * Marks that the node at {@code path} was created.
+     * @param path the path
+     */
     void onCreated(String path);
 
+    /**
+     * Marks that the node at {@code path} was deleted.
+     * @param path the path
+     */
     void onDeleted(String path);
 
+    /**
+     * Marks that the node at {@code path} was replaced.
+     * @param path the path
+     */
     void onReplaced(String path);
 
+    /**
+     * Marks that the node at {@code path} is missing.
+     * @param path the path
+     */
     void onMissing(String path);
 
+    /**
+     * Marks that the node at {@code path} caused an error.
+     * @param path the path
+     * @param e exception
+     */
     void onError(String path, Exception e);
 
+    /**
+     * Returns the import information
+     * @return the import information
+     * @since 3.1
+     */
+    TreeMap<String, Info> getInfos();
+
+    /**
+     * Returns the info at {@code path}
+     * @param path path
+     * @return the info or {@code null}
+     * @since 3.1
+     */
+    Info getInfo(String path);
+
+    /**
+     * Returns the modifications of all infos
+     * @return the modifications
+     */
     TreeMap<String, Type> getModifications();
 
+    /**
+     * @deprecated since 3.1. use getInfo(path).getError();
+     */
+    @Deprecated
     Exception getError(String path);
 
+    /**
+     * Returns a collection of UUIDs of the nodes that need to be versioned.
+     * @return a collection of UUIDs.
+     */
     Collection<String> getToVersion();
 
+    /**
+     * Returns a list of memberships that need to be resolved
+     * @return a list of memberships
+     */
+    Map<String, String[]> getMemberships();
+
+    /**
+     * Merges an import info into this one.
+     * @param info the other info
+     * @return a new, merged info.
+     */
     ImportInfo merge(ImportInfo info);
     
     /**
      * returns the number of non-NOP entries.
-     * @return the number of modfiied entries.
+     * @return the number of modified entries.
      */
     int numModified();
 
@@ -61,13 +133,54 @@ public interface ImportInfo {
      */
     int numErrors();
 
+    /**
+     * The detailed information about an imported path
+     * @since 3.1
+     */
+    interface Info {
+
+        /**
+         * The path
+         * @return the path
+         */
+        String getPath();
+
+        /**
+         * The modification type
+         * @return the type
+         */
+        Type getType();
+
+        /**
+         * the child node name list if relevant
+         * @return the child node name list
+         */
+        NodeNameList getNameList();
+
+        /**
+         * The error or {@code null}
+         * @return the error
+         */
+        Exception getError();
+    }
+
+    /**
+     * The modification type
+     */
     public static enum Type {
+        /** created */
         CRE,
+        /** modified */
         MOD,
+        /** deleted */
         DEL,
+        /** replaced */
         REP,
+        /** nothing changed */
         NOP,
+        /** error */
         ERR,
+        /** missing */
         MIS
     }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/NodeNameList.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/NodeNameList.java
index da6254d3..55c7bb32 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/NodeNameList.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/api/NodeNameList.java
@@ -56,6 +56,10 @@ public class NodeNameList {
         return names.size() > 1 && parent.getPrimaryNodeType().hasOrderableChildNodes();
     }
 
+    public boolean isEmpty() {
+        return names.isEmpty();
+    }
+
     public boolean restoreOrder(Node parent) throws RepositoryException {
         // assume needsReorder check is performed
         // quick check if node is checked out
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
index de04b838..5a747603 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
@@ -1067,6 +1067,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             // need to be removed
             NodeNameList childNames = stack.getChildNames();
             Node node = stack.getNode();
+            int numChildren = 0;
             if (node == null) {
                 DocViewAdapter adapter = stack.getAdapter();
                 if (adapter != null) {
@@ -1081,6 +1082,7 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
             } else {
                 NodeIterator iter = node.getNodes();
                 while (iter.hasNext()) {
+                    numChildren++;
                     Node child = iter.nextNode();
                     String path = child.getPath();
                     String label = Text.getName(path);
@@ -1114,10 +1116,13 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                 }
             }
             stack = stack.pop();
-            if (stack.isRoot()) {
-                // record child names of root node
-                importInfo.setNameList(childNames);
-                importInfo.setNode(node);
+//            if (stack.isRoot()) {
+//                // record child names of root node
+//                importInfo.setNameList(childNames);
+//                importInfo.setNode(node);
+//            }
+            if (node != null && numChildren == 0 && !childNames.isEmpty()) {
+                importInfo.addNameList(node.getPath(), childNames);
             }
         } catch (RepositoryException e) {
             throw new SAXException(e);
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
index 7db99a81..28884fe5 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
@@ -49,9 +49,7 @@ public class ImportInfoImpl implements ImportInfo {
      */
     static final Logger log = LoggerFactory.getLogger(ImportInfoImpl.class);
 
-    private final TreeMap<String, Type> mods = new TreeMap<String, Type>(new PathComparator());
-
-    private final Map<String, Exception> errorMap =  new HashMap<String, Exception>();
+    private final TreeMap<String, Info> infos = new TreeMap<String, Info>(new PathComparator());
 
     private Map<String, String> remapped;
 
@@ -60,12 +58,10 @@ public class ImportInfoImpl implements ImportInfo {
      */
     private final Set<String> toVersion = new LinkedHashSet<String>();
 
-    private NodeNameList nameList;
-
-    private Node node;
-
     private int numModified;
 
+    private int numErrors;
+
     private Map<String, String[]> memberships;
 
     public static ImportInfo create(ImportInfo base) {
@@ -82,15 +78,10 @@ public class ImportInfoImpl implements ImportInfo {
     public ImportInfoImpl merge(ImportInfo base) {
         if (base instanceof ImportInfoImpl) {
             ImportInfoImpl baseImpl = (ImportInfoImpl) base;
-            mods.putAll(baseImpl.mods);
-            errorMap.putAll(baseImpl.errorMap);
+            infos.putAll(baseImpl.infos);
             numModified +=baseImpl.numModified;
+            numErrors += baseImpl.numErrors;
             toVersion.addAll(baseImpl.toVersion);
-            // also merge node and name list if not set yet
-            if (node == null) {
-                node = baseImpl.node;
-                nameList = baseImpl.nameList;
-            }
             if (remapped == null) {
                 remapped = baseImpl.remapped;
             } else {
@@ -105,58 +96,64 @@ public class ImportInfoImpl implements ImportInfo {
         return this;
     }
 
-    public NodeNameList getNameList() {
-        return nameList;
+    public TreeMap<String, Info> getInfos() {
+        return infos;
     }
 
-    public void setNameList(NodeNameList nameList) {
-        this.nameList = nameList;
+    public Info getInfo(String path) {
+        return infos.get(path);
     }
 
-    /**
-     * Returns the root node of this import.
-     * @return root node if this import or <code>null</code>
-     */
-    public Node getNode() {
-        return node;
+    @Deprecated
+    public NodeNameList getNameList() {
+        return infos.isEmpty()
+                ? null
+                : infos.firstEntry().getValue().getNameList();
     }
 
-    public void setNode(Node node) {
-        this.node = node;
+    private InfoImpl getOrCreateInfo(String path) {
+        InfoImpl info = (InfoImpl) infos.get(path);
+        if (info == null) {
+            info = new InfoImpl(path);
+            infos.put(path, info);
+        }
+        return info;
+    }
+
+    public void addNameList(String path, NodeNameList nameList) {
+        getOrCreateInfo(path).nameList = nameList;
     }
 
     public void onModified(String path) {
-        Type prev = mods.get(path);
+        Type prev = getOrCreateInfo(path).type;
         if (prev == null || prev != Type.CRE) {
-            addMod(path, Type.MOD);
+            addMod(path, Type.MOD, null);
         }
     }
 
     public void onNop(String path) {
-        if (!mods.containsKey(path)) {
-            addMod(path, Type.NOP);
-        }
+        getOrCreateInfo(path);
     }
 
     public void onCreated(String path) {
-        addMod(path, Type.CRE);
+        addMod(path, Type.CRE, null);
     }
 
     public void onDeleted(String path) {
-        addMod(path, Type.DEL);
+        addMod(path, Type.DEL, null);
     }
 
     public void onReplaced(String path) {
-        addMod(path, Type.REP);
+        addMod(path, Type.REP, null);
     }
 
     public void onMissing(String path) {
-        addMod(path, Type.MIS);
+        addMod(path, Type.MIS, null);
     }
 
     public void onError(String path, Exception e) {
-        addMod(path, Type.ERR);
-        errorMap.put(path, e);
+        addMod(path, Type.ERR, e);
+        numErrors++;
     }
 
     public void onRemapped(String oldPath, String newPath) {
@@ -170,23 +167,34 @@ public class ImportInfoImpl implements ImportInfo {
         return remapped == null ? Collections.<String, String>emptyMap() : remapped;
     }
 
-    private void addMod(String path, Type mod) {
-        // don't overwrite errors
-        if (mods.get(path) != Type.ERR) {
-            mods.put(path, mod);
-            if (mod != Type.NOP) {
-                numModified++;
-            }
+    private void addMod(String path, Type mod, Exception e) {
+        InfoImpl info = getOrCreateInfo(path);
+        if (info.type != Type.ERR) {
+            info.type = mod;
+            info.error = e;
+        }
+        if (mod != Type.NOP) {
+            numModified++;
         }
         log.debug("{} {}", mod, path);
     }
 
     public TreeMap<String, Type> getModifications() {
+        TreeMap<String, Type> mods = new TreeMap<String, Type>();
+        for (Map.Entry<String, Info> e: infos.entrySet()) {
+            Type mod = e.getValue().getType();
+            if (mod != null) {
+                mods.put(e.getKey(), mod);
+            }
+        }
         return mods;
     }
 
+    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
+    @Deprecated
     public Exception getError(String path) {
-        return errorMap.get(path);
+        Info info = infos.get(path);
+        return info == null ? null : info.getError();
     }
 
     public Collection<String> getToVersion() {
@@ -225,7 +233,7 @@ public class ImportInfoImpl implements ImportInfo {
     }
 
     public int numErrors() {
-        return errorMap.size();
+        return numErrors;
     }
 
     public void registerMemberships(String id, String[] members) {
@@ -238,4 +246,35 @@ public class ImportInfoImpl implements ImportInfo {
     public Map<String, String[]> getMemberships() {
         return memberships == null ? Collections.<String, String[]>emptyMap() : memberships;
     }
+
+    static final class InfoImpl implements Info {
+
+        private final String path;
+
+        private Type type = Type.NOP;
+
+        private NodeNameList nameList;
+
+        private Exception error;
+
+        InfoImpl(String path) {
+            this.path = path;
+        }
+
+        public String getPath() {
+            return path;
+        }
+
+        public Type getType() {
+            return type;
+        }
+
+        public NodeNameList getNameList() {
+            return nameList;
+        }
+
+        public Exception getError() {
+            return error;
+        }
+    }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
index 65fa2512..be807b40 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
@@ -236,7 +236,7 @@ public class Importer {
     /**
      * the checkpoint import info.
      */
-    private ImportInfoImpl cpImportInfo;
+    private ImportInfo cpImportInfo;
 
     /**
      * retry counter for the batch auto recovery
@@ -748,7 +748,7 @@ public class Importer {
 
     private void commit(Session session, TxInfo info, LinkedList<TxInfo> skipList) throws RepositoryException, IOException {
         try {
-            ImportInfoImpl imp = null;
+            ImportInfo imp = null;
             if (skipList.isEmpty()) {
                 if (info == cpTxInfo) {
                     // don't need to import again, just set import info
@@ -904,9 +904,9 @@ public class Importer {
         }
 
         if (imp != null) {
-            for (Map.Entry<String, ImportInfoImpl.Type> entry: imp.getModifications().entrySet()) {
+            for (Map.Entry<String, ImportInfo.Info> entry: imp.getInfos().entrySet()) {
                 String path = entry.getKey();
-                ImportInfoImpl.Type type = entry.getValue();
+                ImportInfo.Type type = entry.getValue().getType();
                 if (type != ImportInfoImpl.Type.DEL) {
                     // mark intermediates as processed
                     TxInfo im = intermediates.remove(path);
@@ -942,7 +942,7 @@ public class Importer {
                         autoSave.markMissing(path);
                         break;
                     case ERR:
-                        Exception error = imp.getError(path);
+                        Exception error = entry.getValue().getError();
                         if (error == null) {
                             track("E", path);
                         } else {
@@ -951,17 +951,31 @@ public class Importer {
                         hasErrors = true;
                         break;
                 }
-            }
-            // see if any child nodes need to be reordered and remember namelist. we can only reorder the children 
-            if (imp.getNameList() != null && imp.getNode() != null && imp.getNameList().needsReorder(imp.getNode())) {
+
+                // see if any child nodes need to be reordered and remember namelist. we can only reorder the children
+                NodeNameList nameList = entry.getValue().getNameList();
                 // only restore order if in filter scope (bug #31906)
                 // or if freshly created (bug #32075)
-                if (filter.contains(info.path) || imp.getModifications().get(info.path) == ImportInfo.Type.CRE) {
-                    assert(info.path.equals(imp.getNode().getPath()));
-                    log.debug("remember to be reordered. path={} node.path={}", info.path, imp.getNode().getPath());
-                    info.nameList = imp.getNameList();
+                if (nameList != null && (filter.contains(path) || type == ImportInfo.Type.CRE)) {
+                    // find tx info
+                    TxInfo subInfo = info.findChild(path);
+                    if (subInfo != null) {
+                        subInfo.nameList = nameList;
+                    }
                 }
             }
+//            // see if any child nodes need to be reordered and remember namelist. we can only reorder the children
+//            ImportInfo.Info impInfo = imp.getInfo(info.path);
+//            if (impInfo != null && impInfo.getNameList() != null) {
+//            //if (imp.getNameList() != null && imp.getNode() != null && imp.getNameList().needsReorder(imp.getNode())) {
+//                // only restore order if in filter scope (bug #31906)
+//                // or if freshly created (bug #32075)
+//                if (filter.contains(info.path) || impInfo.getType() == ImportInfo.Type.CRE) {
+//                    //assert(info.path.equals(imp.getNode().getPath()));
+//                    log.debug("remember to be reordered. path={} node.path={}", info.path, impInfo.getPath());
+//                    info.nameList = impInfo.getNameList();
+//                }
+//            }
             // check if node was remapped. currently we just skip them as it's not clear how the filter should be
             // reapplied or what happens if the remapping links to a tree we already processed.
             // in this case we don't descend in any children and can clear them right away
@@ -1140,6 +1154,24 @@ public class Importer {
             artifacts = null;
             children = null;
         }
+
+        public TxInfo findChild(String absPath) {
+            if (path.equals(absPath)) {
+                return this;
+            }
+            if (!absPath.startsWith(path + "/")) {
+                return null;
+            }
+            absPath = absPath.substring(path.length());
+            TxInfo root = this;
+            for (String name: Text.explode(absPath, '/')) {
+                root = root.children().get(name);
+                if (root == null) {
+                    break;
+                }
+            }
+            return root;
+        }
     }
 
 }
\ No newline at end of file
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestPackageInstall.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestPackageInstall.java
index 2bfd6838..6f98e982 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestPackageInstall.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestPackageInstall.java
@@ -20,6 +20,8 @@ package org.apache.jackrabbit.vault.packaging.integration;
 import java.io.File;
 import java.io.IOException;
 
+import javax.jcr.Node;
+import javax.jcr.NodeIterator;
 import javax.jcr.RepositoryException;
 
 import org.apache.commons.io.FileUtils;
@@ -251,7 +253,24 @@ public class TestPackageInstall extends IntegrationTestBase {
         assertNodeExists("/tmp/test/content/foo/jcr:content/a/folder/file.txt/jcr:content");
     }
 
+    /**
+     * installs a package that contains a node with childnode ordering and full-coverage sub nodes.
+     * see JCRVLT-24
+     */
+    @Test
+    public void testChildNodeOrder() throws IOException, RepositoryException, PackageException {
+        JcrPackage pack = packMgr.upload(getStream("testpackages/test_childnodeorder.zip"), false);
+        assertNotNull(pack);
+        pack.install(getDefaultOptions());
 
+        assertNodeExists("/tmp/ordertest/test/rail/items/modes/items");
+        NodeIterator iter = admin.getNode("/tmp/ordertest/test/rail/items/modes/items").getNodes();
+        StringBuilder names = new StringBuilder();
+        while (iter.hasNext()) {
+            names.append(iter.nextNode().getName()).append(",");
+        }
+        assertEquals("child order", "a,d,b,c,", names.toString());
+    }
 
     // todo: upload with version
     // todo: install / uninstall
diff --git a/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_childnodeorder.zip b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_childnodeorder.zip
new file mode 100644
index 00000000..7b4669b7
Binary files /dev/null and b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/testpackages/test_childnodeorder.zip differ
