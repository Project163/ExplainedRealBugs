diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewAdapter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewAdapter.java
index e542f0a4..e50a4ddb 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewAdapter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewAdapter.java
@@ -16,6 +16,7 @@
  ************************************************************************/
 package org.apache.jackrabbit.vault.fs.impl.io;
 
+import java.io.IOException;
 import java.util.List;
 
 import javax.jcr.RepositoryException;
@@ -35,19 +36,19 @@ public interface DocViewAdapter {
      * @param node the node
      * @throws RepositoryException if a import exception occurs.
      */
-    void startNode(DocViewNode2 node) throws RepositoryException;
+    void startNode(DocViewNode2 node) throws IOException, RepositoryException;
 
     /**
      * Ends node is invoked when the importer ascends from an element.
      * @throws RepositoryException if a import exception occurs.
      */
-    void endNode() throws RepositoryException;
+    void endNode() throws IOException, RepositoryException;
 
     /**
      * Is called by the importer if the adapter is no longer used and must finalize the import.
      * @throws RepositoryException if a import exception occurs.
      * @return The paths that were created.
      */
-    List<String> close() throws RepositoryException;
+    List<String> close() throws IOException, RepositoryException;
 
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewImporter.java
index 97a01b7b..e6af027a 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewImporter.java
@@ -54,6 +54,7 @@ import javax.jcr.nodetype.NoSuchNodeTypeException;
 import javax.jcr.nodetype.NodeDefinition;
 import javax.jcr.nodetype.NodeType;
 import javax.jcr.nodetype.PropertyDefinition;
+import javax.jcr.security.AccessControlPolicy;
 import javax.jcr.version.VersionException;
 
 import org.apache.jackrabbit.spi.Name;
@@ -481,7 +482,9 @@ public class DocViewImporter implements DocViewParserHandler {
                                     }
                                 }
                             } 
+
                             if (shouldRemoveChild) {
+                                stashPrincipalAcls(child);
                                 importInfo.onDeleted(path);
                                 child.remove();
                             }
@@ -505,6 +508,14 @@ public class DocViewImporter implements DocViewParserHandler {
         }
     }
 
+    protected void stashPrincipalAcls(Node node) throws RepositoryException {
+        Map<String, List<? extends AccessControlPolicy>> principalAcls = aclManagement.getPrincipalAcls(node);
+        if (!principalAcls.isEmpty()) {
+            log.debug("Stashing {} principal ACLs below to be deleted node {}", principalAcls.size(), node.getPath());
+            importInfo.onDeletedPrincipalAcls(principalAcls);
+        }
+    }
+
     private boolean hasSiblingWithPrimaryTypesAndName(Node node, NodeType[] requiredPrimaryNodeTypes, String requiredName) throws RepositoryException {
         NodeIterator iter = node.getParent().getNodes();
         while (iter.hasNext()) {
@@ -723,24 +734,29 @@ public class DocViewImporter implements DocViewParserHandler {
      * @param node the parent node
      * @param docViewNode   doc view node of the authorizable
      * @throws RepositoryException if an error accessing the repository occurrs.
+     * @throws IOException 
      * @throws SAXException        if an XML parsing error occurrs.
      */
-    private void handleAuthorizable(Node node, DocViewNode2 docViewNode) throws RepositoryException {
+    private void handleAuthorizable(Node node, DocViewNode2 docViewNode) throws RepositoryException, IOException {
         String id = userManagement.getAuthorizableId(docViewNode);
         String newPath = node.getPath() + "/" + npResolver.getJCRName(docViewNode.getName());
         boolean isIncluded = wspFilter.contains(newPath);
         String oldPath = userManagement.getAuthorizablePath(this.session, id);
+        // what to do with policies inside the authorizable node subtree?
+        boolean keepAcPolicies = aclHandling == AccessControlHandling.IGNORE || 
+                aclHandling == AccessControlHandling.MERGE || 
+                aclHandling == AccessControlHandling.MERGE_PRESERVE;
         if (oldPath == null) {
             if (!isIncluded) {
                 log.trace("auto-creating authorizable node not in filter {}", newPath);
             }
 
             // just import the authorizable node
-            log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
+            log.trace("Authorizable element detected. Starting sysview transformation {}", newPath);
             stack = stack.push();
-            stack.adapter = new JcrSysViewTransformer(node, wspFilter.getImportMode(newPath));
+            stack.adapter = new JcrSysViewTransformer(node, wspFilter.getImportMode(newPath), keepAcPolicies);
             stack.adapter.startNode(docViewNode);
-            importInfo.onCreated(newPath);
+            importInfo.onAuthorizableCreated(id);
             return;
         }
 
@@ -782,16 +798,19 @@ public class DocViewImporter implements DocViewParserHandler {
                 // just replace the entire subtree for now.
                 log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
                 stack = stack.push();
-                stack.adapter = new JcrSysViewTransformer(node, mode);
+                // the principal ACLs are automatically restored by the JcrSysViewTransformer (depending on aclHandling)
+                stack.adapter = new JcrSysViewTransformer(node, mode, keepAcPolicies);
                 stack.adapter.startNode(docViewNode);
-                importInfo.onReplaced(newPath);
+                importInfo.onReplaced(oldPath);
+                importInfo.onAuthorizableCreated(id);
                 break;
 
             case UPDATE:
             case UPDATE_PROPERTIES:
                 log.trace("Authorizable element detected. starting sysview transformation {}", newPath);
                 stack = stack.push();
-                stack.adapter = new JcrSysViewTransformer(node, oldPath, mode);
+                // the principal ACLs are automatically restored by the JcrSysViewTransformer (depending on aclHandling)
+                stack.adapter = new JcrSysViewTransformer(node, oldPath, mode, keepAcPolicies);
                 // we need to tweak the ni.name so that the sysview import does not
                 // rename the authorizable node name
                 String newName = Text.getName(oldPath);
@@ -813,7 +832,8 @@ public class DocViewImporter implements DocViewParserHandler {
                 );
                 
                 stack.adapter.startNode(mapped);
-                importInfo.onReplaced(newPath);
+                importInfo.onReplaced(oldPath);
+                importInfo.onAuthorizableCreated(id);
                 break;
         }
     }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
index 2106cb21..78cc5790 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/ImportInfoImpl.java
@@ -17,11 +17,13 @@
 
 package org.apache.jackrabbit.vault.fs.impl.io;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
@@ -29,8 +31,10 @@ import java.util.TreeMap;
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
 import javax.jcr.Session;
+import javax.jcr.security.AccessControlPolicy;
 import javax.jcr.version.Version;
 
+import org.apache.jackrabbit.api.security.user.Authorizable;
 import org.apache.jackrabbit.vault.fs.api.ImportInfo;
 import org.apache.jackrabbit.vault.fs.api.MultiPathMapping;
 import org.apache.jackrabbit.vault.fs.api.NodeNameList;
@@ -66,6 +70,29 @@ public class ImportInfoImpl implements ImportInfo {
 
     private Map<String, String[]> memberships;
 
+    /**
+     * The principal ACLs which have been deleted during the import (might need to be restored later in case parent authorizable has been recreated)
+     */
+    private final Map<String, List<? extends AccessControlPolicy>> deletedPrincipalAcls;
+
+    public Map<String, List<? extends AccessControlPolicy>> getDeletedPrincipalAcls() {
+        return deletedPrincipalAcls;
+    }
+
+    public List<String> getCreatedAuthorizableIds() {
+        return createdAuthorizableIds;
+    }
+
+    /**
+     * All authorizable ids being deleted during the import
+     */
+    private final List<String> deletedAuthorizableIds;
+
+    /**
+     * All authorizable ids being created during the import
+     */
+    private final List<String> createdAuthorizableIds;
+
     public static ImportInfo create(ImportInfo base) {
         if (base == null) {
             return new ImportInfoImpl();
@@ -75,6 +102,9 @@ public class ImportInfoImpl implements ImportInfo {
     }
 
     public ImportInfoImpl() {
+        deletedPrincipalAcls = new HashMap<>();
+        createdAuthorizableIds = new ArrayList<>();
+        deletedAuthorizableIds = new ArrayList<>();
     }
 
     public ImportInfoImpl merge(ImportInfo base) {
@@ -94,6 +124,9 @@ public class ImportInfoImpl implements ImportInfo {
             } else {
                 memberships.putAll(baseImpl.getMemberships());
             }
+            deletedPrincipalAcls.putAll(baseImpl.deletedPrincipalAcls);
+            deletedAuthorizableIds.addAll(baseImpl.deletedAuthorizableIds);
+            createdAuthorizableIds.addAll(baseImpl.createdAuthorizableIds);
         }
         return this;
     }
@@ -164,6 +197,10 @@ public class ImportInfoImpl implements ImportInfo {
         numModified += 1;
     }
 
+    public void onDeletedPrincipalAcls(Map<String, List<? extends AccessControlPolicy>> principalAcls) {
+        deletedPrincipalAcls.putAll(principalAcls);
+    }
+
     /**
      * remembers that a package path was remapped during import. e.g. when the importer follows and existing
      * authorizable for MERGE and UPDATE modes.
@@ -264,6 +301,10 @@ public class ImportInfoImpl implements ImportInfo {
         return memberships == null ? Collections.<String, String[]>emptyMap() : memberships;
     }
 
+    public void onAuthorizableCreated(String id) throws RepositoryException {
+        createdAuthorizableIds.add(id);
+    }
+
     static final class InfoImpl implements Info {
 
         private final String path;
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JackrabbitACLImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JackrabbitACLImporter.java
index f8b5db69..1224e886 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JackrabbitACLImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JackrabbitACLImporter.java
@@ -16,48 +16,44 @@
  ************************************************************************/
 package org.apache.jackrabbit.vault.fs.impl.io;
 
-import java.security.Principal;
-import java.util.ArrayList;
+import java.io.IOException;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.Function;
 import java.util.stream.Collectors;
 
+import javax.jcr.NamespaceException;
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
 import javax.jcr.Session;
 import javax.jcr.Value;
-import javax.jcr.ValueFactory;
-import javax.jcr.security.AccessControlEntry;
-import javax.jcr.security.AccessControlException;
-import javax.jcr.security.AccessControlManager;
-import javax.jcr.security.AccessControlPolicy;
-import javax.jcr.security.AccessControlPolicyIterator;
-import javax.jcr.security.Privilege;
+import javax.jcr.ValueFormatException;
 
-import org.apache.jackrabbit.api.JackrabbitSession;
-import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;
-import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
-import org.apache.jackrabbit.api.security.authorization.PrincipalAccessControlList;
-import org.apache.jackrabbit.api.security.authorization.PrincipalSetPolicy;
-import org.apache.jackrabbit.api.security.principal.PrincipalManager;
-import org.apache.jackrabbit.api.security.user.Authorizable;
-import org.apache.jackrabbit.commons.jackrabbit.authorization.AccessControlUtils;
 import org.apache.jackrabbit.spi.Name;
 import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
 import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
-import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
 import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitACLManagement;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.AbstractAccessControlEntry;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.JackrabbitAccessControlEntryBuilder;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.JackrabbitAccessControlPolicy;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.JackrabbitAccessControlPolicyBuilder;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.PrincipalBasedAccessControlEntry;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.PrincipalBasedAccessControlList;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.PrincipalSetAccessControlPolicy;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.ResourceBasedAccessControlEntry;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.ResourceBasedAccessControlList;
 import org.apache.jackrabbit.vault.util.DocViewNode2;
 import org.apache.jackrabbit.vault.util.DocViewProperty2;
+import org.apache.jackrabbit.vault.util.UncheckedRepositoryException;
+import org.apache.jackrabbit.vault.util.UncheckedValueFormatException;
 import org.slf4j.Logger;
 
 /**
@@ -66,6 +62,7 @@ import org.slf4j.Logger;
  */
 public class JackrabbitACLImporter implements DocViewAdapter {
 
+    // TODO: move to repository impl specific package
     private static final Name NAME_REP_EFFECTIVE_PATH = NameFactoryImpl.getInstance().create(Name.NS_REP_URI, "effectivePath");
     private static final Name NAME_REP_PRINCIPAL_NAMES = NameFactoryImpl.getInstance().create(Name.NS_REP_URI, "principalNames");
 
@@ -74,29 +71,39 @@ public class JackrabbitACLImporter implements DocViewAdapter {
      */
     private static final Logger log = DocViewImporter.log;
 
-    private final JackrabbitSession session;
+    private final Session session;
 
     private final AccessControlHandling aclHandling;
 
-    private final AccessControlManager acMgr;
-
-    private final PrincipalManager pMgr;
-
     private final String accessControlledPath;
 
     private final  NamePathResolver resolver;
 
-    private ImportedPolicy<? extends AccessControlPolicy> importPolicy;
-
+    /**
+     * The state representing the level of the last evaluated node (i.e. the parent)
+     *
+     */
     private enum State {
         INITIAL,
-        ACL,
-        ACE,
-        RESTRICTION,
-        ERROR,
-        PRINCIPAL_SET_POLICY
+        RESOURCE_BASED_ACL,
+        PRINCIPAL_BASED_ACL,
+        PRINCIPAL_SET_POLICY,
+        RESOURCE_BASED_ACE,
+        PRINCIPAL_BASED_ACE,
+        RESTRICTION
     }
 
+    /** all property names on either rep:GrantACE/rep:DenyACE or rep:Restrictions which don't represent an access control restriction */
+    private static final Set<Name> NON_RESTRICTION_PROPERTY_NAMES = new HashSet<>(Arrays.asList(
+            NameConstants.REP_PRINCIPAL_NAME,
+            NameConstants.JCR_PRIMARYTYPE,
+            NameConstants.JCR_MIXINTYPES,
+            NameConstants.REP_PRIVILEGES
+            ));
+
+    private JackrabbitAccessControlPolicyBuilder<?> policyBuilder;
+    private JackrabbitAccessControlEntryBuilder<? extends AbstractAccessControlEntry> entryBuilder;
+   
     private final Deque<State> states = new LinkedList<>();
 
     public JackrabbitACLImporter(Node accessControlledNode, AccessControlHandling aclHandling)
@@ -115,433 +122,156 @@ public class JackrabbitACLImporter implements DocViewAdapter {
             throw new RepositoryException("Error while reading access control content: unsupported AccessControlHandling: " + aclHandling);
         }
         this.accessControlledPath = path;
-        this.session = (JackrabbitSession) session;
-        this.acMgr = this.session.getAccessControlManager();
-        this.pMgr = this.session.getPrincipalManager();
+        this.session = session;
         this.aclHandling = aclHandling;
         this.states.push(State.INITIAL);
         this.resolver = new DefaultNamePathResolver(session);
     }
 
-    public void startNode(DocViewNode2 node) {
+    public void startNode(DocViewNode2 node) throws RepositoryException, IOException {
         State state = states.peek();
-        switch (state) {
-            case INITIAL:
-                String primaryType = node.getPrimaryType().orElseThrow(() -> new IllegalStateException("Error while reading access control content: Missing 'jcr:primaryType'"));
-                if ("rep:ACL".equals(primaryType)) {
-                    importPolicy = new ImportedAcList();
-                    state = State.ACL;
-                } else if ("rep:CugPolicy".equals(primaryType)) {
-                    importPolicy = new ImportedPrincipalSet(node);
-                    state = State.PRINCIPAL_SET_POLICY;
-                } else if ("rep:PrincipalPolicy".equals(primaryType)) {
-                    importPolicy = new ImportedPrincipalAcList(node);
-                    state = State.ACL;
-                } else {
-                    log.error("Error while reading access control content: Expected rep:ACL or rep:CugPolicy but was: {}", node.getPrimaryType());
-                    state = State.ERROR;
-                }
-                break;
-            case ACL:
-            case ACE:
-            case RESTRICTION:
-                state = importPolicy.append(state, node);
-                break;
-            case PRINCIPAL_SET_POLICY:
-                state = importPolicy.append(state, node);
-                break;
-            case ERROR:
-                // stay in error
-                break;
-        }
-        states.push(state);
-    }
-
-    public void endNode() {
-        State state = states.pop();
-        importPolicy.endNode(state);
-    }
-
-    public List<String> close() throws RepositoryException {
-        if (states.peek() != State.INITIAL) {
-            log.error("Unexpected end state: {}", states.peek());
-        }
-        List<String> paths = new ArrayList<>();
-        importPolicy.apply(paths, resolver);
-        return paths;
-    }
-
-    private void addPathIfExists(List<String> paths, String path) throws RepositoryException {
-        if (session.nodeExists(path)) {
-            paths.add(path);
-        }
-    }
-
-    private abstract class ImportedPolicy<T extends AccessControlPolicy> {
-
-        abstract State append(State state, DocViewNode2 node);
-
-        abstract void endNode(State state);
-
-        abstract void apply(List<String> paths, NameResolver resolver) throws RepositoryException;
-
-        Principal getPrincipal(final String principalName) {
-            Principal principal = new Principal() {
-                public String getName() {
-                    return principalName;
-                }
-            };
-            return principal;
-        }
-
-        T getPolicy(Class<T> clz) throws RepositoryException {
-            for (AccessControlPolicy p : acMgr.getPolicies(accessControlledPath)) {
-                if (clz.isAssignableFrom(p.getClass())) {
-                    return clz.cast(p);
-                }
-            }
-            return null;
-        }
-
-        T getPolicy(Class<T> clz, Principal principal) throws RepositoryException {
-            if (acMgr instanceof JackrabbitAccessControlManager) {
-                for (AccessControlPolicy p : ((JackrabbitAccessControlManager) acMgr).getPolicies(principal)) {
-                    if (clz.isAssignableFrom(p.getClass())) {
-                        return clz.cast(p);
-                    }
-                }
-            }
-            return null;
-        }
-
-        T getApplicablePolicy(Class<T> clz) throws RepositoryException {
-            AccessControlPolicyIterator iter = acMgr.getApplicablePolicies(accessControlledPath);
-            while (iter.hasNext()) {
-                AccessControlPolicy p = iter.nextAccessControlPolicy();
-                if (clz.isAssignableFrom(p.getClass())) {
-                    return clz.cast(p);
-                }
-            }
-
-            // no applicable policy
-            throw new RepositoryException("no applicable AccessControlPolicy of type "+ clz + " on " +
-                    (accessControlledPath == null ? "'root'" : accessControlledPath));
-        }
-
-        T getApplicablePolicy(Class<T> clz, Principal principal) throws RepositoryException {
-            if (acMgr instanceof JackrabbitAccessControlManager) {
-                for (AccessControlPolicy p : ((JackrabbitAccessControlManager) acMgr).getApplicablePolicies(principal)) {
-                    if (clz.isAssignableFrom(p.getClass())) {
-                        return clz.cast(p);
+        try {
+            switch (state) {
+                case INITIAL:
+                    String primaryType = node.getPrimaryType().orElseThrow(() -> new IllegalStateException("Error while reading access control content: Missing 'jcr:primaryType'"));
+                    if (JackrabbitACLManagement.NT_REP_ACL.equals(primaryType)) {
+                        policyBuilder = new ResourceBasedAccessControlList.Builder();
+                        state = State.RESOURCE_BASED_ACL;
+                    } else if (JackrabbitACLManagement.NT_REP_CUG_POLICY.equals(primaryType)) {
+                        // just collect the rep:principalNames property
+                        Collection<String> principalNames = node.getPropertyValues(NAME_REP_PRINCIPAL_NAMES);
+                        policyBuilder = new PrincipalSetAccessControlPolicy.Builder(principalNames);
+                        state = State.PRINCIPAL_SET_POLICY;
+                    } else if (JackrabbitACLManagement.NT_REP_PRINCIPAL_POLICY.equals(primaryType)) {
+                        String principalName = node.getPropertyValue(NameConstants.REP_PRINCIPAL_NAME).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:principalName' missing on principal policy node"));
+                        policyBuilder = new PrincipalBasedAccessControlList.Builder(principalName);
+                        state = State.PRINCIPAL_BASED_ACL;
+                    } else {
+                        throw new IOException("Error while reading access control content: Expected rep:ACL, rep:PrincipalPolicy or rep:CugPolicy primary type but found: " + node.getPrimaryType().toString());
                     }
-                }
+                    break;
+                case RESOURCE_BASED_ACL:
+                case PRINCIPAL_BASED_ACL:
+                case RESOURCE_BASED_ACE:
+                case PRINCIPAL_BASED_ACE:
+                case RESTRICTION:
+                    state = startEntryNode(node, state);
+                    break;
+                case PRINCIPAL_SET_POLICY:
+                    throw new IOException("Error while reading access control content: Unexpected node: " + node.getPrimaryType().orElse("") + " for state " + state);
             }
-
-            // no applicable policy
-            throw new AccessControlException("no applicable AccessControlPolicy of type "+ clz + " for " + principal.getName());
-        }
+        } catch (UncheckedRepositoryException e) {
+            throw e.getCause();
+        } 
+        states.push(state);
     }
 
-    private final class ImportedAcList extends ImportedPolicy<JackrabbitAccessControlList> {
-
-        private List<ACE> aceList = new ArrayList<>();
-        private ACE currentACE;
-
-        private ImportedAcList() {
-        }
-
-        @Override
-        State append(State state, DocViewNode2 childNode) {
-            if (state == State.ACL) {
-                try {
-                    currentACE = new ACE(childNode);
-                    aceList.add(currentACE);
-                    return State.ACE;
-                } catch (IllegalArgumentException e) {
-                    log.error("Error while reading access control content: {}", e);
-                    return State.ERROR;
+    /**
+     * Extracts all information from rep:GrantACE/rep:DenyACE and children.
+     * This is used for both resource-based and principal based access control entries.
+     * 
+     * @param node
+     * @param state
+     * @return
+     * @see <a href="https://jackrabbit.apache.org/oak/docs/security/accesscontrol/default.html#representation-in-the-repository">Oak Access Control Management : The Default Implementation</a>
+     * @see <a href="https://jackrabbit.apache.org/oak/docs/security/authorization/principalbased.html#representation-in-the-repository">Oak Principal Based Access Control Management</a>
+     * @see <a href="https://jackrabbit.apache.org/oak/docs/security/authorization/restriction.html#representation-in-the-repository">Oak Restrictions</a>
+     */
+    private State startEntryNode(DocViewNode2 node, State state) throws IOException {
+        final State newState;
+        switch(state) {
+            case RESOURCE_BASED_ACL: {
+                final boolean allow;
+                final String primaryType = node.getPrimaryType().orElseThrow(() -> new IllegalStateException("mandatory property 'jcr:primaryType' missing on ace node"));
+                if (JackrabbitACLManagement.NT_REP_GRANT_ACE.equals(primaryType)) {
+                    allow = true;
+                } else if (JackrabbitACLManagement.NT_REP_DENY_ACE.equals(primaryType)) {
+                    allow = false;
+                } else {
+                    throw new IOException("Unexpected node ACE type inside resource based ACL: " + node.getPrimaryType());
                 }
-            } else if (state == State.ACE) {
-                currentACE.addRestrictions(childNode);
-                return State.RESTRICTION;
-            } else {
-                log.error("Error while reading access control content: Unexpected node: {} for state {}", childNode.getPrimaryType(), state);
-                return State.ERROR;
-            }
-        }
-
-        @Override
-        void endNode(State state) {
-            if (state == State.ACE) {
-                currentACE = null;
+                final String principalName = node.getPropertyValue(NameConstants.REP_PRINCIPAL_NAME).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:principalName' missing"));
+                Collection<String> privileges = node.getPropertyValues(NameConstants.REP_PRIVILEGES);
+                entryBuilder = new ResourceBasedAccessControlEntry.Builder(privileges, allow, principalName);
+                extractRestrictions(node).entrySet().stream().forEach( entry -> entryBuilder.addRestriction(entry.getKey(), entry.getValue()));
+                newState = State.RESOURCE_BASED_ACE;
+                break;
             }
-        }
-
-        @Override
-        void apply(List<String> paths, NameResolver resolver) throws RepositoryException {
-            // find principals of existing ACL
-            JackrabbitAccessControlList acl = getPolicy(JackrabbitAccessControlList.class);
-            Set<String> existingPrincipals = new HashSet<String>();
-            if (acl != null) {
-                for (AccessControlEntry ace: acl.getAccessControlEntries()) {
-                    existingPrincipals.add(ace.getPrincipal().getName());
-                }
-
-                // remove existing policy for 'overwrite'
-                if (aclHandling == AccessControlHandling.OVERWRITE) {
-                    acMgr.removePolicy(accessControlledPath, acl);
-                    acl = null;
+            case PRINCIPAL_BASED_ACL: {
+                if (!"rep:PrincipalEntry".equals(node.getPrimaryType().orElseThrow(() -> new IllegalStateException("mandatory property 'jcr:primaryType' missing on principal policy node")))) {
+                    throw new IOException("Unexpected node ACE type inside principal based ACL: " + node.getPrimaryType());
                 }
-            }
-
-            if (acl == null) {
-                acl = getApplicablePolicy(JackrabbitAccessControlList.class);
-            }
-
-            // clear all ACEs of the package principals for merge (VLT-94), otherwise the `acl.addEntry()` below
-            // might just combine the privileges.
-            if (aclHandling == AccessControlHandling.MERGE) {
-                for (ACE entry : aceList) {
-                    for (AccessControlEntry ace : acl.getAccessControlEntries()) {
-                        if (ace.getPrincipal().getName().equals(entry.principalName)) {
-                            acl.removeAccessControlEntry(ace);
-                        }
-                    }
+                Collection<String> privileges = node.getPropertyValues(NameConstants.REP_PRIVILEGES);
+                String v = node.getPropertyValue(NAME_REP_EFFECTIVE_PATH).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:effectivePath ' missing on principal entry node"));
+                final String effectivePath;
+                if (v.isEmpty()) {
+                    effectivePath = null;
+                } else {
+                    effectivePath = v;
                 }
+                entryBuilder = new PrincipalBasedAccessControlEntry.Builder(privileges, effectivePath);
+                newState = State.PRINCIPAL_BASED_ACE;
+                break;
             }
-
-            // apply ACEs of package
-            for (ACE ace : aceList) {
-                final String principalName = ace.principalName;
-                if (aclHandling == AccessControlHandling.MERGE_PRESERVE && existingPrincipals.contains(principalName)) {
-                    // skip principal if it already has an ACL
-                    continue;
+            case RESOURCE_BASED_ACE:
+            case PRINCIPAL_BASED_ACE: {
+                if (!JackrabbitACLManagement.NT_REP_RESTRICTIONS.equals(node.getPrimaryType().orElseThrow(() -> new IllegalStateException("mandatory property 'jcr:primaryType' missing on principal policy node")))) {
+                    throw new IllegalArgumentException("Unexpected restriction type inside principal or resource based ACE: " + node.getPrimaryType());
                 }
-                Principal principal = getPrincipal(principalName);
-
-                Map<String, Value> svRestrictions = new HashMap<String, Value>();
-                Map<String, Value[]> mvRestrictions = new HashMap<String, Value[]>();
-                ace.convertRestrictions(acl, session.getValueFactory(), resolver, svRestrictions, mvRestrictions);
-                acl.addEntry(principal, ace.getPrivileges(acMgr), ace.allow, svRestrictions, mvRestrictions);
-            }
-            acMgr.setPolicy(accessControlledPath, acl);
-
-            if (accessControlledPath == null) {
-                addPathIfExists(paths, "/rep:repoPolicy");
-            } else if ("/".equals(accessControlledPath)) {
-                addPathIfExists(paths, "/rep:policy");
-            } else {
-                addPathIfExists(paths, accessControlledPath + "/rep:policy");
+                extractRestrictions(node).entrySet().stream().forEach( entry -> entryBuilder.addRestriction(entry.getKey(), entry.getValue()));
+                newState = State.RESTRICTION;
+                break;
             }
+            case RESTRICTION:
+                throw new IOException("Restriction nodes are not supposed to have any children but found " + node.toString());
+            default:
+                throw new IllegalArgumentException("This method must not be called with state " + state);
         }
+        return newState;
     }
 
-    private final class ImportedPrincipalSet extends ImportedPolicy<PrincipalSetPolicy> {
-
-        private final Collection<String> principalNames;
-
-        private ImportedPrincipalSet(DocViewNode2 node) {
-            // don't change the status as a cug policy may not have child nodes.
-            // just collect the rep:principalNames property
-            // any subsequent state would indicate an error
-            principalNames = node.getPropertyValues(NAME_REP_PRINCIPAL_NAMES);
-        }
-
-        @Override
-        State append(State state, DocViewNode2 childNode) {
-            log.error("Error while reading access control content: Unexpected node: {} for state {}", childNode.getPrimaryType(), state);
-            return State.ERROR;
-        }
-
-        @Override
-        void endNode(State state) {
-            // nothing to do
-        }
-
-        @Override
-        void apply(List<String> paths, NameResolver resolver) throws RepositoryException {
-            PrincipalSetPolicy psPolicy = getPolicy(PrincipalSetPolicy.class);
-            if (psPolicy != null) {
-                Set<Principal> existingPrincipals = psPolicy.getPrincipals();
-                // remove existing policy for 'overwrite'
-                if (aclHandling == AccessControlHandling.OVERWRITE) {
-                    psPolicy.removePrincipals(existingPrincipals.toArray(new Principal[existingPrincipals.size()]));
-                }
-            } else {
-                psPolicy = getApplicablePolicy(PrincipalSetPolicy.class);
-            }
-
-            // TODO: correct behavior for MERGE and MERGE_PRESERVE?
-            Principal[] principals = principalNames.stream().map(name -> getPrincipal(name)).toArray(Principal[]::new);
-
-            psPolicy.addPrincipals(principals);
-            acMgr.setPolicy(accessControlledPath, psPolicy);
-
-            if ("/".equals(accessControlledPath)) {
-                addPathIfExists(paths, "/rep:cugPolicy");
-            } else {
-                addPathIfExists(paths, accessControlledPath + "/rep:cugPolicy");
-            }
-        }
+    private Map<String, Value[]> extractRestrictions(DocViewNode2 node) {
+       return node.getProperties().stream()
+                .filter(p -> (!NON_RESTRICTION_PROPERTY_NAMES.contains(p.getName())))
+                .collect(Collectors.<DocViewProperty2, String, Value[]>toMap(
+                        p -> {
+                            try {
+                                return resolver.getJCRName(p.getName());
+                            } catch (NamespaceException e) {
+                                // should not happen
+                                throw new IllegalStateException("Cannot retrieve qualified name for " + p.getName().toString(), e);
+                            }
+                        }, 
+                        p -> {
+                            try {
+                                return p.getValues(session.getValueFactory()).toArray(new Value[0]);
+                            } catch (ValueFormatException e) {
+                                throw new UncheckedValueFormatException(e);
+                            } catch (RepositoryException e) {
+                                throw new UncheckedRepositoryException(e);
+                            }
+                        }));
     }
 
-    private final class ImportedPrincipalAcList extends ImportedPolicy<PrincipalAccessControlList> {
-
-        private final Principal principal;
-        private final List<PrincipalEntry> entries = new ArrayList<>();
-        private PrincipalEntry currentEntry;
-
-        private ImportedPrincipalAcList(DocViewNode2 node) {
-             String principalName = node.getPropertyValue(NameConstants.REP_PRINCIPAL_NAME).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:principalName' missing on principal policy node"));
-             Principal p = pMgr.getPrincipal(principalName);
-             if (p == null) {
-                 try {
-                     Authorizable a = session.getUserManager().getAuthorizableByPath(accessControlledPath);
-                     if (a != null) {
-                         p = a.getPrincipal();
-                     }
-                 } catch (RepositoryException e) {
-                     log.debug("Error while trying to retrieve user/group from access controlled path {}, {}", accessControlledPath, e.getMessage());
-                 }
-                 if (p == null) {
-                     p = getPrincipal(principalName);
-                 }
-             }
-             principal = p;
-        }
-
-        @Override
-        State append(State state, DocViewNode2 childNode) {
-            if (state == State.ACL) {
-                if (!"rep:PrincipalEntry".equals(childNode.getPrimaryType().orElseThrow(() -> new IllegalStateException("mandatory property 'jcr:primaryType' missing on principal policy node")))) {
-                    log.error("Unexpected node type of access control entry: {}", childNode.getPrimaryType());
-                    return State.ERROR;
-                }
-                currentEntry = new PrincipalEntry(childNode);
-                entries.add(currentEntry);
-                return State.ACE;
-            } else if (state == State.ACE) {
-                currentEntry.addRestrictions(childNode);
-                return State.RESTRICTION;
-            } else {
-                log.error("Error while reading access control content: Unexpected node: {} for state {}", childNode.getPrimaryType(), state);
-                return State.ERROR;
-            }
-        }
-
-        @Override
-        void endNode(State state) {
-            if (state == State.ACE) {
-                currentEntry = null;
-            }
-        }
-
-        @Override
-        void apply(List<String> paths, NameResolver resolver) throws RepositoryException {
-            if (aclHandling == AccessControlHandling.MERGE_PRESERVE) {
-                log.debug("MERGE_PRESERVE for principal-based access control list is equivalent to IGNORE.");
-                return;
-            }
-
-            PrincipalAccessControlList acl = getPolicy(PrincipalAccessControlList.class, principal);
-            if (acl != null && aclHandling == AccessControlHandling.OVERWRITE) {
-                // remove existing policy for 'OVERWRITE'
-                acMgr.removePolicy(acl.getPath(), acl);
-                acl = null;
-            }
-
-            if (acl == null) {
-                acl = getApplicablePolicy(PrincipalAccessControlList.class, principal);
-            }
-
-            // apply ACEs of package for MERGE and OVERWRITE
-            for (PrincipalEntry entry : entries) {
-                Map<String, Value> svRestrictions = new HashMap<>();
-                Map<String, Value[]> mvRestrictions = new HashMap<String, Value[]>();
-                entry.convertRestrictions(acl, session.getValueFactory(), resolver, svRestrictions, mvRestrictions);
-                acl.addEntry(entry.effectivePath, entry.getPrivileges(acMgr), svRestrictions, mvRestrictions);
-            }
-            acMgr.setPolicy(acl.getPath(), acl);
-
-            if (accessControlledPath == null) {
-                addPathIfExists(paths, "/rep:repoPolicy");
-            } else if ("/".equals(accessControlledPath)) {
-                addPathIfExists(paths, "/rep:policy");
-            } else {
-                addPathIfExists(paths, accessControlledPath + "/rep:policy");
-            }
-        }
-    }
-
-    private static class AbstractEntry {
-
-        private final Collection<String> privileges;
-        private final Map<Name, DocViewProperty2> restrictions;
-
-        private AbstractEntry(DocViewNode2 node) {
-            privileges = node.getPropertyValues(NameConstants.REP_PRIVILEGES);
-            restrictions = new HashMap<>();
-            addRestrictions(node);
-        }
-
-        void addRestrictions(DocViewNode2 node) {
-            restrictions.putAll(node.getProperties().stream().collect(Collectors.toMap(DocViewProperty2::getName, Function.identity())));
-        }
-
-        void convertRestrictions(JackrabbitAccessControlList acl, ValueFactory vf, NameResolver resolver, Map<String, Value> svRestrictions, Map<String, Value[]> mvRestrictions) throws RepositoryException {
-            for (String restName : acl.getRestrictionNames()) {
-                DocViewProperty2 restriction = restrictions.get(resolver.getQName(restName));
-                if (restriction != null) {
-                    Value[] values = new Value[restriction.getStringValues().size()];
-                    int type = acl.getRestrictionType(restName);
-                    for (int i=0; i<values.length; i++) {
-                        values[i] = vf.createValue(restriction.getStringValues().get(i), type);
-                    }
-                    if (restriction.isMultiValue()) {
-                        mvRestrictions.put(restName, values);
-                    } else {
-                        svRestrictions.put(restName, values[0]);
-                    }
-                }
+    public void endNode() {
+        State state = states.pop();
+        switch(state) {
+            case RESOURCE_BASED_ACE:
+            case PRINCIPAL_BASED_ACE: {
+                policyBuilder.addEntry(entryBuilder.build());
+                break;
             }
-        }
-
-        Privilege[] getPrivileges(AccessControlManager acMgr) throws RepositoryException {
-            return AccessControlUtils.privilegesFromNames(acMgr, privileges.toArray(new String[0]));
+            default:
+                // nothing happens in all other states
         }
     }
 
-    private static class ACE extends AbstractEntry {
-
-        private final boolean allow;
-        private final String principalName;
-
-        private ACE(DocViewNode2 childNode) {
-            super(childNode);
-            String primaryType = childNode.getPrimaryType().orElseThrow(() -> new IllegalStateException("mandatory property 'jcr:primaryType' missing on ace node"));
-            if ("rep:GrantACE".equals(primaryType)) {
-                allow = true;
-            } else if ("rep:DenyACE".equals(primaryType)) {
-                allow = false;
-            } else {
-                throw new IllegalArgumentException("Unexpected node ACE type: " + childNode.getPrimaryType());
-            }
-            principalName = childNode.getPropertyValue(NameConstants.REP_PRINCIPAL_NAME).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:principalName' missing"));
+    public List<String> close() throws RepositoryException {
+        if (states.peek() != State.INITIAL) {
+            log.error("Unexpected end state: {}", states.peek());
         }
+        JackrabbitAccessControlPolicy policy = policyBuilder.build();
+        return policy.apply(session, aclHandling, accessControlledPath);
     }
 
-    private static class PrincipalEntry extends AbstractEntry {
-
-        private final String effectivePath;
-
-        private PrincipalEntry(DocViewNode2 node) {
-            super(node);
-            String v = node.getPropertyValue(NAME_REP_EFFECTIVE_PATH).orElseThrow(() -> new IllegalStateException("mandatory property 'rep:effectivePath ' missing on principal entry node"));
-            if (v.isEmpty()) {
-                effectivePath = null;
-            } else {
-                effectivePath = v;
-            }
-        }
-    }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
index e7e18a91..cedba243 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java
@@ -34,6 +34,7 @@ import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
 import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
 import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
 import org.apache.jackrabbit.vault.fs.api.ImportMode;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitACLManagement;
 import org.apache.jackrabbit.vault.util.DocViewNode2;
 import org.apache.jackrabbit.vault.util.DocViewProperty2;
 import org.jetbrains.annotations.NotNull;
@@ -82,11 +83,11 @@ public class JcrSysViewTransformer implements DocViewAdapter {
 
     private long ignoreLevel = 0;
 
-    public JcrSysViewTransformer(@NotNull Node node, @NotNull ImportMode importMode) throws RepositoryException {
-        this(node, null, importMode);
+    public JcrSysViewTransformer(@NotNull Node node, @NotNull ImportMode importMode, boolean keepAcPolicies) throws RepositoryException {
+        this(node, null, importMode, keepAcPolicies);
     }
 
-    JcrSysViewTransformer(@NotNull Node node, @Nullable String existingPath, @NotNull ImportMode importMode) throws RepositoryException {
+    JcrSysViewTransformer(@NotNull Node node, @Nullable String existingPath, @NotNull ImportMode importMode, boolean keepAcPolicies) throws RepositoryException {
         Session session = node.getSession();
         parent = node;
         handler = session.getImportContentHandler(
@@ -110,6 +111,9 @@ public class JcrSysViewTransformer implements DocViewAdapter {
         if (existingPath != null) {
             // check if there is an existing node with the name
             recovery = new NodeStash(session, existingPath).excludeName("rep:cache");
+            if (!keepAcPolicies) {
+                recovery.excludeName(JackrabbitACLManagement.REP_POLICY).excludeName(JackrabbitACLManagement.REP_PRINCIPAL_POLICY);
+            }
             recovery.stash(null);
         }
         excludeNode(NAME_REP_CACHE);
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/FileArchive.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/FileArchive.java
index c41f6626..0bf29795 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/FileArchive.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/FileArchive.java
@@ -61,9 +61,9 @@ public class FileArchive extends AbstractArchive {
         if (jcrRoot != null) {
             return;
         }
-        eRoot = ExportRoot.findRoot(rootDirectory);
+        eRoot = new ExportRoot(rootDirectory);
         if (!eRoot.isValid()) {
-            throw new IOException("No " + Constants.ROOT_DIR + " found.");
+            throw new IOException("Either no " + Constants.ROOT_DIR + " or no " + Constants.META_INF + " directory found below " + rootDirectory);
         }
         jcrRoot = new OsEntry(eRoot.getJcrRoot());
     }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
index 88316a0c..8547e1a3 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/io/Importer.java
@@ -34,15 +34,19 @@ import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
+import java.util.Properties;
 import java.util.Set;
 
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
 import javax.jcr.Session;
+import javax.jcr.security.AccessControlPolicy;
 import javax.jcr.version.Version;
 
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
+import org.apache.jackrabbit.api.security.authorization.PrincipalSetPolicy;
 import org.apache.jackrabbit.spi.commons.namespace.NamespaceMapping;
 import org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver;
 import org.apache.jackrabbit.spi.commons.namespace.SessionNamespaceResolver;
@@ -81,6 +85,7 @@ import org.apache.jackrabbit.vault.fs.spi.PrivilegeInstaller;
 import org.apache.jackrabbit.vault.fs.spi.ProgressTracker;
 import org.apache.jackrabbit.vault.fs.spi.ServiceProviderFactory;
 import org.apache.jackrabbit.vault.fs.spi.UserManagement;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol.JackrabbitAccessControlPolicy;
 import org.apache.jackrabbit.vault.packaging.PackageException;
 import org.apache.jackrabbit.vault.packaging.impl.ActivityLog;
 import org.apache.jackrabbit.vault.packaging.registry.impl.JcrPackageRegistry;
@@ -158,6 +163,9 @@ public class Importer {
      */
     private static final Logger activityLog = LoggerFactory.getLogger(ActivityLog.class);
 
+    // not exported.
+    static final String FEATURE_STASH_PRINCIPAL_POLICIES = "vault.feature.stashPrincipalPolicies";
+
     /**
      * workspace filter to use during import
      */
@@ -186,12 +194,16 @@ public class Importer {
     /**
      * set of paths to versionable nodes that need to be checked in after import
      */
-    private final Set<String> nodesToCheckin = new HashSet<String>();
+    private final Set<String> nodesToCheckin = new HashSet<>();
 
     /**
      * map of group memberships that need to be applied after import
      */
-    private final Map<String, String[]> memberships = new HashMap<String, String[]>();
+    private final Map<String, String[]> memberships = new HashMap<>();
+
+    private Map<String, List<? extends AccessControlPolicy>> deletedPrincipalAcls = new HashMap<>();
+
+    private List<String> createdAuthorizableIds = new LinkedList<>();
 
     /**
      * general flag that indicates if the import had (recoverable) errors
@@ -259,7 +271,7 @@ public class Importer {
     /**
      * the checkpoint import info.
      */
-    private ImportInfo cpImportInfo;
+    private ImportInfoImpl cpImportInfo;
 
     /**
      * retry counter for the batch auto recovery
@@ -280,6 +292,14 @@ public class Importer {
     private final boolean isStrictByDefault;
     private final boolean overwritePrimaryTypesOfFoldersByDefault;
 
+    /**
+     * JCRVLT-683 feature flag. This variable is used to enable the new behavior of stashing principal policies when an
+     * Archive's package properties do not specify a {@code vault.feature.stashPrincipalPolicies} property.
+     * Initially false by default, with the ability to set a global override using the key as a System property.
+     * This default should be changed to true in a future release after sufficient testing across the ecosystem.
+     */
+    private final boolean stashPrincipalPoliciesByDefault = Boolean.getBoolean(FEATURE_STASH_PRINCIPAL_POLICIES);
+
     /**
      * Default constructor neither setting specific import options nor defaults.
      */
@@ -328,7 +348,7 @@ public class Importer {
         this.isStrict = opts.isStrict(isStrictByDefault);
         this.isStrictByDefault = isStrictByDefault;
         this.overwritePrimaryTypesOfFoldersByDefault = overwritePrimaryTypesOfFoldersByDefault;
-        if (!this.opts.hasIdConflictPolicyBeenSet()) {
+        if (!this.opts.hasIdConflictPolicyBeenSet() && defaultIdConflictPolicy != null) {
             this.opts.setIdConflictPolicy(defaultIdConflictPolicy);
         }
     }
@@ -540,6 +560,7 @@ public class Importer {
         if (tracker != null) {
             tracker.setMode(ProgressTrackerListener.Mode.TEXT);
         }
+        restorePrincipalAcls(session, shouldStashPrincipalPoliciesForArchive(archive));
         checkinNodes(session);
         applyMemberships(session);
         applyPatches();
@@ -565,6 +586,56 @@ public class Importer {
         }
     }
 
+    // remove featureStashPrincipalPolicies argument before making this method public
+    private void restorePrincipalAcls(Session session, boolean featureStashPrincipalPolicies) throws RepositoryException {
+        for (String authorizableId : createdAuthorizableIds) {
+            String principalName = userManagement.getPrincipalName(session, authorizableId);
+            if (deletedPrincipalAcls.containsKey(principalName)) {
+                if (opts.isDryRun()) {
+                    track("Dry run: Would potentially restore principal ACLs of " + principalName + " ...", "");
+                } else if (!featureStashPrincipalPolicies) {
+                    track(FEATURE_STASH_PRINCIPAL_POLICIES + " disabled: Would potentially restore principal ACLs of " + principalName + " ...", "");
+                } else {
+                    for (AccessControlPolicy policy : deletedPrincipalAcls.get(principalName)) {
+                        // CUG or ACL handling relevant?
+                        AccessControlHandling aclHandling;
+                        if (policy instanceof PrincipalSetPolicy) {
+                            aclHandling = opts.getCugHandling();
+                        } else {
+                            aclHandling = opts.getAccessControlHandling();
+                        }
+                        // convert aclHandling (as this was set for the imported ACLs, not the existing ones)
+                        final AccessControlHandling aclHandlingForRestoredPolicy;
+                        switch (aclHandling) {
+                            case OVERWRITE:
+                                aclHandlingForRestoredPolicy = AccessControlHandling.IGNORE;
+                                break;
+                            case IGNORE:
+                                aclHandlingForRestoredPolicy = AccessControlHandling.OVERWRITE;
+                                break;
+                            case CLEAR:
+                                aclHandlingForRestoredPolicy = AccessControlHandling.IGNORE;
+                                break;
+                            case MERGE:
+                                aclHandlingForRestoredPolicy = AccessControlHandling.MERGE;
+                                break;
+                            default:
+                                aclHandlingForRestoredPolicy = AccessControlHandling.MERGE;
+                           
+                        }
+                        String accessControlledPath = userManagement.getAuthorizablePath(session, authorizableId);
+                        List<String> paths = JackrabbitAccessControlPolicy.fromAccessControlPolicy(policy).apply(session, aclHandlingForRestoredPolicy, accessControlledPath);
+                        for (String path: paths) {
+                            track("Restored principal ACLs of " + principalName, path);
+                        }
+                    }
+                }
+            }
+        }
+        
+        
+    }
+
     /**
      * Returns a human-readable error message from the throwable including all its causes till the root.
      * Also the throwable class names are included in the message
@@ -895,7 +966,7 @@ public class Importer {
 
     private void commit(Session session, TxInfo info, LinkedList<TxInfo> skipList) throws RepositoryException, IOException {
         try {
-            ImportInfo imp = null;
+            ImportInfoImpl imp = null;
             if (skipList.isEmpty()) {
                 if (info == cpTxInfo) {
                     // don't need to import again, just set import info
@@ -907,6 +978,8 @@ public class Importer {
                         nodesToCheckin.addAll(imp.getToVersion());
                         memberships.putAll(imp.getMemberships());
                         autoSave.modified(imp.numModified());
+                        deletedPrincipalAcls.putAll(imp.getDeletedPrincipalAcls());
+                        createdAuthorizableIds.addAll(imp.getCreatedAuthorizableIds());
                     }
                 }
             } else if (log.isDebugEnabled()) {
@@ -1337,4 +1410,10 @@ public class Importer {
         }
     }
 
+    boolean shouldStashPrincipalPoliciesForArchive(Archive archive) {
+        return Optional.ofNullable(archive.getMetaInf().getProperties())
+                .filter(properties -> properties.containsKey(FEATURE_STASH_PRINCIPAL_POLICIES))
+                .map(properties -> Boolean.valueOf(properties.getProperty(FEATURE_STASH_PRINCIPAL_POLICIES)))
+                .orElse(stashPrincipalPoliciesByDefault);
+    }
 }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/ACLManagement.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/ACLManagement.java
index 90703db5..801b47f8 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/ACLManagement.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/ACLManagement.java
@@ -17,9 +17,14 @@
 
 package org.apache.jackrabbit.vault.fs.spi;
 
+import java.util.List;
+import java.util.Map;
+
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
+import javax.jcr.security.AccessControlPolicy;
 
+import org.jetbrains.annotations.NotNull;
 import org.osgi.annotation.versioning.ProviderType;
 
 /**
@@ -70,4 +75,14 @@ public interface ACLManagement {
      * @throws RepositoryException if an error occurs
      */
     void clearACL(Node node) throws RepositoryException;
+
+    /**
+     * 
+     * @param node the start node from where to collect principal policies
+     * @return all collected principal access control policies per principal name inside the given node (even nested ones)
+     * @throws RepositoryException in case some error occurred while collecting the principal policies
+     * @see <a href="https://jackrabbit.apache.org/archive/wiki/JCR/AccessControl_115513330.html">Access Control</a>
+     * @since 3.6.10
+     */
+    @NotNull Map<String, List<? extends AccessControlPolicy>> getPrincipalAcls(Node node) throws RepositoryException;
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/UserManagement.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/UserManagement.java
index b9490599..99331466 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/UserManagement.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/UserManagement.java
@@ -39,13 +39,22 @@ public interface UserManagement {
 
     /**
      * Returns the path of the authorizable or {@code null} if not exists.
-     * @param name the authorizable name
+     * @param id the authorizable id
      * @param session the session to access the repository
      * @return path of authorizable
      *
      * @since 2.3.26
      */
-    String getAuthorizablePath(Session session, String name);
+    String getAuthorizablePath(Session session, String id);
+
+    /**
+     * 
+     * @param session the session to access the repository
+     * @param id the authorizable id
+     * @return the principal name corresponding to the given authorizable id or {@code null} if the authorizable id cannot be found
+     * @since 3.6.10
+     */
+    String getPrincipalName(Session session, String id);
 
     /**
      * Returns the id of the authorizable from the specified authorizable node
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitACLManagement.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitACLManagement.java
new file mode 100644
index 00000000..2fb3f5f1
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitACLManagement.java
@@ -0,0 +1,276 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20;
+
+import java.security.Principal;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.function.Consumer;
+
+import javax.jcr.Node;
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.security.AccessControlManager;
+import javax.jcr.security.AccessControlPolicy;
+
+import org.apache.jackrabbit.api.JackrabbitSession;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlPolicy;
+import org.apache.jackrabbit.api.security.user.Authorizable;
+import org.apache.jackrabbit.api.security.user.Group;
+import org.apache.jackrabbit.api.security.user.User;
+import org.apache.jackrabbit.api.security.user.UserManager;
+import org.apache.jackrabbit.commons.JcrUtils;
+import org.apache.jackrabbit.util.Text;
+import org.apache.jackrabbit.vault.fs.spi.ACLManagement;
+import org.apache.jackrabbit.vault.fs.spi.UserManagement;
+import org.apache.jackrabbit.vault.util.UncheckedRepositoryException;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * This is Jackrabbit/Oak specific as it is not defined by JCR 2.0 how access control policies are persisted.
+ */
+public class JackrabbitACLManagement implements ACLManagement {
+
+    // Constants copied from Oak classes
+    
+    /**
+     * The primary node type name of the CUG policy node.
+     */
+    public static final String NT_REP_CUG_POLICY = "rep:CugPolicy";
+
+    /**
+     * The name of the CUG policy node.
+     */
+    public static final String REP_CUG_POLICY = "rep:cugPolicy";
+    
+    /** the name of the ACL policy node (resource based) */
+    public static final String REP_POLICY = "rep:policy";
+
+    /** the name of the ACL policy node (principal based) */
+    public static final String REP_PRINCIPAL_POLICY = "rep:principalPolicy";
+    /**
+     * The primary node type name of the principal based access control policy node.
+     */
+    public static final String NT_REP_PRINCIPAL_POLICY = "rep:PrincipalPolicy";
+   
+    /** the name of the repository wide ACL policy node (both principal and resource based) */
+    public static final String REP_REPO_POLICY = "rep:repoPolicy";
+    
+    /**
+     * Node type name of ancestor for both {@link #NT_REP_PRINCIPAL_POLICY} and {@link #NT_REP_ACL}
+     */
+    public static final String NT_REP_POLICY = "rep:Policy";
+    
+    /**
+     * The primary node type name of the resource based access control policy node.
+     */
+    public static final String NT_REP_ACL = "rep:ACL";
+    public static final String NT_REP_ACE = "rep:ACE";
+    public static final String NT_REP_GRANT_ACE = "rep:GrantACE";
+    public static final String NT_REP_DENY_ACE = "rep:DenyACE";
+    public static final String NT_REP_RESTRICTIONS = "rep:Restrictions";
+
+    public static final String MIX_REP_ACCESS_CONTROLLABLE = "rep:AccessControllable";
+    public static final String MIX_REP_REPO_ACCESS_CONTROLLABLE = "rep:RepoAccessControllable";
+    /**
+     * The name of the mixin type that defines the CUG policy node.
+     */
+    public static final String MIX_REP_CUG_MIXIN = "rep:CugMixin";
+
+    /**
+     * The name of the mixin type that defines the principal based access control policy node.
+     */
+    public static final String MIX_REP_PRINCIPAL_BASED_MIXIN = "rep:PrincipalBasedMixin";
+
+    private String groupsRootPath;
+    private String usersRootPath;
+    private final UserManagement userManagement;
+
+    public JackrabbitACLManagement() {
+        userManagement = new JackrabbitUserManagement();
+    }
+
+    /**
+     * Determines the authorizable root paths (as Jackrabbit/Oak stores authorizables inside the repo below a dedicated root path)
+     * @param session
+     * @throws RepositoryException
+     */
+    private synchronized void determineAuthorizableRootPaths(Session session) throws RepositoryException {
+        JackrabbitSession jrSession = (JackrabbitSession)session;
+        UserManager userMgr = jrSession.getUserManager();
+        // userMgr.autoSave(false) is not supported by Oak
+        String testAuthorizableId = UUID.randomUUID().toString();
+        Group group = userMgr.createGroup(new SimplePrincipal(testAuthorizableId), "intermediate");
+        groupsRootPath = Text.getRelativeParent(group.getPath(), 2);
+        group.remove();
+        User user = userMgr.createUser(testAuthorizableId, "test", new SimplePrincipal(testAuthorizableId), "intermediate");
+        usersRootPath = Text.getRelativeParent(user.getPath(), 2);
+        user.remove();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isACLNodeType(String name) {
+        return name.equals(NT_REP_ACL) || name.equals(NT_REP_CUG_POLICY) || name.equals(NT_REP_PRINCIPAL_POLICY);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isAccessControllableMixin(String name) {
+        return name.equals(MIX_REP_ACCESS_CONTROLLABLE)
+                || name.equals(MIX_REP_REPO_ACCESS_CONTROLLABLE)
+                || name.equals(MIX_REP_CUG_MIXIN)
+                || name.equals(MIX_REP_PRINCIPAL_BASED_MIXIN);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isACLNode(Node node) throws RepositoryException {
+        return node.isNodeType(NT_REP_POLICY);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean ensureAccessControllable(Node node, String policyPrimaryType) throws RepositoryException {
+        boolean modified = false;
+        if (NT_REP_ACL.equals(policyPrimaryType)) {
+            if (!node.isNodeType(MIX_REP_ACCESS_CONTROLLABLE)) {
+                node.addMixin(MIX_REP_ACCESS_CONTROLLABLE);
+                modified = true;
+            }
+            if (isRootNode(node) && !node.isNodeType(MIX_REP_REPO_ACCESS_CONTROLLABLE)) {
+                node.addMixin(MIX_REP_REPO_ACCESS_CONTROLLABLE);
+                modified = true;
+            }
+        } else if (NT_REP_CUG_POLICY.equals(policyPrimaryType)) {
+            if (!node.isNodeType(MIX_REP_CUG_MIXIN)) {
+                node.addMixin(MIX_REP_CUG_MIXIN);
+                modified = true;
+            }
+        } else if (NT_REP_PRINCIPAL_POLICY.equals(policyPrimaryType)) {
+            if (!node.isNodeType(MIX_REP_PRINCIPAL_BASED_MIXIN)) {
+                node.addMixin(MIX_REP_PRINCIPAL_BASED_MIXIN);
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void clearACL(Node node) throws RepositoryException {
+        AccessControlManager ac = node.getSession().getAccessControlManager();
+        String pPath = node.getPath();
+        for (AccessControlPolicy p: ac.getPolicies(pPath)) {
+            ac.removePolicy(pPath, p);
+        }
+        if (isRootNode(node)) {
+            for (AccessControlPolicy p: ac.getPolicies(null)) {
+                ac.removePolicy(null, p);
+            }
+        }
+    }
+
+    //--------------------------------------------------------------------------
+    private static boolean isRootNode(Node node) throws RepositoryException {
+        return node.getDepth() == 0;
+    }
+
+    private boolean areAuthorizablesAllowedBelowPath(Session session, String nodePath) throws RepositoryException {
+        if (usersRootPath == null || groupsRootPath == null) {
+            determineAuthorizableRootPaths(session);
+        }
+        return nodePath.startsWith(usersRootPath) || nodePath.startsWith(groupsRootPath);
+    }
+
+    @Override
+    public @NotNull Map<String, List<? extends AccessControlPolicy>> getPrincipalAcls(Node node) throws RepositoryException {
+        // first do a quick check if path may contain principal ACLs at all before triggering expensive traversal
+        if (!areAuthorizablesAllowedBelowPath(node.getSession(), node.getPath())) {
+            // TODO: Oak does not allow principal based authorizables everywhere, so we may restrict further
+            return Collections.emptyMap();
+        }
+        JackrabbitSession jrSession = (JackrabbitSession)node.getSession();
+        AccessControlManager acMgr = jrSession.getAccessControlManager();
+        if (!(acMgr instanceof JackrabbitAccessControlManager)) {
+            throw new RepositoryException("The access control manager returned is no JackrabbitAccessControlManager, this is probably not a Jackrabbit/Oak repository");
+        }
+        JackrabbitAccessControlManager jrAcMgr = (JackrabbitAccessControlManager) acMgr;
+        PrincipalAccessControlPolicyCollector policiesCollector = new PrincipalAccessControlPolicyCollector(jrAcMgr);
+        try {
+            findPrincipalsRecursively(jrSession.getUserManager(), node, policiesCollector);
+            return policiesCollector.getPoliciesPerPrincipal();
+        } catch (UncheckedRepositoryException e) {
+            throw e.getCause();
+        }
+    }
+
+    private static final class PrincipalAccessControlPolicyCollector implements Consumer<Principal> {
+
+        private final JackrabbitAccessControlManager jrAcMgr;
+        private final Map<String, List<? extends AccessControlPolicy>> policiesPerPrincipal;
+
+        public PrincipalAccessControlPolicyCollector(JackrabbitAccessControlManager jrAcMgr) {
+            super();
+            this.jrAcMgr = jrAcMgr;
+            this.policiesPerPrincipal = new HashMap<>();
+        }
+
+        public Map<String, List<? extends AccessControlPolicy>> getPoliciesPerPrincipal() {
+            return policiesPerPrincipal;
+        }
+
+        @Override
+        public void accept(Principal principal) {
+            try {
+                List<JackrabbitAccessControlPolicy> policies = Arrays.asList(jrAcMgr.getPolicies(principal));
+                if (!policies.isEmpty()) {
+                    policiesPerPrincipal.put(principal.getName(), policies);
+                }
+            } catch (RepositoryException e) {
+                throw new UncheckedRepositoryException(e);
+            }
+        }
+    }
+
+    private void findPrincipalsRecursively(UserManager userMgr, Node node, Consumer<Principal> principalConsumer) throws RepositoryException {
+        // TODO: check if the additional check with UserManagement isAuthorizableNodeType really speeds things up...
+        if (userManagement.isAuthorizableNodeType(node.getPrimaryNodeType().getName())) {
+            Authorizable authorizable = userMgr.getAuthorizableByPath(node.getPath());
+            if (authorizable != null) {
+                principalConsumer.accept(authorizable.getPrincipal());
+            }
+        } else {
+            for (Node child : JcrUtils.in(((Iterator<Node>)node.getNodes()))) {
+                findPrincipalsRecursively(userMgr, child, principalConsumer);
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitServiceProvider.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitServiceProvider.java
index 568b8f80..5eafbf13 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitServiceProvider.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitServiceProvider.java
@@ -88,7 +88,7 @@ public class JackrabbitServiceProvider implements ServiceProvider {
      */
     public ACLManagement getACLManagement() {
         if (aclManagement == null) {
-            aclManagement = new JcrACLManagement();
+            aclManagement = new JackrabbitACLManagement();
         }
         return aclManagement;
     }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitUserManagement.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitUserManagement.java
index 2c1086be..7fb88fb1 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitUserManagement.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JackrabbitUserManagement.java
@@ -17,8 +17,6 @@
 
 package org.apache.jackrabbit.vault.fs.spi.impl.jcr20;
 
-import java.util.UUID;
-
 import javax.jcr.ItemNotFoundException;
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
@@ -45,6 +43,7 @@ public class JackrabbitUserManagement implements UserManagement {
 
     // https://issues.apache.org/jira/browse/OAK-9584
     public static final Name NAME_REP_AUTHORIZABLE_ID = NameFactoryImpl.getInstance().create(Name.NS_REP_URI, "authorizableId");
+
     /**
      * default logger
      */
@@ -55,21 +54,26 @@ public class JackrabbitUserManagement implements UserManagement {
      * {@inheritDoc}
      */
     public boolean isAuthorizableNodeType(String ntName) {
-        return ntName.equals("rep:Group") || ntName.equals("rep:User");
+        return ntName.equals("rep:Group") || ntName.equals("rep:User") || ntName.equals("rep:SystemUser");
     }
 
     /**
      * {@inheritDoc}
      */
-    public String getAuthorizablePath(Session session, String name) {
-        // currently we rely on the implementation detail to keep the API dependency to jackrabbit  < 2.3.
+    public String getAuthorizablePath(Session session, String id) {
+        Authorizable authorizable;
         try {
-            UUID uuid = UUID.nameUUIDFromBytes(name.toLowerCase().getBytes("UTF-8"));
-            return session.getNodeByIdentifier(uuid.toString()).getPath();
-        } catch (Exception e) {
-            // ignore
+            authorizable = getAuthorizable(session, id);
+            if (authorizable == null) {
+                log.debug("No existing authorizable with id {} found", id);
+                return null;
+            }
+            return authorizable.getPath();
+        } catch (RepositoryException e) {
+            log.warn("Unable to get authorizable path of {}: {}", id, e.getMessage(), e);
+            return null;
         }
-        return null;
+       
     }
 
     @Override
@@ -104,19 +108,10 @@ public class JackrabbitUserManagement implements UserManagement {
      * {@inheritDoc}
      */
     public void addMembers(Session session, String id, String[] membersUUID) {
-        if (!(session instanceof JackrabbitSession)) {
-            log.warn("Unable to update membership. no jackrabbit session.");
-            return;
-        }
-        UserManager uMgr;
-        try {
-            uMgr = ((JackrabbitSession) session).getUserManager();
-        } catch (RepositoryException e) {
-            log.warn("Unable to update membership of {}. Error while retrieving user manager.", id, e);
-            return;
-        }
         Authorizable auth;
+        UserManager uMgr;
         try {
+            uMgr = getUserManager(session);
             auth = uMgr.getAuthorizable(id);
         } catch (RepositoryException e) {
             log.warn("Unable to update membership of {}. Error while retrieving authorizable.", id, e);
@@ -158,4 +153,29 @@ public class JackrabbitUserManagement implements UserManagement {
             }
         }
     }
+
+    private UserManager getUserManager(Session session) throws RepositoryException {
+        if (!(session instanceof JackrabbitSession)) {
+            throw new RepositoryException("no jackrabbit session.");
+        }
+        return ((JackrabbitSession) session).getUserManager();
+    }
+
+    private Authorizable getAuthorizable(Session session, String id) throws RepositoryException {
+        return getUserManager(session).getAuthorizable(id);
+    }
+
+    @Override
+    public String getPrincipalName(Session session, String id) {
+        try {
+            Authorizable auth = getAuthorizable(session, id);
+            if (auth != null) {
+                return auth.getPrincipal().getName();
+            }
+        } catch (RepositoryException e) {
+            log.warn("Unable to get principal name of {}. Error while retrieving user manager or authorizable.", id, e);
+            return null;
+        }
+        return null;
+    }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JcrACLManagement.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JcrACLManagement.java
deleted file mode 100644
index bd2ab782..00000000
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/JcrACLManagement.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jackrabbit.vault.fs.spi.impl.jcr20;
-
-import javax.jcr.Node;
-import javax.jcr.RepositoryException;
-import javax.jcr.security.AccessControlManager;
-import javax.jcr.security.AccessControlPolicy;
-
-import org.apache.jackrabbit.vault.fs.spi.ACLManagement;
-
-/**
- * {@code JcrACLManagement}...
- * This is Jackrabbit/Oak specific as it is not defined by JCR 2.0 how access control policies are persisted.
- */
-public class JcrACLManagement implements ACLManagement {
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isACLNodeType(String name) {
-        return name.equals("rep:ACL") || name.equals("rep:CugPolicy") || name.equals("rep:PrincipalPolicy");
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isAccessControllableMixin(String name) {
-        return name.equals("rep:AccessControllable")
-                || name.equals("rep:RepoAccessControllable")
-                || name.equals("rep:CugMixin")
-                || name.equals("rep:PrincipalBasedMixin");
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isACLNode(Node node) throws RepositoryException {
-        return node.isNodeType("rep:Policy");
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean ensureAccessControllable(Node node, String policyPrimaryType) throws RepositoryException {
-        boolean modified = false;
-        if ("rep:ACL".equals(policyPrimaryType)) {
-            if (!node.isNodeType("rep:AccessControllable")) {
-                node.addMixin("rep:AccessControllable");
-                modified = true;
-            }
-            if (isRootNode(node) && !node.isNodeType("rep:RepoAccessControllable")) {
-                node.addMixin("rep:RepoAccessControllable");
-                modified = true;
-            }
-        } else if ("rep:CugPolicy".equals(policyPrimaryType)) {
-            if (!node.isNodeType("rep:CugMixin")) {
-                node.addMixin("rep:CugMixin");
-                modified = true;
-            }
-        } else if ("rep:PrincipalPolicy".equals(policyPrimaryType)) {
-            if (!node.isNodeType("rep:PrincipalBasedMixin")) {
-                node.addMixin("rep:PrincipalBasedMixin");
-                modified = true;
-            }
-        }
-        return modified;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void clearACL(Node node) throws RepositoryException {
-        AccessControlManager ac = node.getSession().getAccessControlManager();
-        String pPath = node.getPath();
-        for (AccessControlPolicy p: ac.getPolicies(pPath)) {
-            ac.removePolicy(pPath, p);
-        }
-        if (isRootNode(node)) {
-            for (AccessControlPolicy p: ac.getPolicies(null)) {
-                ac.removePolicy(null, p);
-            }
-        }
-    }
-
-    //--------------------------------------------------------------------------
-    private static boolean isRootNode(Node node) throws RepositoryException {
-        return node.getDepth() == 0;
-    }
-}
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/SimplePrincipal.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/SimplePrincipal.java
new file mode 100644
index 00000000..7bc9b004
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/SimplePrincipal.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20;
+
+import java.security.Principal;
+
+/** Helper class to create users/groups with intermediate path */
+public final class SimplePrincipal implements Principal {
+    private final String name;
+
+    public SimplePrincipal(String name) {
+        if(name == null) {
+            throw new IllegalArgumentException("Name cannot be null");
+        }
+        this.name = name;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        return (
+                other instanceof SimplePrincipal)
+                && (this.name.equals(((SimplePrincipal)other).name));
+    }
+
+    @Override
+    public int hashCode() {
+        return name.hashCode();
+    }
+}
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/AbstractAccessControlEntry.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/AbstractAccessControlEntry.java
new file mode 100644
index 00000000..7afeccf5
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/AbstractAccessControlEntry.java
@@ -0,0 +1,96 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
+import javax.jcr.security.AccessControlManager;
+import javax.jcr.security.Privilege;
+
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlEntry;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;
+import org.apache.jackrabbit.commons.jackrabbit.authorization.AccessControlUtils;
+import org.apache.jackrabbit.vault.util.UncheckedRepositoryException;
+
+public class AbstractAccessControlEntry {
+    final Collection<String> privileges;
+    final Map<String, Value[]> restrictions;
+
+    protected abstract static class Builder<T extends AbstractAccessControlEntry> implements JackrabbitAccessControlEntryBuilder<T> {
+        final Collection<String> privileges;
+        final Map<String, Value[]> restrictions;
+
+        Builder(Collection<String> privileges) {
+            this.privileges = new HashSet<>(privileges);
+            this.restrictions = new HashMap<>();
+        }
+
+        @Override
+        public void addRestriction(String restrictionName, Value[] values) {
+            restrictions.put(restrictionName, values);
+        }
+    }
+
+    protected AbstractAccessControlEntry(JackrabbitAccessControlEntry entry) throws RepositoryException {
+        this(Arrays.stream(entry.getPrivileges()).map(Privilege::getName).collect(Collectors.toList()), 
+             Arrays.stream(entry.getRestrictionNames())
+                .collect(Collectors.<String, String, Value[]>toMap(rn -> rn, rn -> {
+                    try {
+                        return entry.getRestrictions(rn);
+                    } catch (RepositoryException e) {
+                        throw new UncheckedRepositoryException(e);
+                    }
+                })));
+    }
+
+    Map.Entry<Map<String, Value>, Map<String, Value[]>> separateRestrictions(JackrabbitAccessControlList list) throws RepositoryException {
+        Map<String, Value> svRestrictions = new HashMap<>();
+        Map<String, Value[]> mvRestrictions = new HashMap<>();
+        try {
+            Map<Boolean, List<String>> restrictionNamesMap = restrictions.keySet().stream().collect(Collectors.partitioningBy(r -> {
+                try {
+                    return list.isMultiValueRestriction(r);
+                } catch (RepositoryException e) {
+                    throw new UncheckedRepositoryException(e);
+                }
+            }));
+            restrictionNamesMap.get(Boolean.TRUE).stream().forEach(restrictionName -> mvRestrictions.put(restrictionName, restrictions.get(restrictionName)));
+            restrictionNamesMap.get(Boolean.FALSE).stream().forEach(restrictionName -> svRestrictions.put(restrictionName, restrictions.get(restrictionName)[0]));
+        } catch (UncheckedRepositoryException e) {
+            throw e.getCause();
+        }
+        return new AbstractMap.SimpleEntry<>(svRestrictions, mvRestrictions);
+    }
+
+    protected AbstractAccessControlEntry(Collection<String> privileges, Map<String, Value[]> restrictions) {
+        this.privileges = new HashSet<>(privileges);
+        this.restrictions = new HashMap<>(restrictions);
+    }
+
+    Privilege[] getPrivileges(AccessControlManager acMgr) throws RepositoryException {
+        return AccessControlUtils.privilegesFromNames(acMgr, privileges.toArray(new String[0]));
+    }
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlEntryBuilder.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlEntryBuilder.java
new file mode 100644
index 00000000..9c2f8cb0
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlEntryBuilder.java
@@ -0,0 +1,32 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import javax.jcr.Value;
+
+/**
+ * Builder for an entry to be used with {@link PrincipalBasedAccessControlList} or {@link ResourceBasedAccessControlList}.
+ *
+ * @param <T> the type of the entry
+ */
+public interface JackrabbitAccessControlEntryBuilder<T extends AbstractAccessControlEntry> {
+
+    T build();
+
+    void addRestriction(String restrictionName, Value[] values);
+
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicy.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicy.java
new file mode 100644
index 00000000..4b3eb027
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicy.java
@@ -0,0 +1,186 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.security.Principal;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.security.AccessControlException;
+import javax.jcr.security.AccessControlManager;
+import javax.jcr.security.AccessControlPolicy;
+import javax.jcr.security.AccessControlPolicyIterator;
+
+import org.apache.jackrabbit.api.JackrabbitSession;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlEntry;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
+import org.apache.jackrabbit.api.security.authorization.PrincipalAccessControlList;
+import org.apache.jackrabbit.api.security.authorization.PrincipalSetPolicy;
+import org.apache.jackrabbit.api.security.principal.PrincipalManager;
+import org.apache.jackrabbit.api.security.user.Authorizable;
+import org.apache.jackrabbit.api.security.user.UserManager;
+import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.SimplePrincipal;
+import org.apache.jackrabbit.vault.util.UncheckedRepositoryException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/** 
+ * Abstraction on top of a JCR Access control policies (not bound to a JCR)
+ */
+public abstract class JackrabbitAccessControlPolicy {
+
+    /** default logger */
+    protected static final Logger log = LoggerFactory.getLogger(JackrabbitAccessControlPolicy.class);
+
+    public static JackrabbitAccessControlPolicy fromAccessControlPolicy(AccessControlPolicy policy) throws RepositoryException {
+        final JackrabbitAccessControlPolicyBuilder<? extends JackrabbitAccessControlPolicy> builder;
+        if (policy instanceof PrincipalAccessControlList) {
+            PrincipalAccessControlList principalAcl = (PrincipalAccessControlList)policy;
+            builder = new PrincipalBasedAccessControlList.Builder(principalAcl.getPrincipal().getName());
+            Arrays.stream(principalAcl.getAccessControlEntries()).map(PrincipalAccessControlList.Entry.class::cast).map(t -> {
+                try {
+                    return new PrincipalBasedAccessControlEntry(t);
+                } catch (RepositoryException e) {
+                    throw new UncheckedRepositoryException(e);
+                }
+            }).forEach(builder::addEntry);
+        } else if (policy instanceof PrincipalSetPolicy) {
+            PrincipalSetPolicy principalSetPolicy = (PrincipalSetPolicy)policy;
+            builder = new PrincipalSetAccessControlPolicy.Builder(principalSetPolicy.getPrincipals().stream().map(Principal::getName).collect(Collectors.toList()));
+        } else if (policy instanceof JackrabbitAccessControlList) {
+            JackrabbitAccessControlList acl = (JackrabbitAccessControlList)policy;
+            builder = new ResourceBasedAccessControlList.Builder();
+            Arrays.stream(acl.getAccessControlEntries()).map(JackrabbitAccessControlEntry.class::cast).map(t -> {
+                try {
+                    return new ResourceBasedAccessControlEntry(t);
+                } catch (RepositoryException e) {
+                    throw new UncheckedRepositoryException(e);
+                }
+            }).forEach(builder::addEntry);
+        } else {
+            throw new RepositoryException("Unsupported policy type " + policy);
+        }
+        return builder.build();
+    }
+
+    JackrabbitAccessControlPolicy() {
+    }
+
+    Principal getPrincipal(Session session, final String principalName, final String accessControlledPath) throws RepositoryException {
+        PrincipalManager pMgr = getPrincipalManager(session);
+        Principal p = pMgr.getPrincipal(principalName);
+        if (p == null) {
+            try {
+                Authorizable a = getUserManager(session).getAuthorizableByPath(accessControlledPath);
+                if (a != null) {
+                    p = a.getPrincipal();
+                }
+            } catch (RepositoryException e) {
+                log.debug("Error while trying to retrieve user/group from access controlled path {}, {}", accessControlledPath, e.getMessage());
+            }
+            if (p == null) {
+                p = getPrincipal(principalName);
+            }
+        }
+        return p;
+    }
+
+    Principal getPrincipal(final String principalName) {
+        return new SimplePrincipal(principalName);
+    }
+
+    protected static final JackrabbitAccessControlManager getAccessControlManager(Session session) throws RepositoryException {
+        AccessControlManager acMgr = session.getAccessControlManager();
+        if (!(acMgr instanceof JackrabbitAccessControlManager)) {
+            throw new IllegalStateException("The access control manager exposed by the given session is no JackrabbitAccessControlManager");
+        }
+        return (JackrabbitAccessControlManager)acMgr;
+    }
+
+    protected static final PrincipalManager getPrincipalManager(Session session) throws RepositoryException {
+        if(!(session instanceof JackrabbitSession)) {
+            throw new IllegalStateException("This session is not a JackrabbitSession");
+        }
+        return ((JackrabbitSession)session).getPrincipalManager();
+    }
+
+    protected static final UserManager getUserManager(Session session) throws RepositoryException {
+        if(!(session instanceof JackrabbitSession)) {
+            throw new IllegalStateException("This session is not a JackrabbitSession");
+        }
+        return ((JackrabbitSession)session).getUserManager();
+    }
+
+    <T> T getPolicy(JackrabbitAccessControlManager acMgr, Class<T> clz, final String accessControlledPath) throws RepositoryException {
+        for (AccessControlPolicy p : acMgr.getPolicies(accessControlledPath)) {
+            if (clz.isAssignableFrom(p.getClass())) {
+                return clz.cast(p);
+            }
+        }
+        return null;
+    }
+
+    <T> T getPolicy(JackrabbitAccessControlManager acMgr, Class<T> clz, Principal principal) throws RepositoryException {
+        for (AccessControlPolicy p : acMgr.getPolicies(principal)) {
+            if (clz.isAssignableFrom(p.getClass())) {
+                return clz.cast(p);
+            }
+        }
+        return null;
+    }
+
+    <T> T getApplicablePolicy(JackrabbitAccessControlManager acMgr, Class<T> clz, final String accessControlledPath) throws RepositoryException {
+        AccessControlPolicyIterator iter = acMgr.getApplicablePolicies(accessControlledPath);
+        while (iter.hasNext()) {
+            AccessControlPolicy p = iter.nextAccessControlPolicy();
+            if (clz.isAssignableFrom(p.getClass())) {
+                return clz.cast(p);
+            }
+        }
+
+        // no applicable policy
+        throw new RepositoryException("no applicable AccessControlPolicy of type " + clz + " on " +
+                (accessControlledPath == null ? "'root'" : accessControlledPath));
+    }
+
+    <T> T getApplicablePolicy(JackrabbitAccessControlManager acMgr, Class<T> clz, Principal principal) throws RepositoryException {
+        for (AccessControlPolicy p : acMgr.getApplicablePolicies(principal)) {
+            if (clz.isAssignableFrom(p.getClass())) {
+                return clz.cast(p);
+            }
+        }
+
+        // no applicable policy
+        throw new AccessControlException("no applicable AccessControlPolicy of type " + clz + " for " + principal.getName());
+    }
+
+    /**
+     * Imports the policy into the repository according to the rules from {@code aclHandling}.
+     * @param session
+     * @param aclHandling
+     * @param accessControlledPath the path under which the policy is supposed to be added/imported (not necessarily equal to the path the policy affects)
+     * @return the paths which have been modified or added
+     * 
+     * @throws RepositoryException
+     */
+    public abstract List<String> apply(Session session, AccessControlHandling aclHandling, String accessControlledPath) throws RepositoryException;
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicyBuilder.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicyBuilder.java
new file mode 100644
index 00000000..3b84054d
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/JackrabbitAccessControlPolicyBuilder.java
@@ -0,0 +1,25 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+public interface JackrabbitAccessControlPolicyBuilder<T extends JackrabbitAccessControlPolicy> {
+
+    T build();
+
+    void addEntry(AbstractAccessControlEntry entry);
+
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlEntry.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlEntry.java
new file mode 100644
index 00000000..7abf2f72
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlEntry.java
@@ -0,0 +1,54 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.util.Collection;
+import java.util.Map;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
+
+import org.apache.jackrabbit.api.security.authorization.PrincipalAccessControlList;
+
+public class PrincipalBasedAccessControlEntry extends AbstractAccessControlEntry {
+
+    public static class Builder extends AbstractAccessControlEntry.Builder<PrincipalBasedAccessControlEntry> {
+        final String effectivePath;
+
+        public Builder(Collection<String> privileges, String effectivePath) {
+            super(privileges);
+            this.effectivePath = effectivePath;
+        }
+
+        @Override
+        public PrincipalBasedAccessControlEntry build() {
+            return new PrincipalBasedAccessControlEntry(effectivePath, privileges, restrictions);
+        }
+    }
+
+    final String effectivePath;
+
+    public PrincipalBasedAccessControlEntry(PrincipalAccessControlList.Entry entry) throws RepositoryException {
+        super(entry);
+        this.effectivePath = entry.getEffectivePath();
+    }
+
+    public PrincipalBasedAccessControlEntry(String effectivePath, Collection<String> privileges, Map<String, Value[]> restrictions) {
+        super(privileges, restrictions);
+        this.effectivePath = effectivePath;
+    }
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlList.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlList.java
new file mode 100644
index 00000000..0352211c
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalBasedAccessControlList.java
@@ -0,0 +1,107 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.Value;
+
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
+import org.apache.jackrabbit.api.security.authorization.PrincipalAccessControlList;
+import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitACLManagement;
+
+public class PrincipalBasedAccessControlList extends JackrabbitAccessControlPolicy {
+
+    public static final class Builder implements JackrabbitAccessControlPolicyBuilder<PrincipalBasedAccessControlList> {
+        private final List<PrincipalBasedAccessControlEntry> entries = new ArrayList<>();
+        private final String principalName;
+
+        public Builder(String principalName) {
+            this.principalName = principalName;
+        }
+
+        @Override
+        public void addEntry(AbstractAccessControlEntry entry) {
+            if (!(entry instanceof PrincipalBasedAccessControlEntry)) {
+                throw new IllegalStateException("Only entries of type PrincipalBasedAccessControlEntry are supported");
+            }
+            entries.add((PrincipalBasedAccessControlEntry)entry);
+        }
+
+        @Override
+        public PrincipalBasedAccessControlList build() {
+            return new PrincipalBasedAccessControlList(principalName, entries);
+        }
+    }
+
+    private final String principalName;
+    private final List<PrincipalBasedAccessControlEntry> entries = new ArrayList<>();
+
+    private PrincipalBasedAccessControlList(String principalName, List<PrincipalBasedAccessControlEntry> entries) {
+        this.entries.addAll(entries);
+        this.principalName = principalName;
+    }
+
+    @Override
+    public List<String> apply(Session session, final AccessControlHandling aclHandling, String accessControlledPath) throws RepositoryException {
+        if (aclHandling == AccessControlHandling.IGNORE) {
+            return Collections.emptyList();
+        }
+        if (aclHandling == AccessControlHandling.MERGE_PRESERVE) {
+            log.debug("MERGE_PRESERVE for principal-based access control list is equivalent to IGNORE.");
+            return Collections.emptyList();
+        }
+
+        JackrabbitAccessControlManager acMgr = getAccessControlManager(session);
+        Principal principal = getPrincipal(session, principalName, accessControlledPath);
+        PrincipalAccessControlList acl = getPolicy(acMgr, PrincipalAccessControlList.class, principal);
+        if (acl != null && aclHandling == AccessControlHandling.OVERWRITE) {
+            // remove existing policy for 'OVERWRITE'
+            acMgr.removePolicy(acl.getPath(), acl);
+            acl = null;
+        }
+
+        if (acl == null) {
+            acl = getApplicablePolicy(acMgr, PrincipalAccessControlList.class, principal);
+        }
+
+        // apply ACEs of package for MERGE and OVERWRITE
+        for (PrincipalBasedAccessControlEntry entry : entries) {
+            Entry<Map<String, Value>, Map<String, Value[]>> restrictions = entry.separateRestrictions(acl);
+            acl.addEntry(entry.effectivePath, entry.getPrivileges(acMgr), restrictions.getKey(), restrictions.getValue());
+        }
+        acMgr.setPolicy(acl.getPath(), acl);
+
+        final String path;
+        if (acl.getPath() == null) {
+            path =  "/" + JackrabbitACLManagement.REP_REPO_POLICY;
+        } else if ("/".equals(acl.getPath())) {
+            path = "/" + JackrabbitACLManagement.REP_PRINCIPAL_POLICY;
+        } else {
+            path = acl.getPath() + "/" + JackrabbitACLManagement.REP_PRINCIPAL_POLICY;
+        }
+        return Collections.singletonList(path);
+    }
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalSetAccessControlPolicy.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalSetAccessControlPolicy.java
new file mode 100644
index 00000000..5a4eec06
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/PrincipalSetAccessControlPolicy.java
@@ -0,0 +1,94 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.security.Principal;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
+import org.apache.jackrabbit.api.security.authorization.PrincipalSetPolicy;
+import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitACLManagement;
+
+public class PrincipalSetAccessControlPolicy extends JackrabbitAccessControlPolicy {
+
+    public static final class Builder implements JackrabbitAccessControlPolicyBuilder<JackrabbitAccessControlPolicy> {
+        private final Collection<String> principalNames;
+
+        public Builder(Collection<String> principalNames) {
+            this.principalNames = new HashSet<>(principalNames);
+        }
+
+        @Override
+        public void addEntry(AbstractAccessControlEntry entry) {
+            throw new UnsupportedOperationException("This policy type does not support entries");
+        }
+
+        @Override
+        public PrincipalSetAccessControlPolicy build() {
+            return new PrincipalSetAccessControlPolicy(principalNames);
+        }
+
+    }
+
+    private final Collection<String> principalNames;
+
+    public PrincipalSetAccessControlPolicy(Collection<String> principalNames) {
+        this.principalNames = new HashSet<>(principalNames);
+    }
+
+    @Override
+    public List<String> apply(Session session, AccessControlHandling aclHandling, String accessControlledPath) throws RepositoryException {
+        if (aclHandling == AccessControlHandling.IGNORE) {
+            return Collections.emptyList();
+        }
+        JackrabbitAccessControlManager acMgr = getAccessControlManager(session);
+        PrincipalSetPolicy psPolicy = getPolicy(acMgr, PrincipalSetPolicy.class, accessControlledPath);
+        if (psPolicy != null) {
+            Set<Principal> existingPrincipals = psPolicy.getPrincipals();
+            // remove existing policy for 'overwrite'
+            if (aclHandling == AccessControlHandling.OVERWRITE) {
+                psPolicy.removePrincipals(existingPrincipals.toArray(new Principal[existingPrincipals.size()]));
+            }
+        } else {
+            psPolicy = getApplicablePolicy(acMgr, PrincipalSetPolicy.class, accessControlledPath);
+        }
+
+        // TODO: correct behavior for MERGE and MERGE_PRESERVE?
+        Principal[] principals = principalNames.stream().map(name -> getPrincipal(name)).toArray(Principal[]::new);
+
+        psPolicy.addPrincipals(principals);
+        acMgr.setPolicy(accessControlledPath, psPolicy);
+
+        final String path;
+        if ("/".equals(accessControlledPath)) {
+            path = "/" + JackrabbitACLManagement.REP_CUG_POLICY;
+        } else {
+            path = accessControlledPath + "/" + JackrabbitACLManagement.REP_CUG_POLICY;
+        }
+        return Collections.singletonList(path);
+    }
+    
+    
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlEntry.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlEntry.java
new file mode 100644
index 00000000..1a5efead
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlEntry.java
@@ -0,0 +1,59 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.util.Collection;
+import java.util.Map;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
+
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlEntry;
+
+public class ResourceBasedAccessControlEntry extends AbstractAccessControlEntry {
+
+    public static class Builder extends AbstractAccessControlEntry.Builder<ResourceBasedAccessControlEntry> {
+        final boolean allow;
+        final String principalName;
+
+        public Builder(Collection<String> privileges, boolean allow, String principalName) {
+            super(privileges);
+            this.allow = allow;
+            this.principalName = principalName;
+        }
+
+        @Override
+        public ResourceBasedAccessControlEntry build() {
+            return new ResourceBasedAccessControlEntry(allow, principalName, privileges, restrictions);
+        }
+    }
+
+    final boolean allow;
+    final String principalName;
+
+    public ResourceBasedAccessControlEntry(JackrabbitAccessControlEntry entry) throws RepositoryException {
+        super(entry);
+        this.allow = entry.isAllow();
+        this.principalName = entry.getPrincipal().getName();
+    }
+
+    protected ResourceBasedAccessControlEntry(boolean allow, String principalName, Collection<String> privileges, Map<String, Value[]> restrictions) {
+        super(privileges, restrictions);
+        this.allow = allow;
+        this.principalName = principalName;
+    }
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlList.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlList.java
new file mode 100644
index 00000000..1b5c1e91
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/impl/jcr20/accesscontrol/ResourceBasedAccessControlList.java
@@ -0,0 +1,128 @@
+/*************************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ************************************************************************/
+package org.apache.jackrabbit.vault.fs.spi.impl.jcr20.accesscontrol;
+
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.Value;
+import javax.jcr.security.AccessControlEntry;
+
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlManager;
+import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitACLManagement;
+
+public class ResourceBasedAccessControlList extends JackrabbitAccessControlPolicy {
+
+    public static final class Builder implements JackrabbitAccessControlPolicyBuilder<ResourceBasedAccessControlList> {
+        private final List<ResourceBasedAccessControlEntry> entries;
+
+        public Builder() {
+            entries = new ArrayList<>();
+        }
+
+        @Override
+        public void addEntry(AbstractAccessControlEntry entry) {
+            if (!(entry instanceof ResourceBasedAccessControlEntry)) {
+                throw new IllegalStateException("Only entries of type ResourceBasedAccessControlEntry are supported");
+            }
+            entries.add((ResourceBasedAccessControlEntry)entry);
+        }
+
+        @Override
+        public ResourceBasedAccessControlList build() {
+            return new ResourceBasedAccessControlList(entries);
+        }
+    }
+
+    private final List<ResourceBasedAccessControlEntry> entries = new ArrayList<>();
+
+    ResourceBasedAccessControlList(List<ResourceBasedAccessControlEntry> aceList) {
+        super();
+        this.entries.addAll(aceList);
+    }
+
+    @Override
+    public List<String> apply(Session session, final AccessControlHandling aclHandling, String accessControlledPath) throws RepositoryException {
+        if (aclHandling == AccessControlHandling.IGNORE) {
+            return Collections.emptyList();
+        }
+        JackrabbitAccessControlManager acMgr = getAccessControlManager(session);
+        // find principals of existing ACL
+        JackrabbitAccessControlList acl = getPolicy(acMgr, JackrabbitAccessControlList.class, accessControlledPath);
+        Set<String> existingPrincipals = new HashSet<>();
+        if (acl != null) {
+            for (AccessControlEntry ace : acl.getAccessControlEntries()) {
+                existingPrincipals.add(ace.getPrincipal().getName());
+            }
+
+            // remove existing policy for 'overwrite'
+            if (aclHandling == AccessControlHandling.OVERWRITE) {
+                acMgr.removePolicy(accessControlledPath, acl);
+                acl = null;
+            }
+        }
+
+        if (acl == null) {
+            acl = getApplicablePolicy(acMgr, JackrabbitAccessControlList.class, accessControlledPath);
+        }
+
+        // clear all ACEs of the package principals for merge (VLT-94), otherwise the `acl.addEntry()` below
+        // might just combine the privileges.
+        if (aclHandling == AccessControlHandling.MERGE) {
+            for (ResourceBasedAccessControlEntry entry : entries) {
+                for (AccessControlEntry ace : acl.getAccessControlEntries()) {
+                    if (ace.getPrincipal().getName().equals(entry.principalName)) {
+                        acl.removeAccessControlEntry(ace);
+                    }
+                }
+            }
+        }
+
+        // apply ACEs of package
+        for (ResourceBasedAccessControlEntry ace : entries) {
+            final String principalName = ace.principalName;
+            if (aclHandling == AccessControlHandling.MERGE_PRESERVE && existingPrincipals.contains(principalName)) {
+                // skip principal if it already has an ACL
+                continue;
+            }
+            Principal principal = getPrincipal(principalName);
+            Entry<Map<String, Value>, Map<String, Value[]>> restrictions = ace.separateRestrictions(acl);
+            acl.addEntry(principal, ace.getPrivileges(acMgr), ace.allow, restrictions.getKey(), restrictions.getValue());
+        }
+        acMgr.setPolicy(accessControlledPath, acl);
+        final String path;
+        if (accessControlledPath == null) {
+            path = "/" + JackrabbitACLManagement.REP_REPO_POLICY;
+        } else if ("/".equals(accessControlledPath)) {
+            path = "/" + JackrabbitACLManagement.REP_POLICY;
+        } else {
+            path = accessControlledPath + "/" + JackrabbitACLManagement.REP_POLICY;
+        }
+        return Collections.singletonList(path);
+    }
+
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/package-info.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/package-info.java
index 9b735fd4..6fae8abe 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/package-info.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/spi/package-info.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-@Version("2.5.0")
+@Version("2.6.0")
 package org.apache.jackrabbit.vault.fs.spi;
 
 import org.osgi.annotation.versioning.Version;
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewProperty2.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewProperty2.java
index 98ab931e..c5060ff2 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewProperty2.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/DocViewProperty2.java
@@ -25,6 +25,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import javax.jcr.Binary;
 import javax.jcr.InvalidSerializedDataException;
@@ -35,6 +36,7 @@ import javax.jcr.PropertyType;
 import javax.jcr.RepositoryException;
 import javax.jcr.Session;
 import javax.jcr.Value;
+import javax.jcr.ValueFactory;
 import javax.jcr.ValueFormatException;
 import javax.jcr.lock.LockException;
 import javax.jcr.nodetype.ConstraintViolationException;
@@ -49,13 +51,14 @@ import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.util.Text;
 import org.apache.jackrabbit.util.XMLChar;
+import org.apache.jackrabbit.value.ValueFactoryImpl;
 import org.apache.jackrabbit.value.ValueHelper;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 /**
- * Helper class that represents a JCR property in the FileVault (enhanced) document view format.
- * It contains formatting and parsing methods for writing/reading enhanced
+ * Immutable helper class that represents a JCR property in the FileVault (enhanced) document view format.
+ * It contains formatting and parsing methods for serializing/deserializing enhanced
  * docview properties.
  * <br>
  * The string representation adheres to the following grammar:
@@ -703,6 +706,10 @@ public class DocViewProperty2 {
         return type;
     }
 
+    private int getSafeType() {
+        return type == PropertyType.UNDEFINED ? PropertyType.STRING : type;
+    }
+
     public @NotNull Optional<String> getStringValue() {
         if (!values.isEmpty()) {
             return Optional.of(values.get(0));
@@ -713,4 +720,37 @@ public class DocViewProperty2 {
     public @NotNull List<String> getStringValues() {
         return values;
     }
+
+    /**
+     * @param valueFactory the value factory to use for converting the underlying string to the JCR value
+     * @return the value or empty if no value set. For multi value only the first item is returned
+     * @throws ValueFormatException
+     * @since 3.6.10
+     */ 
+    public @NotNull Optional<Value> getValue(@NotNull ValueFactory valueFactory) throws ValueFormatException {
+        if (!values.isEmpty()) {
+            return Optional.of(valueFactory.createValue(values.get(0), getSafeType()));
+        }
+        return Optional.empty();
+    }
+
+    /**
+     * @param valueFactory the value factory to use for converting the underlying string to the JCR value
+     * @return the list of values, may be empty. In case of single value entry just a single value list.
+     * @throws ValueFormatException
+     * @since 3.6.10
+     */
+    public @NotNull List<Value> getValues(@NotNull ValueFactory valueFactory) throws ValueFormatException {
+        try {
+            return values.stream().map(v -> {
+                try {
+                    return valueFactory.createValue(v, getSafeType());
+                } catch (ValueFormatException e) {
+                    throw new UncheckedValueFormatException(e);
+                }
+            }).collect(Collectors.toList());
+        } catch (UncheckedValueFormatException e) {
+            throw e.getCause();
+        }
+    }
 }
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/UncheckedValueFormatException.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/UncheckedValueFormatException.java
new file mode 100644
index 00000000..2a49e107
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/UncheckedValueFormatException.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.util;
+
+import javax.jcr.ValueFormatException;
+
+/**
+ * Wraps a {@link ValueFormatException} with an unchecked exception.
+ * Useful in {@link FunctionalInterface} methods/lambda expressions which must not throw checked exceptions.
+ * @since 3.6.10
+ *
+ */
+public class UncheckedValueFormatException extends RuntimeException {
+
+    private static final long serialVersionUID = 7179774059211440453L;
+
+    public UncheckedValueFormatException(ValueFormatException e) {
+        super(e);
+    }
+
+    @Override
+    public synchronized ValueFormatException getCause() {
+        return (ValueFormatException) super.getCause();
+    }
+}
