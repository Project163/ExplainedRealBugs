diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
index 56eee3d7..8e128ccf 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXImporter.java
@@ -70,6 +70,7 @@ import org.apache.jackrabbit.vault.fs.spi.UserManagement;
 import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JcrNamespaceHelper;
 import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.util.DocViewProperty;
+import org.apache.jackrabbit.vault.util.EffectiveNodeType;
 import org.apache.jackrabbit.vault.util.JcrConstants;
 import org.apache.jackrabbit.vault.util.MimeTypes;
 import org.apache.jackrabbit.vault.util.RejectingEntityDefaultHandler;
@@ -1110,77 +1111,14 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
 
     /**
      * Determines if a given property is protected according to the node type.
-     * <br>
-     * Using the EffectiveNodeType would be faster and require less code, but this is not exposed via JCR API (but only via SPI and differs between Jackrabbit 2 and Oak).
-     * Also {@link NodeType#canSetProperty(String, Value)} cannot be used as this would return false not only for protected property but also for other constraint violations.
-     * This is functionally equivalent to <a href="https://github.com/apache/jackrabbit/blob/ed3124e5fe223dada33ce6ddf53bc666063c3f2f/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/EffectiveNodeType.java#L764">EffectiveNodeType.getApplicablePropertyDef(...)</a>.
-     * 
-     * @param node the node
+    * 
+     * @param effectiveNodeType the effective node type
      * @param docViewProperty the property
      * @return{@code true} in case the property is protected, {@code false} otherwise
      * @throws RepositoryException 
      */
-    private static boolean isPropertyProtected(@NotNull Node node, @NotNull DocViewProperty docViewProperty) throws RepositoryException {
-        // first named property definitions
-        PropertyDefinition propDef = getApplicablePropertyDefinition(node, docViewProperty, true);
-        if (propDef == null) {
-            // then residual property definitions
-            propDef = getApplicablePropertyDefinition(node, docViewProperty, false);
-        }
-        if (propDef != null) {
-            return propDef.isProtected();
-        }
-        return false;
-    }
-
-    private static @Nullable PropertyDefinition getApplicablePropertyDefinition(@NotNull Node node, @NotNull DocViewProperty docViewProperty, boolean onlyNamedDefinitions) throws RepositoryException {
-        PropertyDefinition propDef = getMatchingPropertyDefinition(node.getPrimaryNodeType(), docViewProperty, onlyNamedDefinitions);
-        if (propDef != null) {
-            return propDef;
-        }
-        for (NodeType mixinNodeType : node.getMixinNodeTypes()) {
-            propDef = getMatchingPropertyDefinition(mixinNodeType, docViewProperty, onlyNamedDefinitions);
-            if (propDef != null) {
-                return propDef;
-            }
-        }
-        return null;
-    }
-
-    // functionally almost equivalent to https://github.com/apache/jackrabbit/blob/ed3124e5fe223dada33ce6ddf53bc666063c3f2f/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/EffectiveNodeType.java#L825
-    private static PropertyDefinition getMatchingPropertyDefinition(@NotNull NodeType nodeType, @NotNull DocViewProperty docViewProperty, boolean onlyNamedDefinitions) {
-        
-        Predicate<PropertyDefinition> predicate;
-        if (onlyNamedDefinitions) {
-            predicate = (pd) -> docViewProperty.name.equals(pd.getName());
-        } else {
-            predicate = (pd) -> "*".equals(pd.getName());
-        }
-        // either named or residual property definitions
-        Set<PropertyDefinition> relevantPropertyDefinitions = Arrays.stream(nodeType.getPropertyDefinitions()).filter(predicate).collect(Collectors.toSet());
-        
-        PropertyDefinition match = null;
-        for (PropertyDefinition pd : relevantPropertyDefinitions) {
-            int reqType = pd.getRequiredType();
-            // match type
-            if (reqType == PropertyType.UNDEFINED
-                    || docViewProperty.type == PropertyType.UNDEFINED
-                    || reqType == docViewProperty.type) {
-                // match multiValued flag
-                if (docViewProperty.isMulti == pd.isMultiple()) {
-                    // found match
-                    if (pd.getRequiredType() != PropertyType.UNDEFINED) {
-                        // found best possible match, get outta here
-                        return pd;
-                    } else {
-                        if (match == null) {
-                            match = pd;
-                        }
-                    }
-                }
-            }
-        }
-        return match;
+    private static boolean isPropertyProtected(@NotNull EffectiveNodeType effectiveNodeType, @NotNull DocViewProperty docViewProperty) throws RepositoryException {
+        return effectiveNodeType.getApplicablePropertyDefinition(docViewProperty.name, docViewProperty.isMulti, docViewProperty.type).map(PropertyDefinition::isProtected).orElse(false);
     }
 
     private Node getNodeByUUIDLabelOrName(@NotNull Node currentNode, @NotNull DocViewNode ni) throws RepositoryException {
@@ -1219,10 +1157,11 @@ public class DocViewSAXImporter extends RejectingEntityDefaultHandler implements
                 }
             }
         }
+        EffectiveNodeType effectiveNodeType = EffectiveNodeType.ofNode(node);
         boolean modified = false;
         // add properties
         for (DocViewProperty prop : ni.props.values()) {
-            if (prop != null && !isPropertyProtected(node, prop) && (overwriteExistingProperties || !node.hasProperty(prop.name)) && wspFilter.includesProperty(node.getPath() + "/" + prop.name)) {
+            if (prop != null && !isPropertyProtected(effectiveNodeType, prop) && (overwriteExistingProperties || !node.hasProperty(prop.name)) && wspFilter.includesProperty(node.getPath() + "/" + prop.name)) {
                 // check if property is allowed
                 try {
                     modified |= prop.apply(node);
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
index c8131b84..c0a9119d 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/FolderArtifactHandler.java
@@ -18,7 +18,10 @@
 package org.apache.jackrabbit.vault.fs.impl.io;
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 import javax.jcr.Node;
@@ -33,6 +36,7 @@ import org.apache.jackrabbit.vault.fs.api.ImportMode;
 import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.fs.impl.ArtifactSetImpl;
 import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
+import org.apache.jackrabbit.vault.util.EffectiveNodeType;
 import org.apache.jackrabbit.vault.util.JcrConstants;
 
 /**
@@ -41,6 +45,11 @@ import org.apache.jackrabbit.vault.util.JcrConstants;
  */
 public class FolderArtifactHandler extends AbstractArtifactHandler {
 
+    /**
+     * qualified names of those default node types which should not be used for intermediate nodes (as they come with too many restrictions)
+     */
+    private static final List<String> DISALLOWED_PRIMARY_NODE_TYPE_NAMES = Arrays.asList(JcrConstants.NT_BASE, JcrConstants.NT_HIERARCHYNODE);
+
     /**
      * node type to use for the folders
      */
@@ -62,6 +71,18 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
         this.nodeType = nodeType;
     }
 
+    private Node createIntermediateNode(Node parent, String intermediateNodeName) throws RepositoryException {
+        // preferably use default (=primary) node type for intermediate nodes
+        Optional<String> defaultPrimaryChildNodeType = EffectiveNodeType.ofNode(parent).getDefaultPrimaryChildNodeTypeName(parent, intermediateNodeName);
+        final Node node;
+        if (defaultPrimaryChildNodeType.isPresent() && !DISALLOWED_PRIMARY_NODE_TYPE_NAMES.contains(defaultPrimaryChildNodeType.get())) {
+            node = parent.addNode(intermediateNodeName);
+        } else {
+            node = parent.addNode(intermediateNodeName, nodeType);
+        }
+        return node;
+    }
+
     /**
      * {@inheritDoc}
      *
@@ -84,18 +105,12 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
             if (wspFilter.contains(parent.getPath() + "/" + dir.getRelativePath())) {
                 node = parent.addNode(dir.getRelativePath(), nodeType);
             } else {
-                // preferably use default node type for intermediate nodes
-                if (parent.getPrimaryNodeType().canAddChildNode(dir.getRelativePath())) {
-                    node = parent.addNode(dir.getRelativePath());
-                } else {
-                    node = parent.addNode(dir.getRelativePath(), nodeType);
-                }
-                
+                node = createIntermediateNode(parent, dir.getRelativePath());
             }
             info.onCreated(node.getPath());
         } else {
             // sync nodes
-            Set<String> hints = new HashSet<String>();
+            Set<String> hints = new HashSet<>();
             String rootPath = parent.getPath();
             if (!rootPath.equals("/")) {
                 rootPath += "/";
@@ -112,26 +127,24 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
             while (iter.hasNext()) {
                 Node child = iter.nextNode();
                 String path = child.getPath();
-                if (wspFilter.contains(path)) {
-                    if (wspFilter.getImportMode(path) == ImportMode.REPLACE) {
-                        if (!hints.contains(path)) {
-                            // if the child is in the filter, it belongs to
-                            // this aggregate and needs to be removed
-                            if (getAclManagement().isACLNode(child)) {
-                                if (acHandling == AccessControlHandling.OVERWRITE
-                                        || acHandling == AccessControlHandling.CLEAR) {
-                                    info.onDeleted(path);
-                                    getAclManagement().clearACL(node);
-                                }
-                            } else {
+                if (wspFilter.contains(path) && wspFilter.getImportMode(path) == ImportMode.REPLACE) {
+                    if (!hints.contains(path)) {
+                        // if the child is in the filter, it belongs to
+                        // this aggregate and needs to be removed
+                        if (getAclManagement().isACLNode(child)) {
+                            if (acHandling == AccessControlHandling.OVERWRITE
+                                    || acHandling == AccessControlHandling.CLEAR) {
                                 info.onDeleted(path);
-                                child.remove();
+                                getAclManagement().clearACL(node);
                             }
-                        } else if (acHandling == AccessControlHandling.CLEAR
-                                && getAclManagement().isACLNode(child)) {
+                        } else {
                             info.onDeleted(path);
-                            getAclManagement().clearACL(node);
+                            child.remove();
                         }
+                    } else if (acHandling == AccessControlHandling.CLEAR
+                            && getAclManagement().isACLNode(child)) {
+                        info.onDeleted(path);
+                        getAclManagement().clearACL(node);
                     }
                 }
             }
@@ -169,7 +182,7 @@ public class FolderArtifactHandler extends AbstractArtifactHandler {
             try {
                 node.checkout();
             } catch (RepositoryException e) {
-                info.log.warn("error while checkout node (ignored)", e);
+                ImportInfoImpl.log.warn("error while checkout node (ignored)", e);
             }
         }
     }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/EffectiveNodeType.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/EffectiveNodeType.java
new file mode 100644
index 00000000..c90a7f88
--- /dev/null
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/EffectiveNodeType.java
@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.util;
+
+import static javax.jcr.PropertyType.UNDEFINED;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+import javax.jcr.Node;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ItemDefinition;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.PropertyDefinition;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Effective node type as defined by <a href="https://docs.adobe.com/content/docs/en/spec/jcr/2.0/3_Repository_Model.html#3.7.6.5%20Effective%20Node%20Type">JCR 2.0, Chapter 3.7.6.5</a>.
+ * The order is an implementation detail (compare with <a href="https://docs.adobe.com/content/docs/en/spec/jcr/2.0/3_Repository_Model.html#3.7.7%20Applicable%20Item%20Definition">JCR 2.0, Chapter 3.7.7</a>)
+ * but this implementation replicates the logic from Oak:
+ * <ul>
+ * <li>local before inherited types</li>
+ * <li>named primary types (even inherited ones) before named mixin types</li>
+ * <li>residual primary types (even inherited ones) before residual mixin types</li>
+ * <li>all named item definitions should be considered first (of both primary and mixins) and only afterwards the unnamed ones</li>
+ * <li>the first potential match wins (even if it is only for the undefined type and more type-specific definitions follow later)</li>
+ * </ul>
+ */
+public final class EffectiveNodeType {
+
+    public static EffectiveNodeType ofNode(Node node) throws RepositoryException {
+        return ofPrimaryTypeAndMixins(node.getPrimaryNodeType(), node.getMixinNodeTypes());
+    }
+
+    public static EffectiveNodeType ofPrimaryTypeAndMixins(NodeType primaryType, NodeType... mixinTypes) {
+        List<NodeType> types = new ArrayList<>();
+        types.add(primaryType);
+        Arrays.stream(mixinTypes).forEach(types::add);
+        return new EffectiveNodeType(types);
+    }
+
+    private final List<NodeType> nodeTypes;
+
+    private EffectiveNodeType(List<NodeType> nodeTypes) {
+        this.nodeTypes = nodeTypes;
+    }
+
+    /**
+     * Returns the applicable property definition for the given name and type.
+     * @param name the property name
+     * @param isMultiple {@code true} if this is a multi-value type otherwise {@code false}
+     * @param type the property value type (one of the constants from {@link PropertyType})
+     * @return the applicable property definition
+     * 
+     */
+    public Optional<PropertyDefinition> getApplicablePropertyDefinition(@NotNull String name, boolean isMultiple, int type) {
+        // This replicates the logic from https://github.com/apache/jackrabbit-oak/blob/274f92402a12978040939965e92ee4519f2ce1c3/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveNodeTypeImpl.java#L365
+        return getApplicablePropertyDefinition(pd -> isMultiple == pd.isMultiple() && (type == pd.getRequiredType() || UNDEFINED == type || UNDEFINED == pd.getRequiredType()), name);
+    }
+
+    public Optional<PropertyDefinition> getApplicablePropertyDefinition(Predicate<PropertyDefinition> predicate, @NotNull String name) {
+        List<PropertyDefinition> propertyDefinitions = nodeTypes.stream().flatMap(nt -> Arrays.stream(nt.getPropertyDefinitions())).collect(Collectors.toList());
+        // first named then unnamed
+        Optional<PropertyDefinition> namedPropertyDef = EffectiveNodeType.<PropertyDefinition>getApplicableItemDefinition(propertyDefinitions, predicate, name);
+        if (!namedPropertyDef.isPresent()) {
+            // then unnamed
+            return EffectiveNodeType.<PropertyDefinition>getApplicableItemDefinition(propertyDefinitions, predicate, null);
+        } else {
+            return namedPropertyDef;
+        }
+    }
+
+    /**
+     * Returns the applicable node definition for the given name and types.
+     * @param name the child node name
+     * @param types the node types
+     * @return the applicable child node definition
+     */
+    public Optional<NodeDefinition> getApplicableChildNodeDefinition(@NotNull String name, @NotNull NodeType... types) {
+        // This replicates the logic from https://github.com/apache/jackrabbit-oak/blob/274f92402a12978040939965e92ee4519f2ce1c3/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveNodeTypeImpl.java#L440
+        return getApplicableChildNodeDefinition(nd -> Arrays.stream(nd.getRequiredPrimaryTypeNames()).allMatch(requiredPrimaryType -> Arrays.stream(types).anyMatch(providedType -> providedType.isNodeType(requiredPrimaryType))), name);
+    }
+
+    public Optional<NodeDefinition> getApplicableChildNodeDefinition(Predicate<NodeDefinition> predicate, @NotNull String name) {
+        List<NodeDefinition> nodeDefinitions = nodeTypes.stream().flatMap(nt -> Arrays.stream(nt.getChildNodeDefinitions())).collect(Collectors.toList());
+        // first named then unnamed
+        Optional<NodeDefinition> namedNodeDef = EffectiveNodeType.<NodeDefinition>getApplicableItemDefinition(nodeDefinitions, predicate, name);
+        if (!namedNodeDef.isPresent()) {
+            // then unnamed
+            return EffectiveNodeType.<NodeDefinition>getApplicableItemDefinition(nodeDefinitions, predicate, null);
+        } else {
+            return namedNodeDef;
+        }
+    }
+
+    private static <T extends ItemDefinition> Optional<T> getApplicableItemDefinition(List<T> itemDefinitions, Predicate<T> predicate, @Nullable String name) {
+        final Predicate<ItemDefinition> namePredicate;
+        if (name != null) {
+            namePredicate = pd -> name.equals(pd.getName());
+        } else {
+            namePredicate = pd -> "*".equals(pd.getName());
+        }
+        // either named or residual child node definitions
+        return itemDefinitions.stream().filter(predicate).filter(namePredicate).findFirst();
+    }
+
+    /**
+     * 
+     * @param parent the node the parent node for which to figure out the default primary type
+     * @param nodeName the name of the to be created node
+     * @return the qualified name of the default primary type for the given intermediate node below parent
+     * @throws RepositoryException
+     */
+    public Optional<String> getDefaultPrimaryChildNodeTypeName(Node parent, String nodeName) throws RepositoryException {
+        Optional<NodeDefinition> nodeDefinition = getApplicableChildNodeDefinition(nd -> nd.getDefaultPrimaryType() != null,  nodeName);
+        return nodeDefinition.map(NodeDefinition::getDefaultPrimaryTypeName);
+    }
+}
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/package-info.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/package-info.java
index c40fa9a6..8d018d66 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/util/package-info.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/util/package-info.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-@Version("2.7.0")
+@Version("2.8.0")
 package org.apache.jackrabbit.vault.util;
 
 import org.osgi.annotation.versioning.Version;
\ No newline at end of file
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/FolderArtifactHandlerIT.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/FolderArtifactHandlerIT.java
index 16712aa7..be167c73 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/FolderArtifactHandlerIT.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/FolderArtifactHandlerIT.java
@@ -20,10 +20,15 @@ package org.apache.jackrabbit.vault.packaging.integration;
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.StandardCharsets;
 
 import javax.jcr.Node;
 import javax.jcr.RepositoryException;
 
+import org.apache.jackrabbit.commons.cnd.CndImporter;
+import org.apache.jackrabbit.commons.cnd.ParseException;
 import org.apache.jackrabbit.vault.packaging.PackageException;
 import org.apache.jackrabbit.vault.packaging.VaultPackage;
 import org.junit.Test;
@@ -100,7 +105,7 @@ public class FolderArtifactHandlerIT extends IntegrationTestBase {
         }
     }
 
-    // JCRVLT-542
+    // https://issues.apache.org/jira/browse/JCRVLT-542
     @Test
     public void testRootTypeOnMerge() throws RepositoryException, IOException, PackageException {
         Node rootNode = admin.getRootNode();
@@ -115,4 +120,16 @@ public class FolderArtifactHandlerIT extends IntegrationTestBase {
             assertNodeHasPrimaryType("/home/groups", "rep:AuthorizableFolder");
         }
     }
+
+    // https://issues.apache.org/jira/browse/JCRVLT-544
+    @Test
+    public void testFallbackToNtFolderForRestrictedDefaultNodeType() throws IOException, PackageException, RepositoryException, ParseException {
+        try (Reader reader = new InputStreamReader(getStream("cqComponent.cnd"), StandardCharsets.US_ASCII)) {
+            CndImporter.registerNodeTypes(reader, admin);
+        }
+        admin.getRootNode().addNode("testroot", "cq:Component"); // this has nt:base as default child node type
+        try (VaultPackage vltPackage = extractVaultPackage("/test-packages/intermediate_folders.zip")) {
+            assertNodeHasPrimaryType("/testroot/myfolder", "nt:folder");
+        }
+    }
 }
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/util/EffectiveNodeTypeIT.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/util/EffectiveNodeTypeIT.java
new file mode 100644
index 00000000..34460b67
--- /dev/null
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/util/EffectiveNodeTypeIT.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.util;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.StandardCharsets;
+import java.util.Optional;
+
+import javax.jcr.Node;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.NodeTypeExistsException;
+import javax.jcr.nodetype.PropertyDefinition;
+
+import org.apache.jackrabbit.commons.cnd.CndImporter;
+import org.apache.jackrabbit.commons.cnd.ParseException;
+import org.apache.jackrabbit.vault.packaging.integration.IntegrationTestBase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class EffectiveNodeTypeIT extends IntegrationTestBase {
+
+    private static final String MY_PRIMARY_TYPE = "my:Folder";
+    private static final String MY_MIXIN = "my:Mixin";
+
+    private Node node;
+
+    @Before
+    public void before() throws IOException, InvalidNodeTypeDefinitionException, NodeTypeExistsException, UnsupportedRepositoryOperationException, ParseException, RepositoryException {
+        try (Reader reader = new InputStreamReader(getStream("mynodetypes.cnd"), StandardCharsets.UTF_8)) {
+            // register cnd
+            CndImporter.registerNodeTypes(reader, admin);
+        }
+        node = admin.getRootNode().addNode("test", MY_PRIMARY_TYPE);
+    }
+
+    @After
+    public void after() {
+        clean("/test");
+    }
+
+    @Test
+    public void testGetApplicablePropertyDefinition() throws RepositoryException, ParseException, IOException {
+        node.addMixin(MY_MIXIN);
+        EffectiveNodeType effectiveNodeType = EffectiveNodeType.ofNode(node);
+
+        // this should be the named property definition from mixin type
+        Optional<PropertyDefinition> pd = effectiveNodeType.getApplicablePropertyDefinition("my:protectedProperty", false, PropertyType.BOOLEAN);
+        assertTrue(pd.isPresent());
+        assertTrue(pd.get().isProtected());
+
+        // this should be the residual property definition from primary type
+        pd = effectiveNodeType.getApplicablePropertyDefinition("my:stringProperty", false, PropertyType.STRING);
+        assertTrue(pd.isPresent());
+        assertFalse(pd.get().isMandatory());
+
+        // this should be inherited property definition from primary type
+        pd = effectiveNodeType.getApplicablePropertyDefinition("jcr:createdBy", false, PropertyType.STRING);
+        assertTrue(pd.isPresent());
+        assertTrue(pd.get().isProtected());
+        assertTrue(pd.get().isAutoCreated());
+    }
+
+    @Test
+    public void testGetApplicableChildNodeDefinition() throws RepositoryException, ParseException, IOException {
+        node.addMixin(MY_MIXIN);
+        EffectiveNodeType effectiveNodeType = EffectiveNodeType.ofNode(node);
+        NodeType myPrimaryType = admin.getWorkspace().getNodeTypeManager().getNodeType(MY_PRIMARY_TYPE);
+        NodeType myMixinType = admin.getWorkspace().getNodeTypeManager().getNodeType(MY_MIXIN);
+
+        // this should be the named child node definition from mixin type
+        Optional<NodeDefinition> nd = effectiveNodeType.getApplicableChildNodeDefinition("my:protectedChildNode", myPrimaryType, myMixinType);
+        assertTrue(nd.isPresent());
+        assertTrue(nd.get().isProtected());
+
+        // this should be the residual child node definition from primary type
+        nd = effectiveNodeType.getApplicableChildNodeDefinition("my:otherNode", myPrimaryType);
+        assertTrue(nd.isPresent());
+        assertTrue(nd.get().isMandatory());
+    }
+}
diff --git a/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/cqComponent.cnd b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/cqComponent.cnd
new file mode 100644
index 00000000..e528f067
--- /dev/null
+++ b/vault-core/src/test/resources/org/apache/jackrabbit/vault/packaging/integration/cqComponent.cnd
@@ -0,0 +1,81 @@
+/*
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+<'sling'='http://sling.apache.org/jcr/sling/1.0'>
+<'nt'='http://www.jcp.org/jcr/nt/1.0'>
+<'vlt'='http://www.day.com/jcr/vault/1.0'>
+<'cq'='http://www.day.com/jcr/cq/1.0'>
+
+[sling:ResourceSuperType]
+  mixin
+  - sling:resourceSuperType (string)
+
+[sling:Folder] > nt:folder
+  - * (undefined) multiple
+  - * (undefined)
+  + * (nt:base) = sling:Folder version
+
+[cq:InplaceEditingConfig] > nt:unstructured
+  orderable
+  - editorType (string)
+  - configPath (string)
+  - active (boolean)
+  + config (nt:unstructured) = nt:unstructured
+
+[cq:EditListenersConfig]
+  - afteredit (string)
+  - aftermove (string)
+  - afterremove (string)
+  - afterinsert (string)
+  - * (undefined)
+  - afterdelete (string)
+  - * (undefined) multiple
+  - aftercreate (string)
+  + * (nt:base) = nt:base multiple version
+
+[cq:EditConfig] > nt:hierarchyNode, nt:unstructured
+  orderable
+  - cq:dialogMode (string) < 'auto', 'floating', 'inline'
+  - cq:emptyText (string)
+  - cq:layout (string) < 'editbar', 'rollover', 'auto'
+  - cq:inherit (boolean)
+  - cq:actions (string) multiple
+  + cq:inplaceEditing (cq:InplaceEditingConfig) = cq:InplaceEditingConfig
+  + cq:actionConfigs (nt:base) = nt:unstructured
+  + cq:listeners (nt:base) = cq:EditListenersConfig
+  + cq:formParameters (nt:base) = nt:unstructured
+  + cq:dropTargets (nt:base) = nt:unstructured
+
+[cq:Component] > mix:title, nt:folder, sling:ResourceSuperType
+  - dialogPath (string)
+  - cq:noDecoration (boolean)
+  - allowedChildren (string) multiple
+  - * (undefined)
+  - cq:isContainer (boolean)
+  - allowedParents (string) multiple
+  - * (undefined) multiple
+  - cq:cellName (string)
+  - componentGroup (string)
+  + dialog (nt:base) = nt:unstructured
+  + design_dialog (nt:base) = nt:unstructured
+  + cq:htmlTag (nt:base) = nt:unstructured
+  + * (nt:base) = nt:base multiple version
+  + cq:infoProviders (nt:base) = nt:unstructured
+  + cq:editConfig (cq:EditConfig) = cq:EditConfig
+  + icon.png (nt:file)
+  + cq:childEditConfig (cq:EditConfig) = cq:EditConfig
+  + thumbnail.png (nt:file)
+  + virtual (nt:base) = sling:Folder
diff --git a/vault-core/src/test/resources/org/apache/jackrabbit/vault/util/mynodetypes.cnd b/vault-core/src/test/resources/org/apache/jackrabbit/vault/util/mynodetypes.cnd
new file mode 100644
index 00000000..1a2e6486
--- /dev/null
+++ b/vault-core/src/test/resources/org/apache/jackrabbit/vault/util/mynodetypes.cnd
@@ -0,0 +1,30 @@
+/*
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+<'nt'='http://www.jcp.org/jcr/nt/1.0'>
+<'vlt'='http://www.day.com/jcr/vault/1.0'>
+<'my'='http://jackrabbit.apache.org/filevault/testing'>
+
+// nt:hierarchyNode is a primary type defining  "jcr:created (date) autocreated protected" and "jcr:createdBy (string) autocreated protected"
+[my:Folder] > nt:hierarchyNode 
+  - * (boolean)
+  - * (string)
+  + * (my:Folder) mandatory
+
+[my:Mixin]
+  mixin
+  - my:protectedProperty (*) protected
+  + my:protectedChildNode protected
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/filter.xml b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/filter.xml
new file mode 100644
index 00000000..d11d3ef0
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/filter.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<workspaceFilter version="1.0">
+    <filter root="/testroot/myfolder/mychild"/>
+</workspaceFilter>
diff --git a/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/properties.xml b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/properties.xml
new file mode 100644
index 00000000..c606e192
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/META-INF/vault/properties.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
+<properties>
+<comment>FileVault Package Properties</comment>
+<entry key="createdBy">admin</entry>
+<entry key="name">import-modes-test</entry>
+<entry key="lastModified">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="lastModifiedBy">admin</entry>
+<entry key="created">2011-11-15T09:45:14.685+01:00</entry>
+<entry key="buildCount">1</entry>
+<entry key="version"/>
+<entry key="dependencies"/>
+<entry key="packageFormatVersion">2</entry>
+<entry key="description"/>
+<entry key="lastWrapped">2011-11-15T09:45:14.664+01:00</entry>
+<entry key="group"/>
+<entry key="lastWrappedBy">admin</entry>
+</properties>
diff --git a/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/.content.xml b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/.content.xml
new file mode 100644
index 00000000..e546f292
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/.content.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal"
+    jcr:mixinTypes="[rep:AccessControllable]"
+    jcr:primaryType="rep:root"
+    sling:resourceType="sling:redirect"
+    sling:target="/index.html">
+    <rep:policy/>
+    <jcr:system/>
+    <var/>
+    <libs/>
+    <etc/>
+    <apps/>
+    <content/>
+    <tmp/>
+    <home/>
+    <testroot/>
+</jcr:root>
\ No newline at end of file
diff --git a/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/testroot/myfolder/mychild/.content.xml b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/testroot/myfolder/mychild/.content.xml
new file mode 100644
index 00000000..909ea7a7
--- /dev/null
+++ b/vault-core/src/test/resources/test-packages/intermediate_folders.zip/jcr_root/testroot/myfolder/mychild/.content.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:rep="internal" xmlns:my="http://jackrabbit.apache.org/filevault/testing"
+    jcr:primaryType="nt:folder">
+</jcr:root>
