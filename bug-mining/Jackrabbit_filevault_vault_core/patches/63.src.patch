diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/AbstractSAXFormatter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/AbstractSAXFormatter.java
deleted file mode 100644
index c0ce707e..00000000
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/AbstractSAXFormatter.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jackrabbit.vault.fs.impl.io;
-
-import javax.jcr.NamespaceException;
-import javax.jcr.Node;
-import javax.jcr.RepositoryException;
-import javax.jcr.Session;
-
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver;
-import org.apache.jackrabbit.spi.commons.namespace.SessionNamespaceResolver;
-import org.apache.jackrabbit.vault.fs.api.Aggregate;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.SAXException;
-
-/**
- * {@code AbstractSaxFormatter}...
- *
- */
-public abstract class AbstractSAXFormatter implements AggregateWalkListener {
-
-    /**
-     * The XML elements and attributes used in serialization
-     */
-    public static final String NODE_ELEMENT = "node";
-    public static final String PREFIXED_NODE_ELEMENT =
-        Name.NS_SV_PREFIX + ":" + NODE_ELEMENT;
-
-    public static final String PROPERTY_ELEMENT = "property";
-    public static final String PREFIXED_PROPERTY_ELEMENT =
-        Name.NS_SV_PREFIX + ":" + PROPERTY_ELEMENT;
-
-    public static final String VALUE_ELEMENT = "value";
-    public static final String PREFIXED_VALUE_ELEMENT =
-        Name.NS_SV_PREFIX + ":" + VALUE_ELEMENT;
-
-    public static final String NAME_ATTRIBUTE = "name";
-    public static final String PREFIXED_NAME_ATTRIBUTE =
-        Name.NS_SV_PREFIX + ":" + NAME_ATTRIBUTE;
-
-    public static final String TYPE_ATTRIBUTE = "type";
-    public static final String PREFIXED_TYPE_ATTRIBUTE =
-        Name.NS_SV_PREFIX + ":" + TYPE_ATTRIBUTE;
-
-    public static final String CDATA_TYPE = "CDATA";
-    public static final String ENUMERATION_TYPE = "ENUMERATION";
-
-    /**
-     * indicates if binaries are to be excluded from the serialization
-     */
-    protected boolean skipBinary = true;
-
-    /**
-     * the session to be used for resolving namespace mappings
-     */
-    protected final Session session;
-
-    /**
-     * the session's namespace resolver
-     */
-    protected final NamespaceResolver nsResolver;
-
-    /**
-     * the content handler to feed the SAX events to
-     */
-    protected final ContentHandler contentHandler;
-
-    /**
-     * The jcr:primaryType property name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrPrimaryType;
-
-    /**
-     * The nt:unstructured name (allowed for session-local prefix mappings)
-     */
-    protected final String ntUnstructured;
-
-    /**
-     * The jcr:mixinTypes property name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrMixinTypes;
-
-    /**
-     * The jcr:uuid property name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrUUID;
-
-    /**
-     * The jcr:root node name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrRoot;
-
-    /**
-     * The jcr:xmltext node name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrXMLText;
-
-    /**
-     * The jcr:xmlCharacters property name (allowed for session-local prefix mappings)
-     */
-    protected final String jcrXMLCharacters;
-
-    /**
-     * the export context
-     */
-    protected final Aggregate aggregate;
-
-    protected AbstractSAXFormatter(Aggregate aggregate, ContentHandler contentHandler)
-            throws RepositoryException {
-
-        this.aggregate = aggregate;
-        this.session = aggregate.getNode().getSession();
-        nsResolver = new SessionNamespaceResolver(session);
-
-        this.contentHandler = contentHandler;
-
-        DefaultNamePathResolver npResolver = new DefaultNamePathResolver(nsResolver);
-
-        // resolve the names of some well known properties
-        // allowing for session-local prefix mappings
-        try {
-            jcrPrimaryType = npResolver.getJCRName(NameConstants.JCR_PRIMARYTYPE);
-            jcrMixinTypes = npResolver.getJCRName(NameConstants.JCR_MIXINTYPES);
-            jcrUUID = npResolver.getJCRName(NameConstants.JCR_UUID);
-            jcrRoot = npResolver.getJCRName(NameConstants.JCR_ROOT);
-            jcrXMLText = npResolver.getJCRName(NameConstants.JCR_XMLTEXT);
-            jcrXMLCharacters = npResolver.getJCRName(NameConstants.JCR_XMLCHARACTERS);
-            ntUnstructured = npResolver.getJCRName(NameConstants.NT_UNSTRUCTURED);
-        } catch (NamespaceException e) {
-            // should never get here...
-            String msg = "internal error: failed to resolve namespace mappings";
-            throw new RepositoryException(msg, e);
-        }
-    }
-
-    public void onWalkBegin(Node root) throws RepositoryException {
-        try {
-            contentHandler.startDocument();
-            startNamespaceDeclarations();
-        } catch (SAXException e) {
-            throw new RepositoryException(e);
-        }
-    }
-
-    public void onWalkEnd(Node root) throws RepositoryException {
-        try {
-            // clear namespace declarations and end document
-            endNamespaceDeclarations();
-            contentHandler.endDocument();
-        } catch (SAXException e) {
-            throw new RepositoryException(e);
-        }
-    }
-
-    /**
-     * Starts namespace declarations
-     *
-     * @throws RepositoryException if a repository error occurs
-     * @throws SAXException if the underlying content handler throws a sax exception
-     */
-    protected void startNamespaceDeclarations()
-            throws RepositoryException, SAXException {
-        // start namespace declarations
-        for (String prefix: aggregate.getNamespacePrefixes()) {
-            if (Name.NS_XML_PREFIX.equals(prefix)) {
-                // skip 'xml' prefix as this would be an illegal namespace declaration
-                continue;
-            }
-            contentHandler.startPrefixMapping(prefix, aggregate.getNamespaceURI(prefix));
-        }
-    }
-
-    /**
-     * Ends namespace declarations
-     *
-     * @throws RepositoryException if a repository error occurs
-     * @throws SAXException if the underlying content handler throws a sax exception
-      */
-    protected void endNamespaceDeclarations()
-            throws RepositoryException, SAXException {
-        // end namespace declarations
-        for (String prefix: aggregate.getNamespacePrefixes()) {
-            if (Name.NS_XML_PREFIX.equals(prefix)) {
-                // skip 'xml' prefix as this would be an illegal namespace declaration
-                continue;
-            }
-            contentHandler.endPrefixMapping(prefix);
-        }
-    }
-}
\ No newline at end of file
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXFormatter.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXFormatter.java
index 106c808c..b1f152dd 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXFormatter.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSAXFormatter.java
@@ -23,19 +23,23 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import javax.jcr.NamespaceException;
 import javax.jcr.Node;
 import javax.jcr.Property;
 import javax.jcr.RepositoryException;
+import javax.jcr.Session;
 
 import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
 import org.apache.jackrabbit.spi.commons.conversion.NameException;
 import org.apache.jackrabbit.spi.commons.conversion.NameParser;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver;
+import org.apache.jackrabbit.spi.commons.namespace.SessionNamespaceResolver;
 import org.apache.jackrabbit.util.ISO9075;
 import org.apache.jackrabbit.vault.fs.api.Aggregate;
 import org.apache.jackrabbit.vault.fs.api.VaultFsConfig;
-import org.apache.jackrabbit.vault.fs.impl.AggregateManagerImpl;
 import org.apache.jackrabbit.vault.util.DocViewProperty;
 import org.apache.jackrabbit.vault.util.ItemNameComparator;
 import org.apache.jackrabbit.vault.util.JcrConstants;
@@ -45,29 +49,137 @@ import org.xml.sax.SAXException;
 import org.xml.sax.helpers.AttributesImpl;
 
 /**
- * {@code DocViewSAXFormatter}...
- *
+ * The docview sax formatter generates SAX events to a given ContentHandler based on the aggregate tree.
  */
-public class DocViewSAXFormatter extends AbstractSAXFormatter {
+public class DocViewSAXFormatter implements AggregateWalkListener {
 
+    /**
+     * The XML elements and attributes used in serialization
+     */
     public static final String CDATA_TYPE = "CDATA";
 
+    /**
+     * the session to be used for resolving namespace mappings
+     */
+    protected final Session session;
+
+    /**
+     * the session's namespace resolver
+     */
+    protected final NamespaceResolver nsResolver;
+
+    /**
+     * the content handler to feed the SAX events to
+     */
+    protected final ContentHandler contentHandler;
+
+    /**
+     * The jcr:primaryType property name (allowed for session-local prefix mappings)
+     */
+    protected final String jcrPrimaryType;
+
+    /**
+     * The nt:unstructured name (allowed for session-local prefix mappings)
+     */
+    protected final String ntUnstructured;
+
+    /**
+     * The jcr:mixinTypes property name (allowed for session-local prefix mappings)
+     */
+    protected final String jcrMixinTypes;
+
+    /**
+     * The jcr:uuid property name (allowed for session-local prefix mappings)
+     */
+    protected final String jcrUUID;
+
+    /**
+     * The jcr:root node name (allowed for session-local prefix mappings)
+     */
+    protected final String jcrRoot;
+
     // used to temporarily store properties of a node
     private final List<Property> props = new ArrayList<Property>();
 
-    private boolean useJcrRoot;
+    /**
+     * the export context
+     */
+    private final Aggregate aggregate;
 
-    private boolean useBinaryReferences;
+    /**
+     * flag indicating if binary references are to be used.
+     */
+    private final boolean useBinaryReferences;
 
-    private Set<String> ignored = new HashSet<String>();
+    /**
+     * internally ignored properties
+     */
+    private final Set<String> ignored = new HashSet<String>();
 
-    public DocViewSAXFormatter(Aggregate aggregate, ContentHandler contentHandler)
+    protected DocViewSAXFormatter(Aggregate aggregate, ContentHandler contentHandler)
             throws RepositoryException {
-        super(aggregate, contentHandler);
+
+        this.aggregate = aggregate;
+        this.session = aggregate.getNode().getSession();
+        nsResolver = new SessionNamespaceResolver(session);
+
+        this.contentHandler = contentHandler;
+
+        DefaultNamePathResolver npResolver = new DefaultNamePathResolver(nsResolver);
+
+        // resolve the names of some well known properties
+        // allowing for session-local prefix mappings
+        try {
+            jcrPrimaryType = npResolver.getJCRName(NameConstants.JCR_PRIMARYTYPE);
+            jcrMixinTypes = npResolver.getJCRName(NameConstants.JCR_MIXINTYPES);
+            jcrUUID = npResolver.getJCRName(NameConstants.JCR_UUID);
+            jcrRoot = npResolver.getJCRName(NameConstants.JCR_ROOT);
+            ntUnstructured = npResolver.getJCRName(NameConstants.NT_UNSTRUCTURED);
+        } catch (NamespaceException e) {
+            // should never get here...
+            String msg = "internal error: failed to resolve namespace mappings";
+            throw new RepositoryException(msg, e);
+        }
 
         useBinaryReferences = "true".equals(aggregate.getManager().getConfig().getProperty(VaultFsConfig.NAME_USE_BINARY_REFERENCES));
     }
 
+    /**
+     * Starts namespace declarations
+     *
+     * @throws RepositoryException if a repository error occurs
+     * @throws SAXException if the underlying content handler throws a sax exception
+     */
+    protected void startNamespaceDeclarations()
+            throws RepositoryException, SAXException {
+        // start namespace declarations
+        for (String prefix: aggregate.getNamespacePrefixes()) {
+            if (Name.NS_XML_PREFIX.equals(prefix)) {
+                // skip 'xml' prefix as this would be an illegal namespace declaration
+                continue;
+            }
+            contentHandler.startPrefixMapping(prefix, aggregate.getNamespaceURI(prefix));
+        }
+    }
+
+    /**
+     * Ends namespace declarations
+     *
+     * @throws RepositoryException if a repository error occurs
+     * @throws SAXException if the underlying content handler throws a sax exception
+      */
+    protected void endNamespaceDeclarations()
+            throws RepositoryException, SAXException {
+        // end namespace declarations
+        for (String prefix: aggregate.getNamespacePrefixes()) {
+            if (Name.NS_XML_PREFIX.equals(prefix)) {
+                // skip 'xml' prefix as this would be an illegal namespace declaration
+                continue;
+            }
+            contentHandler.endPrefixMapping(prefix);
+        }
+    }
+
     private Name getQName(String rawName) throws RepositoryException {
         try {
             return NameParser.parse(rawName, nsResolver, NameFactoryImpl.getInstance());
@@ -78,21 +190,11 @@ public class DocViewSAXFormatter extends AbstractSAXFormatter {
         }
     }
 
-    /**
-     * Controls if the jcr:root should be used as root element name.
-     * @param useJcrRoot {@code true} if jcrRoot is to be used as
-     * root element name.
-     */
-    public void setUseJcrRoot(boolean useJcrRoot) {
-        this.useJcrRoot = useJcrRoot;
-    }
-
     /**
      * {@inheritDoc}
      */
+    @Override
     public void onWalkBegin(Node root) throws RepositoryException {
-        super.onWalkBegin(root);
-
         // init ignored protected properties
         ignored.clear();
         ignored.add(JcrConstants.JCR_CREATED);
@@ -100,85 +202,83 @@ public class DocViewSAXFormatter extends AbstractSAXFormatter {
         ignored.add(JcrConstants.JCR_BASEVERSION);
         ignored.add(JcrConstants.JCR_VERSIONHISTORY);
         ignored.add(JcrConstants.JCR_PREDECESSORS);
+
+        try {
+            contentHandler.startDocument();
+            startNamespaceDeclarations();
+        } catch (SAXException e) {
+            throw new RepositoryException(e);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onWalkEnd(Node root) throws RepositoryException {
+        try {
+            // clear namespace declarations and end document
+            endNamespaceDeclarations();
+            contentHandler.endDocument();
+        } catch (SAXException e) {
+            throw new RepositoryException(e);
+        }
     }
 
     /**
      * {@inheritDoc}
      */
+    @Override
     public void onNodeBegin(Node node, boolean included, int level)
             throws RepositoryException{
         // register used node types
-        ((AggregateManagerImpl) aggregate.getManager()).addNodeTypes(node);
+        aggregate.getManager().addNodeTypes(node);
         props.clear();
     }
 
     /**
      * {@inheritDoc}
      */
+    @Override
     public void onChildren(Node node, int level) throws RepositoryException {
-        String name = node.getName();
         String label = Text.getName(node.getPath());
-        if (name.equals(jcrXMLText)) {
-            // the node represents xml character data
-            for (Property prop : props) {
-                String propName = prop.getName();
-                if (propName.equals(jcrXMLCharacters)) {
-                    // assume jcr:xmlcharacters is single-valued
-                    char[] chars = prop.getValue().getString().toCharArray();
-                    try {
-                        contentHandler.characters(chars, 0, chars.length);
-                    } catch (SAXException e) {
-                        throw new RepositoryException(e);
-                    }
-                }
-            }
+        String elemName;
+        if (level == 0 || node.getDepth() == 0) {
+            // root node needs a name
+            elemName = jcrRoot;
         } else {
-            // regular node
-            // element name
-            String elemName;
-            if ((level == 0 && useJcrRoot) || node.getDepth() == 0) {
-                // root node needs a name
-                elemName = jcrRoot;
-            } else {
-                // encode node name to make sure it's a valid xml name
-                elemName = ISO9075.encode(label);
-            }
+            // encode node name to make sure it's a valid xml name
+            elemName = ISO9075.encode(label);
+        }
 
-            // attributes (properties)
-            AttributesImpl attrs = new AttributesImpl();
-            Collections.sort(props, ItemNameComparator.INSTANCE);
-            for (Property prop: props) {
-                // attribute name (encode property name to make sure it's a valid xml name)
-                String attrName = ISO9075.encode(prop.getName());
-                Name qName = getQName(attrName);
-                boolean sort = qName.equals(NameConstants.JCR_MIXINTYPES);
-                attrs.addAttribute(qName.getNamespaceURI(), qName.getLocalName(),
-                        attrName, CDATA_TYPE, DocViewProperty.format(prop, sort, useBinaryReferences));
-            }
+        // attributes (properties)
+        AttributesImpl attrs = new AttributesImpl();
+        Collections.sort(props, ItemNameComparator.INSTANCE);
+        for (Property prop: props) {
+            // attribute name (encode property name to make sure it's a valid xml name)
+            String attrName = ISO9075.encode(prop.getName());
+            Name qName = getQName(attrName);
+            boolean sort = qName.equals(NameConstants.JCR_MIXINTYPES);
+            attrs.addAttribute(qName.getNamespaceURI(), qName.getLocalName(),
+                    attrName, CDATA_TYPE, DocViewProperty.format(prop, sort, useBinaryReferences));
+        }
 
-            // start element (node)
-            Name qName = getQName(elemName);
-            try {
-                contentHandler.startElement(qName.getNamespaceURI(),
+        // start element (node)
+        Name qName = getQName(elemName);
+        try {
+            contentHandler.startElement(qName.getNamespaceURI(),
                     qName.getLocalName(), elemName, attrs);
-            } catch (SAXException e) {
-                throw new RepositoryException(e);
-            }
+        } catch (SAXException e) {
+            throw new RepositoryException(e);
         }
     }
 
     /**
      * {@inheritDoc}
      */
+    @Override
     public void onNodeEnd(Node node, boolean included, int level) throws RepositoryException {
-        String name = node.getName();
         String label = Text.getName(node.getPath());
-        if (name.equals(jcrXMLText)) {
-            // the node represents xml character data
-            // (already processed in leavingProperties(NodeImpl, int)
-            return;
-        }
-        // element name
         String elemName;
         if (node.getDepth() == 0) {
             // root node needs a name
@@ -191,8 +291,7 @@ public class DocViewSAXFormatter extends AbstractSAXFormatter {
         // end element (node)
         Name qName = getQName(elemName);
         try {
-            contentHandler.endElement(qName.getNamespaceURI(), qName.getLocalName(),
-                    elemName);
+            contentHandler.endElement(qName.getNamespaceURI(), qName.getLocalName(), elemName);
         } catch (SAXException e) {
             throw new RepositoryException(e);
         }
@@ -201,8 +300,8 @@ public class DocViewSAXFormatter extends AbstractSAXFormatter {
     /**
      * {@inheritDoc}
      */
-    public void onProperty(Property prop, int level)
-            throws RepositoryException {
+    @Override
+    public void onProperty(Property prop, int level) throws RepositoryException {
         if (ignored.contains(prop.getName()) && prop.getDefinition().isProtected()) {
             return;
         }
@@ -213,16 +312,15 @@ public class DocViewSAXFormatter extends AbstractSAXFormatter {
     /**
      * {@inheritDoc}
      */
+    @Override
     public void onNodeIgnored(Node node, int depth) throws RepositoryException {
         // just add an empty node. used for ordering
         String label = Text.getName(node.getPath());
         String elemName = ISO9075.encode(label);
         Name qName = getQName(elemName);
         try {
-            contentHandler.startElement(qName.getNamespaceURI(),
-                qName.getLocalName(), elemName, null);
-            contentHandler.endElement(qName.getNamespaceURI(), qName.getLocalName(),
-                    elemName);
+            contentHandler.startElement(qName.getNamespaceURI(), qName.getLocalName(), elemName, null);
+            contentHandler.endElement(qName.getNamespaceURI(), qName.getLocalName(), elemName);
         } catch (SAXException e) {
             throw new RepositoryException(e);
         }
diff --git a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSerializer.java b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSerializer.java
index 5b1e2569..989a1eca 100644
--- a/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSerializer.java
+++ b/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/DocViewSerializer.java
@@ -59,7 +59,6 @@ public class DocViewSerializer implements Serializer {
         oFmt.setBreakEachAttribute(true);
         XMLSerializer ser = new XMLSerializer(out, oFmt);
         DocViewSAXFormatter fmt = new DocViewSAXFormatter(aggregate, ser);
-        fmt.setUseJcrRoot(true);
         aggregate.walk(fmt);
     }
 
diff --git a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestSerialization.java b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestSerialization.java
index b611cdca..06c41d40 100644
--- a/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestSerialization.java
+++ b/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestSerialization.java
@@ -27,10 +27,12 @@ import javax.jcr.nodetype.NodeType;
 
 import org.apache.commons.io.IOUtils;
 import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
+import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.fs.config.DefaultMetaInf;
 import org.apache.jackrabbit.vault.fs.config.DefaultWorkspaceFilter;
 import org.apache.jackrabbit.vault.fs.io.Archive;
 import org.apache.jackrabbit.vault.packaging.ExportOptions;
+import org.apache.jackrabbit.vault.packaging.JcrPackage;
 import org.apache.jackrabbit.vault.packaging.PackageException;
 import org.apache.jackrabbit.vault.packaging.VaultPackage;
 import org.junit.Ignore;
@@ -38,6 +40,7 @@ import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 /**
  * {@code TestEmptyPackage}...
@@ -45,7 +48,6 @@ import static org.junit.Assert.assertNotNull;
 public class TestSerialization extends IntegrationTestBase {
 
     @Test
-    @Ignore("JCRVLT-147")
     public void exportJcrXmlTest() throws RepositoryException, IOException, PackageException {
         Node testRoot = admin.getRootNode().addNode("testroot", NodeType.NT_UNSTRUCTURED);
         Node nodeA = testRoot.addNode("a", NodeType.NT_UNSTRUCTURED);
@@ -76,11 +78,11 @@ public class TestSerialization extends IntegrationTestBase {
                         "<jcr:root xmlns:jcr=\"http://www.jcp.org/jcr/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\"\n" +
                         "    jcr:primaryType=\"nt:unstructured\">\n" +
                         "    <a jcr:primaryType=\"nt:unstructured\">\n" +
-                        "        <jcr:xmltext \n" +
+                        "        <jcr:xmltext\n" +
                         "            jcr:primaryType=\"nt:unstructured\"\n" +
-                        "            jcr:xmlcharacters=\"Hello, World.\" />\n" +
+                        "            jcr:xmlcharacters=\"Hello, World.\"/>\n" +
                         "    </a>\n" +
-                "</jcr:root>";
+                        "</jcr:root>\n";
         assertEquals("content.xml must be correct", expected, src);
         pkg.close();
         tmpFile.delete();
