diff --git a/mqtt-ds/src/main/java/org/apache/rocketmq/mqtt/ds/upstream/processor/ConnectProcessor.java b/mqtt-ds/src/main/java/org/apache/rocketmq/mqtt/ds/upstream/processor/ConnectProcessor.java
index cc93863..dfb1f1a 100644
--- a/mqtt-ds/src/main/java/org/apache/rocketmq/mqtt/ds/upstream/processor/ConnectProcessor.java
+++ b/mqtt-ds/src/main/java/org/apache/rocketmq/mqtt/ds/upstream/processor/ConnectProcessor.java
@@ -20,21 +20,13 @@ package org.apache.rocketmq.mqtt.ds.upstream.processor;
 import io.netty.handler.codec.mqtt.MqttMessage;
 import org.apache.rocketmq.mqtt.common.hook.HookResult;
 import org.apache.rocketmq.mqtt.common.model.MqttMessageUpContext;
-import org.apache.rocketmq.mqtt.ds.config.ServiceConf;
 import org.apache.rocketmq.mqtt.ds.upstream.UpstreamProcessor;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Component;
 
-import javax.annotation.Resource;
 import java.util.concurrent.CompletableFuture;
 
 @Component
 public class ConnectProcessor extends BaseProcessor implements UpstreamProcessor {
-    private static Logger logger = LoggerFactory.getLogger(ConnectProcessor.class);
-
-    @Resource
-    private ServiceConf serviceConf;
 
     @Override
     public CompletableFuture<HookResult> process(MqttMessageUpContext context, MqttMessage message) {
diff --git a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/TestUpstreamProcessorManager.java b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/TestUpstreamProcessorManager.java
new file mode 100644
index 0000000..a6ade2a
--- /dev/null
+++ b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/TestUpstreamProcessorManager.java
@@ -0,0 +1,92 @@
+/*
+ *
+ *  * Licensed to the Apache Software Foundation (ASF) under one or more
+ *  * contributor license agreements.  See the NOTICE file distributed with
+ *  * this work for additional information regarding copyright ownership.
+ *  * The ASF licenses this file to You under the Apache License, Version 2.0
+ *  * (the "License"); you may not use this file except in compliance with
+ *  * the License.  You may obtain a copy of the License at
+ *  *
+ *  *     http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  * Unless required by applicable law or agreed to in writing, software
+ *  * distributed under the License is distributed on an "AS IS" BASIS,
+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  * See the License for the specific language governing permissions and
+ *  * limitations under the License.
+ *
+ */
+
+package org.apache.rocketmq.mqtt.ds.test.upstream;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.mqtt.MqttFixedHeader;
+import io.netty.handler.codec.mqtt.MqttMessageType;
+import io.netty.handler.codec.mqtt.MqttPublishMessage;
+import io.netty.handler.codec.mqtt.MqttPublishVariableHeader;
+import io.netty.handler.codec.mqtt.MqttQoS;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.hook.HookResult;
+import org.apache.rocketmq.mqtt.common.model.MqttMessageUpContext;
+import org.apache.rocketmq.mqtt.ds.upstream.UpstreamProcessorManager;
+import org.apache.rocketmq.mqtt.ds.upstream.processor.PublishProcessor;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestUpstreamProcessorManager {
+
+    @Mock
+    private PublishProcessor publishProcessor;
+
+    private UpstreamProcessorManager processorManager;
+    private MqttMessageUpContext upContext;
+    private MqttPublishVariableHeader variableHeader;
+    private ByteBuf payload;
+
+    @Before
+    public void SetUp() throws IllegalAccessException {
+        processorManager = new UpstreamProcessorManager();
+        FieldUtils.writeDeclaredField(processorManager, "publishProcessor", publishProcessor, true);
+
+        upContext = new MqttMessageUpContext();
+        variableHeader = new MqttPublishVariableHeader("test", 0);
+        payload = Unpooled.copiedBuffer("test".getBytes(StandardCharsets.UTF_8));
+    }
+
+    @Test
+    public void test() {
+        MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, false, MqttQoS.AT_LEAST_ONCE, false, 1);
+        MqttPublishMessage publishMessage = new MqttPublishMessage(mqttFixedHeader, variableHeader, payload);
+
+        processorManager.processMqttMessage(upContext, publishMessage);
+
+        verify(publishProcessor).process(eq(upContext), eq(publishMessage));
+    }
+
+    @Test
+    public void testDefaultCase() throws ExecutionException, InterruptedException {
+        MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PINGREQ, false, MqttQoS.AT_LEAST_ONCE, false, 1);
+        MqttPublishMessage publishMessage = new MqttPublishMessage(mqttFixedHeader, variableHeader, payload);
+
+        CompletableFuture<HookResult> hookResult = processorManager.processMqttMessage(upContext, publishMessage);
+
+        verify(publishProcessor, times(0)).process(any(), any());
+        Assert.assertEquals(HookResult.FAIL, hookResult.get().getCode());
+    }
+
+}
diff --git a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestPublishProcessor.java b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestPublishProcessor.java
new file mode 100644
index 0000000..aea33e7
--- /dev/null
+++ b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestPublishProcessor.java
@@ -0,0 +1,96 @@
+/*
+ *
+ *  * Licensed to the Apache Software Foundation (ASF) under one or more
+ *  * contributor license agreements.  See the NOTICE file distributed with
+ *  * this work for additional information regarding copyright ownership.
+ *  * The ASF licenses this file to You under the Apache License, Version 2.0
+ *  * (the "License"); you may not use this file except in compliance with
+ *  * the License.  You may obtain a copy of the License at
+ *  *
+ *  *     http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  * Unless required by applicable law or agreed to in writing, software
+ *  * distributed under the License is distributed on an "AS IS" BASIS,
+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  * See the License for the specific language governing permissions and
+ *  * limitations under the License.
+ *
+ */
+
+package org.apache.rocketmq.mqtt.ds.test.upstream.processor;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.mqtt.MqttFixedHeader;
+import io.netty.handler.codec.mqtt.MqttMessageType;
+import io.netty.handler.codec.mqtt.MqttPublishMessage;
+import io.netty.handler.codec.mqtt.MqttPublishVariableHeader;
+import io.netty.handler.codec.mqtt.MqttQoS;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.rocketmq.mqtt.common.facade.LmqQueueStore;
+import org.apache.rocketmq.mqtt.common.hook.HookResult;
+import org.apache.rocketmq.mqtt.common.model.MqttMessageUpContext;
+import org.apache.rocketmq.mqtt.common.model.StoreResult;
+import org.apache.rocketmq.mqtt.ds.meta.FirstTopicManager;
+import org.apache.rocketmq.mqtt.ds.meta.WildcardManager;
+import org.apache.rocketmq.mqtt.ds.upstream.processor.PublishProcessor;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anySet;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(MockitoJUnitRunner.class)
+public class TestPublishProcessor {
+
+    @Mock
+    private LmqQueueStore lmqQueueStore;
+
+    @Mock
+    private WildcardManager wildcardManager;
+
+    @Mock
+    private FirstTopicManager firstTopicManager;
+
+    @Test
+    public void test() throws IllegalAccessException, ExecutionException, InterruptedException {
+        PublishProcessor publishProcessor = new PublishProcessor();
+        FieldUtils.writeDeclaredField(publishProcessor, "lmqQueueStore", lmqQueueStore, true);
+        FieldUtils.writeDeclaredField(publishProcessor, "wildcardManager", wildcardManager, true);
+        FieldUtils.writeDeclaredField(publishProcessor, "firstTopicManager", firstTopicManager, true);
+
+        MqttMessageUpContext upContext = new MqttMessageUpContext();
+        upContext.setNamespace("testPubProcessor");
+
+        MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, false, MqttQoS.AT_LEAST_ONCE, false, 1);
+        MqttPublishVariableHeader variableHeader = new MqttPublishVariableHeader("test", 0);
+        ByteBuf payload = Unpooled.copiedBuffer("test".getBytes(StandardCharsets.UTF_8));
+        MqttPublishMessage publishMessage = new MqttPublishMessage(mqttFixedHeader, variableHeader, payload);
+
+        Set<String> queues = Collections.singleton("testQueue");
+        when(wildcardManager.matchQueueSetByMsgTopic(anyString(), anyString())).thenReturn(queues);
+        CompletableFuture<StoreResult> storeResultFuture = new CompletableFuture<>();
+        StoreResult storeResult = new StoreResult();
+        storeResultFuture.complete(storeResult);
+        when(lmqQueueStore.putMessage(anySet(), any())).thenReturn(storeResultFuture);
+
+        CompletableFuture<HookResult> hookResultCompletableFuture = publishProcessor.process(upContext, publishMessage);
+
+        verify(firstTopicManager).checkFirstTopicIfCreated(anyString());
+        Assert.assertNull(hookResultCompletableFuture.get().getRemark());
+        Assert.assertNotNull(hookResultCompletableFuture.get().getData());
+    }
+
+}
diff --git a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestSubscribeProcessor.java b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestSubscribeProcessor.java
similarity index 98%
rename from mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestSubscribeProcessor.java
rename to mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestSubscribeProcessor.java
index 11fc358..d57a408 100644
--- a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestSubscribeProcessor.java
+++ b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestSubscribeProcessor.java
@@ -17,7 +17,7 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.ds.test;
+package org.apache.rocketmq.mqtt.ds.test.upstream.processor;
 
 import io.netty.handler.codec.mqtt.MqttFixedHeader;
 import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
diff --git a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestUnSubscribeProcessor.java b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestUnSubscribeProcessor.java
similarity index 89%
rename from mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestUnSubscribeProcessor.java
rename to mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestUnSubscribeProcessor.java
index 3c1c3af..efd47cc 100644
--- a/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/TestUnSubscribeProcessor.java
+++ b/mqtt-ds/src/test/java/org/apache/rocketmq/mqtt/ds/test/upstream/processor/TestUnSubscribeProcessor.java
@@ -17,22 +17,18 @@
  *
  */
 
-package org.apache.rocketmq.mqtt.ds.test;
+package org.apache.rocketmq.mqtt.ds.test.upstream.processor;
 
 import io.netty.handler.codec.mqtt.MqttFixedHeader;
 import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
 import io.netty.handler.codec.mqtt.MqttMessageType;
 import io.netty.handler.codec.mqtt.MqttQoS;
-import io.netty.handler.codec.mqtt.MqttSubscribeMessage;
-import io.netty.handler.codec.mqtt.MqttSubscribePayload;
-import io.netty.handler.codec.mqtt.MqttTopicSubscription;
 import io.netty.handler.codec.mqtt.MqttUnsubscribeMessage;
 import io.netty.handler.codec.mqtt.MqttUnsubscribePayload;
 import org.apache.commons.lang3.reflect.FieldUtils;
 import org.apache.rocketmq.mqtt.common.facade.SubscriptionPersistManager;
 import org.apache.rocketmq.mqtt.common.model.MqttMessageUpContext;
 import org.apache.rocketmq.mqtt.ds.meta.FirstTopicManager;
-import org.apache.rocketmq.mqtt.ds.upstream.processor.SubscribeProcessor;
 import org.apache.rocketmq.mqtt.ds.upstream.processor.UnSubscribeProcessor;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -63,7 +59,7 @@ public class TestUnSubscribeProcessor {
         MqttMessageUpContext context = new MqttMessageUpContext();
         context.setClientId("test");
 
-        MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.SUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 1);
+        MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 1);
         MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(1);
         MqttUnsubscribePayload payload = new MqttUnsubscribePayload(Arrays.asList("test"));
         MqttUnsubscribeMessage mqttUnsubscribeMessage = new MqttUnsubscribeMessage(mqttFixedHeader, variableHeader, payload);
