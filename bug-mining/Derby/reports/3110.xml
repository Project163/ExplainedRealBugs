<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 14:50:10 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[DERBY-6786] NullPointerException in INSERT INTO statement with multiple subselects</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6786</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Hello,&lt;br/&gt;
I&apos;m getting this wrapped NullPointerException when I try to execute an INSERT INTO SQL statement:&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:101)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:148)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.seeNextException(Util.java:349)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:431)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:353)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2400)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:85)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1437)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:711)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeLargeUpdate(EmbedStatement.java:190)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeUpdate(EmbedStatement.java:179)&lt;br/&gt;
	at de.foconis.dakobp.unittests.div.TestMain.testNullpointer(TestMain.java:49)&lt;br/&gt;
	at de.foconis.dakobp.unittests.div.TestMain.main(TestMain.java:28)&lt;br/&gt;
Caused by: java.sql.SQLException: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:42)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:125)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:71)&lt;br/&gt;
	... 12 more&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:42)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:125)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:71)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:148)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:370)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:436)&lt;br/&gt;
	... 10 more&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.exe.acf81e0010x014axa9c2x46e6x000000c6dc781.e2(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:105)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:275)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:263)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:519)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:461)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:340)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1344)&lt;br/&gt;
	... 5 more&lt;/p&gt;

&lt;p&gt;Most likely this bug has already been reported as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5041&quot; title=&quot;NullPointerException in generated code in query with group by&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5041&quot;&gt;&lt;del&gt;DERBY-5041&lt;/del&gt;&lt;/a&gt;, which has already been closed (although I don&apos;t use a GROUP BY clause).&lt;/p&gt;

&lt;p&gt;The original statement is quite complex and partially generated, but the error can be reproduced easily, using a statement as simple as this:&lt;br/&gt;
insert into t&lt;br/&gt;
 select erg.* from (&lt;br/&gt;
  select d1.s from (select k,s from k1) as d1&lt;br/&gt;
   right join (select k,s from k2) as d2 on d1.k = d2.k&lt;br/&gt;
  ) as erg&lt;br/&gt;
 where s &amp;gt; 10&lt;/p&gt;

&lt;p&gt;I will attach the file &quot;repro.sql&quot;, containing all SQL statements required to reproduce it (including the CREATE TABLEs).&lt;/p&gt;

&lt;p&gt;These are my investigation results:&lt;/p&gt;

&lt;p&gt;Conditions&lt;br/&gt;
-------------&lt;br/&gt;
1. the outermost statement must NOT be a SELECT (e. g. INSERT)&lt;br/&gt;
2. there has to be a outer join in the subselect, where at least one dataset has no join partner&lt;br/&gt;
3. an outer SELECT must have a restriction (WHERE clause) and access a column from the table, that did not have a join partner&lt;/p&gt;

&lt;p&gt;Error state&lt;br/&gt;
-------------&lt;br/&gt;
The NullPointer occurs inside a generated class. So i enabled the Debug Option &quot;DumpClassFile&quot;, to get the generated class file (the decompiled java class file will also be appended).&lt;br/&gt;
The method &quot;e2&quot;, stated in the StackTrace, performs the restrction &quot;where s &amp;gt; 10&quot;. Therefore it calls getColumnFromRow() with its resultSetNumber.&lt;/p&gt;

&lt;p&gt;This is where the error occurs: there is no &quot;current row&quot; available. Precisely, the &quot;row&quot; property of the activation class at the specified index (which is the resultSetNumber=3 in this example) is not set.&lt;br/&gt;
It gets a bit complicated now, I will try to explain it, starting with the generated resultset hierarchy.&lt;/p&gt;

&lt;p&gt;This tree of resultset implementations is generated to perform the query:&lt;/p&gt;

&lt;p&gt;Implementation				resultSetNumber&lt;br/&gt;
-------------------				---------------------&lt;br/&gt;
InsertResultSet			-&amp;gt; none&lt;br/&gt;
 ProjectRestrictResultSet		-&amp;gt; 5&lt;br/&gt;
  ProjectRestrictResultSet	-&amp;gt; 4&lt;br/&gt;
   HashLeftOuterJoinResultSet	-&amp;gt; 0&lt;br/&gt;
    TableScanResultSet		-&amp;gt; 1&lt;br/&gt;
    HashTableResultSet		-&amp;gt; 3&lt;br/&gt;
     TableScanResultSet		-&amp;gt; 2&lt;/p&gt;

&lt;p&gt;The HashTableResultSet, which got the resultSetNumber 3 doesn&apos;t set a current row, because there is no join partner (still everything correct). But the ProjectRestrictResultSet on position 4 uses the restriction method (&quot;e2&quot;), which accesses a column on resultSetNumber 3 -&amp;gt; error.&lt;/p&gt;

&lt;p&gt;As far as I can tell, a restriction must never relate to the source of an outer join ResultSet. The numeration error does not occur, if the outermost statement is a SELECT and the numeration is generated top-down.&lt;/p&gt;

&lt;p&gt;Unfortunately I couldn&apos;t find an easy solution for this problem. In my case, this is a critical bug, because changing the query as workaround is difficult, since parts of it are generated. Please note, that this error is not dependent on any environment settings or platform and occured with all of the abolve mentioned versions. I didn&apos;t test the versions from 10.6 to 10.7, but probably those are also affected.&lt;/p&gt;

&lt;p&gt;If you require any further information, please let me know. I&apos;m able to perform a build, so I wouldn&apos;t need a full version, a patch would be sufficient.&lt;/p&gt;</description>
                <environment>not relevant, but tested under Windows 7 32bit, Windows Server 2008 64bit, Java 6 and Java 7.</environment>
        <key id="12764513">DERBY-6786</key>
            <summary>NullPointerException in INSERT INTO statement with multiple subselects</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="mac777">Abhinav Gupta</assignee>
                                    <reporter username="jstadler">Johannes Stadler</reporter>
                        <labels>
                            <label>NullPointerException</label>
                    </labels>
                <created>Fri, 2 Jan 2015 12:41:27 +0000</created>
                <updated>Sun, 30 Aug 2015 14:50:57 +0000</updated>
                                            <version>10.2.2.0</version>
                    <version>10.5.1.1</version>
                    <version>10.8.2.2</version>
                    <version>10.9.1.0</version>
                    <version>10.10.1.1</version>
                    <version>10.11.1.1</version>
                                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="14262868" author="jstadler" created="Fri, 2 Jan 2015 12:42:44 +0000"  >&lt;p&gt;Attached steps to reproduce and decompiled generated method.&lt;/p&gt;</comment>
                            <comment id="14264899" author="mamtas" created="Mon, 5 Jan 2015 18:51:24 +0000"  >&lt;p&gt;Thanks for providing the repro. I tried it on top of the trunk and was able to reproduce the behavior you noticed.&lt;/p&gt;</comment>
                            <comment id="14264981" author="mamtas" created="Mon, 5 Jan 2015 19:41:17 +0000"  >&lt;p&gt;I am looking at the code to see if I can understand what the issue might be.&lt;/p&gt;</comment>
                            <comment id="14265822" author="mamtas" created="Tue, 6 Jan 2015 08:15:36 +0000"  >&lt;p&gt;While looking at the issue, I found that the queries from repro sql do not result into NPE if the data in the tables is different.&lt;br/&gt;
create table k1 (k varchar(64), s decimal);&lt;br/&gt;
create table k2 (k varchar(64), s decimal);&lt;br/&gt;
create table t (s decimal);&lt;br/&gt;
insert into k1 values (&apos;110007&apos;, 224);&lt;br/&gt;
insert into k2 values (&apos;110007&apos;, 361);&lt;/p&gt;

&lt;p&gt;Note that both the tables above have same value for column k and thus join will actually result in matching rows.&lt;/p&gt;

&lt;p&gt;Now for all the 4 queries provided in repro case by Johannes will actually find a matching row and for such a data, there is no NPE. &lt;/p&gt;

&lt;p&gt;In the case where no matching row is found(which is the case with the data set provided in the repro case by Johannes), issue might be that Derby is not equipped to handle empty resultset for the 2 queries provided in the repro.&lt;/p&gt;</comment>
                            <comment id="14266050" author="jstadler" created="Tue, 6 Jan 2015 12:49:50 +0000"  >&lt;p&gt;Hi Mamta,&lt;br/&gt;
thanks for your attempt to reproduce the error. Your investigation result is exactly what I was trying to explain. &lt;/p&gt;

&lt;p&gt;But in my opinion, the resultsetNumber, that is specified in the restriction method e2() is wrong. The number 3 corresponds to the right side of the outer join, which eventually can get null.&lt;/p&gt;</comment>
                            <comment id="14266802" author="mamtas" created="Tue, 6 Jan 2015 21:28:35 +0000"  >&lt;p&gt;You are correct Johannes. Just want to share some more information from my debugging which enforces your point.&lt;/p&gt;

&lt;p&gt;First of all, for reference purposes, here are the tables we are dealing with following tables&lt;br/&gt;
create table k1 (k varchar(64), s decimal);&lt;br/&gt;
create table k2 (k varchar(64), s decimal);&lt;br/&gt;
create table t (s decimal);&lt;/p&gt;

&lt;p&gt;And one of the queries that may result in npe (depending on what data is in the tables) is as follows&lt;br/&gt;
insert into t&lt;br/&gt;
 select erg.* from (&lt;br/&gt;
  select d2.s from (select k,s from k1) as d1&lt;br/&gt;
   left join (select k,s from k2) as d2 on d1.k=d2.k&lt;br/&gt;
  ) as erg&lt;br/&gt;
 where s &amp;gt; 10;&lt;/p&gt;

&lt;p&gt;For the query above, we generate various internal Derby resultsets. The issue appears to be what resultset gets associated to column s in predicate where s &amp;gt; 10. It would seem that for this predicate, column s should be associated with the internal resulset created for outermost select which is select erg.*. Instead, it looks like it is getting associated with the 2nd select in the join clause which is (select k,s from k2) as d2&lt;/p&gt;

&lt;p&gt;Lets look at the contents of these two internal resultsets for different data in tables k1 and k2 to understand the NPE better.&lt;br/&gt;
case 1) &lt;br/&gt;
Let&apos;s say the only data into the two tables is&lt;br/&gt;
delete from k1;&lt;br/&gt;
delete from k2;&lt;br/&gt;
insert into k1 values (&apos;110007&apos;, 224);&lt;br/&gt;
insert into k2 values (&apos;110007&apos;, 361);&lt;/p&gt;

&lt;p&gt;For this data, the join above will result into a match because both k1 and k2 have &apos;110007&apos; for column k. The contents of resultset for (select k,s from k2) as d2 is &lt;/p&gt;
{ 110007, 361 }
&lt;p&gt; and the merged row looks like &lt;/p&gt;
{ 110007, 224, 110007, 361 }. Here, even though predicate column s is incorrectly associated with internal resultset for (select k,s from k2) as d2, we will not get a npe because that resultset for the given data is not null(because there was a matching row in table k2.)&lt;br/&gt;
&lt;br/&gt;
Case 2)&lt;br/&gt;
Let&apos;s say the only data into the two tables is&lt;br/&gt;
delete from k1;&lt;br/&gt;
delete from k2;&lt;br/&gt;
insert into k1 values (&apos;110007&apos;, 224);&lt;br/&gt;
insert into k2 values (&apos;110007&apos;, null);&lt;br/&gt;
&lt;br/&gt;
Again, for this data, the join above will result into a match because both k1 and k2 have &apos;110007&apos; for column k. The contents of resultset for (select k,s from k2) as d2 is { 110007, NULL } and the merged row looks like { 110007, 224, 110007, 361 }
&lt;p&gt;. For this case again, we will not get a npe because the resultset associated with (select k,s from k2) as d2 is not null (because there was a matching row in table k2.)&lt;/p&gt;

&lt;p&gt;Case 3)&lt;br/&gt;
This is the case where we run into NPE.&lt;br/&gt;
Let&apos;s say the only data into the two tables is&lt;br/&gt;
delete from k1;&lt;br/&gt;
delete from k2;&lt;br/&gt;
insert into k1 values (&apos;110007&apos;, 224);&lt;br/&gt;
insert into k2 values (&apos;110019&apos;, 361);&lt;/p&gt;

&lt;p&gt;For this data, the join above will not find a matching row in k2. Because of this, the resultset associated with (select k,s from k2) as d2 will be null but the merged row will look like &lt;/p&gt;
{ 110007, 224, NULL, NULL }
&lt;p&gt;. Predicate where s &amp;gt; 10 association with resultset for (select k,s from k2) as d2 I believe is the cause of npe. It seems like we should be looking at the merged row resultset to find predicate s&apos;s value. Doing that will work for all the 3 cases covered here. &lt;/p&gt;

&lt;p&gt;It will appear that to fix the issue, we will need to fix the predicate&apos;s assoication with correct resulset and that will automatically generate the correct run time behavior.&lt;/p&gt;</comment>
                            <comment id="14266901" author="mamtas" created="Tue, 6 Jan 2015 22:43:19 +0000"  >&lt;p&gt;Hopefully the information I shared earlier is useful. I am working on other issues currently and hence will not be able to spend much time on this issue at this time.&lt;/p&gt;</comment>
                            <comment id="14269019" author="foco-mste" created="Thu, 8 Jan 2015 09:07:38 +0000"  >&lt;p&gt;Two additional observations:&lt;/p&gt;

&lt;p&gt;1) The bug seems to be very old: It can be reproduced in Derby 10.1.1 (dating from August 2005).&lt;/p&gt;

&lt;p&gt;2) There is an even simpler statement producing the same kind of NullPointerException&lt;br/&gt;
...&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.exe.acf81e0010x014axc8afx79cbx00000031dbd00.e2(GC.java:29)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:105)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:302)&lt;br/&gt;
...&lt;/p&gt;

&lt;p&gt;namely:&lt;/p&gt;

&lt;p&gt;insert into t&lt;br/&gt;
	select erg.* from (&lt;br/&gt;
		select d2.s from k1&lt;br/&gt;
			left join (select k,s from k2) as d2 on k1.k=d2.k&lt;br/&gt;
		) as erg&lt;br/&gt;
	where s &amp;gt; 10&lt;/p&gt;

&lt;p&gt;thus reducing the complexity of the example given above (which is already extraordinarily simple) by one subselect.&lt;/p&gt;
</comment>
                            <comment id="14277081" author="jira-bot" created="Wed, 14 Jan 2015 15:39:11 +0000"  >&lt;p&gt;Commit 1651707 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mamtas&quot; class=&quot;user-hover&quot; rel=&quot;mamtas&quot;&gt;mamtas&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1651707&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1651707&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6786&quot; title=&quot;NullPointerException in INSERT INTO statement with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6786&quot;&gt;DERBY-6786&lt;/a&gt;(NullPointerException in INSERT INTO statement with multiple subselects)&lt;/p&gt;

&lt;p&gt;Adding test casee for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6786&quot; title=&quot;NullPointerException in INSERT INTO statement with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6786&quot;&gt;DERBY-6786&lt;/a&gt;. One test case(zztestDerby6786InsertIntoSelectCase3) which will result into NPE has been disabled. Once &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6786&quot; title=&quot;NullPointerException in INSERT INTO statement with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6786&quot;&gt;DERBY-6786&lt;/a&gt; is fixed, we should enable that test by removing the zz in front of the test name.&lt;/p&gt;</comment>
                            <comment id="14284548" author="mamtas" created="Tue, 20 Jan 2015 22:30:33 +0000"  >&lt;p&gt;I have been debugging this issue a little bit and what I have found so far in the case with INSERT and in the case with no INSERT is that the case with INSERT goes through additional cycle of binding of the SELECT clause.&lt;br/&gt;
Here are the two cases&lt;br/&gt;
1)With INSERT&lt;br/&gt;
 insert into t&lt;br/&gt;
 select erg.* from (&lt;br/&gt;
 select d2.s from (select k,s from k1) as d1&lt;br/&gt;
 left join (select k,s from k2) as d2 on d1.k=d2.k&lt;br/&gt;
 ) as erg&lt;br/&gt;
 where s &amp;gt; 10;&lt;br/&gt;
2)Without INSERT&lt;br/&gt;
 select erg.* from (&lt;br/&gt;
 select d2.s from (select k,s from k1) as d1&lt;br/&gt;
 left join (select k,s from k2) as d2 on d1.k=d2.k&lt;br/&gt;
 ) as erg&lt;br/&gt;
 where s &amp;gt; 10;&lt;/p&gt;

&lt;p&gt;In both of the cases above, first we go through the bind phase of SELECT erg.*... first. &lt;br/&gt;
1)In case with INSERT, here is the code path for the first round of binding of SELECT erg,*...&lt;br/&gt;
SelectNode.bindExpressions(FromList) line: 549	&lt;br/&gt;
SelectNode.bindExpressionsWithTables(FromList) line: 738	&lt;br/&gt;
InsertNode(DMLStatementNode).bindExpressionsWithTables() line: 232	&lt;br/&gt;
InsertNode(DMLStatementNode).bindResultSetsWithTables(DataDictionary) line: 165	&lt;br/&gt;
InsertNode.bindStatement() line: 246	&lt;br/&gt;
GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 401	&lt;br/&gt;
GenericStatement.prepare(LanguageConnectionContext, boolean) line: 99	&lt;br/&gt;
.....&lt;br/&gt;
2)In case of no INSERT sql, here is the code path for the binding of SELECT erg,*...&lt;br/&gt;
CursorNode.bindStatement() line: 283	&lt;br/&gt;
GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 401	&lt;br/&gt;
GenericStatement.prepare(LanguageConnectionContext, boolean) line: 99	&lt;/p&gt;

&lt;p&gt;At the end of this, the query nodes for the two queries seem to be in sync. But, for the case with INSERT, we go through the bind phase of SELECT erg.* again through the following codepath&lt;br/&gt;
SelectNode.bindExpressions(FromList) line: 523	&lt;br/&gt;
InsertNode(DMLStatementNode).bindExpressions() line: 209	&lt;br/&gt;
InsertNode.bindStatement() line: 338	&lt;br/&gt;
GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 401	&lt;br/&gt;
GenericStatement.prepare(LanguageConnectionContext, boolean) line: 99	&lt;br/&gt;
There is following comment before this second round of binding in InsertNode.bindStatement()&lt;br/&gt;
		/* Bind the expressions now that the result columns are bound &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;NOTE: This will be the 2nd time for those underlying ResultSets&lt;/li&gt;
	&lt;li&gt;that have tables (no harm done), but it is necessary for those&lt;/li&gt;
	&lt;li&gt;that do not have tables.  It&apos;s too hard/not work the effort to&lt;/li&gt;
	&lt;li&gt;avoid the redundancy.&lt;br/&gt;
		 */&lt;br/&gt;
It is in this second phase of rounding, it looks like we bind the columns to incorrect position. More work is needed to pin point where exactly the column mapping is going wrong.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14284998" author="bryanpendleton" created="Wed, 21 Jan 2015 01:54:06 +0000"  >&lt;p&gt;&amp;gt; * NOTE: This will be the 2nd time for those underlying ResultSets&lt;br/&gt;
&amp;gt; * that have tables (no harm done)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; ...&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; It is in this second phase of rounding, it looks like we bind the columns to incorrect position.&lt;/p&gt;

&lt;p&gt;But, the comment says &quot;no harm done&quot;! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Guess we need that Java compiler that can read the comments ...&lt;/p&gt;

&lt;p&gt;Seriously, though, thanks for digging into this; I think that is an excellent theory about the source of the bug.&lt;/p&gt;</comment>
                            <comment id="14287541" author="bryanpendleton" created="Thu, 22 Jan 2015 14:56:48 +0000"  >&lt;p&gt;Sometimes, when I see some ancient code that I think is misbehaving in my case,&lt;br/&gt;
but I&apos;m not sure what other cases it might get used in, I use the following trick:&lt;/p&gt;

&lt;p&gt;I modify that code to contain something like:&lt;/p&gt;

&lt;p&gt;    Exception debugExc(&quot;How did I get here?&quot;).printStackTrace();&lt;/p&gt;

&lt;p&gt;Then I run the test suites, and crawl through my log files at the end of the run,&lt;br/&gt;
looking for stack traces that got left in the log files by this debugging code.&lt;/p&gt;

&lt;p&gt;Not sure if that will offer any insights in this case, thought I&apos;d make the suggestion anyway.&lt;/p&gt;</comment>
                            <comment id="14287557" author="mamtas" created="Thu, 22 Jan 2015 15:10:18 +0000"  >&lt;p&gt;Thanks Bryan for the tip. I normally do System.out.println and then print stack trace but I like your one statement to do both. Thanks again.&lt;/p&gt;</comment>
                            <comment id="14287888" author="jira-bot" created="Thu, 22 Jan 2015 18:13:41 +0000"  >&lt;p&gt;Commit 1653986 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mamtas&quot; class=&quot;user-hover&quot; rel=&quot;mamtas&quot;&gt;mamtas&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1653986&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1653986&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6788&quot; title=&quot;Wrong value inserted by INSERT INTO with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6788&quot;&gt;DERBY-6788&lt;/a&gt;(Wrong value inserted by INSERT INTO with multiple subselects)&lt;/p&gt;

&lt;p&gt;Adding a junit test case for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6788&quot; title=&quot;Wrong value inserted by INSERT INTO with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6788&quot;&gt;DERBY-6788&lt;/a&gt;. This bug might be related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6786&quot; title=&quot;NullPointerException in INSERT INTO statement with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6786&quot;&gt;DERBY-6786&lt;/a&gt;(NullPointerException in INSERT INTO statement with  multiple subselects)&lt;/p&gt;</comment>
                            <comment id="14294886" author="mamtas" created="Wed, 28 Jan 2015 08:47:55 +0000"  >&lt;p&gt;I have done more debugging and found that the code in JoinNode:buildRCL() is what is causing for us to run into NPE. &lt;/p&gt;

&lt;p&gt;The code here checks if we already have built a ResultColumnList. If yes, then we leave the routine with no other work.&lt;br/&gt;
		/* NOTE - we only need to build this list if it does not already &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;exist.  This can happen in the degenerate case of an insert&lt;/li&gt;
	&lt;li&gt;select with a join expression in a derived table within the select.&lt;br/&gt;
		 */&lt;br/&gt;
		if (getResultColumns() != null)
		{
			return;
		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If the ResultColumnList for JoinNode is not built yet, we go through the LeftResultSet&apos;s result column list and make a copy of it, build virtual nodes on top of them and then we do the same with RightResultSet&apos;s result column list and then we append thecopy of the right resultcolumns to the copy of the left result columns and use it as JoinNode&apos;s result column list. &lt;/p&gt;

&lt;p&gt;In case of our INSERT case, as described earlier in this jira, we go through two cycles of binds. Once for the SELECT inside the INSERT statement and then for the bind of INSERT statement itself(which causes the SELECT to rebind itself). In the first iteration of bind of the SELECT, the JoinNode.buildRCL will find the resultcolumn list to be null and hence we build a result column list using left resultset and right resultset. The second time when we come again for the bind of the SELECT, we find that the result column list already exist and hence we just return from this method. But I believe what is happening is that the resultset list built in the first cycle ends up having virtual nodes created on top of it and that causes it to loose its column id. I removed the if condition from JoinNode.buildRCL and we do not run into NPE with the test cases provided here. I am going to enable the junit test case zztestDerby6786InsertIntoSelectCase3 and see if it runs successfully. I will also run the test case added for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6788&quot; title=&quot;Wrong value inserted by INSERT INTO with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6788&quot;&gt;DERBY-6788&lt;/a&gt;. If they both pass, I will run our junit suite and derbyall suite to see how things go.&lt;/p&gt;

&lt;p&gt;This if condition has been there from Derby 10.1 days(and that is why we see the failures in 10.1 codeline as well). But my guess is that the reason we have the if condition in JoinNode.buildRCL is to avoid recreating the result column list. But it looks like, it should be ok to remove the if statement and let the result column list to be built again during the second round of the bind of SELECT in case of INSERT statement. &lt;/p&gt;
</comment>
                            <comment id="14295118" author="jstadler" created="Wed, 28 Jan 2015 13:08:45 +0000"  >&lt;p&gt;Great work, it really looks like you found the cause for this bug. I did a quick test with a new built derby.jar (with the outcommented if condition) and it worked - it actually also fixed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6788&quot; title=&quot;Wrong value inserted by INSERT INTO with multiple subselects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6788&quot;&gt;DERBY-6788&lt;/a&gt;, which does now work as expected.&lt;/p&gt;</comment>
                            <comment id="14295208" author="bryanpendleton" created="Wed, 28 Jan 2015 14:33:40 +0000"  >&lt;p&gt;Perhaps a slight twist on your approach, Mamta, would be to add a new method to JoinNode,&lt;br/&gt;
call it something like ClearResultColumnList(), and call that method when binding the INSERT&lt;br/&gt;
when we know that we&apos;re going to intentionally re-bind the SELECT.&lt;/p&gt;

&lt;p&gt;I just wanted to toss that idea into the arena.&lt;/p&gt;

&lt;p&gt;Clearly your approach is simpler, but if there are other routine cases where we call&lt;br/&gt;
JoinNode::buildRCL multiple times, will your approach result in our doing new extra&lt;br/&gt;
work in those cases?&lt;/p&gt;</comment>
                            <comment id="14301508" author="mamtas" created="Mon, 2 Feb 2015 17:41:53 +0000"  >&lt;p&gt;Hi Bryan, thanks for your suggestion. I was thinking of what you suggested when I was looking at possible fix but I do not think we know that we are going to do 2 phases of bind. May be there is a way to determine that but I haven&apos;t looked into that further. Also, I ran the junit suite and derbyall with my proposed change and everything ran fine. Additionally, I ran these two test suites with a println in JoinNode:buildRCL()  in case we find that there is already a resultcolumn list built when we get in the method. And I found not just INSERT with join clause but also special instances of JOIN SELECTs which find that resultcolumn list is not null.&lt;br/&gt;
I would suggest anyone with time to pursue this fix. I might not be able to get to this jira in near future.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12689786" name="acaaeec04ex014axaa2ex076bx000000c72a081.java" size="3179" author="jstadler" created="Fri, 2 Jan 2015 12:42:44 +0000"/>
                            <attachment id="12689785" name="repro.sql" size="990" author="jstadler" created="Fri, 2 Jan 2015 12:42:43 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10421"><![CDATA[Seen in production]]></customfieldvalue>
    <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 42 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i23whz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>