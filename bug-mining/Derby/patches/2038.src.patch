diff --git a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
index 553edd2ce..de5d07a6e 100644
--- a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
+++ b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
@@ -720,54 +720,66 @@ public class GenericLanguageConnectionContext
         // in XA use nested user updatable transaction.  Delay creating
         // the transaction until loop below finds one it needs to 
         // process.
-        TransactionController xa_tran       = null; 
-        TransactionController tran_for_drop = 
-            (in_xa_transaction ? null : getTransactionExecute());
-
-        try
+        
+        for (int i=0; i<allDeclaredGlobalTempTables.size(); i++)
         {
-            for (int i=0; i<allDeclaredGlobalTempTables.size(); i++)
+            TableDescriptor td = 
+                ((TempTableInfo) (allDeclaredGlobalTempTables.
+                                      get(i))).getTableDescriptor();
+            if (td.isOnCommitDeleteRows() == false) 
             {
-                TableDescriptor td = 
-                    ((TempTableInfo) (allDeclaredGlobalTempTables.
-                                          get(i))).getTableDescriptor();
-                if (td.isOnCommitDeleteRows() == false) 
-                {
-                    // do nothing for temp table with ON COMMIT PRESERVE ROWS
-                    continue;
-                }
-                else if (checkIfAnyActivationHasHoldCursor(td.getName()) == 
-                            false)
-                {
-                    // temp tables with ON COMMIT DELETE ROWS and 
-                    // no open held cursors
-                    getDataDictionary().getDependencyManager().invalidateFor(
-                        td, DependencyManager.DROP_TABLE, this);
-
-                    // handle delayed creation of nested xact for XA.
-                    if (in_xa_transaction)
-                    {
-                        if (xa_tran == null)
-                        {
-                            xa_tran = 
-                                getTransactionExecute().
-                                    startNestedUserTransaction(false);
-                            tran_for_drop = xa_tran;
-                        }
-                    }
+                // do nothing for temp table with ON COMMIT PRESERVE ROWS
+                continue;
+            }
+            else if (checkIfAnyActivationHasHoldCursor(td.getName()) == 
+                        false)
+            {
+                // temp tables with ON COMMIT DELETE ROWS and 
+                // no open held cursors
+                getDataDictionary().getDependencyManager().invalidateFor(
+                    td, DependencyManager.DROP_TABLE, this);
 
-                    cleanupTempTableOnCommitOrRollback(tran_for_drop, td, true);
+                if (!in_xa_transaction)
+                {
+                    // delay physical cleanup to after the commit for XA
+                    // transactions.   In XA the transaction is likely in
+                    // prepare state at this point and physical changes to
+                    // store are not allowed until after the commit.
+                    // Do the work here for non-XA so that fast path does
+                    // have to do the 2 commits that the XA path will.
+                    cleanupTempTableOnCommitOrRollback(td, true);
                 }
             }
         }
-        finally
+    }
+
+    private void tempTablesXApostCommit() 
+        throws StandardException
+    {
+        TransactionController tc = getTransactionExecute();
+
+        // at commit time for an XA transaction drop all temporary tables.
+        // A transaction context may not be maintained from one
+        // XAResource.xa_commit to the next in the case of XA with
+        // network server and thus there is no way to get at the temp
+        // tables again.  To provide consistent behavior in embedded vs
+        // network server, consistently remove temp tables at XA commit
+        // transaction boundary.
+        for (int i=0; i < allDeclaredGlobalTempTables.size(); i++)
         {
-            // if we created a nested user transaction for XA get rid of it.
-            if (xa_tran != null)
-            {
-                xa_tran.destroy();
-            }
+            // remove all temp tables from this context.
+            TableDescriptor td = 
+                ((TempTableInfo) 
+                 (allDeclaredGlobalTempTables.get(i))).getTableDescriptor();
+
+            //remove the conglomerate created for this temp table
+            tc.dropConglomerate(td.getHeapConglomerateId()); 
+
+            //remove it from the list of temp tables
+            allDeclaredGlobalTempTables.remove(i); 
         }
+
+        tc.commit();
     }
 
     /**
@@ -944,8 +956,7 @@ public class GenericLanguageConnectionContext
                 // restore the old definition of temp table because drop is 
                 // being rolledback
                 TableDescriptor td = tempTableInfo.getTableDescriptor();
-                td = cleanupTempTableOnCommitOrRollback(
-                        getTransactionExecute(), td, false);
+                td = cleanupTempTableOnCommitOrRollback(td, false);
 
                 // In order to store the old conglomerate information for the 
                 // temp table, we need to replace the existing table descriptor
@@ -976,8 +987,7 @@ public class GenericLanguageConnectionContext
                 getDataDictionary().getDependencyManager().invalidateFor(
                         td, DependencyManager.DROP_TABLE, this);
 
-                cleanupTempTableOnCommitOrRollback(
-                    getTransactionExecute(), td, true);
+                cleanupTempTableOnCommitOrRollback(td, true);
             } 
             // there is no else here because there is no special processing 
             // required for temp tables declares in earlier work of 
@@ -1530,6 +1540,13 @@ public class GenericLanguageConnectionContext
             // location, since any outer nesting
             // levels expect there to be a savepoint
             resetSavepoints();
+
+            // Do post commit XA temp table cleanup if necessary.
+            if ((allDeclaredGlobalTempTables != null) &&
+                (commitflag != NON_XA))
+            {
+                tempTablesXApostCommit();
+            }
         }
     }
 
@@ -1545,11 +1562,12 @@ public class GenericLanguageConnectionContext
      * temp table (because the drop on it is being rolled back).
      */
     private TableDescriptor cleanupTempTableOnCommitOrRollback(
-    TransactionController   tc,
     TableDescriptor         td, 
     boolean                 dropAndRedeclare)
          throws StandardException
     {
+        TransactionController tc = getTransactionExecute();
+
         //create new conglomerate with same properties as the old conglomerate 
         //and same row template as the old conglomerate
         long conglomId = 
@@ -1580,7 +1598,7 @@ public class GenericLanguageConnectionContext
         //will be refetched next time with the new value
         td.resetHeapConglomNumber();
 
-        if(dropAndRedeclare)
+        if (dropAndRedeclare)
         {
             //remove the old conglomerate from the system
             tc.dropConglomerate(cid); 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.java
index d4041493e..d2b12c87c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.java
@@ -1172,6 +1172,7 @@ public class XATest extends BaseJDBCTestCase {
         ps.executeUpdate();
         ResultSet rs = s.executeQuery("SELECT count(*) FROM SESSION.t1");
         JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
+        rs.close();
         // You could work around the issue by dropping the TEMP table
         //s.executeUpdate("DROP TABLE SESSION.T1");
         xar.end(xid, XAResource.TMSUCCESS);
@@ -1187,8 +1188,11 @@ public class XATest extends BaseJDBCTestCase {
             // is temp table empty after the commit?
             rs = s.executeQuery("SELECT count(*) FROM SESSION.t1");
             JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
+            rs.close();
+            conn.commit();
         }
 
+
         s.close();
         conn.close();
         xaconn.close();
