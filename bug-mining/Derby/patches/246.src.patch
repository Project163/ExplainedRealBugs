diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/readlocks.out b/java/testing/org/apache/derbyTesting/functionTests/master/readlocks.out
index 650cc0869..80140da50 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/readlocks.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/readlocks.out
@@ -2840,6 +2840,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -3065,6 +3074,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -5931,6 +5949,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -6159,6 +6186,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -9090,6 +9126,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -9315,6 +9360,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -12219,6 +12273,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -12447,6 +12510,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -15865,6 +15937,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -16108,6 +16189,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -19518,6 +19608,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -19764,6 +19863,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -22717,6 +22825,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -22952,6 +23069,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -25893,6 +26019,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
@@ -26132,6 +26267,15 @@ ij> ----------------------------------------------------------------------------
 delete from a where a = 2 or a = 4 or a = 6;
 3 rows inserted/updated/deleted
 ij> commit;
+ij> -- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+0 rows inserted/updated/deleted
 ij> select a from a;
 A          
 -----------
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/store/readBtreeSetLocks.subsql b/java/testing/org/apache/derbyTesting/functionTests/tests/store/readBtreeSetLocks.subsql
index 69f29ca71..be2780ed2 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/store/readBtreeSetLocks.subsql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/store/readBtreeSetLocks.subsql
@@ -74,6 +74,15 @@ commit;
 delete from a where a = 2 or a = 4 or a = 6;
 commit;
 
+-- The above delete and commit can allow post commit processing to run before
+-- the subsequent select is run, most likely if this run is on a table where
+-- there is one row per page.  To get reproducible results from the subsequent
+-- lock calls, wait for post commit to finish before running the select.  
+-- Without this wait "extra" locks sometimes might show up - these are locks
+-- on the committed deleted rows which have not been cleaned yet depending
+-- on timing.
+CALL WAIT_FOR_POST_COMMIT();
+
 select a from a;
 select * from lock_table order by tabname, type desc, mode, cnt, lockname;
 commit;
