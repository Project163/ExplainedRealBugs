diff --git a/java/engine/org/apache/derby/impl/store/raw/log/LogAccessFile.java b/java/engine/org/apache/derby/impl/store/raw/log/LogAccessFile.java
index a376a2cee..2a9f9e3b2 100644
--- a/java/engine/org/apache/derby/impl/store/raw/log/LogAccessFile.java
+++ b/java/engine/org/apache/derby/impl/store/raw/log/LogAccessFile.java
@@ -930,6 +930,9 @@ public class LogAccessFile
 
 	}
 
+    /** Return the length of a checksum record */
+    public  int getChecksumLogRecordSize() { return checksumLogRecordSize; }
+
 
 	protected void writeEndMarker(int marker) throws IOException, StandardException 
 	{
diff --git a/java/engine/org/apache/derby/impl/store/raw/log/LogCounter.java b/java/engine/org/apache/derby/impl/store/raw/log/LogCounter.java
index c77bed90c..4d037de13 100644
--- a/java/engine/org/apache/derby/impl/store/raw/log/LogCounter.java
+++ b/java/engine/org/apache/derby/impl/store/raw/log/LogCounter.java
@@ -90,9 +90,9 @@ public class LogCounter implements LogInstant {
 			SanityManager.ASSERT(position > 0, "illegal file position");
 
 			SanityManager.ASSERT(position < MAX_LOGFILE_SIZE,
-							 "log file position exceeded max log file size");
+							 "log file position exceeded max log file size. log file position = " + position );
 			SanityManager.ASSERT(fileNumber < MAX_LOGFILE_NUMBER,
-							 "log file number exceeded max log file number");
+							 "log file number exceeded max log file number. log file number = " + fileNumber );
 		}
 
 		this.fileNumber = fileNumber;
@@ -118,9 +118,9 @@ public class LogCounter implements LogInstant {
 			SanityManager.ASSERT(filepos > 0, "illegal file position");
 
 			SanityManager.ASSERT(filepos < MAX_LOGFILE_SIZE,
-							 "log file position exceeded max log file size");
+							 "log file position exceeded max log file size. log file position = " + filepos );
 			SanityManager.ASSERT(filenum < MAX_LOGFILE_NUMBER,
-							 "log file number exceeded max log file number");
+							 "log file number exceeded max log file number. log file number = " + filenum );
 		}
 
 		return ((filenum << FILE_NUMBER_SHIFT) | filepos);
diff --git a/java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java b/java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java
index 801bcd653..aa6802546 100644
--- a/java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java
+++ b/java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java
@@ -225,6 +225,8 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 								  Serviceable, java.security.PrivilegedExceptionAction
 {
 
+	private static final    long INT_LENGTH = 4L;
+
 	private static int fid = StoredFormatIds.FILE_STREAM_LOG_FILE; 
 
 	// format Id must fit in 4 bytes
@@ -1032,7 +1034,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 
                         // successfully init'd the log file - set up markers,
                         // and position at the end of the log.
-						endPosition = theLog.getFilePointer();
+						setEndPosition( theLog.getFilePointer() );
 						lastFlush   = endPosition;
 						
 						//if write sync is true , prellocate the log file
@@ -1103,7 +1105,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 
 					if (!ReadOnlyDB)
 					{
-						endPosition = LogCounter.getLogFilePosition(logEnd);
+						setEndPosition( LogCounter.getLogFilePosition(logEnd) );
 
 						//
 						// The end of the log is at endPosition.  Which is where
@@ -2098,7 +2100,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 					
 					logOut.writeEndMarker(0);
 
-					endPosition += 4;
+					setEndPosition( endPosition + INT_LENGTH );
 					//set that we are in log switch to prevent flusher 
 					//not requesting  to switch log again 
 					inLogSwitch = true; 
@@ -2118,7 +2120,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 					
 					logWrittenFromLastCheckPoint += endPosition;
 
-					endPosition = newLog.getFilePointer();
+					setEndPosition( newLog.getFilePointer() );
 					lastFlush = endPosition;
 					
 					if(isWriteSynced)
@@ -3380,7 +3382,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
                             SQLState.LOG_SEGMENT_NOT_EXIST, logFile.getPath());
                     }
 
-					endPosition = firstLog.getFilePointer();
+					setEndPosition( firstLog.getFilePointer() );
 					lastFlush = firstLog.getFilePointer();
 
                     //if write sync is true , prellocate the log file
@@ -3800,15 +3802,18 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 				 */
 
 				// see if the log file is too big, if it is, switch to the next
-				// log file
-				if ((endPosition + LOG_RECORD_OVERHEAD + length) >=
-					LogCounter.MAX_LOGFILE_SIZE)
+				// log file. account for an extra INT_LENGTH because switchLogFile()
+                // writes an extra 0 at the end of the log. in addition, a checksum log record
+                // may need to be written (see DERBY-2254).
+                int     checksumLogRecordSize = logOut.getChecksumLogRecordSize();
+				if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=
+                     LogCounter.MAX_LOGFILE_SIZE)
 				{
 					switchLogFile();
 
 					// still too big??  Giant log record?
-					if ((endPosition + LOG_RECORD_OVERHEAD + length) >=
-						LogCounter.MAX_LOGFILE_SIZE) 
+                    if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=
+                         LogCounter.MAX_LOGFILE_SIZE)
                     {
 						throw StandardException.newException(
                                 SQLState.LOG_EXCEED_MAX_LOG_FILE_SIZE, 
@@ -3820,7 +3825,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 				}
 
 				//reserve the space for the checksum log record
-				endPosition += logOut.reserveSpaceForChecksum(length, logFileNumber,endPosition);
+				setEndPosition( endPosition + logOut.reserveSpaceForChecksum(length, logFileNumber,endPosition) );
 
 				// don't call currentInstant since we are already in a
 				// synchronzied block 
@@ -3849,7 +3854,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 					}
 				}
 
-				endPosition += (length + LOG_RECORD_OVERHEAD);
+				setEndPosition( endPosition + (length + LOG_RECORD_OVERHEAD) );
 			}
 		}
 		catch (IOException ioe)
@@ -4665,19 +4670,19 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 				{
 					// reserve the space for the checksum log record
 					// NOTE:  bytesToWrite include the log record overhead.
-					endPosition += 
+					setEndPosition( endPosition +
 						logOut.reserveSpaceForChecksum(((length + LOG_RECORD_OVERHEAD) 
 														< bytesToWrite ? length :
 														(bytesToWrite - LOG_RECORD_OVERHEAD)),
-													   logFileNumber,endPosition);
+													   logFileNumber,endPosition) );
 					instant = currentInstant();
 
 					//check if the length of the records to be written is 
 					//actually smaller than the number of bytesToWrite 
 					if(length + LOG_RECORD_OVERHEAD < bytesToWrite)
-						endPosition += (length + LOG_RECORD_OVERHEAD);
+                    { setEndPosition( endPosition + (length + LOG_RECORD_OVERHEAD) ); }
 					else
-						endPosition += bytesToWrite;
+                    { setEndPosition( endPosition + bytesToWrite ); }
 
 					while(true)		// so we can break out without returning out of
 						// sync block...
@@ -5300,7 +5305,7 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
                 logEndInstant = scanOfHighestLogFile.getLogRecordEnd();
             }
 
-            endPosition = LogCounter.getLogFilePosition(logEndInstant);
+            setEndPosition( LogCounter.getLogFilePosition(logEndInstant) );
 
             // endPosition and logFileNumber now point to the end of the
             // highest log file. This is where a new log record should be
@@ -5738,6 +5743,17 @@ public final class LogToFile implements LogFactory, ModuleControl, ModuleSupport
 		}
 	}
 
+    /** set the endPosition of the log and make sure the new position won't spill off the end of the log */
+    private void    setEndPosition( long newPosition )
+    {
+		if (SanityManager.DEBUG)
+        {
+			SanityManager.ASSERT(newPosition < LogCounter.MAX_LOGFILE_SIZE,
+							 "log file would spill past its legal end if the end were set to = " + newPosition );
+		}
+
+        endPosition = newPosition;
+    }
 
 	
 
