diff --git a/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java b/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
index 9b8ac4eb7..7ed1eb2a1 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
@@ -185,6 +185,8 @@ public class OrderByColumn extends OrderedColumn {
                 SanityManager.ASSERT( addedColumnOffset >= 0,
                                       "Order by expression was not pulled into the result column list");
             resolveAddedColumn(target);
+		if (resultCol == null)
+			throw StandardException.newException(SQLState.LANG_UNION_ORDER_BY);
 		}
 
 		// Verify that the column is orderable
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index a7fbdab53..54817a33b 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -1173,6 +1173,11 @@ Guide.
                 <arg>columnName</arg>
             </msg>
 
+            <msg>
+                <name>42878</name>
+                <text>The ORDER BY clause of a SELECT UNION statement only supports unqualified column references and column position numbers. Other expressions are not currently supported.</text>
+            </msg>
+
             <msg>
                 <name>42884</name>
                 <text>No authorized routine named '{0}' of type '{1}' having compatible arguments was found.</text>
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 7756e16a7..64d74c374 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -855,6 +855,7 @@ public interface SQLState {
 	String LANG_ORDER_BY_COLUMN_NOT_FOUND                              = "42X78";
 	String LANG_DUPLICATE_COLUMN_FOR_ORDER_BY                          = "42X79";
 	String LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED                      = "42877";
+        String LANG_UNION_ORDER_BY                                         = "42878";
 	String LANG_EMPTY_VALUES_CLAUSE                                    = "42X80";
 	String LANG_USING_CARDINALITY_VIOLATION                            = "42X82";
 	String LANG_ADDING_COLUMN_WITH_NULL_AND_NOT_NULL_CONSTRAINT        = "42X83";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
index aca81f166..bbcae7cf3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
@@ -1485,4 +1485,193 @@ ij> select * from derby1861 order by 2, a-2;
 A          |B          |C          |D          
 -----------------------------------------------
 1          |2          |3          |4          
+ij> -- Tests which verify the handling of expressions in the ORDER BY list
+-- related to DERBY-2459. The issue in DERBY-2459 has to do with handling
+-- of ORDER BY in the UNION case. The current Derby implementation has no
+-- support for expressions in the ORDER BY clause of a UNION SELECT.
+-- These test cases demonstrate some aspects of what works, and what doesn't.
+
+create table d2459_A1 ( id char(1) ,value int ,ref char(1));
+0 rows inserted/updated/deleted
+ij> create table d2459_A2 ( id char(1) ,value int ,ref char(1));
+0 rows inserted/updated/deleted
+ij> create table d2459_B1 ( id char(1) ,value int);
+0 rows inserted/updated/deleted
+ij> create table d2459_B2 ( id char(1) ,value int);
+0 rows inserted/updated/deleted
+ij> insert into d2459_A1 (id, value, ref) values ('b', 1, null);
+1 row inserted/updated/deleted
+ij> insert into d2459_A1 (id, value, ref) values ('a', 12, 'e');
+1 row inserted/updated/deleted
+ij> insert into d2459_A2 (id, value, ref) values ('c', 3, 'g');
+1 row inserted/updated/deleted
+ij> insert into d2459_A2 (id, value, ref) values ('d', 8, null);
+1 row inserted/updated/deleted
+ij> insert into d2459_B1 (id, value) values ('f', 2);
+1 row inserted/updated/deleted
+ij> insert into d2459_B1 (id, value) values ('e', 4);
+1 row inserted/updated/deleted
+ij> insert into d2459_B2 (id, value) values ('g', 5);
+1 row inserted/updated/deleted
+ij> -- Should work, as the order by expression is against a select, not a union:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END ;
+ID  |2          
+----------------
+c   |5          
+d   |8          
+ij> -- Should work, it's a simple column reference to the first column in UNION:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by id;
+ID  |2          
+----------------
+a   |4          
+b   |1          
+c   |5          
+d   |8          
+ij> -- Should work, it's a column reference by position number
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by 2;
+ID  |2          
+----------------
+b   |1          
+a   |4          
+c   |5          
+d   |8          
+ij> -- should fail, because qualified column references can't refer to UNIONs
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by t1.id;
+ERROR 42877: A qualified column name 'T1.ID' is not allowed in the ORDER BY clause.
+ij> -- should fail, because the union's results can't be referenced this way
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END;
+ERROR 42878: The ORDER BY clause of a SELECT UNION statement only supports unqualified column references and column position numbers. Other expressions are not currently supported.
+ij> -- should fail, because this column is not in the result:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by value;
+ERROR 42X78: Column 'VALUE' is not in the result of the query expression.
+ij> -- ought to work, but currently fails, due to implementation restrictions:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN id IS NOT NULL THEN id ELSE 2 END;
+ERROR 42878: The ORDER BY clause of a SELECT UNION statement only supports unqualified column references and column position numbers. Other expressions are not currently supported.
+ij> -- Also ought to work, but currently fails due to implementation restrictions:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by id || 'abc';
+ERROR 42878: The ORDER BY clause of a SELECT UNION statement only supports unqualified column references and column position numbers. Other expressions are not currently supported.
+ij> -- A number of simpler test cases investigating how the result set of the
+-- UNION is constructed. If both children have identical result column names,
+-- then the UNION result set's columns have the same names. Otherwise the
+-- UNION result set's columns have generated names, and can only be
+-- referred to by column position. Note als othat the matching of columns
+-- for the result set of the UNION is done by column position, not by name
+
+select id from D2459_A1 union select ref from D2459_A2;
+1   
+----
+a   
+b   
+g   
+NULL
+ij> select id from D2459_A1 union select ref from D2459_A2 order by id;
+ERROR 42X78: Column 'ID' is not in the result of the query expression.
+ij> select id from D2459_A1 union select ref from D2459_A2 order by 1;
+1   
+----
+a   
+b   
+g   
+NULL
+ij> select id i from D2459_A1 union select ref i from D2459_A2 order by i;
+I   
+----
+a   
+b   
+g   
+NULL
+ij> select id i from D2459_A1 union select ref j from D2459_A2;
+1   
+----
+a   
+b   
+g   
+NULL
+ij> select id i from D2459_A1 union select ref j from D2459_A2 order by i;
+ERROR 42X78: Column 'I' is not in the result of the query expression.
+ij> select id i from D2459_A1 union select ref j from D2459_A2 order by 1;
+1   
+----
+a   
+b   
+g   
+NULL
+ij> select id from D2459_A1 union select id from D2459_A2 order by D2459_A1.id;
+ERROR 42877: A qualified column name 'D2459_A1.ID' is not allowed in the ORDER BY clause.
+ij> select id from D2459_A1 union select id from D2459_A2 order by id||'abc';
+ERROR 42878: The ORDER BY clause of a SELECT UNION statement only supports unqualified column references and column position numbers. Other expressions are not currently supported.
+ij> select * from D2459_A1 union select id, value, ref from D2459_A2 order by value;
+ID  |VALUE      |REF 
+---------------------
+b   |1          |NULL
+c   |3          |g   
+d   |8          |NULL
+a   |12         |e   
+ij> select id, value, ref from D2459_A1 union select * from D2459_A2 order by 2;
+ID  |VALUE      |REF 
+---------------------
+b   |1          |NULL
+c   |3          |g   
+d   |8          |NULL
+a   |12         |e   
+ij> select id, id i from D2459_A1 union select id j, id from D2459_A2 order by id;
+ERROR 42X78: Column 'ID' is not in the result of the query expression.
+ij> select id, id i from D2459_A1 union select id j, id from D2459_A2 order by 2;
+1   |2   
+---------
+a   |a   
+b   |b   
+c   |c   
+d   |d   
+ij> select id, ref from D2459_A1 union select ref, id from D2459_A2;
+1   |2   
+---------
+a   |e   
+b   |NULL
+g   |c   
+NULL|d   
+ij> select id i, ref j from D2459_A1 union select ref i, id j from D2459_A2;
+I   |J   
+---------
+a   |e   
+b   |NULL
+g   |c   
+NULL|d   
 ij> 
\ No newline at end of file
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
index 81f55ee4e..76b5dca63 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
@@ -534,3 +534,105 @@ select * from derby1861 order by c-1, c+1, a, b, c * 6;
 select t.*, t.c+2 from derby1861 t order by a, b, c+2;
 select * from derby1861 order by 3, 1;
 select * from derby1861 order by 2, a-2;
+
+-- Tests which verify the handling of expressions in the ORDER BY list
+-- related to DERBY-2459. The issue in DERBY-2459 has to do with handling
+-- of ORDER BY in the UNION case. The current Derby implementation has no
+-- support for expressions in the ORDER BY clause of a UNION SELECT.
+-- These test cases demonstrate some aspects of what works, and what doesn't.
+
+create table d2459_A1 ( id char(1) ,value int ,ref char(1));
+create table d2459_A2 ( id char(1) ,value int ,ref char(1));
+create table d2459_B1 ( id char(1) ,value int);
+create table d2459_B2 ( id char(1) ,value int);
+insert into d2459_A1 (id, value, ref) values ('b', 1, null);
+insert into d2459_A1 (id, value, ref) values ('a', 12, 'e');
+insert into d2459_A2 (id, value, ref) values ('c', 3, 'g');
+insert into d2459_A2 (id, value, ref) values ('d', 8, null);
+insert into d2459_B1 (id, value) values ('f', 2);
+insert into d2459_B1 (id, value) values ('e', 4);
+insert into d2459_B2 (id, value) values ('g', 5); 
+
+-- Should work, as the order by expression is against a select, not a union:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END ;
+
+-- Should work, it's a simple column reference to the first column in UNION:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by id;
+
+-- Should work, it's a column reference by position number
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by 2;
+
+-- should fail, because qualified column references can't refer to UNIONs
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by t1.id;
+
+-- should fail, because the union's results can't be referenced this way
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END;
+
+-- should fail, because this column is not in the result:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by value;
+
+-- ought to work, but currently fails, due to implementation restrictions:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by CASE WHEN id IS NOT NULL THEN id ELSE 2 END;
+
+-- Also ought to work, but currently fails due to implementation restrictions:
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref
+union all
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref
+order by id || 'abc';
+
+-- A number of simpler test cases investigating how the result set of the
+-- UNION is constructed. If both children have identical result column names,
+-- then the UNION result set's columns have the same names. Otherwise the
+-- UNION result set's columns have generated names, and can only be
+-- referred to by column position. Note als othat the matching of columns
+-- for the result set of the UNION is done by column position, not by name
+
+select id from D2459_A1 union select ref from D2459_A2;
+select id from D2459_A1 union select ref from D2459_A2 order by id;
+select id from D2459_A1 union select ref from D2459_A2 order by 1;
+select id i from D2459_A1 union select ref i from D2459_A2 order by i;
+select id i from D2459_A1 union select ref j from D2459_A2;
+select id i from D2459_A1 union select ref j from D2459_A2 order by i;
+select id i from D2459_A1 union select ref j from D2459_A2 order by 1;
+select id from D2459_A1 union select id from D2459_A2 order by D2459_A1.id;
+select id from D2459_A1 union select id from D2459_A2 order by id||'abc';
+select * from D2459_A1 union select id, value, ref from D2459_A2 order by value;
+select id, value, ref from D2459_A1 union select * from D2459_A2 order by 2;
+select id, id i from D2459_A1 union select id j, id from D2459_A2 order by id;
+select id, id i from D2459_A1 union select id j, id from D2459_A2 order by 2;
+select id, ref from D2459_A1 union select ref, id from D2459_A2;
+select id i, ref j from D2459_A1 union select ref i, id j from D2459_A2;
