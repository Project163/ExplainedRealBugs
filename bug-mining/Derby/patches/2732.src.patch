diff --git a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
index 4d8be2167..37eab9593 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
@@ -1328,13 +1328,32 @@ public class FromBaseTable extends FromTable
 				if (statCompositeSelectivity == -1.0d)
 					statCompositeSelectivity = 1.0d;
 			}
-
-			if (seenFirstColumn && statisticsForConglomerate &&
-				(startStopPredCount > 0))
-			{
-				statStartStopSelectivity = 
-					tableDescriptor.selectivityForConglomerate(cd, startStopPredCount);
-			}
+			
+            if (seenFirstColumn && (startStopPredCount > 0))
+            {
+                if (statisticsForConglomerate) {
+                    statStartStopSelectivity =
+                        tableDescriptor.selectivityForConglomerate(cd, 
+                            startStopPredCount);				
+                } else if (cd.isIndex())  {
+                    //DERBY-3790 (Investigate if request for update 
+                    // statistics can be skipped for certain kind of 
+                    // indexes, one instance may be unique indexes based 
+                    // on one column.) But as found in DERBY-6045 (in list
+                    // multi-probe by primary key not chosen on tables with
+                    // >256 rows), even though we do not keep the 
+                    // statistics for single-column unique indexes, we 
+                    // should improve the selectivity of such an index
+                    // when the index is being considered by the optimizer.
+                    IndexRowGenerator irg = cd.getIndexDescriptor();
+                    if (irg.isUnique() 
+                        && irg.numberOfOrderedColumns() == 1 
+                        && startStopPredCount == 1) {
+                            statStartStopSelectivity = 
+                                (double)(1/(double)baseRowCount());
+                    }
+                }
+            }
 
 			/*
 			** Factor the non-base-table predicates into the extra
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/refActions1.out b/java/testing/org/apache/derbyTesting/functionTests/master/refActions1.out
index 9014b425d..f963a1258 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/refActions1.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/refActions1.out
@@ -8853,7 +8853,8 @@ union all
 ij> -- #BEGIN;
 select * from db2test.dept where dno in (select vdno from
   db2test.vempunion)
-  and dno in ('K55', 'K52');
+  and dno in ('K55', 'K52')
+  order by dno;
 C0         |DNO|DNAME     |DMGRNAME  
 -------------------------------------
 2          |K52|OFC       |ROBIN     
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/InListMultiProbeTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/InListMultiProbeTest.java
index 1010b8665..1593fce7b 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/InListMultiProbeTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/InListMultiProbeTest.java
@@ -905,7 +905,7 @@ public class InListMultiProbeTest extends BaseJDBCTestCase {
     //  with >256 rows)
     // Following test shows that we should continue using index scan 
     //  even after adding extra rows to the table.
-    public void xtestDerby6045()
+    public void testDerby6045()
         throws SQLException
     {
         Statement s = createStatement();
@@ -962,7 +962,7 @@ public class InListMultiProbeTest extends BaseJDBCTestCase {
     //    doing table scan rather than index scan.
     //    If the unique key is removed from the table, the same query
     //    will start doing index scan.
-    public void xtestDerby6045InsertAllRowsAdditionalUniqueIndex() 
+    public void testDerby6045InsertAllRowsAdditionalUniqueIndex() 
             throws SQLException
     {
          Statement s = createStatement();
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/refActions1.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/refActions1.sql
index a9eb129f1..c9ca030c9 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/refActions1.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/refActions1.sql
@@ -3143,7 +3143,8 @@ union all
 -- #BEGIN;
 select * from db2test.dept where dno in (select vdno from
   db2test.vempunion)
-  and dno in ('K55', 'K52');
+  and dno in ('K55', 'K52')
+  order by dno;
 -- #END;
 
 delete from db2test.dept where dno in (select vdno from
