diff --git a/java/engine/org/apache/derby/impl/sql/compile/BetweenOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/BetweenOperatorNode.java
index 4339adf83..37c649705 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/BetweenOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/BetweenOperatorNode.java
@@ -123,6 +123,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 									C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
 									leftOperand, 
 								 	rightOperandList.elementAt(0),
+								 	Boolean.FALSE,
 									cm);
 		/* Set type info for the operator node */
 		leftBCO.bindComparisonOperator();
@@ -139,6 +140,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 								C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE,
 								leftClone,
 								rightOperandList.elementAt(1),
+							 	Boolean.FALSE,
 								cm);
 		/* Set type info for the operator node */
 		rightBCO.bindComparisonOperator();
@@ -224,6 +226,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 						C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE,
 						leftClone1, 
 						rightOperandList.elementAt(1),
+					 	Boolean.FALSE,
 						cm);
 
 		/* Set type info for the operator node */
@@ -243,6 +246,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 					C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
 					leftOperand, 
 					rightOperandList.elementAt(0),
+				 	Boolean.FALSE,
 					cm);
 
 		/* Set type info for the operator node */
@@ -302,6 +306,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 							C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
 							leftOperand, 
 							rightOperandList.elementAt(0),
+						 	Boolean.FALSE,
 							cm);
 		/* Set type info for the operator node */
 		leftBCO.bindComparisonOperator();
@@ -312,6 +317,7 @@ public class BetweenOperatorNode extends BinaryListOperatorNode
 						C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE,
 						leftOperand, 
 						rightOperandList.elementAt(1),
+					 	Boolean.FALSE,
 						cm);
 		/* Set type info for the operator node */
 		rightBCO.bindComparisonOperator();
diff --git a/java/engine/org/apache/derby/impl/sql/compile/BinaryComparisonOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/BinaryComparisonOperatorNode.java
index 588d64938..00a60e0e5 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/BinaryComparisonOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/BinaryComparisonOperatorNode.java
@@ -53,14 +53,28 @@ public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode
 	 * @param operator		The name of the operator
 	 * @param methodName	The name of the method to call in the generated
 	 *						class
+	 * @param forQueryRewrite Can be true only if if this node has been 
+	 *                      added by an internal rewrite of the query. This
+	 *                      allows binding to be more liberal when checking 
+	 *                      it against allowed syntax.
+	 *                      This parameter will be passed FALSE when a new 
+	 *                      instance of the node is being created(which is 
+	 *                      the majority of the cases). But when an  
+	 *                      existing node is getting cloned, the value of
+	 *                      this parameter should be passed as the 
+	 *                      originalNode.getForQueryRewrite(). Examples of
+	 *                      this can be found in Predicate.Java and 
+	 *                      PredicateList.java
 	 */
 
 	public void init(
 				Object	leftOperand,
 				Object	rightOperand,
 				Object		operator,
-				Object		methodName)
+				Object		methodName,
+                Object      forQueryRewrite)
 	{
+        this.forQueryRewrite = ((Boolean)forQueryRewrite).booleanValue();
 		super.init(leftOperand, rightOperand, operator, methodName,
 				ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);
 	}
diff --git a/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
index abb5a6c74..e4630e931 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
@@ -86,7 +86,18 @@ public class BinaryRelationalOperatorNode
 	 */
 	private InListOperatorNode inListProbeSource = null;
 
-	public void init(Object leftOperand, Object rightOperand)
+	//DERBY-6185 (Query against view  with "where name LIKE 
+	// 'Col1' ESCAPE '\' " failed)
+	//4th argument forQueryRewrite can be true only if this node has been 
+	//  added by an internal rewrite of the query. This allows binding to 
+	//  be more liberal when checking it against allowed syntax.
+	//  This parameter will be passed FALSE when a new instance of the node
+	//  is being created(which is the majority of the cases). But when an 
+	//  existing node is getting cloned, the value of this parameter should 
+	//  be passed as the originalNode.getForQueryRewrite(). Examples of this
+	//  can be found in Predicate.Java and PredicateList.java
+	public void init(Object leftOperand, Object rightOperand,
+        Object forQueryRewrite)
 	{
 		String methodName = "";
 		String operatorName = "";
@@ -135,7 +146,7 @@ public class BinaryRelationalOperatorNode
 				}
 			    break;
 		}
-		super.init(leftOperand, rightOperand, operatorName, methodName);
+		super.init(leftOperand, rightOperand, operatorName, methodName, forQueryRewrite);
 		btnVis = null;
 	}
 
@@ -144,10 +155,21 @@ public class BinaryRelationalOperatorNode
 	 * an InListOperatorNode.  This version is used during IN-list
 	 * preprocessing to create a "probe predicate" for the IN-list.
 	 * See InListOperatorNode.preprocess() for more.
+	 * DERBY-6185 (Query against view  with "where name LIKE 
+	 *  'Col1' ESCAPE '\' " failed)
+	 * 4th argument forQueryRewrite can be true only if this node has been
+	 *  added by an internal rewrite of the query. This allows binding to
+	 *  be more liberal when checking it against allowed syntax.
+	 *  This parameter will be passed FALSE when a new instance of the node
+	 *  is being created(which is the majority of the cases). But when an 
+	 *  existing node is getting cloned, the value of this parameter should
+	 *  be passed as the originalNode.getForQueryRewrite(). Examples of this
+	 *  can be found in Predicate.Java and PredicateList.java
 	 */
-	public void init(Object leftOperand, Object rightOperand, Object inListOp)
+	public void init(Object leftOperand, Object rightOperand,
+			 Object inListOp, Object forQueryRewrite)
 	{
-		init(leftOperand, rightOperand);
+		init(leftOperand, rightOperand, forQueryRewrite);
 		this.inListProbeSource = (InListOperatorNode)inListOp;
 	}
 
@@ -1047,6 +1069,7 @@ public class BinaryRelationalOperatorNode
 		negation = (BinaryOperatorNode)
 			getNodeFactory().getNode(getNegationNode(),
 									 leftOperand, rightOperand,
+									 Boolean.FALSE,
 									 getContextManager());
 		negation.setType(getTypeServices());
 		return negation;
@@ -1092,6 +1115,7 @@ public class BinaryRelationalOperatorNode
     BinaryOperatorNode getSwappedEquivalent() throws StandardException {
         BinaryOperatorNode newNode = (BinaryOperatorNode) getNodeFactory().getNode(getNodeTypeForSwap(),
                 rightOperand, leftOperand,
+                Boolean.FALSE,
                 getContextManager());
         newNode.setType(getTypeServices());
         return newNode;
@@ -1319,6 +1343,7 @@ public class BinaryRelationalOperatorNode
 		return (RelationalOperator)getNodeFactory().getNode(getNodeType(),
 														  otherCR,
 														  rightOperand,
+														  Boolean.FALSE,
 														  getContextManager());
 	}
 	
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index a68da8d5e..d6d13d253 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -603,6 +603,7 @@ public class ColumnReference extends ValueNode
 										C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 										this,
 										trueNode,
+										Boolean.FALSE,
 										getContextManager());
 		/* Set type info for the operator node */
 		equalsNode.bindComparisonOperator();
diff --git a/java/engine/org/apache/derby/impl/sql/compile/InListOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/InListOperatorNode.java
index d67a1a11f..ef0e052aa 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/InListOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/InListOperatorNode.java
@@ -145,6 +145,7 @@ public final class InListOperatorNode extends BinaryListOperatorNode
 						C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 						leftOperand, 
 						(ValueNode) rightOperandList.elementAt(0),
+						Boolean.FALSE,
 						getContextManager());
 			/* Set type info for the operator node */
 			equal.bindComparisonOperator();
@@ -287,6 +288,7 @@ public final class InListOperatorNode extends BinaryListOperatorNode
 							C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 							leftOperand, 
 							minValue,
+							Boolean.FALSE,
 							getContextManager());
 					/* Set type info for the operator node */
 					equal.bindComparisonOperator();
@@ -356,6 +358,7 @@ public final class InListOperatorNode extends BinaryListOperatorNode
 					leftOperand, 
 					pNode,
 					this,
+					Boolean.FALSE,
 					getContextManager());
 
 			/* Set type info for the operator node */
@@ -450,6 +453,7 @@ public final class InListOperatorNode extends BinaryListOperatorNode
 						C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
 						leftClone,
 						(ValueNode) rightOperandList.elementAt(0),
+						Boolean.FALSE,
 						getContextManager());
 		/* Set type info for the operator node */
 		leftBCO.bindComparisonOperator();
@@ -466,6 +470,7 @@ public final class InListOperatorNode extends BinaryListOperatorNode
 							C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
 							leftClone,
 							(ValueNode) rightOperandList.elementAt(elemsDone),
+							Boolean.FALSE,
 							getContextManager());
 			/* Set type info for the operator node */
 			rightBCO.bindComparisonOperator();
diff --git a/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java b/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
index 488f44ca7..24d134d04 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
@@ -903,6 +903,7 @@ public class JoinNode extends TableOperatorNode
 										C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 										leftCR,
 										rightCR,
+										Boolean.FALSE,
 										getContextManager());
 				equalsNode.bindComparisonOperator();
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
index e4716758f..c70ab6f56 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
@@ -396,6 +396,7 @@ public final class LikeEscapeOperatorNode extends TernaryOperatorNode
                                 C_NodeTypes.CHAR_CONSTANT_NODE,
                                 newPattern,
                                 getContextManager()),
+                                Boolean.FALSE,
                             getContextManager());
 
                     // Set forQueryRewrite to bypass comparability checks
@@ -675,7 +676,8 @@ public final class LikeEscapeOperatorNode extends TernaryOperatorNode
                     C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
                     receiver.getClone(), 
                     likeLTopt,
-                    getContextManager());
+                    Boolean.FALSE,
+                   getContextManager());
 
             // Disable comparability checks
             lessThan.setForQueryRewrite(true);
@@ -734,6 +736,7 @@ public final class LikeEscapeOperatorNode extends TernaryOperatorNode
                 C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
                 receiver.getClone(), 
                 likeGEopt,
+                Boolean.FALSE,
                 getContextManager());
 
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/Predicate.java b/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
index a0aa09b36..f0ed3a0ab 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
@@ -994,6 +994,7 @@ public final class Predicate extends QueryTreeNode implements OptimizablePredica
 					parentRSNsTables,
 					childRSN,
 					whichRC),
+					Boolean.valueOf(opNode.getForQueryRewrite()),
 				getContextManager());
 
 		// Bind the new op node.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
index 0ae848407..df275f483 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
@@ -1571,6 +1571,7 @@ public class PredicateList extends QueryTreeNodeVector implements OptimizablePre
 										newCRNode,
 										opNode.getRightOperand(),
 										inNode,
+										Boolean.valueOf(opNode.getForQueryRewrite()),
 										getContextManager());
 					newRelop.bindComparisonOperator();
 					leftOperand = newRelop;
@@ -2159,6 +2160,7 @@ public class PredicateList extends QueryTreeNodeVector implements OptimizablePre
 										C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 										outerCR.getClone(),
 										innerCR.getClone(),
+										Boolean.FALSE,
 										getContextManager());
 					newEquals.bindComparisonOperator();
 					/* Create the AND */
diff --git a/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java b/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
index 02e5b400d..6bf6ae86e 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
@@ -1615,6 +1615,7 @@ public class SubqueryNode extends ValueNode
 							nodeType,
 							leftOperand,
 							rightOperand,
+							Boolean.FALSE,
 							getContextManager());
 
 		bcoNode.bindComparisonOperator();
@@ -2379,6 +2380,7 @@ public class SubqueryNode extends ValueNode
   									C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
   									leftOperand,
   									this,
+  									Boolean.FALSE,
   									getContextManager());
   				break;
 
@@ -2387,6 +2389,7 @@ public class SubqueryNode extends ValueNode
   								C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
   								leftOperand,
   								this,
+  								Boolean.FALSE,
   								getContextManager());
   				break;
 
@@ -2395,6 +2398,7 @@ public class SubqueryNode extends ValueNode
   								C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE,
   								leftOperand,
   								this,
+  								Boolean.FALSE,
   								getContextManager());
   				break;
 
@@ -2403,6 +2407,7 @@ public class SubqueryNode extends ValueNode
   							C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
   							leftOperand,
   							this,
+  							Boolean.FALSE,
   							getContextManager());
   				break;
 
@@ -2411,6 +2416,7 @@ public class SubqueryNode extends ValueNode
   							C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
   							leftOperand,
   							this,
+  							Boolean.FALSE,
   							getContextManager());
   				break;
 
@@ -2419,6 +2425,7 @@ public class SubqueryNode extends ValueNode
   								C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE,
   								leftOperand,
   								this,
+  								Boolean.FALSE,
   								getContextManager());
   				break;
   		}
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java b/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
index 7d5b940a4..f040217e2 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
@@ -549,6 +549,7 @@ public abstract class ValueNode extends QueryTreeNode
 								C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 								this,
 								falseNode,
+								Boolean.FALSE,
 								getContextManager());
 		nullableResult = getTypeServices().isNullable();
 		equalsNode.setType(new DataTypeDescriptor(
diff --git a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
index 70a0b82f8..e0029f475 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
+++ b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
@@ -5671,6 +5671,7 @@ additiveExpression(ValueNode farLeftOperand, int compOp) throws StandardExceptio
 							nodeType,
 							farLeftOperand,
 							leftOperand,
+							Boolean.FALSE,
 							getContextManager());
 	}
 }
@@ -12621,6 +12622,7 @@ valueSpecification() throws StandardException :
 														C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
 														leftExpression,
 														rightExpression,
+														Boolean.FALSE,
 														cm),
 											thenElseList,
 											Boolean.TRUE,//this node is for nullif 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ViewsTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ViewsTest.java
index 131bd10a4..43a70ea69 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ViewsTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ViewsTest.java
@@ -52,6 +52,88 @@ public final class ViewsTest extends BaseJDBCTestCase {
         return new CleanDatabaseTestSetup(suite);
     }
 
+    //DERBY-6185(Query against view  with 
+    // "where name LIKE 'Col1' ESCAPE '\' " failed)
+    //Problem was that we clone binary comparison operator node during the
+    // optimize phase but we did not copy the entire state of the original
+    // node
+    public void test_DERBY6185() throws Exception
+    {
+        ResultSet rs = null;
+        
+        Statement st = createStatement();
+        PreparedStatement ps;
+
+        // create 2 tables and a view
+        st.executeUpdate(
+            "create table mytbl1 (name clob(10K))");
+        st.executeUpdate("insert into mytbl1 "+
+            "values ('Col1'),('Col2')");
+        st.executeUpdate(
+            "create table mytbl2 (name clob(10K))");
+        st.executeUpdate("insert into mytbl2 "+
+                "values ('Col1'),('Col2')");
+        st.executeUpdate(
+            "create view myview (name) as select t1.name from " +
+            "mytbl1 t1 union all select t2.name from mytbl2 t2");
+
+        //test base table's CLOB and LIKE clause with Statement
+        rs = st.executeQuery("select name from mytbl1 " +
+                "where name LIKE 'Col1'");
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"}
+        });
+
+        //test base table's CLOB and LIKE clause with PreparedStatement
+        ps = prepareStatement("select name from mytbl1 " +
+                "where name LIKE ?");
+        ps.setString(1, "Col1");
+        rs = ps.executeQuery();
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"}
+        });
+
+        //test view's CLOB and LIKE clause with Statement
+        rs = st.executeQuery("select name from myview " +
+            "where name LIKE 'Col1'");
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"},
+                {"Col1"}
+        });
+
+        //test view's CLOB and LIKE clause with PreparedStatement
+        ps = prepareStatement("select name from myview " +
+                "where name LIKE ?");
+        ps.setString(1, "Col1");
+        rs = ps.executeQuery();
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"},
+                {"Col1"}
+        });
+
+        //test UNION's CLOB and LIKE clause with Statement
+        rs = st.executeQuery("select name from " +
+             "(select name from mytbl1 t1 union all " +
+             "select t2.name from mytbl2 t2) " +
+             "as s where name like 'Col1'");
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"},
+                {"Col1"}
+        });
+
+        //test UNION's CLOB and LIKE clause with PreparedStatement
+        ps = prepareStatement("select name from " +
+             "(select name from mytbl1 t1 union all " +
+             "select t2.name from mytbl2 t2) " +
+             "as s where name like ?");
+        ps.setString(1, "Col1");
+        rs = ps.executeQuery();
+        JDBC.assertFullResultSet(rs, new String[][]{
+                {"Col1"},
+                {"Col1"}
+        });
+    }
+
     public void test_views() throws Exception
     {
         ResultSet rs = null;
