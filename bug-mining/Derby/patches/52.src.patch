diff --git a/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java b/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
index 4e2b91151..75a04258d 100755
--- a/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
+++ b/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
@@ -47,23 +47,40 @@ public interface ResultColumnDescriptor
 	String	getName();
 
 	/**
-	 * Get the name of the schema the Column is in, if any.
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
 	 *
-	 * @return	A String containing the name of the schema the Column
-	 *		is in.  If the column is not in a schema (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	The name of the schema of the Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
-	String	getSchemaName();
+	String	getSourceSchemaName();
 
 	/**
-	 * Get the name of the table the Column is in, if any.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	A String containing the name of the table the Column
+	 * @return	A String containing the name of the base table of the Column
 	 *		is in. If the column is not in a table (i.e. is a
 	 * 		derived column), it returns NULL.
+	 * @return	The name of the Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
 	String	getSourceTableName();
 
+	/**
+	 * Return true if the column is wirtable by a positioned update.
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by a positioned update.
+	 */
+	boolean updatableByCursor();
+
 	/**
 	 * Get the position of the Column.
 	 * NOTE - position is 1-based.
diff --git a/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java b/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
index 6bb4414c9..70da44842 100755
--- a/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
+++ b/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
@@ -104,7 +104,7 @@ public class ColumnDescriptor extends TupleDescriptor
 			this.table = table;
 			this.uuid = table.getUUID();
 		}
-		
+
 		if (SanityManager.DEBUG)
 		{
 			if (autoinc)
@@ -136,7 +136,7 @@ public class ColumnDescriptor extends TupleDescriptor
 	 *							(null if no default)
 	 * @param columnDefaultInfo		The default info for the column.
 	 * @param uuid			A uuid for the object that this column
-	 *						is in. 
+	 *						is in.
 	 * @param defaultUUID			The UUID for the default, if any.
 	 * @param autoincStart	Start value for an autoincrement column.
 	 * @param autoincInc	Increment for autoincrement column
@@ -145,8 +145,8 @@ public class ColumnDescriptor extends TupleDescriptor
 	public ColumnDescriptor(String columnName, int columnPosition,
 		DataTypeDescriptor columnType, DataValueDescriptor columnDefault,
 		DefaultInfo columnDefaultInfo,
-		UUID uuid, 
-		UUID defaultUUID, 
+		UUID uuid,
+		UUID defaultUUID,
         long autoincStart, long autoincInc, boolean autoinc)
 
 	{
@@ -220,7 +220,7 @@ public class ColumnDescriptor extends TupleDescriptor
 	}
 
 	/**
-	 * Sets the the column name in case of rename column.
+	 * Sets the column name in case of rename column.
 	 *
 	 * @param newColumnName	The new column name.
 	 */
@@ -229,6 +229,16 @@ public class ColumnDescriptor extends TupleDescriptor
 		this.columnName = newColumnName;
 	}
 
+	/**
+	 * Sets the table descriptor for the column.
+	 *
+	 * @param tableDescriptor	The table descriptor for this column
+	 */
+	public void	setTableDescriptor(TableDescriptor tableDescriptor)
+	{
+		this.table = tableDescriptor;
+	}
+
 	/**
 	 * Get the ordinal position of the column (1 based)
 	 *
@@ -326,6 +336,10 @@ public class ColumnDescriptor extends TupleDescriptor
 	{
 		return (autoincInc != 0);
 	}
+	public boolean updatableByCursor()
+	{
+		return false;
+	}
 
 	/**
 	 * Get the start value of an autoincrement column
diff --git a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
index c6fb8f85d..b3768e487 100755
--- a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
+++ b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
@@ -2043,11 +2043,19 @@ public abstract class EmbedResultSet extends ConnectionChild
       //1)Make sure for updateXXX methods, the column position is not out of range
       ResultDescription rd = theResults.getResultDescription();
       if (columnIndex < 1 || columnIndex > rd.getColumnCount())
-        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION, new Integer(columnIndex), String.valueOf(rd.getColumnCount()));
+        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,
+					new Integer(columnIndex), String.valueOf(rd.getColumnCount()));
 
       //2)Make sure the column corresponds to a column in the base table and it is not a derived column
       if (rd.getColumnDescriptor(columnIndex).getSourceTableName() == null)
-        throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE, methodName);
+        throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE,
+					methodName);
+
+      //3)If column not updatable then throw an exception
+      if (!getMetaData().isWritable(columnIndex))
+        throw Util.generateCsSQLException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR,
+					theResults.getResultDescription().getColumnDescriptor(columnIndex).getName(),
+					getCursorName());
 	}
 
 	//do following few checks before accepting updatable resultset api
@@ -3153,6 +3161,8 @@ public abstract class EmbedResultSet extends ConnectionChild
             boolean foundOneColumnAlready = false;
             StringBuffer updateWhereCurrentOfSQL = new StringBuffer("UPDATE ");
             CursorActivation activation = getEmbedConnection().getLanguageConnection().lookupCursorActivation(getCursorName());
+
+
             ExecCursorTableReference targetTable = activation.getPreparedStatement().getTargetTable();
             updateWhereCurrentOfSQL.append(getFullBaseTableName(targetTable));//got the underlying (schema.)table name
             updateWhereCurrentOfSQL.append(" SET ");
diff --git a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
index 7da88f4c9..a83b55676 100755
--- a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
+++ b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
@@ -204,7 +204,7 @@ public class EmbedResultSetMetaData
 	public String getSchemaName(int column) throws SQLException	{
 		ResultColumnDescriptor cd = columnInfo[column - 1];
 
-		String s = cd.getSchemaName();
+		String s = cd.getSourceSchemaName();
 		// database returns null when no schema name to differentiate from empty name
 		return (s==null? "" : s);
 	}
@@ -308,9 +308,7 @@ public class EmbedResultSetMetaData
      */
 	public boolean isWritable(int column) throws SQLException {
 		validColumnNumber(column);
-
-		// we just don't know if it is a base table column or not
-		return false;
+		return columnInfo[column - 1].updatableByCursor();
 	}
 
     /**
diff --git a/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java b/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
index 5aae4dd10..2f7bc7592 100755
--- a/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
+++ b/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
@@ -66,6 +66,7 @@ public final class GenericColumnDescriptor
 	private int					columnPos;
 	private DataTypeDescriptor	type;
 	private boolean 			isAutoincrement;
+	private boolean 			updatableByCursor;
 
 	/**
 	 * Niladic constructor for Formatable
@@ -92,10 +93,11 @@ public final class GenericColumnDescriptor
 	{
 		name = rcd.getName();
 		tableName = rcd.getSourceTableName();
-		schemaName = rcd.getSchemaName();
+ 		schemaName = rcd.getSourceSchemaName();
 		columnPos = rcd.getColumnPosition();
 		type = rcd.getType();
 		isAutoincrement = rcd.isAutoincrement();
+		updatableByCursor = rcd.updatableByCursor();
 	}
 
 	/**
@@ -121,23 +123,29 @@ public final class GenericColumnDescriptor
 	}
 
 	/**
-	 * Get the name of the schema the Column is in, if any.
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
 	 *
-	 * @return	A String containing the name of the schema the Column
-	 *		is in.  If the column is not in a schema (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	A String containing the name of the schema of the Column's table.
+	 *		If the column is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
-	public String	getSchemaName()
+	public String	getSourceSchemaName()
 	{
 		return schemaName;
 	}
 
 	/**
-	 * Get the name of the table the Column is in, if any.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	A String containing the name of the table the Column
-	 *		is in. If the column is not in a table (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	A String containing the name of the Column's base table.
+	 *		If the column is not in a table (i.e. is a derived column), it returns NULL.
 	 */
 	public String	getSourceTableName()
 	{
@@ -161,6 +169,11 @@ public final class GenericColumnDescriptor
 		return isAutoincrement;
 	}
 
+	public boolean updatableByCursor()
+	{
+		return updatableByCursor;
+	}
+
 	//////////////////////////////////////////////
 	//
 	// FORMATABLE
@@ -182,6 +195,7 @@ public final class GenericColumnDescriptor
 		fh.putInt("columnPos", columnPos);
 		fh.put("type", type);
 		fh.putBoolean("isAutoincrement", isAutoincrement);
+		fh.putBoolean("updatableByCursor", updatableByCursor);
 		out.writeObject(fh);
 		return;
 	}	
@@ -205,6 +219,7 @@ public final class GenericColumnDescriptor
 		columnPos = fh.getInt("columnPos");
 		type = (DataTypeDescriptor)fh.get("type");
 		isAutoincrement = fh.getBoolean("isAutoincrement");
+		updatableByCursor = fh.getBoolean("updatableByCursor");
 	}
 	
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java b/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
index a3481e5e4..a33f20d51 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
@@ -111,6 +111,8 @@ public class BaseColumnNode extends ValueNode
 	/**
 	 * Get the user-supplied table name of this column.  This will be null
 	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
 	 *
 	 * @return	The user-supplied name of this column.  Null if no user-
 	 * 		supplied name.
@@ -121,6 +123,19 @@ public class BaseColumnNode extends ValueNode
 		return ( ( tableName != null) ? tableName.getTableName() : null );
 	}
 
+	/**
+	 * Get the user-supplied schema name for this column's table. This will be null
+	 * if the user did not supply a name (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 *
+	 * @return	The schema name for this column's table
+	 */
+	public String getSchemaName() throws StandardException
+	{
+		return ( ( tableName != null) ? tableName.getSchemaName() : null );
+	}
+
 	/**
 	 * Do the code generation for this node. Should never be called.
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index 35aa92d29..ae610f1fd 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -489,6 +489,8 @@ public class ColumnReference extends ValueNode
 	/**
 	 * Get the user-supplied table name of this column.  This will be null
 	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
 	 *
 	 * @return	The user-supplied name of this column.  Null if no user-
 	 * 		supplied name.
@@ -500,16 +502,45 @@ public class ColumnReference extends ValueNode
 	}
 
 	/**
-	 * Get the name of the table this column comes from.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	The name of the table that this column comes from.  
+	 * @return	The name of the base table that this column comes from.
 	 *			Null if not a ColumnReference.
 	 */
 
 	public String getSourceTableName()
 	{
-		return ( ( tableName != null) ? tableName.getTableName() : 
-					((source != null) ? source.getTableName() : null));
+		return ((source != null) ? source.getTableName() : null);
+	}
+
+	/**
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
+	 *
+	 * @return	The name of the schema for Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
+	 */
+	public String getSourceSchemaName() throws StandardException
+	{
+		return ((source != null) ? source.getSchemaName() : null);
+	}
+
+	/**
+	 * Is the column wirtable by the cursor or not. (ie, is it in the list of FOR UPDATE columns list)
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by cursor.
+	 */
+	public boolean updatableByCursor()
+	{
+		return ((source != null) ? source.updatableByCursor() : false);
 	}
 
 	/**
@@ -943,6 +974,9 @@ public class ColumnReference extends ValueNode
 	/**
 	 * Get the user-supplied schema name of this column.  This will be null
 	 * if the user did not supply a name (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 * Code generation of aggregate functions relies on this method
 	 *
 	 * @return	The user-supplied schema name of this column.  Null if no user-
 	 * 		supplied name.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java b/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
index 3211bfa53..e6a042866 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
@@ -295,7 +295,7 @@ public class CursorNode extends ReadCursorNode
 			if (updateMode == READ_ONLY)
 				updatableColumns = null; // don't need them any more
 		}
-	
+
 		// bind the update columns
 		if (updateMode == UPDATE)
 		{
@@ -308,6 +308,11 @@ public class CursorNode extends ReadCursorNode
 			if (updateTable instanceof FromTable)
 			{
 				((FromTable) updateTable).markUpdatableByCursor(updatableColumns);
+				//make sure that alongwith the FromTable, we keep other ResultSetLists
+				//in correct state too. ResultSetMetaData.isWritable looks at this to
+				//return the correct value.
+				resultSet.getResultColumns().markColumnsInSelectListUpdatableByCursor(
+					updatableColumns);
 			}
 		}
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
index b3f9bb484..82e5dc778 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
@@ -3459,6 +3459,12 @@ public class FromBaseTable extends FromTable
 		{
 			/* Build a ResultColumn/BaseColumnNode pair for the column */
 			colDesc = (ColumnDescriptor) cdl.elementAt(index);
+			//A ColumnDescriptor instantiated through SYSCOLUMNSRowFactory only has 
+			//the uuid set on it and no table descriptor set on it. Since we know here
+			//that this columnDescriptor is tied to tableDescriptor, set it so using
+			//setTableDescriptor method. ColumnDescriptor's table descriptor is used
+			//to get ResultSetMetaData.getTableName & ResultSetMetaData.getSchemaName
+			colDesc.setTableDescriptor(tableDescriptor);
 
 			valueNode = (ValueNode) getNodeFactory().getNode(
 											C_NodeTypes.BASE_COLUMN_NODE,
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java b/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
index 6648ab19d..75c5f4bbb 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
@@ -85,6 +85,8 @@ public class ResultColumn extends ValueNode
 	String			exposedName;
 	String			tableName;
 	String			sourceTableName;
+	//Used by metadata api ResultSetMetaData.getSchemaName to get a column's table's schema.
+	String			sourceSchemaName;
 	ValueNode		expression;
 	ColumnDescriptor	columnDescriptor;
 	boolean			isGenerated;
@@ -215,12 +217,12 @@ public class ResultColumn extends ValueNode
 		return exposedName;
 	}
 
-	public String getSchemaName()
+	public String getSchemaName() throws StandardException
 	{
-		if ((columnDescriptor!=null) && 
-			(columnDescriptor.getTableDescriptor() != null)) 
+		if ((columnDescriptor!=null) &&
+			(columnDescriptor.getTableDescriptor() != null))
 			return columnDescriptor.getTableDescriptor().getSchemaName();
-		else 
+		else
 		{
 			if (expression != null)
 			// REMIND: could look in reference, if set.
@@ -236,8 +238,8 @@ public class ResultColumn extends ValueNode
 		{
 			return tableName;
 		}
-		if ((columnDescriptor!=null) && 
-			(columnDescriptor.getTableDescriptor() != null)) 
+		if ((columnDescriptor!=null) &&
+			(columnDescriptor.getTableDescriptor() != null))
 		{
 			return columnDescriptor.getTableDescriptor().getName();
 		}
@@ -255,6 +257,14 @@ public class ResultColumn extends ValueNode
 		return sourceTableName;
 	}
 
+	/**
+	 * @see ResultColumnDescriptor#getSourceSchemaName
+	 */
+	public String getSourceSchemaName()
+	{
+		return sourceSchemaName;
+	}
+
 	/**
 	 * Clear the table name for the underlying ColumnReference.
 	 * See UpdateNode for full explaination.
@@ -274,14 +284,14 @@ public class ResultColumn extends ValueNode
 
 	public DataTypeDescriptor getExpressionType()
 	{
-		return (expression == null) ? 
+		return (expression == null) ?
 			dataTypeServices :
 			expression.getTypeServices();
 	}
 
 	public int getColumnPosition()
 	{
-		if (columnDescriptor!=null) 
+		if (columnDescriptor!=null)
 			return columnDescriptor.getPosition();
 		else
 			return virtualColumnId;
@@ -785,6 +795,7 @@ public class ResultColumn extends ValueNode
 			ColumnReference cr = (ColumnReference) expression;
 			tableName = cr.getTableName();
 			sourceTableName = cr.getSourceTableName();
+			sourceSchemaName = cr.getSourceSchemaName();
 		}
 	}
 
@@ -1335,11 +1346,11 @@ public class ResultColumn extends ValueNode
 	}
 
 	/**
-	 * Tell whether this column is updatable bay a positioned update.
+	 * Tell whether this column is updatable by a positioned update.
 	 *
 	 * @return	true means this column is updatable
 	 */
-	boolean updatableByCursor()
+	public boolean updatableByCursor()
 	{
 		return updatableByCursor;
 	}
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index 06066faa0..9b61afedf 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -2422,7 +2422,7 @@ public class ResultColumnList extends QueryTreeNodeVector
 	}
 
 	/**
-	 * Mark all the columns in this list as updatable by a positioned update
+	 * Mark all the (base) columns in this list as updatable by a positioned update
 	 * statement.  This is necessary
 	 * for positioned update statements, because we expand the column list
 	 * to include all the columns in the base table, and we need to be able
@@ -2438,7 +2438,9 @@ public class ResultColumnList extends QueryTreeNodeVector
 
 		for (int index = 0; index < size; index++)
 		{
-			((ResultColumn) elementAt(index)).markUpdatableByCursor();
+			//determine if the column is a base column and not a derived column
+			if (((ResultColumn) elementAt(index)).getSourceTableName() != null)
+				((ResultColumn) elementAt(index)).markUpdatableByCursor();
 		}
 	}
 
@@ -2615,17 +2617,33 @@ public class ResultColumnList extends QueryTreeNodeVector
 	}
 
 	/**
-	 * Mark as updatable all the columns in this result column list
-	 * that match the columns in the given update column list
+	 * Mark all the columns in the select sql that this result column list represents
+	 * as updatable if they match the columns in the given update column list.
 	 *
 	 * @param updateColumns		A Vector representing the columns
 	 *							to be updated.
 	 */
-	void markUpdatableByCursor(Vector updateColumns)
+	void markColumnsInSelectListUpdatableByCursor(Vector updateColumns)
+	{
+		commonCodeForUpdatableByCursor(updateColumns, true);
+	}
+
+	/**
+	 * dealingWithSelectResultColumnList true means we are dealing with
+	 * ResultColumnList for a select sql. When dealing with ResultColumnList for
+	 * select sql, it is possible that not all the updatable columns are
+	 * projected in the select column list and hence it is possible that we may
+	 * not find the column to be updated in the ResultColumnList and that is why
+	 * special handling is required when dealingWithSelectResultColumnList is true.
+	 * eg select c11, c13 from t1 for update of c11, c12
+	 * In the eg above, we will find updatable column c11 in the select column
+	 * list but we will not find updatable column c12 in the select column list
+	 */
+	private void commonCodeForUpdatableByCursor(Vector updateColumns, boolean dealingWithSelectResultColumnList)
 	{
 		/*
-		** If there is no update column list, or the list is empty,
-		** it means all the columns are updatable.
+		** If there is no update column list, or the list is empty, then it means that
+		** all the columns which have a base table associated with them are updatable.
 		*/
 		if ( (updateColumns == null) || (updateColumns.size() == 0) )
 		{
@@ -2639,25 +2657,38 @@ public class ResultColumnList extends QueryTreeNodeVector
 
 			for (int index = 0; index < ucSize; index++)
 			{
-				columnName = (String) updateColumns.elementAt(index); 
+				columnName = (String) updateColumns.elementAt(index);
 
 				resultColumn = getResultColumn(columnName);
-
 				if (SanityManager.DEBUG)
 				{
-					if (resultColumn == null)
+					if (resultColumn == null && !dealingWithSelectResultColumnList)
 					{
-						SanityManager.THROWASSERT(
-							"No result column found with name " +
+						SanityManager.THROWASSERT("No result column found with name " +
 							columnName);
 					}
 				}
-
+				//Following if means the column specified in FOR UPDATE clause is not
+				//part of the select list
+				if (resultColumn == null && dealingWithSelectResultColumnList)
+					continue;
 				resultColumn.markUpdatableByCursor();
 			}
 		}
 	}
 
+	/**
+	 * Mark as updatable all the columns in this result column list
+	 * that match the columns in the given update column list
+	 *
+	 * @param updateColumns		A Vector representing the columns
+	 *							to be updated.
+	 */
+	void markUpdatableByCursor(Vector updateColumns)
+	{
+		commonCodeForUpdatableByCursor(updateColumns, false);
+	}
+
 	/**
 	 * Returns true if the given column position is for a column that will
 	 * be or could be updated by the positioned update of a cursor.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java b/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
index 139ca02b9..63d102f95 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
@@ -661,6 +661,11 @@ public abstract class ValueNode extends QueryTreeNode
 	}
 
 	/**
+	 * This returns the user-supplied schema name of the column.
+	 * At this class level, it simply returns null. But, the subclasses
+	 * of ValueNode will overwrite this method to return the
+	 * user-supplied schema name.
+	 * 
 	 * When the value node is in a result column of a select list,
 	 * the user can request metadata information. The result column
 	 * won't have a column descriptor, so we return some default
@@ -670,19 +675,39 @@ public abstract class ValueNode extends QueryTreeNode
 	 *
 	 * @return the default schema name for an expression -- null
 	 */
-	public String getSchemaName()
+	public String getSchemaName() throws StandardException
 	{
 		return null;
 	}
 
 	/**
-	 * @return the default schema name for an expression -- null
+	 * This returns the user-supplied table name of the column.
+	 * At this class level, it simply returns null. But, the subclasses
+	 * of ValueNode will overwrite this method to return the
+	 * user-supplied table name.
+	 *
+	 * When the value node is in a result column of a select list,
+	 * the user can request metadata information. The result column
+	 * won't have a column descriptor, so we return some default
+	 * information through the expression. This lets expressions that
+	 * are simply columns return all of the info, and others use
+	 * this supertype's default values.
+	 *
+	 * @return the default table name for an expression -- null
 	 */
 	public String getTableName()
 	{
 		return null;
 	}
 
+	/**
+	 * @return the default updatability for an expression - false
+	 */
+	public boolean updatableByCursor()
+	{
+		return false;
+	}
+
 	/**
 	 * This is null so that the caller will substitute in the resultset generated
 	 * name as needed.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java b/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
index 59a92f645..a540acb87 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
@@ -122,6 +122,47 @@ public class VirtualColumnNode extends ValueNode
 		return sourceColumn;
 	}
 
+	/**
+	 * Get the name of the table the ResultColumn is in, if any.  This will be null
+	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
+	 *
+	 * @return	A String containing the name of the table the Column
+	 *		is in. If the column is not in a table (i.e. is a
+	 * 		derived column), it returns NULL.
+	 */
+	public String getTableName()
+	{
+		return ( ( sourceColumn != null) ? sourceColumn.getTableName() : null );
+	}
+
+	/**
+	 * Get the name of the schema the ResultColumn's table is in, if any.
+	 * The return value will be null if the user did not supply a schema name
+	 * (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 *
+	 * @return	A String containing the name of the schema for the Column's table.
+	 *		If the column is not in a schema (i.e. derived column), it returns NULL.
+	 */
+	public String getSchemaName() throws StandardException
+	{
+		return ( ( sourceColumn != null) ? sourceColumn.getSchemaName() : null );
+	}
+
+	/**
+	 * Return whether or not the ResultColumn is wirtable by a positioned update.
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by a positioned update.
+	 */
+	public boolean updatableByCursor()
+	{
+		return ((sourceColumn != null) ? sourceColumn.updatableByCursor() : false);
+	}
+
 	/**
 	 * Return the ResultColumn that is the source of this VirtualColumnNode.
 	 *
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/resultset.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/resultset.out
index a80c9ce2b..b7a20e39c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/resultset.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/resultset.out
@@ -10,7 +10,7 @@ getColumnDisplaySize(1): 11
 getColumnLabel(1): I
 getColumnName(1): I
 getTableName(1): T
-getSchemaName(1): 
+getSchemaName(1): APP
 getCatalogName(1): 
 getColumnType(1): 4
 getPrecision(1): 10
@@ -28,7 +28,7 @@ getColumnDisplaySize(2): 6
 getColumnLabel(2): S
 getColumnName(2): S
 getTableName(2): T
-getSchemaName(2): 
+getSchemaName(2): APP
 getCatalogName(2): 
 getColumnType(2): 5
 getPrecision(2): 5
@@ -46,7 +46,7 @@ getColumnDisplaySize(3): 13
 getColumnLabel(3): R
 getColumnName(3): R
 getTableName(3): T
-getSchemaName(3): 
+getSchemaName(3): APP
 getCatalogName(3): 
 getColumnType(3): 7
 getPrecision(3): 7
@@ -64,7 +64,7 @@ getColumnDisplaySize(4): 22
 getColumnLabel(4): D
 getColumnName(4): D
 getTableName(4): T
-getSchemaName(4): 
+getSchemaName(4): APP
 getCatalogName(4): 
 getColumnType(4): 8
 getPrecision(4): 15
@@ -82,7 +82,7 @@ getColumnDisplaySize(5): 10
 getColumnLabel(5): DT
 getColumnName(5): DT
 getTableName(5): T
-getSchemaName(5): 
+getSchemaName(5): APP
 getCatalogName(5): 
 getColumnType(5): 91
 getPrecision(5): 10
@@ -100,7 +100,7 @@ getColumnDisplaySize(6): 8
 getColumnLabel(6): T
 getColumnName(6): T
 getTableName(6): T
-getSchemaName(6): 
+getSchemaName(6): APP
 getCatalogName(6): 
 getColumnType(6): 92
 getPrecision(6): 8
@@ -118,7 +118,7 @@ getColumnDisplaySize(7): 26
 getColumnLabel(7): TS
 getColumnName(7): TS
 getTableName(7): T
-getSchemaName(7): 
+getSchemaName(7): APP
 getCatalogName(7): 
 getColumnType(7): 93
 getPrecision(7): 26
@@ -136,7 +136,7 @@ getColumnDisplaySize(8): 10
 getColumnLabel(8): C
 getColumnName(8): C
 getTableName(8): T
-getSchemaName(8): 
+getSchemaName(8): APP
 getCatalogName(8): 
 getColumnType(8): 1
 getPrecision(8): 10
@@ -154,7 +154,7 @@ getColumnDisplaySize(9): 40
 getColumnLabel(9): V
 getColumnName(9): V
 getTableName(9): T
-getSchemaName(9): 
+getSchemaName(9): APP
 getCatalogName(9): 
 getColumnType(9): 12
 getPrecision(9): 40
@@ -172,7 +172,7 @@ getColumnDisplaySize(10): 12
 getColumnLabel(10): DC
 getColumnName(10): DC
 getTableName(10): T
-getSchemaName(10): 
+getSchemaName(10): APP
 getCatalogName(10): 
 getColumnType(10): 3
 getPrecision(10): 10
@@ -190,7 +190,7 @@ getColumnDisplaySize(11): 20
 getColumnLabel(11): BI
 getColumnName(11): BI
 getTableName(11): T
-getSchemaName(11): 
+getSchemaName(11): APP
 getCatalogName(11): 
 getColumnType(11): -5
 getPrecision(11): 19
@@ -208,7 +208,7 @@ getColumnDisplaySize(12): 20
 getColumnLabel(12): CBD
 getColumnName(12): CBD
 getTableName(12): T
-getSchemaName(12): 
+getSchemaName(12): APP
 getCatalogName(12): 
 getColumnType(12): -2
 getPrecision(12): 10
@@ -226,7 +226,7 @@ getColumnDisplaySize(13): 20
 getColumnLabel(13): VBD
 getColumnName(13): VBD
 getTableName(13): T
-getSchemaName(13): 
+getSchemaName(13): APP
 getCatalogName(13): 
 getColumnType(13): -3
 getPrecision(13): 10
@@ -244,7 +244,7 @@ getColumnDisplaySize(14): 65400
 getColumnLabel(14): LVBD
 getColumnName(14): LVBD
 getTableName(14): T
-getSchemaName(14): 
+getSchemaName(14): APP
 getCatalogName(14): 
 getColumnType(14): -4
 getPrecision(14): 32700
@@ -262,7 +262,7 @@ getColumnDisplaySize(15): 2147483647
 getColumnLabel(15): CL
 getColumnName(15): CL
 getTableName(15): T
-getSchemaName(15): 
+getSchemaName(15): APP
 getCatalogName(15): 
 getColumnType(15): 2005
 getPrecision(15): 2147483647
@@ -280,7 +280,7 @@ getColumnDisplaySize(16): -2147483648
 getColumnLabel(16): BL
 getColumnName(16): BL
 getTableName(16): T
-getSchemaName(16): 
+getSchemaName(16): APP
 getCatalogName(16): 
 getColumnType(16): 2004
 getPrecision(16): 1073741824
@@ -1011,4 +1011,28 @@ OK EQUALITY OBJECT RETURNED column 4 existing 1
 OK EQUALITY OBJECT RETURNED column 5 existing 1
 OK EQUALITY OBJECT RETURNED column 6 existing 1
 COMPLETE testMutableValues
+Run select * from s ss (f, e, d, c, b, a) where f = 0 and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from (select * from s) a and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Table name of second column is T1
+Schema name of second column is S1
+Run select abc.c11 from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Run select bcd.a, abc.c11 from s1.t1 as abc, s as bcd and then try getTableName and getSchemaName on columns
+Table name of first column is S
+Schema name of first column is APP
+Table name of second column is T1
+Schema name of second column is S1
+Run select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1 and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is APP1
+Table name of second column is T1
+Schema name of second column is APP2
 Test resultset finished
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
index 99fe8ddc4..9f5e61bc2 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
@@ -47,13 +47,88 @@ SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Now attempting to send a updateRow on a sql with no FOR UPDATE clause.
 SQL State : null
-Got expected exception Invalid operation: result set closed
+Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause
 Make sure that we got CONCUR_READ_ONLY? true
+Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode
+Will see the warnings in embedded mode only
 Now attempting to send a delete on a sql with FOR READ ONLY clause.
 SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Now attempting to send a updateRow on a sql with FOR READ ONLY clause.
 SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row
+Make sure that we got CONCUR_UPDATABLE? true
+Now attempt a deleteRow without first doing next on the resultset.
+SQL State : XCL08
+Got expected exception Cursor 'SQL_CURSH200C7' is not on a row.
+Now attempt a updateRow without first doing next on the resultset.
+In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
+In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not
+PASS!!! In Network Server mode, this updateRow is a no-op because no updateXXX were issued before the updateRow
+ResultSet is positioned after the last row. attempt to deleteRow at this point should fail!
+SQL State : null
+Got expected exception Invalid operation: result set closed
+ResultSet is positioned after the last row. attempt to updateRow at this point should fail!
+SQL State : null
+Got expected exception Invalid operation: result set closed
+Negative Test8 - attempt deleteRow & updateRow on updatable resultset after closing the resultset
+Make sure that we got CONCUR_UPDATABLE? true
+SQL State : null
+Got expected exception Invalid operation: result set closed
+SQL State : null
+Got expected exception Invalid operation: result set closed
+Negative Test9 - try updatable resultset on system table
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test10 - try updatable resultset on a view
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test11 - attempt to open updatable resultset when there is join in the select query should fail
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test12 - With autocommit on, attempt to drop a table when there is an open updatable resultset on it
+Opened an updatable resultset. Now trying to drop that table through another Statement
+SQL State : X0X95
+Got expected exception Operation 'DROP TABLE' cannot be performed on object 'T1' because there is an open ResultSet dependent on that object.
+Since autocommit is on, the drop table exception resulted in a runtime rollback causing updatable resultset object to close
+SQL State : 42X01
+Got expected exception Syntax error: Encountered "(" at line 1, column 19.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
+Negative Test13 - foreign key constraint failure will cause deleteRow to fail
+SQL State : 23503
+Got expected exception DELETE on table 'TABLEWITHPRIMARYKEY' caused a violation of foreign key constraint 'FK' for key (1,1).  The statement has been rolled back.
+Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close
+Jira entry Derby-160 : for Network Server because next should have failed
+FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback
+Negative Test14 - foreign key constraint failure will cause updateRow to fail
+SQL State : 42X01
+Got expected exception Syntax error: Encountered "(" at line 1, column 36.
+Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close
+Jira entry Derby-160 : for Network Server because next should have failed
+FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback
+Negative Test15 - Can't call updateXXX methods on columns that do not correspond to a column in the table
+SQL State : null
+Got expected exception Column not updatable
+Negative Test16 - Call updateXXX method on out of the range column
+There are only 2 columns in the select list and we are trying to send updateXXX on column position 3
+SQL State : null
+Got expected exception Invalid argument: parameter index 3 is out of range.
+Positive Test1a - request updatable resultset for forward only type resultset
+requested TYPE_FORWARD_ONLY, CONCUR_UPDATABLE
+got TYPE_FORWARD_ONLY? true
+got CONCUR_UPDATABLE? true
+JDBC 2.0 updatable resultset apis on this ResultSet object will pass because this is an updatable resultset
+column 1 on this row before deleteRow is 1
+column 2 on this row before deleteRow is aa                  
+Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX
+column 1 on this deleted row is 0
+calling deleteRow again w/o first positioning the ResultSet on the next row will fail
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
+Position the ResultSet with next()
+Should be able to deletRow() on the current row now
 Finished testing updateable resultsets
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/resultset.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/resultset.out
index 2103c6768..a92d557db 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/resultset.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/resultset.out
@@ -10,7 +10,7 @@ getColumnDisplaySize(1): 11
 getColumnLabel(1): I
 getColumnName(1): I
 getTableName(1): T
-getSchemaName(1): 
+getSchemaName(1): APP
 getCatalogName(1): 
 getColumnType(1): 4
 getPrecision(1): 10
@@ -28,7 +28,7 @@ getColumnDisplaySize(2): 6
 getColumnLabel(2): S
 getColumnName(2): S
 getTableName(2): T
-getSchemaName(2): 
+getSchemaName(2): APP
 getCatalogName(2): 
 getColumnType(2): 5
 getPrecision(2): 5
@@ -46,7 +46,7 @@ getColumnDisplaySize(3): 13
 getColumnLabel(3): R
 getColumnName(3): R
 getTableName(3): T
-getSchemaName(3): 
+getSchemaName(3): APP
 getCatalogName(3): 
 getColumnType(3): 7
 getPrecision(3): 7
@@ -64,7 +64,7 @@ getColumnDisplaySize(4): 22
 getColumnLabel(4): D
 getColumnName(4): D
 getTableName(4): T
-getSchemaName(4): 
+getSchemaName(4): APP
 getCatalogName(4): 
 getColumnType(4): 8
 getPrecision(4): 15
@@ -82,7 +82,7 @@ getColumnDisplaySize(5): 10
 getColumnLabel(5): DT
 getColumnName(5): DT
 getTableName(5): T
-getSchemaName(5): 
+getSchemaName(5): APP
 getCatalogName(5): 
 getColumnType(5): 91
 getPrecision(5): 10
@@ -100,7 +100,7 @@ getColumnDisplaySize(6): 8
 getColumnLabel(6): T
 getColumnName(6): T
 getTableName(6): T
-getSchemaName(6): 
+getSchemaName(6): APP
 getCatalogName(6): 
 getColumnType(6): 92
 getPrecision(6): 8
@@ -118,7 +118,7 @@ getColumnDisplaySize(7): 26
 getColumnLabel(7): TS
 getColumnName(7): TS
 getTableName(7): T
-getSchemaName(7): 
+getSchemaName(7): APP
 getCatalogName(7): 
 getColumnType(7): 93
 getPrecision(7): 26
@@ -136,7 +136,7 @@ getColumnDisplaySize(8): 10
 getColumnLabel(8): C
 getColumnName(8): C
 getTableName(8): T
-getSchemaName(8): 
+getSchemaName(8): APP
 getCatalogName(8): 
 getColumnType(8): 1
 getPrecision(8): 10
@@ -154,7 +154,7 @@ getColumnDisplaySize(9): 40
 getColumnLabel(9): V
 getColumnName(9): V
 getTableName(9): T
-getSchemaName(9): 
+getSchemaName(9): APP
 getCatalogName(9): 
 getColumnType(9): 12
 getPrecision(9): 40
@@ -172,7 +172,7 @@ getColumnDisplaySize(10): 12
 getColumnLabel(10): DC
 getColumnName(10): DC
 getTableName(10): T
-getSchemaName(10): 
+getSchemaName(10): APP
 getCatalogName(10): 
 getColumnType(10): 3
 getPrecision(10): 10
@@ -190,7 +190,7 @@ getColumnDisplaySize(11): 20
 getColumnLabel(11): BI
 getColumnName(11): BI
 getTableName(11): T
-getSchemaName(11): 
+getSchemaName(11): APP
 getCatalogName(11): 
 getColumnType(11): -5
 getPrecision(11): 19
@@ -208,7 +208,7 @@ getColumnDisplaySize(12): 20
 getColumnLabel(12): CBD
 getColumnName(12): CBD
 getTableName(12): T
-getSchemaName(12): 
+getSchemaName(12): APP
 getCatalogName(12): 
 getColumnType(12): -2
 getPrecision(12): 10
@@ -226,7 +226,7 @@ getColumnDisplaySize(13): 20
 getColumnLabel(13): VBD
 getColumnName(13): VBD
 getTableName(13): T
-getSchemaName(13): 
+getSchemaName(13): APP
 getCatalogName(13): 
 getColumnType(13): -3
 getPrecision(13): 10
@@ -244,7 +244,7 @@ getColumnDisplaySize(14): 65400
 getColumnLabel(14): LVBD
 getColumnName(14): LVBD
 getTableName(14): T
-getSchemaName(14): 
+getSchemaName(14): APP
 getCatalogName(14): 
 getColumnType(14): -4
 getPrecision(14): 32700
@@ -262,7 +262,7 @@ getColumnDisplaySize(15): 2147483647
 getColumnLabel(15): CL
 getColumnName(15): CL
 getTableName(15): T
-getSchemaName(15): 
+getSchemaName(15): APP
 getCatalogName(15): 
 getColumnType(15): 2005
 getPrecision(15): 2147483647
@@ -280,7 +280,7 @@ getColumnDisplaySize(16): -2147483648
 getColumnLabel(16): BL
 getColumnName(16): BL
 getTableName(16): T
-getSchemaName(16): 
+getSchemaName(16): APP
 getCatalogName(16): 
 getColumnType(16): 2004
 getPrecision(16): 1073741824
@@ -1011,4 +1011,28 @@ OK EQUALITY OBJECT RETURNED column 4 existing 1
 OK EQUALITY OBJECT RETURNED column 5 existing 1
 OK EQUALITY OBJECT RETURNED column 6 existing 1
 COMPLETE testMutableValues
+Run select * from s ss (f, e, d, c, b, a) where f = 0 and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from (select * from s) a and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Table name of second column is T1
+Schema name of second column is S1
+Run select abc.c11 from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Run select bcd.a, abc.c11 from s1.t1 as abc, s as bcd and then try getTableName and getSchemaName on columns
+Table name of first column is S
+Schema name of first column is APP
+Table name of second column is T1
+Schema name of second column is S1
+Run select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1 and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is APP1
+Table name of second column is T1
+Schema name of second column is APP2
 Test resultset finished
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
index cd38ad07b..98e7d43eb 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
@@ -47,13 +47,88 @@ SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Now attempting to send a updateRow on a sql with no FOR UPDATE clause.
 SQL State : null
-Got expected exception Invalid operation: result set closed
+Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause
 Make sure that we got CONCUR_READ_ONLY? true
+Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode
+Will see the warnings in embedded mode only
 Now attempting to send a delete on a sql with FOR READ ONLY clause.
 SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
 Now attempting to send a updateRow on a sql with FOR READ ONLY clause.
 SQL State : null
 Got expected exception This method cannot be invoked while the cursor is on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row
+Make sure that we got CONCUR_UPDATABLE? true
+Now attempt a deleteRow without first doing next on the resultset.
+SQL State : XCL08
+Got expected exception Cursor 'SQL_CURLH000C8' is not on a row.
+Now attempt a updateRow without first doing next on the resultset.
+In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
+In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not
+PASS!!! In Network Server mode, this updateRow is a no-op because no updateXXX were issued before the updateRow
+ResultSet is positioned after the last row. attempt to deleteRow at this point should fail!
+SQL State : null
+Got expected exception Invalid operation: result set closed
+ResultSet is positioned after the last row. attempt to updateRow at this point should fail!
+SQL State : null
+Got expected exception Invalid operation: result set closed
+Negative Test8 - attempt deleteRow & updateRow on updatable resultset after closing the resultset
+Make sure that we got CONCUR_UPDATABLE? true
+SQL State : null
+Got expected exception Invalid operation: result set closed
+SQL State : null
+Got expected exception Invalid operation: result set closed
+Negative Test9 - try updatable resultset on system table
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test10 - try updatable resultset on a view
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test11 - attempt to open updatable resultset when there is join in the select query should fail
+SQL State : 42Y90
+Got expected exception FOR UPDATE is not permitted on this type of statement.
+Negative Test12 - With autocommit on, attempt to drop a table when there is an open updatable resultset on it
+Opened an updatable resultset. Now trying to drop that table through another Statement
+SQL State : X0X95
+Got expected exception Operation 'DROP TABLE' cannot be performed on object 'T1' because there is an open ResultSet dependent on that object.
+Since autocommit is on, the drop table exception resulted in a runtime rollback causing updatable resultset object to close
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
+Negative Test13 - foreign key constraint failure will cause deleteRow to fail
+SQL State : 23503
+Got expected exception DELETE on table 'TABLEWITHPRIMARYKEY' caused a violation of foreign key constraint 'FK' for key (1,1).  The statement has been rolled back.
+Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close
+Jira entry Derby-160 : for Network Server because next should have failed
+FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback
+Negative Test14 - foreign key constraint failure will cause updateRow to fail
+SQL State : 23503
+Got expected exception UPDATE on table 'TABLEWITHPRIMARYKEY' caused a violation of foreign key constraint 'FK' for key (1,1).  The statement has been rolled back.
+Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close
+Jira entry Derby-160 : for Network Server because next should have failed
+FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback
+Negative Test15 - Can't call updateXXX methods on columns that do not correspond to a column in the table
+SQL State : null
+Got expected exception Column not updatable
+Negative Test16 - Call updateXXX method on out of the range column
+There are only 2 columns in the select list and we are trying to send updateXXX on column position 3
+SQL State : null
+Got expected exception Invalid argument: parameter index 3 is out of range.
+Positive Test1a - request updatable resultset for forward only type resultset
+requested TYPE_FORWARD_ONLY, CONCUR_UPDATABLE
+got TYPE_FORWARD_ONLY? true
+got CONCUR_UPDATABLE? true
+JDBC 2.0 updatable resultset apis on this ResultSet object will pass because this is an updatable resultset
+column 1 on this row before deleteRow is 1
+column 2 on this row before deleteRow is aa                  
+Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX
+column 1 on this deleted row is 0
+calling deleteRow again w/o first positioning the ResultSet on the next row will fail
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
+Position the ResultSet with next()
+Should be able to deletRow() on the current row now
 Finished testing updateable resultsets
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
index a98f69a8a..67fc236bf 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
@@ -51,6 +51,8 @@ SQL State : XJ083
 Got expected exception 'updateRow' not allowed because the ResultSet is not an updatable ResultSet. 
 Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause
 Make sure that we got CONCUR_READ_ONLY? true
+Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode
+Will see the warnings in embedded mode only
 Expected warnings on resultset = java.sql.SQLWarning: ResultSet not updatable. Query does not qualify to generate an updatable ResultSet.
 Now attempting to send a delete on a sql with FOR READ ONLY clause.
 SQL State : XJ083
@@ -64,6 +66,8 @@ Now attempt a deleteRow without first doing next on the resultset.
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 Now attempt a updateRow without first doing next on the resultset.
+In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
+In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 ResultSet is positioned after the last row. attempt to deleteRow at this point should fail!
@@ -122,7 +126,8 @@ got CONCUR_UPDATABLE? true
 JDBC 2.0 updatable resultset apis on this ResultSet object will pass because this is an updatable resultset
 column 1 on this row before deleteRow is 1
 column 2 on this row before deleteRow is aa                  
-Since after deleteRow(), ResultSet is positioned before the next row, getXXX will fail
+Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
@@ -135,7 +140,8 @@ column 1 on this row before updateInt is 1
 column 1 on this row after updateInt is 234
 column 2 on this row before updateString is aa                  
 now updateRow on the row
-Since after updateRow(), ResultSet is positioned before the next row, getXXX will fail
+Since after updateRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the updated row after updateRow and hence no error for getXXX
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 calling updateRow again w/o first positioning the ResultSet on the next row will fail
@@ -269,9 +275,29 @@ Table t1 after updateRow has following rows
 Positive Test9c - try to updateXXX on a readonly column. Should get error
 SQL State : 42X31
 Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR15'.
+attempt to get an updatable resultset using correlation name for an readonly column. It should work
+The sql is SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1
 Table t1 after updateRow has following rows
 	 C1,C2
 	 -- --
+	{11,aa                  }
+	{2,bb                  }
+	{3,cc                  }
+Positive Test9c - try to updateXXX on a readonly column. Should get error
+SQL State : 42X31
+Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR17'.
+Table t1 has following rows
+	 C1,C2
+	 -- --
+	{1,aa                  }
+	{2,bb                  }
+	{3,cc                  }
+Positive Test9d - try to updateXXX on a readonly column with correlation name. Should get error
+SQL State : 42X31
+Got expected exception Column 'COL2' is not in FOR UPDATE list of cursor 'SQLCUR18'.
+Table t1 has following rows
+	 C1,C2
+	 -- --
 	{1,aa                  }
 	{2,bb                  }
 	{3,cc                  }
@@ -279,7 +305,7 @@ Positive Test10 - 2 updatable resultsets going against the same table, will they
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
 SQL State : XCL08
-Got expected exception Cursor 'SQLCUR17' is not on a row.
+Got expected exception Cursor 'SQLCUR20' is not on a row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
@@ -3046,7 +3072,7 @@ Positive Test32 - call updateXXX methods on column that is not in for update col
 	{2,bb                  }
 	{3,cc                  }
 SQL State : 42X31
-Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR536'.
+Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR539'.
   Make sure the contents of table are unchanged
 	 C1,C2
 	 -- --
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/resultset.out b/java/testing/org/apache/derbyTesting/functionTests/master/resultset.out
index abec5222b..c5360a625 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/resultset.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/resultset.out
@@ -10,7 +10,7 @@ getColumnDisplaySize(1): 11
 getColumnLabel(1): I
 getColumnName(1): I
 getTableName(1): T
-getSchemaName(1): 
+getSchemaName(1): APP
 getCatalogName(1): 
 getColumnType(1): 4
 getPrecision(1): 10
@@ -29,7 +29,7 @@ getColumnDisplaySize(2): 6
 getColumnLabel(2): S
 getColumnName(2): S
 getTableName(2): T
-getSchemaName(2): 
+getSchemaName(2): APP
 getCatalogName(2): 
 getColumnType(2): 5
 getPrecision(2): 5
@@ -48,7 +48,7 @@ getColumnDisplaySize(3): 13
 getColumnLabel(3): R
 getColumnName(3): R
 getTableName(3): T
-getSchemaName(3): 
+getSchemaName(3): APP
 getCatalogName(3): 
 getColumnType(3): 7
 getPrecision(3): 7
@@ -67,7 +67,7 @@ getColumnDisplaySize(4): 22
 getColumnLabel(4): D
 getColumnName(4): D
 getTableName(4): T
-getSchemaName(4): 
+getSchemaName(4): APP
 getCatalogName(4): 
 getColumnType(4): 8
 getPrecision(4): 15
@@ -86,7 +86,7 @@ getColumnDisplaySize(5): 10
 getColumnLabel(5): DT
 getColumnName(5): DT
 getTableName(5): T
-getSchemaName(5): 
+getSchemaName(5): APP
 getCatalogName(5): 
 getColumnType(5): 91
 getPrecision(5): 10
@@ -105,7 +105,7 @@ getColumnDisplaySize(6): 8
 getColumnLabel(6): T
 getColumnName(6): T
 getTableName(6): T
-getSchemaName(6): 
+getSchemaName(6): APP
 getCatalogName(6): 
 getColumnType(6): 92
 getPrecision(6): 0
@@ -124,7 +124,7 @@ getColumnDisplaySize(7): 26
 getColumnLabel(7): TS
 getColumnName(7): TS
 getTableName(7): T
-getSchemaName(7): 
+getSchemaName(7): APP
 getCatalogName(7): 
 getColumnType(7): 93
 getPrecision(7): 0
@@ -143,7 +143,7 @@ getColumnDisplaySize(8): 10
 getColumnLabel(8): C
 getColumnName(8): C
 getTableName(8): T
-getSchemaName(8): 
+getSchemaName(8): APP
 getCatalogName(8): 
 getColumnType(8): 1
 getPrecision(8): 10
@@ -162,7 +162,7 @@ getColumnDisplaySize(9): 40
 getColumnLabel(9): V
 getColumnName(9): V
 getTableName(9): T
-getSchemaName(9): 
+getSchemaName(9): APP
 getCatalogName(9): 
 getColumnType(9): 12
 getPrecision(9): 40
@@ -181,7 +181,7 @@ getColumnDisplaySize(10): 13
 getColumnLabel(10): DC
 getColumnName(10): DC
 getTableName(10): T
-getSchemaName(10): 
+getSchemaName(10): APP
 getCatalogName(10): 
 getColumnType(10): 3
 getPrecision(10): 10
@@ -200,7 +200,7 @@ getColumnDisplaySize(11): 20
 getColumnLabel(11): BI
 getColumnName(11): BI
 getTableName(11): T
-getSchemaName(11): 
+getSchemaName(11): APP
 getCatalogName(11): 
 getColumnType(11): -5
 getPrecision(11): 19
@@ -219,7 +219,7 @@ getColumnDisplaySize(12): 20
 getColumnLabel(12): CBD
 getColumnName(12): CBD
 getTableName(12): T
-getSchemaName(12): 
+getSchemaName(12): APP
 getCatalogName(12): 
 getColumnType(12): -2
 getPrecision(12): 10
@@ -238,7 +238,7 @@ getColumnDisplaySize(13): 20
 getColumnLabel(13): VBD
 getColumnName(13): VBD
 getTableName(13): T
-getSchemaName(13): 
+getSchemaName(13): APP
 getCatalogName(13): 
 getColumnType(13): -3
 getPrecision(13): 10
@@ -257,7 +257,7 @@ getColumnDisplaySize(14): 65400
 getColumnLabel(14): LVBD
 getColumnName(14): LVBD
 getTableName(14): T
-getSchemaName(14): 
+getSchemaName(14): APP
 getCatalogName(14): 
 getColumnType(14): -4
 getPrecision(14): 32700
@@ -276,7 +276,7 @@ getColumnDisplaySize(15): 2147483647
 getColumnLabel(15): CL
 getColumnName(15): CL
 getTableName(15): T
-getSchemaName(15): 
+getSchemaName(15): APP
 getCatalogName(15): 
 getColumnType(15): 2005
 getPrecision(15): 2147483647
@@ -295,7 +295,7 @@ getColumnDisplaySize(16): 2147483647
 getColumnLabel(16): BL
 getColumnName(16): BL
 getTableName(16): T
-getSchemaName(16): 
+getSchemaName(16): APP
 getCatalogName(16): 
 getColumnType(16): 2004
 getPrecision(16): 1073741824
@@ -1011,4 +1011,28 @@ OK EQUALITY OBJECT RETURNED column 4 existing 1
 OK EQUALITY OBJECT RETURNED column 5 existing 1
 OK EQUALITY OBJECT RETURNED column 6 existing 1
 COMPLETE testMutableValues
+Run select * from s ss (f, e, d, c, b, a) where f = 0 and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from (select * from s) a and then try getTableName and getSchemaName on columns
+getTableName(1): S
+getSchemaName(1): APP
+Run select * from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Table name of second column is T1
+Schema name of second column is S1
+Run select abc.c11 from s1.t1 as abc and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is S1
+Run select bcd.a, abc.c11 from s1.t1 as abc, s as bcd and then try getTableName and getSchemaName on columns
+Table name of first column is S
+Schema name of first column is APP
+Table name of second column is T1
+Schema name of second column is S1
+Run select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1 and then try getTableName and getSchemaName on columns
+Table name of first column is T1
+Schema name of first column is APP1
+Table name of second column is T1
+Schema name of second column is APP2
 Test resultset finished
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
index e86ac3083..24c3ffd4e 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
@@ -51,6 +51,8 @@ SQL State : XJ083
 Got expected exception 'updateRow' not allowed because the ResultSet is not an updatable ResultSet. 
 Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause
 Make sure that we got CONCUR_READ_ONLY? true
+Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode
+Will see the warnings in embedded mode only
 Expected warnings on resultset = java.sql.SQLWarning: ResultSet not updatable. Query does not qualify to generate an updatable ResultSet.
 Now attempting to send a delete on a sql with FOR READ ONLY clause.
 SQL State : XJ083
@@ -64,6 +66,8 @@ Now attempt a deleteRow without first doing next on the resultset.
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 Now attempt a updateRow without first doing next on the resultset.
+In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
+In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 ResultSet is positioned after the last row. attempt to deleteRow at this point should fail!
@@ -122,7 +126,8 @@ got CONCUR_UPDATABLE? true
 JDBC 2.0 updatable resultset apis on this ResultSet object will pass because this is an updatable resultset
 column 1 on this row before deleteRow is 1
 column 2 on this row before deleteRow is aa                  
-Since after deleteRow(), ResultSet is positioned before the next row, getXXX will fail
+Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
@@ -135,7 +140,8 @@ column 1 on this row before updateInt is 1
 column 1 on this row after updateInt is 234
 column 2 on this row before updateString is aa                  
 now updateRow on the row
-Since after updateRow(), ResultSet is positioned before the next row, getXXX will fail
+Since after updateRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail
+In Network Server mode, the ResultSet stays on the updated row after updateRow and hence no error for getXXX
 SQL State : 24000
 Got expected exception Invalid cursor state - no current row.
 calling updateRow again w/o first positioning the ResultSet on the next row will fail
@@ -269,9 +275,29 @@ Table t1 after updateRow has following rows
 Positive Test9c - try to updateXXX on a readonly column. Should get error
 SQL State : 42X31
 Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR15'.
+attempt to get an updatable resultset using correlation name for an readonly column. It should work
+The sql is SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1
 Table t1 after updateRow has following rows
 	 C1,C2
 	 -- --
+	{11,aa                  }
+	{2,bb                  }
+	{3,cc                  }
+Positive Test9c - try to updateXXX on a readonly column. Should get error
+SQL State : 42X31
+Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR17'.
+Table t1 has following rows
+	 C1,C2
+	 -- --
+	{1,aa                  }
+	{2,bb                  }
+	{3,cc                  }
+Positive Test9d - try to updateXXX on a readonly column with correlation name. Should get error
+SQL State : 42X31
+Got expected exception Column 'COL2' is not in FOR UPDATE list of cursor 'SQLCUR18'.
+Table t1 has following rows
+	 C1,C2
+	 -- --
 	{1,aa                  }
 	{2,bb                  }
 	{3,cc                  }
@@ -279,7 +305,7 @@ Positive Test10 - 2 updatable resultsets going against the same table, will they
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
 SQL State : XCL08
-Got expected exception Cursor 'SQLCUR17' is not on a row.
+Got expected exception Cursor 'SQLCUR20' is not on a row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
@@ -563,7 +589,9 @@ Positive Test20 - Test updateXXX methods as the first updatable ResultSet api on
   Got expected exception : 'updateBinaryStream' not allowed because the ResultSet is not an updatable ResultSet. 
   Test updateClob on a readonly resultset
   Using column position as first parameter to updateClob
+  Got expected exception : 'updateClob' not allowed because the ResultSet is not an updatable ResultSet. 
   Using column name as first parameter to updateClob
+  Got expected exception : 'updateClob' not allowed because the ResultSet is not an updatable ResultSet. 
   Test updateDate on a readonly resultset
   Using column position as first parameter to updateDate
   Got expected exception : 'updateDate' not allowed because the ResultSet is not an updatable ResultSet. 
@@ -581,7 +609,9 @@ Positive Test20 - Test updateXXX methods as the first updatable ResultSet api on
   Got expected exception : 'updateTimestamp' not allowed because the ResultSet is not an updatable ResultSet. 
   Test updateBlob on a readonly resultset
   Using column position as first parameter to updateBlob
+  Got expected exception : 'updateBlob' not allowed because the ResultSet is not an updatable ResultSet. 
   Using column name as first parameter to updateBlob
+  Got expected exception : 'updateBlob' not allowed because the ResultSet is not an updatable ResultSet. 
   Test updateBoolean on a readonly resultset
   Using column position as first parameter to updateBoolean
   Got expected exception : 'updateBoolean' not allowed because the ResultSet is not an updatable ResultSet. 
@@ -594,10 +624,14 @@ Positive Test20 - Test updateXXX methods as the first updatable ResultSet api on
   Got expected exception : 'updateNull' not allowed because the ResultSet is not an updatable ResultSet. 
   Test updateArray on a readonly resultset
   Using column position as first parameter to updateArray
+  Got expected exception : Feature not implemented: no details.
   Using column name as first parameter to updateArray
+  Got expected exception : Feature not implemented: no details.
   Test updateRef on a readonly resultset
   Using column position as first parameter to updateRef
+  Got expected exception : Feature not implemented: no details.
   Using column name as first parameter to updateRef
+  Got expected exception : Feature not implemented: no details.
 Positive Test21 - Test all updateXXX(excluding updateObject) methods on all the supported sql datatypes
 Next datatype to test is SMALLINT
   Testing updateShort on SQL type SMALLINT
@@ -646,7 +680,9 @@ Next datatype to test is SMALLINT
       Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type SMALLINT
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type SMALLINT
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'SMALLINT'.
@@ -664,7 +700,9 @@ Next datatype to test is SMALLINT
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'SMALLINT'.
   Testing updateBlob on SQL type SMALLINT
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type SMALLINT
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -673,10 +711,14 @@ Next datatype to test is SMALLINT
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type SMALLINT
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type SMALLINT
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is INTEGER
   Testing updateShort on SQL type INTEGER
     Using column position as first parameter to updateShort
@@ -724,7 +766,9 @@ Next datatype to test is INTEGER
       Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type INTEGER
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type INTEGER
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'INTEGER'.
@@ -742,7 +786,9 @@ Next datatype to test is INTEGER
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'INTEGER'.
   Testing updateBlob on SQL type INTEGER
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type INTEGER
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -751,10 +797,14 @@ Next datatype to test is INTEGER
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type INTEGER
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type INTEGER
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is BIGINT
   Testing updateShort on SQL type BIGINT
     Using column position as first parameter to updateShort
@@ -802,7 +852,9 @@ Next datatype to test is BIGINT
       Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type BIGINT
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type BIGINT
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'BIGINT'.
@@ -820,7 +872,9 @@ Next datatype to test is BIGINT
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'BIGINT'.
   Testing updateBlob on SQL type BIGINT
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type BIGINT
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -829,10 +883,14 @@ Next datatype to test is BIGINT
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type BIGINT
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type BIGINT
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is DECIMAL(10,5)
   Testing updateShort on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateShort
@@ -880,7 +938,9 @@ Next datatype to test is DECIMAL(10,5)
       Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'DECIMAL'.
@@ -898,7 +958,9 @@ Next datatype to test is DECIMAL(10,5)
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DECIMAL'.
   Testing updateBlob on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -907,10 +969,14 @@ Next datatype to test is DECIMAL(10,5)
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type DECIMAL(10,5)
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is REAL
   Testing updateShort on SQL type REAL
     Using column position as first parameter to updateShort
@@ -958,7 +1024,9 @@ Next datatype to test is REAL
       Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type REAL
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type REAL
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'REAL'.
@@ -976,7 +1044,9 @@ Next datatype to test is REAL
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'REAL'.
   Testing updateBlob on SQL type REAL
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type REAL
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -985,10 +1055,14 @@ Next datatype to test is REAL
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type REAL
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type REAL
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is DOUBLE
   Testing updateShort on SQL type DOUBLE
     Using column position as first parameter to updateShort
@@ -1036,7 +1110,9 @@ Next datatype to test is DOUBLE
       Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type DOUBLE
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type DOUBLE
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'DOUBLE'.
@@ -1054,7 +1130,9 @@ Next datatype to test is DOUBLE
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DOUBLE'.
   Testing updateBlob on SQL type DOUBLE
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type DOUBLE
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -1063,10 +1141,14 @@ Next datatype to test is DOUBLE
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type DOUBLE
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type DOUBLE
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is CHAR(60)
   Testing updateShort on SQL type CHAR(60)
     Using column position as first parameter to updateShort
@@ -1108,7 +1190,9 @@ Next datatype to test is CHAR(60)
       Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type CHAR(60)
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type CHAR(60)
     Using column position as first parameter to updateDate
     Using column name as first parameter to updateDate
@@ -1120,7 +1204,9 @@ Next datatype to test is CHAR(60)
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type CHAR(60)
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type CHAR(60)
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -1129,10 +1215,14 @@ Next datatype to test is CHAR(60)
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type CHAR(60)
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type CHAR(60)
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is VARCHAR(60)
   Testing updateShort on SQL type VARCHAR(60)
     Using column position as first parameter to updateShort
@@ -1174,7 +1264,9 @@ Next datatype to test is VARCHAR(60)
       Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type VARCHAR(60)
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type VARCHAR(60)
     Using column position as first parameter to updateDate
     Using column name as first parameter to updateDate
@@ -1186,7 +1278,9 @@ Next datatype to test is VARCHAR(60)
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type VARCHAR(60)
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type VARCHAR(60)
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -1195,10 +1289,14 @@ Next datatype to test is VARCHAR(60)
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type VARCHAR(60)
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type VARCHAR(60)
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is LONG VARCHAR
   Testing updateShort on SQL type LONG VARCHAR
     Using column position as first parameter to updateShort
@@ -1240,7 +1338,9 @@ Next datatype to test is LONG VARCHAR
       Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type LONG VARCHAR
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type LONG VARCHAR
     Using column position as first parameter to updateDate
     Using column name as first parameter to updateDate
@@ -1252,7 +1352,9 @@ Next datatype to test is LONG VARCHAR
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type LONG VARCHAR
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type LONG VARCHAR
     Using column position as first parameter to updateBoolean
     Using column name as first parameter to updateBoolean
@@ -1261,10 +1363,14 @@ Next datatype to test is LONG VARCHAR
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type LONG VARCHAR
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type LONG VARCHAR
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is CHAR(2) FOR BIT DATA
   Testing updateShort on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateShort
@@ -1324,7 +1430,9 @@ Next datatype to test is CHAR(2) FOR BIT DATA
     Using column name as first parameter to updateBinaryStream
   Testing updateClob on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'CHAR () FOR BIT DATA'.
@@ -1342,7 +1450,9 @@ Next datatype to test is CHAR(2) FOR BIT DATA
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CHAR () FOR BIT DATA'.
   Testing updateBlob on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'CHAR () FOR BIT DATA'.
@@ -1353,10 +1463,14 @@ Next datatype to test is CHAR(2) FOR BIT DATA
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type CHAR(2) FOR BIT DATA
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is VARCHAR(2) FOR BIT DATA
   Testing updateShort on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateShort
@@ -1416,7 +1530,9 @@ Next datatype to test is VARCHAR(2) FOR BIT DATA
     Using column name as first parameter to updateBinaryStream
   Testing updateClob on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'VARCHAR () FOR BIT DATA'.
@@ -1434,7 +1550,9 @@ Next datatype to test is VARCHAR(2) FOR BIT DATA
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'VARCHAR () FOR BIT DATA'.
   Testing updateBlob on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'VARCHAR () FOR BIT DATA'.
@@ -1445,10 +1563,14 @@ Next datatype to test is VARCHAR(2) FOR BIT DATA
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type VARCHAR(2) FOR BIT DATA
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is LONG VARCHAR FOR BIT DATA
   Testing updateShort on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateShort
@@ -1508,7 +1630,9 @@ Next datatype to test is LONG VARCHAR FOR BIT DATA
     Using column name as first parameter to updateBinaryStream
   Testing updateClob on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
@@ -1526,7 +1650,9 @@ Next datatype to test is LONG VARCHAR FOR BIT DATA
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
   Testing updateBlob on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
@@ -1537,10 +1663,14 @@ Next datatype to test is LONG VARCHAR FOR BIT DATA
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type LONG VARCHAR FOR BIT DATA
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is CLOB(1k)
   Testing updateShort on SQL type CLOB(1k)
     Using column position as first parameter to updateShort
@@ -1616,7 +1746,9 @@ Next datatype to test is CLOB(1k)
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CLOB'.
   Testing updateBlob on SQL type CLOB(1k)
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CLOB' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'CLOB' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type CLOB(1k)
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'CLOB'.
@@ -1627,10 +1759,14 @@ Next datatype to test is CLOB(1k)
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type CLOB(1k)
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type CLOB(1k)
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is DATE
   Testing updateShort on SQL type DATE
     Using column position as first parameter to updateShort
@@ -1694,7 +1830,9 @@ Next datatype to test is DATE
       Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type DATE
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type DATE
     Using column position as first parameter to updateDate
     Using column name as first parameter to updateDate
@@ -1708,7 +1846,9 @@ Next datatype to test is DATE
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type DATE
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type DATE
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'DATE'.
@@ -1719,10 +1859,14 @@ Next datatype to test is DATE
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type DATE
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type DATE
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is TIME
   Testing updateShort on SQL type TIME
     Using column position as first parameter to updateShort
@@ -1786,7 +1930,9 @@ Next datatype to test is TIME
       Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type TIME
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type TIME
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'TIME'.
@@ -1800,7 +1946,9 @@ Next datatype to test is TIME
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type TIME
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type TIME
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'TIME'.
@@ -1811,10 +1959,14 @@ Next datatype to test is TIME
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type TIME
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type TIME
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is TIMESTAMP
   Testing updateShort on SQL type TIMESTAMP
     Using column position as first parameter to updateShort
@@ -1878,7 +2030,9 @@ Next datatype to test is TIMESTAMP
       Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.io.InputStream'.
   Testing updateClob on SQL type TIMESTAMP
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type TIMESTAMP
     Using column position as first parameter to updateDate
     Using column name as first parameter to updateDate
@@ -1890,7 +2044,9 @@ Next datatype to test is TIMESTAMP
     Using column name as first parameter to updateTimestamp
   Testing updateBlob on SQL type TIMESTAMP
     Using column position as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Blob'.
     Using column name as first parameter to updateBlob
+      Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Blob'.
   Testing updateBoolean on SQL type TIMESTAMP
     Using column position as first parameter to updateBoolean
       Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'TIMESTAMP'.
@@ -1901,10 +2057,14 @@ Next datatype to test is TIMESTAMP
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type TIMESTAMP
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type TIMESTAMP
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Next datatype to test is BLOB(1k)
   Testing updateShort on SQL type BLOB(1k)
     Using column position as first parameter to updateShort
@@ -1964,7 +2124,9 @@ Next datatype to test is BLOB(1k)
     Using column name as first parameter to updateBinaryStream
   Testing updateClob on SQL type BLOB(1k)
     Using column position as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'BLOB' from a data value of type 'java.sql.Clob'.
     Using column name as first parameter to updateClob
+      Got expected exception : An attempt was made to get a data value of type 'BLOB' from a data value of type 'java.sql.Clob'.
   Testing updateDate on SQL type BLOB(1k)
     Using column position as first parameter to updateDate
       Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'BLOB'.
@@ -1993,10 +2155,14 @@ Next datatype to test is BLOB(1k)
     Using column name as first parameter to updateNull
   Testing updateArray on SQL type BLOB(1k)
     Using column position as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateArray
+      Got expected exception : Feature not implemented: no details.
   Testing updateRef on SQL type BLOB(1k)
     Using column position as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
     Using column name as first parameter to updateRef
+      Got expected exception : Feature not implemented: no details.
 Positive Test22 - Test updateObject method
 Next datatype to test is SMALLINT
   updateObject with column position & Short object as parameters
@@ -2017,6 +2183,10 @@ Next datatype to test is SMALLINT
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'SMALLINT'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'SMALLINT'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'SMALLINT'.
   updateObject with column name & Date object as parameters
@@ -2029,6 +2199,10 @@ Next datatype to test is SMALLINT
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'SMALLINT'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'SMALLINT'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'SMALLINT' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2052,6 +2226,10 @@ Next datatype to test is INTEGER
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'INTEGER'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'INTEGER'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'INTEGER'.
   updateObject with column name & Date object as parameters
@@ -2064,6 +2242,10 @@ Next datatype to test is INTEGER
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'INTEGER'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'INTEGER'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'INTEGER' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2087,6 +2269,10 @@ Next datatype to test is BIGINT
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'BIGINT'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'BIGINT'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'BIGINT'.
   updateObject with column name & Date object as parameters
@@ -2099,6 +2285,10 @@ Next datatype to test is BIGINT
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'BIGINT'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'BIGINT'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BIGINT' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2122,6 +2312,10 @@ Next datatype to test is DECIMAL(10,5)
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DECIMAL'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DECIMAL'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'DECIMAL'.
   updateObject with column name & Date object as parameters
@@ -2134,6 +2328,10 @@ Next datatype to test is DECIMAL(10,5)
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DECIMAL'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DECIMAL'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DECIMAL' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2157,6 +2355,10 @@ Next datatype to test is REAL
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'REAL'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'REAL'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'REAL'.
   updateObject with column name & Date object as parameters
@@ -2169,6 +2371,10 @@ Next datatype to test is REAL
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'REAL'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'REAL'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'REAL' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2192,6 +2398,10 @@ Next datatype to test is DOUBLE
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DOUBLE'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DOUBLE'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'DOUBLE'.
   updateObject with column name & Date object as parameters
@@ -2204,6 +2414,10 @@ Next datatype to test is DOUBLE
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DOUBLE'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'DOUBLE'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DOUBLE' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2225,12 +2439,20 @@ Next datatype to test is CHAR(60)
   updateObject with column name & String object as parameters
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
   updateObject with column name & Date object as parameters
   updateObject with column position & Time object as parameters
   updateObject with column name & Time object as parameters
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2252,12 +2474,20 @@ Next datatype to test is VARCHAR(60)
   updateObject with column name & String object as parameters
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
   updateObject with column name & Date object as parameters
   updateObject with column position & Time object as parameters
   updateObject with column name & Time object as parameters
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2279,12 +2509,20 @@ Next datatype to test is LONG VARCHAR
   updateObject with column name & String object as parameters
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
   updateObject with column name & Date object as parameters
   updateObject with column position & Time object as parameters
   updateObject with column name & Time object as parameters
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
   updateObject with column name & Boolean object as parameters
   updateObject with column position & null as parameters
@@ -2320,6 +2558,10 @@ Next datatype to test is CHAR(2) FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.lang.String' into a data value of type 'CHAR () FOR BIT DATA'.
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'CHAR () FOR BIT DATA'.
   updateObject with column name & Date object as parameters
@@ -2332,6 +2574,10 @@ Next datatype to test is CHAR(2) FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CHAR () FOR BIT DATA'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CHAR () FOR BIT DATA'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'CHAR () FOR BIT DATA'.
   updateObject with column name & Boolean object as parameters
@@ -2369,6 +2615,10 @@ Next datatype to test is VARCHAR(2) FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.lang.String' into a data value of type 'VARCHAR () FOR BIT DATA'.
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'VARCHAR () FOR BIT DATA'.
   updateObject with column name & Date object as parameters
@@ -2381,6 +2631,10 @@ Next datatype to test is VARCHAR(2) FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'VARCHAR () FOR BIT DATA'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'VARCHAR () FOR BIT DATA'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'VARCHAR () FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'VARCHAR () FOR BIT DATA'.
   updateObject with column name & Boolean object as parameters
@@ -2418,6 +2672,10 @@ Next datatype to test is LONG VARCHAR FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.lang.String' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
   updateObject with column name & Date object as parameters
@@ -2430,6 +2688,10 @@ Next datatype to test is LONG VARCHAR FOR BIT DATA
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'LONG VARCHAR FOR BIT DATA' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'LONG VARCHAR FOR BIT DATA'.
   updateObject with column name & Boolean object as parameters
@@ -2467,6 +2729,8 @@ Next datatype to test is CLOB(1k)
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'CLOB'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'CLOB'.
+  updateObject with column position & Clob object as parameters
+  updateObject with column name & Clob object as parameters
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'CLOB'.
   updateObject with column name & Date object as parameters
@@ -2479,6 +2743,10 @@ Next datatype to test is CLOB(1k)
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CLOB'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'CLOB'.
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CLOB' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'CLOB' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'CLOB'.
   updateObject with column name & Boolean object as parameters
@@ -2518,6 +2786,10 @@ Next datatype to test is DATE
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DATE'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'DATE'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
   updateObject with column name & Date object as parameters
   updateObject with column position & Time object as parameters
@@ -2526,6 +2798,10 @@ Next datatype to test is DATE
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Time' into a data value of type 'DATE'.
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'DATE' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'DATE'.
   updateObject with column name & Boolean object as parameters
@@ -2565,6 +2841,10 @@ Next datatype to test is TIME
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'TIME'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'TIME'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'TIME'.
   updateObject with column name & Date object as parameters
@@ -2573,6 +2853,10 @@ Next datatype to test is TIME
   updateObject with column name & Time object as parameters
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIME' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'TIME'.
   updateObject with column name & Boolean object as parameters
@@ -2612,12 +2896,20 @@ Next datatype to test is TIMESTAMP
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'TIMESTAMP'.
   updateObject with column name & bytes[] array as parameters
     Got expected exception : An attempt was made to put a data value of type 'byte[]' into a data value of type 'TIMESTAMP'.
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
   updateObject with column name & Date object as parameters
   updateObject with column position & Time object as parameters
   updateObject with column name & Time object as parameters
   updateObject with column position & TimeStamp object as parameters
   updateObject with column name & TimeStamp object as parameters
+  updateObject with column position & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Blob'.
+  updateObject with column name & Blob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'TIMESTAMP' from a data value of type 'java.sql.Blob'.
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'TIMESTAMP'.
   updateObject with column name & Boolean object as parameters
@@ -2655,6 +2947,10 @@ Next datatype to test is BLOB(1k)
     Got expected exception : An attempt was made to put a data value of type 'java.lang.String' into a data value of type 'BLOB'.
   updateObject with column position & bytes[] array as parameters
   updateObject with column name & bytes[] array as parameters
+  updateObject with column position & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BLOB' from a data value of type 'java.sql.Clob'.
+  updateObject with column name & Clob object as parameters
+    Got expected exception : An attempt was made to get a data value of type 'BLOB' from a data value of type 'java.sql.Clob'.
   updateObject with column position & Date object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Date' into a data value of type 'BLOB'.
   updateObject with column name & Date object as parameters
@@ -2667,6 +2963,8 @@ Next datatype to test is BLOB(1k)
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'BLOB'.
   updateObject with column name & TimeStamp object as parameters
     Got expected exception : An attempt was made to put a data value of type 'java.sql.Timestamp' into a data value of type 'BLOB'.
+  updateObject with column position & Blob object as parameters
+  updateObject with column name & Blob object as parameters
   updateObject with column position & Boolean object as parameters
     Got expected exception : An attempt was made to put a data value of type 'boolean' into a data value of type 'BLOB'.
   updateObject with column name & Boolean object as parameters
@@ -2689,6 +2987,8 @@ Positive Test23 - Test cancelRowUpdates after updateXXX methods on all the suppo
   updateDate and then cancelRowUpdates
   updateTime and then cancelRowUpdates
   updateTimestamp and then cancelRowUpdates
+  updateClob and then cancelRowUpdates
+  updateBlob and then cancelRowUpdates
 Positive Test24a - after updateXXX, try cancelRowUpdates and then deleteRow
 column 1 on this row before updateInt is 1
 column 1 on this row after updateInt is 234
@@ -2772,7 +3072,7 @@ Positive Test32 - call updateXXX methods on column that is not in for update col
 	{2,bb                  }
 	{3,cc                  }
 SQL State : 42X31
-Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR528'.
+Got expected exception Column 'C2' is not in FOR UPDATE list of cursor 'SQLCUR539'.
   Make sure the contents of table are unchanged
 	 C1,C2
 	 -- --
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
index f1f145896..0d05f6997 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
@@ -88,7 +88,7 @@ public class resultset {
 
 			stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
 									   ResultSet.CONCUR_UPDATABLE);
-			
+
 			// REMIND: might want a usertype case as well...
 			stmt.execute("create table t (i int, s smallint, r real, "+
 				"d double precision, dt date, t time, ts timestamp, "+
@@ -132,7 +132,7 @@ public class resultset {
 				System.out.println("isReadOnly("+i+"): "+met.isReadOnly(i));
 				boolean writable = met.isWritable(i);
 				// JCC Supports updatable resultsets so isWritable is true
-				if ((isDerbyNet && writable == true) || 
+				if ((isDerbyNet && writable == true) ||
 					(!isDerbyNet && writable == false))
 					System.out.println("isWritable("+i+"): Expected isWritable value");
 				System.out.println("isDefinitelyWritable("+i+"): "+met.isDefinitelyWritable(i));
@@ -525,6 +525,7 @@ public class resultset {
 			stmt.close();
 
 			testMutableValues(con);
+			testCorrelationNamesAndMetaDataCalls(con);
 			con.close();
 
 		}
@@ -541,6 +542,64 @@ public class resultset {
     }
 
 
+	static private void testCorrelationNamesAndMetaDataCalls(Connection conn) throws Exception
+	{
+		Statement stmt = conn.createStatement();
+		stmt.executeUpdate("create table s (a int, b int, c int, d int, e int, f int)");
+		stmt.executeUpdate("insert into s values (0,1,2,3,4,5)");
+		stmt.executeUpdate("insert into s values (10,11,12,13,14,15)");
+		System.out.println("Run select * from s ss (f, e, d, c, b, a) where f = 0 and then try getTableName and getSchemaName on columns");
+		ResultSet rs = stmt.executeQuery("select * from s ss (f, e, d, c, b, a) where f = 0");
+    rs.next();
+    ResultSetMetaData met = rs.getMetaData();
+		System.out.println("getTableName(1): "+met.getTableName(1));
+		System.out.println("getSchemaName(1): "+met.getSchemaName(1));
+
+		System.out.println("Run select * from (select * from s) a and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select * from (select * from s) a");
+    rs.next();
+    met = rs.getMetaData();
+		System.out.println("getTableName(1): "+met.getTableName(1));
+		System.out.println("getSchemaName(1): "+met.getSchemaName(1));
+
+		stmt.executeUpdate("create schema s1");
+		stmt.executeUpdate("create table s1.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into s1.t1 values (11, 12), (21, 22)");
+		System.out.println("Run select * from s1.t1 as abc and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select * from s1.t1 as abc");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+		System.out.println("Run select abc.c11 from s1.t1 as abc and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select abc.c11 from s1.t1 as abc");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Run select bcd.a, abc.c11 from s1.t1 as abc, s as bcd and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select bcd.a, abc.c11 from s1.t1 as abc, s as bcd");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+
+		stmt.executeUpdate("create schema app1");
+		stmt.executeUpdate("create table app1.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into app1.t1 values (11, 12), (21, 22)");
+		stmt.executeUpdate("create schema app2");
+		stmt.executeUpdate("create table app2.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into app2.t1 values (11, 12), (21, 22)");
+		System.out.println("Run select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1 and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+	}
+
 	static private void doTheTests() throws Exception
 	{
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
index c7a232e44..9e9fe8e9a 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
@@ -33,8 +33,8 @@ import java.sql.SQLWarning;
 
 import org.apache.derby.tools.ij;
 import org.apache.derby.tools.JDBCDisplayUtil;
-import org.apache.derbyTesting.functionTests.util.TestUtil;
 import org.apache.derby.iapi.services.info.JVMInfo;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
 
 import java.math.BigDecimal;
 import java.sql.Array;
@@ -154,7 +154,7 @@ public class updatableResultSet {
 
 
 	//I have constructed following table based on if combination of datatype and updateXXX method would work or not.
-	public static final String[][]  updateXXXRulesTable = {
+	public static final String[][]  updateXXXRulesTableForEmbedded = {
 
   // Types.             u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u
 	//                    p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p
@@ -194,7 +194,50 @@ public class updatableResultSet {
 /* 15 TIMESTAMP    */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
 /* 16 BLOB         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "PASS", "ERROR", "ERROR" },
 
-	};                                                                         
+	};
+
+	//I have constructed following table for network server based on if combination of datatype and updateXXX method would work or not.
+	public static final String[][]  updateXXXRulesTableForNetworkServer = {
+
+  // Types.             u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u
+	//                    p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p
+	//                    d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d
+  //                    a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a
+  //                    t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t
+  //                    e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e
+  //                    S  I  L  B  F  D  S  A  C  B  B  B  C  D  T  T  B  B  N  A  R
+	//                    h  n  o  i  l  o  t  s  h  y  y  i  l  a  i  i  l  o  u  r  e
+	//                    o  t  n  g  o  u  r  c  a  t  t  n  o  t  m  m  o  o  l  r  f
+	//                    r     g  D  a  b  i  i  r  e  e  a  b  e  e  e  b  l  l  a
+	//                    t        e  t  l  n  i  c     s  r           s     e     y
+	//                             c     e  g  S  t        y           t     a
+	//                             i           t  e        S           a     n
+	//                             m           r  r        t           m
+	//                             a           e  S        r           p
+	//                             l           a  t        e
+	//                                         m  r        a
+	//                                            e        m
+	//                                            a
+	//                                            m
+/* 0 SMALLINT */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 1 INTEGER  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 2 BIGINT   */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 3 DECIMAL  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 4 REAL     */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 5 DOUBLE   */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 6 CHAR     */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 7 VARCHAR  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 8 LONGVARCHAR */     { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 9 CHAR FOR BIT */    { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 10 VARCH. BIT   */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 11 LONGVAR. BIT */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 12 CLOB         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 13 DATE         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 14 TIME         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 15 TIMESTAMP    */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 16 BLOB         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+
+	};
 
 	public static void main(String[] args) {
 		System.out.println("Start testing delete and update using JDBC2.0 updateable resultset apis");
@@ -256,7 +299,7 @@ public class updatableResultSet {
 			}
 			conn.clearWarnings();
       System.out.println("requested TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE but that is not supported");
-			System.out.println("Jira issue Derby-154 : When client connects to Network Server using JCC, it incorrectly shows support for scroll sensitive updatable resultsets"); 
+			System.out.println("Jira issue Derby-154 : When client connects to Network Server using JCC, it incorrectly shows support for scroll sensitive updatable resultsets");
       System.out.println("Make sure that we got TYPE_SCROLL_INSENSITIVE? " +  (stmt.getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE));
       System.out.println("Make sure that we got CONCUR_READ_ONLY? " +  (stmt.getResultSetConcurrency() == ResultSet.CONCUR_READ_ONLY));
 			System.out.println("JDBC 2.0 updatable resultset api will fail on this resultset because this is not an updatable resultset");
@@ -334,6 +377,7 @@ public class updatableResultSet {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
+
 			System.out.println("Negative Test5 - request updatable resultset for sql with no FOR UPDATE clause");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("select * from t1");//notice that we forgot to give mandatory FOR UPDATE clause for updatable resultset
@@ -357,8 +401,6 @@ public class updatableResultSet {
 				System.out.println("SQL State : " + e.getSQLState());
 				System.out.println("Got expected exception " + e.getMessage());
 			}
-			//have to close the resultset because by default, resultsets are held open over commit
-			rs.close();
       System.out.println("Now attempting to send a updateRow on a sql with no FOR UPDATE clause.");
 			try {
 				rs.updateRow();
@@ -369,10 +411,15 @@ public class updatableResultSet {
 				System.out.println("Got expected exception " + e.getMessage());
 			}
 
+			//have to close the resultset because by default, resultsets are held open over commit
+			rs.close();
+
 			System.out.println("Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("select * from t1 FOR READ ONLY");
 			System.out.println("Make sure that we got CONCUR_READ_ONLY? " + (rs.getConcurrency() == ResultSet.CONCUR_READ_ONLY));
+			System.out.println("Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode");
+			System.out.println("Will see the warnings in embedded mode only");
 			warnings = rs.getWarnings();
 			while (warnings != null)
 			{
@@ -402,10 +449,9 @@ public class updatableResultSet {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
-			if (TestUtil.isEmbeddedFramework()) {
 			System.out.println("Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM t1 FOR UPDATE");
 			System.out.println("Make sure that we got CONCUR_UPDATABLE? " + (rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE));
       System.out.println("Now attempt a deleteRow without first doing next on the resultset.");
 			try {
@@ -417,9 +463,14 @@ public class updatableResultSet {
 				System.out.println("Got expected exception " + e.getMessage());
 			}
       System.out.println("Now attempt a updateRow without first doing next on the resultset.");
+			System.out.println("In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX");
+			System.out.println("In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not");
 			try {
 				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed because resultset is not on a row");
+				if (TestUtil.isEmbeddedFramework()) 
+					System.out.println("FAIL!!! In embedded mode, this updateRow should have failed because resultset is not on a row");
+				else
+					System.out.println("PASS!!! In Network Server mode, this updateRow is a no-op because no updateXXX were issued before the updateRow");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
@@ -448,7 +499,7 @@ public class updatableResultSet {
 
 			System.out.println("Negative Test8 - attempt deleteRow & updateRow on updatable resultset after closing the resultset");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM t1 FOR UPDATE");
 			System.out.println("Make sure that we got CONCUR_UPDATABLE? " + (rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE));
 			rs.next();
 			rs.close();
@@ -503,8 +554,9 @@ public class updatableResultSet {
 
 			System.out.println("Negative Test12 - With autocommit on, attempt to drop a table when there is an open updatable resultset on it");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT c1 FROM t1 FOR UPDATE");
 			rs.next();
+			rs.updateInt(1,123);
 			System.out.println("Opened an updatable resultset. Now trying to drop that table through another Statement");
 			stmt1 = conn.createStatement();
 			try {
@@ -535,7 +587,7 @@ public class updatableResultSet {
 
 			System.out.println("Negative Test13 - foreign key constraint failure will cause deleteRow to fail");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM tableWithPrimaryKey FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM tableWithPrimaryKey FOR UPDATE");
 			rs.next();
 			try {
 				rs.deleteRow();
@@ -548,6 +600,8 @@ public class updatableResultSet {
 			System.out.println("Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close");
 			try {
 				rs.next();
+				if (TestUtil.isNetFramework())
+					System.out.println("Jira entry Derby-160 : for Network Server because next should have failed");
 				System.out.println("FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback");
 			}
 			catch (SQLException e) {
@@ -572,6 +626,8 @@ public class updatableResultSet {
 			System.out.println("Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close");
 			try {
 				rs.next();
+				if (TestUtil.isNetFramework())
+					System.out.println("Jira entry Derby-160 : for Network Server because next should have failed");
 				System.out.println("FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback");
 			}
 			catch (SQLException e) {
@@ -581,7 +637,7 @@ public class updatableResultSet {
 
 			System.out.println("Negative Test15 - Can't call updateXXX methods on columns that do not correspond to a column in the table");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-			rs = stmt.executeQuery("SELECT 1, 2 FROM tableWithPrimaryKey FOR UPDATE");
+			rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
 			rs.next();
 			try {
 				rs.updateInt(1,22);
@@ -623,13 +679,17 @@ public class updatableResultSet {
       System.out.println("column 1 on this row before deleteRow is " + rs.getInt(1));
       System.out.println("column 2 on this row before deleteRow is " + rs.getString(2));
 			rs.deleteRow();
-      System.out.println("Since after deleteRow(), ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX");
 			try {
 				System.out.println("column 1 on this deleted row is " + rs.getInt(1));
 			}
 			catch (SQLException e) {
-				System.out.println("SQL State : " + e.getSQLState());
-				System.out.println("Got expected exception " + e.getMessage());
+				if (TestUtil.isEmbeddedFramework()) {
+					System.out.println("SQL State : " + e.getSQLState());
+					System.out.println("Got expected exception " + e.getMessage());
+				} else
+					System.out.println("Got unexpected exception " + e.getMessage());
 			}
       System.out.println("calling deleteRow again w/o first positioning the ResultSet on the next row will fail");
 			try {
@@ -647,6 +707,7 @@ public class updatableResultSet {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
+			if (TestUtil.isEmbeddedFramework()) {
 			System.out.println("Positive Test1b - request updatable resultset for forward only type resultset");
 			reloadData();
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
@@ -664,7 +725,8 @@ public class updatableResultSet {
 			System.out.println("column 2 on this row before updateString is " + rs.getString(2));
 			System.out.println("now updateRow on the row");
 			rs.updateRow();
-			System.out.println("Since after updateRow(), ResultSet is positioned before the next row, getXXX will fail");
+			System.out.println("Since after updateRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("In Network Server mode, the ResultSet stays on the updated row after updateRow and hence no error for getXXX");
 			try {
 				System.out.println("column 1 on this updateRow row is " + rs.getInt(1));
 			}
@@ -975,19 +1037,56 @@ public class updatableResultSet {
 			reloadData();
 			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 abcde FOR UPDATE of c1");
 			rs.next();
-			rs.updateString(2,"bbbb");
 			try {
-				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed");
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
 				System.out.println("Got expected exception " + e.getMessage());
 			}
+			System.out.println("attempt to get an updatable resultset using correlation name for an readonly column. It should work");
+			System.out.println("The sql is SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs = stmt.executeQuery("SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			rs.updateInt(1,11);
+			rs.updateRow();
 			rs.close();
 			System.out.println("Table t1 after updateRow has following rows");
 			dumpRS(stmt.executeQuery("select * from t1"));
 
+			System.out.println("Positive Test9c - try to updateXXX on a readonly column. Should get error");
+			reloadData();
+			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			try {
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
+			}
+			catch (SQLException e) {
+				System.out.println("SQL State : " + e.getSQLState());
+				System.out.println("Got expected exception " + e.getMessage());
+			}
+			rs.close();
+			System.out.println("Table t1 has following rows");
+			dumpRS(stmt.executeQuery("select * from t1"));
+
+			System.out.println("Positive Test9d - try to updateXXX on a readonly column with correlation name. Should get error");
+			reloadData();
+			rs = stmt.executeQuery("SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			try {
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
+			}
+			catch (SQLException e) {
+				System.out.println("SQL State : " + e.getSQLState());
+				System.out.println("Got expected exception " + e.getMessage());
+			}
+			rs.close();
+			System.out.println("Table t1 has following rows");
+			dumpRS(stmt.executeQuery("select * from t1"));
+
 			System.out.println("Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?");
 			conn.setAutoCommit(false);
       reloadData();
@@ -1543,7 +1642,7 @@ public class updatableResultSet {
 									rs.updateRef(ColumnNames[sqlType-1], null);
               }
 							rs.updateRow();
-							if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR")) {
+							if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR")) {
 								System.out.println("FAILURE : We shouldn't reach here. The test should have failed earlier on updateXXX or updateRow call");
 								return;
 							}
@@ -1553,7 +1652,7 @@ public class updatableResultSet {
 								return;
 							}
 						} catch (Throwable e) {
-							if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR"))
+							if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR"))
 								System.out.println("      Got expected exception : " + e.getMessage());
 							else {
 								if ((sqlType == 14 || sqlType == 15 || sqlType == 16) && //we are dealing with DATE/TIME/TIMESTAMP column types
@@ -1696,7 +1795,7 @@ public class updatableResultSet {
 									continue;
 
 								rs.updateRow();
-								if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR")) {
+								if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR")) {
 									System.out.println("FAILURE : We shouldn't reach here. The test should have failed earlier on updateXXX or updateRow call");
 									return;
 								}
@@ -1706,7 +1805,7 @@ public class updatableResultSet {
 									return;
 								}
 						} catch (Throwable e) {
-								if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR"))
+								if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR"))
 									System.out.println("    Got expected exception : " + e.getMessage());
 								else {
 									if ((sqlType == 14 || sqlType == 15 || sqlType == 16) && //we are dealing with DATE/TIME/TIMESTAMP column types
@@ -2065,10 +2164,9 @@ public class updatableResultSet {
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 FOR UPDATE of c1");
 			rs.next();
-			rs.updateInt(2,22);
 			try {
-				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed because c12 is not the FOR UPDATE columns list.");
+				rs.updateInt(2,22);
+				System.out.println("FAIL!!! updateInt should have failed because c12 is not the FOR UPDATE columns list.");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
