diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/xaSimplePositive.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/xaSimplePositive.out
new file mode 100644
index 000000000..60a46c66c
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/xaSimplePositive.out
@@ -0,0 +1,195 @@
+ij> xa_datasource 'wombat';
+ij> ---------------------------------------------
+----- a single connection and 1 phase commit
+-----
+xa_connect ;
+ij> xa_start xa_noflags 0;
+ij> xa_getconnection;
+ij(XA)> drop table foo;
+ERROR 42Y55: 'DROP TABLE' cannot be performed on 'FOO' because it does not exist.
+ij(XA)> create table foo (a int);
+0 rows inserted/updated/deleted
+ij(XA)> insert into foo values (0);
+1 row inserted/updated/deleted
+ij(XA)> select * from foo;
+A          
+-----
+0          
+ij(XA)> run resource '/org/apache/derbyTesting/functionTests/tests/store/global_xactTable.view';
+ij(XA)> create view global_xactTable as
+select 
+    cast(global_xid as char(2)) as gxid,
+    status,
+    case when first_instant is NULL then 'NULL' else 'false' end as readOnly,
+    cast (username as char(10)) as username,
+    type 
+from new org.apache.derby.diag.TransactionTable() t;
+0 rows inserted/updated/deleted
+ij(XA)> select * from global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(0 |ACTIVE |false |APP |UserTransaction               
+ij(XA)> xa_end xa_success 0;
+ij(XA)> xa_commit xa_1phase 0;
+ij(XA)> xa_datasource 'wombat' shutdown;
+ERROR 08006: DERBY SQL error: SQLCODE: -1, SQLSTATE: 08006, SQLERRMC: Database 'wombat' shutdown.
+ij(XA)> ---------------------------------------------
+----- two interleaving connections and prepare/commit prepare/rollback
+-----
+xa_datasource 'wombat';
+ij(XA)> xa_connect user 'sku' password 'testxa' ;
+ij(XA)> xa_start xa_noflags 1;
+ij(XA)> xa_getconnection;
+ij(XA)> insert into APP.foo values (1);
+1 row inserted/updated/deleted
+ij(XA)> xa_end xa_suspend 1;
+ij(XA)> xa_start xa_noflags 2;
+ij(XA)> insert into APP.foo values (2);
+1 row inserted/updated/deleted
+ij(XA)> xa_end xa_suspend 2;
+ij(XA)> xa_start xa_resume 1;
+ij(XA)> insert into APP.foo values (3);
+1 row inserted/updated/deleted
+ij(XA)> xa_end xa_suspend 1;
+ij(XA)> xa_start xa_resume 2;
+ij(XA)> insert into APP.foo values (4);
+1 row inserted/updated/deleted
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(1 |ACTIVE |false |SKU |UserTransaction               
+(2 |ACTIVE |false |SKU |UserTransaction               
+ij(XA)> -- this prepare won't work since transaction 1 has been suspended - XA_PROTO
+xa_prepare 1;
+IJ ERROR: XAER_PROTO 
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(1 |ACTIVE |false |SKU |UserTransaction               
+(2 |ACTIVE |false |SKU |UserTransaction               
+ij(XA)> xa_end xa_success 2;
+ij(XA)> -- this assumes a resume
+xa_end xa_success 1;
+ij(XA)> xa_prepare 1;
+ij(XA)> xa_prepare 2;
+ij(XA)> -- both transactions should be prepared
+select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(1 |PREPARED |false |SKU |UserTransaction               
+(2 |PREPARED |false |SKU |UserTransaction               
+ij(XA)> -- NOTE: The following call to "xa_recover xa_startrscan" is apt to
+----- return the result set rows in reverse order when changes to
+----- the Derby engine affect the number of transactions that it takes
+----- to create a database.  The transactions are stored in a hash table
+----- based on a global and local id, and when the number of transactions
+----- changes, the (internal) local id can change, which may lead to a
+----- change in the result set order.  This order is determined by the
+----- JVM's hashing algorithm. Examples of changes to the engine that
+----- can affect this include ones that cause more commits or that
+----- change the amount of data being stored, such as changes to the
+----- metadata statements (which is what prompted this explanation in
+----- the first place).  Ultimately, the problem is that there is no
+----- way to order the return values from "xa_recover" since it is an
+----- ij internal statement, not SQL...
+xa_recover xa_startrscan;
+Recovered 2 in doubt transactions
+Transaction 1 : {ClientXid: formatID(2), gtrid_length(6), bqual_length(6), data(776F6D62 6174776F 6D626174)}
+Transaction 2 : {ClientXid: formatID(1), gtrid_length(6), bqual_length(6), data(776F6D62 6174776F 6D626174)}
+ij(XA)> xa_recover xa_noflags;
+Recovered 0 in doubt transactions
+ij(XA)> xa_commit xa_2Phase 1;
+ij(XA)> xa_rollback 2;
+ij(XA)> -- check results
+xa_start xa_noflags 3;
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(3 |IDLE |NULL |SKU |UserTransaction               
+ij(XA)> select * from APP.foo;
+A          
+-----
+0          
+1          
+3          
+ij(XA)> xa_end xa_success 3;
+ij(XA)> xa_prepare 3;
+ij(XA)> -- should fail with XA_NOTA because we prepared a read only transaction 
+xa_commit xa_1Phase 3;
+IJ ERROR: XAER_NOTA 
+ij(XA)> disconnect;
+ij> ---------------------------------------------
+----- 3 interleaving xa connections and a local connection
+-----
+xa_start xa_noflags 4;
+ij> xa_end xa_suspend 4;
+ij> xa_start xa_noflags 5;
+ij> xa_end xa_suspend 5;
+ij> xa_start xa_noflags 6;
+ij> xa_end xa_suspend 6;
+ij> connect 'wombat' as local;
+ij(LOCAL)> select * from foo;
+A          
+-----
+0          
+1          
+3          
+ij(LOCAL)> xa_start xa_resume 4;
+ij(LOCAL)> xa_getconnection;
+ij(XA)> insert into APP.foo values (4);
+1 row inserted/updated/deleted
+ij(XA)> disconnect;
+ij> set connection local;
+ij(LOCAL)> insert into foo values (77);
+1 row inserted/updated/deleted
+ij(LOCAL)> xa_end xa_suspend 4;
+ij(LOCAL)> xa_end xa_success 4;
+ij(LOCAL)> -- this getconnection should get a local connection
+----- this has problems
+-----xa_getconnection;
+-----insert into APP.foo values (88);
+-----commit;
+-----disconnect;
+xa_start xa_resume 5;
+ij(LOCAL)> xa_getconnection;
+ij(XA)> insert into APP.foo values (5);
+1 row inserted/updated/deleted
+ij(XA)> xa_end xa_success 5;
+ij(XA)> xa_start xa_resume 6;
+ij(XA)> insert into APP.foo values (6);
+1 row inserted/updated/deleted
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(4 |ACTIVE |false |SKU |UserTransaction               
+(5 |ACTIVE |false |SKU |UserTransaction               
+(6 |ACTIVE |false |SKU |UserTransaction               
+ij(XA)> xa_commit xa_1Phase 4;
+ij(XA)> insert into APP.foo values (6);
+1 row inserted/updated/deleted
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(5 |ACTIVE |false |SKU |UserTransaction               
+(6 |ACTIVE |false |SKU |UserTransaction               
+ij(XA)> xa_end xa_fail 6;
+IJ ERROR: XA_RBROLLBACK 
+ij(XA)> xa_rollback 6;
+ij(XA)> xa_start xa_join 5;
+ij(XA)> select * from APP.global_xactTable where gxid is not null order by gxid;
+GXID |STATUS |READ& |USERNAME |TYPE                          
+-----
+(5 |ACTIVE |false |SKU |UserTransaction               
+ij(XA)> select * from APP.foo;
+A          
+-----
+0          
+1          
+3          
+4          
+77         
+5          
+ij(XA)> xa_end xa_success 5;
+ij(XA)> xa_prepare 5;
+ij(XA)> xa_commit xa_2Phase 5;
+ij(XA)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/suites/derbynetclientmats.runall b/java/testing/org/apache/derbyTesting/functionTests/suites/derbynetclientmats.runall
index f13a42d9a..d6b86c2e3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/suites/derbynetclientmats.runall
+++ b/java/testing/org/apache/derbyTesting/functionTests/suites/derbynetclientmats.runall
@@ -1,2 +1,2 @@
-derbynet/netxaPositive.sql
+jdbcapi/xaSimplePositive.sql
 jdbcapi/xaStateTran.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/copyfiles.ant b/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/copyfiles.ant
index a187fabe3..4b4dc6612 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/copyfiles.ant
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/copyfiles.ant
@@ -7,9 +7,6 @@ dataSourcePermissions_net_app.properties
 dataSourcePermissions_net_sed.properties
 default_app.properties
 default_derby.properties
-netxaPositive.sql
-netxaPositive_app.properties
-netxaPositive_sed.properties
 runtimeinfo_sed.properties
 sysinfo_sed.properties
 testij.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive.sql
deleted file mode 100644
index 03f8b9a0a..000000000
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive.sql
+++ /dev/null
@@ -1,107 +0,0 @@
-
-xa_datasource 'wombat';
-
----------------------------------------------
--- a single connection and 1 phase commit
----------------------------------------------
-xa_connect ;
-xa_start xa_noflags 0;
-xa_getconnection;
--- Global transactions can not have hold cursor over commit. And hence we need to make sure the holdability is false for all jdks
--- In jdk13 and lower, this Brokered Connection has its holdability false over commit so we are fine. 
--- In jdk14 and higher, this Brokered Connection has its holdability true over commit. In order to set it to false, we have NoHoldForConnection 
--- NoHoldForConnection uses setHoldability api on Connection to set the holdability to false. But this api exists only for jdk14 and higher
--- And that is why, in jkd13 master, we see an exception nosuchmethod 
-NoHoldForConnection;
-drop table foo;
-create table foo (a int);
-insert into foo values (0);
-select * from foo;
-run resource '/org/apache/derbyTesting/functionTests/tests/store/global_xactTable.view';
-select * from global_xactTable where gxid is not null order by gxid;
-xa_end xa_success 0;
-xa_commit xa_1phase 0;
-
-xa_datasource 'wombat' shutdown;
-
----------------------------------------------
--- two interleaving connections and prepare/commit prepare/rollback
----------------------------------------------
-xa_datasource 'wombat';
-xa_connect user 'sku' password 'testxa' ;
-
-xa_start xa_noflags 1;
-xa_getconnection;
--- Global transactions can not have hold cursor over commit. And hence we need to make sure the holdability is false for all jdks
--- In jdk13 and lower, this Brokered Connection has its holdability false over commit so we are fine. 
--- In jdk14 and higher, this Brokered Connection has its holdability true over commit. In order to set it to false, we have NoHoldForConnection 
--- NoHoldForConnection uses setHoldability api on Connection to set the holdability to false. But this api exists only for jdk14 and higher
--- And that is why, in jkd13 master, we see an exception nosuchmethod 
-NoHoldForConnection;
-insert into APP.foo values (1);
-xa_end xa_suspend 1;
-
-xa_start xa_noflags 2;
-insert into APP.foo values (2);
-xa_end xa_suspend 2;
-
-xa_start xa_resume 1;
-insert into APP.foo values (3);
-xa_end xa_suspend 1;
-
-xa_start xa_resume 2;
-insert into APP.foo values (4);
-select * from APP.global_xactTable where gxid is not null order by gxid;
-xa_end xa_success 2;
-
-
-xa_start xa_resume 1;
-insert into APP.foo values(5);
-xa_end xa_success 1;
-xa_prepare 1;
-xa_prepare 2;
-
--- both transactions should be prepared
-select * from APP.global_xactTable where gxid is not null order by gxid;
-
-xa_recover xa_startrscan;
-xa_recover xa_noflags;
-
-xa_commit xa_2Phase 1;
-xa_rollback 2;
-
--- check results
-xa_start xa_noflags 3;
-select * from APP.global_xactTable where gxid is not null order by gxid;
-select * from APP.foo;
-xa_end xa_success 3;
-
-xa_prepare 3;
-
--- should fail with XA_NOTA because we prepared a read only transaction 
-xa_commit xa_1Phase 3;
-
-
--- DERBY-246 xa_end after connection close should be ok.  
--- Also to reuse xaconnection in the same global transaction
-xa_getconnection;
-xa_start xa_noflags 4;
-create table APP.derby246  (i int);
-insert into APP.derby246 values(1);
-disconnect;
-xa_getconnection;
-insert into APP.derby246 values(2);
-disconnect;
-xa_end xa_success 4;
-xa_prepare 4;
-xa_commit xa_2phase 4;
-
--- now connect with a local connection to make sure locks are released 
--- and our values are there. Should see two rows
-connect 'wombat';
-select * from APP.derby246;
-
-disconnect;
-
-
-
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_app.properties b/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_app.properties
deleted file mode 100644
index 48a5aac94..000000000
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_app.properties
+++ /dev/null
@@ -1,10 +0,0 @@
-ij.protocol=jdbc:derby:
-ij.database=jdbc:derby:wombat;create=true
-ij.showNoConnectionsAtStart=true
-ij.showNoCountForSelect=true
-#ij.exceptionTrace=true
-
-# DataSource properties, only used if ij.dataSource is set
-ij.dataSource.databaseName=wombat
-ij.dataSource.createDatabase=create
-
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_sed.properties b/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_sed.properties
deleted file mode 100644
index 1adcfefa4..000000000
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/netxaPositive_sed.properties
+++ /dev/null
@@ -1,10 +0,0 @@
-# Filters and substitutes for SED
-# Multiple patterns for DELETE: comma separated
-#   delete=pattern1,pattern2,...,patternn
-# No commas can be allowed in the patterns.
-#
-# Multiple patterns for SUBSTITUTE: comma separated <pattern;substitute> pair
-#   substitute=pattern1;substitute1,pattern2;substitute2,...,patternn;substituten
-# No commas or semicolons can be allowed in the patterns/subsitutes.
-delete=ERROR XJ001: Java exception: 'java.lang.NoSuchMethodException: '.,ERROR XJ001: Java exception: 'java.lang.NoSuchMethodException: setHoldability'.
-substitute=(server log.*);(server log XXX)
