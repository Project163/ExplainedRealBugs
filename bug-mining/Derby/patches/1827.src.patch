diff --git a/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index 43fd4e1bf..208062577 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -643,6 +643,13 @@ public class SelectNode extends ResultSetNode
 		{
 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
 		}
+
+        // DERBY-4407: A derived table must have at least one column.
+        if (resultColumns.size() == 0)
+        {
+            throw StandardException.newException(
+                    SQLState.LANG_EMPTY_COLUMN_LIST);
+        }
 	}
 
 	/**
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index ca4f27c0a..11b7da4ca 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -1894,6 +1894,11 @@ Guide.
                 <text>VALUES clause must contain at least one element. Empty elements are not allowed. </text>
             </msg>
 
+            <msg>
+                <name>42X81</name>
+                <text>A query expression must return at least one column.</text>
+            </msg>
+
             <msg>
                 <name>42X82</name>
                 <text>The USING clause returned more than one row. Only single-row ResultSets are permissible.</text>
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 310105e99..7fdeb430f 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -882,6 +882,7 @@ public interface SQLState {
 	String LANG_DISTINCT_ORDER_BY                                      = "42879";
 	String LANG_DISTINCT_ORDER_BY_EXPRESSION                           = "4287A";
 	String LANG_EMPTY_VALUES_CLAUSE                                    = "42X80";
+	String LANG_EMPTY_COLUMN_LIST                                      = "42X81";
 	String LANG_USING_CARDINALITY_VIOLATION                            = "42X82";
 	String LANG_ADDING_COLUMN_WITH_NULL_AND_NOT_NULL_CONSTRAINT        = "42X83";
 	String LANG_CANT_DROP_BACKING_INDEX                                = "42X84";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/JoinTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/JoinTest.java
index 4220436bd..520f4e9d6 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/JoinTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/JoinTest.java
@@ -38,6 +38,7 @@ public class JoinTest extends BaseJDBCTestCase {
     private static final String AMBIGUOUS_COLNAME = "42X03";
     private static final String COLUMN_NOT_IN_SCOPE = "42X04";
     private static final String NON_COMPARABLE = "42818";
+    private static final String NO_COLUMNS = "42X81";
 
     public JoinTest(String name) {
         super(name);
@@ -641,5 +642,15 @@ public class JoinTest extends BaseJDBCTestCase {
         // of the columns to use.
         assertStatementError(AMBIGUOUS_COLNAME, s,
                 "select * from (t1 cross join t2) join t2 tt2 using(b)");
+
+        // DERBY-4407: If all the columns of table X are in the USING clause,
+        // X.* will expand to no columns. A result should always have at least
+        // one column.
+        assertStatementError(NO_COLUMNS, s,
+                "select x.* from t1 x inner join t1 y using (a,b,c)");
+        assertStatementError(NO_COLUMNS, s,
+                "select x.* from t1 x left join t1 y using (a,b,c)");
+        assertStatementError(NO_COLUMNS, s,
+                "select x.* from t1 x right join t1 y using (a,b,c)");
     }
 }
