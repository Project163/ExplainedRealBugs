diff --git a/java/engine/org/apache/derby/impl/sql/compile/FromList.java b/java/engine/org/apache/derby/impl/sql/compile/FromList.java
index da5f0a852..e66a5a5b9 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/FromList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/FromList.java
@@ -1548,6 +1548,42 @@ public class FromList extends QueryTreeNodeVector implements OptimizableList
 		}
 	}
 
+	/**
+	 * determine whether this table is NOT EXISTS.
+	 *
+	 * This routine searches for the indicated table number in the fromlist
+	 * and returns TRUE if the table is present in the from list and is 
+	 * marked NOT EXISTS, false otherwise.
+	 *
+	 * A table may be present in the from list for NOT EXISTS if it is used
+	 * as a correlated NOT EXISTS subquery. In such a situation, when the
+	 * subquery is flattened, it is important that we remember that this is
+	 * a NOT EXISTS subquery, because the join semantics are different 
+	 * (we're looking for rows that do NOT match, rather than rows
+	 * that do). And since the join semantics are different, we cannot
+	 * include this table into a transitive closure of equijoins
+	 * (See DERBY-3033 for a situation where this occurs).
+	 *
+	 * @param tableNumber	which table to check
+	 * @return true if this table is in the from list as NOT EXISTS
+	 */
+	boolean tableNumberIsNotExists(int tableNumber)
+		throws StandardException
+	{
+		int size = size();
+		for (int index = 0; index < size; index++)
+		{
+			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
+			if (! (prn.getChildResult() instanceof FromTable))
+			{
+				continue;
+			}
+			FromTable ft = (FromTable) prn.getChildResult();
+			if (ft.getTableNumber() == tableNumber)
+				return ft.isNotExists();
+		}
+		return false;
+	}
 	/**
 	 * Get the lock mode for the target of an update statement
 	 * (a delete or update).  The update mode will always be row for
diff --git a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
index b0e418bef..05ab42eb6 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
@@ -1817,6 +1817,14 @@ public class PredicateList extends QueryTreeNodeVector implements OptimizablePre
      * other side of the middle predicate to see if we can find an equijoin 
      * between outer and inner.  If so, then we simply assign it to the same 
      * equivalence class.  If not, then we add the new equijoin clause.
+	 *
+	 * Note that an equijoin predicate between two tables CANNOT be
+	 * used for transitive closure, if either of the tables is in the
+	 * fromlist for NOT EXISTS. In that case, the join predicate
+	 * actually specifies that the rows from the indicated table must
+	 * NOT exist, and therefore those non-existent rows cannot be
+	 * transitively joined to the other matching tables. See DERBY-3033
+	 * for a description of a situation in which this actually arises.
 	 *
 	 * @param numTables	The number of tables in the query
 	 * @param fromList	The FromList in question.
@@ -1867,7 +1875,9 @@ public class PredicateList extends QueryTreeNodeVector implements OptimizablePre
 				ColumnReference leftCR = (ColumnReference) left;
 				ColumnReference rightCR = (ColumnReference) right;
 				if (leftCR.getSourceLevel() == rightCR.getSourceLevel() &&
-					leftCR.getTableNumber() != rightCR.getTableNumber())
+					leftCR.getTableNumber() != rightCR.getTableNumber() &&
+					!fromList.tableNumberIsNotExists(leftCR.getTableNumber()) &&
+					!fromList.tableNumberIsNotExists(rightCR.getTableNumber()))
 				{
 					// Add the equijoin clause to each of the lists
 					joinClauses[leftCR.getTableNumber()].addElement(predicate);
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSetOpsTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSubqueriesTest.java
similarity index 70%
rename from java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSetOpsTest.java
rename to java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSubqueriesTest.java
index 1edfdacce..f190251da 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSetOpsTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ExistsWithSubqueriesTest.java
@@ -1,6 +1,6 @@
 /*
  
-   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ExistsWithSetOpsTest
+   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ExistsWithSubqueriesTest
 
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
@@ -31,9 +31,12 @@ import org.apache.derbyTesting.junit.TestConfiguration;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.sql.PreparedStatement;
 
 /**
- * This test ensures that an EXISTS predicate which wraps a set operation--
+ * This test contains a variety of cases of EXISTS predicates with subqueries.
+ *
+ * Several tests ensure that an EXISTS predicate which wraps a set operation--
  * meaning a UNION, INTERSECT, or EXCEPT node--returns the correct results.
  * For example:
  *
@@ -41,8 +44,14 @@ import java.sql.Statement;
  *     where exists ((values 1) intersect (values 2))
  *
  * should return zero rows. Prompted by DERBY-2370.
+ *
+ * A somewhat unrelated test verifies the DERBY-3033 behavior, which
+ * involves flattening of subqueries with NOT EXISTS predicates. The
+ * issue here is that a flattened NOT EXISTS subquery cannot be used
+ * to perform equi-join transitive closure, because the implied predicate
+ * that results from the flattening is a NOT EQUALS condition.
  */
-public class ExistsWithSetOpsTest extends BaseJDBCTestCase {
+public class ExistsWithSubqueriesTest extends BaseJDBCTestCase {
     
     private static final String EXISTS_PREFIX_1 =
         "select * from ( values 'GOT_A_ROW' ) as T where exists (";
@@ -55,7 +64,7 @@ public class ExistsWithSetOpsTest extends BaseJDBCTestCase {
      * @param name name of the test.
      *
      */
-    public ExistsWithSetOpsTest(String name)
+    public ExistsWithSubqueriesTest(String name)
     {
         super(name);
     }
@@ -72,7 +81,7 @@ public class ExistsWithSetOpsTest extends BaseJDBCTestCase {
          * to run the test against one or the other; we choose embedded.
          */
         suite.addTest(
-            TestConfiguration.embeddedSuite(ExistsWithSetOpsTest.class));
+            TestConfiguration.embeddedSuite(ExistsWithSubqueriesTest.class));
 
         /* Wrap the suite in a CleanDatabaseTestSetup that will create
          * and populate the test tables.
@@ -382,4 +391,153 @@ public class ExistsWithSetOpsTest extends BaseJDBCTestCase {
             JDBC.assertFullResultSet(rs, expRS);
         rs.close();
     }
+
+    /**
+     * Regression test for Derby-3033.
+     *
+     * This method constructs a query with the property that it:
+     * - contains a NOT EXISTS condition against a correlated subquery
+     * - such that if that subquery is flattened, the result is 3 tables
+     *   which all have join predicates on the same key.
+     * The point of the test is that it is *not* correct to construct
+     * a new equijoin predicate between table d3033_a and d3033_c via
+     * transitive closure, because the join condition between d3033_b and
+     * d3033_c is NOT EXISTS.
+     *
+     * In the original bug, the compiler/optimizer erroneously generated
+     * the extra equijoin predicate, which caused NPE exceptions at
+     * runtime due to attempts to reference the non-existent (NOT EXISTS) row.
+     *
+     * So this test succeeds if it gets the right results and no NPE.
+     */
+    public void testDerby3033()
+        throws Exception
+    {
+        setupDerby3033();
+
+        PreparedStatement pstmt = prepareStatement(
+            "select c1, c2_b " +
+            "from (select distinct st.c1,st.c2_b,dsr.c3_a,st.c3_b " +
+            "      from " +
+            "             d3033_a dsr, " +  // Table order matters here!
+            "             d3033_b st " +
+            "      where dsr.c4_a is null " +
+            "      and   dsr.c2 = ? " +
+            "      and   dsr.c1 = st.c1 " +
+            "      and   not exists ( " +
+            "              select 1 " +
+            "              from d3033_c " +
+            "              where d3033_c.c1 = st.c1 " +
+            "              and   d3033_c.c2 = ? " +
+            "              and   d3033_c.c3_c = ? " +
+            "              ) " +
+            ") temp "
+        );
+ 
+        pstmt.setInt(1, 4);
+        pstmt.setInt(2, 4);
+        pstmt.setInt(3, 100);
+ 
+        String [][]expected = {
+            { "1", "100" },
+            { "2", "200" },
+            { "3", "300" },
+        };
+        ResultSet rs = pstmt.executeQuery();
+        JDBC.assertFullResultSet(rs, expected);
+        pstmt.close();
+    }
+
+    /**
+     * Ensure that the #rows statistics are updated
+     */
+    private void updateStats(Statement st, String tName)
+        throws Exception
+    {
+        ResultSet rs = st.executeQuery("select * from " + tName);
+        int numRows = 0;
+        while (rs.next())
+            numRows ++;
+        rs.close();
+    }
+
+    private void setupDerby3033()
+        throws Exception
+    {
+        // The pattern of inserting the data is fairly important, as we
+        // are going to do a combination of joins between the three tables
+        // and we want both matching data and non-matching data. We load:
+        //
+        // d3033_a      d3033_b       d3033_c
+        // --------     --------      --------
+        //    1            1             1
+        //    2            2             3
+        //    3            3
+        //                 4
+        //
+        // We also load a whole pile of irrelevant data into tables a and c
+        // so that the index becomes relevant in the optimizer's analysis,
+        // then we create some constraints and indexes and delete the rows
+        // from table d3033_c (the NOT EXISTS table).
+        //
+        Statement s = createStatement();
+
+        s.executeUpdate("create table d3033_a "+
+                        "(c1 int, c2 int, c3_a int, c4_a date)");
+        s.executeUpdate("create table d3033_b "+
+                        "(c1 int primary key not null, c2_b int, c3_b date)");
+        s.executeUpdate("create table d3033_c (c1 int, c2 int, c3_c int)");
+        s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(1, 4, 10)");
+        s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(2, 4, 20)");
+        s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(3, 4, 30)");
+        s.executeUpdate("insert into d3033_b values(1, 100, CURRENT_DATE)");
+        s.executeUpdate("insert into d3033_b values(2, 200, CURRENT_DATE)");
+        s.executeUpdate("insert into d3033_b values(3, 300, CURRENT_DATE)");
+        s.executeUpdate("insert into d3033_b values(4, 400, CURRENT_DATE)");
+        s.executeUpdate("insert into d3033_c values(1, 4, 100)");
+        s.executeUpdate("insert into d3033_c values(3, 4, 100)");
+            
+        PreparedStatement pstmt2 = prepareStatement(
+                "insert into d3033_a (c1, c2, c3_a) values (?,?,?)");
+
+        PreparedStatement pstmt = prepareStatement(
+                "insert into d3033_b (c1, c2_b, c3_b) values (?,?,?)");
+
+        java.util.Date now = new java.util.Date();
+        java.sql.Timestamp nowTS = new java.sql.Timestamp(now.getTime());
+        for (int i = 0; i < 15; i++)
+        {
+            pstmt.setInt(1, 100+i);
+            pstmt.setInt(2, 100+i);
+            pstmt.setTimestamp(3, nowTS);
+            pstmt.executeUpdate();
+
+            for (int j = 0; j < 200; j++)
+            {
+                pstmt2.setInt(1, 1000+j);
+                pstmt2.setInt(2, 100+i); // note "i" here (FK)
+                pstmt2.setInt(3, 1000 + (j+1)*10);
+                pstmt2.executeUpdate();
+            }
+        }
+
+
+        s.executeUpdate("alter table d3033_a add constraint " +
+                "d3033_a_fk foreign key (c2) references d3033_b(c1) " +
+                "on delete cascade on update no action");
+
+        s.executeUpdate("alter table d3033_c add constraint " +
+                "d3033_c_fk foreign key (c1) references d3033_b(c1) " +
+                "on delete cascade on update no action");
+
+        s.executeUpdate("delete from d3033_c");
+
+        // Update the statistics on the 3 tables:
+        updateStats(s, "d3033_a");
+        updateStats(s, "d3033_b");
+        updateStats(s, "d3033_c");
+
+        s.close();
+    }
+
 }
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
index dc698333a..e9a76fa83 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
@@ -63,7 +63,7 @@ public class _Suite extends BaseTestCase  {
         suite.addTest(CreateTableFromQueryTest.suite());
         suite.addTest(DatabaseClassLoadingTest.suite());
         suite.addTest(DynamicLikeOptimizationTest.suite());
-        suite.addTest(ExistsWithSetOpsTest.suite());
+        suite.addTest(ExistsWithSubqueriesTest.suite());
         suite.addTest(GrantRevokeTest.suite());
         suite.addTest(GroupByExpressionTest.suite());
 		suite.addTest(LangScripts.suite());
