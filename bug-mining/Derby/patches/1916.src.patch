diff --git a/java/client/org/apache/derby/client/am/ResultSet.java b/java/client/org/apache/derby/client/am/ResultSet.java
index 74494677c..7bece85a3 100644
--- a/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/java/client/org/apache/derby/client/am/ResultSet.java
@@ -25,9 +25,9 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.Reader;
 import java.sql.SQLException;
+import java.util.Arrays;
 import org.apache.derby.client.am.SQLExceptionFactory;
 import org.apache.derby.shared.common.reference.SQLState;
-import org.apache.derby.shared.common.i18n.MessageUtil;
 import org.apache.derby.shared.common.sanity.SanityManager;
 
 public abstract class ResultSet implements java.sql.ResultSet,
@@ -204,8 +204,13 @@ public abstract class ResultSet implements java.sql.ResultSet,
     // Keep maxRows in the ResultSet, so that changes to maxRow in the statement
     // do not affect the resultSet after it has been created
     private int maxRows_;
-    
-    private boolean[] streamUsedFlags_;
+
+    /**
+     * Indicates which columns have been fetched as a stream or as a LOB for a
+     * row. Created on-demand by a getXXXStream or a get[BC]lob call. Note that
+     * we only track columns that can be accessed as a stream or a LOB object.
+     */
+    private boolean[] columnUsedFlags_;
     
     //---------------------constructors/finalizer---------------------------------
 
@@ -293,8 +298,8 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
         // discard all previous updates when moving the cursor
         resetUpdatedColumns();
-	
-	unuseStreams();
+
+        unuseStreamsAndLOBs();
 
         // for TYPE_FORWARD_ONLY ResultSet, just call cursor.next()
         if (resultSetType_ == java.sql.ResultSet.TYPE_FORWARD_ONLY) {
@@ -1119,7 +1124,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
             }
 
             checkGetterPreconditions(column);
-        useStream(column);
+            useStreamOrLOB(column);
 
             java.io.InputStream result = null;
             if (wasNonNullSensitiveUpdate(column)) {
@@ -1150,7 +1155,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
             }
 
             checkGetterPreconditions(column);
-        useStream(column);
+            useStreamOrLOB(column);
 
             java.io.InputStream result = null;
             if (wasNonNullSensitiveUpdate(column)) {
@@ -1201,7 +1206,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
             }
 
             checkGetterPreconditions(column);
-        useStream(column);
+            useStreamOrLOB(column);
 
             java.io.Reader result = null;
             if (wasNonNullSensitiveUpdate(column)) {
@@ -1232,6 +1237,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
                 agent_.logWriter_.traceEntry(this, "getBlob", column);
             }
             checkGetterPreconditions(column);
+            useStreamOrLOB(column);
             java.sql.Blob result = null;
             if (wasNonNullSensitiveUpdate(column)) {
                 result = (java.sql.Blob) agent_.crossConverters_.setObject(java.sql.Types.BLOB,
@@ -1261,6 +1267,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
                 agent_.logWriter_.traceEntry(this, "getClob", column);
             }
             checkGetterPreconditions(column);
+            useStreamOrLOB(column);
             java.sql.Clob result = null;
             if (wasNonNullSensitiveUpdate(column)) {
                 result = (java.sql.Clob) agent_.crossConverters_.setObject(java.sql.Types.CLOB,
@@ -2096,8 +2103,8 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
     private void beforeFirstX() throws SqlException {
         
-	resetRowsetFlags();
-	unuseStreams();
+        resetRowsetFlags();
+        unuseStreamsAndLOBs();
 
         moveToCurrentRowX();
 
@@ -2137,7 +2144,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
     private void afterLastX() throws SqlException {
         resetRowsetFlags();
-    unuseStreams();
+        unuseStreamsAndLOBs();
     
         moveToCurrentRowX();
 
@@ -2189,7 +2196,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
         resetUpdatedColumns();
 
         resetRowsetFlags();
-    unuseStreams();
+        unuseStreamsAndLOBs();
 
         // if first row is not in the current rowset, fetch the first rowset from the server.
         // rowIsInCurrentRowset with orientation first will always return false for dynamic cursors.
@@ -2244,7 +2251,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
         resetUpdatedColumns();
 
         resetRowsetFlags();
-	unuseStreams();
+        unuseStreamsAndLOBs();
 
         // only get the rowCount for static cursors.
         if (rowCountIsUnknown()) {
@@ -2361,7 +2368,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
         resetUpdatedColumns();
 
         resetRowsetFlags();
-	unuseStreams();
+        unuseStreamsAndLOBs();
 
         if (maxRows_ > 0) {
             // if "row" is positive and > maxRows, fetch afterLast
@@ -2444,8 +2451,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
         // discard all previous updates when moving the cursor.
         resetUpdatedColumns();
-	
-	unuseStreams();
+        unuseStreamsAndLOBs();
 
         // If the resultset is empty, relative(n) is a null operation
         if (resultSetContainsNoRows()) {
@@ -2571,8 +2577,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
         // discard all previous updates when moving the cursor.
         resetUpdatedColumns();
-	
-	unuseStreams();
+        unuseStreamsAndLOBs();
 
         isBeforeFirst_ = false;
         isFirst_ = false;
@@ -3691,9 +3696,9 @@ public abstract class ResultSet implements java.sql.ResultSet,
             } catch ( SQLException sqle ) {
                 throw new SqlException(sqle);
             }
-	    
-    	    unuseStreams();
-	    
+
+            unuseStreamsAndLOBs();
+
         }
     }
 
@@ -5486,33 +5491,34 @@ public abstract class ResultSet implements java.sql.ResultSet,
 	}
     
     
-    void useStream(int columnIndex) throws SqlException {
-	
-	if(streamUsedFlags_[columnIndex - 1]){
-	    throw new SqlException(agent_.logWriter_,
-            new ClientMessageId(SQLState.LANG_STREAM_RETRIEVED_ALREADY));
-	}
-
-	streamUsedFlags_[columnIndex - 1] = true;
+    /**
+     * Mark a column as already having a stream or LOB accessed from it.
+     * If the column was already accessed, throw an exception.
+     *
+     * @param columnIndex 1-based column index
+     * @throws SQLException if the column has already been accessed
+     */
+    void useStreamOrLOB(int columnIndex) throws SqlException {
+        if (columnUsedFlags_ == null) {
+            columnUsedFlags_ = new boolean[resultSetMetaData_.columns_];
+        }
+        if (columnUsedFlags_[columnIndex - 1]) {
+            throw new SqlException(agent_.logWriter_,
+                new ClientMessageId(SQLState.LANG_STREAM_RETRIEVED_ALREADY));
+        }
 
+        columnUsedFlags_[columnIndex - 1] = true;
     }
 
 
-    private void unuseStreams(){
-	
-	if(streamUsedFlags_ == null){
-	    streamUsedFlags_ = new boolean[ resultSetMetaData_.columns_ ];
-	    return;
-	}
-
-	for(int i = 0;
-	    i < streamUsedFlags_.length;
-	    i ++){
-	    
-	    streamUsedFlags_[i] = false;
-	    
-	}
-	
+    /**
+     * Clears the flags for used columns, typically invoked when changing the
+     * result set position.
+     */
+    private void unuseStreamsAndLOBs() {
+        if(columnUsedFlags_ != null){
+            Arrays.fill(columnUsedFlags_, false);
+        }
     }
 
     private SQLException jdbc3MethodNotSupported()
diff --git a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
index 8fe32cbeb..c931ba459 100644
--- a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
+++ b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
@@ -203,10 +203,11 @@ public abstract class EmbedResultSet extends ConnectionChild
     private int fetchSize;
     
     /**
-     * Indicates which columns have already been fetched
-     * as a stream for a row. Created on-demand by a getXXXStream call.
+     * Indicates which columns have been fetched as a stream or as a LOB for a
+     * row. Created on-demand by a getXXXStream or a get[BC]lob call. Note that
+     * we only track columns that can be accessed as a stream or a LOB object.
      */
-    private boolean[] streamUsedFlags;
+    private boolean[] columnUsedFlags;
     
 	/**
 	 * This class provides the glue between the Derby
@@ -508,9 +509,9 @@ public abstract class EmbedResultSet extends ConnectionChild
 		     }
 		    }
 
-			// Clear the indication of which columns were fetched as streams.
-			if (streamUsedFlags != null)
-			    Arrays.fill(streamUsedFlags, false);
+            // Clear the indication of which columns were fetched as streams.
+            if (columnUsedFlags != null)
+                Arrays.fill(columnUsedFlags, false);
 			if (columnGotUpdated != null && currentRowHasBeenUpdated) {
 				initializeUpdateRowModifiers();
 			}
@@ -1125,7 +1126,7 @@ public abstract class EmbedResultSet extends ConnectionChild
 		boolean pushStack = false;
 		try {
 
-		    useStream(columnIndex);
+            useStreamOrLOB(columnIndex);
 
             StringDataValue dvd = (StringDataValue)getColumn(columnIndex);
 
@@ -1238,7 +1239,7 @@ public abstract class EmbedResultSet extends ConnectionChild
 		boolean pushStack = false;
 		try {
 		    
-		    useStream(columnIndex);
+            useStreamOrLOB(columnIndex);
 
 			DataValueDescriptor dvd = getColumn(columnIndex);
 
@@ -3956,6 +3957,8 @@ public abstract class EmbedResultSet extends ConnectionChild
 		// on the underlying connection. Do this
 		// outside of the connection synchronization.
 
+        useStreamOrLOB(columnIndex);
+
 		synchronized (getConnectionSynchronization()) {
 			int colType = getColumnType(columnIndex);
 
@@ -4007,6 +4010,8 @@ public abstract class EmbedResultSet extends ConnectionChild
 		// on the underlying connection. Do this
 		// outside of the connection synchronization.
 
+        useStreamOrLOB(columnIndex);
+
 		synchronized (getConnectionSynchronization()) {
 			int colType = getColumnType(columnIndex);
 
@@ -4547,20 +4552,19 @@ public abstract class EmbedResultSet extends ConnectionChild
 	}
     
     /**
-     * Mark a column as already having a stream accessed from it.
-     * If the stream was already accessed, then throw an exception.
-     * @param columnIndex
-     * @throws SQLException
+     * Mark a column as already having a stream or LOB accessed from it.
+     * If the column was already accessed, throw an exception.
+     *
+     * @param columnIndex 1-based column index
+     * @throws SQLException if the column has already been accessed
      */
-    final void useStream(int columnIndex) throws SQLException {
-    	
-    	if (streamUsedFlags == null)
-    		streamUsedFlags = new boolean[getMetaData().getColumnCount()];
-    	
-    	else if (streamUsedFlags[columnIndex - 1])
-	        throw newSQLException(SQLState.LANG_STREAM_RETRIEVED_ALREADY);
-    	
-    	streamUsedFlags[columnIndex - 1] = true;
+    final void useStreamOrLOB(int columnIndex) throws SQLException {
+        if (columnUsedFlags == null) {
+            columnUsedFlags = new boolean[getMetaData().getColumnCount()];
+        } else if (columnUsedFlags[columnIndex - 1]) {
+            throw newSQLException(SQLState.LANG_STREAM_RETRIEVED_ALREADY);
+        }
+        columnUsedFlags[columnIndex - 1] = true;
     }
 
     /**
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index c84f69b63..89b3a8738 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -3875,7 +3875,7 @@ ln=lower-case two-letter ISO-639 language code, CO=upper-case two-letter ISO-316
 
             <msg>
                 <name>XCL18.S</name>
-                <text>Stream of column value in result cannot be retrieved twice</text>
+                <text>Stream or LOB value cannot be retrieved more than once</text>
             </msg>
 
             <msg>
diff --git a/java/engine/org/apache/derby/loc/messages_cs.properties b/java/engine/org/apache/derby/loc/messages_cs.properties
index 1d2cfe98a..5fca36a4b 100644
--- a/java/engine/org/apache/derby/loc/messages_cs.properties
+++ b/java/engine/org/apache/derby/loc/messages_cs.properties
@@ -1104,7 +1104,6 @@ XCL15.S=Vyskytla se v\u00fdjimka ClassCastException p\u0159i vol\u00e1n\u00ed me
 XCL16.S.0=Mno\u017eina v\u00fdsledk\u016f nen\u00ed otev\u0159ena. Operace ''{0}'' nen\u00ed povolena. Ov\u011b\u0159te, \u017ee automatick\u00e9 potvrzov\u00e1n\u00ed je VYPNUTO.
 # This one is used for the network client, where we don't know what operation is being performed.
 XCL16.S.1=Mno\u017eina v\u00fdsledk\u016f nen\u00ed otev\u0159ena. Ov\u011b\u0159te, \u017ee automatick\u00e9 potvrzov\u00e1n\u00ed je VYPNUTO.
-XCL18.S=Tok dat hodnoty sloupce ve v\u00fdsledku nelze na\u010d\u00edst dvakr\u00e1t
 XCL19.S=Chyb\u00ed \u0159\u00e1dek v tabulce ''{0}'' pro kl\u00ed\u010d ''{1}''.
 XCL20.S=Katalogy na \u00farovni verze ''{0}'' nelze pov\u00fd\u0161it na \u00farove\u0148 verze ''{1}''.
 XCL21.S=Pokou\u0161\u00edte se prov\u00e9st p\u0159\u00edkaz definice dat (CREATE, DROP nebo ALTER) p\u0159i p\u0159\u00edprav\u011b odli\u0161n\u00e9ho p\u0159\u00edkazu. Takov\u00fd p\u0159\u00edpad nen\u00ed povolen. K tomu m\u016f\u017ee doj\u00edt, pokud provedete p\u0159\u00edkaz definice dat ze statick\u00e9ho inicializ\u00e1toru t\u0159\u00eddy Javy, kter\u00e1 je pou\u017e\u00edv\u00e1na v p\u0159\u00edkazu SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_de_DE.properties b/java/engine/org/apache/derby/loc/messages_de_DE.properties
index 633cb0297..94d9c08c3 100644
--- a/java/engine/org/apache/derby/loc/messages_de_DE.properties
+++ b/java/engine/org/apache/derby/loc/messages_de_DE.properties
@@ -922,7 +922,6 @@ XCL14.S=Die Spaltenposition ''{0}'' befindet sich au\u00DFerhalb des Bereichs. D
 XCL15.S=Beim Aufrufen der Methode compareTo() f\u00FCr ein Objekt ''{0}'' ist eine ClassCastException eingetreten. Der Parameter f\u00FCr compareTo() geh\u00F6rt zur Klasse ''{1}''.
 XCL16.S.0=Das ResultSet ist nicht ge\u00F6ffnet. Die Operation ''{0}'' ist unzul\u00E4ssig. Pr\u00FCfen Sie, ob das automatische Festschreiben inaktiviert ist.
 XCL16.S.1=Das ResultSet ist nicht offen. Pr\u00FCfen Sie, ob das automatische Festschreiben inaktiviert ist.
-XCL18.S=Der Datenstrom des Spaltenwertes im Ergebnis kann nicht zweimal abgerufen werden.
 XCL19.S=In der Tabelle ''{0}'' fehlt die Zeile f\u00FCr den Schl\u00FCssel ''{1}''.
 XCL20.S=F\u00FCr Kataloge mit dem Versionsstand ''{0}'' kann kein Upgrade auf den Versionsstand ''{1}'' durchgef\u00FChrt werden.
 XCL21.S=Sie versuchen, eine Datendefinitionsanweisung (CREATE, DROP oder ALTER) auszuf\u00FChren, w\u00E4hrend Sie eine andere Anweisung vorbereiten. Dies ist unzul\u00E4ssig. Dies kann geschehen, wenn Sie eine Definitionsanweisung aus einem statischen Initialisierungsoperator f\u00FCr eine Java-Klasse heraus ausf\u00FChren, der innerhalb einer SQL-Anweisung verwendet wird.
diff --git a/java/engine/org/apache/derby/loc/messages_es.properties b/java/engine/org/apache/derby/loc/messages_es.properties
index 0c63d7df3..06e5809e3 100644
--- a/java/engine/org/apache/derby/loc/messages_es.properties
+++ b/java/engine/org/apache/derby/loc/messages_es.properties
@@ -922,7 +922,6 @@ XCL14.S=La posici\u00F3n de la columna ''{0}'' est\u00E1 fuera de rango.  El n\u
 XCL15.S=Se ha producido una ClassCastException al llamar al m\u00E9todo compareTo() sobre un objeto ''{0}''.  El par\u00E1metro para compareTo() es de clase ''{1}''.
 XCL16.S.0=ResultSet no abierto. Operaci\u00F3n ''{0}'' no permitida. Verifique que AutoCommit sea OFF.
 XCL16.S.1=ResultSet no abierto.  Verifique que AutoCommit sea OFF.
-XCL18.S=La corriente del valor de columna del resultado no se puede recuperar dos veces
 XCL19.S=Falta fila en la tabla ''{0}'' para la clave ''{1}''.
 XCL20.S=Los cat\u00E1logos del nivel de versi\u00F3n ''{0}'' no pueden actualizarse al nivel de versi\u00F3n ''{1}''.
 XCL21.S=Est\u00E1 intentando ejecutar una sentencia de definici\u00F3n de datos (CREATE, DROP o ALTER) mientras prepara una sentencia diferente. No est\u00E1 permitido. Puede suceder si ejecuta una sentencia de definici\u00F3n de datos desde un inicializador est\u00E1tico de una clase Java que se est\u00E1 utilizando desde una sentencia SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_fr.properties b/java/engine/org/apache/derby/loc/messages_fr.properties
index d30e3ad65..c9e05f408 100644
--- a/java/engine/org/apache/derby/loc/messages_fr.properties
+++ b/java/engine/org/apache/derby/loc/messages_fr.properties
@@ -922,7 +922,6 @@ XCL14.S=La position de colonne ''{0}'' est en dehors des limites.  Le nombre de
 XCL15.S=Une exception ClassCastException s''est produite lors de l''appel de la m\u00E9thode compareTo() sur un objet ''{0}''.  Le param\u00E8tre pour compareTo() est de classe ''{1}''.
 XCL16.S.0=L''\u00E9l\u00E9ment ResultSet n''est pas ouvert. L''op\u00E9ration ''{0}'' n''est pas autoris\u00E9e. V\u00E9rifiez que la fonction de validation automatique est d\u00E9sactiv\u00E9e (OFF).
 XCL16.S.1=L''\u00E9l\u00E9ment ResultSet n''est pas ouvert.  V\u00E9rifiez que la fonction de validation automatique est d\u00E9sactiv\u00E9e (OFF).
-XCL18.S=Le flux de valeurs de la colonne du r\u00E9sultat ne peut pas \u00EAtre extrait deux fois
 XCL19.S=Ligne manquante dans la table ''{0}'' pour la cl\u00E9 ''{1}''.
 XCL20.S=Les catalogues dont le niveau de version est ''{0}'' ne peuvent pas \u00EAtre mis \u00E0 niveau vers le niveau de version ''{1}''.
 XCL21.S=Vous essayez d''ex\u00E9cuter une instruction de d\u00E9finition de donn\u00E9es (CREATE, DROP ou ALTER) tandis que vous pr\u00E9parez une instruction diff\u00E9rente. Cette op\u00E9ration n''est pas admise. Cette situation peut se produire si vous ex\u00E9cutez une instruction de d\u00E9finition de donn\u00E9es \u00E0 partir d''un initialiseur statique d''une classe Java qui est en cours d''utilisation depuis une instruction SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_hu.properties b/java/engine/org/apache/derby/loc/messages_hu.properties
index e3e504d8a..66145e7b1 100644
--- a/java/engine/org/apache/derby/loc/messages_hu.properties
+++ b/java/engine/org/apache/derby/loc/messages_hu.properties
@@ -1104,7 +1104,6 @@ XCL15.S=ClassCastException t\u00f6rt\u00e9nt a compareTo() met\u00f3dus ''{0}''
 XCL16.S.0=A ResultSet nincs megnyitva. A(z) ''{0}'' m\u0171velet nem megengedett. Ellen\u0151rizze, hogy az autocommit ki van-e kapcsolva (OFF).
 # This one is used for the network client, where we don't know what operation is being performed.
 XCL16.S.1=A ResultSet nincs megnyitva.  Ellen\u0151rizze, hogy az autocommit ki van-e kapcsolva (OFF).
-XCL18.S=Az oszlop\u00e9rt\u00e9k folyama az eredm\u00e9nyben nem k\u00e9rhet\u0151 le k\u00e9tszer
 XCL19.S=A(z) ''{0}'' t\u00e1bl\u00e1ban a(z) ''{1}'' kulcshoz tartoz\u00f3 sor hi\u00e1nyzik.
 XCL20.S=A katal\u00f3gusok ''{0}'' v\u00e1ltozatszinten nem friss\u00edthet\u0151k ''{1}'' v\u00e1ltozatszintre.
 XCL21.S=Adatdefin\u00edci\u00f3s utas\u00edt\u00e1st (CREATE, DROP vagy ALTER) pr\u00f3b\u00e1l v\u00e9grehajtani egy m\u00e1sik utas\u00edt\u00e1s el\u0151k\u00e9sz\u00edt\u00e9se sor\u00e1n. Ez nem enged\u00e9lyezett. Ez akkor t\u00f6rt\u00e9nhet, ha adatdefin\u00edci\u00f3s utas\u00edt\u00e1st hajt v\u00e9gre egy SQL utas\u00edt\u00e1sban haszn\u00e1lni k\u00edv\u00e1nt Java oszt\u00e1ly statikus inicializ\u00e1l\u00f3j\u00e1b\u00f3l.
diff --git a/java/engine/org/apache/derby/loc/messages_it.properties b/java/engine/org/apache/derby/loc/messages_it.properties
index 6a982c1c7..3599d5ed4 100644
--- a/java/engine/org/apache/derby/loc/messages_it.properties
+++ b/java/engine/org/apache/derby/loc/messages_it.properties
@@ -922,7 +922,6 @@ XCL14.S=La posizione della colonna ''{0}'' non \u00E8 compresa nell''intervallo.
 XCL15.S=Si \u00E8 verificata una ClassCastException durante la chiamata del metodo compareTo() su un oggetto ''{0}''.  Il parametro sul metodo compareTo() \u00E8 di classe ''{1}''.
 XCL16.S.0=ResultSet non aperto. Operazione {0} non consentita. Verificare che l''autocommit sia in modalit\u00E0 OFF.
 XCL16.S.1=ResultSet non aperto.  Verificare che l''autocommit sia in modalit\u00E0 OFF.
-XCL18.S=Il flusso del valore della colonna nel risultato non pu\u00F2 essere richiamato due volte
 XCL19.S=Riga mancante nella tabella ''{0}'' per la chiave ''{1}''.
 XCL20.S=Impossibile aggiornare i cataloghi a livello della versione ''{0}'' al livello della versione ''{1}''.
 XCL21.S=Si sta tentando di eseguire un''istruzione di definizione dati (CREATE, DROP, o ALTER) durante la  preparazione di un''istruzione differente. Ci\u00F2 non \u00E8 consentito. Si pu\u00F2 verificare se si esegue un''istruzione di definizione dati da un inizializzatore statico di una classe Java, utilizzata da un''istruzione SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_ja_JP.properties b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
index dca7e6cde..2f352fea9 100644
--- a/java/engine/org/apache/derby/loc/messages_ja_JP.properties
+++ b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
@@ -922,7 +922,6 @@ XCL14.S=\u5217\u4F4D\u7F6E ''{0}'' \u306F\u7BC4\u56F2\u5916\u3067\u3059\u3002  \
 XCL15.S=\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8 ''{0}'' \u306B\u304A\u3044\u3066 compareTo() \u30E1\u30BD\u30C3\u30C9\u3092\u547C\u3073\u51FA\u3057\u3066\u3044\u308B\u3068\u304D\u306B ClassCastException \u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002  compareTo() \u306E\u30D1\u30E9\u30E1\u30FC\u30BF\u30FC\u306F\u30AF\u30E9\u30B9 ''{1}'' \u3067\u3059\u3002
 XCL16.S.0=ResultSet \u304C\u30AA\u30FC\u30D7\u30F3\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002 \u30AA\u30DA\u30EC\u30FC\u30B7\u30E7\u30F3 ''{0}'' \u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093\u3002 \u81EA\u52D5\u30B3\u30DF\u30C3\u30C8\u304C\u30AA\u30D5\u306B\u306A\u3063\u3066\u3044\u308B\u3053\u3068\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 XCL16.S.1=ResultSet \u304C\u30AA\u30FC\u30D7\u30F3\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002  \u81EA\u52D5\u30B3\u30DF\u30C3\u30C8\u304C\u30AA\u30D5\u306B\u306A\u3063\u3066\u3044\u308B\u3053\u3068\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-XCL18.S=\u7D50\u679C\u5185\u306E\u5217\u5024\u306E\u30B9\u30C8\u30EA\u30FC\u30E0\u3092 2 \u56DE\u53D6\u5F97\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
 XCL19.S=\u8868 ''{0}'' \u306B\u30AD\u30FC ''{1}'' \u306B\u5BFE\u3059\u308B\u884C\u304C\u3042\u308A\u307E\u305B\u3093\u3002
 XCL20.S=\u30D0\u30FC\u30B8\u30E7\u30F3\u30FB\u30EC\u30D9\u30EB ''{0}'' \u306E\u30AB\u30BF\u30ED\u30B0\u3092\u3001\u30D0\u30FC\u30B8\u30E7\u30F3\u30FB\u30EC\u30D9\u30EB ''{1}'' \u306B\u30A2\u30C3\u30D7\u30B0\u30EC\u30FC\u30C9\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
 XCL21.S=\u5225\u306E\u30B9\u30C6\u30FC\u30C8\u30E1\u30F3\u30C8\u3092\u6E96\u5099\u3057\u306A\u304C\u3089\u3001\u30C7\u30FC\u30BF\u5B9A\u7FA9\u30B9\u30C6\u30FC\u30C8\u30E1\u30F3\u30C8 (CREATE\u3001DROP\u3001\u307E\u305F\u306F ALTER) \u3092\u5B9F\u884C\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u307E\u3059\u3002 \u3053\u308C\u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093\u3002 \u3053\u308C\u306F\u3001SQL \u30B9\u30C6\u30FC\u30C8\u30E1\u30F3\u30C8\u5185\u304B\u3089\u4F7F\u7528\u3055\u308C\u3066\u3044\u308B Java \u30AF\u30E9\u30B9\u306E\u9759\u7684\u30A4\u30CB\u30B7\u30E3\u30E9\u30A4\u30B6\u30FC\u5185\u304B\u3089\u30C7\u30FC\u30BF\u5B9A\u7FA9\u30B9\u30C6\u30FC\u30C8\u30E1\u30F3\u30C8\u3092\u5B9F\u884C\u3057\u305F\u5834\u5408\u306B\u8D77\u3053\u308B\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_ko_KR.properties b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
index a9f08d8e6..e8d1de87d 100644
--- a/java/engine/org/apache/derby/loc/messages_ko_KR.properties
+++ b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
@@ -922,7 +922,6 @@ XCL14.S=''{0}'' \uC5F4 \uC704\uCE58\uAC00 \uBC94\uC704\uB97C \uBC97\uC5B4\uB0AC\
 XCL15.S=''{0}'' \uC624\uBE0C\uC81D\uD2B8\uC5D0\uC11C compareTo() \uBA54\uC18C\uB4DC\uB97C \uD638\uCD9C\uD560 \uB54C ClassCastException\uC774 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. compareTo()\uC5D0 \uB300\uD55C \uB9E4\uAC1C\uBCC0\uC218\uC758 \uD074\uB798\uC2A4\uB294 ''{1}''\uC785\uB2C8\uB2E4.
 XCL16.S.0=Resultset\uC774 \uC5F4\uB9AC\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. ''{0}'' \uC870\uC791\uC740 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uC790\uB3D9 \uD655\uC57D\uC774 OFF\uC778\uC9C0 \uD655\uC778\uD558\uC2ED\uC2DC\uC624.
 XCL16.S.1=Resultset\uC774 \uC5F4\uB9AC\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC790\uB3D9 \uD655\uC57D\uC774 OFF\uC778\uC9C0 \uD655\uC778\uD558\uC2ED\uC2DC\uC624.
-XCL18.S=\uACB0\uACFC\uC5D0 \uC788\uB294 \uC5F4 \uAC12\uC758 \uC2A4\uD2B8\uB9BC\uC740 \uB450 \uBC88 \uAC80\uC0C9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.
 XCL19.S=''{1}'' \uD0A4\uC758 ''{0}'' \uD14C\uC774\uBE14\uC5D0\uC11C \uD589\uC774 \uB204\uB77D\uB418\uC5C8\uC2B5\uB2C8\uB2E4.
 XCL20.S=\uBC84\uC804 \uB808\uBCA8 ''{0}''\uC758 \uCE74\uD0C8\uB85C\uADF8\uB97C \uBC84\uC804 \uB808\uBCA8 ''{1}''(\uC73C)\uB85C \uC5C5\uADF8\uB808\uC774\uB4DC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.
 XCL21.S=\uB2E4\uB978 \uBA85\uB839\uBB38\uC744 \uC900\uBE44\uD558\uB294 \uB3D9\uC548 \uB370\uC774\uD130 \uC815\uC758 \uBA85\uB839\uBB38(CREATE, DROP \uB610\uB294 ALTER)\uC744 \uC2E4\uD589\uD558\uB824\uACE0 \uC2DC\uB3C4\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4. \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. SQL\uBB38 \uB0B4\uC5D0\uC11C \uC0AC\uC6A9\uB418\uACE0 \uC788\uB294 Java \uD074\uB798\uC2A4\uC758 \uC815\uC801 \uCD08\uAE30\uC790 \uB0B4\uC5D0\uC11C \uB370\uC774\uD130 \uC815\uC758 \uBA85\uB839\uBB38\uC744 \uC2E4\uD589\uD558\uB294 \uACBD\uC6B0\uC5D0 \uC774\uB7EC\uD55C \uC0C1\uD0DC\uAC00 \uBC1C\uC0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.
diff --git a/java/engine/org/apache/derby/loc/messages_pl.properties b/java/engine/org/apache/derby/loc/messages_pl.properties
index 9332dba4b..2a8bc0c66 100644
--- a/java/engine/org/apache/derby/loc/messages_pl.properties
+++ b/java/engine/org/apache/derby/loc/messages_pl.properties
@@ -1104,7 +1104,6 @@ XCL15.S=Wyst\u0105pi\u0142 wyj\u0105tek ClassCastException podczas wywo\u0142ywa
 XCL16.S.0=Obiekt ResultSet nie jest otwarty. Operacja ''{0}'' nie jest dozwolona. Sprawd\u017a, czy funkcja automatycznego zatwierdzania jest wy\u0142\u0105czona (OFF).
 # This one is used for the network client, where we don't know what operation is being performed.
 XCL16.S.1=Obiekt ResultSet nie jest otwarty. Sprawd\u017a, czy funkcja automatycznego zatwierdzania jest wy\u0142\u0105czona (OFF).
-XCL18.S=Strumie\u0144 warto\u015bci kolumny w wyniku nie mo\u017ce by\u0107 pobierany dwa razy
 XCL19.S=Brak wiersza w tabeli ''{0}'' dla klucza ''{1}''.
 XCL20.S=Katalogi w wersji ''{0}'' nie mog\u0105 by\u0107 aktualizowane do wersji ''{1}''.
 XCL21.S=Pr\u00f3ba wykonania instrukcji definicji danych (CREATE, DROP lub ALTER) podczas przygotowywania innej instrukcji. To nie jest dozwolone. Mo\u017ce si\u0119 to zdarzy\u0107 podczas wywo\u0142ywania instrukcji definicji danych z inicjatora statycznego klasy Java, kt\u00f3ry jest u\u017cywany w instrukcji SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_pt_BR.properties b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
index 7b752d748..57fcd56ab 100644
--- a/java/engine/org/apache/derby/loc/messages_pt_BR.properties
+++ b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
@@ -1100,7 +1100,6 @@ XCL15.S=Ocorreu uma ClassCastException ao chamar o m\u00e9todo compareTo() no ob
 XCL16.S.0=O ResultSet n\u00e3o est\u00e1 aberto. A opera\u00e7\u00e3o ''{0}'' n\u00e3o \u00e9 permitida. Verifique se a auto-efetiva\u00e7\u00e3o est\u00e1 desabilitada.
 # This one is used for the network client, where we don't know what operation is being performed.
 XCL16.S.1=O ResultSet n\u00e3o est\u00e1 abero.  Verifique se a auto-efetiva\u00e7\u00e3o est\u00e1 desabilitada.
-XCL18.S=O fluxo do valor da coluna no resultado n\u00e3o pode ser trazido duas vezes.
 XCL19.S=Faltando a linha da tabela ''{0}'' para a chave ''{1}''.
 XCL20.S=Os cat\u00e1logos no n\u00edvel de vers\u00e3o ''{0}'' n\u00e3o podem ser atualizados para o n\u00edvel de vers\u00e3o ''{1}''.
 XCL21.S=Tentativa de executar uma instru\u00e7\u00e3o de defini\u00e7\u00e3o de dados (CREATE, DROP ou ALTER) durante a prepara\u00e7\u00e3o de uma instru\u00e7\u00e3o diferente. Isto n\u00e3o \u00e9 permitido. Isto pode ocorrer se for executada uma instru\u00e7\u00e3o de defini\u00e7\u00e3o de dados de dentro de um inicializador est\u00e1tico de uma classe Java que est\u00e1 sendo utilizada de dentro de uma instru\u00e7\u00e3o SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_ru.properties b/java/engine/org/apache/derby/loc/messages_ru.properties
index 884e7d571..77167d04d 100644
--- a/java/engine/org/apache/derby/loc/messages_ru.properties
+++ b/java/engine/org/apache/derby/loc/messages_ru.properties
@@ -1104,7 +1104,6 @@ XCL15.S=\u041f\u0440\u043e\u0438\u0437\u043e\u0448\u043b\u043e \u0438\u0441\u043
 XCL16.S.0=\u041d\u0430\u0431\u043e\u0440 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 (ResultSet) \u043d\u0435 \u043e\u0442\u043a\u0440\u044b\u0442. \u041e\u043f\u0435\u0440\u0430\u0446\u0438\u044f ''{0}'' \u043d\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0430. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u043e\u043f\u0446\u0438\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f \u0432\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u0430 (OFF).
 # This one is used for the network client, where we don't know what operation is being performed.
 XCL16.S.1=\u041d\u0430\u0431\u043e\u0440 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 (ResultSet) \u043d\u0435 \u043e\u0442\u043a\u0440\u044b\u0442.  \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u043e\u043f\u0446\u0438\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f \u0432\u044b\u043a\u043b\u044e\u0447\u0435\u043d\u0430 (OFF).
-XCL18.S=\u041f\u043e\u0442\u043e\u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u043d\u0435\u043b\u044c\u0437\u044f \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u0432\u0430\u0436\u0434\u044b
 XCL19.S=\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0430 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 ''{0}'' \u0434\u043b\u044f \u043a\u043b\u044e\u0447\u0430 ''{1}''.
 XCL20.S=\u041a\u0430\u0442\u0430\u043b\u043e\u0433\u0438 \u0432\u0435\u0440\u0441\u0438\u0438 \u0443\u0440\u043e\u0432\u043d\u044f ''{0}'' \u043d\u0435\u043b\u044c\u0437\u044f \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0434\u043e \u0432\u0435\u0440\u0441\u0438\u0438 \u0443\u0440\u043e\u0432\u043d\u044f ''{1}''.
 XCL21.S=\u0412\u044b \u043f\u044b\u0442\u0430\u0435\u0442\u0435\u0441\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 (CREATE, DROP \u0438\u043b\u0438 ALTER) \u043f\u0440\u0438 \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0435 \u0434\u0440\u0443\u0433\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430. \u042d\u0442\u043e \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442\u0441\u044f. \u042d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442\u044c, \u0435\u0441\u043b\u0438 \u0432\u044b \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0442\u043e\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 Java, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0438\u0437 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430 SQL.
diff --git a/java/engine/org/apache/derby/loc/messages_zh_CN.properties b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
index 3030a28f0..568c78ada 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_CN.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
@@ -922,7 +922,6 @@ XCL14.S=\u5217\u4F4D\u7F6E\u201C{0}\u201D\u8D85\u51FA\u8303\u56F4\u3002\u6B64 Re
 XCL15.S=\u5F53\u5728\u5BF9\u8C61\u201C{0}\u201D\u4E0A\u8C03\u7528 compareTo() \u65B9\u6CD5\u65F6\uFF0C\u53D1\u751F ClassCastException\u3002compareTo() \u7684\u53C2\u6570\u5C5E\u4E8E\u7C7B\u201C{1}\u201D\u3002
 XCL16.S.0=ResultSet \u672A\u6253\u5F00\u3002\u4E0D\u5141\u8BB8\u64CD\u4F5C\u201C{0}\u201D\u3002\u9A8C\u8BC1\u81EA\u52A8\u843D\u5B9E\u662F\u5426\u5DF2\u5173\u95ED\u3002
 XCL16.S.1=ResultSet \u672A\u6253\u5F00\u3002\u9A8C\u8BC1\u81EA\u52A8\u843D\u5B9E\u662F\u5426\u5DF2\u5173\u95ED\u3002
-XCL18.S=\u4E0D\u80FD\u68C0\u7D22\u4E24\u6B21\u7ED3\u679C\u4E2D\u7684\u5217\u503C\u6D41\u3002
 XCL19.S=\u5173\u952E\u5B57\u201C{1}\u201D\u7684\u8868\u201C{0}\u201D\u7F3A\u5C11\u884C\u3002
 XCL20.S=\u7248\u672C\u7EA7\u522B\u201C{0}\u201D\u4E0A\u7684\u76EE\u5F55\u65E0\u6CD5\u5347\u7EA7\u4E3A\u7248\u672C\u7EA7\u522B\u201C{1}\u201D\u3002
 XCL21.S=\u5728\u51C6\u5907\u4E0D\u540C\u7684\u8BED\u53E5\u65F6\uFF0C\u60A8\u5C1D\u8BD5\u6267\u884C\u6570\u636E\u5B9A\u4E49\u8BED\u53E5\uFF08CREATE\u3001DROP \u6216 ALTER\uFF09\u3002\u8FD9\u662F\u4E0D\u5141\u8BB8\u7684\u3002\u5982\u679C\u60A8\u4ECE Java \u7C7B\u7684\u9759\u6001\u521D\u59CB\u5316\u7A0B\u5E8F\uFF08\u6B63\u5728\u4ECE SQL \u8BED\u53E5\u5185\u4F7F\u7528\uFF09\u5185\u6267\u884C\u6570\u636E\u5B9A\u4E49\u8BED\u53E5\uFF0C\u5219\u5B83\u4F1A\u53D1\u751F\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_zh_TW.properties b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
index 99d443317..e0636733c 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_TW.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
@@ -922,7 +922,6 @@ XCL14.S=\u76F4\u6B04\u4F4D\u7F6E ''{0}'' \u8D85\u51FA\u7BC4\u570D\u3002\u6B64 Re
 XCL15.S=\u547C\u53EB\u7269\u4EF6 ''{0}'' \u4E0A\u7684 compareTo() \u65B9\u6CD5\u6642\uFF0C\u767C\u751F ClassCastException\u3002compareTo() \u4E4B\u53C3\u6578\u7684\u985E\u5225\u662F ''{1}''\u3002
 XCL16.S.0=\u672A\u958B\u555F ResultSet\u3002\u4E0D\u5141\u8A31\u57F7\u884C\u4F5C\u696D ''{0}''\u3002\u8ACB\u78BA\u8A8D\u81EA\u52D5\u78BA\u5B9A\u662F OFF\u3002
 XCL16.S.1=\u672A\u958B\u555F ResultSet\u3002\u8ACB\u78BA\u8A8D\u81EA\u52D5\u78BA\u5B9A\u662F OFF\u3002
-XCL18.S=\u7D50\u679C\u4E2D\u7684\u76F4\u6B04\u503C\u4E32\u6D41\u7121\u6CD5\u64F7\u53D6\u5169\u6B21
 XCL19.S=\u907A\u6F0F\u7D22\u5F15\u9375 ''{1}'' \u4E4B\u8868\u683C ''{0}'' \u4E2D\u7684\u5217\u3002
 XCL20.S=\u7121\u6CD5\u5C07\u7248\u672C\u5C64\u6B21 ''{0}'' \u7684\u578B\u9304\u5347\u7D1A\u6210\u7248\u672C\u5C64\u6B21 ''{1}''\u3002
 XCL21.S=\u60A8\u5728\u6E96\u5099\u5176\u4ED6\u9673\u8FF0\u5F0F\u6642\uFF0C\u8A66\u5716\u57F7\u884C\u300C\u8CC7\u6599\u5B9A\u7FA9\u300D\u9673\u8FF0\u5F0F\uFF08CREATE\u3001DROP \u6216 ALTER\uFF09\u3002\u9019\u662F\u4E0D\u5141\u8A31\u7684\u3002\u5982\u679C\u60A8\u5F9E SQL \u9673\u8FF0\u5F0F\u5167\u6B63\u5728\u4F7F\u7528\u7684 Java \u985E\u5225\u4E4B\u975C\u614B\u8D77\u59CB\u8A2D\u5B9A\u5143\u5167\u57F7\u884C\u300C\u8CC7\u6599\u5B9A\u7FA9\u300D\u9673\u8FF0\u5F0F\uFF0C\u5C31\u53EF\u80FD\u767C\u751F\u9019\u500B\u60C5\u6CC1\u3002
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/BlobClob4BlobTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/BlobClob4BlobTest.java
index efac73c51..5efd54e2a 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/BlobClob4BlobTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/BlobClob4BlobTest.java
@@ -422,12 +422,13 @@ public class BlobClob4BlobTest extends BaseJDBCTestCase {
             assertTrue("statement trigger produced less rows " +
                     count, trigBRS.next());
 
-            if (origRS.getClob(1) != null) {
+            Clob origClob = origRS.getClob(1);
+            if (origClob != null) {
                 assertEquals("FAIL - Invalid checksum for row trigger",
-                        getStreamCheckSum(origRS.getClob(1).getAsciiStream()),
+                        getStreamCheckSum(origClob.getAsciiStream()),
                         getStreamCheckSum(trigARS.getClob(1).getAsciiStream()));
                 assertEquals("FAIL - Invalid checksum for statement trigger",
-                        getStreamCheckSum(origRS.getClob(1).getAsciiStream()),
+                        getStreamCheckSum(origClob.getAsciiStream()),
                         getStreamCheckSum(trigBRS.getClob(1).getAsciiStream()));
             }
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/LobStreamsTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/LobStreamsTest.java
index a876c0bd9..97e1bbafb 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/LobStreamsTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/LobStreamsTest.java
@@ -27,14 +27,15 @@ import java.io.Writer;
 
 import java.sql.Blob;
 import java.sql.Clob;
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.sql.Statement;
 
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
+import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
 import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
 import org.apache.derbyTesting.junit.Decorator;
@@ -86,6 +87,127 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         stmt2.close();
     }
 
+    /**
+     * Originally tested that the usage pattern {@code rs.getBlob().method()}
+     * didn't cause the underlying source stream to be closed too early. This
+     * behavior was forbidden, the test now checks that an exception is thrown.
+     * <p>
+     * Test description: Select from a BLOB column, access the BLOB using the
+     * pattern rs.getBlob(1).blobMethod() (note that we do not keep a reference
+     * to the Blob-object), provoke/invoke GC and finalization, and finally try
+     * to access the same BLOB again (through a different/another call to
+     * rs.getBlob(1)).
+     * <p>
+     * Note that the BLOB must be of a certain size (i.e. multiple pages), such
+     * that it is stored/accessed as a stream in store.
+     * <p>
+     * See DERBY-3844 and DERBY-4440.
+     *
+     * @throws Exception if something goes wrong
+     */
+    public void testGettingBlobTwice()
+            throws Exception {
+        setAutoCommit(false);
+        // We need a Blob represented as a stream in store.
+        int length = 71*1024+7;
+        PreparedStatement ps =
+                prepareStatement("insert into testBlobX1(a,b) values (?,?)");
+        ps.setInt(1, 2);
+        ps.setBinaryStream(2, new LoopingAlphabetStream(length), length);
+        ps.executeUpdate();
+        ps.close();
+
+        // Get a result set with the Blob.
+        ps = prepareStatement("select b from testBlobX1 where a = ?");
+        ps.setInt(1, 2);
+        ResultSet rs = ps.executeQuery();
+        assertTrue(rs.next());
+        Blob b = rs.getBlob(1);
+        try {
+            // Get the length, but don't keep a reference to the Blob.
+            assertEquals(length, rs.getBlob(1).length());
+            fail("Getting the Blob the second time should have failed");
+        } catch (SQLException sqle) {
+            assertSQLState("XCL18", sqle);
+        }
+
+        // Increase the likelyhood of getting the finalizer run.
+        // Create some junk to fill up the heap, hopefully not JIT'ed away...
+        int size = 10*1024; // 10 K
+        byte[] bytes = null;
+        for (int i=0; i < 50; i++) {
+            bytes = new byte[size *(i +1)];
+        }
+        // For good measure...
+        System.gc();
+        System.runFinalization();
+        try {
+            Thread.sleep(100L);
+        } catch (InterruptedException ie) {
+            // No need to reset the interrupted flag here in the test.
+        }
+
+        // This will fail if the finalizer caused the source stream to be
+        // closed and the source page to be unlatched.
+        InputStream is = b.getBinaryStream();
+        while (is.read() != -1) {
+            // Keep on reading...
+        }
+        assertNotNull(bytes);
+    }
+
+    /**
+     * Tests that accessing the same Clob multiple times on a row results in
+     * an exception being thrown.
+     *
+     * @throws Exception if something goes wrong
+     */
+    public void testGettingClobTwice()
+            throws SQLException {
+        // We need a few Clobs.
+        int length = 71*1024+7;
+        PreparedStatement ps =
+                prepareStatement("insert into testBlobX1(a,c) values (?,?)");
+        ps.setInt(1, 3);
+        ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
+        ps.executeUpdate();
+        ps.setInt(1, 4);
+        ps.setString(2, "short clob");
+        ps.executeUpdate();
+        ps.close();
+
+        // Get a result set with the Clobs.
+        final int clobCount = 2;
+        int count = 0;
+        ps = prepareStatement(
+                "select c from testBlobX1 where a >= ? and a <= ?");
+        ps.setInt(1, 3);
+        ps.setInt(2, 4);
+        ResultSet rs = ps.executeQuery();
+        assertTrue(rs.next());
+        do {
+            count++;
+            // First get a Clob.
+            Clob c = rs.getClob(1);
+            // Get a second Clob, which should fail.
+            try {
+                rs.getClob(1);
+                fail("Getting the Clob the second time should have failed");
+            } catch (SQLException sqle) {
+                assertSQLState("XCL18", sqle);
+            }
+            // Finally try to access the column as a stream.
+            try {
+                rs.getCharacterStream(1);
+                fail("Getting the Clob the third time should have failed");
+            } catch (SQLException sqle) {
+                assertSQLState("XCL18", sqle);
+            }
+        } while (rs.next());
+        rs.close();
+        assertEquals(clobCount, count);
+    }
+
     /**
      * Tests the BlobOutputStream.write(byte  b[], int off, int len) method
      **/
@@ -120,13 +242,14 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3 = stmt3.executeQuery();
         assertTrue("FAIL -- blob not found", rs3.next());
 
-        long new_length = rs3.getBlob(1).length();
+        blob = rs3.getBlob(1);
+        long new_length = blob.length();
         assertEquals("FAIL -- wrong blob length;",
                 streamSize[0], new_length);
 
         // Check contents ...
         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
-        InputStream lStream = rs3.getBlob(1).getBinaryStream();
+        InputStream lStream = blob.getBinaryStream();
         assertTrue("FAIL - Blob and file contents do not match",
                 compareLob2File(fStream, lStream));
 
@@ -169,12 +292,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
 
         assertTrue("FAIL -- blob not found", rs3.next());
 
-        long new_length = rs3.getBlob(1).length();
+        blob = rs3.getBlob(1);
+        long new_length = blob.length();
         assertEquals("FAIL -- wrong blob length", streamSize[1], new_length);
 
         // Check contents ...
         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
-        InputStream lStream = rs3.getBlob(1).getBinaryStream();
+        InputStream lStream = blob.getBinaryStream();
         assertTrue("FAIL - Blob and file contents do not match",
                 compareLob2File(fStream, lStream));
 
@@ -216,12 +340,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3 = stmt3.executeQuery();
         assertTrue("FAIL -- clob not found", rs3.next());
 
-        long new_length = rs3.getClob(1).length();
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length", streamSize[1], new_length);
 
         // Check contents ...
         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
-        InputStream lStream = rs3.getClob(1).getAsciiStream();
+        InputStream lStream = clob.getAsciiStream();
         assertTrue("FAIL - Clob and file contents do not match", compareLob2File(fStream, lStream));
         fStream.close();
         lStream.close();
@@ -264,12 +389,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
 
         assertTrue("FAIL -- clob not found", rs3.next());
 
-        long new_length = rs3.getClob(1).length();
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length",
                 streamSize[0], new_length);
         // Check contents ...
         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
-        InputStream lStream = rs3.getClob(1).getAsciiStream();
+        InputStream lStream = clob.getAsciiStream();
         assertTrue("FAIL - Clob and file contents do not match",
                 compareLob2File(fStream, lStream));
 
@@ -306,12 +432,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3 = stmt3.executeQuery();
 
         assertTrue("FAIL -- clob not found", rs3.next());
-        long new_length = rs3.getClob(1).length();
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length",
                 testdata.length, new_length);
 
         // Check contents ...
-        Reader lStream = rs3.getClob(1).getCharacterStream();
+        Reader lStream = clob.getCharacterStream();
         assertTrue("FAIL - Clob and buffer contents do not match",
                 compareClobReader2CharArray(testdata, lStream));
 
@@ -344,11 +471,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3.close();
         rs3 = stmt3.executeQuery();
         assertTrue("FAIL -- clob not found", rs3.next());
-        long new_length = rs3.getClob(1).length();
+
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
 
         // Check contents ...
-        Reader lStream = rs3.getClob(1).getCharacterStream();
+        Reader lStream = clob.getCharacterStream();
         assertTrue("FAIL - Clob and buffer contents do not match",
                 compareClobReader2CharArray(
                     unicodeTestString.toCharArray(),
@@ -383,11 +512,13 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3.close();
         rs3 = stmt3.executeQuery();
         assertTrue("FAIL -- clob not found", rs3.next());
-        long new_length = rs3.getClob(1).length();
+
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
 
         // Check contents ...
-        Reader lStream = rs3.getClob(1).getCharacterStream();
+        Reader lStream = clob.getCharacterStream();
         assertTrue("FAIL - Clob and buffer contents do not match",
                 compareClobReader2CharArray(
                     unicodeTestString.toCharArray(),
@@ -425,11 +556,12 @@ public class LobStreamsTest extends BaseJDBCTestCase {
         rs3.close();
         rs3 = stmt3.executeQuery();
         assertTrue("FAIL -- clob not found", rs3.next());
-        long new_length = rs3.getClob(1).length();
-        Clob fish = rs3.getClob(1);
+
+        clob = rs3.getClob(1);
+        long new_length = clob.length();
         assertEquals("FAIL -- wrong clob length", 1, new_length);
         // Check contents ...
-        Reader lStream = rs3.getClob(1).getCharacterStream();
+        Reader lStream = clob.getCharacterStream();
         char clobchar = (char) lStream.read();
         assertEquals("FAIL - fetched Clob and original contents do " +
                 "not match", testchar, clobchar);
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/TableFunctionTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/TableFunctionTest.java
index 659c71438..5fd23d34e 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/TableFunctionTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/TableFunctionTest.java
@@ -2058,12 +2058,14 @@ public class TableFunctionTest extends BaseJDBCTestCase
                     break;
 
                 case Types.BLOB:
-                    actualValue = squeezeString(  rs.getBlob( column ) );
-                    actualValueByName = squeezeString(  rs.getBlob( columnName ) );
+                    Blob blob = rs.getBlob(column);
+                    actualValue = squeezeString(blob);
+                    actualValueByName = squeezeString(blob);
                     break;
                 case Types.CLOB:
-                    actualValue = squeezeString(  rs.getClob( column ) );
-                    actualValueByName = squeezeString(  rs.getClob( columnName ) );
+                    Clob clob = rs.getClob(column);
+                    actualValue = squeezeString(clob);
+                    actualValueByName = squeezeString(clob);
                     break;
 
                 case Types.BINARY:
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UpdatableResultSetTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UpdatableResultSetTest.java
index 94d732b26..350b877e5 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UpdatableResultSetTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UpdatableResultSetTest.java
@@ -4518,11 +4518,12 @@ public class UpdatableResultSetTest  extends BaseJDBCTestCase {
                             rs1.getBytes(updateXXXName)));
         } else if (sqlType == 13 && JDBC.vmSupportsJDBC3()) {
             // verify update made to CLOB column with updateXXX methods
-            int len = (int)rs.getClob(sqlType).length();
+            Clob clob = rs.getClob(sqlType);
+            int len = (int)clob.length();
             assertEquals("FAIL - wrong value on " + allSQLTypes[sqlType - 1] + 
                     " using " + allUpdateXXXNames[updateXXXName - 1],
                     rs1.getString(updateXXXName).trim(), 
-                    rs.getClob(sqlType).getSubString(1, len).trim());
+                    clob.getSubString(1, len).trim());
         } else if (sqlType == 14) {
             // verify update made to DATE column with updateXXX methods
             assertEquals("FAIL - wrong value on " + allSQLTypes[sqlType - 1] + 
@@ -4540,10 +4541,11 @@ public class UpdatableResultSetTest  extends BaseJDBCTestCase {
                     rs1.getTimestamp(updateXXXName), rs.getTimestamp(sqlType));
         } else if (sqlType == 17 && JDBC.vmSupportsJDBC3()) {
             // verify update made to BLOB column with updateXXX methods
-            long len = rs.getBlob(sqlType).length();
+            Blob blob = rs.getBlob(sqlType);
+            long len = blob.length();
             assertTrue("FAIL - wrong value on " + allSQLTypes[sqlType - 1] + 
                     " using " + allUpdateXXXNames[updateXXXName - 1],
-                    Arrays.equals(rs.getBlob(sqlType).getBytes(1, (int)len), 
+                    Arrays.equals(blob.getBytes(1, (int)len),
                     rs1.getBytes(updateXXXName)));
         }
         
