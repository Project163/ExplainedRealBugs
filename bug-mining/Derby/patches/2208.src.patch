diff --git a/java/engine/org/apache/derby/iapi/services/memory/LowMemory.java b/java/engine/org/apache/derby/iapi/services/memory/LowMemory.java
index 822fe6320..290d3dc60 100644
--- a/java/engine/org/apache/derby/iapi/services/memory/LowMemory.java
+++ b/java/engine/org/apache/derby/iapi/services/memory/LowMemory.java
@@ -90,14 +90,21 @@ public class LowMemory {
             // up some memory that throws off our calcuation. This is
             // avoided by clearing lowMemory some time later on an
             // isLowMemory() call.
+            boolean interrupted = false;
+
             for (int i = 0; i < 5; i++) {
                 System.gc();
                 System.runFinalization();
                 try {
                     Thread.sleep(50L);
                 } catch (InterruptedException e) {
+                    interrupted = true;
                 }
             }
+            if (interrupted) {
+                // reinstate flag
+                Thread.currentThread().interrupt();
+            }
         }
         synchronized (this) {
             if (lowMemory == 0L) {
diff --git a/java/engine/org/apache/derby/iapi/util/InterruptStatus.java b/java/engine/org/apache/derby/iapi/util/InterruptStatus.java
index 0c09ef28a..a671e059a 100644
--- a/java/engine/org/apache/derby/iapi/util/InterruptStatus.java
+++ b/java/engine/org/apache/derby/iapi/util/InterruptStatus.java
@@ -58,7 +58,7 @@ public class InterruptStatus {
 
     /**
      * Use thread local variable to store interrupt status flag *only* if we
-     * don't have lcc, e.g. during database creation.
+     * don't have lcc, e.g. during database creation, shutdown etc.
      */
     private static final ThreadLocal exception = new ThreadLocal ();
 
diff --git a/java/engine/org/apache/derby/impl/db/SlaveDatabase.java b/java/engine/org/apache/derby/impl/db/SlaveDatabase.java
index f6115dfa0..9d78315db 100644
--- a/java/engine/org/apache/derby/impl/db/SlaveDatabase.java
+++ b/java/engine/org/apache/derby/impl/db/SlaveDatabase.java
@@ -30,6 +30,7 @@ import org.apache.derby.iapi.jdbc.AuthenticationService;
 import org.apache.derby.iapi.services.context.ContextManager;
 import org.apache.derby.iapi.services.context.ContextService;
 import org.apache.derby.iapi.services.monitor.Monitor;
+import org.apache.derby.iapi.util.InterruptStatus;
 import org.apache.derby.iapi.store.replication.slave.SlaveFactory;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
 
@@ -271,7 +272,7 @@ public class SlaveDatabase extends BasicDatabase {
                 try {
                     Thread.sleep(500);
                 } catch (InterruptedException ie) {
-                // do nothing
+                    InterruptStatus.setInterrupted();
                 }
             }
         } else {
@@ -347,7 +348,7 @@ public class SlaveDatabase extends BasicDatabase {
                 try {
                     Thread.sleep(500);
                 } catch (InterruptedException ie) {
-                    // do nothing
+                    InterruptStatus.setInterrupted();
                 }
             }
         }
diff --git a/java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java b/java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java
index 4bcd802e9..ebcf85471 100644
--- a/java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java
+++ b/java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java
@@ -2614,22 +2614,27 @@ public abstract class EmbedConnection implements EngineConnection
     }
 
     /**
-     * Puts the current thread to sleep and sets the interrupt flag of the
-     * thread if an {@code InterruptedException} is thrown while sleeping.
+     * Puts the current thread to sleep.
      * <p>
-     * <em>NOTE</em>: This method does not guarantee that the thread sleeps at
+     * <em>NOTE</em>: This method guarantees that the thread sleeps at
      * least {@code millis} milliseconds.
      *
      * @param millis milliseconds to sleep
      */
     private static void sleep(long millis) {
-        try {
-            Thread.sleep(millis);
-        } catch (InterruptedException ie) {
-            // Set the interrupt flag of the thread to allow code higher up the
-            // stack to detect the interruption.
-            Thread.currentThread().interrupt();
+        long startMillis = System.currentTimeMillis();
+        long waited = 0L;
+        while (waited < millis) {
+            try {
+                Thread.sleep(millis - waited);
+            } catch (InterruptedException ie) {
+                InterruptStatus.setInterrupted();
+                waited = System.currentTimeMillis() - startMillis;
+                continue;
+            }
+            break;
         }
+
     }
 
     /**
diff --git a/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java b/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
index 3b2c2cae4..e7d0caea7 100644
--- a/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
+++ b/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
@@ -51,6 +51,7 @@ import org.apache.derby.iapi.store.access.GroupFetchScanController;
 import org.apache.derby.iapi.store.access.ScanController;
 import org.apache.derby.iapi.store.access.TransactionController;
 import org.apache.derby.iapi.types.DataValueDescriptor;
+import org.apache.derby.iapi.util.InterruptStatus;
 
 /**
  * Daemon acting as a coordinator for creating and updating index cardinality
@@ -959,8 +960,7 @@ public class IndexStatisticsDaemonImpl
         try {
             Thread.sleep(ms);
         } catch (InterruptedException ie) {
-            // Set the interrupt flag again.
-            Thread.currentThread().interrupt();
+            InterruptStatus.setInterrupted();
         }
     }
 
diff --git a/java/engine/org/apache/derby/impl/services/monitor/TopService.java b/java/engine/org/apache/derby/impl/services/monitor/TopService.java
index 9a3ed4968..a38fba9ef 100644
--- a/java/engine/org/apache/derby/impl/services/monitor/TopService.java
+++ b/java/engine/org/apache/derby/impl/services/monitor/TopService.java
@@ -28,6 +28,7 @@ import org.apache.derby.iapi.services.monitor.PersistentService;
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.util.InterruptStatus;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.reference.EngineType;
 
@@ -187,7 +188,7 @@ final class TopService {
 				try {
 					wait();
 				} catch (InterruptedException ioe) {
-					return false;
+                    InterruptStatus.setInterrupted();
 				}
 			}
 
diff --git a/java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java b/java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java
index 4c9fe23c2..79facd36a 100644
--- a/java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java
+++ b/java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java
@@ -30,6 +30,7 @@ import java.security.PrivilegedExceptionAction;
 import javax.net.SocketFactory;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.util.InterruptStatus;
 import org.apache.derby.shared.common.reference.MessageId;
 
 /**
@@ -202,12 +203,25 @@ public class ReplicationMessageTransmit {
         receivedMsg = null;
         checkSocketConnection();
         socketConn.writeMessage(message);
-        synchronized (receiveSemaphore) {
-            try {
-                receiveSemaphore.wait(DEFAULT_MESSAGE_RESPONSE_TIMEOUT);
-            } catch (InterruptedException ie) {
+        long startMillis = System.currentTimeMillis();
+        long waited = 0L;
+
+        while (receivedMsg == null &&
+               waited < DEFAULT_MESSAGE_RESPONSE_TIMEOUT) {
+
+            synchronized (receiveSemaphore) {
+                try {
+                    receiveSemaphore.wait(
+                        DEFAULT_MESSAGE_RESPONSE_TIMEOUT - waited);
+                } catch (InterruptedException ie) {
+                    InterruptStatus.setInterrupted();
+                    waited = System.currentTimeMillis() - startMillis;
+                    continue;
+                }
+                break;
             }
         }
+
         if (receivedMsg == null) {
             throw StandardException.
                 newException(SQLState.REPLICATION_CONNECTION_LOST, dbname);
