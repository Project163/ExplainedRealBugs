diff --git a/java/engine/org/apache/derby/iapi/types/SQLChar.java b/java/engine/org/apache/derby/iapi/types/SQLChar.java
index 75e9b5fe0..74423a669 100644
--- a/java/engine/org/apache/derby/iapi/types/SQLChar.java
+++ b/java/engine/org/apache/derby/iapi/types/SQLChar.java
@@ -1565,19 +1565,17 @@ readingLoop:
                 formatJDBCTime( cal, sb);
                 sb.append('.');
 
-                int micros = 
-                    (theValue.getNanos() + SQLTimestamp.FRACTION_TO_NANO/2) / 
-                        SQLTimestamp.FRACTION_TO_NANO;
+                int nanos = theValue.getNanos();
 
-                if (micros == 0)
+                if (nanos == 0)
                 {
                     // Add a single zero after the decimal point to match
                     // the format from Timestamp.toString().
                     sb.append('0');
                 }
-                else if (micros > 0)
+                else if (nanos > 0)
                 {
-                    String microsStr = Integer.toString( micros);
+                    String microsStr = Integer.toString( nanos);
                     if(microsStr.length() > SQLTimestamp.MAX_FRACTION_DIGITS)
                     {
                         sb.append(
diff --git a/java/engine/org/apache/derby/iapi/types/SQLTimestamp.java b/java/engine/org/apache/derby/iapi/types/SQLTimestamp.java
index 95450a361..c25f6aa79 100644
--- a/java/engine/org/apache/derby/iapi/types/SQLTimestamp.java
+++ b/java/engine/org/apache/derby/iapi/types/SQLTimestamp.java
@@ -85,8 +85,8 @@ public final class SQLTimestamp extends DataType
 						implements DateTimeDataValue
 {
 
-    static final int MAX_FRACTION_DIGITS = 6; // Only microsecond resolution on conversion to/from strings
-    static final int FRACTION_TO_NANO = 1000; // 10**(9 - MAX_FRACTION_DIGITS)
+    static final int MAX_FRACTION_DIGITS = 9; // Only nanosecond resolution on conversion to/from strings
+    static final int FRACTION_TO_NANO = 1; // 10**(9 - MAX_FRACTION_DIGITS)
 
     static final int ONE_BILLION = 1000000000;
     
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DateTimeTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DateTimeTest.java
index 99201cff8..f43bdcf51 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DateTimeTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DateTimeTest.java
@@ -1236,16 +1236,16 @@ public final class DateTimeTest extends BaseJDBCTestCase {
     }
     
     /**
-     *  Don't allow more than microseconds in ISO format: cloudscape rejects.
+     * Don't allow more than nanoseconds in ISO format.
      */
-    public void testISOFormat_MoreThanMicroseconds() throws SQLException{
+    public void testISOFormat_MoreThanNanoseconds() throws SQLException{
         Statement st = createStatement();
         
         assertStatementError("22007", st, "insert into ts (ts1) values "
-                + "('2003-03-05-17.05.43.999999999')");
+                + "('2003-03-05-17.05.43.999999999999')");
 
         assertStatementError("22007", st, " insert into ts (ts1) values "
-                + "('2003-03-05-17.05.43.999999000')");
+                + "('2003-03-05-17.05.43.999999999000')");
 
         st.close();
     }
@@ -1784,6 +1784,15 @@ public final class DateTimeTest extends BaseJDBCTestCase {
                 "10:00:00");
     }
 
+    /**
+     * Test case to show that timestamp function accepts nanoseconds
+     * resolution (DERBY-4625).
+     */
+    public void testNanosecondResolution() throws SQLException{
+    	assertSingleValue("values timestamp('2010-04-21 12:00:00.123456789')",
+    			"2010-04-21 12:00:00.123456789");
+    }
+
     /**
      * Execute an SQL statement and check that it returns a single, specific
      * value.
