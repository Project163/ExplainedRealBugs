diff --git a/java/engine/org/apache/derby/security/SystemPermission.java b/java/engine/org/apache/derby/security/SystemPermission.java
index 0aeafb324..79d417bfb 100644
--- a/java/engine/org/apache/derby/security/SystemPermission.java
+++ b/java/engine/org/apache/derby/security/SystemPermission.java
@@ -23,9 +23,14 @@ package org.apache.derby.security;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.security.BasicPermission;
 import java.security.Permission;
+import java.security.PermissionCollection;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
@@ -116,6 +121,12 @@ final public class SystemPermission extends BasicPermission {
      * Actions for this permission.
      */
     private String actions;
+
+    /**
+     * Bit mask representing the actions. It is not serialized, and has
+     * to be recalculated when the object is deserialized.
+     */
+    private transient int actionMask;
     
     /**
      * Creates a new SystemPermission with the specified name.
@@ -131,8 +142,8 @@ final public class SystemPermission extends BasicPermission {
     }
 
     /**
-     * Check if name and actions are valid, and normalize the actions
-     * string.
+     * Check if name and actions are valid, normalize the actions string,
+     * and calculate the actions mask.
      *
      * @param name the name of the permission
      * @param actions the actions of the permission
@@ -147,7 +158,8 @@ final public class SystemPermission extends BasicPermission {
             throw new IllegalArgumentException("Unknown permission " + name);
         }
       
-        this.actions = getCanonicalForm(actions);   
+        this.actions = getCanonicalForm(actions);
+        this.actionMask = getActionMask(this.actions);
     }
     
     /**
@@ -156,6 +168,13 @@ final public class SystemPermission extends BasicPermission {
     public String getActions() {
         return actions;
     }
+
+    // DERBY-6717: Must override newPermissionCollection() since
+    // BasicPermission's implementation ignores actions.
+    @Override
+    public PermissionCollection newPermissionCollection() {
+        return new SystemPermissionCollection();
+    }
     
     /**
      * Return a canonical form of the passed in actions.
@@ -214,12 +233,13 @@ final public class SystemPermission extends BasicPermission {
      * name and (canonical) actions.
      */
     public boolean equals(Object other) {
-        
+        // Check if the types and names match.
         if (!super.equals(other))
             return false;
-        
+
+        // Check if the actions match.
         SystemPermission osp = (SystemPermission) other;
-        return getActions().equals(osp.getActions());
+        return actionMask == osp.actionMask;
     }
     
     /**
@@ -232,11 +252,13 @@ final public class SystemPermission extends BasicPermission {
      */
     public boolean implies(Permission permission)
     {
+        // Check if the types and names match.
         if (!super.implies(permission))
             return false;
-        
-        int myActionMask = getActionMask(getActions());
-        int permissionMask = getActionMask(permission.getActions());
+
+        // Check if the actions match.
+        int myActionMask = actionMask;
+        int permissionMask = ((SystemPermission) permission).actionMask;
         
         return
             (myActionMask & permissionMask) == permissionMask;
@@ -271,4 +293,107 @@ final public class SystemPermission extends BasicPermission {
         // Make sure the name and actions fields contain legal values.
         validateNameAndActions(getName(), getActions());
     }
+
+    /**
+     * A collection of {@code SystemPermission} objects. Instances of this
+     * class must be thread-safe and serializable, per the specification of
+     * {@code java.security.PermissionCollection}.
+     */
+    private static class SystemPermissionCollection
+                                extends PermissionCollection {
+        private static final long serialVersionUID = 0L;
+
+        private HashMap<String, Permission> permissions
+                = new HashMap<String, Permission>();
+
+        @Override
+        public void add(Permission permission) {
+            // The contract of PermissionCollection.add() requires
+            // IllegalArgumentException if permission is not SystemPermission.
+            if (!(permission instanceof SystemPermission)) {
+                throw new IllegalArgumentException();
+            }
+
+            // The contract of PermissionCollection.add() requires
+            // SecurityException if the collection is read-only.
+            if (isReadOnly()) {
+                throw new SecurityException();
+            }
+
+            String name = permission.getName();
+
+            synchronized (this) {
+                Permission existing = permissions.get(name);
+                if (existing == null) {
+                    permissions.put(name, permission);
+                } else {
+                    String actions = existing.getActions() + ','
+                                        + permission.getActions();
+                    permissions.put(name, new SystemPermission(name, actions));
+                }
+            }
+        }
+
+        @Override
+        public boolean implies(Permission permission) {
+            if (!(permission instanceof SystemPermission)) {
+                return false;
+            }
+
+            String name = permission.getName();
+            Permission perm;
+
+            synchronized (this) {
+                perm = permissions.get(name);
+            }
+
+            return (perm != null) && perm.implies(permission);
+        }
+
+        @Override
+        public synchronized Enumeration<Permission> elements() {
+            return Collections.enumeration(permissions.values());
+        }
+
+        /**
+         * Called upon Serialization for saving the state of this
+         * SystemPermissionCollection to a stream.
+         */
+        private void writeObject(ObjectOutputStream s)
+                throws IOException {
+            // Only the values of the HashMap need to be serialized.
+            // The keys can be reconstructed from the values during
+            // deserialization.
+            ArrayList<Permission> perms;
+            synchronized (this) {
+                perms = new ArrayList<Permission>(permissions.values());
+            }
+
+            ObjectOutputStream.PutField fields = s.putFields();
+            fields.put("permissions", perms);
+            s.writeFields();
+        }
+
+        /**
+         * Called upon deserialization for restoring the state of this
+         * SystemPermissionCollection from a stream.
+         */
+        private void readObject(ObjectInputStream s)
+                throws IOException, ClassNotFoundException {
+            ObjectInputStream.GetField fields = s.readFields();
+            List perms = (List) fields.get("permissions", null);
+
+            permissions = new HashMap<String, Permission>();
+
+            // Insert the permissions one at a time, and verify that they
+            // in fact are SystemPermissions by doing an explicit cast. If
+            // a corrupted stream contains other kinds of permissions, a
+            // ClassCastException is raised instead of returning an invalid
+            // collection.
+            for (Object p : perms) {
+                SystemPermission sp = (SystemPermission) p;
+                permissions.put(sp.getName(), sp);
+            }
+        }
+    }
 }
diff --git a/java/testing/org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.java b/java/testing/org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.java
index 12f6807bc..0de20274e 100644
--- a/java/testing/org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.java
+++ b/java/testing/org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.java
@@ -30,10 +30,15 @@ import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.security.AccessControlException;
 import java.security.AccessController;
+import java.security.AllPermission;
 import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.Permissions;
 import java.security.PrivilegedAction;
 import java.util.HashSet;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Locale;
 import java.util.Set;
 import javax.security.auth.Subject;
@@ -178,6 +183,10 @@ public class SystemPrivilegesPermissionTest extends BaseTestCase {
             new SystemPrivilegesPermissionTest("testSystemPrincipal"));
         suite.addTest(
             new SystemPrivilegesPermissionTest("testSystemPermission"));
+        suite.addTest(
+            new SystemPrivilegesPermissionTest(
+                    "testSystemPermissionCollections"));
+
         // the DatabasePermission test attempts to canonicalize various
         // directory path names and requires an all-files-read-permission,
         // which is not granted by default derby_tests.policy
@@ -389,6 +398,97 @@ public class SystemPrivilegesPermissionTest extends BaseTestCase {
         // DERBY-3476: The SystemPermission class should be final.
         assertTrue(Modifier.isFinal(SystemPermission.class.getModifiers()));
     }
+
+    /**
+     * Test that collections of SystemPermissions behave as expected.
+     * Before DERBY-6717, adding multiple single-action permissions with
+     * the same name didn't work.
+     */
+    public void testSystemPermissionCollections() {
+        Permissions allPerms = new Permissions();
+        for (String name : VALID_SYSPERM_NAMES) {
+            for (String action : VALID_SYSPERM_ACTIONS) {
+                allPerms.add(new SystemPermission(name, action));
+            }
+        }
+
+        assertEquals(VALID_SYSPERM_NAMES.length,
+                     Collections.list(allPerms.elements()).size());
+
+        // Check that the collection of all system permissions also implies
+        // all system permissions.
+        for (String name : VALID_SYSPERM_NAMES) {
+            for (String a1 : VALID_SYSPERM_ACTIONS) {
+                // allPerms should imply any valid (name, action) pair.
+                assertTrue(allPerms.implies(new SystemPermission(name, a1)));
+
+                // allPerms should also imply any valid multi-action
+                // system permission.
+                for (String a2 : VALID_SYSPERM_ACTIONS) {
+                    assertTrue(allPerms.implies(
+                            new SystemPermission(name, a1 + ',' + a2)));
+                }
+            }
+        }
+
+        Permissions somePerms = new Permissions();
+        somePerms.add(new SystemPermission("server", "shutdown"));
+        somePerms.add(new SystemPermission("jmx", "shutdown,monitor"));
+        somePerms.add(new SystemPermission("engine", "shutdown,control"));
+        somePerms.add(new SystemPermission("engine", "control,monitor"));
+
+        // somePerms implies the shutdown action for server
+        assertTrue(somePerms.implies(
+                new SystemPermission("server", "shutdown")));
+        assertFalse(somePerms.implies(
+                new SystemPermission("server", "control")));
+        assertFalse(somePerms.implies(
+                new SystemPermission("server", "monitor")));
+        assertFalse(somePerms.implies(
+                new SystemPermission("server", "shutdown,monitor")));
+
+        // somePerms implies the shutdown and monitor actions for jmx
+        assertTrue(somePerms.implies(new SystemPermission("jmx", "shutdown")));
+        assertTrue(somePerms.implies(new SystemPermission("jmx", "monitor")));
+        assertFalse(somePerms.implies(new SystemPermission("jmx", "control")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("jmx", "shutdown,monitor")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("jmx", "monitor,shutdown")));
+        assertFalse(somePerms.implies(
+                new SystemPermission("jmx", "monitor,shutdown,control")));
+
+        // somePerms implies shutdown, control and monitor for engine
+        assertTrue(somePerms.implies(
+                new SystemPermission("engine", "shutdown")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("engine", "control")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("engine", "monitor")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("engine", "shutdown,monitor")));
+        assertTrue(somePerms.implies(
+                new SystemPermission("engine", "shutdown,monitor,control")));
+
+        // A SystemPermission collection should not accept other permissions.
+        SystemPermission sp = new SystemPermission("engine", "monitor");
+        PermissionCollection collection = sp.newPermissionCollection();
+        try {
+            collection.add(new AllPermission());
+            fail();
+        } catch (IllegalArgumentException iae) {
+            // expected
+        }
+
+        // Read-only collections cannot be added to.
+        collection.setReadOnly();
+        try {
+            collection.add(sp);
+            fail();
+        } catch (SecurityException se) {
+            // expected
+        }
+    }
     
     /**
      * Tests SystemPermissions against the Policy.
@@ -815,6 +915,37 @@ public class SystemPrivilegesPermissionTest extends BaseTestCase {
                 VALID_SYSPERM_NAMES[0],
                 null),
             NullPointerException.class);
+
+        // Test serialization of SystemPermission collections.
+
+        // Serialization should work on empty collection.
+        PermissionCollection collection = sp.newPermissionCollection();
+        PermissionCollection readCollection =
+                serializeDeserialize(collection, null);
+        assertFalse(readCollection.elements().hasMoreElements());
+
+        // Serialization should work on non-empty collection.
+        sp = new SystemPermission(
+                VALID_SYSPERM_NAMES[0], VALID_SYSPERM_ACTIONS[0]);
+        collection = sp.newPermissionCollection();
+        collection.add(sp);
+        readCollection = serializeDeserialize(collection, null);
+        assertEquals(Arrays.asList(sp),
+                     Collections.list(readCollection.elements()));
+
+        // Deserialization should fail if the collection contains a
+        // permission with invalid name.
+        collection.add(createSyspermNoCheck("invalid_name", "control"));
+        serializeDeserialize(collection, IllegalArgumentException.class);
+
+        // Deserialization should fail if the collection contains a
+        // permission that is not a SystemPermission.
+        collection = sp.newPermissionCollection();
+        HashMap<String, Permission> permissions =
+                new HashMap<String, Permission>();
+        permissions.put("engine", new AllPermission());
+        setField(collection.getClass(), "permissions", collection, permissions);
+        serializeDeserialize(collection, ClassCastException.class);
     }
 
     /**
