diff --git a/java/engine/org/apache/derby/iapi/sql/dictionary/DDUtils.java b/java/engine/org/apache/derby/iapi/sql/dictionary/DDUtils.java
index eba2114f7..32b02ce0b 100644
--- a/java/engine/org/apache/derby/iapi/sql/dictionary/DDUtils.java
+++ b/java/engine/org/apache/derby/iapi/sql/dictionary/DDUtils.java
@@ -129,6 +129,19 @@ public	class	DDUtils
 					 columnNamesMatch(refColumnNames, 
 										cd.getColumnDescriptors()))
 				{
+                    if (cd.deferrable()) {
+                        final int onDelete = otherConstraintInfo.
+                                getReferentialActionDeleteRule();
+
+                        if (onDelete == StatementType.RA_CASCADE ||
+                            onDelete == StatementType.RA_SETNULL) {
+                            // DERBY-532: Not yet implemented
+                            throw StandardException.newException(
+                                    SQLState.LANG_INVALID_FK_REF_KEY,
+                                    myConstraintName,
+                                    refTd.getQualifiedName());
+                        }
+                    }
 					return (ReferencedKeyConstraintDescriptor)cd;
 				}
 			}
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
index cf397df3b..2d87a6dd2 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
@@ -64,7 +64,6 @@ abstract public class DMLWriteResultSet extends NoRowsResultSetImpl
      */
     protected DataValueDescriptor[] cachedDestinations;
 
-
 	/**
 	 * Constructor
 	 *
@@ -125,7 +124,10 @@ abstract public class DMLWriteResultSet extends NoRowsResultSetImpl
 	/**
      * Returns the description of the inserted rows.
      * REVISIT: Do we want this to return NULL instead?
+     *
+     * @return the description of the inserted rows
 	 */
+    @Override
 	public ResultDescription getResultDescription()
 	{
 	    return resultDescription;
@@ -136,6 +138,9 @@ abstract public class DMLWriteResultSet extends NoRowsResultSetImpl
 	 * 
 	 * @param source		SourceResultSet
 	 * Also look at Track#2432/change 12433
+     * @return             The next row in the result set
+     * @throws StandardException
+     *                     Standard error policy
 	 */
 	protected ExecRow getNextRowCore(NoPutResultSet source)
 		throws StandardException
@@ -200,6 +205,10 @@ abstract public class DMLWriteResultSet extends NoRowsResultSetImpl
 	 * deferred non-sparse row. Share the underlying columns. If there
 	 * is no column bit map, make them the same row.
 	 *
+     * @param deferredBaseRow  the deferred non-sparse row
+     * @param baseRowReadList  the columns to include (1-based bit map)
+     * @param lcc              the language connection context
+     * @return                 the deferred sparse row
 	 * @exception StandardException		Thrown on error
 	 */
 	protected ExecRow makeDeferredSparseRow(
@@ -306,6 +315,11 @@ abstract public class DMLWriteResultSet extends NoRowsResultSetImpl
      * This applies logic usually found in a NormalizeResultSet, which is missing for
      * the MERGE statement.
      * </p>
+     * @param sourceResultSet        the result set for which this action is
+     *                               to be performed
+     * @param row                    the row to be normalized
+     * @return                       the normalized row
+     * @throws StandardException     Standard error policy
      */
     protected   ExecRow normalizeRow( NoPutResultSet sourceResultSet, ExecRow row )
         throws StandardException
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
index 4a26d6b7d..dc461ccd9 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
@@ -21,20 +21,20 @@
 
 package org.apache.derby.impl.sql.execute;
 
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Vector;
+import org.apache.derby.catalog.UUID;
 import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.sql.execute.ConstantAction;
-import org.apache.derby.iapi.sql.execute.CursorResultSet;
-import org.apache.derby.iapi.sql.execute.NoPutResultSet;
+import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.sql.Activation;
 import org.apache.derby.iapi.sql.ResultSet;
+import org.apache.derby.iapi.sql.execute.ConstantAction;
+import org.apache.derby.iapi.sql.execute.CursorResultSet;
 import org.apache.derby.iapi.sql.execute.ExecRow;
+import org.apache.derby.iapi.sql.execute.NoPutResultSet;
 import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
-
-import org.apache.derby.iapi.reference.SQLState;
-
-import java.util.Vector;
-import java.util.Hashtable;
-import java.util.Enumeration;
+import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
 
 /**
  * Delete the rows from the specified  base table and executes delete/update
@@ -52,7 +52,7 @@ class DeleteCascadeResultSet extends DeleteResultSet
 
     ResultSet[] dependentResultSets;
 	private int noDependents =0;
-	private String resultSetId;
+    private final String resultSetId;
 	private boolean mainNodeForTable = true;
 	private boolean affectedRows = false;
 	private int tempRowHolderId; //this result sets temporary row holder id 
@@ -126,13 +126,15 @@ class DeleteCascadeResultSet extends DeleteResultSet
 								SQLState.LANG_NO_ROW_FOUND));
 			}
 
-            runFkChecker(true, true); // check for only RESTRICT referential
+            runFkChecker(true); // check for only RESTRICT referential
                                       // action rule violations
-			Hashtable<String,String> mntHashTable = new Hashtable<String,String>(); //Hash Table to identify  mutiple node for same table cases. 
+            HashMap<String,String> mntHashTable =
+                new HashMap<String,String>(); // Hash table to identify multiple
+                                              // node for same table cases.
 			mergeRowHolders(mntHashTable);
 			fireBeforeTriggers(mntHashTable);
-			deleteDeferredRows();
-            runFkChecker(false, false); // check for all constraint violations
+            deleteDeferredRows();
+            runFkChecker(false); // check for all constraint violations
 			rowChangerFinish();
 			fireAfterTriggers();
 		}finally
@@ -208,8 +210,8 @@ class DeleteCascadeResultSet extends DeleteResultSet
 		return rowsFound;
 	}
 
-    @SuppressWarnings("UseOfObsoleteCollectionType")
-	void fireBeforeTriggers(Hashtable<String,String> msht) throws StandardException
+    void fireBeforeTriggers(HashMap<String, String> msht)
+            throws StandardException
 	{
 		if(!mainNodeForTable) 
 		{
@@ -292,7 +294,7 @@ class DeleteCascadeResultSet extends DeleteResultSet
 
 	
     @Override
-    void runFkChecker(boolean restrictCheckOnly, boolean postCheck)
+    void runFkChecker(boolean restrictCheckOnly)
             throws StandardException
 	{
 
@@ -302,18 +304,18 @@ class DeleteCascadeResultSet extends DeleteResultSet
 			if(dependentResultSets[i] instanceof UpdateResultSet)
 			{
                 ((UpdateResultSet) dependentResultSets[i]).runChecker(
-                    restrictCheckOnly, postCheck);
+                    restrictCheckOnly);
 			}
 			else{
                 ((DeleteCascadeResultSet)dependentResultSets[i]).runFkChecker(
-                    restrictCheckOnly, postCheck);
+                    restrictCheckOnly);
 			}
 		}
 
 		//If there  is more than one node for the same table
 		//only one node does all foreign key checks.
 		if(mainNodeForTable)
-            super.runFkChecker(restrictCheckOnly, postCheck);
+            super.runFkChecker(restrictCheckOnly);
 	}
 
 
@@ -357,8 +359,8 @@ class DeleteCascadeResultSet extends DeleteResultSet
 
 	//if there is more than one node for the same table, copy the rows
 	// into one node , so that we don't fire trigger more than once.
-    @SuppressWarnings("UseOfObsoleteCollectionType")
-	private void mergeRowHolders(Hashtable<String,String> msht) throws StandardException
+    private void mergeRowHolders(HashMap<String, String> msht)
+            throws StandardException
 	{
 		if(msht.containsKey(resultSetId) || rowCount ==0)
 		{
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
index 3135fa682..b9c0181d6 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
@@ -22,14 +22,12 @@
 package org.apache.derby.impl.sql.execute;
 
 import java.util.Properties;
-
+import org.apache.derby.catalog.UUID;
 import org.apache.derby.iapi.db.TriggerExecutionContext;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.io.FormatableBitSet;
-import org.apache.derby.shared.common.sanity.SanityManager;
 import org.apache.derby.iapi.sql.Activation;
-import org.apache.derby.iapi.sql.ResultDescription;
 import org.apache.derby.iapi.sql.ResultSet;
 import org.apache.derby.iapi.sql.execute.ConstantAction;
 import org.apache.derby.iapi.sql.execute.CursorResultSet;
@@ -37,9 +35,11 @@ import org.apache.derby.iapi.sql.execute.ExecRow;
 import org.apache.derby.iapi.sql.execute.NoPutResultSet;
 import org.apache.derby.iapi.sql.execute.RowChanger;
 import org.apache.derby.iapi.store.access.ConglomerateController;
+import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
 import org.apache.derby.iapi.store.access.TransactionController;
 import org.apache.derby.iapi.types.DataValueDescriptor;
 import org.apache.derby.iapi.types.RowLocation;
+import org.apache.derby.shared.common.sanity.SanityManager;
 
 /**
  * Delete the rows from the specified
@@ -129,6 +129,7 @@ class DeleteResultSet extends DMLWriteResultSet
 	/**
 		@exception StandardException Standard Derby error policy
 	*/
+    @Override
 	public void open() throws StandardException
 	{
 
@@ -148,11 +149,11 @@ class DeleteResultSet extends DMLWriteResultSet
 		*/
 		if (constants.deferred)
 		{
-            runFkChecker(true, true); // check for only RESTRICT referential
+            runFkChecker(true); // check for only RESTRICT referential
                                       // action rule violations
 			fireBeforeTriggers();
-			deleteDeferredRows();
-            runFkChecker(false, false); //check for all constraint violations
+            deleteDeferredRows();
+            runFkChecker(false); //check for all constraint violations
 			// apply 
 			rc.finish();
 			fireAfterTriggers();
@@ -394,7 +395,7 @@ class DeleteResultSet extends DMLWriteResultSet
                     // deferred, require at least two rows to be present in the
                     // primary table since we are deleting one of them below,
                     // and we need at least one to fulfill the constraint.
-                    fkChecker.doPKCheck(activation, row, false, false, 2);
+                    fkChecker.doPKCheck(activation, row, false, 2);
 				}
 
 				baseRowLocation = 
@@ -541,8 +542,10 @@ class DeleteResultSet extends DMLWriteResultSet
 	}
 
 
-	// make sure foreign key constraints are not violated
-    void runFkChecker(boolean restrictCheckOnly, boolean postCheck)
+    /**
+     * Make sure foreign key constraints are not violated
+     */
+    void runFkChecker(boolean restrictCheckOnly)
             throws StandardException
 	{
 
@@ -573,11 +576,10 @@ class DeleteResultSet extends DMLWriteResultSet
                             activation,
                             defRLRow,
                             restrictCheckOnly,
-                            postCheck,
                             1);
 				}
 
-                if (postCheck) {
+                if (restrictCheckOnly) {
                     fkChecker.postCheck();
                 }
 
@@ -607,6 +609,7 @@ class DeleteResultSet extends DMLWriteResultSet
 	 *
 	 * @exception StandardException		Thrown on error
 	 */
+    @Override
 	public void	cleanUp() throws StandardException
 	{ 
 		numOpens = 0;
@@ -648,7 +651,7 @@ class DeleteResultSet extends DMLWriteResultSet
     @Override
     public void close() throws StandardException
     {
-        close( constants.underMerge() );
+        super.close( constants.underMerge() );
     }
                                
     @Override
diff --git a/java/engine/org/apache/derby/impl/sql/execute/FKInfo.java b/java/engine/org/apache/derby/impl/sql/execute/FKInfo.java
index ae98f316e..76e9da5c1 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/FKInfo.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/FKInfo.java
@@ -282,6 +282,7 @@ public class FKInfo implements Formatable
 		out.writeInt(stmtType);
 		out.writeObject(refUUID);
 		out.writeLong(refConglomNumber);
+        out.writeBoolean(refConstraintIsDeferrable);
 
 		ArrayUtil.writeArray(out, fkConstraintNames);
 		ArrayUtil.writeArray(out, fkUUIDs);
@@ -320,6 +321,7 @@ public class FKInfo implements Formatable
 			stmtType = in.readInt();
 			refUUID = (UUID)in.readObject();
 			refConglomNumber = in.readLong();
+            refConstraintIsDeferrable = in.readBoolean();
 
 			fkConstraintNames = new String[ArrayUtil.readArrayLength(in)];
 			ArrayUtil.readArrayItems(in, fkConstraintNames);
@@ -362,8 +364,10 @@ public class FKInfo implements Formatable
 			str.append("\ntype:\t\t\t\t");
 			str.append((type == FOREIGN_KEY) ? "FOREIGN_KEY" : "REFERENCED_KEY");
 
-			str.append("\nReferenced Key UUID:\t\t"+refUUID);
+            str.append("\nReferenced Key Index UUID:\t\t"+refUUID);
 			str.append("\nReferenced Key ConglomNum:\t"+refConglomNumber);
+            str.append("\nReferenced Key Constraint is deferrable:\t" +
+                       refConstraintIsDeferrable);
 
 			str.append("\nForeign Key Names:\t\t(");
 			for (int i = 0; i < fkUUIDs.length; i++)
@@ -425,6 +429,8 @@ public class FKInfo implements Formatable
             }
             str.append(")\n");
 
+
+
             return str.toString();
 		}
 		else
diff --git a/java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java b/java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java
index 34979b23e..39c4ca53d 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java
@@ -77,8 +77,6 @@ public class ForeignKeyRIChecker extends GenericRIChecker
      * @param restrictCheckOnly
      *              {@code true} if the check is relevant only for RESTRICTED
      *              referential action.
-     * @param postCheck
-     *              dummy (interface obligation only)
      * @param deferredRowReq
      *              dummy (interface obligation only)
 	 *
@@ -88,7 +86,6 @@ public class ForeignKeyRIChecker extends GenericRIChecker
     void doCheck(Activation a,
                  ExecRow row,
                  boolean restrictCheckOnly,
-                 boolean postCheck,
                  int deferredRowReq) throws StandardException
 	{
 
diff --git a/java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java b/java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java
index 969c10192..a924a3e1f 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java
@@ -98,9 +98,6 @@ public abstract class GenericRIChecker
      * @param restrictCheckOnly
      *              {@code true} if the check is relevant only for RESTRICTED
      *              referential action.
-     * @param postCheck
-     *              For referenced keys: if {@code true}, rows are not yet
-     *              deleted, so do the check in the case of deferred PK later
      * @param deferredRowReq
      *              For referenced keys: The required number of duplicates that
      *              need to be present. Only used if {@code postCheck==false}.
@@ -110,7 +107,6 @@ public abstract class GenericRIChecker
     abstract void doCheck(Activation a,
                           ExecRow row,
                           boolean restrictCheckOnly,
-                          boolean postCheck,
                           int deferredRowReq) throws StandardException;
 
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java b/java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java
index d4b76da97..3b55b2779 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java
@@ -91,9 +91,6 @@ public class RISetChecker
      * @param restrictCheckOnly
      *              {@code true} if the check is relevant only for RESTRICTED
      *              referential action.
-     * @param postCheck
-     *              For referenced keys: if {@code true}, rows are not yet
-     *              deleted, so do the check in the case of deferred PK later.
      * @param deferredRowReq
      *              For referenced keys: The required number of duplicates that
      *              need to be present. Only used if {@code postCheck==false}.
@@ -104,7 +101,6 @@ public class RISetChecker
     public void doPKCheck(Activation a,
                           ExecRow row,
                           boolean restrictCheckOnly,
-                          boolean postCheck,
                           int deferredRowReq) throws StandardException
 	{
 		if (checkers == null)
@@ -115,7 +111,6 @@ public class RISetChecker
                 checker.doCheck(a,
                                 row,
                                 restrictCheckOnly,
-                                postCheck,
                                 deferredRowReq);
             }
         }
@@ -163,7 +158,7 @@ public class RISetChecker
 		{
 			if (checkers[i] instanceof ForeignKeyRIChecker)
 			{
-                checkers[i].doCheck(a, row, false, false, 0);
+                checkers[i].doCheck(a, row, false, 0);
 			}
 		}
 	}
@@ -177,9 +172,6 @@ public class RISetChecker
      * @param restrictCheckOnly
      *              {@code true} if the check is relevant only for RESTRICTED
      *              referential action.
-     * @param postCheck
-     *              For referenced keys: if {@code true}, rows are not yet
-     *              deleted, so do the check in the case of deferred PK later
      * @param deferredRowReq
      *              For referenced keys: the required number of duplicates that
      *              need to be present. Only used if {@code postCheck==false}.
@@ -191,7 +183,6 @@ public class RISetChecker
                           int index,
                           ExecRow row,
                           boolean restrictCheckOnly,
-                          boolean postCheck,
                           int deferredRowReq) throws StandardException
 	{
 		if (SanityManager.DEBUG)
@@ -209,7 +200,7 @@ public class RISetChecker
 		}
 
         checkers[index].doCheck(
-            a, row, restrictCheckOnly, postCheck, deferredRowReq);
+            a, row, restrictCheckOnly, deferredRowReq);
 	}
 
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java b/java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java
index f113978c7..5fc4a0abb 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java
@@ -100,9 +100,6 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
      * @param restrictCheckOnly
      *              {@code true} if the check is relevant only for RESTRICTED
      *              referential action.
-     * @param postCheck
-     *              For referenced keys: if {@code true}, rows are not yet
-     *              deleted, so do the check in the case of deferred PK later.
      * @param deferredRowReq
      *              For referenced keys: The required number of duplicates that
      *              need to be present. Only used if {@code postCheck==false}.
@@ -114,7 +111,6 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
     void doCheck(Activation a,
                  ExecRow row,
                  boolean restrictCheckOnly,
-                 boolean postCheck,
                  int deferredRowReq) throws StandardException
 	{
 		/*
@@ -133,8 +129,9 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
             if (lcc.isEffectivelyDeferred(
                     lcc.getCurrentSQLSessionContext(a),
                     fkInfo.refConglomNumber)) {
-                if (postCheck) {
+                if (restrictCheckOnly) {
                     rememberKey(row);
+                    return;
                 } else {
                     // It *is* a deferred constraint and it is *not* a deferred
                     // rows code path, so go see if we have enough rows
@@ -203,6 +200,12 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
 	}
 
 
+    /**
+     * Remember the deletion of this key, it may cause a RESTRICT
+     * foreign key violation, cf. logic in @{link #postCheck}.
+     * @param rememberRow
+     * @throws StandardException
+     */
     private void rememberKey(ExecRow rememberRow) throws StandardException {
         if (deletedKeys == null) {
             // key: all columns (these are index rows, or a row containing a
@@ -252,8 +255,9 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
 
     /**
      * Check that we have at least one more row in the referenced
-     * table table containing a key than the number of seen deletes of that key.
-     * Only used when the referenced constraint id deferred.
+     * table table containing a key than the number of projected deletes of that
+     * key. Only used when the referenced constraint id deferred and with
+     * RESTRICT mode
      *
      * @throws StandardException Standard error policy
      */
@@ -263,6 +267,19 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
             return;
         }
 
+        int indexOfFirstRestrict = -1;
+
+        for (int i = 0; i < fkInfo.fkConglomNumbers.length; i++) {
+            if (fkInfo.raRules[i] == StatementType.RA_RESTRICT) {
+                indexOfFirstRestrict = i;
+                break;
+            }
+        }
+
+        if (indexOfFirstRestrict == -1) {
+            return;
+        }
+
         if (deletedKeys != null) {
             final Enumeration<?> e = deletedKeys.elements();
 
@@ -289,7 +306,7 @@ public class ReferencedKeyRIChecker extends GenericRIChecker
 
                     StandardException se = StandardException.newException(
                             SQLState.LANG_FK_VIOLATION,
-                            fkInfo.fkConstraintNames[0],
+                            fkInfo.fkConstraintNames[indexOfFirstRestrict],
                             fkInfo.tableName,
                             StatementUtil.typeName(fkInfo.stmtType),
                             RowUtil.toString(row, oneBasedIdentityMap));
diff --git a/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
index 8b4b5a8f8..e53b9da7a 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
@@ -42,6 +42,7 @@ import org.apache.derby.iapi.sql.execute.RowChanger;
 import org.apache.derby.iapi.store.access.BackingStoreHashtable;
 import org.apache.derby.iapi.store.access.ConglomerateController;
 import org.apache.derby.iapi.store.access.ScanController;
+import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
 import org.apache.derby.iapi.store.access.TransactionController;
 import org.apache.derby.iapi.types.BooleanDataValue;
 import org.apache.derby.iapi.types.DataValueDescriptor;
@@ -113,6 +114,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	 * @param source update rows come from source
 	 * @param generationClauses	Generated method for computed generation clauses
 	 * @param checkGM	Generated method for enforcing check constraints
+     * @param activation The activation
 	 * @exception StandardException thrown on error
      */
     UpdateResultSet(NoPutResultSet source,
@@ -133,7 +135,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	 * @param generationClauses	Generated method for computed generation clauses
 	 * @param checkGM	Generated method for enforcing check constraints
 	 * @param activation Activation
-	 * @param constantActionItem  id of the update constant action saved objec
+     * @param constantActionItem  id of the update constant action saved object
 	 * @param rsdItem  id of the Result Description saved object
 	 * @exception StandardException thrown on error
      */
@@ -162,6 +164,9 @@ class UpdateResultSet extends DMLWriteResultSet
 	 * @param source update rows come from source
 	 * @param generationClauses	Generated method for computed generation clauses
 	 * @param checkGM	Generated method for enforcing check constraints
+     * @param activation
+     * @param passedInConstantAction
+     * @param passedInRsd
 	 * @exception StandardException thrown on error
      */
     UpdateResultSet(NoPutResultSet source,
@@ -208,21 +213,20 @@ class UpdateResultSet extends DMLWriteResultSet
 
 		if (fkInfoArray != null)
 		{
-			for (int i = 0; i < fkInfoArray.length; i++)
-			{
-				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
-				{
-					updatingReferencedKey = true;
-					if (SanityManager.DEBUG)
-					{
-						SanityManager.ASSERT(constants.deferred, "updating referenced key but update not deferred, wuzzup?");
-					}
-				}
-				else
-				{	
-					updatingForeignKey = true;
-				}
-			}
+            for (FKInfo fkInfo : fkInfoArray) {
+                if (fkInfo.type == FKInfo.REFERENCED_KEY) {
+                    updatingReferencedKey = true;
+                    if (SanityManager.DEBUG)
+                    {
+                        SanityManager.ASSERT(
+                            constants.deferred,
+                            "updating referenced key but update not " +
+                                "deferred, wuzzup?");
+                    }
+                } else {
+                    updatingForeignKey = true;
+                }
+            }
 		}
 
 		/* Get the # of columns in the ResultSet */
@@ -253,6 +257,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	/**
 		@exception StandardException Standard Derby error policy
 	*/
+    @Override
 	public void open() throws StandardException
 	{
 
@@ -267,13 +272,13 @@ class UpdateResultSet extends DMLWriteResultSet
 		if (deferred)
 		{
 
-            runChecker(true, true); // check for only RESTRICT referential
+            runChecker(true); // check for only RESTRICT referential
                                     // action rule violations
 			fireBeforeTriggers();
-			updateDeferredRows();
+            updateDeferredRows();
 			/* Apply deferred inserts to unique indexes */
 			rowChanger.finish();
-            runChecker(false, false); // check for all  violations
+            runChecker(false); // check for all  violations
 			fireAfterTriggers();
 
 		}
@@ -289,6 +294,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	/**
 		@exception StandardException Standard Derby error policy
 	*/
+    @Override
 	void setup() throws StandardException
 	{
 		super.setup();
@@ -647,11 +653,13 @@ class UpdateResultSet extends DMLWriteResultSet
 	protected ExecRow getNextRowCore( NoPutResultSet source )
 		throws StandardException
 	{
-		ExecRow row = super.getNextRowCore( source );
+        ExecRow nextRow = super.getNextRowCore( source );
 
-        if ( (row != null) && constants.underMerge() ) { row = processMergeRow( source, row ); }
+        if ( (nextRow != null) && constants.underMerge() ) {
+            nextRow = processMergeRow( source, nextRow );
+        }
 
-        return row;
+        return nextRow;
 	}
 
     /**
@@ -754,13 +762,13 @@ class UpdateResultSet extends DMLWriteResultSet
 
 			if (tableScan.past2FutureTbl == null)
 			{
-				double rowCount = tableScan.getEstimatedRowCount();
+                double rowCnt = tableScan.getEstimatedRowCount();
 				int initCapacity = 32 * 1024;
-				if (rowCount > 0.0)
+                if (rowCnt > 0.0)
 				{
-					rowCount = rowCount / 0.75 + 1.0;	// load factor
-					if (rowCount < initCapacity)
-						initCapacity = (int) rowCount;
+                    rowCnt = rowCnt / 0.75 + 1.0;   // load factor
+                    if (rowCnt < initCapacity)
+                        initCapacity = (int) rowCnt;
 				}
 				if (maxCapacity < initCapacity)
 					initCapacity = maxCapacity;
@@ -838,7 +846,8 @@ class UpdateResultSet extends DMLWriteResultSet
 			deferredBaseCC = 
                 tc.openCompiledConglomerate(
                     false,
-                    tc.OPENMODE_FORUPDATE|tc.OPENMODE_SECONDARY_LOCKED,
+                    (TransactionController.OPENMODE_SECONDARY_LOCKED |
+                     TransactionController.OPENMODE_FORUPDATE),
                     lockMode,
                     TransactionController.ISOLATION_SERIALIZABLE,
                     constants.heapSCOCI,
@@ -927,7 +936,7 @@ class UpdateResultSet extends DMLWriteResultSet
 
 
 	
-    void runChecker(boolean restrictCheckOnly, boolean postCheck)
+    void runChecker(boolean restrictCheckOnly)
             throws StandardException
 	{
 
@@ -977,12 +986,11 @@ class UpdateResultSet extends DMLWriteResultSet
                                     i,
                                     deletedRow,
                                     restrictCheckOnly,
-                                    postCheck,
                                     1);
 						}
 					}	
 
-                    if (postCheck) {
+                    if (restrictCheckOnly) {
                         riChecker.postCheck(i);
                     }
 				}
@@ -1031,7 +1039,6 @@ class UpdateResultSet extends DMLWriteResultSet
                                 i,
                                 insertedRow,
                                 restrictCheckOnly,
-                                postCheck, // N/A, not referenced key
                                 0);        // N/A, not referenced key
 						}
                     }
@@ -1103,6 +1110,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	 *
 	 * @exception StandardException		Thrown on error
 	 */
+    @Override
 	public void	cleanUp() throws StandardException
 	{ 
 		numOpens = 0;
@@ -1151,7 +1159,7 @@ class UpdateResultSet extends DMLWriteResultSet
     @Override
     public void close() throws StandardException
     {
-        close( constants.underMerge() );
+        super.close( constants.underMerge() );
     }
                                
 	void rowChangerFinish() throws StandardException
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index c5b692a50..67719a52f 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -3654,6 +3654,13 @@ Guide.
                 <arg>tableName</arg>
             </msg>
 
+            <msg>
+                <name>X0Y47.S</name>
+                <text>Constraint '{0}' is invalid: the unique or primary key constraint on table '{1}' is deferrable and the referential action is CASCADE or SET NULL.</text>
+                <arg>constraintName</arg>
+                <arg>tableName</arg>
+            </msg>
+
             <msg>
                 <name>X0Y54.S</name>
                 <text>Schema '{0}' cannot be dropped because it is not empty.</text>
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index f6f8ffc87..ed7666934 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -1399,6 +1399,7 @@ public interface SQLState {
 	String LANG_INVALID_FK_NO_REF_KEY                                  = "X0Y44.S";
 	String LANG_ADD_FK_CONSTRAINT_VIOLATION                            = "X0Y45.S";
 	String LANG_INVALID_FK_NO_REF_TAB                                  = "X0Y46.S";
+    String LANG_INVALID_FK_REF_KEY                                     = "X0Y47.S";
 	String LANG_SCHEMA_NOT_EMPTY                                       = "X0Y54.S";
 	String LANG_INDEX_ROW_COUNT_MISMATCH                               = "X0Y55.S";
 	String LANG_INVALID_OPERATION_ON_SYSTEM_TABLE                      = "X0Y56.S";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
index 45634e442..bfa7114f1 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
@@ -834,201 +834,310 @@ public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
         ResultSet rs = null;
 
         try {
-            s.executeUpdate(
-                "create table ref_t(i int, j int, constraint ct " +
-                "    primary key(i) deferrable initially deferred)");
-            s.executeUpdate(
-                "create table t(i int unique not null, c char(1)," +
-                "    constraint c foreign key (i) references ref_t(i))");
-
-            s.executeUpdate("insert into ref_t values (1,2),(1,3),(1,4)");
-            s.executeUpdate("insert into t values (1, 'c')");
-
-            // Now, the child (referencing table) is referencing one of the the
-            // rows in the primary table whose value is 1, so the reference is
-            // ok.
-
-            // What happens when we delete one copy before commit?
-            // Even though we have ON DELETE restrict action, there is another
-            // row that would satisfy the constraint.
-            rs = s.executeQuery("select * from ref_t");
-            rs.next();
-            rs.deleteRow();
-            rs.next();
-            rs.deleteRow();
-            // Now there should be only one left, so the referenced table is
-            // OK.
-            commit();
+            // RESTRICT and NO ACTION will throw in different
+            // code paths, but in practice, in Derby presently, the
+            // behavior is the same since we do not support SQL in before
+            // triggers, so test both with the same fixtures.
+            // CASCADE is tested separately later.
+            final String[] refActions = {
+                "ON DELETE NO ACTION ON UPDATE NO ACTION",
+                "ON DELETE RESTRICT ON UPDATE RESTRICT" };
+
+            /*   N O   A C T I O N,   R E S T R I C T   (d i r e c t) */
+
+            for (String refAct: refActions) {
+                s.executeUpdate(
+                    "create table ref_t(i int, j int, constraint ct " +
+                    "    primary key(i) deferrable initially deferred)");
+                s.executeUpdate(
+                    "create table t(i int unique not null, c char(1)," +
+                    "    constraint c foreign key (i) references ref_t(i) " +
+                    refAct + ")");
+
+                s.executeUpdate("insert into ref_t values (1,2),(1,3),(1,4)");
+                s.executeUpdate("insert into t values (1, 'c')");
+
+                // Now, the child (referencing table) is referencing one of the
+                // the rows in the primary table whose value is 1, so the
+                // reference is ok.
+
+                // What happens when we delete one copy before commit?  Even
+                // though we have ON DELETE restrict action, there is another
+                // row that would satisfy the constraint.
+                rs = s.executeQuery("select * from ref_t");
+                rs.next();
+                rs.deleteRow();
+                rs.next();
+                rs.deleteRow();
+                // Now there should be only one left, so the referenced table
+                // is OK.
+                commit();
+
+                // Try again, but this time with normal delete, not using
+                // cursors
+                s.executeUpdate("insert into ref_t values (1,5),(1,6)");
+                s.executeUpdate("delete from ref_t where j > 4 ");
+                commit();
+
+                // Try again, but this time delete both duplicate rows. The
+                // second delete should fail.
+                s.executeUpdate("insert into ref_t values (1,3)");
+                rs = s.executeQuery("select * from ref_t");
+                rs.next();
+                rs.deleteRow();
+                rs.next();
 
-            // Try again, but this time with normal delete, not using cursors
-            s.executeUpdate("insert into ref_t values (1,5),(1,6)");
-            s.executeUpdate("delete from ref_t where j > 4 ");
-            commit();
+                try {
+                    rs.deleteRow();
+                    fail();
+                } catch (SQLException e) {
+                    assertSQLState(LANG_FK_VIOLATION, e);
+                }
 
-            // Try again, but this time delete both duplicate rows. The second
-            // delete should fail.
-            s.executeUpdate("insert into ref_t values (1,3)");
-            rs = s.executeQuery("select * from ref_t");
-            rs.next();
-            rs.deleteRow();
-            rs.next();
+                s.executeUpdate("insert into ref_t values (1,4), (1,5)");
 
-            try {
-                rs.deleteRow();
-                fail();
-            } catch (SQLException e) {
-                assertSQLState(LANG_FK_VIOLATION, e);
+                // direct delete code path
+                assertStatementError(LANG_FK_VIOLATION, s, "delete from ref_t");
+
+                // deferred delete code path: not ok
+                assertStatementError(LANG_FK_VIOLATION, s,
+                                     "delete from ref_t where i = 1 and " +
+                                     "    i in (select i from ref_t)");
+
+                // deferred code path: OK
+                s.executeUpdate("delete from ref_t where i = 1 and " +
+                                "    i in (select i from ref_t) and j >= 4");
+
+                s.executeUpdate("insert into ref_t values (1,4), (1,5)");
+                s.executeUpdate("delete from ref_t where j >= 4");
+                JDBC.assertFullResultSet(
+                    s.executeQuery("select * from ref_t"),
+                    new String[][]{{"1", "3"}});
+
+                commit();
+
+                //
+                // Try similar with update rather than delete. In this
+                // case there is only ever a deferred code path, so separate
+                // teste cases as for delete (above) are not relevant.
+                //
+                s.executeUpdate("insert into ref_t values (1,4)");
+                s.executeUpdate("update ref_t set i = 2 where j = 4");
+                s.executeUpdate("insert into ref_t values (1,4)");
+                assertStatementError(LANG_FK_VIOLATION,
+                                     s,
+                                     "update ref_t set i = 2");
+
+                rs = s.executeQuery("select * from ref_t");
+                rs.next();
+                rs.updateInt(1, 3);
+                rs.updateRow();
+                rs.close();
+                commit();
+
+                dropTable("t");
+                dropTable("ref_t");
+                commit();
             }
 
-            s.executeUpdate("insert into ref_t values (1,4), (1,5)");
+            /*   N O   A C T I O N,   R E S T R I C T   (d e f e r r e d) */
 
-            // direct delete code path
-            assertStatementError(LANG_FK_VIOLATION, s, "delete from ref_t");
+            for (String refAct : refActions) {
+                // Delete (deferred processing code path) with more complex FKs
+                // and more dups with different keys, so we can execise the
+                // postCheck mechanism in ReferencedKeyRIChecker including
+                // row/key mappings
 
-            // deferred delete code path: not ok
-            assertStatementError(LANG_FK_VIOLATION, s,
-                    "delete from ref_t where i = 1 and " +
-                    "    i in (select i from ref_t)");
+                s.executeUpdate(
+                    "create table ref_t(c char(1), i int, j int, k int," +
+                    "    constraint c primary key (k, i) initially deferred)");
+                s.executeUpdate(
+                    "create table t(l bigint, i int, j int, k int," +
+                    "    constraint c2 foreign key(i,k) " +
+                    "    references ref_t(k, i)" + refAct + ")");
+
+                // key (1, 100) has 3 dups, key (3,100) has two dups
+                s.executeUpdate("insert into ref_t values " +
+                                "('a', 100, -1, 1)," +
+                                "('a', 100, -2, 1)," +
+                                "('a', 100, -3, 1)," +
+                                "('a', 100, -1, 2)," +
+                                "('a', 100, -2, 3)," +
+                                "('a', 100, -3, 3)");
+
+                s.executeUpdate("insert into t values " +
+                                "(-11, 1, -4, 100)," +
+                                "(-12, 2, -5, 100)," +
+                                "(-13, 3, -6, 100)");
+
+                // This should throw using the postCheck mechanism.
+                try {
+                    s.executeUpdate(
+                        "delete from ref_t where j < -1 and " +
+                        "    k in (select k from ref_t)");
+                    fail();
+                } catch (SQLException e) {
+                    assertSQLState(LANG_FK_VIOLATION, e);
+                    String expected =
+                        "DELETE on table 'REF_T' caused a violation" +
+                        " of foreign key constraint 'C2' for key (3,100).  " +
+                        "The statement has been rolled back.";
+                    assertEquals(expected, e.getMessage());
+                }
+
+                // These should be ok (using the postCheck mechanism), since
+                // they both leave one row in ref_t to satisfy the constraint.
+                s.executeUpdate(
+                    "delete from ref_t where j < -1 and " +
+                    "    k in (select k from ref_t where k < 3)");
+                s.executeUpdate(
+                    "delete from ref_t where j < -2 and " +
+                    "    k in (select k from ref_t where k >= 3)");
 
-            // deferred code path: OK
-            s.executeUpdate("delete from ref_t where i = 1 and " +
-                    "    i in (select i from ref_t) and j >= 4");
+                commit();
 
-            s.executeUpdate("insert into ref_t values (1,4), (1,5)");
-            s.executeUpdate("delete from ref_t where j >= 4");
-            JDBC.assertFullResultSet(
-                    s.executeQuery("select * from ref_t"),
-                    new String[][]{{"1", "3"}});
+                //
+                // Do the same exercise but now with update instead of delete
+                //
+                dropTable("t");
+                dropTable("ref_t");
+                commit();
 
-            commit();
+                s.executeUpdate(
+                    "create table ref_t(c char(1), i int, j int, k int," +
+                    "    constraint c primary key (k, i) initially deferred)");
+                s.executeUpdate(
+                    "create table t(l bigint, i int, j int, k int," +
+                    "    constraint c2 foreign key(i,k) " +
+                    "    references ref_t(k, i)" + refAct + ")");
+
+                // key (1, 100) has 3 dups, key (3,100) has two dups
+                s.executeUpdate("insert into ref_t values " +
+                                "('a', 100, -1, 1)," +
+                                "('a', 100, -2, 1)," +
+                                "('a', 100, -3, 1)," +
+                                "('a', 100, -1, 2)," +
+                                "('a', 100, -2, 3)," +
+                                "('a', 100, -3, 3)");
+
+                s.executeUpdate("insert into t values " +
+                                "(-11, 1, -4, 100)," +
+                                "(-12, 2, -5, 100)," +
+                                "(-13, 3, -6, 100)");
+
+                // This should throw using the postCheck mechanism.
+                try {
+                    s.executeUpdate(
+                        "update ref_t set k=k*100 where j < -1 and " +
+                        "    k in (select k from ref_t)");
+                    fail();
+                } catch (SQLException e) {
+                    assertSQLState(LANG_FK_VIOLATION, e);
+                    String expected =
+                        "UPDATE on table 'REF_T' caused a violation" +
+                        " of foreign key constraint 'C2' for key (3,100).  " +
+                        "The statement has been rolled back.";
+                    assertEquals(expected, e.getMessage());
+                }
+
+                // These should be ok (using the postCheck mechanism), since
+                // they both leave one row in ref_t to satisfy the constraint.
+                s.executeUpdate(
+                    "update ref_t set k=k*100 where j < -1 and " +
+                    "    k in (select k from ref_t where k < 3)");
+                s.executeUpdate(
+                    "update ref_t set k=k*100 where j < -2 and " +
+                    "    k in (select k from ref_t where k >= 3)");
 
-            //
-            // Try similar with update rather than delete. In this
-            // case there is only ever a deferred code path, so separate
-            // teste cases as for delete (above) are not relevant.
-            //
-            s.executeUpdate("insert into ref_t values (1,4)");
-            s.executeUpdate("update ref_t set i = 2 where j = 4");
-            s.executeUpdate("insert into ref_t values (1,4)");
-            assertStatementError(LANG_FK_VIOLATION,
-                                 s,
-                                 "update ref_t set i = 2");
-
-            rs = s.executeQuery("select * from ref_t");
-            rs.next();
-            rs.updateInt(1, 3);
-            rs.updateRow();
-            rs.close();
-            commit();
+                dropTable("t");
+                dropTable("ref_t");
+                commit();
+            }
 
-            dropTable("t");
-            dropTable("ref_t");
-            commit();
+            /*  C A S C A D E  */
 
-            // Delete (deferred processing code path) with more complex FKs and
-            // more dups with different keys, so we can execise the postCheck
-            // mechanism in ReferencedKeyRIChecker including row/key mappings
+            // CASCADE delete with deferred row code path (not deferred
+            // constraint) should still
+            // not fail. Test since we messed with code path.
             s.executeUpdate(
                 "create table ref_t(c char(1), i int, j int, k int," +
-                "    constraint c primary key (k, i) initially deferred)");
+                "    constraint c primary key (k, i))");
             s.executeUpdate(
                 "create table t(l bigint, i int, j int, k int," +
-                "    constraint c2 foreign key(i,k) references ref_t(k, i))");
+                "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
+                "    on delete cascade)");
 
-            // key (1, 100) has 3 dups, key (3,100) has two dups
             s.executeUpdate("insert into ref_t values " +
-                            "('a', 100, -1, 1)," +
-                            "('a', 100, -2, 1)," +
-                            "('a', 100, -3, 1)," +
-                            "('a', 100, -1, 2)," +
-                            "('a', 100, -2, 3)," +
                             "('a', 100, -3, 3)");
-
             s.executeUpdate("insert into t values " +
-                            "(-11, 1, -4, 100)," +
-                            "(-12, 2, -5, 100)," +
-                            "(-13, 3, -6, 100)");
-
-            // This should throw using the postCheck mechanism.
-            try {
-                s.executeUpdate(
-                    "delete from ref_t where j < -1 and " +
-                    "    k in (select k from ref_t)");
-                fail();
-            } catch (SQLException e) {
-                assertSQLState(LANG_FK_VIOLATION, e);
-                String expected =
-                    "DELETE on table 'REF_T' caused a violation" +
-                    " of foreign key constraint 'C2' for key (3,100).  " +
-                    "The statement has been rolled back.";
-                assertEquals(expected, e.getMessage());
-            }
-
-            // These should be ok (using the postCheck mechanism), since they
-            // both leave one row in ref_t to satisfy the constraint.
+                            "(-11, 3, -4, 100)");
             s.executeUpdate(
                 "delete from ref_t where j < -1 and " +
-                "    k in (select k from ref_t where k < 3)");
-            s.executeUpdate(
-                "delete from ref_t where j < -2 and " +
-                "    k in (select k from ref_t where k >= 3)");
+                "    k in (select k from ref_t)");
 
-            commit();
+            JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
+            JDBC.assertEmpty(s.executeQuery("select * from t"));
 
-            //
-            // Do the same exercise but now with update instead of delete
-            //
             dropTable("t");
             dropTable("ref_t");
             commit();
 
+            // Deferred PK constraint, this time with delete with CASCADE,
+            // should not fail
             s.executeUpdate(
                 "create table ref_t(c char(1), i int, j int, k int," +
                 "    constraint c primary key (k, i) initially deferred)");
+
+            // Not yet implemented
+            assertStatementError("X0Y47", s,
+                "create table t(l bigint, i int, j int, k int," +
+                "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
+                "    on delete cascade)");
+
+            dropTable("t");
+            dropTable("ref_t");
+
+            commit();
+
+            /*  S E T   N U L L  */
+
+            // SET NULL  delete with deferred row code path should still
+            // not fail. Test since we messed with code path.
+            s.executeUpdate(
+                "create table ref_t(c char(1), i int, j int, k int," +
+                "    constraint c primary key (k, i))");
             s.executeUpdate(
                 "create table t(l bigint, i int, j int, k int," +
-                "    constraint c2 foreign key(i,k) references ref_t(k, i))");
+                "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
+                "    on delete set null)");
 
-            // key (1, 100) has 3 dups, key (3,100) has two dups
             s.executeUpdate("insert into ref_t values " +
-                            "('a', 100, -1, 1)," +
-                            "('a', 100, -2, 1)," +
-                            "('a', 100, -3, 1)," +
-                            "('a', 100, -1, 2)," +
-                            "('a', 100, -2, 3)," +
                             "('a', 100, -3, 3)");
-
             s.executeUpdate("insert into t values " +
-                            "(-11, 1, -4, 100)," +
-                            "(-12, 2, -5, 100)," +
-                            "(-13, 3, -6, 100)");
+                            "(-11, 3, -4, 100)");
+            s.executeUpdate("delete from ref_t");
 
-            // This should throw using the postCheck mechanism.
-            try {
-                s.executeUpdate(
-                    "update ref_t set k=k*100 where j < -1 and " +
-                    "    k in (select k from ref_t)");
-                fail();
-            } catch (SQLException e) {
-                assertSQLState(LANG_FK_VIOLATION, e);
-                String expected =
-                    "UPDATE on table 'REF_T' caused a violation" +
-                    " of foreign key constraint 'C2' for key (3,100).  " +
-                    "The statement has been rolled back.";
-                assertEquals(expected, e.getMessage());
-            }
+            JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
+            JDBC.assertFullResultSet(s.executeQuery("select * from t"),
+                    new String[][]{{"-11", null, "-4", null}});
 
-            // These should be ok (using the postCheck mechanism), since they
-            // both leave one row in ref_t to satisfy the constraint.
-            s.executeUpdate(
-                "update ref_t set k=k*100 where j < -1 and " +
-                "    k in (select k from ref_t where k < 3)");
+            dropTable("t");
+            dropTable("ref_t");
+            commit();
+
+            // Deferred constraint PK, delete with SET NULL should not
+            // fail
             s.executeUpdate(
-                "update ref_t set k=k*100 where j < -2 and " +
-                "    k in (select k from ref_t where k >= 3)");
+                "create table ref_t(c char(1), i int, j int, k int," +
+                "    constraint c primary key (k, i) initially deferred)");
 
-            commit();
+            // Not yet implemented
+            assertStatementError("X0Y47", s,
+               "create table t(l bigint, i int, j int, k int," +
+                "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
+                "    on delete set null)");
 
+            commit();
         } finally {
             if (rs != null) {
                 rs.close();
@@ -1038,4 +1147,47 @@ public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
             commit();
         }
     }
+
+    public void testSelfReferential() throws SQLException {
+        Statement s = createStatement();
+        try {
+
+            s.executeUpdate(
+                "create table t(name varchar(10) primary key " +
+                "                   deferrable initially deferred," +
+                "               boss varchar(10) references t(name) " +
+                "                   on delete restrict, i int)");
+
+            s.executeUpdate("insert into t values ('daisy', null, 1)");
+            s.executeUpdate("insert into t values ('daisy', null, 2)");
+            s.executeUpdate("insert into t values ('donald', 'daisy', 3)");
+
+            s.executeUpdate("delete from t where name like 'daisy%' and i = 1");
+            JDBC.assertFullResultSet(s.executeQuery("select * from t"),
+                    new String[][]{
+                        {"daisy", null, "2"},
+                        {"donald", "daisy", "3"}});
+            commit();
+
+            s.executeUpdate(
+                    "create table employees(name char(40), " +
+                    "    constraint ec primary key(name) initially deferred, " +
+                    "    address char(40))");
+
+            // Not yet implemented.
+            assertStatementError("X0Y47", s,
+                "create table teammember(" +
+                "name char(40) primary key " +
+                        "references employees(name) on delete cascade, " +
+                "boss char(40) " +
+                        "references teammember(name) on delete cascade)");
+
+
+        } finally {
+            dropTable("t");
+            dropTable("employees");
+            dropTable("teammember");
+            commit();
+        }
+    }
 }
