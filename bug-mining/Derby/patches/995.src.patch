diff --git a/java/engine/org/apache/derby/iapi/types/DataTypeDescriptor.java b/java/engine/org/apache/derby/iapi/types/DataTypeDescriptor.java
index 7eb427e51..0e5715660 100644
--- a/java/engine/org/apache/derby/iapi/types/DataTypeDescriptor.java
+++ b/java/engine/org/apache/derby/iapi/types/DataTypeDescriptor.java
@@ -1332,5 +1332,73 @@ public final class DataTypeDescriptor implements TypeDescriptor, Formatable
 	 *	@return	the formatID of this class
 	 */
 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_SERVICES_IMPL_V01_ID; }
+
+    /**
+     * Check to make sure that this type id is something a user can create
+     * him/herself directly through an SQL CREATE TABLE statement.
+     * 
+     * This method is used for CREATE TABLE AS ... WITH [NO] DATA binding
+     * because it's possible for the query to return types which are not
+     * actually creatable for a user.  DERBY-2605.
+     *
+     * Three examples are:
+     *
+     *  BOOLEAN: A user can select boolean columns from system tables, but
+     *   s/he is not allowed to create such a column him/herself.
+     *
+     *  JAVA_OBJECT: A user can select columns of various java object types
+     *   from system tables, but s/he is not allowed to create such a column
+     *   him/herself.
+     *  
+     *  DECIMAL: A user can specify a VALUES clause with a constant that
+     *   has a precision of greater than 31.  Derby can apparently handle
+     *   such a value internally, but the user is not supposed to be able
+     *   create such a column him/herself.
+     * 
+     * @return True if the type associated with this DTD can be created via
+     *  the CREATE TABLE syntax; false otherwise.
+     */
+    public boolean isUserCreatableType() throws StandardException
+    {
+        switch (typeId.getJDBCTypeId())
+        {
+            case Types.BOOLEAN:
+            case Types.JAVA_OBJECT:
+            	return false;
+            case Types.DECIMAL:
+                return
+                (getPrecision() <= typeId.getMaximumPrecision()) &&
+                (getScale() <= typeId.getMaximumScale()) &&
+                (getMaximumWidth() <= typeId.getMaximumMaximumWidth());
+            default: break;
+        }
+        return true;
+    }
+
+    /**
+     * Return the SQL type name and, if applicable, scale/precision/length
+     * for this DataTypeDescriptor.  Note that we want the values from *this*
+     * object specifically, not the max values defined on this.typeId.
+     */
+    public String getFullSQLTypeName()
+    {
+        StringBuffer sbuf = new StringBuffer(typeId.getSQLTypeName());
+        if (typeId.isDecimalTypeId() || typeId.isNumericTypeId())
+        {
+            sbuf.append("(");
+            sbuf.append(getPrecision());
+            sbuf.append(", ");
+            sbuf.append(getScale());
+            sbuf.append(")");
+        }
+        else if (typeId.variableLength())
+        {
+            sbuf.append("(");
+            sbuf.append(getMaximumWidth());
+            sbuf.append(")");
+        }
+
+        return sbuf.toString();
+    }
 }
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/CreateTableNode.java b/java/engine/org/apache/derby/impl/sql/compile/CreateTableNode.java
index 881057808..f37787ebd 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/CreateTableNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/CreateTableNode.java
@@ -297,8 +297,8 @@ public class CreateTableNode extends DDLStatementNode
 			{
 				ResultColumn rc = (ResultColumn) qeRCL.elementAt(index);
 				if (rc.isGenerated()) 
-			        {
-				    continue;
+				{
+					continue;
 				}
 				/* Raise error if column name is system generated. */
 				if (rc.isNameGenerated())
@@ -306,6 +306,16 @@ public class CreateTableNode extends DDLStatementNode
 					throw StandardException.newException(
 							SQLState.LANG_TABLE_REQUIRES_COLUMN_NAMES);
 				}
+
+				DataTypeDescriptor dtd = rc.getExpressionType();
+				if ((dtd != null) && !dtd.isUserCreatableType())
+				{
+					throw StandardException.newException(
+							SQLState.LANG_INVALID_COLUMN_TYPE_CREATE_TABLE,
+							dtd.getFullSQLTypeName(),
+							rc.getName());
+				}
+
 				ColumnDefinitionNode column = new ColumnDefinitionNode();
 				column.init(rc.getName(), null, rc.getType(), null);
 				tableElementList.addTableElement(column);
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index 45e25d4f1..9a38a276c 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -1649,6 +1649,13 @@ Guide.
                 <arg>value</arg>
             </msg>
 
+            <msg>
+                <name>42X71</name>
+                <text>Invalid data type '{0}' for column '{1}'.</text>
+                <arg>datatypeName</arg>
+                <arg>columnName</arg>
+            </msg>
+
             <msg>
                 <name>42X72</name>
                 <text>No static field '{0}' was found belonging to class '{1}'.  The field might exist, but it is not public and/or static, or the class does not exist or the class is not public.  </text>
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 4d99a5049..2ae163ee6 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -845,6 +845,7 @@ public interface SQLState {
 	String LANG_NO_FIELD_FOUND                                         = "42X68";
 	String LANG_PRIMITIVE_REFERENCING_EXPRESSION                       = "42X69";
 	String LANG_TABLE_DEFINITION_R_C_L_MISMATCH                        = "42X70";
+	String LANG_INVALID_COLUMN_TYPE_CREATE_TABLE                       = "42X71";
 	String LANG_NO_STATIC_FIELD_FOUND                                  = "42X72";
 	String LANG_AMBIGUOUS_METHOD_INVOCATION                            = "42X73";
 	String LANG_INVALID_CALL_STATEMENT                                 = "42X74";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CreateTableFromQueryTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CreateTableFromQueryTest.java
index a0800b4ad..1c7aacbc0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CreateTableFromQueryTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CreateTableFromQueryTest.java
@@ -233,6 +233,24 @@ public final class CreateTableFromQueryTest extends BaseJDBCTestCase {
         assertStatementError("0A000", stmt,
             "create table t3 as select * from t1 with data");
     }
+    
+    /**
+     * Test error for creating table where the data type is invalid.
+     */
+    public void testInvalidDataType() throws Exception
+    {
+        // BOOLEAN
+        assertStatementError("42X71", stmt,
+            "create table t as select systemalias from sys.sysaliases with no data");
+
+        // USER (Java Object)
+        assertStatementError("42X71", stmt,
+            "create table t as select aliasinfo from sys.sysaliases with no data");
+        
+        // DECIMAL(44,0)
+        assertStatementError("42X71", stmt,
+        	"create table t(x) as values 12345678901234567890123456789012345678901234 with no data");
+    }
    
     private void positiveTest(String sql, String [] columnNames,
             String [] nullability, String [] types) throws Exception
