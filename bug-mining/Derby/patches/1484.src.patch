diff --git a/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java b/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
index cc5e56b21..05e827e98 100644
--- a/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
+++ b/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
@@ -1041,21 +1041,15 @@ nextMethod:	for (int i = 0; i < methods.length; i++) {
 				return true;
 		} else if ((fromClass == Integer.TYPE) || fromName.equals(nonPrimTypeNames[4]))
 		{
-			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) ||
-				(toClass == Long.TYPE) ||
-				(toClass == Float.TYPE) ||
-				(toClass == Double.TYPE) )
+			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) )
 				return true;
 		} else if ((fromClass == Long.TYPE) || fromName.equals(nonPrimTypeNames[5]))
 		{
-			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) ||
-				(toClass == Float.TYPE) ||
-				(toClass == Double.TYPE) )
+			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) )
 				return true;
 		} else if ((fromClass == Float.TYPE) || fromName.equals(nonPrimTypeNames[6]))
 		{
-			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) ||
-				(toClass == Double.TYPE) )
+			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) )
 				return true;
 		} else if ((fromClass == Double.TYPE) || fromName.equals(nonPrimTypeNames[7]))
 		{
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/lockTableVti.out b/java/testing/org/apache/derbyTesting/functionTests/master/lockTableVti.out
index acb2452bc..eeef4cae7 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/lockTableVti.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/lockTableVti.out
@@ -16,7 +16,7 @@ ij> --
 --
 --test to make sure WAIT state is displayed when lock table is printed
 connect 'wombat;user=c1' AS C1;
-ij(C1)> create procedure c1.sleep(t INTEGER) dynamic result sets 0  language java external name 'java.lang.Thread.sleep' parameter style java;
+ij(C1)> create procedure c1.sleep(t BIGINT) dynamic result sets 0  language java external name 'java.lang.Thread.sleep' parameter style java;
 0 rows inserted/updated/deleted
 ij(C1)> create table c1.account (a int primary key not null, b int);
 0 rows inserted/updated/deleted
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/onlineBackupTest2.out b/java/testing/org/apache/derbyTesting/functionTests/master/onlineBackupTest2.out
index e3c8cc3ae..aa95a41a9 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/onlineBackupTest2.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/onlineBackupTest2.out
@@ -14,263 +14,263 @@ ij> --
 --   See the License for the specific language governing permissions and
 --   limitations under the License.
 --
--- This script tests online backup functionality 
--- 1) in a non-idle tranaction.
--- 2) mutiple backup calls on the same connection. 
--- 3) when unlogged operations are running in parallel 
---      to the  backup thread. 
-connect 'wombat' as c1 ;
-ij(C1)> create procedure sleep(t INTEGER) dynamic result sets 0  
-language java external name 'java.lang.Thread.sleep' 
-parameter style java;
-0 rows inserted/updated/deleted
-ij(C1)> create function fileExists(fileName varchar(128))
-returns VARCHAR(100) external name
- 'org.apache.derbyTesting.functionTests.util.FTFileUtil.fileExists' 
-language java parameter style java;
-0 rows inserted/updated/deleted
-ij(C1)> create function removeDirectory(fileName varchar(128))
-returns VARCHAR(100) external name
- 'org.apache.derbyTesting.functionTests.util.FTFileUtil.removeDirectory' 
-language java parameter style java;
-0 rows inserted/updated/deleted
-ij(C1)> autocommit off;
-ij(C1)> create table t1(a int ) ;
-0 rows inserted/updated/deleted
-ij(C1)> insert into t1 values(1) ;
-1 row inserted/updated/deleted
-ij(C1)> insert into t1 values(2) ;
-1 row inserted/updated/deleted
-ij(C1)> commit ;
-ij(C1)> -- make sure backup calls are not allowed in a transaction that
--- has executed unlogged operations before the backup calls. 
-insert into t1 values(3);
-1 row inserted/updated/deleted
-ij(C1)> create index idx1 on t1(a);
-0 rows inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE('extinout/mybackup') ;
-ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup') ;
-ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
-                                              'extinout/mybackup', 1);
-ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
-                                              'extinout/mybackup', 1);
-ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
-ij(C1)> --backup failures should not rollback/commit the transaction. 
-select * from t1 ;
-A          
------------
-1          
-2          
-3          
-ij(C1)> insert into t1 values(4) ;
-1 row inserted/updated/deleted
-ij(C1)> commit;
-ij(C1)> drop index idx1;
-0 rows inserted/updated/deleted
-ij(C1)> commit;
-ij(C1)> --- make sure backup calls can be run one after another.
-insert into t1 values(5) ;
-1 row inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE('extinout/mybackup') ;
-0 rows inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup');
-0 rows inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
-                                           'extinout/mybackup', 1);
-0 rows inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
-                                               'extinout/mybackup', 1);
-0 rows inserted/updated/deleted
-ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
-0 rows inserted/updated/deleted
-ij(C1)> commit;
-ij(C1)> -- make sure backup is not allowed when non-logged 
--- operations are pending
-connect 'wombat' as c2 ;
-ij(C2)> autocommit off ;
-ij(C2)> -- index creaton is a non-logged ops, backup should not run 
--- until it is committed
-create index idx1 on t1(a) ;
-0 rows inserted/updated/deleted
-ij(C2)> set connection c1 ;
-ij(C1)> -- following two backup calls should fail , because they are not waiting
--- for the unlogged index creation in anothere transaction to commit/rollback.
-call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup') ;
-ERROR XSRSA: Cannot backup the database when unlogged operations are uncommitted. Please commit the transactions with backup blocking operations. 
-ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
-                                               'extinout/mybackup', 1);
-ERROR XSRSA: Cannot backup the database when unlogged operations are uncommitted. Please commit the transactions with backup blocking operations. 
-ij(C1)> set connection c2;
-ij(C2)> rollback ;
-ij(C2)> -- make sure backup call waits, if wait parameter value is non-zero or 
--- the procedures used from before 10.2( old backup procedures wait by 
--- default for  unlogged operation to finish.)
--- This testing is done by starting backup in a different thread and then 
--- wait for few seconds and check if the backup dir is created ? 
--- If backup dir is not created , the backup thread is waiting for unlogged
--- op to finih.
--- Note: Not a 100% foolproof approach because checking for backupdir 
--- might occur before backup thread gets into action. But I think 
--- test  will fail  atleast on some systems, if  backup is not waiting
--- for unlogged ops to complete.
--- case1 : simple database backup with unlogged ops pending.
-set connection c2;
-ij(C2)> -- index is a non-logged operation
-create index idx1 on t1(a) ;
-0 rows inserted/updated/deleted
-ij(C2)> set connection c1;
-ij(C1)> -- make sure backup does not already exists at the backup location.
-values removeDirectory('extinout/ulbackup1');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> values fileExists('extinout/ulbackup1');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C1)> async bthread1 'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE(
-                                    ''extinout/ulbackup1'')' ;
-ij(C1)> set connection c2;
-ij(C2)> -- sleep for a while for the backup thread to 
--- really get into the wait state
-call sleep(1000);
-0 rows inserted/updated/deleted
-ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
-values fileExists('extinout/ulbackup1');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C2)> -- rollback the unlogged op for backup to proceed.
-rollback;
-ij(C2)> set connection c1;
-ij(C1)> -- wait for backup thread to finish the work.
-wait for bthread1;
-0 rows inserted/updated/deleted
-ij(C1)> -- check if backup is created.
-values fileExists('extinout/ulbackup1');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> commit;
-ij(C1)> -- case2: simple backup call with the default wait for ulogged ops
-set connection c2;
-ij(C2)> create index idx1 on t1(a) ;
-0 rows inserted/updated/deleted
-ij(C2)> set connection c1;
-ij(C1)> -- make sure backup does not already exists at the backup location.
-values removeDirectory('extinout/ulbackup2');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> values fileExists('extinout/ulbackup2');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C1)> async bthread1 
-  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE(''extinout/ulbackup2'')';
-ij(C1)> set connection c2;
-ij(C2)> -- sleep for a while for the backup thread to 
--- really get into the wait state
-call sleep(1000);
-0 rows inserted/updated/deleted
-ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
-values fileExists('extinout/ulbackup2');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C2)> -- rollback the unlogged op for backup to proceed.
-rollback;
-ij(C2)> set connection c1;
-ij(C1)> -- wait for backup thread to finish the work.
-wait for bthread1;
-0 rows inserted/updated/deleted
-ij(C1)> -- check if backup is created.
-values fileExists('extinout/ulbackup2');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> commit;
-ij(C1)> --- case 3: log archive backup with with unlogged ops pending.
-set connection c2;
-ij(C2)> create index idx1 on t1(a) ;
-0 rows inserted/updated/deleted
-ij(C2)> set connection c1;
-ij(C1)> --make sure backup does not already exists at the backup location.
-values removeDirectory('extinout/ulbackup3');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> values fileExists('extinout/ulbackup3');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C1)> async bthread1 
-  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
-                                    ''extinout/ulbackup3'' , 1)' ;
-ij(C1)> set connection c2;
-ij(C2)> -- sleep for a while for the backup thread to 
--- really get into the wait state
-call sleep(1000);
-0 rows inserted/updated/deleted
-ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
-values fileExists('extinout/ulbackup3');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C2)> -- rollback the unlogged op for backup to proceed.
-rollback;
-ij(C2)> set connection c1;
-ij(C1)> -- wait for backup thread to finish the work.
-wait for bthread1;
-0 rows inserted/updated/deleted
-ij(C1)> -- check if backup is created.
-values fileExists('extinout/ulbackup3');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
-0 rows inserted/updated/deleted
-ij(C1)> -- case4 : log archive backup with the defailt wait for unlogged ops.
-set connection c2;
-ij(C2)> create index idx1 on t1(a) ;
-0 rows inserted/updated/deleted
-ij(C2)> set connection c1;
-ij(C1)> --make sure backup does not already exists at the backup location.
-values removeDirectory('extinout/ulbackup4');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> values fileExists('extinout/ulbackup4');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C1)> async bthread1 
-  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
-                                    ''extinout/ulbackup4'' , 1)' ;
-ij(C1)> set connection c2;
-ij(C2)> -- sleep for a while for the backup thread to 
--- really get into the wait state
-call sleep(1000);
-0 rows inserted/updated/deleted
-ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
-values fileExists('extinout/ulbackup4');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-false                                                                                                                           
-ij(C2)> -- commit the unlogged op for backup to proceed.
-commit;
-ij(C2)> set connection c1;
-ij(C1)> -- wait for backup thread to finish the work.
-wait for bthread1;
-0 rows inserted/updated/deleted
-ij(C1)> -- check if backup is created.
-values fileExists('extinout/ulbackup4');
-1                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------
-true                                                                                                                            
-ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
-0 rows inserted/updated/deleted
-ij(C1)> 
+-- This script tests online backup functionality 
+-- 1) in a non-idle tranaction.
+-- 2) mutiple backup calls on the same connection. 
+-- 3) when unlogged operations are running in parallel 
+--      to the  backup thread. 
+connect 'wombat' as c1 ;
+ij(C1)> create procedure sleep(t BIGINT) dynamic result sets 0  
+language java external name 'java.lang.Thread.sleep' 
+parameter style java;
+0 rows inserted/updated/deleted
+ij(C1)> create function fileExists(fileName varchar(128))
+returns VARCHAR(100) external name
+ 'org.apache.derbyTesting.functionTests.util.FTFileUtil.fileExists' 
+language java parameter style java;
+0 rows inserted/updated/deleted
+ij(C1)> create function removeDirectory(fileName varchar(128))
+returns VARCHAR(100) external name
+ 'org.apache.derbyTesting.functionTests.util.FTFileUtil.removeDirectory' 
+language java parameter style java;
+0 rows inserted/updated/deleted
+ij(C1)> autocommit off;
+ij(C1)> create table t1(a int ) ;
+0 rows inserted/updated/deleted
+ij(C1)> insert into t1 values(1) ;
+1 row inserted/updated/deleted
+ij(C1)> insert into t1 values(2) ;
+1 row inserted/updated/deleted
+ij(C1)> commit ;
+ij(C1)> -- make sure backup calls are not allowed in a transaction that
+-- has executed unlogged operations before the backup calls. 
+insert into t1 values(3);
+1 row inserted/updated/deleted
+ij(C1)> create index idx1 on t1(a);
+0 rows inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE('extinout/mybackup') ;
+ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup') ;
+ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
+                                              'extinout/mybackup', 1);
+ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
+                                              'extinout/mybackup', 1);
+ERROR XSRSB: Backup cannot be performed in a transaction with uncommitted unlogged operations.
+ij(C1)> --backup failures should not rollback/commit the transaction. 
+select * from t1 ;
+A          
+-----------
+1          
+2          
+3          
+ij(C1)> insert into t1 values(4) ;
+1 row inserted/updated/deleted
+ij(C1)> commit;
+ij(C1)> drop index idx1;
+0 rows inserted/updated/deleted
+ij(C1)> commit;
+ij(C1)> --- make sure backup calls can be run one after another.
+insert into t1 values(5) ;
+1 row inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE('extinout/mybackup') ;
+0 rows inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup');
+0 rows inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
+                                           'extinout/mybackup', 1);
+0 rows inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
+                                               'extinout/mybackup', 1);
+0 rows inserted/updated/deleted
+ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
+0 rows inserted/updated/deleted
+ij(C1)> commit;
+ij(C1)> -- make sure backup is not allowed when non-logged 
+-- operations are pending
+connect 'wombat' as c2 ;
+ij(C2)> autocommit off ;
+ij(C2)> -- index creaton is a non-logged ops, backup should not run 
+-- until it is committed
+create index idx1 on t1(a) ;
+0 rows inserted/updated/deleted
+ij(C2)> set connection c1 ;
+ij(C1)> -- following two backup calls should fail , because they are not waiting
+-- for the unlogged index creation in anothere transaction to commit/rollback.
+call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup') ;
+ERROR XSRSA: Cannot backup the database when unlogged operations are uncommitted. Please commit the transactions with backup blocking operations. 
+ij(C1)> call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(
+                                               'extinout/mybackup', 1);
+ERROR XSRSA: Cannot backup the database when unlogged operations are uncommitted. Please commit the transactions with backup blocking operations. 
+ij(C1)> set connection c2;
+ij(C2)> rollback ;
+ij(C2)> -- make sure backup call waits, if wait parameter value is non-zero or 
+-- the procedures used from before 10.2( old backup procedures wait by 
+-- default for  unlogged operation to finish.)
+-- This testing is done by starting backup in a different thread and then 
+-- wait for few seconds and check if the backup dir is created ? 
+-- If backup dir is not created , the backup thread is waiting for unlogged
+-- op to finih.
+-- Note: Not a 100% foolproof approach because checking for backupdir 
+-- might occur before backup thread gets into action. But I think 
+-- test  will fail  atleast on some systems, if  backup is not waiting
+-- for unlogged ops to complete.
+-- case1 : simple database backup with unlogged ops pending.
+set connection c2;
+ij(C2)> -- index is a non-logged operation
+create index idx1 on t1(a) ;
+0 rows inserted/updated/deleted
+ij(C2)> set connection c1;
+ij(C1)> -- make sure backup does not already exists at the backup location.
+values removeDirectory('extinout/ulbackup1');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> values fileExists('extinout/ulbackup1');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C1)> async bthread1 'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE(
+                                    ''extinout/ulbackup1'')' ;
+ij(C1)> set connection c2;
+ij(C2)> -- sleep for a while for the backup thread to 
+-- really get into the wait state
+call sleep(1000);
+0 rows inserted/updated/deleted
+ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
+values fileExists('extinout/ulbackup1');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C2)> -- rollback the unlogged op for backup to proceed.
+rollback;
+ij(C2)> set connection c1;
+ij(C1)> -- wait for backup thread to finish the work.
+wait for bthread1;
+0 rows inserted/updated/deleted
+ij(C1)> -- check if backup is created.
+values fileExists('extinout/ulbackup1');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> commit;
+ij(C1)> -- case2: simple backup call with the default wait for ulogged ops
+set connection c2;
+ij(C2)> create index idx1 on t1(a) ;
+0 rows inserted/updated/deleted
+ij(C2)> set connection c1;
+ij(C1)> -- make sure backup does not already exists at the backup location.
+values removeDirectory('extinout/ulbackup2');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> values fileExists('extinout/ulbackup2');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C1)> async bthread1 
+  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE(''extinout/ulbackup2'')';
+ij(C1)> set connection c2;
+ij(C2)> -- sleep for a while for the backup thread to 
+-- really get into the wait state
+call sleep(1000);
+0 rows inserted/updated/deleted
+ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
+values fileExists('extinout/ulbackup2');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C2)> -- rollback the unlogged op for backup to proceed.
+rollback;
+ij(C2)> set connection c1;
+ij(C1)> -- wait for backup thread to finish the work.
+wait for bthread1;
+0 rows inserted/updated/deleted
+ij(C1)> -- check if backup is created.
+values fileExists('extinout/ulbackup2');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> commit;
+ij(C1)> --- case 3: log archive backup with with unlogged ops pending.
+set connection c2;
+ij(C2)> create index idx1 on t1(a) ;
+0 rows inserted/updated/deleted
+ij(C2)> set connection c1;
+ij(C1)> --make sure backup does not already exists at the backup location.
+values removeDirectory('extinout/ulbackup3');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> values fileExists('extinout/ulbackup3');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C1)> async bthread1 
+  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
+                                    ''extinout/ulbackup3'' , 1)' ;
+ij(C1)> set connection c2;
+ij(C2)> -- sleep for a while for the backup thread to 
+-- really get into the wait state
+call sleep(1000);
+0 rows inserted/updated/deleted
+ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
+values fileExists('extinout/ulbackup3');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C2)> -- rollback the unlogged op for backup to proceed.
+rollback;
+ij(C2)> set connection c1;
+ij(C1)> -- wait for backup thread to finish the work.
+wait for bthread1;
+0 rows inserted/updated/deleted
+ij(C1)> -- check if backup is created.
+values fileExists('extinout/ulbackup3');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
+0 rows inserted/updated/deleted
+ij(C1)> -- case4 : log archive backup with the defailt wait for unlogged ops.
+set connection c2;
+ij(C2)> create index idx1 on t1(a) ;
+0 rows inserted/updated/deleted
+ij(C2)> set connection c1;
+ij(C1)> --make sure backup does not already exists at the backup location.
+values removeDirectory('extinout/ulbackup4');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> values fileExists('extinout/ulbackup4');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C1)> async bthread1 
+  'call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(
+                                    ''extinout/ulbackup4'' , 1)' ;
+ij(C1)> set connection c2;
+ij(C2)> -- sleep for a while for the backup thread to 
+-- really get into the wait state
+call sleep(1000);
+0 rows inserted/updated/deleted
+ij(C2)> -- make sure backup did not really proceed, backup dir should not exist
+values fileExists('extinout/ulbackup4');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+false                                                                                                                           
+ij(C2)> -- commit the unlogged op for backup to proceed.
+commit;
+ij(C2)> set connection c1;
+ij(C1)> -- wait for backup thread to finish the work.
+wait for bthread1;
+0 rows inserted/updated/deleted
+ij(C1)> -- check if backup is created.
+values fileExists('extinout/ulbackup4');
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+true                                                                                                                            
+ij(C1)> call SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE(1);
+0 rows inserted/updated/deleted
+ij(C1)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignaturesTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignaturesTest.java
index 2feaa9f02..9ea844248 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignaturesTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AnsiSignaturesTest.java
@@ -344,40 +344,40 @@ public class AnsiSignaturesTest extends BaseJDBCTestCase
     public  void    test_integer_unres_int()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "integer_unres_int", "int", new String[] { "int" }, "3", "3", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "integer_unres_int", "int", new String[] { "int" }, "3", "3", TRIED_ALL_COMBINATIONS );
     }
     public  void    test_integer_unres_Integer()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "integer_unres_Integer", "int", new String[] { "int" }, "3", "3", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "integer_unres_Integer", "int", new String[] { "int" }, "3", "3", TRIED_ALL_COMBINATIONS );
     }
     
     public  void    test_bigint_unres_long()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "bigint_unres_long", "bigint", new String[] { "bigint" }, "3", "3", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "bigint_unres_long", "bigint", new String[] { "bigint" }, "3", "3", TRIED_ALL_COMBINATIONS );
     }
     public  void    test_bigint_unres_Long()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "bigint_unres_Long", "bigint", new String[] { "bigint" }, "3", "3", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "bigint_unres_Long", "bigint", new String[] { "bigint" }, "3", "3", TRIED_ALL_COMBINATIONS );
     }
         
     public  void    test_real_unres_float()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "real_unres_float", "real", new String[] { "real" }, "3.0", "3.0", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "real_unres_float", "real", new String[] { "real" }, "3.0", "3.0", TRIED_ALL_COMBINATIONS );
     }
     public  void    test_real_unres_Float()
         throws Exception
     {
-        //FIXME declareAndFailFunction
-        //FIXME ( "real_unres_Float", "real", new String[] { "real" }, "3.0", "3.0", MISSING_METHOD_SQLSTATE );
+        declareAndFailFunction
+            ( "real_unres_Float", "real", new String[] { "real" }, "3.0", "3.0", TRIED_ALL_COMBINATIONS );
     }
         
     public  void    test_double_unres_double()
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/closed.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/closed.java
index e2550db03..1040ff411 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/closed.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/closed.java
@@ -121,7 +121,7 @@ public class closed implements Runnable {
 
 		c3a.createStatement().execute("CREATE TABLE CLOSED.LOCKME(i int)");
 		
-		c3a.createStatement().execute("create procedure sleep(t INTEGER) dynamic result sets 0 language java external name 'java.lang.Thread.sleep' parameter style java");
+		c3a.createStatement().execute("create procedure sleep(t BIGINT) dynamic result sets 0 language java external name 'java.lang.Thread.sleep' parameter style java");
 		c3a.setAutoCommit(false);
 		c3a.createStatement().execute("LOCK TABLE CLOSED.LOCKME IN SHARE MODE");
 		
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/store/lockTableVti.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/store/lockTableVti.sql
index eddecdadf..f318cebee 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/store/lockTableVti.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/store/lockTableVti.sql
@@ -16,7 +16,7 @@
 --
 --test to make sure WAIT state is displayed when lock table is printed
 connect 'wombat;user=c1' AS C1;
-create procedure c1.sleep(t INTEGER) dynamic result sets 0  language java external name 'java.lang.Thread.sleep' parameter style java;
+create procedure c1.sleep(t BIGINT) dynamic result sets 0  language java external name 'java.lang.Thread.sleep' parameter style java;
 create table c1.account (a int primary key not null, b int);
 autocommit off;
 insert into c1.account values (0, 1);
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/store/onlineBackupTest2.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/store/onlineBackupTest2.sql
index b3effa9d4..748daed44 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/store/onlineBackupTest2.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/store/onlineBackupTest2.sql
@@ -21,7 +21,7 @@
 --      to the  backup thread. 
 
 connect 'wombat' as c1 ;
-create procedure sleep(t INTEGER) dynamic result sets 0  
+create procedure sleep(t BIGINT) dynamic result sets 0  
 language java external name 'java.lang.Thread.sleep' 
 parameter style java;
 
