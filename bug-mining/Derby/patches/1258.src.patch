diff --git a/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
index 6d6c57fa2..bec470053 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
@@ -28,22 +28,17 @@ import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.sql.compile.C_NodeTypes;
 import org.apache.derby.iapi.sql.compile.Visitable;
 import org.apache.derby.iapi.sql.compile.Visitor;
-import org.apache.derby.iapi.sql.dictionary.DataDictionary;
-import org.apache.derby.iapi.store.access.Qualifier;
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.sql.compile.TypeCompiler;
-import org.apache.derby.iapi.types.NumberDataValue;
 import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
 
-import org.apache.derby.iapi.store.access.Qualifier;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.reference.ClassName;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
 
-import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.util.ReuseFactory;
 
@@ -765,7 +760,7 @@ public class TernaryOperatorNode extends ValueNode
 			throws StandardException
 	{
 		TypeId	receiverType;
-		TypeId	resultType;
+		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
 
 		// handle parameters here
 
@@ -813,7 +808,7 @@ public class TernaryOperatorNode extends ValueNode
 		** Check the type of the receiver - this function is allowed only on
 		** string value types.  
 		*/
-		resultType = receiverType = receiver.getTypeId();
+		receiverType = receiver.getTypeId();
 		switch (receiverType.getJDBCTypeId())
 		{
 			case Types.CHAR:
@@ -826,6 +821,15 @@ public class TernaryOperatorNode extends ValueNode
 				throwBadType("SUBSTR", receiverType.getSQLTypeName());
 			}
 		}
+		if ((receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) ||
+		   (receiverType.getTypeFormatId() == StoredFormatIds.NCLOB_TYPE_ID)) {
+		// special case for CLOBs: if we start with a CLOB, we have to get
+		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
+		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
+		// This is okay because CLOBs, like VARCHARs, allow variable-length
+		// values (which is a must for the substr to actually work).
+			resultType = receiverType;
+		}
 
 		// Determine the maximum length of the result
 		int resultLen = receiver.getTypeServices().getMaximumWidth();
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
index d4f0d0151..0f6a7faa4 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
@@ -1857,4 +1857,50 @@ ID         |C8_DATE
 1          |1991-01-01
 ij> drop table d2887_types;
 0 rows inserted/updated/deleted
-ij> 
\ No newline at end of file
+ij> -- DERBY-2352 involved a mismatch between the return type of the SUBSTR
+-- method and the expected type of the result column. During compilation,
+-- bind processing was computing that the SUBSTR would return a CHAR, but
+-- at execution time it actually returned a VARCHAR, resulting in a type
+-- mismatch detected by the sorter. Since the TRIM functions are very
+-- closely related to the SUBSTR function, we include a few tests of
+-- those functions in the test case.
+
+create table d2352 (c int);
+0 rows inserted/updated/deleted
+ij> insert into d2352 values (1), (2), (3);
+3 rows inserted/updated/deleted
+ij> select substr('abc', 1) from d2352 order by substr('abc', 1);
+1   
+----
+abc 
+abc 
+abc 
+ij> select substr('abc', 1) from d2352 group by substr('abc', 1);
+1   
+----
+abc 
+ij> select ltrim('abc') from d2352 order by ltrim('abc');
+1   
+----
+abc 
+abc 
+abc 
+ij> select ltrim('abc') from d2352 group by ltrim('abc');
+1   
+----
+abc 
+ij> select trim(trailing ' ' from 'abc') from d2352
+       order by trim(trailing ' ' from 'abc');
+1   
+----
+abc 
+abc 
+abc 
+ij> select trim(trailing ' ' from 'abc') from d2352
+       group by trim(trailing ' ' from 'abc');
+1   
+----
+abc 
+ij> drop table d2352;
+0 rows inserted/updated/deleted
+ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
index 623c1d88b..ad77320b0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
@@ -733,4 +733,23 @@ select id, c8_date from d2887_types order by c8_date desc nulls first;
 
 drop table d2887_types;
 
+-- DERBY-2352 involved a mismatch between the return type of the SUBSTR
+-- method and the expected type of the result column. During compilation,
+-- bind processing was computing that the SUBSTR would return a CHAR, but
+-- at execution time it actually returned a VARCHAR, resulting in a type
+-- mismatch detected by the sorter. Since the TRIM functions are very
+-- closely related to the SUBSTR function, we include a few tests of
+-- those functions in the test case.
+
+create table d2352 (c int);
+insert into d2352 values (1), (2), (3);
+select substr('abc', 1) from d2352 order by substr('abc', 1);
+select substr('abc', 1) from d2352 group by substr('abc', 1);
+select ltrim('abc') from d2352 order by ltrim('abc');
+select ltrim('abc') from d2352 group by ltrim('abc');
+select trim(trailing ' ' from 'abc') from d2352
+       order by trim(trailing ' ' from 'abc');
+select trim(trailing ' ' from 'abc') from d2352
+       group by trim(trailing ' ' from 'abc');
+drop table d2352;
 
