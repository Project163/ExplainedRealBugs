diff --git a/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
index 27d35e8de..045f190de 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java
@@ -150,26 +150,30 @@ abstract class DMLWriteResultSet extends NoRowsResultSetImpl
 					heapIx :
 					baseRowReadMap[heapIx];
 
-                
 				DataValueDescriptor col = row.getColumn(readIx+1);
-				InputStream stream = ((StreamStorable)col).returnStream();
-				((StreamStorable)col).loadStream();
-				// DERBY-3238 
-				// fix up any duplicate streams, for instance in the case of an update with a trigger,
-				// all the columns are read as update columns even if they are not updated, so 
-				// the update column will still have a reference to the original stream.
-				// If we knew from this context that this was an update and we knew the number
-				// of columns in the base table we would be able to calculate exactly the offset to 
-				// check, but we don't have that information from this context.
-				// If DERBY-1482 is fixed, perhaps this code can be removed.
 				
-				if (stream != null)
-					for (int i = 1; i <= row.nColumns(); i++)
-					{
-						DataValueDescriptor c = row.getColumn(i);
-						if (c instanceof StreamStorable)
-							if (((StreamStorable)c).returnStream() == stream)
-								row.setColumn(i, col.cloneValue(false));
+				// Derby-4779
+				if ( col != null ) {
+					InputStream stream = ((StreamStorable)col).returnStream();
+					((StreamStorable)col).loadStream();
+
+					// DERBY-3238
+					// fix up any duplicate streams, for instance in the case of an update with a trigger,
+					// all the columns are read as update columns even if they are not updated, so 
+					// the update column will still have a reference to the original stream.
+					// If we knew from this context that this was an update and we knew the number
+					// of columns in the base table we would be able to calculate exactly the offset to 
+					// check, but we don't have that information from this context.
+					// If DERBY-1482 is fixed, perhaps this code can be removed.
+
+					if (stream != null)
+						for (int i = 1; i <= row.nColumns(); i++)
+						{
+							DataValueDescriptor c = row.getColumn(i);
+							if (c instanceof StreamStorable)
+								if (((StreamStorable)c).returnStream() == stream)
+									row.setColumn(i, col.cloneValue(false));
+						}
 					}
 				}
 			}
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsTest.java
index 079f3ed2c..2c428b221 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsTest.java
@@ -986,7 +986,7 @@ public class GeneratedColumnsTest extends GeneratedColumnsHelper
                  { "before_insert_statement_trigger: [ -1, -1, -1 ]" },
                  { "after_insert_row_trigger: [ 1, -1, null ]" },
                  { "after_insert_row_trigger: [ 2, -2, null ]" },
-                 { "after_insert_row_trigger: [ 3, -3, null ]" },                                                           
+                 { "after_insert_row_trigger: [ 3, -3, null ]" },
                  { "after_insert_statement_trigger: [ -1, -1, -1 ]" },
              }
              );
@@ -5472,7 +5472,69 @@ public class GeneratedColumnsTest extends GeneratedColumnsHelper
                 new String[][] { {"1","2"},{"2","4"},{"3","6"}}, false);
     }
 
+    // Derby 4779
+    public void test_derby_4779()
+        throws Exception
+    {
+    	Connection conn = getConnection();
+
+        goodStatement
+        (
+         conn,
+         "create function f_getRegion\n" +
+         "(\n" +
+         "    v int\n" +
+         ")\n" +
+         "returns int\n" +
+         "language java\n" +
+         "parameter style java\n" +
+         "deterministic\n" +
+         "no sql\n" +
+         "external name 'java.lang.Integer.signum'\n"
+        );
+
+        goodStatement
+        (
+         conn,
+         "create table t1_orders( price int, region generated always as " +
+         "( f_getRegion(price) ) )\n"
+        );
+        
+        goodStatement
+        (
+         conn,
+         "create table t1_dummy(a int)\n"
+        );
+
+        goodStatement
+        (
+         conn,
+         "create trigger t1_trig_after_insert_row_trigger_4779\n" +
+         "after insert on t1_orders\n" +
+         "referencing new as ar\n" +
+         "for each row\n" +
+         "insert into t1_dummy( a ) values ( 1 )\n"
+        );
+
+        goodStatement
+        (
+         conn, 
+         "insert into t1_orders(price) values (1), (2)"
+        );
 
+        assertResults
+        ( 
+         conn,
+         "select a from t1_dummy",
+         new String[][]
+                      {
+                          { "1" },
+                          { "1" }
+                      },
+                      false
+         
+        );
+    }
 
     ///////////////////////////////////////////////////////////////////////////////////
     //
