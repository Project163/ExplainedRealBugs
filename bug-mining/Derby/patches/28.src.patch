diff --git a/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java b/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
index b53c99279..b93177084 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
@@ -305,6 +305,10 @@ public final class CurrentOfNode extends FromTable {
 
 		columnsTableName = columnReference.getTableNameNode();
 
+        if(columnsTableName != null)
+            if(columnsTableName.getSchemaName() == null && correlationName == null)
+                columnsTableName.bind(this.getDataDictionary());
+
 		if (SanityManager.DEBUG)
 		{
 			SanityManager.ASSERT(preStmt!=null, "must have prepared statement");
@@ -324,6 +328,10 @@ public final class CurrentOfNode extends FromTable {
 			SanityManager.ASSERT(baseTableName!=null,"no name on target table");
 		}
 
+        if(baseTableName != null)
+            if(baseTableName.getSchemaName() == null && correlationName == null)
+                baseTableName.bind(this.getDataDictionary());
+
 		/*
 		 * If the column did not specify a name, or the specified name
 		 * matches the table we're looking at, see whether the column
diff --git a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
index 405c2c6f2..9fc1eb4c1 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
@@ -2445,6 +2445,10 @@ public class FromBaseTable extends FromTable
 
 		columnsTableName = columnReference.getTableNameNode();
 
+        if(columnsTableName != null) {
+            if(columnsTableName.getSchemaName() == null && correlationName == null)
+                columnsTableName.bind(this.getDataDictionary());
+        }
 		/*
 		** If there is a correlation name, use that instead of the
 		** table name.
@@ -2458,6 +2462,8 @@ public class FromBaseTable extends FromTable
 			exposedTableName = tableName;
 		}
 
+        if(exposedTableName.getSchemaName() == null && correlationName == null)
+            exposedTableName.bind(this.getDataDictionary());
 		/*
 		** If the column did not specify a name, or the specified name
 		** matches the table we're looking at, see whether the column
@@ -3572,6 +3578,13 @@ public class FromBaseTable extends FromTable
 		TableName tn;
 
 		tn = super.getTableName();
+
+        if(tn != null) {
+            if(tn.getSchemaName() == null &&
+               correlationName == null)
+                   tn.bind(this.getDataDictionary());
+        }
+
 		return (tn != null ? tn : tableName);
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/dml162.out b/java/testing/org/apache/derbyTesting/functionTests/master/dml162.out
index f4ba59b8a..8019a7d29 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/dml162.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/dml162.out
@@ -18,7 +18,7 @@ ij> -- date_time print
    CREATE VIEW BLIVET (CITY, PNUM, EMPNUM, EMPNAME, GRADE,
       HOURS, PNAME, PTYPE, BUDGET) AS
 --0      HU.STAFF NATURAL JOIN HU.WORKS NATURAL JOIN HU.PROJ;
-	  SELECT PROJ.CITY, HU.PROJ.PNUM, HU.STAFF.EMPNUM, EMPNAME, GRADE, HOURS, PNAME, PTYPE, BUDGET
+	  SELECT HU.PROJ.CITY, HU.PROJ.PNUM, HU.STAFF.EMPNUM, EMPNAME, GRADE, HOURS, PNAME, PTYPE, BUDGET
       FROM HU.STAFF JOIN HU.WORKS ON (HU.STAFF.EMPNUM=HU.WORKS.EMPNUM) JOIN HU.PROJ ON (HU.PROJ.PNUM=HU.WORKS.PNUM AND HU.PROJ.CITY=HU.STAFF.CITY)
 	  ;
 0 rows inserted/updated/deleted
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
index 4ba1d5c7a..5c686ba2b 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
@@ -460,7 +460,7 @@ ERROR 42877: A qualified column name 'T3.C3' is not allowed in the ORDER BY clau
 ij> select c1 from t1 union select c3 from t3 order by asdf.c3;
 ERROR 42877: A qualified column name 'ASDF.C3' is not allowed in the ORDER BY clause.
 ij> select c1 from t1 order by sys.t1.c1;
-ERROR 42X10: 'SYS.T1' is not an exposed table name in the scope in which it appears.
+ERROR 42X04: Column 'SYS.T1.C1' is not in any table in the FROM list or it appears within a join specification and is outside the scope of the join specification or it appears in a HAVING clause and is not in the GROUP BY list.  If this is a CREATE or ALTER TABLE statement then 'SYS.T1.C1' is not a column in the target table.
 ij> select c1 from app.t1 order by sys.t1.c1;
 ERROR 42X04: Column 'SYS.T1.C1' is not in any table in the FROM list or it appears within a join specification and is outside the scope of the join specification or it appears in a HAVING clause and is not in the GROUP BY list.  If this is a CREATE or ALTER TABLE statement then 'SYS.T1.C1' is not a column in the target table.
 ij> select c1 from t1 c order by app.c.c1;
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/select.out b/java/testing/org/apache/derbyTesting/functionTests/master/select.out
index 5aa3e728e..215a25edb 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/select.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/select.out
@@ -179,4 +179,8 @@ ij> select * from "S1.T1" , APP."S1.T1";
 ERROR 42X09: The table or alias name 'APP.S1.T1' is used more than once in the FROM list.
 ij> select "S1.T1".d1 from "S1.T1", APP."S1.T1";
 ERROR 42X09: The table or alias name 'APP.S1.T1' is used more than once in the FROM list.
+ij> select SYS."S1.T1".d1 from "S1.T1";
+ERROR 42X04: Column 'SYS.S1.T1.D1' is not in any table in the FROM list or it appears within a join specification and is outside the scope of the join specification or it appears in a HAVING clause and is not in the GROUP BY list.  If this is a CREATE or ALTER TABLE statement then 'SYS.S1.T1.D1' is not a column in the target table.
+ij> select SYS."S1.T1".d1 from "S1.T1" t1;
+ERROR 42X04: Column 'SYS.S1.T1.D1' is not in any table in the FROM list or it appears within a join specification and is outside the scope of the join specification or it appears in a HAVING clause and is not in the GROUP BY list.  If this is a CREATE or ALTER TABLE statement then 'SYS.S1.T1.D1' is not a column in the target table.
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/select.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/select.sql
index 00ae394d9..bc1209a9d 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/select.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/select.sql
@@ -121,3 +121,7 @@ select "S1.T1".* from s1.t1;
 select * from "S1.T1" , APP."S1.T1";
 
 select "S1.T1".d1 from "S1.T1", APP."S1.T1";
+
+select SYS."S1.T1".d1 from "S1.T1";
+
+select SYS."S1.T1".d1 from "S1.T1" t1;
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml162.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml162.sql
index e8cbcc4ab..73bc13a22 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml162.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml162.sql
@@ -21,7 +21,7 @@ AUTOCOMMIT OFF;
    CREATE VIEW BLIVET (CITY, PNUM, EMPNUM, EMPNAME, GRADE,
       HOURS, PNAME, PTYPE, BUDGET) AS
 --0      HU.STAFF NATURAL JOIN HU.WORKS NATURAL JOIN HU.PROJ;
-	  SELECT PROJ.CITY, HU.PROJ.PNUM, HU.STAFF.EMPNUM, EMPNAME, GRADE, HOURS, PNAME, PTYPE, BUDGET
+	  SELECT HU.PROJ.CITY, HU.PROJ.PNUM, HU.STAFF.EMPNUM, EMPNAME, GRADE, HOURS, PNAME, PTYPE, BUDGET
       FROM HU.STAFF JOIN HU.WORKS ON (HU.STAFF.EMPNUM=HU.WORKS.EMPNUM) JOIN HU.PROJ ON (HU.PROJ.PNUM=HU.WORKS.PNUM AND HU.PROJ.CITY=HU.STAFF.CITY)
 	  ;
 -- PASS:0863 If view created successfully?
