diff --git a/java/drda/org/apache/derby/drda/NetworkServerControl.java b/java/drda/org/apache/derby/drda/NetworkServerControl.java
index 71f1cca0f..d2c771bf7 100644
--- a/java/drda/org/apache/derby/drda/NetworkServerControl.java
+++ b/java/drda/org/apache/derby/drda/NetworkServerControl.java
@@ -23,6 +23,7 @@ package org.apache.derby.drda;
 
 import java.io.PrintWriter;
 import java.net.InetAddress;
+import java.net.Inet6Address;
 import java.net.URL;
 import java.util.Properties;
 import org.apache.derby.iapi.reference.Property;
@@ -626,7 +627,9 @@ public class NetworkServerControl{
      * default server policy file. The special
      * wildcard valuse "0.0.0.0" and "::" are forced to be "*" since that is the wildcard
      * hostname understood by SocketPermission. SocketPermission does
-     * not understand the "0.0.0.0" and "::" wildcards.
+     * not understand the "0.0.0.0" and "::" wildcards. IPV6 addresses are
+     * enclosed in square brackets. This logic arose from two JIRAs:
+     * DERBY-2811 and DERBY-2874.
      */
     private static String  getHostNameForSocketPermission( NetworkServerControlImpl server )
         throws Exception
@@ -642,6 +645,8 @@ public class NetworkServerControl{
             IPV6_HOSTNAME_WILDCARD.equals( hostname ) 
             )
         { hostname = SOCKET_PERMISSION_HOSTNAME_WILDCARD; }
+        else if ( isIPV6Address( hostname ) )
+        { hostname = '[' + hostname + "]:0-"; }
 
         return hostname;
     }
@@ -658,6 +663,39 @@ public class NetworkServerControl{
         } catch (Exception e) { return false; }
     }
     
+    // return true if the host address is an IPV6 address
+    private static  boolean isIPV6Address( String hostname )
+    {
+        if ( hostname == null ) { return false; }
+
+        //
+        // First make sure that the address is composed entirely
+        // of hex digits and colons.
+        //
+        int         count = hostname.length();
+
+        for ( int i = 0; i < count; i++ )
+        {
+            char    currentChar = hostname.charAt( i );
+
+            if ( currentChar == ':' ) { continue; }
+            if ( Character.digit( currentChar, 16 ) >= 0 ) { continue; }
+
+            return false;
+        }
+
+        //
+        // OK, now see whether the address is parsed as an IPV6 address.
+        //
+        
+        try {
+            InetAddress address = InetAddress.getByName( hostname );
+
+            return (address instanceof Inet6Address);
+            
+        } catch (Exception e) { return false; }
+    }
+
     /**
      *<p>
      * Find the url of the library directory which holds derby.jar and
diff --git a/java/drda/org/apache/derby/drda/server.policy b/java/drda/org/apache/derby/drda/server.policy
index 5c3854523..1b11bf6ef 100644
--- a/java/drda/org/apache/derby/drda/server.policy
+++ b/java/drda/org/apache/derby/drda/server.policy
@@ -27,6 +27,6 @@ grant codeBase "${derby.install.url}derbynet.jar"
 //
 // This permission lets the Network Server manage connections from clients.
 //
-  permission java.net.SocketPermission "${derby.security.host}:*", "accept"; 
+  permission java.net.SocketPermission "${derby.security.host}", "accept"; 
 };
 
diff --git a/java/drda/org/apache/derby/drda/template.policy b/java/drda/org/apache/derby/drda/template.policy
index a13e4d8cb..736f06654 100644
--- a/java/drda/org/apache/derby/drda/template.policy
+++ b/java/drda/org/apache/derby/drda/template.policy
@@ -39,6 +39,6 @@ grant codeBase "${derby.install.url}derbynet.jar"
 //
 // This permission lets the Network Server manage connections from clients.
 //
-  permission java.net.SocketPermission "${derby.security.host}:*", "accept"; 
+  permission java.net.SocketPermission "${derby.security.host}", "accept"; 
 };
 
