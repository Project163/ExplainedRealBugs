diff --git a/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java b/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
index ef72ed6bb..b12be6ef4 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
@@ -233,6 +233,13 @@ public class OrderByColumn extends OrderedColumn {
 			}
 
 		}else{
+            if (list.isTableValueCtorOrdering()) {
+                // For VALUES, we only allow ordering by column number,
+                // SQL-92 style. This is a more general expression, so throw.
+                throw StandardException.newException(
+                        SQLState.LANG_TABLE_VALUE_CTOR_RESTRICTION);
+            }
+
 			/*checks for the conditions when using distinct*/
 			if (addedColumnOffset >= 0 &&
 					target instanceof SelectNode &&
diff --git a/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java b/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
index 25f5cdfb0..212af95fe 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
@@ -78,6 +78,25 @@ public class OrderByList extends OrderedColumnList
 	private boolean sortNeeded = true;
 	private int resultSetNumber = -1;
 
+    /**
+     * {@code true} if this instance orders a
+     * {@literal <table value constructor>}.
+     * See {@link #isTableValueCtorOrdering}.
+     */
+    private boolean isTableValueCtorOrdering;
+
+    /**
+     * Initialize with the type of the result set this {@code OrderByList} is
+     * attached to, e.g. {@code SELECT}, {@code VALUES} or a set operation.
+     * @param rs The result set this {@code OrderByList} is ordering.
+    */
+   public void init(Object rs) {
+        this.isTableValueCtorOrdering =
+                (rs instanceof UnionNode &&
+                ((UnionNode)rs).tableConstructor()) ||
+                rs instanceof RowResultSetNode;
+    }
+
 	/**
 		Add a column to the list
 	
@@ -846,4 +865,12 @@ public class OrderByList extends OrderedColumnList
 	public int getResultSetNumber() {
 		return resultSetNumber;
 	}
+
+    /**
+     * @return {@code true} if the {@code ORDER BY} is attached to a
+     * {@literal <table value constructor>}, i.e. a {@code VALUES} clause.
+     */
+    public boolean isTableValueCtorOrdering() {
+        return isTableValueCtorOrdering;
+    }
 }
diff --git a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
index 299a8ee19..aa5c88e0b 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
+++ b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
@@ -3435,7 +3435,7 @@ preparableSelectStatement(boolean checkParams) throws StandardException :
 }
 {
 	queryExpression = queryExpression(null, NO_SET_OP) 
-		[ orderCols = orderByClause() ]
+       [ orderCols = orderByClause(queryExpression) ]
         hasJDBClimitClause = offsetFetchFirstClause( offsetClauses )
 		[ <FOR> forUpdateState = forUpdateClause(updateColumns) ]
 		[ isolationLevel = atIsolationLevel() ]
@@ -5170,7 +5170,7 @@ nonJoinQueryPrimary() throws StandardException :
 |
     <LEFT_PAREN>
     primary = queryExpression(null, NO_SET_OP)
-    [ orderCols = orderByClause() ]
+    [ orderCols = orderByClause(primary) ]
     hasJDBClimitClause = offsetFetchFirstClause( offsetClauses )
 	<RIGHT_PAREN>
 	{
@@ -8291,12 +8291,12 @@ columnReference() throws StandardException :
 */
 
 OrderByList
-orderByClause() throws StandardException :
+orderByClause(ResultSetNode rs) throws StandardException :
 {
 	OrderByList orderCols;
 }
 {
-	<ORDER> <BY> orderCols = sortSpecificationList()
+   <ORDER> <BY> orderCols = sortSpecificationList(rs)
 	{
         forbidNextValueFor();
         
@@ -8318,10 +8318,11 @@ atIsolationLevel() throws StandardException :
 }
 
 OrderByList
-sortSpecificationList() throws StandardException :
+sortSpecificationList(ResultSetNode rs) throws StandardException :
 { 
 	OrderByList orderCols = (OrderByList) nodeFactory.getNode(
 											C_NodeTypes.ORDER_BY_LIST,
+                                           rs,
 											getContextManager()); 
 }
 {
@@ -8683,7 +8684,7 @@ insertColumnsAndSource(QueryTreeNode targetTable)
 	]
 	[ targetProperties = propertyList(false) <CHECK_PROPERTIES>]
 	queryExpression = queryExpression(null, NO_SET_OP)
-	[ orderCols = orderByClause() ]
+   [ orderCols = orderByClause(queryExpression) ]
     hasJDBClimitClause = offsetFetchFirstClause( offsetClauses )
 	{
 		if (orderCols != null && isTableValueConstructor(queryExpression)) {
@@ -8960,7 +8961,7 @@ subquery(int subqueryType, ValueNode leftOperand) throws StandardException :
 }
 {
 	queryExpression = queryExpression(null, NO_SET_OP)
-	[ orderCols = orderByClause() ]
+   [ orderCols = orderByClause(queryExpression) ]
     hasJDBClimitClause = offsetFetchFirstClause( offsetClauses )
 	{
 		subqueryNode = (SubqueryNode) nodeFactory.getNode(
@@ -9924,7 +9925,7 @@ overClause() throws StandardException :
   LOOKAHEAD({ getToken(2).kind == LEFT_PAREN ||
 			  getToken(2).kind == IDENTIFIER })
 	<OVER>
-  ( <LEFT_PAREN> [ orderCols = orderByClause() ] <RIGHT_PAREN>
+  ( <LEFT_PAREN> [ orderCols = orderByClause(null) ] <RIGHT_PAREN>
 	{
 		return (QueryTreeNode) nodeFactory.getNode(
 			C_NodeTypes.WINDOW_DEFINITION_NODE,
@@ -10258,7 +10259,7 @@ windowDefinition(WindowList wl) throws StandardException :
 {
 	windowName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
 	<AS>
-	<LEFT_PAREN> [ orderCols = orderByClause() ] <RIGHT_PAREN>
+   <LEFT_PAREN> [ orderCols = orderByClause(null) ] <RIGHT_PAREN>
 	{
 		wl.addWindow(
 			(WindowDefinitionNode)nodeFactory.getNode(
@@ -11280,7 +11281,7 @@ viewDefinition(Token beginToken) throws StandardException :
 	<VIEW> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
 		[ <LEFT_PAREN> resultColumns = viewColumnList() <RIGHT_PAREN> ]
 		<AS> queryExpression = queryExpression(null, NO_SET_OP)
-		[ orderCols = orderByClause() ]
+       [ orderCols = orderByClause(queryExpression) ]
         hasJDBClimitClause = offsetFetchFirstClause( offsetClauses )
 	{
 		checkOptionType = ViewDescriptor.NO_CHECK_OPTION;
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index a9cd81296..37d7bbb3f 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -1,4 +1,4 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <!DOCTYPE messages SYSTEM "messages.dtd">
 
 <!-- 
@@ -1469,6 +1469,11 @@ Guide.
                 <text>The ORDER BY clause may not specify an expression, since the query specifies DISTINCT.</text>
             </msg>
 
+            <msg>
+                <name>4287B</name>
+                <text>In this context, the ORDER BY clause may only specify a column number.</text>
+            </msg>
+
 
             <msg>
                 <name>42884</name>
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 998feb69f..d01a05cbd 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -898,6 +898,7 @@ public interface SQLState {
         String LANG_UNION_ORDER_BY                                         = "42878";
 	String LANG_DISTINCT_ORDER_BY                                      = "42879";
 	String LANG_DISTINCT_ORDER_BY_EXPRESSION                           = "4287A";
+    String LANG_TABLE_VALUE_CTOR_RESTRICTION                           = "4287B";
 	String LANG_EMPTY_VALUES_CLAUSE                                    = "42X80";
 	String LANG_EMPTY_COLUMN_LIST                                      = "42X81";
 	String LANG_USING_CARDINALITY_VIOLATION                            = "42X82";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
index 35b07da04..550ea8691 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/orderby.out
@@ -2320,5 +2320,30 @@ ij> drop table d3303;
 0 rows inserted/updated/deleted
 ij> -- See also Derby5005.java which should be merged with this test when
 -- it gets converted to JUnit.
-;
+
+-- DERBY-6009: forbid expression when using ORDER BY with VALUES
+values 1 order by 1+0;
+ERROR 4287B: In this context, the ORDER BY clause may only specify a column number.
+ij> values 1,2 order by 1+0;
+ERROR 4287B: In this context, the ORDER BY clause may only specify a column number.
+ij> (values 1 order by 1+0) union (values 1,2 order by 1);
+ERROR 4287B: In this context, the ORDER BY clause may only specify a column number.
+ij> -- OK:
+(values 1 order by 1) union (values 1,2 order by 1);
+1          
+-----------
+1          
+2          
+ij> values (1,-1),(3,-3),(2,-2) order by 1;
+1          |2          
+-----------------------
+1          |-1         
+2          |-2         
+3          |-3         
+ij> values (1,-1),(3,-3),(2,-2) order by 2;
+1          |2          
+-----------------------
+3          |-3         
+2          |-2         
+1          |-1         
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
index f4e60d5ea..623f399b1 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/orderby.sql
@@ -904,3 +904,13 @@ drop table d3303;
 
 -- See also Derby5005.java which should be merged with this test when
 -- it gets converted to JUnit.
+
+-- DERBY-6009: forbid expression when using ORDER BY with VALUES
+values 1 order by 1+0;
+values 1,2 order by 1+0;
+(values 1 order by 1+0) union (values 1,2 order by 1);
+-- OK:
+(values 1 order by 1) union (values 1,2 order by 1);
+values (1,-1),(3,-3),(2,-2) order by 1;
+values (1,-1),(3,-3),(2,-2) order by 2;
+
