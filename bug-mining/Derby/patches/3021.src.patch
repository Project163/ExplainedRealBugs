diff --git a/java/engine/org/apache/derby/impl/sql/compile/CreateIndexNode.java b/java/engine/org/apache/derby/impl/sql/compile/CreateIndexNode.java
index 120efb52e..c89e9d1ac 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/CreateIndexNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/CreateIndexNode.java
@@ -274,7 +274,8 @@ class CreateIndexNode extends DDLStatementNode
                     false, // it's not a UniqueWithDuplicateNulls Index
                     false, // it's not a constraint, so its checking
                            // is not deferrable
-                    false, // initialltDeferred: N/A
+                    false, // initiallyDeferred: N/A
+                    -1,    // constraintType: N/A
                     indexType,
                     sd.getSchemaName(),
                     indexName.getTableName(),
diff --git a/java/engine/org/apache/derby/impl/sql/compile/TableElementList.java b/java/engine/org/apache/derby/impl/sql/compile/TableElementList.java
index d8f1527cc..3e2381a94 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/TableElementList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/TableElementList.java
@@ -1061,12 +1061,8 @@ class TableElementList extends QueryTreeNodeVector<TableElementNode>
 					indexAction = genIndexAction(
 						forCreateTable,
 						constraintDN.requiresUniqueIndex(), false,
-                        cChars[0] &                     // deferrable ?
-                                (constraintType !=
-                                 DataDictionary.FOREIGNKEY_CONSTRAINT),
-                        cChars[1] &                     // initiallyDeferred ?
-                                (constraintType !=
-                                 DataDictionary.FOREIGNKEY_CONSTRAINT),
+                        cChars[0],
+                        cChars[1],
 						null, constraintDN,
 						columnNames, true, tableSd, tableName,
 						constraintType, dd);
@@ -1257,6 +1253,7 @@ class TableElementList extends QueryTreeNodeVector<TableElementNode>
                     isUniqueWithDuplicateNulls,
                     hasDeferrableChecking,
                     initiallyDeferred,
+                    constraintType,
                     "BTREE", // indexType
                     sd.getSchemaName(),
                     indexName,
diff --git a/java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java
index de59465f9..e9c83e155 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java
@@ -100,6 +100,13 @@ class CreateIndexConstantAction extends IndexConstantAction
      */
     private final boolean   initiallyDeferred;
 
+    /**
+     * The constraint type, see 
+     * {@link org.apache.derby.iapi.sql.dictionary.DataDictionary} 
+     * definition of constants.
+     */
+    private final int       constraintType;
+    
 	private String			indexType;
 	private String[]		columnNames;
 	private boolean[]		isAscending;
@@ -171,6 +178,7 @@ class CreateIndexConstantAction extends IndexConstantAction
             boolean			uniqueWithDuplicateNulls,
             boolean         hasDeferrableChecking,
             boolean         initiallyDeferred,
+            int             constraintType,
             String			indexType,
             String			schemaName,
             String			indexName,
@@ -189,6 +197,7 @@ class CreateIndexConstantAction extends IndexConstantAction
 		this.uniqueWithDuplicateNulls   = uniqueWithDuplicateNulls;
         this.hasDeferrableChecking      = hasDeferrableChecking;
         this.initiallyDeferred          = initiallyDeferred;
+        this.constraintType             = constraintType;
         this.uniqueDeferrable           = unique && hasDeferrableChecking;
 		this.indexType                  = indexType;
 		this.columnNames                = columnNames;
@@ -243,6 +252,7 @@ class CreateIndexConstantAction extends IndexConstantAction
         this.hasDeferrableChecking = false; // N/A such indexes are not shared
         this.uniqueDeferrable = false;      // N/A
         this.initiallyDeferred = false;     // N/A
+        this.constraintType = -1;           // N/A
 		this.indexType = irg.indexType();
 		this.columnNames = srcCD.getColumnNames();
 		this.isAscending = irg.isAscending();
@@ -661,14 +671,15 @@ class CreateIndexConstantAction extends IndexConstantAction
             if (dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, null))
             {
                 indexRowGenerator = new IndexRowGenerator(
-                                            indexType, 
-                                            unique, 
-                                            uniqueWithDuplicateNulls,
-                                            uniqueDeferrable,
-                                            hasDeferrableChecking,
-                                            baseColumnPositions,
-                                            isAscending,
-                                            baseColumnPositions.length);
+                        indexType, 
+                        unique, 
+                        uniqueWithDuplicateNulls,
+                        uniqueDeferrable,
+                        (hasDeferrableChecking && 
+                         constraintType != DataDictionary.FOREIGNKEY_CONSTRAINT),
+                        baseColumnPositions,
+                        isAscending,
+                        baseColumnPositions.length);
 			}
 			else 
             {
@@ -857,7 +868,8 @@ class CreateIndexConstantAction extends IndexConstantAction
                             lcc,
                             DeferredConstraintsMemory.UNDEFINED_CONGLOMERATE,
                             true,
-                            hasDeferrableChecking,
+                            (hasDeferrableChecking && 
+                            constraintType != DataDictionary.FOREIGNKEY_CONSTRAINT),
                             initiallyDeferred,
                             indexOrConstraintName,
                             indexTemplateRow,
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DDLSingleTableConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/DDLSingleTableConstantAction.java
index c25b90ed6..d336a90e3 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DDLSingleTableConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DDLSingleTableConstantAction.java
@@ -310,6 +310,7 @@ abstract class DDLSingleTableConstantAction extends DDLConstantAction
                         false,          // deferred or not: shouldn't matter
                                         // since we know we already have a
                                         // unique index
+                        DataDictionary.UNIQUE_CONSTRAINT,
                         cd.getIndexDescriptor().indexType(), 
                         td.getSchemaName(), 
                         cd.getConglomerateName(), td.getName(), td.getUUID(),
diff --git a/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java b/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
index ccb837631..a9e9f1c3c 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
@@ -230,6 +230,7 @@ public class GenericConstantActionFactory
      *                              deferrable constraint
      * @param initiallyDeferred  True means the deferrable constraint has
      *                           deferred mode initially.
+     * @param constraintType  The constraint type
      * @param indexType	The type of index (BTREE, for example)
      * @param schemaName			the schema that table (and index) lives in.
      * @param indexName	Name of the index
@@ -248,6 +249,7 @@ public class GenericConstantActionFactory
 		boolean			uniqueWithDuplicateNulls,
         boolean         hasDeferrableChecking,
         boolean         initiallyDeferred,
+        int             constraintType,
 		String			indexType,
 		String			schemaName,
 		String			indexName,
@@ -266,6 +268,7 @@ public class GenericConstantActionFactory
             uniqueWithDuplicateNulls,
             hasDeferrableChecking,
             initiallyDeferred,
+            constraintType,
             indexType,
             schemaName,
             indexName,
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
index c1de669ef..264bbdb2f 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java
@@ -75,6 +75,8 @@ import static org.apache.derbyTesting.junit.TestConfiguration.embeddedSuite;
  */
 public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
 {
+    private static final String  LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T
+                                                                    = "23506";
     private static final String  LANG_DEFERRED_FK_CONSTRAINT_T = "23516";
     private static final String  LANG_DEFERRED_FK_CONSTRAINT_S = "23517";
     private static final String  LANG_ADD_FK_CONSTRAINT_VIOLATION = "X0Y45";
@@ -1247,4 +1249,63 @@ public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
              );
     }
     
+    /**
+     * Regression test case for DERBY-6665. The prevention of shared physical
+     * conglomerates in the presence of the deferrable constraint
+     * characteristic failed for foreign keys sometimes.  This sometimes made
+     * the deferred check of constraints miss violations if two deferred
+     * constraints erroneously shared a physical conglomerate.
+     */
+    public void testSharedConglomerates() throws SQLException {
+        setAutoCommit(false);
+        Statement s = createStatement();
+        s.execute("create table d6665_t1(x int primary key)");
+        s.execute("create table d6665_t2(x int primary key)");
+
+        // Create a table with two foreign keys - they would share one
+        // conglomerate since they are declared on the same column and the hole
+        // in the sharing avoidance logic.
+        s.execute("create table d6665_t3(x int "
+                + "references d6665_t1 initially deferred "
+                + "references d6665_t2 initially deferred)");
+
+        s.execute("insert into d6665_t1 values 1");
+
+        // This violates the second foreign key, since T2 doesn't contain 1.
+        // No error here since the constraint is deferred.
+        s.execute("insert into d6665_t3 values 1");
+
+        // Now we're no longer violating the foreign key.
+        s.execute("insert into d6665_t2 values 1");
+
+        // Introduce a violation of the first foreign key. No error because
+        // the checking is deferred.
+        s.execute("delete from d6665_t1");
+
+        // Commit. Should fail because of the violation introduced by the
+        // delete statement above. Was not detected before DERBY-6665.
+        assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
+
+        // Another example: A PRIMARY KEY constraint and a FOREIGN KEY
+        // constraint erroneously share a conglomerate.
+
+        s.execute("create table d6665_t4(x int primary key)");
+        s.execute("create table d6665_t5(x int "
+                + "primary key initially deferred "
+                + "references d6665_t4 initially deferred)");
+
+        // First violate the foreign key. No error, since it is deferred.
+        s.execute("insert into d6665_t5 values 1");
+
+        // No longer in violation of the foreign key after this statement.
+        s.execute("insert into d6665_t4 values 1");
+
+        // Violate the PRIMARY KEY constraint on T5.X.
+        s.execute("insert into d6665_t5 values 1");
+
+        // Commit. Should fail because the PRIMARY KEY constraint of T5
+        // is violated. Was not detected before DERBY-6665.
+        assertCommitError(LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T,
+                          getConnection());
+    }
 }
