diff --git a/java/engine/org/apache/derby/iapi/types/JSQLType.java b/java/engine/org/apache/derby/iapi/types/JSQLType.java
index 590700c08..93cd9beb8 100644
--- a/java/engine/org/apache/derby/iapi/types/JSQLType.java
+++ b/java/engine/org/apache/derby/iapi/types/JSQLType.java
@@ -327,7 +327,7 @@ public final class JSQLType implements Formatable
 	  *
 	  *	@return	name of the java wrapper class corresponding to the primitive
 	  */
-	private	static String	getWrapperClassName
+	public	static String	getWrapperClassName
 	(
 		byte	primitive
     )
@@ -345,7 +345,7 @@ public final class JSQLType implements Formatable
 	  *	@return	BOOLEAN, INT, ... etc if the name is that of a primitive.
 	  *			NOT_PRIMITIVE otherwise
 	  */
-	private	static byte	getPrimitiveID
+	public	static byte	getPrimitiveID
 	(
 		String	name
     )
diff --git a/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java b/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
index 1c34d9dcf..8dd3bdc43 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
@@ -33,6 +33,7 @@ import org.apache.derby.catalog.types.TypeDescriptorImpl;
 import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.services.classfile.VMOpcode;
 import org.apache.derby.iapi.services.compiler.LocalField;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.context.ContextManager;
@@ -578,11 +579,38 @@ abstract class MethodCallNode extends JavaValueNode
 
         if (!parameterType.equals(argumentType))
         {
+            //
+            // This handles the conversion from primitive to wrapper type. See DERBY-6511.
+            // If the parameter type is the wrapper form of the primitive argument type,
+            // then call the "valueOf" static method of the wrapper type in order to convert
+            // the argument into a wrapper object. So, for instance, this converts a primitive "int"
+            // into a "java.lang.Integer".
+            //
+            if (
+                ClassInspector.primitiveType( argumentType ) &&
+                parameterType.equals( JSQLType.getWrapperClassName( JSQLType.getPrimitiveID( argumentType ) ) )
+                )
+            {
+                // short must be converted to int
+                if ( "short".equals( argumentType ) )
+                {
+                    mb.cast( "int" );
+                }
+                
+                mb.callMethod
+                    (
+                     VMOpcode.INVOKESTATIC,
+                     parameterType,
+                     "valueOf",
+                     parameterType,
+                     1
+                     );
+            }
             // since we reached here through method resolution
             // casts are only required for primitive types.
             // In any other case the expression type must be assignable
             // to the parameter type.
-            if (ClassInspector.primitiveType(parameterType))
+            else if (ClassInspector.primitiveType(parameterType))
             {
                 mb.cast(parameterType);
             } else
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsHelper.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsHelper.java
index 773b8796d..a8935aabb 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsHelper.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GeneratedColumnsHelper.java
@@ -271,58 +271,6 @@ public class GeneratedColumnsHelper extends BaseJDBCTestCase
         ps.close();
     }
         
-    /**
-     * Assert that the statement returns the correct results.
-     */
-    protected void assertResults( Connection conn, String query, String[][] rows, boolean trimResults )
-        throws Exception
-    {
-        PreparedStatement   ps = chattyPrepare( conn, query );
-        ResultSet                   rs = ps.executeQuery();
-
-        assertResults( rs, rows, trimResults );
-
-        rs.close();
-        ps.close();
-    }
-        
-    /**
-     * Assert that the ResultSet returns the desired rows.
-     */
-    protected void assertResults( ResultSet rs, String[][] rows, boolean trimResults )
-        throws Exception
-    {
-        int     rowCount = rows.length;
-
-        for ( int i = 0; i < rowCount; i++ )
-        {
-            String[]    row = rows[ i ];
-            int             columnCount = row.length;
-
-            assertTrue( rs.next() );
-
-            for ( int j = 0; j < columnCount; j++ )
-            {
-                String  expectedValue =  row[ j ];
-                //println( "(row, column ) ( " + i + ", " +  j + " ) should be " + expectedValue );
-                String  actualValue = null;
-                int         column = j+1;
-
-                actualValue = rs.getString( column );
-                if ( rs.wasNull() ) { actualValue = null; }
-
-                if ( (actualValue != null) && trimResults ) { actualValue = actualValue.trim(); }
-                
-                assertEquals( (expectedValue == null), rs.wasNull() );
-                
-                if ( expectedValue == null )    { assertNull( actualValue ); }
-                else { assertEquals(expectedValue, actualValue); }
-            }
-        }
-
-        assertFalse( rs.next() );
-    }
-
     /**
      * Test that a privilege can't be revoked if an object depends on it.
      */
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/RoutineTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/RoutineTest.java
index 676c88222..93c8f4211 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/RoutineTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/RoutineTest.java
@@ -23,6 +23,7 @@ package org.apache.derbyTesting.functionTests.tests.lang;
 
 import java.io.UnsupportedEncodingException;
 import java.sql.CallableStatement;
+import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -685,7 +686,87 @@ public class RoutineTest extends BaseJDBCTestCase {
         }
     }
 
+    /**
+     * DERBY-6511: Make sure that conversions between primitive and wrapper
+     * types work properly.
+     */
+    public void test_6511() throws Exception
+    {
+        Connection  conn = getConnection();
+
+        vet_6511( conn, "boolean", "booleanpToBoolean", "booleanToBooleanp", "true" );
+        vet_6511( conn, "int", "intToInteger", "integerToInt", "1" );
+        vet_6511( conn, "bigint", "longpToLong", "longToLongp", "1" );
+        vet_6511( conn, "smallint", "shortpToInteger", "integerToShortp", "1" );
+        vet_6511( conn, "double", "doublepToDouble", "doubleToDoublep", "1.0" );
+        vet_6511( conn, "real", "floatpToFloat", "floatToFloatp", "1.0" );
+    }
+    private void    vet_6511
+        (
+         Connection conn,
+         String sqlDatatype,
+         String primitiveToWrapperName,
+         String wrapperToPrimitiveName,
+         String dataValue
+         )
+        throws Exception
+    {
+        createFunction_6511( conn, sqlDatatype, primitiveToWrapperName );
+        createFunction_6511( conn, sqlDatatype, wrapperToPrimitiveName );
+
+        vetChaining_6511( conn, primitiveToWrapperName, primitiveToWrapperName, dataValue );
+        vetChaining_6511( conn, primitiveToWrapperName, wrapperToPrimitiveName, dataValue );
+        vetChaining_6511( conn, wrapperToPrimitiveName, primitiveToWrapperName, dataValue );
+        vetChaining_6511( conn, wrapperToPrimitiveName, wrapperToPrimitiveName, dataValue );
 
+        dropFunction_6511( conn, primitiveToWrapperName );
+        dropFunction_6511( conn, wrapperToPrimitiveName );
+    }
+    private void    createFunction_6511
+        (
+         Connection conn,
+         String sqlDatatype,
+         String functionName
+         )
+        throws Exception
+    {
+        goodStatement
+            (
+             conn,
+             "create function " + functionName + "( val " + sqlDatatype + " ) returns " + sqlDatatype + "\n" +
+             "language java parameter style java deterministic no sql\n" +
+             "external name '" + getClass().getName() + "." + functionName + "'"
+             );
+    }
+    private void    dropFunction_6511
+        (
+         Connection conn,
+         String functionName
+         )
+        throws Exception
+    {
+        goodStatement( conn, "drop function " + functionName );
+    }
+    private void    vetChaining_6511
+        (
+         Connection conn,
+         String innerFunctionName,
+         String outerFunctionName,
+         String dataValue
+         )
+        throws Exception
+    {
+        assertResults
+            (
+             conn,
+             "values " + outerFunctionName + "( " + innerFunctionName + "( " + dataValue + " ) )",
+             new String[][]
+             {
+                 { dataValue },
+             },
+             false
+             );
+    }
 
 
     /*
@@ -738,5 +819,67 @@ public class RoutineTest extends BaseJDBCTestCase {
 
     public static void p5749 (String s) {
     }
+
+    // functions for converting between primitive and wrapper types
+    public  static  Boolean booleanpToBoolean( boolean val )
+    {
+        return new Boolean( val );
+    }
+    public  static  boolean booleanToBooleanp( Boolean val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.booleanValue(); }
+    }
+    
+    public  static  Integer intToInteger( int val )
+    {
+        return new Integer( val );
+    }
+    public  static  int     integerToInt( Integer val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.intValue(); }
+    }
+    
+    public  static  Long    longpToLong( long val )
+    {
+        return new Long( val );
+    }
+    public  static  long     longToLongp( Long val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.longValue(); }
+    }
+    
+    public  static  Integer    shortpToInteger( short val )
+    {
+        return new Integer( val );
+    }
+    public  static  short     integerToShortp( Integer val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.shortValue(); }
+    }
+    
+    public  static  Float floatpToFloat( float val )
+    {
+        return new Float( val );
+    }
+    public  static  float     floatToFloatp( Float val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.floatValue(); }
+    }
+    
+    public  static  Double doublepToDouble( double val )
+    {
+        return new Double( val );
+    }
+    public  static  double     doubleToDoublep( Double val ) throws Exception
+    {
+        if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
+        else { return val.doubleValue(); }
+    }
+    
 }
 
diff --git a/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java b/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
index a686cb70c..f715d6a93 100644
--- a/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
+++ b/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
@@ -1693,6 +1693,58 @@ public abstract class BaseJDBCTestCase
         assertEquals( expectedRowCount, actualRowCount );
     }
     
+    /**
+     * Assert that the statement returns the correct results.
+     */
+    protected void assertResults( Connection conn, String query, String[][] rows, boolean trimResults )
+        throws Exception
+    {
+        PreparedStatement   ps = chattyPrepare( conn, query );
+        ResultSet                   rs = ps.executeQuery();
+
+        assertResults( rs, rows, trimResults );
+
+        rs.close();
+        ps.close();
+    }
+        
+    /**
+     * Assert that the ResultSet returns the desired rows.
+     */
+    protected void assertResults( ResultSet rs, String[][] rows, boolean trimResults )
+        throws Exception
+    {
+        int     rowCount = rows.length;
+
+        for ( int i = 0; i < rowCount; i++ )
+        {
+            String[]    row = rows[ i ];
+            int             columnCount = row.length;
+
+            assertTrue( rs.next() );
+
+            for ( int j = 0; j < columnCount; j++ )
+            {
+                String  expectedValue =  row[ j ];
+                //println( "(row, column ) ( " + i + ", " +  j + " ) should be " + expectedValue );
+                String  actualValue = null;
+                int         column = j+1;
+
+                actualValue = rs.getString( column );
+                if ( rs.wasNull() ) { actualValue = null; }
+
+                if ( (actualValue != null) && trimResults ) { actualValue = actualValue.trim(); }
+                
+                assertEquals( (expectedValue == null), rs.wasNull() );
+                
+                if ( expectedValue == null )    { assertNull( actualValue ); }
+                else { assertEquals(expectedValue, actualValue); }
+            }
+        }
+
+        assertFalse( rs.next() );
+    }
+
 	protected	static	ResultSet	executeQuery( Statement stmt, String text )
 		throws SQLException
 	{
