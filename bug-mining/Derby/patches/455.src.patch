diff --git a/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java b/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
index 419288e32..2c7ce3d5b 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/CurrentOfNode.java
@@ -347,6 +347,16 @@ public final class CurrentOfNode extends FromTable {
 
 			if (resultColumn != null) 
 			{
+				// If we found the ResultColumn, set the ColumnReference's
+				// table number accordingly.  Note: we used to only set
+				// the tableNumber for correlated references (as part of
+				// changes for DERBY-171) but inspection of code (esp.
+				// the comments in FromList.bindColumnReferences() and
+				// the getMatchingColumn() methods on other FromTables)
+				// suggests that we should always set the table number
+				// if we've found the ResultColumn.  So we do that here.
+				columnReference.setTableNumber( tableNumber );
+
 				// If there is a result column, are we really updating it?
 				// If so, verify that the column is updatable as well
 				notfound = 
@@ -368,15 +378,6 @@ public final class CurrentOfNode extends FromTable {
 			}
 		}
 
-		/*
-		 * Patch up the table number for correlated references.
-		 * Part of the fix for bug 171.
-		 */
-		if ( (correlationName != null) && (columnReference.getTableNumber() < 0) )
-		{
-			columnReference.setTableNumber( tableNumber );
-		}
-		
 		return resultColumn;
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/update.out b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
index 95138cb84..9c008fcff 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/update.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
@@ -518,4 +518,51 @@ drop table bug171_employee;
 0 rows inserted/updated/deleted
 ij> drop table bug171_bonuses;
 0 rows inserted/updated/deleted
+ij> --
+-- DERBY-1329: Correlated subquery in UPDATE ... SET ... WHERE CURRENT OF
+--
+CREATE TABLE BASICTABLE1(ID INTEGER, C3 CHAR(10));
+0 rows inserted/updated/deleted
+ij> CREATE TABLE BASICTABLE2(IID INTEGER, CC3 CHAR(10));
+0 rows inserted/updated/deleted
+ij> insert into BASICTABLE1 (C3, ID) values ('abc', 1);
+1 row inserted/updated/deleted
+ij> insert into BASICTABLE2 (CC3, IID) values ('def', 1);
+1 row inserted/updated/deleted
+ij> -- Check data.
+select * from BASICTABLE1;
+ID         |C3        
+----------------------
+1          |abc       
+ij> select * from BASICTABLE2;
+IID        |CC3       
+----------------------
+1          |def       
+ij> autocommit off;
+ij> get cursor c1 as 'select c3, id from basictable1 for update';
+ij> next c1;
+C3        |ID         
+----------------------
+abc       |1          
+ij> -- Before fix for DERBY-1329 the following statement would fail with
+-- an ASSERT failure or an IndexOutOfBoundsException; after the fix
+-- the statement should succeed and the update as well.
+update BASICTABLE1 set C3 = (SELECT CC3 FROM BASICTABLE2
+  WHERE BASICTABLE1.ID=BASICTABLE2.IID) where current of c1;
+1 row inserted/updated/deleted
+ij> -- Check data; BASICTABLE1 should have been updated.
+select * from BASICTABLE1;
+ID         |C3        
+----------------------
+1          |def       
+ij> select * from BASICTABLE2;
+IID        |CC3       
+----------------------
+1          |def       
+ij> -- Cleanup.
+rollback;
+ij> drop table BASICTABLE1;
+0 rows inserted/updated/deleted
+ij> drop table BASICTABLE2;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
index 9a45ebbcd..a647b08e5 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
@@ -310,3 +310,34 @@ autocommit on;
 
 drop table bug171_employee;
 drop table bug171_bonuses;
+
+--
+-- DERBY-1329: Correlated subquery in UPDATE ... SET ... WHERE CURRENT OF
+--
+CREATE TABLE BASICTABLE1(ID INTEGER, C3 CHAR(10));
+CREATE TABLE BASICTABLE2(IID INTEGER, CC3 CHAR(10));
+insert into BASICTABLE1 (C3, ID) values ('abc', 1);
+insert into BASICTABLE2 (CC3, IID) values ('def', 1);
+
+-- Check data.
+select * from BASICTABLE1;
+select * from BASICTABLE2;
+
+autocommit off;
+get cursor c1 as 'select c3, id from basictable1 for update';
+next c1;
+
+-- Before fix for DERBY-1329 the following statement would fail with
+-- an ASSERT failure or an IndexOutOfBoundsException; after the fix
+-- the statement should succeed and the update as well.
+update BASICTABLE1 set C3 = (SELECT CC3 FROM BASICTABLE2
+  WHERE BASICTABLE1.ID=BASICTABLE2.IID) where current of c1;
+
+-- Check data; BASICTABLE1 should have been updated.
+select * from BASICTABLE1;
+select * from BASICTABLE2;
+
+-- Cleanup.
+rollback;
+drop table BASICTABLE1;
+drop table BASICTABLE2;
