diff --git a/java/build/org/apache/derbyBuild/splitmessages.java b/java/build/org/apache/derbyBuild/splitmessages.java
index 00b41cb7a..0abcf809b 100644
--- a/java/build/org/apache/derbyBuild/splitmessages.java
+++ b/java/build/org/apache/derbyBuild/splitmessages.java
@@ -97,7 +97,6 @@ public class splitmessages {
         clientMessageIds.add(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY);
         clientMessageIds.add(SQLState.CANCEL_NOT_SUPPORTED_BY_SERVER);
         clientMessageIds.add(SQLState.LANG_INVALID_CALL_STATEMENT);
-        clientMessageIds.add(SQLState.LOSS_OF_PRECISION_EXCEPTION);
         clientMessageIds.add(SQLState.LANG_INVALID_SQL_IN_BATCH);
         clientMessageIds.add(SQLState.LANG_RESULT_SET_NOT_OPEN);
         clientMessageIds.add(SQLState.CANT_CONVERT_UNICODE_TO_EBCDIC);
diff --git a/java/client/org/apache/derby/client/am/CrossConverters.java b/java/client/org/apache/derby/client/am/CrossConverters.java
index 4babad9f3..2e75b732e 100644
--- a/java/client/org/apache/derby/client/am/CrossConverters.java
+++ b/java/client/org/apache/derby/client/am/CrossConverters.java
@@ -191,7 +191,8 @@ final class CrossConverters {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
@@ -285,14 +286,16 @@ final class CrossConverters {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
@@ -331,21 +334,24 @@ final class CrossConverters {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Long.MAX_VALUE || source < Long.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long((long) source);
 
@@ -362,7 +368,8 @@ final class CrossConverters {
                     //           |                          |________________________
                     //-----------------------------------------------------------------------------------
                     (source == Float.POSITIVE_INFINITY || source == Float.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float(source);
 
@@ -377,7 +384,8 @@ final class CrossConverters {
                     //            |                          |________________________
                     //-------------------------------------------------------------------------------------
                     (source == Double.POSITIVE_INFINITY || source == Double.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             // source passed in is a float, do we need to check if the source already contains "infinity"??
             return new Double(String.valueOf(source));
@@ -410,28 +418,32 @@ final class CrossConverters {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Long.MAX_VALUE || source < Long.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long((long) source);
 
         case Types.REAL:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Float.MAX_VALUE || source < -Float.MAX_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float((float) source);
 
@@ -448,7 +460,8 @@ final class CrossConverters {
                     //            |                          |________________________
                     //-------------------------------------------------------------------------------------
                     (source == Double.POSITIVE_INFINITY || source == Double.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             return new Double(source);
 
@@ -478,35 +491,40 @@ final class CrossConverters {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxShortValue__) == 1 || source.compareTo(bdMinShortValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short(source.shortValue());
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxIntValue__) == 1 || source.compareTo(bdMinIntValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer(source.intValue());
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxLongValue__) == 1 || source.compareTo(bdMinLongValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long(source.longValue());
 
         case Types.REAL:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxFloatValue__) == 1 || source.compareTo(bdMinFloatValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float(source.floatValue());
 
         case Types.DOUBLE:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxDoubleValue__) == 1 || source.compareTo(bdMinDoubleValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             return new Double(source.doubleValue());
 
@@ -1000,7 +1018,8 @@ final class CrossConverters {
     final byte getByteFromShort(short source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1009,7 +1028,8 @@ final class CrossConverters {
     final byte getByteFromInt(int source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1018,7 +1038,8 @@ final class CrossConverters {
     final byte getByteFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1027,7 +1048,8 @@ final class CrossConverters {
     final byte getByteFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1036,7 +1058,8 @@ final class CrossConverters {
     final byte getByteFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1061,7 +1084,8 @@ final class CrossConverters {
     final short getShortFromInt(int source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1070,7 +1094,8 @@ final class CrossConverters {
     final short getShortFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1079,7 +1104,8 @@ final class CrossConverters {
     final short getShortFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1088,7 +1114,8 @@ final class CrossConverters {
     final short getShortFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1114,7 +1141,8 @@ final class CrossConverters {
     final int getIntFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1123,7 +1151,8 @@ final class CrossConverters {
     final int getIntFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1132,7 +1161,8 @@ final class CrossConverters {
     final int getIntFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1157,7 +1187,8 @@ final class CrossConverters {
     final long getLongFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Long.MAX_VALUE || source < java.lang.Long.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "BIGINT");
         }
 
         return (long) source;
@@ -1166,7 +1197,8 @@ final class CrossConverters {
     final long getLongFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Long.MAX_VALUE || source < java.lang.Long.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "BIGINT");
         }
 
         return (long) source;
@@ -1191,7 +1223,8 @@ final class CrossConverters {
     final float getFloatFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 Float.isInfinite((float)source)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "DOUBLE");
         }
 
         return (float) source;
diff --git a/java/client/org/apache/derby/client/am/SqlException.java b/java/client/org/apache/derby/client/am/SqlException.java
index 93900d943..773f35833 100644
--- a/java/client/org/apache/derby/client/am/SqlException.java
+++ b/java/client/org/apache/derby/client/am/SqlException.java
@@ -536,9 +536,10 @@ class ColumnTypeConversionException extends SqlException {
 // An intermediate exception encapsulation to provide code-reuse
 // for common CrossConverters data conversion exceptions.
 
-class LossOfPrecisionConversionException extends SqlException {
-    LossOfPrecisionConversionException(LogWriter logWriter, String instance) {
-        super(logWriter, new ClientMessageId(SQLState.LOSS_OF_PRECISION_EXCEPTION), 
-            instance);
+class OutsideRangeForDataTypeException extends SqlException {
+    OutsideRangeForDataTypeException(LogWriter logWriter, String instance) {
+        super(logWriter,
+              new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE), 
+              instance);
     }
 }
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index a761f18ab..b5ee6226d 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -739,12 +739,6 @@ Guide.
                 <arg>fromString</arg>
             </msg>
 
-            <msg>
-                <name>22015.S.1</name>
-                <text> Invalid data conversion: requested conversion would result in a loss of precision of {0}</text>
-                <arg>value</arg>
-            </msg>
-
             <msg>
                 <name>22015</name>
                 <text>The '{0}' function is not allowed on the following set of types.  First operand is of type '{1}'.  Second operand is of type '{2}'.  Third operand (start position) is of type '{3}'.</text>
diff --git a/java/engine/org/apache/derby/loc/messages_de_DE.properties b/java/engine/org/apache/derby/loc/messages_de_DE.properties
index 7c2967c18..c2f339e6e 100644
--- a/java/engine/org/apache/derby/loc/messages_de_DE.properties
+++ b/java/engine/org/apache/derby/loc/messages_de_DE.properties
@@ -122,7 +122,6 @@
 22011.S.1=Der Bereich f\u00FCr die Unterzeichenkette mit der relativen Position {0} und der L\u00E4nge {1} liegt au\u00DFerhalb des g\u00FCltigen Bereichs f\u00FCr die Zeichenkette: {2}.
 22013=Es wurde versucht, die Quadratwurzel einer negativen Zahl (''{0}'') zu ziehen.
 22014=Die Anfangsposition f\u00FCr LOCATE ist ung\u00FCltig. Sie muss eine positive ganze Zahl sein. Der Index, bei dem die Suche beginnen soll, ist ''{2}''. Zu suchende Zeichenfolge\: ''{0}''. Die Zeichenfolge, bei der die Suche beginnen soll, ist ''{1}''. 
-22015.S.1=Ung\u00FCltige Datenkonvertierung. Bei der angeforderten Konvertierung w\u00FCrde einen Genauigkeitsverlust von {0} nach sich ziehen.
 22015=Die Funktion ''{0}'' ist f\u00FCr die folgenden Typen unzul\u00E4ssig. Der erste Operand ist vom Typ ''{1}''.  Der zweite Operand ist vom Typ ''{2}''. Der dritte Operand (Anfangsposition) ist vom Typ ''{3}''.
 22018=Ung\u00FCltiges Zeichenfolgenformat f\u00FCr den Typ {0}
 22019=Die Escape-Zeichenfolge ''{0}'' ist ung\u00FCltig. Die Escape-Zeichenfolge muss aus genau einem Zeichen bestehen. Sie muss ungleich null sein und darf nicht mehr als ein Zeichen enthalten.
diff --git a/java/engine/org/apache/derby/loc/messages_es.properties b/java/engine/org/apache/derby/loc/messages_es.properties
index 1486cd75a..93f31783f 100644
--- a/java/engine/org/apache/derby/loc/messages_es.properties
+++ b/java/engine/org/apache/derby/loc/messages_es.properties
@@ -122,7 +122,6 @@
 22012=Intento de divisi\u00F3n por cero.
 22013=Intento de calcular la ra\u00EDz cuadrada de un n\u00FAmero negativo, ''{0}''.
 22014=La posici\u00F3n inicial de LOCATE no es v\u00E1lida; debe ser un entero positivo. El \u00EDndice desde el que comenzar la b\u00FAsqueda es ''{2}''.  La serie a buscar es ''{0}''.  La serie desde la que buscar es ''{1}''. 
-22015.S.1=Conversi\u00F3n de datos no v\u00E1lida\: la conversi\u00F3n solicitada producir\u00EDa una p\u00E9rdida de precisi\u00F3n de {0}
 22015=La funci\u00F3n ''{0}'' no est\u00E1 permitida en el siguiente conjunto de tipos.  El primer operando es de tipo ''{1}''.  El segundo operando es de tipo ''{2}''.  El tercer operando (posici\u00F3n inicial) es de tipo ''{3}''.
 22018=Formato de serie de caracteres no v\u00E1lido para tipo {0}.
 22019=Secuencia de escape no v\u00E1lida, ''{0}''. La serie de escape debe contener exactamente un car\u00E1cter. No puede ser nula o contener m\u00E1s de un car\u00E1cter.
diff --git a/java/engine/org/apache/derby/loc/messages_fr.properties b/java/engine/org/apache/derby/loc/messages_fr.properties
index fa26f2aca..235264206 100644
--- a/java/engine/org/apache/derby/loc/messages_fr.properties
+++ b/java/engine/org/apache/derby/loc/messages_fr.properties
@@ -122,7 +122,6 @@
 22012=Tentative de division par z\u00E9ro.
 22013=Tentative d''extraction de la racine carr\u00E9e d''un nombre n\u00E9gatif, ''{0}''.
 22014=La position de d\u00E9but pour LOCATE est incorrecte ; cette valeur doit \u00EAtre un entier positif. L''index \u00E0 partir duquel la recherche doit commencer est ''{2}''.  La cha\u00EEne \u00E0 rechercher est ''{0}''.  La cha\u00EEne dans laquelle effectuer la recherche est ''{1}''. 
-22015.S.1=Conversion de donn\u00E9es incorrecte \: la conversion requise entra\u00EEnerait une perte de pr\u00E9cision de {0}
 22015=La fonction ''{0}'' n''est pas autoris\u00E9e sur l''ensemble de types suivant.  Le premier op\u00E9rande est de type ''{1}''.  Le deuxi\u00E8me op\u00E9rande est de type ''{2}''.  Le troisi\u00E8me op\u00E9rande (position de d\u00E9but) est de type ''{3}''.
 22018=Le format de la cha\u00EEne de caract\u00E8res n''est pas valide pour le type {0}.
 22019=S\u00E9quence d''\u00E9chappement non valide, ''{0}''. Cette cha\u00EEne doit comporter un seul caract\u00E8re. Elle ne doit pas avoir la valeur null ni comporter plusieurs caract\u00E8res.
diff --git a/java/engine/org/apache/derby/loc/messages_hu.properties b/java/engine/org/apache/derby/loc/messages_hu.properties
index 7baabc337..66d37c706 100644
--- a/java/engine/org/apache/derby/loc/messages_hu.properties
+++ b/java/engine/org/apache/derby/loc/messages_hu.properties
@@ -446,7 +446,6 @@ XSDG8.D=Vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a(z) ''{0}'' k\u00f6nyvt\u00e1r
 22013=''{0}'' negat\u00edv sz\u00e1mb\u00f3l n\u00e9gyzetgy\u00f6k von\u00e1s\u00e1ra t\u00f6rt\u00e9nt k\u00eds\u00e9rlet.
 22014=A LOCATE kezd\u0151poz\u00edci\u00f3ja \u00e9rv\u00e9nytelen, pozit\u00edv eg\u00e9sznek kell lennie. A keres\u00e9s ind\u00edt\u00e1s\u00e1nak indexe: ''{2}''.  A keresend\u0151 karaktersorozat: ''{0}''.  A keres\u00e9s a k\u00f6vetkez\u0151 karaktersorozatt\u00f3l ind\u00edtand\u00f3: ''{1}''. 
 22015=A(z) ''{0}'' f\u00fcggv\u00e9ny nem enged\u00e9lyezett a k\u00f6vetkez\u0151 t\u00edpushalmazon.  Az els\u0151 operandus ''{1}'' t\u00edpus\u00fa.  A m\u00e1sodik operandus ''{2}'' t\u00edpus\u00fa.  A harmadik operandus (a kezd\u0151poz\u00edci\u00f3) ''{3}'' t\u00edpus\u00fa.
-22015.S.1= \u00c9rv\u00e9nytelen adat\u00e1talak\u00edt\u00e1s: a k\u00e9rt \u00e1talak\u00edt\u00e1s hat\u00e1s\u00e1ra a(z) {0} vesztene a pontoss\u00e1g\u00e1b\u00f3l
 22018=\u00c9rv\u00e9nytelen karaktersorozat-form\u00e1tum a k\u00f6vetkez\u0151 t\u00edpushoz: {0}.
 22019=\u00c9rv\u00e9nytelen vez\u00e9rl\u0151 jelsorozat: ''{0}''. A vez\u00e9rl\u0151 jelsorozatnak pontosan egy karakterb\u0151l kell \u00e1llnia. Nem lehet nulla vagy egyn\u00e9l t\u00f6bb karakter.
 22025=A vez\u00e9rl\u0151karaktert a ''_'' vagy ''%'' vez\u00e9rl\u0151karakternek kell k\u00f6vetnie. Nem k\u00f6vetheti m\u00e1sik karakter vagy nem \u00e1llhat a minta v\u00e9g\u00e9n.
diff --git a/java/engine/org/apache/derby/loc/messages_it.properties b/java/engine/org/apache/derby/loc/messages_it.properties
index e4f7d797b..94d3664c0 100644
--- a/java/engine/org/apache/derby/loc/messages_it.properties
+++ b/java/engine/org/apache/derby/loc/messages_it.properties
@@ -122,7 +122,6 @@
 22012=Tentativo di dividere per zero.
 22013=Tentativo di ottenere la radice quadrata di un numero negativo, ''{0}''.
 22014=La posizione iniziale di LOCATE non \u00E8 valida; \u00E8 necessario che sia un numero intero positivo. L''indice da cui iniziare la ricerca \u00E8 ''{2}''.  La stringa da cui effettuare la ricerca \u00E8 ''{0}''.  La stringa da cui effettuare la ricerca \u00E8 ''{1}''. 
-22015.S.1=Invalida conversione di dati\: la conversione richiesta provocherebbe una perdita di precisione di {0}
 22015=La funzione ''{0}'' non \u00E8 consentita sul seguente insieme di tipi.  Il primo operando \u00E8 di tipo ''{1}''.  Il secondo operando \u00E8 di tipo ''{2}''.  Il terzo operando (posizione iniziale) \u00E8 di tipo ''{3}''.
 22018=Formato stringa di caratteri non valido per il tipo {0}.
 22019=Sequenza escape non valida, ''{0}''. La stringa escape deve essere esattamente un carattere. Non pu\u00F2 essere vuota o contenere pi\u00F9 di un carattere.
diff --git a/java/engine/org/apache/derby/loc/messages_ja_JP.properties b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
index 3942b9440..8e42dd3ed 100644
--- a/java/engine/org/apache/derby/loc/messages_ja_JP.properties
+++ b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
@@ -122,7 +122,6 @@
 22012=\u30BC\u30ED\u9664\u7B97\u3092\u8A66\u884C\u3057\u3066\u3044\u307E\u3059\u3002
 22013=\u8CA0\u306E\u6570\u5024 ''{0}'' \u306E\u5E73\u65B9\u6839\u3092\u53D6\u308D\u3046\u3068\u3057\u3066\u3044\u307E\u3059\u3002
 22014=LOCATE \u306E\u958B\u59CB\u4F4D\u7F6E\u304C\u7121\u52B9\u3067\u3059\u3002\u3053\u306E\u4F4D\u7F6E\u306F\u6B63\u306E\u6574\u6570\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002 \u691C\u7D22\u3092\u958B\u59CB\u3059\u308B\u7D22\u5F15\u306F ''{2}'' \u3067\u3059\u3002  \u691C\u7D22\u3059\u308B\u30B9\u30C8\u30EA\u30F3\u30B0\u306F ''{0}'' \u3067\u3059\u3002  \u30B9\u30C8\u30EA\u30F3\u30B0\u306E\u691C\u7D22\u5143\u306F ''{1}'' \u3067\u3059\u3002 
-22015.S.1=\u7121\u52B9\u306A\u30C7\u30FC\u30BF\u5909\u63DB\u3067\u3059\u3002\u8981\u6C42\u3055\u308C\u305F\u5909\u63DB\u3092\u884C\u3046\u3068\u3001{0} \u306E\u7CBE\u5EA6\u304C\u5931\u308F\u308C\u307E\u3059\u3002
 22015=''{0}'' \u95A2\u6570\u306F\u3001\u6B21\u306E\u578B\u306E\u30BB\u30C3\u30C8\u3067\u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093\u3002  \u7B2C 1 \u30AA\u30DA\u30E9\u30F3\u30C9\u306F\u578B ''{1}'' \u3067\u3059\u3002  \u7B2C 2 \u30AA\u30DA\u30E9\u30F3\u30C9\u306F\u578B ''{2}'' \u3067\u3059\u3002  \u7B2C 3 \u30AA\u30DA\u30E9\u30F3\u30C9 (\u958B\u59CB\u4F4D\u7F6E) \u306F\u578B ''{3}'' \u3067\u3059\u3002
 22018=\u578B {0} \u306B\u5BFE\u3057\u3066\u7121\u52B9\u306A\u6587\u5B57\u30B9\u30C8\u30EA\u30F3\u30B0\u30FB\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u3067\u3059\u3002
 22019=\u7121\u52B9\u306A\u30A8\u30B9\u30B1\u30FC\u30D7\u30FB\u30B7\u30FC\u30B1\u30F3\u30B9\u3067\u3059\: ''{0}''\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30FB\u30B9\u30C8\u30EA\u30F3\u30B0\u306F\u30011 \u6587\u5B57\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002 NULL \u3067\u3082 2 \u6587\u5B57\u4EE5\u4E0A\u3067\u3082\u3044\u3051\u307E\u305B\u3093\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_ko_KR.properties b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
index ae373e45f..5eea856d0 100644
--- a/java/engine/org/apache/derby/loc/messages_ko_KR.properties
+++ b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
@@ -122,7 +122,6 @@
 22012=0\uC73C\uB85C \uB098\uB204\uB824\uACE0 \uC2DC\uB3C4\uD569\uB2C8\uB2E4.
 22013=\uC74C\uC218\uC758 \uC81C\uACF1\uADFC ''{0}''\uC744(\uB97C) \uAD6C\uD558\uB824\uACE0 \uC2DC\uB3C4\uD569\uB2C8\uB2E4.
 22014=LOCATE\uC758 \uC2DC\uC791 \uC704\uCE58\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uC591\uC758 \uC815\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4. \uAC80\uC0C9\uC744 \uC2DC\uC791\uD560 \uC0C9\uC778\uC740 ''{2}''\uC785\uB2C8\uB2E4. \uAC80\uC0C9 \uB300\uC0C1 \uBB38\uC790\uC5F4\uC740 ''{0}''\uC785\uB2C8\uB2E4. \uAC80\uC0C9\uD560 \uBB38\uC790\uC5F4\uC740 ''{1}''\uC785\uB2C8\uB2E4. 
-22015.S.1=\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uB370\uC774\uD130 \uBCC0\uD658\: \uC694\uCCAD\uB41C \uBCC0\uD658\uC73C\uB85C \uC778\uD574 {0}\uC758 \uC815\uBC00\uB3C4\uAC00 \uB5A8\uC5B4\uC9C8 \uC218 \uC788\uC2B5\uB2C8\uB2E4.
 22015=''{0}'' \uD568\uC218\uB294 \uB2E4\uC74C\uC758 \uC720\uD615 \uC138\uD2B8\uC5D0\uC11C\uB294 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uCCAB \uBC88\uC9F8 \uD53C\uC5F0\uC0B0\uC790\uC758 \uC720\uD615\uC740 ''{1}''\uC785\uB2C8\uB2E4. \uB450 \uBC88\uC9F8 \uD53C\uC5F0\uC0B0\uC790\uC758 \uC720\uD615\uC740 ''{2}''\uC785\uB2C8\uB2E4. \uC138 \uBC88\uC9F8 \uD53C\uC5F0\uC0B0\uC790(\uC2DC\uC791 \uC704\uCE58)\uC758 \uC720\uD615\uC740 ''{3}''\uC785\uB2C8\uB2E4.
 22018={0} \uC720\uD615\uC5D0 \uB300\uD55C \uC62C\uBC14\uB978 \uBB38\uC790\uC5F4 \uD615\uC2DD\uC774 \uC544\uB2D9\uB2C8\uB2E4.
 22019=\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uC774\uD0C8 \uC21C\uC11C ''{0}''. \uC774\uD0C8 \uBB38\uC790\uC5F4\uC740 \uD55C \uBB38\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4. \uB110 \uB610\uB294 \uB458 \uC774\uC0C1\uC758 \uBB38\uC790\uC5EC\uC11C\uB294 \uC548\uB429\uB2C8\uB2E4.
diff --git a/java/engine/org/apache/derby/loc/messages_pl.properties b/java/engine/org/apache/derby/loc/messages_pl.properties
index ab1cc8378..1f9dffa1c 100644
--- a/java/engine/org/apache/derby/loc/messages_pl.properties
+++ b/java/engine/org/apache/derby/loc/messages_pl.properties
@@ -446,7 +446,6 @@ XSDG8.D=Nie mo\u017cna skopiowa\u0107 katalogu ''{0}'' do ''{1}'' podczas odtwar
 22013=Pr\u00f3ba obliczenia pierwiastka kwadratowego z liczby ujemnej, ''{0}''.
 22014=Pozycja pocz\u0105tkowa dla funkcji LOCATE jest niepoprawna. Musi to by\u0107 liczba ca\u0142kowita dodatnia. Indeks, od kt\u00f3rego ma si\u0119 rozpocz\u0105\u0107 wyszukiwanie, to ''{2}''. \u0141a\u0144cuch do wyszukania to ''{0}''. \u0141a\u0144cuch, od kt\u00f3rego rozpocznie si\u0119 wyszukiwanie, to ''{1}''. 
 22015=Funkcja ''{0}'' nie jest dozwolona dla nast\u0119puj\u0105cego zestawu typ\u00f3w. Pierwszy operand jest typu ''{1}''. Drugi operand jest typu ''{2}''. Trzeci operand (pozycja pocz\u0105tkowa) jest typu ''{3}''.
-22015.S.1= Niepoprawna konwersja danych: \u017c\u0105dana konwersja spowoduje zmniejszenie dok\u0142adno\u015bci dla {0}
 22018=Niepoprawny format \u0142a\u0144cucha znak\u00f3w dla typu {0}.
 22019=Niepoprawna sekwencja o zmienionym znaczeniu: ''{0}''. \u0141a\u0144cuch zmiany znaczenia musi mie\u0107 dok\u0142adnie jeden znak. Nie mo\u017ce mie\u0107 warto\u015bci null ani zawiera\u0107 wi\u0119cej ni\u017c jednego znaku.
 22025=Po znaku zmiany znaczenia musi nast\u0119powa\u0107 znak zmiany znaczenia ''_'' lub ''%''. Nie mo\u017ce po nim nast\u0119powa\u0107 \u017caden inny znak ani nie mo\u017ce si\u0119 on znajdowa\u0107 na ko\u0144cu wzorca.
diff --git a/java/engine/org/apache/derby/loc/messages_pt_BR.properties b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
index cc98a51d6..2438ce5cc 100644
--- a/java/engine/org/apache/derby/loc/messages_pt_BR.properties
+++ b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
@@ -443,7 +443,6 @@ XSDG8.D=N\u00e3o foi poss\u00edvel copiar o diret\u00f3rio ''{0}'' para ''{1}''
 22013=Tentativa de obter a raiz quadrada de um n\u00famero negativo, ''{0}''.
 22014=A posi\u00e7\u00e3o inicial para LOCATE n\u00e3o \u00e9 v\u00e1lida; deve ser um inteiro positivo. O \u00edndice a partir do qual a procura ser\u00e1 feita \u00e9 ''{2}''.  A cadeia de caracteres a ser procurada \u00e9 ''{0}''.  A cadeia de caracteres onde ser\u00e1 feita a procura \u00e9 ''{1}''.
 22015=A fun\u00e7\u00e3o ''{0}'' n\u00e3o \u00e9 permitida no seguinte conjunto de tipos.  O primeiro operando \u00e9 do tipo ''{1}''.  O segundo operando \u00e9 do tipo ''{2}''.  O terceiro operando (posi\u00e7\u00e3o inicial) \u00e9 do tipo ''{3}''.
-22015.S.1= Convers\u00e3o de dado inv\u00e1lida: a convers\u00e3o requisitada resultaria em uma perda de precis\u00e3o para {0}
 22018=Formato de cadeia de caracteres inv\u00e1lido para o tipo {0}.
 22019=Seq\u00fc\u00eancia de escape inv\u00e1lida, ''{0}''. A cadeia de caracteres de escape deve ter exatamente um caractere: n\u00e3o pode ser nula ou ter mais de um caractere.
 22025=O caractere de escape deve ser seguido pelo caractere de escape, ''_'' ou ''%'': n\u00e3o pode ser seguido por qualquer outro caractere, ou estar no final do padr\u00e3o.
diff --git a/java/engine/org/apache/derby/loc/messages_ru.properties b/java/engine/org/apache/derby/loc/messages_ru.properties
index f9819a922..a2581bb6a 100644
--- a/java/engine/org/apache/derby/loc/messages_ru.properties
+++ b/java/engine/org/apache/derby/loc/messages_ru.properties
@@ -446,7 +446,6 @@ XSDG8.D=\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043a\u04
 22013=\u041f\u043e\u043f\u044b\u0442\u043a\u0430 \u0438\u0437\u0432\u043b\u0435\u0447\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439 \u043a\u043e\u0440\u0435\u043d\u044c \u0438\u0437 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430, ''{0}''.
 22014=\u041d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f LOCATE; \u044d\u0442\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e. \u0418\u043d\u0434\u0435\u043a\u0441 \u0434\u043b\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e\u0438\u0441\u043a\u0430 - ''{2}''.  \u0418\u0441\u043a\u043e\u043c\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 - ''{0}''.  \u0421\u0442\u0440\u043e\u043a\u0430, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u044c \u043f\u043e\u0438\u0441\u043a - ''{1}''. 
 22015=\u0424\u0443\u043d\u043a\u0446\u0438\u044f ''{0}'' \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0433\u043e \u043d\u0438\u0436\u0435 \u043d\u0430\u0431\u043e\u0440\u0430 \u0442\u0438\u043f\u043e\u0432.  \u041f\u0435\u0440\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u043a \u0442\u0438\u043f\u0443 ''{1}''.  \u0412\u0442\u043e\u0440\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u043a \u0442\u0438\u043f\u0443 ''{2}''.  \u0422\u0440\u0435\u0442\u0438\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434 (\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435) \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u043a \u0442\u0438\u043f\u0443 ''{3}''.
-22015.S.1= \u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445: \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u0437\u0430\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u0442\u0435\u0440\u044f\u043d\u0430 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c {0}
 22018=\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u0444\u043e\u0440\u043c\u0430\u0442 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0434\u043b\u044f \u0442\u0438\u043f\u0430 {0}.
 22019=\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u0430\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432, ''{0}''. \u0423\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u043e\u0447\u043d\u043e \u043e\u0434\u0438\u043d \u0441\u0438\u043c\u0432\u043e\u043b. \u041e\u043d\u0430 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u043d\u0438 \u043d\u0443\u043b\u0435\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432, \u043d\u0438 \u0431\u043e\u043b\u0435\u0435 \u043e\u0434\u043d\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430.
 22025=\u041f\u043e\u0441\u043b\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0435\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u0442\u043e\u044f\u0442\u044c \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u0441\u0438\u043c\u0432\u043e\u043b, ''_'' \u0438\u043b\u0438 ''%''. \u041d\u0438\u043a\u0430\u043a\u043e\u0439 \u0434\u0440\u0443\u0433\u043e\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043f\u043e\u0441\u043b\u0435 \u043d\u0435\u0433\u043e \u0441\u0442\u043e\u044f\u0442\u044c \u043d\u0435 \u043c\u043e\u0436\u0435\u0442, \u0438 \u043e\u043d \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u0432 \u043a\u043e\u043d\u0446\u0435 \u0448\u0430\u0431\u043b\u043e\u043d\u0430.
diff --git a/java/engine/org/apache/derby/loc/messages_zh_CN.properties b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
index 6749e1e36..36b2fee29 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_CN.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
@@ -121,7 +121,6 @@
 22012=\u5C1D\u8BD5\u7528\u96F6\u9664\u3002
 22013=\u5C1D\u8BD5\u91C7\u7528\u8D1F\u6570\u7684\u5E73\u65B9\u6839\u201C{0}\u201D\u3002
 22014=LOCATE \u7684\u5F00\u59CB\u4F4D\u7F6E\u65E0\u6548\uFF1B\u5B83\u5FC5\u987B\u4E3A\u6B63\u6574\u6570\u3002\u5F00\u59CB\u641C\u7D22\u7684\u7D22\u5F15\u4E3A\u201C{2}\u201D\u3002\u8981\u641C\u7D22\u7684\u5B57\u7B26\u4E32\u4E3A\u201C{0}\u201D\u3002\u4ECE\u4E2D\u641C\u7D22\u7684\u5B57\u7B26\u4E32\u4E3A\u201C{1}\u201D\u3002
-22015.S.1=\u6570\u636E\u8F6C\u6362\u65E0\u6548\uFF1A\u8BF7\u6C42\u7684\u8F6C\u6362\u5C06\u5BFC\u81F4\u7CBE\u5EA6 {0} \u4E22\u5931
 22015=\u4E0B\u5217\u7C7B\u578B\u96C6\u4E0A\u4E0D\u5141\u8BB8\u201C{0}\u201D\u51FD\u6570\u3002\u7B2C\u4E00\u4E2A\u64CD\u4F5C\u6570\u4E3A\u7C7B\u578B\u201C{1}\u201D\u3002\u7B2C\u4E8C\u4E2A\u64CD\u4F5C\u6570\u4E3A\u7C7B\u578B\u201C{2}\u201D\u3002\u7B2C\u4E09\u4E2A\u64CD\u4F5C\u6570\uFF08\u8D77\u59CB\u4F4D\u7F6E\uFF09\u4E3A\u7C7B\u578B\u201C{3}\u201D\u3002
 22018=\u7C7B\u578B {0} \u7684\u5B57\u7B26\u4E32\u683C\u5F0F\u65E0\u6548\u3002
 22019=\u8F6C\u4E49\u5E8F\u5217\u201C{0}\u201D\u65E0\u6548\u3002\u8F6C\u4E49\u5B57\u7B26\u4E32\u5FC5\u987B\u6B63\u597D\u4E3A\u4E00\u4E2A\u5B57\u7B26\u3002\u5B83\u4E0D\u80FD\u4E3A\u7A7A\u6216\u5927\u4E8E\u4E00\u4E2A\u5B57\u7B26\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_zh_TW.properties b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
index 4fcaf1b6f..6e5f2f15c 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_TW.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
@@ -122,7 +122,6 @@
 22012=\u5617\u8A66\u9664\u4EE5\u96F6\u3002
 22013=\u8A66\u5716\u53D6\u5F97\u8CA0\u6578 ''{0}'' \u7684\u5E73\u65B9\u6839\u3002
 22014=LOCATE \u7684\u8D77\u59CB\u4F4D\u7F6E\u7121\u6548\uFF1B\u5B83\u5FC5\u9808\u662F\u6B63\u6574\u6578\u3002\u641C\u5C0B\u7684\u8D77\u59CB\u7D22\u5F15\u662F  ''{2}''\u3002\u8981\u641C\u5C0B\u7684\u5B57\u4E32\u662F ''{0}''\u3002\u8981\u5F9E\u4E2D\u9032\u884C\u641C\u5C0B\u7684\u5B57\u4E32\u662F ''{1}''\u3002
-22015.S.1=\u8CC7\u6599\u8F49\u63DB\u7121\u6548\uFF1A\u6240\u8981\u6C42\u7684\u8F49\u63DB\u5C07\u5C0E\u81F4 {0} \u7CBE\u6E96\u5EA6\u6D41\u5931
 22015=\u5728\u4E0B\u9762\u9019\u7D44\u985E\u578B\u4E2D\uFF0C\u4E0D\u5141\u8A31\u4F7F\u7528 ''{0}'' \u51FD\u6578\u3002\u7B2C\u4E00\u500B\u904B\u7B97\u5143\u662F ''{1}'' \u985E\u578B\u3002\u7B2C\u4E8C\u500B\u904B\u7B97\u5143\u662F  ''{2}''  \u985E\u578B\u3002\u7B2C\u4E09\u500B\u904B\u7B97\u5143\uFF08\u8D77\u59CB\u4F4D\u7F6E\uFF09\u662F ''{3}''\u3002
 22018=\u985E\u578B {0} \u7684\u5B57\u5143\u5B57\u4E32\u683C\u5F0F\u7121\u6548\u3002
 22019=\u7121\u6548\u7684 ESC \u5E8F\u5217 ''{0}''\u3002\u8DF3\u51FA\u5B57\u4E32\u5FC5\u9808\u53EA\u6709\u4E00\u500B\u5B57\u5143\u3002\u5B83\u4E0D\u80FD\u662F\u7A7A\u503C\u6216 1 \u500B\u4EE5\u4E0A\u7684\u5B57\u5143\u3002
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 564dcb7dc..86b5f155a 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -715,7 +715,6 @@ public interface SQLState {
     String LANG_SQRT_OF_NEG_NUMBER                                     = "22013";
     String LANG_INVALID_PARAMETER_FOR_SEARCH_POSITION                  = "22014";
     String LANG_INVALID_TYPE_FOR_LOCATE_FUNCTION                       = "22015";
-    String LOSS_OF_PRECISION_EXCEPTION                                 = "22015.S.1";
 	String LANG_FORMAT_EXCEPTION                                       = "22018";
 	String LANG_INVALID_ESCAPE_CHARACTER                               = "22019";
 	String LANG_INVALID_TRIM_CHARACTER                                 = "22020";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
index 60be1ac4c..38d96e926 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
@@ -1102,6 +1102,7 @@ public class ParameterMappingTest extends BaseJDBCTestCase {
      */
     protected void tearDown() throws Exception {
         Connection conn = getConnection();
+        rollback();
         Statement scb = conn.createStatement();
         scb.execute("DROP TABLE PM.LOB_GET");
         scb.close();
@@ -4485,6 +4486,548 @@ public class ParameterMappingTest extends BaseJDBCTestCase {
 
         assertCompileError( sqlState, query );
     }
-}
 
+    /**
+     * Tests that SQLStates are correct across drivers on rs.getXXX
+     * over/underflow.
+     * @exception SQLException database access error. Causes test to
+     *                         fail with an error.
+     */
+    public void testDerby5533GetXXX() throws SQLException
+    {
+        String createTableString = "CREATE TABLE MultiTypeTable (" +
+            "F01 SMALLINT," +
+            "F02 INTEGER," +
+            "F03 BIGINT," +
+            "F04 REAL," +
+            "F05 FLOAT," +
+            "F06 DOUBLE," +
+            "F07 DECIMAL(31)," +
+            "F08 NUMERIC," +
+            "F09 CHAR(100)," +
+            "F10 VARCHAR(256)," +
+            "F11 BOOLEAN)";
+        Statement stmt = createStatement();
+        stmt.executeUpdate(createTableString);
+
+        PreparedStatement ps = prepareStatement
+            ("insert into MultiTypeTable values(?,?,?,?,?,?,?,?,?,?,?)");
+
+        /* First check upper bounds */
+
+        ps.setShort(1, (short)((short)Byte.MAX_VALUE + 1));
+        ps.setInt(2, (int)Short.MAX_VALUE + 1);
+        ps.setLong(3, (long)Integer.MAX_VALUE + 1);
+        ps.setFloat(4, (float)Long.MAX_VALUE * 10);
+        ps.setFloat(5, (float)Long.MAX_VALUE * 10);
+        ps.setDouble(6, (double)Float.MAX_VALUE * 10);
+        // Largest integer representable in DECIMAL is Derby has 31 digits:
+        ps.setBigDecimal(7, new BigDecimal("9999999999999999999999999999999"));
+        ps.setInt(8, _X);
+        ps.setString(9, " ");
+        ps.setString(10, " ");
+        ps.setBoolean(11, true);
+        ps.executeUpdate();
+
+        ResultSet rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        // JDBC type -> byte
+        assertGetState(rs, "F01", XXX_BYTE, "22003");
+        assertGetState(rs, "F02", XXX_BYTE, "22003");
+        assertGetState(rs, "F03", XXX_BYTE, "22003");
+        assertGetState(rs, "F04", XXX_BYTE, "22003");
+        assertGetState(rs, "F05", XXX_BYTE, "22003");
+        assertGetState(rs, "F06", XXX_BYTE, "22003");
+        assertGetState(rs, "F07", XXX_BYTE, "22003");
+
+        // JDBC type -> short
+        assertGetState(rs, "F02", XXX_SHORT, "22003");
+        assertGetState(rs, "F03", XXX_SHORT, "22003");
+        assertGetState(rs, "F04", XXX_SHORT, "22003");
+        assertGetState(rs, "F05", XXX_SHORT, "22003");
+        assertGetState(rs, "F06", XXX_SHORT, "22003");
+        assertGetState(rs, "F07", XXX_SHORT, "22003");
+
+        // JDBC type -> int
+        assertGetState(rs, "F03", XXX_INT, "22003");
+        assertGetState(rs, "F04", XXX_INT, "22003");
+        assertGetState(rs, "F05", XXX_INT, "22003");
+        assertGetState(rs, "F06", XXX_INT, "22003");
+        assertGetState(rs, "F07", XXX_INT, "22003");
+
+        // JDBC type -> long
+        assertGetState(rs, "F04", XXX_LONG, "22003");
+        assertGetState(rs, "F05", XXX_LONG, "22003");
+        assertGetState(rs, "F06", XXX_LONG, "22003");
+
+        // Uncomment when DERBY-5536 is fixed
+        // assertGetState(rs, "F07", XXX_LONG, "22003");
+
+
+        // JDBC type -> float
+        rs.close();
+        Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+        rs.updateDouble("F06", Float.MAX_VALUE * 10.0);
+        rs.updateRow();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        assertGetState(rs, "F06", XXX_FLOAT, "22003");
+
+
+        /* Now check lower bounds */
+        PreparedStatement psDelete = prepareStatement(
+                "delete from MultiTypeTable");
+        psDelete.executeUpdate();
+
+        ps.setShort(1, (short)((short)Byte.MIN_VALUE - 1));
+        ps.setInt(2, (int)Short.MIN_VALUE - 1);
+        ps.setLong(3, (long)Integer.MIN_VALUE - 1);
+        ps.setFloat(4, -(float)Long.MAX_VALUE * 10);
+        ps.setFloat(5, -(float)Long.MAX_VALUE * 10);
+        ps.setDouble(6, -(double)Float.MAX_VALUE * 10);
+        // Largest integer representable in DECIMAL is Derby has 31 digits:
+        ps.setBigDecimal(7, new BigDecimal("-999999999999999999999999999999"));
+        ps.setInt(8, _X);
+        ps.setString(9, " ");
+        ps.setString(10, " ");
+        ps.setBoolean(11, false);
+        ps.executeUpdate();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+        // JDBC type -> byte
+        assertGetState(rs, "F01", XXX_BYTE, "22003");
+        assertGetState(rs, "F02", XXX_BYTE, "22003");
+        assertGetState(rs, "F03", XXX_BYTE, "22003");
+        assertGetState(rs, "F04", XXX_BYTE, "22003");
+        assertGetState(rs, "F05", XXX_BYTE, "22003");
+        assertGetState(rs, "F06", XXX_BYTE, "22003");
+        assertGetState(rs, "F07", XXX_BYTE, "22003");
+
+        // JDBC type -> short
+        assertGetState(rs, "F02", XXX_SHORT, "22003");
+        assertGetState(rs, "F03", XXX_SHORT, "22003");
+        assertGetState(rs, "F04", XXX_SHORT, "22003");
+        assertGetState(rs, "F05", XXX_SHORT, "22003");
+        assertGetState(rs, "F06", XXX_SHORT, "22003");
+        assertGetState(rs, "F07", XXX_SHORT, "22003");
+
+        // JDBC type -> int
+        assertGetState(rs, "F03", XXX_INT, "22003");
+        assertGetState(rs, "F04", XXX_INT, "22003");
+        assertGetState(rs, "F05", XXX_INT, "22003");
+        assertGetState(rs, "F06", XXX_INT, "22003");
+        assertGetState(rs, "F07", XXX_INT, "22003");
+
+        // JDBC type -> long
+        assertGetState(rs, "F04", XXX_LONG, "22003");
+        assertGetState(rs, "F05", XXX_LONG, "22003");
+        assertGetState(rs, "F06", XXX_LONG, "22003");
+
+        // JDBC type -> float
+        rs.close();
+        s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+        rs.updateDouble("F06", -Float.MAX_VALUE * 10.0);
+        rs.updateRow();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        assertGetState(rs, "F06", XXX_FLOAT, "22003");
+    }
+
+
+    /**
+     * Tests that SQLStates are correct across drivers on updateXXX
+     * over/underflow.
+     * @exception SQLException database access error. Causes test to
+     *                         fail with an error.
+     */
+    public void testDerby5533UpdateXXX() throws SQLException
+    {
+        String createTableString = "CREATE TABLE MultiTypeTable (" +
+            "F01 SMALLINT," +
+            "F02 INTEGER," +
+            "F03 BIGINT," +
+            "F04 REAL," +
+            "F05 FLOAT," +
+            "F06 DOUBLE," +
+            "F07 DECIMAL(31)," +
+            "F08 NUMERIC," +
+            "F09 CHAR(100)," +
+            "F10 VARCHAR(256)," +
+            "F11 BOOLEAN)";
+        Statement stmt = createStatement();
+        stmt.executeUpdate(createTableString);
+
+        PreparedStatement ps = prepareStatement
+            ("insert into MultiTypeTable values(?,?,?,?,?,?,?,?,?,?,?)");
+        PreparedStatement psDelete = prepareStatement(
+            "delete from MultiTypeTable");
+
+        /* First check upper bounds */
+
+        ps.setShort(1, (short)1);
+        ps.setInt(2, 1);
+        ps.setLong(3, 1L);
+        ps.setFloat(4, 1.0f);
+        ps.setDouble(5, 1.0);
+        ps.setDouble(6, 1.0);
+        ps.setString(7, "1");
+        ps.setString(8, "1");
+        ps.setString(9, "1");
+        ps.setString(10, "1");
+        ps.setBoolean(11, true);
+
+        ps.executeUpdate();
+
+        Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        ResultSet rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+
+        // SMALLINT
+        assertUpdateState(rs, "F01",
+                          Short.MAX_VALUE + 1, _X, XXX_INT,"22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MAX_VALUE + 1, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F01",
+                          Short.MAX_VALUE + 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MAX_VALUE + 1, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F01",
+                          bdMaxShortValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F01",
+                          Short.MIN_VALUE - 1, _X, XXX_INT,"22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MIN_VALUE - 1, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F01",
+                          Short.MIN_VALUE - 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MIN_VALUE - 1, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F01",
+                          bdMinShortValue.subtract(BigDecimal.ONE), "22003");
+
+
+        // INT
+        assertUpdateState(rs, "F02",
+                          (long)Integer.MAX_VALUE + 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F02", _X,
+                          (float)Integer.MAX_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F02", _X,
+                          (double)Integer.MAX_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F02",
+                          bdMaxIntValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F02",
+                          (long)Integer.MIN_VALUE - 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F02",
+                       _X, (float)Integer.MIN_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F02",
+                       _X, (double)Integer.MIN_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F02",
+                          bdMinIntValue.subtract(BigDecimal.ONE), "22003");
+
+        // BIGINT
+        assertUpdateState(rs, "F03",
+                          _X, (float)Long.MAX_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F03",
+                          _X, (double)Long.MAX_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F03",
+                          bdMaxLongValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F03",
+                          _X, (float)Long.MIN_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F03",
+                          _X, (double)Long.MIN_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F03",
+                          bdMinLongValue.subtract(BigDecimal.ONE), "22003");
+
+        // REAL overflow checking
+        assertUpdateState(rs, "F04",
+                          _X, (new Float(Float.MAX_VALUE)).doubleValue() * 10,
+                          XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F04",
+                          _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F04",
+                          bdMaxFloatValue.multiply(BigDecimal.TEN), "22003");
+
+        assertUpdateState(rs, "F04",
+                          _X, -(new Float(Float.MAX_VALUE)).doubleValue() * 10,
+                          XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F04",
+                          _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F04",
+                          bdMinFloatValue.multiply(BigDecimal.TEN), "22003");
+
+        // Remove test when DERBY-5534 is fixed
+        if (usingEmbedded()) {
+            assertUpdateState(rs, "F04",
+                              _X, Float.NaN, XXX_FLOAT, "22003");
+            assertUpdateState(rs, "F04",
+                              _X, Double.MIN_VALUE, XXX_DOUBLE, "22003");
+
+            // REAL DB2 limits: remove if DERBY-3398 is implemented
+            assertUpdateState(rs, "F04", bdSmallestPosFloatValue, "22003");
+            assertUpdateState(rs, "F04", bdSmallestNegFloatValue, "22003");
+
+            assertUpdateState(rs, "F04", bdMaxFloatValue, "22003");
+            assertUpdateState(rs, "F04", bdMinFloatValue, "22003");
+        }
+
+        // REAL Underflow checking
+        //
+        // Uncomment when DERBY-5546 is fixed:
+        // assertUpdateState(rs, "F04", bdSmallestPosDoubleValue, "22003");
+        // assertUpdateState(rs, "F04", bdSmallestNegDoubleValue, "22003");
+
+
+        // DOUBLE, FLOAT (SQL FLOAT is really the same as SQL DOUBLE in Derby)
+        final String[] dfCols = new String[]{"F05", "F06"};
+        for (int i = 0; i < 2; i++) {
+            assertUpdateState(rs, dfCols[i], _X,
+                              Float.POSITIVE_INFINITY, XXX_FLOAT, "22003");
+            assertUpdateState(rs, dfCols[i], _X,
+                              Double.POSITIVE_INFINITY, XXX_DOUBLE, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              bdMaxDoubleValue.multiply(BigDecimal.TEN),
+                              "22003");
+
+            // Uncomment when DERBY-5534 is fixed, or remove entirely if
+            // DERBY-3398 is fixed
+            // assertUpdateState(rs, dfCols[i], _X,
+            //                   Double.MAX_VALUE, UPDATE_DOUBLE, "22003");
+
+            assertUpdateState(rs, dfCols[i],
+                              _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              _X, Double.NEGATIVE_INFINITY,
+                              XXX_DOUBLE, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              bdMinDoubleValue.multiply(BigDecimal.TEN),
+                              "22003");
+
+            // Uncomment when DERBY-5534 is fixed, or remove entirely if
+            // DERBY-3398 is fixed
+
+            // assertUpdateState(rs, dfCols[i], _X,
+            //                   Double.MIN_VALUE, UPDATE_DOUBLE, "22003");
+
+            // Remove test when DERBY-5534 is fixed
+            if (usingEmbedded()) {
+                assertUpdateState(rs, dfCols[i],
+                                  _X, Double.NaN, XXX_DOUBLE, "22003");
+            }
+
+            // DOUBLE, FLOAT underflow checking
+            //
+            // Uncomment when DERBY-5546 is fixed
+            // assertUpdateState(rs, dfCols[i],
+            //     bdSmallestPosDoubleValue.divide(BigDecimal.TEN), "22003");
+            // assertUpdateState(rs, dfCols[i],
+            //     bdSmallestNegDoubleValue.divide(BigDecimal.TEN), "22003");
+        }
+
+        // Derby BOOLEAN: not range checked: FALSE of 0, else TRUE.
+        // assertUpdateState(rs, "F11", 2, _X, XXX_BYTE, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_SHORT, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_INT, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_LONG, "22003");
+        // assertUpdateState(rs, "F11", _X, 2.0, XXX_FLOAT, "22003");
+        // assertUpdateState(rs, "F11", _X, 2.0, XXX_DOUBLE, "22003");
+        // assertUpdateState(rs, "F11", new BigDecimal(2), "22003");
+    }
+
+    // Short limits
+    //
+    private final static BigDecimal bdMaxShortValue =
+        BigDecimal.valueOf(Short.MAX_VALUE);
+
+    private final static BigDecimal bdMinShortValue =
+        BigDecimal.valueOf(Short.MIN_VALUE);
+
+    // Integer limits
+    //
+    private final static BigDecimal bdMaxIntValue =
+        BigDecimal.valueOf(Integer.MAX_VALUE);
+
+    private final static BigDecimal bdMinIntValue =
+        BigDecimal.valueOf(Integer.MIN_VALUE);
+
+    // Long limits
+    //
+    private final static BigDecimal bdMaxLongValue =
+        BigDecimal.valueOf(Long.MAX_VALUE);
+
+    private final static BigDecimal bdMinLongValue =
+        BigDecimal.valueOf(Long.MIN_VALUE);
+
+    // Float limits
+    //
+    private final static BigDecimal bdMaxFloatValue =
+        new BigDecimal(Float.MAX_VALUE);
+
+    private final static BigDecimal bdMinFloatValue =
+        new BigDecimal(-Float.MAX_VALUE);
+
+    private final static BigDecimal bdSmallestPosFloatValue =
+        new BigDecimal(Float.MIN_VALUE);
 
+    private final static BigDecimal bdSmallestNegFloatValue =
+        new BigDecimal(-Float.MIN_VALUE);
+
+    // Double limits
+    //
+    private final static BigDecimal bdMaxDoubleValue =
+        new BigDecimal(Double.MAX_VALUE);
+
+    private final static BigDecimal bdMinDoubleValue =
+        new BigDecimal(-Double.MAX_VALUE);
+
+    private final static BigDecimal bdSmallestPosDoubleValue =
+        new BigDecimal(Double.MIN_VALUE);
+
+    private final static BigDecimal bdSmallestNegDoubleValue =
+        new BigDecimal(-Double.MIN_VALUE);
+
+    // REAL/FLOAT/DOUBLE range limits
+
+    static final float DB2_SMALLEST_REAL = -3.402E+38f;
+    static final float DB2_LARGEST_REAL  = +3.402E+38f;
+    static final float DB2_SMALLEST_POSITIVE_REAL = +1.175E-37f;
+    static final float DB2_LARGEST_NEGATIVE_REAL  = -1.175E-37f;
+
+    static final double DB2_SMALLEST_DOUBLE = -1.79769E+308d;
+    static final double DB2_LARGEST_DOUBLE  = +1.79769E+308d;
+    static final double DB2_SMALLEST_POSITIVE_DOUBLE = +2.225E-307d;
+    static final double DB2_LARGEST_NEGATIVE_DOUBLE  = -2.225E-307d;
+
+    // Constants for use with assertUpdateState and assertGetState
+
+    private static final int _X = -1; // don't care
+    private static final int XXX_BYTE = 0;
+    private static final int XXX_SHORT = 1;
+    private static final int XXX_INT = 2;
+    private static final int XXX_LONG = 3;
+    private static final int XXX_FLOAT = 4;
+    private static final int XXX_DOUBLE = 5;
+
+    /*
+     * Using ResultSet.updateBigDecimal with value on colName, assert that we
+     * see the SQLstate expected.
+     */
+    private void assertUpdateState(
+        ResultSet rs,
+        String colName,
+        BigDecimal value,
+        String expected) throws SQLException {
+
+        try {
+            rs.updateBigDecimal(colName, value);
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+
+
+    /*
+     * Using ResultSet.updateXXX with value or dvalue as the case may be on
+     * colName, assert that we see the SQLstate expected. XXX is indicated by
+     * updateType.
+     */
+    private void assertUpdateState(
+        ResultSet rs,
+        String colName,
+        long value,
+        double dvalue,
+        int updateType,
+        String expected) throws SQLException {
+
+        try {
+            switch (updateType) {
+            case XXX_BYTE:
+                rs.updateByte(colName, (byte)value);
+                break;
+            case XXX_SHORT:
+                rs.updateShort(colName, (short)value);
+            case XXX_INT:
+                rs.updateInt(colName, (int)value);
+                break;
+            case XXX_LONG:
+                rs.updateLong(colName, value);
+                break;
+            case XXX_FLOAT:
+                rs.updateFloat(colName, (float)dvalue);
+                break;
+            case XXX_DOUBLE:
+                rs.updateDouble(colName, dvalue);
+                break;
+            default:
+                fail("wrong argument");
+            }
+
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+
+
+    /*
+     * Using ResultSet.getXXX on colName, assert that we see the SQLstate
+     * expected. XXX is indicated by getType.
+     */
+    private void assertGetState(
+        ResultSet rs,
+        String colName,
+        int getType,
+        String expected) throws SQLException {
+
+        try {
+            switch (getType) {
+            case XXX_BYTE:
+                rs.getByte(colName);
+                break;
+            case XXX_SHORT:
+                rs.getShort(colName);
+                    break;
+            case XXX_INT:
+                rs.getInt(colName);
+                break;
+            case XXX_LONG:
+                rs.getLong(colName);
+                break;
+            case XXX_FLOAT:
+                rs.getFloat(colName);
+                break;
+            case XXX_DOUBLE:
+                rs.getDouble(colName);
+                break;
+            default:
+                fail("wrong argument");
+            }
+
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+}
