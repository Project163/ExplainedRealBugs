diff --git a/java/testing/org/apache/derbyTesting/functionTests/harness/ibm15.java b/java/testing/org/apache/derbyTesting/functionTests/harness/ibm15.java
index 8f97fcb67..4515c2f79 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/harness/ibm15.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/harness/ibm15.java
@@ -1,99 +1,99 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.harness.ibm15
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derbyTesting.functionTests.harness;
-
-import java.util.Vector;
-import java.util.StringTokenizer;
-
-/**
-  <p>This class is for IBM's jdk 1.5.
-
-  @author ames
- */
-public class ibm15 extends jvm {
-
-	public String getName(){return "ibm15";}
-    public ibm15(boolean noasyncgc, boolean verbosegc, boolean noclassgc,
-    long ss, long oss, long ms, long mx, String classpath, String prof,
-    boolean verify, boolean noverify, boolean nojit, Vector D) {
-        super(noasyncgc,verbosegc,noclassgc,ss,oss,ms,mx,classpath,prof,
-		verify,noverify,nojit,D);
-    }
-    // more typical use:
-    public ibm15(String classpath, Vector D) {
-        super(classpath,D);
-    }
-    // more typical use:
-    public ibm15(long ms, long mx, String classpath, Vector D) {
-        super(ms,mx,classpath,D);
-    }
-    // actual use
-    public ibm15() { }
-
-    // return the command line to invoke this VM.  The caller then adds
-    // the class and program arguments.
-    public Vector getCommandLine()
-    {
-        StringBuffer sb = new StringBuffer();
-        Vector v = super.getCommandLine();
-        appendOtherFlags(sb);
-        String s = sb.toString();
-        StringTokenizer st = new StringTokenizer(s);
-        while (st.hasMoreTokens())
-        {
-            v.addElement(st.nextToken());
-        }
-        return v;
-	}
-
-	public void appendOtherFlags(StringBuffer sb)
-	{
-        if (noasyncgc) warn("ibm15 does not support noasyncgc");
-        if (verbosegc) sb.append(" -verbose:gc");
-        if (noclassgc) sb.append(" -Xnoclassgc");
-        if (ss>=0) warn("ibm15 does not support ss");
-        if (oss>=0) warn("ibm15 does not support oss");
-        if (ms>=0) {
-          sb.append(" -ms");
-          sb.append(ms);
-        }
-        if (mx>=0) {
-          sb.append(" -mx");
-          sb.append(mx);
-        }
-        if (classpath!=null) {
-          sb.append(" -classpath ");
-          sb.append(classpath);
-        }
-        if (prof!=null) warn("ibm15 does not support prof");
-        if (verify) warn("ibm15 does not support verify");
-        if (noverify) warn("ibm15 does not support noverify");
-        if (nojit) sb.append(" -Djava.compiler=NONE");
-        if (D != null)
-          for (int i=0; i<D.size();i++) {
-	        sb.append(" -D");
-	        sb.append((String)(D.elementAt(i)));
-          }
-    }
-	public String getDintro() { return "-D"; }
-}
-
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.harness.ibm15
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.harness;
+
+import java.util.Vector;
+import java.util.StringTokenizer;
+
+/**
+  <p>This class is for IBM's jdk 1.5.
+
+  @author ames
+ */
+public class ibm15 extends jvm {
+
+	public String getName(){return "ibm15";}
+    public ibm15(boolean noasyncgc, boolean verbosegc, boolean noclassgc,
+    long ss, long oss, long ms, long mx, String classpath, String prof,
+    boolean verify, boolean noverify, boolean nojit, Vector D) {
+        super(noasyncgc,verbosegc,noclassgc,ss,oss,ms,mx,classpath,prof,
+		verify,noverify,nojit,D);
+    }
+    // more typical use:
+    public ibm15(String classpath, Vector D) {
+        super(classpath,D);
+    }
+    // more typical use:
+    public ibm15(long ms, long mx, String classpath, Vector D) {
+        super(ms,mx,classpath,D);
+    }
+    // actual use
+    public ibm15() { }
+
+    // return the command line to invoke this VM.  The caller then adds
+    // the class and program arguments.
+    public Vector getCommandLine()
+    {
+        StringBuffer sb = new StringBuffer();
+        Vector v = super.getCommandLine();
+        appendOtherFlags(sb);
+        String s = sb.toString();
+        StringTokenizer st = new StringTokenizer(s);
+        while (st.hasMoreTokens())
+        {
+            v.addElement(st.nextToken());
+        }
+        return v;
+	}
+
+	public void appendOtherFlags(StringBuffer sb)
+	{
+        if (noasyncgc) warn("ibm15 does not support noasyncgc");
+        if (verbosegc) sb.append(" -verbose:gc");
+        if (noclassgc) sb.append(" -Xnoclassgc");
+        if (ss>=0) warn("ibm15 does not support ss");
+        if (oss>=0) warn("ibm15 does not support oss");
+        if (ms>=0) {
+          sb.append(" -ms");
+          sb.append(ms);
+        }
+        if (mx>=0) {
+          sb.append(" -mx");
+          sb.append(mx);
+        }
+        if (classpath!=null) {
+          sb.append(" -classpath ");
+          sb.append(classpath);
+        }
+        if (prof!=null) warn("ibm15 does not support prof");
+        if (verify) warn("ibm15 does not support verify");
+        if (noverify) warn("ibm15 does not support noverify");
+        if (nojit) sb.append(" -Djava.compiler=NONE");
+        if (D != null)
+          for (int i=0; i<D.size();i++) {
+	        sb.append(" -D");
+	        sb.append((String)(D.elementAt(i)));
+          }
+    }
+	public String getDintro() { return "-D"; }
+}
+
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/i18n/MessageBundleTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/i18n/MessageBundleTest.java
index ce1a525d4..fe8188104 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/i18n/MessageBundleTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/i18n/MessageBundleTest.java
@@ -1,195 +1,195 @@
-/*
- 
-   Derby - Class org.apache.derbyTesting.functionTests.tests.i18n.MessageBundleTest
- 
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
- 
-      http://www.apache.org/licenses/LICENSE-2.0
- 
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
- 
- */
-
-package org.apache.derbyTesting.functionTests.tests.i18n;
-
-import org.apache.derbyTesting.junit.BaseTestCase;
-import org.apache.derby.shared.common.reference.SQLState;
-import org.apache.derby.shared.common.reference.MessageId;
-
-import java.util.HashSet;
-import java.lang.reflect.Field;
-import java.util.ResourceBundle;
-import java.util.Locale;
-import java.util.Iterator;
-
-/**
- * This class does everything we can to validate that the messages_en.properties
- * file is in synch with SQLState.java and MessageId.java.  We want to make sure
- * that message ids defined in SQLState and MessageId have matching messages
- * in the messages properties file, and also find out if there are any messages
- * that don't have matching ids in the SQLState and MessageId files.   The
- * first is a bug, the second is something to be aware of.
- */
-public class MessageBundleTest extends BaseTestCase {
-    public MessageBundleTest(String name) {
-        super(name);
-    }
-
-    // The list of ids.  We use a HashSet so we can detect duplicates easily
-    static HashSet sqlStateIds          = new HashSet();
-    static HashSet messageIdIds         = new HashSet();
-    static HashSet messageBundleIds     = new HashSet();
-    
-    static {
-        try {
-            // Load all the ids for the SQLState class
-            loadClassIds(SQLState.class, sqlStateIds);
-
-            // Load all the ids for the MessageId class
-            loadClassIds(MessageId.class, messageIdIds);
-
-            // Load all the ids for the messages_en properties file
-            loadMessageBundleIds();
-        } catch ( Exception e ) {
-            e.printStackTrace();
-            throw new RuntimeException(e.getMessage());
-        }
-    }
-    
-    static void loadClassIds(Class idclass, HashSet set) throws Exception {
-        Field[] fields = idclass.getFields();
-        
-        int length = fields.length;
-        for ( int i = 0; i < length ; i++ )
-        {
-            String id = (String)fields[i].get(null);
-            
-            if ( id.length() == 2 ) {
-                // Skip past identifiers that are just categories
-                continue;
-            }
-            
-            // Skip past "special" SQL States that are not expected
-            // to have messages
-            if ( id.equals("close.C.1") )   continue;            
-            if ( id.equals("rwupd" ) )      continue;
-            if ( id.equals("02502" ) )      continue;
-            if ( id.equals("XSAX0") )       continue;
-            
-            if ( ! set.add(id) )
-            {
-                System.err.println("ERROR: The id " + id + 
-                    " was found twice in " + idclass.getName());
-            }
-        }
-    }
-            
-    /** 
-     * Load all the message ids from messages_en.properties into a HashSet.
-     * This assumes its available on the classpath
-     */
-    static void loadMessageBundleIds() throws Exception {
-        ResourceBundle bundle;
-        
-        // The messages_*.properties files are split into fifty separate
-        // message bundle files.  We need to load each one in turn
-        int numBundles = 50;
-        
-        for ( int i=0 ; i < numBundles ; i++ ) {
-            loadMessageBundle(i);
-        }
-    }
-    
-    static void loadMessageBundle(int index) {
-        String bundleName = "org.apache.derby.loc.m" + index;
-        
-        ResourceBundle bundle = 
-            ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
-
-        java.util.Enumeration keys = bundle.getKeys();
-
-        while ( keys.hasMoreElements() ) {
-            String key = (String)keys.nextElement();                
-
-            if ( ! messageBundleIds.add(key) ) {
-                System.err.println("ERROR: the key " + key +
-                    " exists twice in messages_en.properties");
-            }
-        }        
-    }
-
-    /**
-     * See if there are any message ids in SQLState.java that are
-     * not in the message bundle
-     */
-    public void testSQLStateOrphanedIds() throws Exception {
-        Iterator it = sqlStateIds.iterator();
-        
-        while ( it.hasNext() ) {
-            String sqlStateId = (String)it.next();
-            
-            if ( ! messageBundleIds.contains(sqlStateId) ) {
-                // Don't fail out on the first one, we want to catch
-                // all of them.  Just note there was a failure and continue
-                System.err.println("ERROR: Message id " + sqlStateId +
-                    " in SQLState.java was not found in" +
-                    " messages_en.properties");                     
-             }
-        }
-    }
-
-    /**
-     * See if there are any message ids in MessageId.java not in
-     * the message bundle
-     */
-    public void testMessageIdOrphanedIds() throws Exception {
-        Iterator it = messageIdIds.iterator();
-        
-        while ( it.hasNext() ) {
-            String sqlStateId = (String)it.next();
-            
-            if ( ! messageBundleIds.contains(sqlStateId) ) {
-                // Don't fail out on the first one, we want to catch
-                // all of them.  Just note there was a failure and continue
-                System.err.println("ERROR: Message id " + sqlStateId +
-                    " in MessageId.java was not found in" +
-                    " messages_en.properties");                    
-             }
-        }
-    }
-     
-    /**
-     * See if there are any message ids in the message bundle that
-     * are <b>not</b> in SQLState.java or MessageId.java
-     */
-    public void testMessageBundleOrphanedMessages() throws Exception {
-        Iterator it = messageBundleIds.iterator();
-        
-        while (it.hasNext() ) {
-            String msgid = (String)it.next();
-            
-            if ( sqlStateIds.contains(msgid)) {
-                continue;
-            }
-            
-            if ( messageIdIds.contains(msgid)) {
-                continue;
-            }
-            
-            // Don't fail out on the first one, we want to catch
-            // all of them.  Just note there was a failure and continue
-            System.err.println("WARNING: Message id " + msgid + 
-                " in messages_en.properties is not " +
-                "referenced in either SQLState.java or MessageId.java");
-        }        
-    }
-}
+/*
+ 
+   Derby - Class org.apache.derbyTesting.functionTests.tests.i18n.MessageBundleTest
+ 
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+ 
+      http://www.apache.org/licenses/LICENSE-2.0
+ 
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ 
+ */
+
+package org.apache.derbyTesting.functionTests.tests.i18n;
+
+import org.apache.derbyTesting.junit.BaseTestCase;
+import org.apache.derby.shared.common.reference.SQLState;
+import org.apache.derby.shared.common.reference.MessageId;
+
+import java.util.HashSet;
+import java.lang.reflect.Field;
+import java.util.ResourceBundle;
+import java.util.Locale;
+import java.util.Iterator;
+
+/**
+ * This class does everything we can to validate that the messages_en.properties
+ * file is in synch with SQLState.java and MessageId.java.  We want to make sure
+ * that message ids defined in SQLState and MessageId have matching messages
+ * in the messages properties file, and also find out if there are any messages
+ * that don't have matching ids in the SQLState and MessageId files.   The
+ * first is a bug, the second is something to be aware of.
+ */
+public class MessageBundleTest extends BaseTestCase {
+    public MessageBundleTest(String name) {
+        super(name);
+    }
+
+    // The list of ids.  We use a HashSet so we can detect duplicates easily
+    static HashSet sqlStateIds          = new HashSet();
+    static HashSet messageIdIds         = new HashSet();
+    static HashSet messageBundleIds     = new HashSet();
+    
+    static {
+        try {
+            // Load all the ids for the SQLState class
+            loadClassIds(SQLState.class, sqlStateIds);
+
+            // Load all the ids for the MessageId class
+            loadClassIds(MessageId.class, messageIdIds);
+
+            // Load all the ids for the messages_en properties file
+            loadMessageBundleIds();
+        } catch ( Exception e ) {
+            e.printStackTrace();
+            throw new RuntimeException(e.getMessage());
+        }
+    }
+    
+    static void loadClassIds(Class idclass, HashSet set) throws Exception {
+        Field[] fields = idclass.getFields();
+        
+        int length = fields.length;
+        for ( int i = 0; i < length ; i++ )
+        {
+            String id = (String)fields[i].get(null);
+            
+            if ( id.length() == 2 ) {
+                // Skip past identifiers that are just categories
+                continue;
+            }
+            
+            // Skip past "special" SQL States that are not expected
+            // to have messages
+            if ( id.equals("close.C.1") )   continue;            
+            if ( id.equals("rwupd" ) )      continue;
+            if ( id.equals("02502" ) )      continue;
+            if ( id.equals("XSAX0") )       continue;
+            
+            if ( ! set.add(id) )
+            {
+                System.err.println("ERROR: The id " + id + 
+                    " was found twice in " + idclass.getName());
+            }
+        }
+    }
+            
+    /** 
+     * Load all the message ids from messages_en.properties into a HashSet.
+     * This assumes its available on the classpath
+     */
+    static void loadMessageBundleIds() throws Exception {
+        ResourceBundle bundle;
+        
+        // The messages_*.properties files are split into fifty separate
+        // message bundle files.  We need to load each one in turn
+        int numBundles = 50;
+        
+        for ( int i=0 ; i < numBundles ; i++ ) {
+            loadMessageBundle(i);
+        }
+    }
+    
+    static void loadMessageBundle(int index) {
+        String bundleName = "org.apache.derby.loc.m" + index;
+        
+        ResourceBundle bundle = 
+            ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
+
+        java.util.Enumeration keys = bundle.getKeys();
+
+        while ( keys.hasMoreElements() ) {
+            String key = (String)keys.nextElement();                
+
+            if ( ! messageBundleIds.add(key) ) {
+                System.err.println("ERROR: the key " + key +
+                    " exists twice in messages_en.properties");
+            }
+        }        
+    }
+
+    /**
+     * See if there are any message ids in SQLState.java that are
+     * not in the message bundle
+     */
+    public void testSQLStateOrphanedIds() throws Exception {
+        Iterator it = sqlStateIds.iterator();
+        
+        while ( it.hasNext() ) {
+            String sqlStateId = (String)it.next();
+            
+            if ( ! messageBundleIds.contains(sqlStateId) ) {
+                // Don't fail out on the first one, we want to catch
+                // all of them.  Just note there was a failure and continue
+                System.err.println("ERROR: Message id " + sqlStateId +
+                    " in SQLState.java was not found in" +
+                    " messages_en.properties");                     
+             }
+        }
+    }
+
+    /**
+     * See if there are any message ids in MessageId.java not in
+     * the message bundle
+     */
+    public void testMessageIdOrphanedIds() throws Exception {
+        Iterator it = messageIdIds.iterator();
+        
+        while ( it.hasNext() ) {
+            String sqlStateId = (String)it.next();
+            
+            if ( ! messageBundleIds.contains(sqlStateId) ) {
+                // Don't fail out on the first one, we want to catch
+                // all of them.  Just note there was a failure and continue
+                System.err.println("ERROR: Message id " + sqlStateId +
+                    " in MessageId.java was not found in" +
+                    " messages_en.properties");                    
+             }
+        }
+    }
+     
+    /**
+     * See if there are any message ids in the message bundle that
+     * are <b>not</b> in SQLState.java or MessageId.java
+     */
+    public void testMessageBundleOrphanedMessages() throws Exception {
+        Iterator it = messageBundleIds.iterator();
+        
+        while (it.hasNext() ) {
+            String msgid = (String)it.next();
+            
+            if ( sqlStateIds.contains(msgid)) {
+                continue;
+            }
+            
+            if ( messageIdIds.contains(msgid)) {
+                continue;
+            }
+            
+            // Don't fail out on the first one, we want to catch
+            // all of them.  Just note there was a failure and continue
+            System.err.println("WARNING: Message id " + msgid + 
+                " in messages_en.properties is not " +
+                "referenced in either SQLState.java or MessageId.java");
+        }        
+    }
+}
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/store/LogDeviceTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/store/LogDeviceTest.java
index 237232371..938226b57 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/store/LogDeviceTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/store/LogDeviceTest.java
@@ -1,229 +1,229 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.store.LogDeviceTest
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derbyTesting.functionTests.tests.store;
-import java.sql.Connection;
-import java.sql.Statement;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import org.apache.derby.tools.ij;
-import org.apache.derbyTesting.functionTests.util.TestUtil;
-import java.io.File;
-import java.io.IOException;
-
-/*
- * This class tests create database with transaction 
- * log at non-default location specified as absolute path.
- * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
- * @version 1.0
- */
-
-public class LogDeviceTest {
-
-	private static final String TEST_DATABASE_NAME = "wombat" ;
-    private static final String TEST_DATABASE_NAME1 = "wombat1" ;
-	private static final String TEST_TABLE_NAME   =    "emp";
-    private static final String LOG_PATH = "extinout/logDeviceTest_c1";
-    private static final String LOG_PATH1 = "extinout/logDeviceTest_c2";
-
-	public static void main(String[] argv) throws Throwable {
-		
-        LogDeviceTest test = new LogDeviceTest();
-   		ij.getPropertyArg(argv); 
-
-        try {
-            test.runTest();
-        }
-        catch (SQLException sqle) {
-			dumpSQLException(sqle);
-		} 
-    }
-
-    /*
-     * Returns the absolute path of the given path.
-     */
-    private String getFullPath(String path) throws IOException{
-        File f = new File(path);
-        return f.getCanonicalPath();
-    }
-
-
-    /*
-     * create a directory.
-     */
-    private boolean createDir(String path) {
-        File f = new File(path);
-        return f.mkdirs();
-    }
-
-
-
-	/*
-	 * Test database creation with log in non-default location.
-	 */
-	private void runTest() throws Exception {
-		logMessage("Begin Log Device Test");
-
-        // case 1: test logDevice property with absolute path
-
-        Connection conn;
-        String connAttr = "create=true;" + "logDevice=" + 
-                           getFullPath(LOG_PATH);
-        conn = TestUtil.getConnection(TEST_DATABASE_NAME, connAttr);
-        conn.setAutoCommit(false);
-        createTable(conn, TEST_TABLE_NAME);
-        conn.commit();
-        // just insert few rows and rollback and commit 
-        // to make sure  tranaction log is working fine. 
-        insert(conn, TEST_TABLE_NAME, 100);
-        conn.commit();
-        insert(conn, TEST_TABLE_NAME, 100);
-        conn.rollback();
-		// shutdown the test db 
-		shutdown(TEST_DATABASE_NAME);
-        
-        // case 2: database creation on non-empty 
-        // log dir location should fail.  
-
-        
-        try {
-            // this database creation is specifying the same log 
-            // location as the one above; so it should fail. 
-            conn = TestUtil.getConnection(TEST_DATABASE_NAME1, 
-                                          connAttr);
-        }catch (SQLException se) {
-            SQLException nse = se.getNextException();
-            if (nse != null) {
-                // expect to fail with log dir exists error.
-                if (nse.getSQLState().equals("XSLAT"))
-                    System.out.println("Failed with Expected error:" + 
-                                       nse.getSQLState());
-                else 
-                    dumpSQLException(se);
-            } else {
-                dumpSQLException(se);
-            }
-        }
-            
-        // case 3: database creation on an empty log dir should pass. 
-
-        // create a dummy log dir 
-        createDir(getFullPath(LOG_PATH1) + 
-                  File.separator + "log"); 
-        connAttr = "create=true;" + "logDevice=" + 
-                   getFullPath(LOG_PATH1);
-        conn = TestUtil.getConnection(TEST_DATABASE_NAME1, 
-                                      connAttr);
-        // just insert few rows and rollback and commit 
-        // to make sure  tranaction log is working fine. 
-        conn.setAutoCommit(false);
-        createTable(conn, TEST_TABLE_NAME);
-        conn.commit();
-        insert(conn, TEST_TABLE_NAME, 100);
-		// shutdown the test db 
-		shutdown(TEST_DATABASE_NAME1);
-        
-        // reconnect to the same database.
-        conn = TestUtil.getConnection(TEST_DATABASE_NAME1, null);
-        
-		logMessage("End log device Test");
-	}
-
-		
-	/**
-	 * Shutdown the datbase
-	 * @param  dbName  Name of the database to shutdown.
-	 */
-	private void shutdown(String dbName) {
-
-		try{
-			//shutdown
-			TestUtil.getConnection(dbName, "shutdown=true");
-		}catch(SQLException se){
-			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
-				System.out.println("database shutdown properly");
-			else
-				dumpSQLException(se);
-		}
-	}
-
-	/**
-	 * Write message to the standard output.
-	 */
-	private void logMessage(String   str)	{
-			System.out.println(str);
-	}
-
-	
-	/**
-	 * dump the SQLException to the standard output.
-	 */
-	static private void dumpSQLException(SQLException sqle) {
-		
-		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
-		sqle.printStackTrace(System.out);
-	}
-
-    /**
-     * Insert some rows into the specified table.
-     * @param  conn   connection to the database.    
-     * @param  tableName  name of the table that rows are inserted.
-     * @param  rowCount   Number of rows to Insert.
-     * @exception SQLException if any database exception occurs.
-     */
-    private void insert(Connection conn, 
-                        String tableName, 
-                        int rowCount) throws SQLException {
-
-        PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
-                                                     tableName + 
-                                                     " VALUES(?,?,?)");
-        for (int i = 0; i < rowCount; i++) {
-			
-            ps.setInt(1, i); // ID
-            ps.setString(2 , "skywalker" + i);
-            ps.setFloat(3, (float)(i * 2000)); 
-            ps.executeUpdate();
-		}
-        ps.close();
-    }
-
-
-    /* 
-     * create the tables that are used by this test.
-     * @param  conn   connection to the database.
-     * @param  tableName  Name of the table to create.
-     * @exception SQLException if any database exception occurs.
-     */
-    private	void createTable(Connection conn, 
-                             String tableName) throws SQLException {
-
-        Statement s = conn.createStatement();
-        s.executeUpdate("CREATE TABLE " + tableName + 
-                        "(id INT," +
-                        "name CHAR(200),"+ 
-                        "salary float)");
-        s.executeUpdate("create index " + tableName + "_id_idx on " + 
-                        tableName + "(id)");
-        s.close();
-    }
-}
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.store.LogDeviceTest
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.store;
+import java.sql.Connection;
+import java.sql.Statement;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import org.apache.derby.tools.ij;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
+import java.io.File;
+import java.io.IOException;
+
+/*
+ * This class tests create database with transaction 
+ * log at non-default location specified as absolute path.
+ * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
+ * @version 1.0
+ */
+
+public class LogDeviceTest {
+
+	private static final String TEST_DATABASE_NAME = "wombat" ;
+    private static final String TEST_DATABASE_NAME1 = "wombat1" ;
+	private static final String TEST_TABLE_NAME   =    "emp";
+    private static final String LOG_PATH = "extinout/logDeviceTest_c1";
+    private static final String LOG_PATH1 = "extinout/logDeviceTest_c2";
+
+	public static void main(String[] argv) throws Throwable {
+		
+        LogDeviceTest test = new LogDeviceTest();
+   		ij.getPropertyArg(argv); 
+
+        try {
+            test.runTest();
+        }
+        catch (SQLException sqle) {
+			dumpSQLException(sqle);
+		} 
+    }
+
+    /*
+     * Returns the absolute path of the given path.
+     */
+    private String getFullPath(String path) throws IOException{
+        File f = new File(path);
+        return f.getCanonicalPath();
+    }
+
+
+    /*
+     * create a directory.
+     */
+    private boolean createDir(String path) {
+        File f = new File(path);
+        return f.mkdirs();
+    }
+
+
+
+	/*
+	 * Test database creation with log in non-default location.
+	 */
+	private void runTest() throws Exception {
+		logMessage("Begin Log Device Test");
+
+        // case 1: test logDevice property with absolute path
+
+        Connection conn;
+        String connAttr = "create=true;" + "logDevice=" + 
+                           getFullPath(LOG_PATH);
+        conn = TestUtil.getConnection(TEST_DATABASE_NAME, connAttr);
+        conn.setAutoCommit(false);
+        createTable(conn, TEST_TABLE_NAME);
+        conn.commit();
+        // just insert few rows and rollback and commit 
+        // to make sure  tranaction log is working fine. 
+        insert(conn, TEST_TABLE_NAME, 100);
+        conn.commit();
+        insert(conn, TEST_TABLE_NAME, 100);
+        conn.rollback();
+		// shutdown the test db 
+		shutdown(TEST_DATABASE_NAME);
+        
+        // case 2: database creation on non-empty 
+        // log dir location should fail.  
+
+        
+        try {
+            // this database creation is specifying the same log 
+            // location as the one above; so it should fail. 
+            conn = TestUtil.getConnection(TEST_DATABASE_NAME1, 
+                                          connAttr);
+        }catch (SQLException se) {
+            SQLException nse = se.getNextException();
+            if (nse != null) {
+                // expect to fail with log dir exists error.
+                if (nse.getSQLState().equals("XSLAT"))
+                    System.out.println("Failed with Expected error:" + 
+                                       nse.getSQLState());
+                else 
+                    dumpSQLException(se);
+            } else {
+                dumpSQLException(se);
+            }
+        }
+            
+        // case 3: database creation on an empty log dir should pass. 
+
+        // create a dummy log dir 
+        createDir(getFullPath(LOG_PATH1) + 
+                  File.separator + "log"); 
+        connAttr = "create=true;" + "logDevice=" + 
+                   getFullPath(LOG_PATH1);
+        conn = TestUtil.getConnection(TEST_DATABASE_NAME1, 
+                                      connAttr);
+        // just insert few rows and rollback and commit 
+        // to make sure  tranaction log is working fine. 
+        conn.setAutoCommit(false);
+        createTable(conn, TEST_TABLE_NAME);
+        conn.commit();
+        insert(conn, TEST_TABLE_NAME, 100);
+		// shutdown the test db 
+		shutdown(TEST_DATABASE_NAME1);
+        
+        // reconnect to the same database.
+        conn = TestUtil.getConnection(TEST_DATABASE_NAME1, null);
+        
+		logMessage("End log device Test");
+	}
+
+		
+	/**
+	 * Shutdown the datbase
+	 * @param  dbName  Name of the database to shutdown.
+	 */
+	private void shutdown(String dbName) {
+
+		try{
+			//shutdown
+			TestUtil.getConnection(dbName, "shutdown=true");
+		}catch(SQLException se){
+			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
+				System.out.println("database shutdown properly");
+			else
+				dumpSQLException(se);
+		}
+	}
+
+	/**
+	 * Write message to the standard output.
+	 */
+	private void logMessage(String   str)	{
+			System.out.println(str);
+	}
+
+	
+	/**
+	 * dump the SQLException to the standard output.
+	 */
+	static private void dumpSQLException(SQLException sqle) {
+		
+		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
+		sqle.printStackTrace(System.out);
+	}
+
+    /**
+     * Insert some rows into the specified table.
+     * @param  conn   connection to the database.    
+     * @param  tableName  name of the table that rows are inserted.
+     * @param  rowCount   Number of rows to Insert.
+     * @exception SQLException if any database exception occurs.
+     */
+    private void insert(Connection conn, 
+                        String tableName, 
+                        int rowCount) throws SQLException {
+
+        PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
+                                                     tableName + 
+                                                     " VALUES(?,?,?)");
+        for (int i = 0; i < rowCount; i++) {
+			
+            ps.setInt(1, i); // ID
+            ps.setString(2 , "skywalker" + i);
+            ps.setFloat(3, (float)(i * 2000)); 
+            ps.executeUpdate();
+		}
+        ps.close();
+    }
+
+
+    /* 
+     * create the tables that are used by this test.
+     * @param  conn   connection to the database.
+     * @param  tableName  Name of the table to create.
+     * @exception SQLException if any database exception occurs.
+     */
+    private	void createTable(Connection conn, 
+                             String tableName) throws SQLException {
+
+        Statement s = conn.createStatement();
+        s.executeUpdate("CREATE TABLE " + tableName + 
+                        "(id INT," +
+                        "name CHAR(200),"+ 
+                        "salary float)");
+        s.executeUpdate("create index " + tableName + "_id_idx on " + 
+                        tableName + "(id)");
+        s.close();
+    }
+}
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql
index 058b6b36a..b62cd8be3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql
@@ -14,33 +14,33 @@
 --   See the License for the specific language governing permissions and
 --   limitations under the License.
 --
-drop table t1;
-create table t1 (i integer primary key, j integer, c char(200));
-insert into t1 values (1, 1, 'a');
-insert into t1 (select t1.i + 2,    t1.j + 2,    t1.c from t1);
-insert into t1 (select t1.i + 4,    t1.j + 4,    t1.c from t1);
-insert into t1 (select t1.i + 8,    t1.j + 8,    t1.c from t1);
-insert into t1 (select t1.i + 16,   t1.j + 16,   t1.c from t1);
-insert into t1 (select t1.i + 32,   t1.j + 32,   t1.c from t1);
-insert into t1 (select t1.i + 64,   t1.j + 64,   t1.c from t1);
-insert into t1 (select t1.i + 128,  t1.j + 128,  t1.c from t1);
-insert into t1 (select t1.i + 256,  t1.j + 256,  t1.c from t1);
-insert into t1 (select t1.i + 512,  t1.j + 512,  t1.c from t1);
-insert into t1 (select t1.i + 1024, t1.j + 1024, t1.c from t1);
-
-delete from t1 where j=1;
-
-CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
-
-delete from t1 where j=2;
-
-CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
-
-delete from t1 where i > 1024;
-
-CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
-
-delete from t1 where i < 512;
-
--- prior to the fix the following compress would result in a deadlock
-CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+drop table t1;
+create table t1 (i integer primary key, j integer, c char(200));
+insert into t1 values (1, 1, 'a');
+insert into t1 (select t1.i + 2,    t1.j + 2,    t1.c from t1);
+insert into t1 (select t1.i + 4,    t1.j + 4,    t1.c from t1);
+insert into t1 (select t1.i + 8,    t1.j + 8,    t1.c from t1);
+insert into t1 (select t1.i + 16,   t1.j + 16,   t1.c from t1);
+insert into t1 (select t1.i + 32,   t1.j + 32,   t1.c from t1);
+insert into t1 (select t1.i + 64,   t1.j + 64,   t1.c from t1);
+insert into t1 (select t1.i + 128,  t1.j + 128,  t1.c from t1);
+insert into t1 (select t1.i + 256,  t1.j + 256,  t1.c from t1);
+insert into t1 (select t1.i + 512,  t1.j + 512,  t1.c from t1);
+insert into t1 (select t1.i + 1024, t1.j + 1024, t1.c from t1);
+
+delete from t1 where j=1;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where j=2;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where i > 1024;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where i < 512;
+
+-- prior to the fix the following compress would result in a deadlock
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/tools/IJRunScriptTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/tools/IJRunScriptTest.java
index 95ee3f245..84086d730 100755
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/tools/IJRunScriptTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/tools/IJRunScriptTest.java
@@ -1,149 +1,149 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.tests.tools.IJRunScriptTest
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derbyTesting.functionTests.tests.tools;
-
-import java.io.UnsupportedEncodingException;
-import java.sql.Connection;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import junit.framework.Test;
-import junit.framework.TestSuite;
-
-import org.apache.derbyTesting.junit.BaseJDBCTestCase;
-import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
-
-/**
- * Test the ij.runScript api method.
- *
- */
-public class IJRunScriptTest extends BaseJDBCTestCase {
-    
-    public static Test suite()
-    {
-        TestSuite suite = new TestSuite("IJRunScriptTest");
-        suite.addTestSuite(IJRunScriptTest.class);
-        return new CleanDatabaseTestSetup(suite);
-    }
-    
-    public IJRunScriptTest(String name)
-    {
-        super(name);
-    }
-    
-    /**
-     * Test execution of scripts by executing them and
-     * seeing if the object exists.
-     * @throws SQLException
-     * @throws UnsupportedEncodingException 
-     */
-    public void testScriptExecution()
-        throws SQLException, UnsupportedEncodingException
-    {       
-        runTestingScript("CREATE TABLE T1(I INT);\nCREATE TABLE T2(I INT)", 0);
-        
-        // Check they exist by inserting rows.
-        
-        Statement s = createStatement();
-        
-        // Insert two rows into the first table
-        assertEquals(2, s.executeUpdate("INSERT INTO T1 VALUES 1,2"));
-
-        // Insert three rows into the second table
-        assertEquals(3, s.executeUpdate("INSERT INTO T2 VALUES 1,2,4"));
-        
-        runTestingScript("DROP TABLE T1;DROP TABLE T2", 0);
-               
-        s.close();
-    }
-
-    /**
-     * Test execution an empty script.
-     * @throws SQLException
-     * @throws UnsupportedEncodingException 
-     */
-    public void testEmptyScript()
-        throws SQLException, UnsupportedEncodingException
-    {       
-        runTestingScript("", 0);
-    }   
-
-    /**
-     * Test execution of the IJ AUTOCOMMIT statement.
-     * @throws SQLException
-     * @throws UnsupportedEncodingException 
-     */
-    public void testAutoCommitCommand()
-        throws SQLException, UnsupportedEncodingException
-    {      
-        Connection conn = getConnection();
-        assertTrue(conn.getAutoCommit());
-        runTestingScript("AUTOCOMMIT OFF;", 0);
-        
-        assertFalse(conn.isClosed());
-        assertFalse(conn.getAutoCommit());
-    }
-    
-    /**
-     * Test error counting.
-     * @throws SQLException
-     * @throws UnsupportedEncodingException 
-     */
-    public void testErrorsCount()
-        throws SQLException, UnsupportedEncodingException
-    {      
-       // just a single error
-       runTestingScript("CREATE TAAABLE T (I INT);", 1);
-       runTestingScript("INSERT INTO TIJ VALUES 1;", 1);
-
-       // two errors
-       runTestingScript("INSERT INTO TIJ VALUES 1;\nDELETE FROM SYS.SYSTABLES", 2);
-       runTestingScript("INSERT INTO TIJ VALUES 1;DELETE FROM SYS.SYSTABLES", 2);
-       
-       // mixture of errors (two in all)
-       runTestingScript("CREATX TABLE TIJME(I INT);CREATE TABLE TIJME(I INT);" +
-               "INSERT INTO TIJME VALUES 1,3,4;" +
-               "INSERT INTO TIJME VALUESS 1,3,4;" +
-               "DROP TABLE TIJME"
-               , 2);
-       
-   }
-        
-
-    /**
-     * Run a test script using the passed in String as the source
-     * for the script. Script is run using the UTF-8 encoding and
-     * the output discarded.
-     * @param script
-     * @return error count from ij.runScript.
-     * @throws UnsupportedEncodingException
-     * @throws SQLException
-     */
-    private void runTestingScript(String script, int expectedErrorCount)
-        throws UnsupportedEncodingException, SQLException
-    {       
-        int errorCount = runSQLCommands(script);
-        assertEquals("Error count on " + script,
-                expectedErrorCount, errorCount );
-    }
-    
-}
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.tests.tools.IJRunScriptTest
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.tools;
+
+import java.io.UnsupportedEncodingException;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+import org.apache.derbyTesting.junit.BaseJDBCTestCase;
+import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
+
+/**
+ * Test the ij.runScript api method.
+ *
+ */
+public class IJRunScriptTest extends BaseJDBCTestCase {
+    
+    public static Test suite()
+    {
+        TestSuite suite = new TestSuite("IJRunScriptTest");
+        suite.addTestSuite(IJRunScriptTest.class);
+        return new CleanDatabaseTestSetup(suite);
+    }
+    
+    public IJRunScriptTest(String name)
+    {
+        super(name);
+    }
+    
+    /**
+     * Test execution of scripts by executing them and
+     * seeing if the object exists.
+     * @throws SQLException
+     * @throws UnsupportedEncodingException 
+     */
+    public void testScriptExecution()
+        throws SQLException, UnsupportedEncodingException
+    {       
+        runTestingScript("CREATE TABLE T1(I INT);\nCREATE TABLE T2(I INT)", 0);
+        
+        // Check they exist by inserting rows.
+        
+        Statement s = createStatement();
+        
+        // Insert two rows into the first table
+        assertEquals(2, s.executeUpdate("INSERT INTO T1 VALUES 1,2"));
+
+        // Insert three rows into the second table
+        assertEquals(3, s.executeUpdate("INSERT INTO T2 VALUES 1,2,4"));
+        
+        runTestingScript("DROP TABLE T1;DROP TABLE T2", 0);
+               
+        s.close();
+    }
+
+    /**
+     * Test execution an empty script.
+     * @throws SQLException
+     * @throws UnsupportedEncodingException 
+     */
+    public void testEmptyScript()
+        throws SQLException, UnsupportedEncodingException
+    {       
+        runTestingScript("", 0);
+    }   
+
+    /**
+     * Test execution of the IJ AUTOCOMMIT statement.
+     * @throws SQLException
+     * @throws UnsupportedEncodingException 
+     */
+    public void testAutoCommitCommand()
+        throws SQLException, UnsupportedEncodingException
+    {      
+        Connection conn = getConnection();
+        assertTrue(conn.getAutoCommit());
+        runTestingScript("AUTOCOMMIT OFF;", 0);
+        
+        assertFalse(conn.isClosed());
+        assertFalse(conn.getAutoCommit());
+    }
+    
+    /**
+     * Test error counting.
+     * @throws SQLException
+     * @throws UnsupportedEncodingException 
+     */
+    public void testErrorsCount()
+        throws SQLException, UnsupportedEncodingException
+    {      
+       // just a single error
+       runTestingScript("CREATE TAAABLE T (I INT);", 1);
+       runTestingScript("INSERT INTO TIJ VALUES 1;", 1);
+
+       // two errors
+       runTestingScript("INSERT INTO TIJ VALUES 1;\nDELETE FROM SYS.SYSTABLES", 2);
+       runTestingScript("INSERT INTO TIJ VALUES 1;DELETE FROM SYS.SYSTABLES", 2);
+       
+       // mixture of errors (two in all)
+       runTestingScript("CREATX TABLE TIJME(I INT);CREATE TABLE TIJME(I INT);" +
+               "INSERT INTO TIJME VALUES 1,3,4;" +
+               "INSERT INTO TIJME VALUESS 1,3,4;" +
+               "DROP TABLE TIJME"
+               , 2);
+       
+   }
+        
+
+    /**
+     * Run a test script using the passed in String as the source
+     * for the script. Script is run using the UTF-8 encoding and
+     * the output discarded.
+     * @param script
+     * @return error count from ij.runScript.
+     * @throws UnsupportedEncodingException
+     * @throws SQLException
+     */
+    private void runTestingScript(String script, int expectedErrorCount)
+        throws UnsupportedEncodingException, SQLException
+    {       
+        int errorCount = runSQLCommands(script);
+        assertEquals("Error count on " + script,
+                expectedErrorCount, errorCount );
+    }
+    
+}
diff --git a/java/testing/org/apache/derbyTesting/junit/SystemPropertyTestSetup.java b/java/testing/org/apache/derbyTesting/junit/SystemPropertyTestSetup.java
index 12686e62f..9fb43e93d 100644
--- a/java/testing/org/apache/derbyTesting/junit/SystemPropertyTestSetup.java
+++ b/java/testing/org/apache/derbyTesting/junit/SystemPropertyTestSetup.java
@@ -1,115 +1,115 @@
-/*
- *
- * Derby - Class org.apache.derbyTesting.functionTests.util.SystemPropertyTestSetup
- *
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, 
- * software distributed under the License is distributed on an 
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
- * either express or implied. See the License for the specific 
- * language governing permissions and limitations under the License.
- */
-package org.apache.derbyTesting.junit;
-
-import java.security.PrivilegedActionException;
-import java.util.Enumeration;
-import java.util.Properties;
-
-
-import junit.extensions.TestSetup;
-import junit.framework.Test;
-
-/**
- * Test decorator to set a set of system properties on setUp
- * and restore them to the previous values on tearDown.
- *
- */
-public class SystemPropertyTestSetup extends TestSetup {
-	
-	private Properties newValues;
-	private Properties oldValues;
-	
-	/**
-	 * Create a test decorator that sets and restores the passed
-	 * in properties. Assumption is that the contents of
-	 * properties and values will not change during execution.
-	 * @param test test to be decorated
-	 * @param newValues properties to be set
-	 */
-	public SystemPropertyTestSetup(Test test,
-			Properties newValues)
-	{
-		super(test);
-		this.newValues = newValues;
-		this.oldValues = new Properties();
-	}
-
-	/**
-	 * For each property store the current value and
-	 * replace it with the new value, unless there is no change.
-	 */
-    protected void setUp()
-    throws java.lang.Exception
-    {
-    	setProperties(newValues);
-    }
-
-    /**
-     * Revert the properties to their values prior to the setUp call.
-     */
-    protected void tearDown()
-    throws java.lang.Exception
-    {
-    	// Clear all the system properties set by the new set
-    	// that will not be reset by the old set.
-       	for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
-       	{
-       		String key = (String) e.nextElement();
-       		if (oldValues.getProperty(key) == null)
-       		    BaseTestCase.removeSystemProperty(key);
-       	}
-    	// and then reset nay old values
-    	setProperties(oldValues);
-        newValues = null;
-        oldValues = null;
-    }
-    
-    private void setProperties(Properties values)
-        throws PrivilegedActionException
-    {
-    	for (Enumeration e = values.propertyNames(); e.hasMoreElements();)
-    	{
-    		String key = (String) e.nextElement();
-    		String value = values.getProperty(key);
-    		String old = BaseTestCase.getSystemProperty(key);
-    		
-    		boolean change;
-    		if (old != null)
-    		{
-                // set, might need to be changed.
-                change = !old.equals(value);
-                
-                // If we are not processing the oldValues
-                // then store in the oldValues. Reference equality is ok here.
-    			if (change && (values != oldValues))
-    			   oldValues.setProperty(key, old);
-    		}
-    		else {
-    			// notset, needs to be set
-    			change = true;
-    		}
-    		
-    		if (change) {
-    			BaseTestCase.setSystemProperty(key, value);
-    		}
-    	}
-    }
-}
+/*
+ *
+ * Derby - Class org.apache.derbyTesting.functionTests.util.SystemPropertyTestSetup
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, 
+ * software distributed under the License is distributed on an 
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+ * either express or implied. See the License for the specific 
+ * language governing permissions and limitations under the License.
+ */
+package org.apache.derbyTesting.junit;
+
+import java.security.PrivilegedActionException;
+import java.util.Enumeration;
+import java.util.Properties;
+
+
+import junit.extensions.TestSetup;
+import junit.framework.Test;
+
+/**
+ * Test decorator to set a set of system properties on setUp
+ * and restore them to the previous values on tearDown.
+ *
+ */
+public class SystemPropertyTestSetup extends TestSetup {
+	
+	private Properties newValues;
+	private Properties oldValues;
+	
+	/**
+	 * Create a test decorator that sets and restores the passed
+	 * in properties. Assumption is that the contents of
+	 * properties and values will not change during execution.
+	 * @param test test to be decorated
+	 * @param newValues properties to be set
+	 */
+	public SystemPropertyTestSetup(Test test,
+			Properties newValues)
+	{
+		super(test);
+		this.newValues = newValues;
+		this.oldValues = new Properties();
+	}
+
+	/**
+	 * For each property store the current value and
+	 * replace it with the new value, unless there is no change.
+	 */
+    protected void setUp()
+    throws java.lang.Exception
+    {
+    	setProperties(newValues);
+    }
+
+    /**
+     * Revert the properties to their values prior to the setUp call.
+     */
+    protected void tearDown()
+    throws java.lang.Exception
+    {
+    	// Clear all the system properties set by the new set
+    	// that will not be reset by the old set.
+       	for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
+       	{
+       		String key = (String) e.nextElement();
+       		if (oldValues.getProperty(key) == null)
+       		    BaseTestCase.removeSystemProperty(key);
+       	}
+    	// and then reset nay old values
+    	setProperties(oldValues);
+        newValues = null;
+        oldValues = null;
+    }
+    
+    private void setProperties(Properties values)
+        throws PrivilegedActionException
+    {
+    	for (Enumeration e = values.propertyNames(); e.hasMoreElements();)
+    	{
+    		String key = (String) e.nextElement();
+    		String value = values.getProperty(key);
+    		String old = BaseTestCase.getSystemProperty(key);
+    		
+    		boolean change;
+    		if (old != null)
+    		{
+                // set, might need to be changed.
+                change = !old.equals(value);
+                
+                // If we are not processing the oldValues
+                // then store in the oldValues. Reference equality is ok here.
+    			if (change && (values != oldValues))
+    			   oldValues.setProperty(key, old);
+    		}
+    		else {
+    			// notset, needs to be set
+    			change = true;
+    		}
+    		
+    		if (change) {
+    			BaseTestCase.setSystemProperty(key, value);
+    		}
+    	}
+    }
+}
