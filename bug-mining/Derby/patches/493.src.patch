diff --git a/java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java b/java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java
index a8074b419..7aed913dc 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java
@@ -511,9 +511,10 @@ public final class UpdateNode extends DMLModStatementNode
 
 		/*
 		 * The last thing that we do to the generated RCL is to clear
-		 * the table name out from each RC. See comment on scrubResultColumns().
+		 * the table name out from each RC. See comment on 
+		 * checkTableNameAndScrubResultColumns().
 		 */
-		scrubResultColumns( resultColumnList );
+		checkTableNameAndScrubResultColumns(resultColumnList);
 
 		/* Set the new result column list in the result set */
 		resultSet.setResultColumns(resultColumnList);
@@ -1007,20 +1008,6 @@ public final class UpdateNode extends DMLModStatementNode
 		return	columnMap;
 	}
 
-	private	void	scrubResultColumns( ResultColumnList rcl )
-	{
-		/* The table name is
-		 * unnecessary for an update.  More importantly, though, it
-		 * creates a problem in the degenerate case with a positioned
-		 * update.  The user must specify the base table name for a
-		 * positioned update.  If a correlation name was specified for
-		 * the cursor, then a match for the ColumnReference would not
-		 * be found if we didn't null out the name.  (Aren't you
-		 * glad you asked?)
-		 */
-		rcl.clearTableNames();
-	}
-
 	/*
 	 * Force correlated column references in the SET clause to have the
 	 * name of the base table. This dances around the problem alluded to
@@ -1053,5 +1040,59 @@ public final class UpdateNode extends DMLModStatementNode
 		}
 		
 	}
+
+	/**
+	 * Check table name and then clear it from the result set columns.
+	 * 
+	 * @exception StandardExcepion if invalid column/table is specified.
+	 */
+	private void checkTableNameAndScrubResultColumns(ResultColumnList rcl) 
+			throws StandardException
+	{
+		int columnCount = rcl.size();
+		int tableCount = ((SelectNode)resultSet).fromList.size();
+
+		for ( int i = 0; i < columnCount; i++ )
+		{
+			boolean foundMatchingTable = false;			
+			ResultColumn	column = (ResultColumn) rcl.elementAt( i );
+
+			if (column.getTableName() != null) {
+				for (int j = 0; j < tableCount; j++) {
+					FromTable fromTable = (FromTable) ((SelectNode)resultSet).
+							fromList.elementAt(j);
+					final String tableName;
+					if ( fromTable instanceof CurrentOfNode ) { 
+						tableName = ((CurrentOfNode)fromTable).
+								getBaseCursorTargetTableName().getTableName();
+					} else { 
+						tableName = fromTable.getBaseTableName();
+					}
+
+					if (column.getTableName().equals(tableName)) {
+						foundMatchingTable = true;
+						break;
+					}
+				}
+
+				if (!foundMatchingTable) {
+					throw StandardException.newException(
+							SQLState.LANG_COLUMN_NOT_FOUND, 
+							column.getTableName() + "." + column.getName());
+				}
+			}
+
+			/* The table name is
+			 * unnecessary for an update.  More importantly, though, it
+			 * creates a problem in the degenerate case with a positioned
+			 * update.  The user must specify the base table name for a
+			 * positioned update.  If a correlation name was specified for
+			 * the cursor, then a match for the ColumnReference would not
+			 * be found if we didn't null out the name.  (Aren't you
+			 * glad you asked?)
+			 */
+			column.clearTableName();
+		}
+	}
 	
 } // end of UpdateNode
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/update.out b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
index 0c17a1927..03f4b980d 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/update.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
@@ -565,4 +565,28 @@ ij> drop table BASICTABLE1;
 0 rows inserted/updated/deleted
 ij> drop table BASICTABLE2;
 0 rows inserted/updated/deleted
-ij> 
+ij> -- tests for DERBY-1043
+CREATE TABLE DERBY10431 (ID SMALLINT GENERATED ALWAYS AS IDENTITY, A_COL VARCHAR(15) NOT NULL PRIMARY KEY);
+0 rows inserted/updated/deleted
+ij> CREATE TABLE DERBY10432 (TYPE VARCHAR(15) NOT NULL, A_COL VARCHAR(15) NOT NULL, AMOUNT SMALLINT NOT NULL DEFAULT 0);
+0 rows inserted/updated/deleted
+ij> INSERT INTO DERBY10431(A_COL) VALUES ('apples');
+1 row inserted/updated/deleted
+ij> INSERT INTO DERBY10432 VALUES ('tree fruit','apples',1);
+1 row inserted/updated/deleted
+ij> SELECT * FROM DERBY10431;
+ID    |A_COL          
+----------------------
+1     |apples         
+ij> SELECT * FROM DERBY10432;
+TYPE           |A_COL          |AMOUNT
+--------------------------------------
+tree fruit     |apples         |1     
+ij> -- after fix for DERBY-1043 this update should cause an exception
+UPDATE DERBY10432 SET DERBY10432.A_COL = DERBY10431.A_COL WHERE A_COL = 'apples';
+ERROR 42X04: Column 'DERBY10431.A_COL' is either not in any table in the FROM list or appears within a join specification and is outside the scope of the join specification or appears in a HAVING clause and is not in the GROUP BY list. If this is a CREATE or ALTER TABLE  statement then 'DERBY10431.A_COL' is not a column in the target table.
+ij> DROP TABLE DERBY10431;
+0 rows inserted/updated/deleted
+ij> DROP TABLE DERBY10432;
+0 rows inserted/updated/deleted
+ij> 
\ No newline at end of file
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
index a647b08e5..d13487e40 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/update.sql
@@ -341,3 +341,19 @@ select * from BASICTABLE2;
 rollback;
 drop table BASICTABLE1;
 drop table BASICTABLE2;
+
+-- tests for DERBY-1043
+CREATE TABLE DERBY10431 (ID SMALLINT GENERATED ALWAYS AS IDENTITY, A_COL VARCHAR(15) NOT NULL PRIMARY KEY);
+CREATE TABLE DERBY10432 (TYPE VARCHAR(15) NOT NULL, A_COL VARCHAR(15) NOT NULL, AMOUNT SMALLINT NOT NULL DEFAULT 0);
+
+INSERT INTO DERBY10431(A_COL) VALUES ('apples');
+INSERT INTO DERBY10432 VALUES ('tree fruit','apples',1);
+
+SELECT * FROM DERBY10431;
+SELECT * FROM DERBY10432;
+
+-- after fix for DERBY-1043 this update should cause an exception
+UPDATE DERBY10432 SET DERBY10432.A_COL = DERBY10431.A_COL WHERE A_COL = 'apples';
+
+DROP TABLE DERBY10431;
+DROP TABLE DERBY10432;
\ No newline at end of file
