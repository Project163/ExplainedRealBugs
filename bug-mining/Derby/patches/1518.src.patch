diff --git a/java/client/org/apache/derby/client/ClientPooledConnection.java b/java/client/org/apache/derby/client/ClientPooledConnection.java
index 6a2595f3d..f2f8afa48 100644
--- a/java/client/org/apache/derby/client/ClientPooledConnection.java
+++ b/java/client/org/apache/derby/client/ClientPooledConnection.java
@@ -242,7 +242,7 @@ public class ClientPooledConnection implements javax.sql.PooledConnection {
             	// to reset the connection state to the default on 
             	// PooledConnection.getConnection() otherwise the 
             	// isolation level and holdability was not correct and out of sync with the server.
-                physicalConnection_.reset(logWriter_, true);
+                physicalConnection_.reset(logWriter_);
             }
             else {
                 physicalConnection_.lightReset();    //poolfix
diff --git a/java/client/org/apache/derby/client/am/Connection.java b/java/client/org/apache/derby/client/am/Connection.java
index 99992eddc..034be5bad 100644
--- a/java/client/org/apache/derby/client/am/Connection.java
+++ b/java/client/org/apache/derby/client/am/Connection.java
@@ -270,30 +270,23 @@ public abstract class Connection implements java.sql.Connection,
     }
 
     // This is a callback method, called by subsystem - NetConnection
-    protected void resetConnection(LogWriter logWriter,
-                                   boolean recomputeFromDataSource) throws SqlException {
+    protected void resetConnection(LogWriter logWriter)
+            throws SqlException {
         // Transaction isolation level is handled in completeReset.
         // clearWarningsX() will re-initialize the following properties
         clearWarningsX();
 
-        if (recomputeFromDataSource) { // no need to reinitialize connection state if ds hasn't changed
-            // property encryptionManager_
-            // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
-            encryptionManager_ = null;
-
-            // property: open_
-            // this should already be true
+        // property encryptionManager_
+        // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
+        encryptionManager_ = null;
 
-            currentSchemaName_ = null;
-            autoCommit_ = true;
-            inUnitOfWork_ = false;
-            holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
-        }
+        currentSchemaName_ = null;
+        autoCommit_ = true;
+        inUnitOfWork_ = false;
+        holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
 
-        
-        if (recomputeFromDataSource) {
-            this.agent_.resetAgent(this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
-        }
+        this.agent_.resetAgent(
+                this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
     }
 
     // For jdbc 1 connections
@@ -2090,14 +2083,14 @@ public abstract class Connection implements java.sql.Connection,
     // can this be called in a unit of work
     // can this be called from within a stored procedure
     //
-    synchronized public void reset(LogWriter logWriter, 
-            boolean recomputeFromDataSource) throws SqlException {
+    synchronized public void reset(LogWriter logWriter)
+            throws SqlException {
         if (logWriter != null) {
             logWriter.traceConnectResetEntry(this, logWriter, user_, 
                                              dataSource_);
         }
         try {
-            reset_(logWriter, recomputeFromDataSource);
+            reset_(logWriter);
         } catch (SqlException sqle) {
             DisconnectException de = new DisconnectException(agent_, 
                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_RESET));
@@ -2114,8 +2107,7 @@ public abstract class Connection implements java.sql.Connection,
         availableForReuse_ = false;
     }
 
-    abstract protected void reset_(LogWriter logWriter, 
-            boolean recomputerFromDataSource) throws SqlException;
+    abstract protected void reset_(LogWriter logWriter) throws SqlException;
 
     /**
      * <br>NOTE:</br>The following comments are valid for the changes done as
@@ -2126,13 +2118,15 @@ public abstract class Connection implements java.sql.Connection,
      * forces us to go to the server all the time. Since the value should now
      * be valid (DERBY-3192), we check if it has been changed from the default.
      *
-     * @param recomputeFromDataSource is now used to differentiate between
+     * @param closeStatementsOnClose is used to differentiate between
      *      cases where statement pooling is enabled or not. If {@code true}, it
      *      means statement pooling is disabled and the statements are fully
      *      reset, which includes a re-prepare. If {@code false}, statement
      *      pooling is enabled, and a more lightweight reset procedure is used.
      */
-    protected void completeReset(boolean isDeferredReset, boolean recomputeFromDataSource) throws SqlException {
+    protected void completeReset(boolean isDeferredReset,
+                                 boolean closeStatementsOnClose)
+            throws SqlException {
         open_ = true;
 
         completeLocalRollback(); // this will close the cursors if the physical connection hadn't been closed for reuse properly
@@ -2141,14 +2135,14 @@ public abstract class Connection implements java.sql.Connection,
         // Notice that these physical statements may not belong to this logical connection.
         // Iterate through the physical statements and re-enable them for reuse.
 
-        if (recomputeFromDataSource) {
+        if (closeStatementsOnClose) {
             // NOTE: This is to match previous behavior.
             //       Investigate and check if it is really necessary.
             this.isolation_ = TRANSACTION_UNKNOWN;
             java.util.Set keySet = openStatements_.keySet();
             for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
                 Object o = i.next();
-                ((Statement) o).reset(recomputeFromDataSource);
+                ((Statement) o).reset(closeStatementsOnClose);
             }
         } else {
             // Must reset transaction isolation level if it has been changed.
diff --git a/java/client/org/apache/derby/client/net/NetConnection.java b/java/client/org/apache/derby/client/net/NetConnection.java
index 4664d5aa0..8bffb0084 100644
--- a/java/client/org/apache/derby/client/net/NetConnection.java
+++ b/java/client/org/apache/derby/client/net/NetConnection.java
@@ -34,7 +34,6 @@ import org.apache.derby.shared.common.i18n.MessageUtil;
 import org.apache.derby.client.am.Statement;
 import org.apache.derby.client.am.Utils;
 import org.apache.derby.jdbc.ClientBaseDataSource;
-import org.apache.derby.jdbc.ClientDataSource;
 import org.apache.derby.jdbc.ClientDriver;
 import org.apache.derby.client.ClientPooledConnection;
 
@@ -306,43 +305,40 @@ public class NetConnection extends org.apache.derby.client.am.Connection {
 
     // preferably without password in the method signature.
     // We can probally get rid of flowReconnect method.
-    public void resetNetConnection(org.apache.derby.client.am.LogWriter logWriter,
-                                   boolean recomputeFromDataSource) throws SqlException {
-        super.resetConnection(logWriter, recomputeFromDataSource);
+    public void resetNetConnection(org.apache.derby.client.am.LogWriter logWriter)
+            throws SqlException {
+        super.resetConnection(logWriter);
         //----------------------------------------------------
-        if (recomputeFromDataSource) {
-            // do not reset managers on a connection reset.  this information shouldn't
-            // change and can be used to check secmec support.
-
-            targetExtnam_ = null;
-            targetSrvclsnm_ = null;
-            targetSrvnam_ = null;
-            targetSrvrlslv_ = null;
-            publicKey_ = null;
-            targetPublicKey_ = null;
-            sourceSeed_ = null;
-            targetSeed_ = null;
-            targetSecmec_ = 0;
-            resetConnectionAtFirstSql_ = false;
-
-        }
+        // do not reset managers on a connection reset.  this information shouldn't
+        // change and can be used to check secmec support.
+
+        targetExtnam_ = null;
+        targetSrvclsnm_ = null;
+        targetSrvnam_ = null;
+        targetSrvrlslv_ = null;
+        publicKey_ = null;
+        targetPublicKey_ = null;
+        sourceSeed_ = null;
+        targetSeed_ = null;
+        targetSecmec_ = 0;
+        resetConnectionAtFirstSql_ = false;
         // properties prddta_ and crrtkn_ will be initialized by
         // calls to constructPrddta() and constructCrrtkn()
         //----------------------------------------------------------
         boolean isDeferredReset = flowReconnect(getDeferredResetPassword(),
                                                 securityMechanism_);
-        completeReset(isDeferredReset, recomputeFromDataSource);
+        completeReset(isDeferredReset);
     }
 
 
-    protected void reset_(org.apache.derby.client.am.LogWriter logWriter,
-                          boolean recomputeFromDataSource) throws SqlException {
+    protected void reset_(org.apache.derby.client.am.LogWriter logWriter)
+            throws SqlException {
         if (inUnitOfWork_) {
             throw new SqlException(logWriter, 
                 new ClientMessageId(
                     SQLState.NET_CONNECTION_RESET_NOT_ALLOWED_IN_UNIT_OF_WORK));
         }
-        resetNetConnection(logWriter, recomputeFromDataSource);
+        resetNetConnection(logWriter);
     }
 
     java.util.List getSpecialRegisters() {
@@ -363,13 +359,9 @@ public class NetConnection extends org.apache.derby.client.am.Connection {
         super.completeConnect();
     }
 
-    protected void completeReset(boolean isDeferredReset, boolean recomputeFromDataSource) throws SqlException {
-        // NB! Override the recomputFromDataSource flag.
-        //     This was done as a temporary, minimal intrusive fix to support
-        //     JDBC statement pooling.
-        //     See DERBY-3341 for details.
-        super.completeReset(isDeferredReset,
-                recomputeFromDataSource && closeStatementsOnClose);
+    protected void completeReset(boolean isDeferredReset)
+            throws SqlException {
+        super.completeReset(isDeferredReset, closeStatementsOnClose);
     }
 
     public void flowConnect(String password,
