diff --git a/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java b/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
index 73ad422ef..2cb75d9c0 100644
--- a/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
+++ b/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
@@ -498,6 +498,15 @@ public interface LanguageConnectionContext extends Context {
 	 */
 	public String getCurrentSchemaName(Activation a);
 
+
+	/**
+	 * Return true if this schema name is the initial default schema for the
+	 * current session.
+	 * @param schemaName 
+	 * @return true
+	 */
+	public boolean isInitialDefaultSchema(String schemaName);
+
 	/**
 	 * Get the identity column value most recently generated.
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
index fa78022a9..c0d02e16b 100644
--- a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
+++ b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
@@ -1853,6 +1853,16 @@ public class GenericLanguageConnectionContext
 		return s.getSchemaName();
 	}
 
+
+	/**
+	 * @see LanguageConnectionContext#isInitialDefaultSchema
+	 */
+	public boolean isInitialDefaultSchema(String schemaName) {
+		return cachedInitialDefaultSchemaDescr.getSchemaName().
+			equals(schemaName);
+	}
+
+
 	/**
 	 * @see LanguageConnectionContext#setDefaultSchema(SchemaDescriptor sd)
 	 */
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
index 27d97e25a..41b95698a 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
@@ -104,81 +104,98 @@ abstract class DDLConstantAction implements ConstantAction
             CreateSchemaConstantAction csca
                 = new CreateSchemaConstantAction(schemaName, (String) null);
 
-			// DERBY-48: This operation creates a schema and we don't
-			// want to hold a lock for SYSSCHEMAS for the duration of
-			// the user transaction, so we perform the creation in a
-			// nested transaction if possible.
-			TransactionController useTc    = null;
-			TransactionController nestedTc = null;
+			if (activation.getLanguageConnectionContext().
+					isInitialDefaultSchema(schemaName)) {
+				// DERBY-48: This operation creates the user's initial default
+				// schema and we don't want to hold a lock for SYSSCHEMAS for
+				// the duration of the user transaction, so we perform the
+				// creation in a nested transaction if possible.
+				TransactionController useTc    = null;
+				TransactionController nestedTc = null;
 
-			try {
-				nestedTc = tc.startNestedUserTransaction(false);
-				useTc = nestedTc;
-			} catch (StandardException e) {
-				if (SanityManager.DEBUG) {
-					SanityManager.THROWASSERT(
-						"Unexpected: not able to start nested transaction " +
-						"to auto-create schema", e);
+				try {
+					nestedTc = tc.startNestedUserTransaction(false);
+					useTc = nestedTc;
+				} catch (StandardException e) {
+					if (SanityManager.DEBUG) {
+						SanityManager.THROWASSERT(
+							"Unexpected: not able to start nested transaction " +
+							"to auto-create schema", e);
+					}
+					useTc = tc;
 				}
-				useTc = tc;
-			}
 
-			// Try max twice: if nested transaction times out, try
-			// again in the outer transaction because it may be a
-			// self-lock, that is, the outer transaction may hold some
-			// lock(s) that make the nested transaction attempt to set
-			// a write lock time out.  Trying it again in the outer
-			// transaction will then succeed. If the reason is some
-			// other transaction barring us, trying again in the outer
-			// transaction will possibly time out again.
-			//
-			// Also, if creating a nested transaction failed, only try
-			// once in the outer transaction.
-			while (true) {
-				try {
-					csca.executeConstantAction(activation, useTc);
-				} catch (StandardException se) {
-					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
-						// We don't test for SQLState.DEADLOCK or
-						// .LOCK_TIMEOUT_LOG here because a) if it is a
-						// deadlock, it may be better to expose it, and b)
-						// LOCK_TIMEOUT_LOG happens when the app has set
-						// derby.locks.deadlockTrace=true, in which case we
-						// don't want to mask the timeout.  So in both the
-						// latter cases we just throw.
-						if (useTc == nestedTc) {
+				// Try max twice: if nested transaction times out, try
+				// again in the outer transaction because it may be a
+				// self-lock, that is, the outer transaction may hold some
+				// lock(s) that make the nested transaction attempt to set
+				// a write lock time out.  Trying it again in the outer
+				// transaction will then succeed. If the reason is some
+				// other transaction barring us, trying again in the outer
+				// transaction will possibly time out again.
+				//
+				// Also, if creating a nested transaction failed, only try
+				// once in the outer transaction.
+				while (true) {
+					try {
+						csca.executeConstantAction(activation, useTc);
+					} catch (StandardException se) {
+						if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
+							// We don't test for SQLState.DEADLOCK or
+							// .LOCK_TIMEOUT_LOG here because a) if it is a
+							// deadlock, it may be better to expose it, and b)
+							// LOCK_TIMEOUT_LOG happens when the app has set
+							// derby.locks.deadlockTrace=true, in which case we
+							// don't want to mask the timeout.  So in both the
+							// latter cases we just throw.
+							if (useTc == nestedTc) {
 
-							// clean up after use of nested transaction,
-							// then try again in outer transaction
-							useTc = tc;
+								// clean up after use of nested transaction,
+								// then try again in outer transaction
+								useTc = tc;
+								nestedTc.destroy();
+								continue;
+							}
+						} else if (se.getMessageId()
+									   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
+							// Ignore "Schema already exists". Another thread has
+							// probably created it after we checked for it
+							break;
+						}
+
+						// We got an non-expected exception, either in
+						// the nested transaction or in the outer
+						// transaction; we had better pass that on
+						if (useTc == nestedTc) {
 							nestedTc.destroy();
-							continue;
 						}
-					} else if (se.getMessageId()
+
+						throw se;
+					}
+					break;
+				}
+
+				// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
+				// Clean up if we did this in a nested transaction.
+				if (useTc == nestedTc) {
+					nestedTc.commit();
+					nestedTc.destroy();
+				}
+			} else {
+				// create the schema in the user transaction always
+				try {
+					csca.executeConstantAction(activation);
+				} catch (StandardException se) {
+					if (se.getMessageId()
 							.equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
 						// Ignore "Schema already exists". Another thread has
 						// probably created it after we checked for it
-						break;
-					}
-
-					// We got an non-expected exception, either in
-					// the nested transaction or in the outer
-					// transaction; we had better pass that on
-					if (useTc == nestedTc) {
-						nestedTc.destroy();
+					} else {
+						throw se;
 					}
-
-					throw se;
 				}
-				break;
 			}
 
-			// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
-			// Clean up if we did this in a nested transaction.
-			if (useTc == nestedTc) {
-				nestedTc.commit();
-				nestedTc.destroy();
-			}
 
 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
 		}
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
index e64d785da..10c0af867 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
@@ -208,7 +208,40 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
         }
     }
 
-    protected void  tearDown() throws Exception {
+    /**
+     * Test that implicit schema creation of other schemas besides
+     * the initial default schema is still transactional.
+     */
+    public void testOtherImplicitSchemaCreation () throws SQLException
+    {
+        Connection c1 = openUserConnection("newuser");
+        c1.setAutoCommit(false);
+        Statement s1 = c1.createStatement();
+
+        // Will auto-create schema OTHERSCHEMA:
+        s1.executeUpdate("create table otherschema.t1(i int)");
+        s1.close();
+        
+        JDBC.assertSingleValueResultSet(
+            c1.createStatement().executeQuery(
+                "select schemaname from sys.sysschemas " +
+                "where schemaname='OTHERSCHEMA'"),
+            "OTHERSCHEMA");
+
+        c1.rollback();
+
+        JDBC.assertEmpty(
+            c1.createStatement().executeQuery(
+                "select schemaname from sys.sysschemas " +
+                "where schemaname='OTHERSCHEMA'"));
+        
+        c1.rollback();
+        c1.close();
+    }
+
+
+
+protected void  tearDown() throws Exception {
         try {
             createStatement().executeUpdate("drop schema newuser restrict");
         } catch (SQLException e) {
