diff --git a/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
index 20fcf61f8..5beaecfdb 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
@@ -1267,7 +1267,7 @@ public class BinaryRelationalOperatorNode
 	 * pointing to "T1.j" (or whatever the corresponding column in T1 is).
 	 *
 	 * ASSUMPTION: We should only get to this method if we know that
-	 * at least one operand in the predicate to which this operator belongs
+	 * exactly one operand in the predicate to which this operator belongs
 	 * can and should be mapped to the received childRSN. 
 	 *
      * @param whichSide The operand are we trying to scope (LEFT or RIGHT)
@@ -1277,6 +1277,10 @@ public class BinaryRelationalOperatorNode
      *  ResultSetNode to which it doesn't apply.
      * @param childRSN The result set node to which we want to create
      *  a scoped predicate.
+     * @param whichRC If not -1 then this tells us which ResultColumn
+     *  in the received childRSN we need to use for the scoped predicate;
+     *  if -1 then the column position of the scoped column reference
+     *  will be stored in this array and passed back to the caller.
      * @return A column reference scoped to the received childRSN, if possible.
      *  If the operand is a ColumnReference that is not supposed to be scoped,
 	 *  we return a _clone_ of the reference--this is necessary because the
@@ -1286,8 +1290,8 @@ public class BinaryRelationalOperatorNode
 	 *  during optimization.
 	 */
 	public ValueNode getScopedOperand(int whichSide,
-		JBitSet parentRSNsTables, ResultSetNode childRSN)
-		throws StandardException
+		JBitSet parentRSNsTables, ResultSetNode childRSN,
+		int [] whichRC) throws StandardException
 	{
 		ResultColumn rc = null;
 		ColumnReference cr = 
@@ -1295,24 +1299,29 @@ public class BinaryRelationalOperatorNode
 				? (ColumnReference)leftOperand
 				: (ColumnReference)rightOperand;
 
-		// The first thing we need to do is see if this ColumnReference
-		// is supposed to be scoped for childRSN.  We do that by figuring
-		// out what underlying base table the column reference is pointing
-		// to and then seeing if that base table is included in the list of
-		// table numbers from the parentRSN.
+		/* When we scope a predicate we only scope one side of it--the
+		 * side that is to be evaluated against childRSN.  We figure out
+		 * if "cr" is that side by using table numbers, as seen below.
+		 * This means that for every scoped predicate there will be one
+		 * operand that is scoped and one operand that is not scoped.  
+		 * When we get here for the operand that will not be scoped,
+		 * we'll just return a clone of that operand.  So in the example
+		 * mentioned above, the scoped predicate for the left child of
+		 * X1 would be
+		 *
+		 *   T1.j <scoped> = X2.b <clone> 
+		 *
+		 * That said, the first thing we need to do is see if this
+		 * ColumnReference is supposed to be scoped for childRSN.  We
+		 * do that by figuring out what underlying base table the column
+		 * reference is pointing to and then seeing if that base table
+		 * is included in the list of table numbers from the parentRSN.
+		 */
 		JBitSet crTables = new JBitSet(parentRSNsTables.size());
 		BaseTableNumbersVisitor btnVis =
 			new BaseTableNumbersVisitor(crTables);
 		cr.accept(btnVis);
 
-		// If the column reference doesn't reference any tables,
-		// then there's no point in mapping it to the child result
-		// set; just return a clone of the operand.
-		if (crTables.getFirstSetBit() == -1)
-		{
-			return (ValueNode)cr.getClone();
-		}
-
 		/* If the column reference in question is not intended for
 		 * the received result set node, just leave the operand as
 		 * it is (i.e. return a clone).  In the example mentioned at
@@ -1325,113 +1334,153 @@ public class BinaryRelationalOperatorNode
 		 * version of that operand.
 		 */
 		if (!parentRSNsTables.contains(crTables))
-		{
-			return (ValueNode)cr.getClone();
-		}
-
-		// If the column reference is already pointing to the
-		// correct table, then there's no need to change it.
-		if ((childRSN.getReferencedTableMap() != null) &&
-			childRSN.getReferencedTableMap().get(cr.getTableNumber()))
-		{
-			return cr;
-		}
+			return (ColumnReference)cr.getClone();
 
 		/* Find the target ResultColumn in the received result set.  At
 		 * this point we know that we do in fact need to scope the column
-		 * reference for childRSN, so go ahead and do it.  We get the
-		 * target column by column position instead of by name because
-		 * it's possible that the name given for the query doesn't match
-		 * the name of the actual column we're looking for.  Ex.
+		 * reference for childRSN, so go ahead and do it.  The way in
+		 * which we get the scope target column differs depending on
+		 * if childRSN corresponds to the left or right child of the
+		 * UNION node.  Before explaining that, though, note that it's
+		 * not good enough to just search for the target column by
+		 * name.  The reason is that it's possible the name provided
+		 * for the column reference to be scoped doesn't match the
+		 * name of the actual underlying column.  Ex.
 		 *
 		 *  select * from
 		 *    (select i,j from t1 union select i,j from t2) X1 (x,y),
 		 *    (select a,b from t3 union select a,b from t4) X2
 		 *  where X1.x = X2.b;
 		 *
-		 * If we searched for "x" in the childRSN "select i,j from t1"
-		 * we wouldn't find it.  So we have to look based on position.
+		 * If we were scoping "X1.x" and we searched for "x" in the
+		 * childRSN "select i,j from t1" we wouldn't find it.
+		 *
+		 * It is similarly incorrect to search for the target column
+		 * by position (DERBY-1633).  This is a bit more subtle, but
+		 * if the child to which we're scoping is a subquery whose RCL
+		 * does not match the column ordering of the RCL for cr's source
+		 * result set, then searching by column position can yield the
+		 * wrong results, as well.  For a detailed example of how this
+		 * can happen, see the fix description attached to DERBY-1633.
+		 * 
+		 * So how do we find the target column, then? As mentioned
+		 * above, the way in which we get the scope target column
+		 * differs depending on if childRSN corresponds to the left
+		 * or right child of the parent UNION node.  And that said,
+		 * we can tell if we're scoping a left child by looking at
+		 * "whichRC" argument: if it is -1 then we know we're scoping
+		 * to the left child of a Union; otherwise we're scoping to
+		 * the right child.
 		 */
+		if (whichRC[0] == -1)
+		{
+			/*
+			 * For the left side we start by figuring out what the source
+			 * result set and column position for "cr" are.  Then, since
+			 * a) cr must be pointing to a result column in the parentRSN's
+			 * ResultColumnList,  b) we know that the parent RSN is a
+			 * SetOperatorNode (at least for now, since we only get here
+			 * for Union nodes), and c) SetOpNode's RCLs are built from the
+			 * left child's RCL (see bindResultColumns() in SetOperatorNode),
+			 * we know that if we search the child's RCL for a reference
+			 * whose source result column is the same as cr's source result
+			 * column, we'll find a match.  Once found, the position of the
+			 * matching column w.r.t childRSN's RCL will be stored in the
+			 * whichRC parameter.
+			 */
+
+			// Find the source result set and source column position of cr.
+			int [] sourceColPos = new int[] {-1};
+			ResultSetNode sourceRSN = cr.getSourceResultSet(sourceColPos);
 
-		rc = childRSN.getResultColumns().getResultColumn(cr.getColumnNumber());
+			if (SanityManager.DEBUG)
+			{
+				/* We assumed that if we made it here "cr" was pointing
+				 * to a base table somewhere down the tree.  If that's
+				 * true then sourceRSN won't be null.  Make sure our
+				 * assumption was correct.
+				 */
+				SanityManager.ASSERT(sourceRSN != null,
+					"Failed to find source result set when trying to " +
+					"scope column reference '" + cr.getTableName() +
+					"." + cr.getColumnName());
+			}
+
+			// Now search for the corresponding ResultColumn in childRSN.
+			rc = childRSN.getResultColumns()
+					.getResultColumn(sourceColPos[0], sourceRSN, whichRC);
+		}
+		else
+		{
+			/*
+			 * For the right side the story is slightly different.  If we were
+			 * to search the right child's RCL for a reference whose source
+			 * result column was the same as cr's, we wouldn't find it.  This
+			 * is because cr's source result column comes from the left child's
+			 * RCL and thus the right child doesn't know about it.  That said,
+			 * though, for set operations like UNION, the left and right RCL's
+			 * are correlated by position--i.e. the operation occurs between
+			 * the nth column in the left RCL and the nth column in the right
+			 * RCL.  So given that we will already have found the scope target
+			 * in the left child's RCL at the position in whichRC, we know that
+			 * that scope target for the right child's RCL is simply the
+			 * whichRC'th column in that RCL.
+			 */
+			rc = childRSN.getResultColumns().getResultColumn(whichRC[0]);
+		}
 
 		// rc shouldn't be null; if there was no matching ResultColumn at all,
 		// then we shouldn't have made it this far.
 		if (SanityManager.DEBUG)
 		{
 			SanityManager.ASSERT(rc != null,
-				"Failed to locate result column when trying to " +
+				"Failed to locate scope target result column when trying to " +
 				"scope operand '" + cr.getTableName() + "." +
 				cr.getColumnName() + "'.");
 		}
 
 		/* If the ResultColumn we found has an expression that is a
-		 * ColumnReference, then that column reference has all of the info
-		 * we need, with one exception: the columnNumber.  Depending on our
-		 * depth in the tree, the ResultColumn's ColumnReference could be
-		 * pointing to a base column in the FromBaseTable.  In that case the
-		 * ColumnReference will hold the column position as it is with respect
-		 * to the FromBaseTable.  But when we're scoping a column reference,
-		 * we're scoping it to a ResultSetNode that sits (either directly or
-		 * indirectly) above a ProjectRestrictNode that in turn sits above the
-		 * FromBaseTable. This means that the scoped reference's columnNumber
-		 * needs to be with respect to the PRN that sits above the base table,
-		 * _not_ with respect to the FromBaseTable itself.  This is important
-		 * because column "1" in the PRN might not be column "1" in the
-		 * underlying base table. For example, if we have base table TT with
-		 * four columns (a int, b int, i int, j int) and the PRN above it only
-		 * projects out columns (i,j), then column "1" for the PRN is "i", but
-		 * column "1" for base table TT is "a".  On the flip side, column "3"
-		 * for base table TT is "i", but if we search the PRN's result columns
-		 * (which match the result columns for the ResultSetNode to which
-		 * we're scoping) for column "3", we won't find it.
+		 * ColumnReference, then that column reference has all of the
+		 * info we need.
+		 *
+		 * It is, however, possible that the ResultColumn's expression
+		 * is NOT a ColumnReference.  For example, the expression would
+		 * be a constant expression if childRSN represented something
+		 * like:
 		 *
-		 * So what does all of that mean?  It means that if the ResultColumn
-		 * we found has an expression that's a ColumnReference, we can simply
-		 * return that ColumnReference IF we set it's columnNumber correctly.
-		 * Thankfully the column reference we're trying to scope ("cr") came
-		 * from further up the tree and so it knows what the correct column
-		 * position (namely, the position w.r.t the ProjectRestrictNode above
-		 * the FromBaseTable) needs to be.  So that's the column number we
-		 * use.
+		 *   select 1, 1 from t1
 		 *
-		 * As a final note, we have to be sure we only set the column
-		 * reference's column number if the reference points to a base table.
-		 * If the reference points to some other ResultSetNode--esp. another
-		 * subquery node--then it (the reference) already holds the correct
-		 * number with respect to that ResultSetNode and we don't change
-		 * it.  The reason is that the reference could end up getting pushed
-		 * down further to that ResultSetNode, in which case we'll do another
-		 * scoping operation and, in order for that to be successful, the
-		 * reference to be scoped has to know what the target column number
-		 * is w.r.t to that ResultSetNode (i.e. it'll be playing the role of
-		 * "cr" as described here).
+		 * In this case the expression does not directly reference a
+		 * column in the underlying result set and is therefore
+		 * "scoped" as far as it can go.  This means that the scoped
+		 * predicate will not necessarily have column references on
+		 * both sides, even though the predicate that we're scoping
+		 * will.  That's not a problem, though, since a predicate with
+		 * a column reference on one side and a non-ColumnReference
+		 * on the other is still valid.
 		 */
+
 		if (rc.getExpression() instanceof ColumnReference)
 		{
-			// Make sure the ColumnReference's columnNumber is correct,
-			// then just return that reference.  Note: it's okay to overwrite
-			// the columnNumber directly because when it eventually makes
-			// it down to the PRN over the FromBaseTable, it will be remapped
-			// for the FromBaseTable and the columnNumber will then be set
-			// correctly.  That remapping is done in the pushOptPredicate()
-			// method of ProjectRestrictNode.
-			ColumnReference cRef = (ColumnReference)rc.getExpression();
-			if (cRef.pointsToBaseTable())
-				cRef.setColumnNumber(cr.getColumnNumber());
+			/* We create a clone of the column reference and mark
+			 * the clone as "scoped" so that we can do the right
+			 * thing when it comes time to remap the predicate;
+			 * see Predicate.remapScopedPred() for more.
+			 */
+			ColumnReference cRef = (ColumnReference)
+				((ColumnReference)rc.getExpression()).getClone();
+			cRef.markAsScoped();
 			return cRef;
 		}
 
-		/* We can get here if the ResultColumn's expression isn't a
-		 * ColumnReference.  For example, the expression would be a
-		 * constant expression if childRSN represented something like:
-		 *
-		 *   select 1, 1 from t1
-		 *
-		 * In this case we just return a clone of the column reference
-		 * because it's scoped as far as we can take it.
+		/* Else just return rc's expression.  This means the scoped
+		 * predicate will have one operand that is _not_ a column
+		 * reference--but that's okay, so long as we account for
+		 * that when pushing/remapping the scoped predicate down
+		 * the query tree (see esp. "isScopedToSourceResultSet()"
+		 * in Predicate.java).
 		 */
-		return (ValueNode)cr.getClone();
+		return rc.getExpression();
 	}
 
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index 3a596bc13..84d66bdc0 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -81,6 +81,16 @@ public class ColumnReference extends ValueNode
 	private int			nestingLevel = -1;
 	private int			sourceLevel = -1;
 
+	/* Whether or not this column reference been scoped for the
+	   sake of predicate pushdown.
+	 */
+	private boolean		scoped;
+
+	/* List of saved remap data if this ColumnReference is scoped
+	   and has been remapped multiple times.
+	 */
+	private java.util.ArrayList remaps;
+
 	/**
 	 * Initializer.
 	 * This one is called by the parser where we could
@@ -105,6 +115,7 @@ public class ColumnReference extends ValueNode
 		this.setBeginOffset(((Integer) tokBeginOffset).intValue());
 		this.setEndOffset(((Integer) tokEndOffset).intValue());
 		tableNumber = -1;
+		remaps = null;
 	}
 
 	/**
@@ -119,6 +130,7 @@ public class ColumnReference extends ValueNode
 		this.columnName = (String) columnName;
 		this.tableName = (TableName) tableName;
 		tableNumber = -1;
+		remaps = null;
 	}
 
 	/**
@@ -299,6 +311,7 @@ public class ColumnReference extends ValueNode
 		nestingLevel = oldCR.getNestingLevel();
 		sourceLevel = oldCR.getSourceLevel();
 		replacesAggregate = oldCR.getGeneratedToReplaceAggregate();
+		scoped = oldCR.isScoped();
 	}
 
 	/**
@@ -642,15 +655,35 @@ public class ColumnReference extends ValueNode
 			return;
 		}
 
+		/* Scoped column references are a special case: they can be
+		 * remapped several times (once for every ProjectRestrictNode
+		 * through which the scoped ColumnReference is pushed before
+		 * reaching its target result set) and will be un-remapped
+		 * several times, as well (as the scoped predicate is "pulled"
+		 * back up the query tree to it's original location).  So we
+		 * have to keep track of the "orig" info for every remap
+		 * operation, not just for the most recent one.
+		 */
+		if (scoped && (origSource != null))
+		{
+			if (remaps == null)
+				remaps = new java.util.ArrayList();
+			remaps.add(new RemapInfo(
+				columnNumber, tableNumber, columnName, source));
+		}
+		else
+		{
+			origSource = source;
+			origName = columnName;
+			origColumnNumber = columnNumber;
+			origTableNumber = tableNumber;
+		}
+
 		/* Find the matching ResultColumn */
-		origSource = source;
 		source = getSourceResultColumn();
-		origName = columnName;
 		columnName = source.getName();
-		origColumnNumber = columnNumber;
 		columnNumber = source.getColumnPosition();
 
-		origTableNumber = tableNumber;
 		if (source.getExpression() instanceof ColumnReference)
 		{
 			ColumnReference cr = (ColumnReference) source.getExpression();
@@ -679,12 +712,28 @@ public class ColumnReference extends ValueNode
 			// 	"Trying to unremap a ColumnReference that was not remapped.");
 		}
 
-		source = origSource;
-		origSource = null;
-		columnName = origName;
-		origName = null;
-		tableNumber = origTableNumber;
-		columnNumber = origColumnNumber;
+		if ((remaps == null) || (remaps.size() == 0))
+		{
+			source = origSource;
+			origSource = null;
+			columnName = origName;
+			origName = null;
+			tableNumber = origTableNumber;
+			columnNumber = origColumnNumber;
+		}
+		else
+		{
+			// This CR is multiply-remapped, so undo the most
+			// recent (and only the most recent) remap operation.
+			RemapInfo rI = (RemapInfo)remaps.remove(remaps.size() - 1);
+			source = rI.getSource();
+			columnName = rI.getColumnName();
+			tableNumber = rI.getTableNumber();
+			columnNumber = rI.getColumnNumber();
+			rI = null;
+			if (remaps.size() == 0)
+				remaps = null;
+		}
 	}
 
 	/**
@@ -982,50 +1031,142 @@ public class ColumnReference extends ValueNode
     } // end of getTypeServices
 
 	/**
-	 * Determine whether or not this ColumnReference's source comes
-	 * from a FromBaseTable (as opposed to some other ResultSetNode).
-	 * We figure this out by walking the ResultColumn/VirtualColumnNode
-	 * chain until we get to last VirtualColumnNode in the chain
-	 * (if there is one), and then seeing what that VCN's source
-	 * result set is.  If there are no VCNs then we check to see
-	 * if the source is pointing to a BaseColumnNode.
+	 * Find the source result set for this ColumnReference and
+	 * return it.  Also, when the source result set is found,
+	 * return the position (within the source result set's RCL)
+	 * of the column referenced by this ColumnReference.  The
+	 * position is returned vai the colNum parameter.
 	 *
-	 * This is useful when scoping predicates for pushing; we
-	 * need to know if the predicate's column references are pointing
-	 * directly to base tables so that we can set the scoped references'
-	 * column numbers correctly.
+	 * @param colNum Place to store the position of the column
+	 *  to which this ColumnReference points (position is w.r.t
+	 *  the source result set).
+	 * @return The source result set for this ColumnReference;
+	 *  null if there is no source result set.
 	 */
-	protected boolean pointsToBaseTable() throws StandardException
+	protected ResultSetNode getSourceResultSet(int [] colNum)
+		throws StandardException
 	{
+		if (source == null)
+		{
+			/* this can happen if column reference is pointing to a column
+			 * that is not from a base table.  For example, if we have a
+			 * VALUES clause like
+			 *
+			 *    (values (1, 2), (3, 4)) V1 (i, j)
+			 *
+			 * and then a column reference to VI.i, the column reference
+			 * won't have a source.
+			 */
+			return null;
+		}
+
+		ValueNode rcExpr = null;
 		ResultColumn rc = getSource();
 
-		if (rc == null) {
-		// this can happen if column reference is pointing to a column
-		// that is not from a base table.  For example, if we have a
-		// VALUES clause like
-		//
-		//    (values (1, 2), (3, 4)) V1 (i, j)
-		//
-		// and then a column reference to VI.i, the column reference
-		// won't have a source.
-			return false;
-		}
+		// Walk the ResultColumn->ColumnReference chain until we
+		// find a ResultColumn whose expression is a VirtualColumnNode.
 
-		// Walk the VirtualColumnNode->ResultColumn chain.
-		VirtualColumnNode vcn = null;
-		ValueNode rcExpr = rc.getExpression();
-		while (rcExpr instanceof VirtualColumnNode) {
-			vcn = (VirtualColumnNode)rcExpr;
-			rc = vcn.getSourceColumn();
+		rcExpr = rc.getExpression();
+		colNum[0] = getColumnNumber();
+
+		while ((rcExpr != null) && (rcExpr instanceof ColumnReference))
+		{
+			colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
+			rc = ((ColumnReference)rcExpr).getSource();
+
+			/* If "rc" is redundant then that means it points to another
+			 * ResultColumn that in turn points to the source expression.
+			 * This can happen in cases where "rc" points to a subquery
+			 * that has been flattened into the query above it (flattening
+			 * of subqueries occurs during preprocessing).  In that case
+			 * we want to skip over the redundant rc and find the
+			 * ResultColumn that actually holds the source expression.
+			 */
+			while (rc.isRedundant())
+			{
+				rcExpr = rc.getExpression();
+				if (rcExpr instanceof VirtualColumnNode)
+					rc = ((VirtualColumnNode)rcExpr).getSourceResultColumn();
+				else if (rcExpr instanceof ColumnReference)
+				{
+					colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
+					rc = ((ColumnReference)rcExpr).getSource();
+				}
+				else
+				{
+					/* If rc isn't pointing to a VirtualColumnNode nor
+					 * to a ColumnReference, then it's not pointing to
+					 * a result set.  It could, for example, be pointing
+					 * to a constant node or to the result of an aggregate
+					 * or function.  Break out of both loops and return
+					 * null since there is no source result set.
+					 */
+					rcExpr = null;
+					break;
+				}
+			}
 			rcExpr = rc.getExpression();
 		}
 
-		// If we've reached the bottom of the chain then see if
-		// the VCN is pointing to a FromBaseTable.
-		if (vcn != null)
-			return (vcn.getSourceResultSet() instanceof FromBaseTable);
+		// If we found a VirtualColumnNode, return the VirtualColumnNode's
+		// sourceResultSet.  The column within that sourceResultSet that
+		// is referenced by this ColumnReference is also returned, via
+		// the colNum parameter, and was set above.
+		if ((rcExpr != null) && (rcExpr instanceof VirtualColumnNode))
+			return ((VirtualColumnNode)rcExpr).getSourceResultSet();
+
+		// If we get here then the ColumnReference doesn't reference
+		// a result set, so return null.
+		colNum[0] = -1;
+		return null;
+	}
+
+	/**
+	 * Mark this column reference as "scoped", which means that it
+	 * was created (as a clone of another ColumnReference) to serve
+	 * as the left or right operand of a scoped predicate.
+	 */
+	protected void markAsScoped()
+	{
+		scoped = true;
+	}
+
+	/**
+	 * Return whether or not this ColumnReference is scoped.
+	 */
+	protected boolean isScoped()
+	{
+		return scoped;
+	}
+
+	/**
+	 * Helper class to keep track of remap data when a ColumnReference
+	 * is remapped multiple times.  This allows the CR to be UN-
+	 * remapped multiple times, as well.
+	 */
+	private class RemapInfo
+	{
+		int colNum;
+		int tableNum;
+		String colName;
+		ResultColumn source;
+
+		RemapInfo(int cNum, int tNum, String cName, ResultColumn rc)
+		{
+			colNum = cNum;
+			tableNum = tNum;
+			colName = cName;
+			source = rc;
+		}
+
+		int getColumnNumber() { return colNum; }
+		int getTableNumber() { return tableNum; }
+		String getColumnName() { return colName; }
+		ResultColumn getSource() { return source; }
 
-		// Else check our source's expression.
-		return (rc.getExpression() instanceof BaseColumnNode);
+		void setColNumber(int cNum) { colNum = cNum; }
+		void setTableNumber(int tNum) { tableNum = tNum; }
+		void setColName(String cName) { colName = cName; }
+		void setSource(ResultColumn rc) { source = rc; }
 	}
 }
diff --git a/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java b/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
index 5a522fdd1..e208bf5ed 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
@@ -2449,7 +2449,7 @@ public class OptimizerImpl implements Optimizer
 	}
 
 	/**
-	 * Add predicates to this optimizer's predicateList. This method
+	 * Add scoped predicates to this optimizer's predicateList. This method
 	 * is intended for use during the modifyAccessPath() phase of
 	 * compilation, as it allows nodes (esp. SelectNodes) to add to the
 	 * list of predicates available for the final "push" before code
@@ -2465,7 +2465,7 @@ public class OptimizerImpl implements Optimizer
 	 * @param pList List of predicates to add to this OptimizerImpl's
 	 *  own list for pushing.
 	 */
-	protected void addPredicatesToList(PredicateList pList)
+	protected void addScopedPredicatesToList(PredicateList pList)
 		throws StandardException
 	{
 		if ((pList == null) || (pList == predicateList))
@@ -2490,9 +2490,22 @@ public class OptimizerImpl implements Optimizer
 				predicateList.removeOptPredicate(i);
 		}
 
-		// Now transfer all of the received predicates into this
-		// OptimizerImpl's list.
-		pList.transferAllPredicates(predicateList);
+		// Now transfer scoped predicates in the received list to
+		// this OptimizerImpl's list, where appropriate.
+		for (int i = pList.size() - 1; i >= 0; i--)
+		{
+			pred = (Predicate)pList.getOptPredicate(i);
+			if (pred.isScopedToSourceResultSet())
+			{
+				// Clear the scoped predicate's scan flags; they'll be set
+				// as appropriate when they make it to the restrictionList
+				// of the scoped pred's source result set.
+				pred.clearScanFlags();
+				predicateList.addOptPredicate(pred);
+				pList.removeOptPredicate(i);
+			}
+		}
+
 		return;
 	}
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/Predicate.java b/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
index c75cd6af5..e6cf13866 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
@@ -914,9 +914,12 @@ public final class Predicate extends QueryTreeNode implements OptimizablePredica
 		BinaryRelationalOperatorNode opNode =
 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
 
-		// If both sides are column references then this is a join pred.
+		// If both sides are column references AND they point to different
+		// tables, then this is a join pred.
 		return ((opNode.getLeftOperand() instanceof ColumnReference) &&
-			(opNode.getRightOperand() instanceof ColumnReference));
+			(opNode.getRightOperand() instanceof ColumnReference) &&
+			(((ColumnReference)opNode.getLeftOperand()).getTableNumber() !=
+			((ColumnReference)opNode.getRightOperand()).getTableNumber()));
 	}
 
 	/**
@@ -965,12 +968,16 @@ public final class Predicate extends QueryTreeNode implements OptimizablePredica
 	 *  ResultSetNode to which they don't apply.
 	 * @param childRSN The result set node for which we want to create
 	 *  a scoped predicate.
+	 * @param whichRC If not -1 then this tells us which ResultColumn
+	 *  in the received childRSN we need to use for the scoped predicate;
+	 *  if -1 then the column position of the scoped column reference
+	 *  will be stored in this array and passed back to the caller.
 	 * @return A new predicate whose operands have been scoped to the
 	 *  received childRSN.
 	 */
 	protected Predicate getPredScopedForResultSet(
-		JBitSet parentRSNsTables, ResultSetNode childRSN)
-		throws StandardException
+		JBitSet parentRSNsTables, ResultSetNode childRSN,
+		int [] whichRC) throws StandardException
 	{
 		// We only deal with binary relational operators here.
 		if (!(getAndNode().getLeftOperand()
@@ -999,11 +1006,13 @@ public final class Predicate extends QueryTreeNode implements OptimizablePredica
 				opNode.getScopedOperand(
 					BinaryRelationalOperatorNode.LEFT,
 					parentRSNsTables,
-					childRSN),
+					childRSN,
+					whichRC),
 				opNode.getScopedOperand(
 					BinaryRelationalOperatorNode.RIGHT,
 					parentRSNsTables,
-					childRSN),
+					childRSN,
+					whichRC),
 				getContextManager());
 
 		// Bind the new op node.
@@ -1062,4 +1071,232 @@ public final class Predicate extends QueryTreeNode implements OptimizablePredica
 		return scoped;
 	}
 
+	/**
+	 * When remapping a "normal" (i.e. non-scoped) predicate both
+	 * of the predicate's operands are remapped and that's it.
+	 * But when remapping a scoped predicate, things are slightly
+	 * different.  This method handles remapping of scoped predicates.
+	 *
+	 * We know that, for a scoped predicate, exactly one operand has
+	 * been scoped for a specific target result set; the other operand
+	 * is pointing to some other instance of FromTable with which the
+	 * target result set is to be joined (see getScopedOperand() in
+	 * BinaryRelationalOperatorNode.java).  For every level of the
+	 * query through which the scoped predicate is pushed, we have
+	 * to perform a remap operation of the scoped operand.  We do
+	 * *not*, however, remap the non-scoped operand.  The reason
+	 * is that the non-scoped operand is already pointing to the
+	 * result set against which it must be evaluated.  As the scoped
+	 * predicate is pushed down the query tree, the non-scoped
+	 * operand should not change where it's pointing and thus should
+	 * not be remapped.  For example, assume we have a query whose
+	 * tree has the following form:
+	 *
+	 *               SELECT[0] 
+	 *                /     \ 
+	 *              PRN      PRN 
+	 *               |        |
+	 *          SELECT[4]   UNION
+	 *           |           /   \ 
+	 *          PRN     SELECT[1]  SELECT[2] 
+	 *           |         |          | 
+	 *       <FBT:T1>     PRN        PRN 
+	 *                     |          |
+	 *                SELECT[3]  <FromBaseTable:T2> 
+	 *                     |
+	 *                    PRN
+	 *                     |
+	 *             <FromBaseTable:T3>
+	 *
+	 * Assume also that we have some predicate "SELECT[4].i = <UNION>.j".
+	 * If the optimizer decides to push the predicate to the UNION
+	 * node, it (the predicate) will be scoped to the UNION's children,
+	 * yielding something like "SELECT[4].i = SELECT[1].j" for the
+	 * left child and "SELECT[4].i = SELECT[2].j" for the right child.
+	 * These scoped predicates will then be pushed to the PRNs above
+	 * SELECT[3] and T2, respectively.  As part of that pushing
+	 * process a call to PRN.pushOptPredicate() will occur, which
+	 * brings us to this method.  So let's assume we're here for
+	 * the scoped predicate "SELECT[4].i = SELECT[1].j".  Then we want
+	 * to remap the scoped operand, "SELECT[1].j", so that it will
+	 * point to the correct column in "SELECT[3]".  We do NOT, however,
+	 * want to remap the non-scoped operand "SELECT[4].i" because that
+	 * operand is already pointing to the correct result set--namely,
+	 * to a column in SELECT[4].  That non-scoped operand should not
+	 * change regardless of how far down the UNION subtree the scoped
+	 * predicate is pushed.
+	 * 
+	 * If we did try to remap the non-scoped operand, it would end up
+	 * pointing to result sets too low in the tree, which could lead to
+	 * execution-time errors.  So when we remap a scoped predicate, we
+	 * have to make sure we only remap the scoped operand.  That's what
+	 * this method does.
+	 *
+	 * @return True if this predicate is a scoped predicate, in which
+	 *  case we performed a one-sided remap.  False if the predicate is
+	 *  not scoped; the caller can then make the calls to perform a
+	 *  "normal" remap on this predicate.
+	 */
+	protected boolean remapScopedPred()
+	{
+		if (!scoped)
+			return false;
+
+		/* Note: right now the only predicates we scope are those
+		 * which are join predicates and all scoped predicates will
+		 * have the same relational operator as the predicates from
+		 * which they were scoped.  Thus if we get here, we know
+		 * that andNode's leftOperand must be an instance of
+		 * BinaryRelationalOperatorNode (and therefore the following
+		 * cast is safe).
+		 */
+		BinaryRelationalOperatorNode binRelOp =
+			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
+
+		ValueNode operand = null;
+
+		if (SanityManager.DEBUG)
+		{
+			/* If this predicate is scoped then one (and only one) of
+			 * its operands should be scoped.  Note that it's possible
+			 * for an operand to be scoped to a non-ColumnReference
+			 * value; if either operand is not a ColumnReference, then
+			 * that operand must be the scoped operand.
+			 */
+			operand = binRelOp.getLeftOperand();
+			boolean leftIsScoped =
+				!(operand instanceof ColumnReference) ||
+					((ColumnReference)operand).isScoped();
+
+			operand = binRelOp.getRightOperand();
+			boolean rightIsScoped =
+				!(operand instanceof ColumnReference) ||
+					((ColumnReference)operand).isScoped();
+
+			SanityManager.ASSERT(leftIsScoped ^ rightIsScoped,
+				"All scoped predicates should have exactly one scoped " +
+				"operand, but '" + binaryRelOpColRefsToString() +
+				"' has " + (leftIsScoped ? "TWO" : "NONE") + ".");
+		}
+
+		// Find the scoped operand and remap it.
+		operand = binRelOp.getLeftOperand();
+		if ((operand instanceof ColumnReference) &&
+			((ColumnReference)operand).isScoped())
+		{
+			// Left operand is the scoped operand.
+			((ColumnReference)operand).remapColumnReferences();
+		}
+		else
+		{
+			operand = binRelOp.getRightOperand();
+			if ((operand instanceof ColumnReference) &&
+				((ColumnReference)operand).isScoped())
+			{
+				// Right operand is the scoped operand.
+				((ColumnReference)operand).remapColumnReferences();
+			}
+
+			// Else scoped operand is not a ColumnReference, which
+			// means it can't (and doesn't need to) be remapped. So
+			// just fall through and return.
+		}
+
+		return true;
+	}
+
+	/**
+	 * Return true if this predicate is scoped AND the scoped
+	 * operand is a ColumnReference that points to a source result
+	 * set.  If the scoped operand is not a ColumnReference that
+	 * points to a source result set then it must be pointing to
+	 * some kind of expression, such as a literal (ex. 'strlit'),
+	 * an aggregate value (ex. "count(*)"), or the result of a
+	 * function (ex. "sin(i)") or operator (ex. "i+1").
+	 *
+	 * This method is used when pushing predicates to determine how
+	 * far down the query tree a scoped predicate needs to be pushed
+	 * to allow for successful evaluation of the scoped operand.  If
+	 * the scoped operand is not pointing to a source result set
+	 * then it should not be pushed any further down tree.  The reason
+	 * is that evaluation of the expression to which the operand is
+	 * pointing may depend on other values from the current level
+	 * in the tree (ex. "sin(i)" depends on the value of "i", which
+	 * could be a column at the predicate's current level).  If we
+	 * pushed the predicate further down, those values could become
+	 * inaccessible, leading to execution-time errors.
+	 *
+	 * If, on the other hand, the scoped operand *is* pointing to
+	 * a source result set, then we want to push it further down
+	 * the tree until it reaches that result set, which allows
+	 * evaluation of this predicate to occur as close to store as
+	 * possible.  This method doesn't actually do the push, it just
+	 * returns "true" and then the caller can push as appropriate.
+	 */
+	protected boolean isScopedToSourceResultSet()
+		throws StandardException
+	{
+		if (!scoped)
+			return false;
+
+		/* Note: right now the only predicates we scope are those
+		 * which are join predicates and all scoped predicates will
+		 * have the same relational operator as the predicates from
+		 * which they were scoped.  Thus if we get here, we know
+		 * that andNode's leftOperand must be an instance of
+		 * BinaryRelationalOperatorNode (and therefore the following
+		 * cast is safe).
+		 */
+		BinaryRelationalOperatorNode binRelOp =
+			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
+
+		ValueNode operand = binRelOp.getLeftOperand();
+
+		/* If operand isn't a ColumnReference then is must be the
+		 * scoped operand.  This is because both operands have to
+		 * be column references in order for scoping to occur (as
+		 * per pushableToSubqueries()) and only the scoped operand
+		 * can change (esp. can become a non-ColumnReference) as
+		 * part of the scoping process.  And since it's not a
+		 * ColumnReference it can't be "a ColumnReference that
+		 * points to a source result set", so return false.
+		 */
+		if (!(operand instanceof ColumnReference))
+			return false;
+
+		/* If the operand is a ColumnReference and is scoped,
+		 * then see if it is pointing to a ResultColumn whose
+		 * expression is either another a CR or a Virtual
+		 * ColumnNode.  If it is then that operand applies
+		 * to a source result set further down the tree and
+		 * thus we return true.
+		 */
+		ValueNode exp = null;
+		ColumnReference cRef = (ColumnReference)operand;
+		if (cRef.isScoped())
+		{
+			exp = cRef.getSource().getExpression();
+			return ((exp instanceof VirtualColumnNode) ||
+				(exp instanceof ColumnReference));
+		}
+
+		operand = binRelOp.getRightOperand();
+		if (!(operand instanceof ColumnReference))
+			return false;
+
+		cRef = (ColumnReference)operand;
+		if (SanityManager.DEBUG)
+		{
+			// If we got here then the left operand was NOT the scoped
+			// operand; make sure the right one is scoped, then.
+			SanityManager.ASSERT(cRef.isScoped(),
+				"All scoped predicates should have exactly one scoped " +
+				"operand, but '" + binaryRelOpColRefsToString() +
+				"has NONE.");
+		}
+
+		exp = cRef.getSource().getExpression();
+		return ((exp instanceof VirtualColumnNode) ||
+			(exp instanceof ColumnReference));
+	}
 }
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java b/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
index d05af7f78..de8928720 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
@@ -547,8 +547,17 @@ public class ProjectRestrictNode extends SingleChildResultSetNode
 		/* Remap all of the ColumnReferences to point to the
 		 * source of the values.
 		 */
-		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
-		((Predicate) optimizablePredicate).getAndNode().accept(rcrv);
+		Predicate pred = (Predicate)optimizablePredicate;
+
+		/* If the predicate is scoped then the call to "remapScopedPred()"
+		 * will do the necessary remapping for us and will return true;
+		 * otherwise, we'll just do the normal remapping here.
+		 */
+		if (!pred.remapScopedPred())
+		{
+			RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
+			pred.getAndNode().accept(rcrv);
+		}
 
 		return true;
 	}
@@ -613,7 +622,14 @@ public class ProjectRestrictNode extends SingleChildResultSetNode
 			// Remember that the original child was not Optimizable
 			origChildOptimizable = false;
 
-			childResult = childResult.modifyAccessPaths();
+			/* When we optimized the child we passed in our restriction list
+			 * so that scoped predicates could be pushed further down the
+			 * tree.  We need to do the same when modifying the access
+			 * paths to ensure we generate the same plans the optimizer
+			 * chose.
+			 */
+			childResult = childResult.modifyAccessPaths(restrictionList);
+
 			/* Mark this node as having the truly ... for
 			 * the underlying tree.
 			 */
diff --git a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index 18bc855e2..453e1d468 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -220,6 +220,52 @@ public class ResultColumnList extends QueryTreeNodeVector
 		return null;
 	}
 
+	/**
+	 * Take a column position and a ResultSetNode and find the ResultColumn
+	 * in this RCL whose source result set is the same as the received
+	 * RSN and whose column position is the same as the received column
+	 * position.
+	 *
+	 * @param colNum The column position (w.r.t rsn) for which we're searching
+	 * @param rsn The result set node for which we're searching.
+	 * @return The ResultColumn in this RCL whose source is column colNum
+	 *  in result set rsn.  That ResultColumn's position w.r.t to this RCL
+	 *  is also returned via the whichRC parameter.  If no match is found,
+	 *  return null and leave whichRC untouched.
+	 */
+	public ResultColumn getResultColumn(int colNum, ResultSetNode rsn,
+		int [] whichRC) throws StandardException
+	{
+		if (colNum == -1)
+			return null;
+
+		ResultColumn rc = null;
+		ColumnReference colRef = null;
+		int [] crColNum = new int[] { -1 };
+
+		for (int index = size() - 1; index >= 0; index--)
+		{
+			rc = (ResultColumn) elementAt(index);
+			if (!(rc.getExpression() instanceof ColumnReference))
+			{
+				// If the rc's expression isn't a column reference then
+				// it can't be pointing to rsn, so just skip it.
+				continue;
+			}
+
+			colRef = (ColumnReference)rc.getExpression();
+			if ((rsn == colRef.getSourceResultSet(crColNum)) &&
+				(crColNum[0] == colNum))
+			{
+				// Found a match.
+				whichRC[0] = index+1;
+				return rc;
+			}
+		}
+
+		return null;
+	}
+
 	/**
 	 * Get a ResultColumn from a column position (1-based) in the list,
 	 * null if out of range (for order by).
diff --git a/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index 5044ae91e..007141202 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -1621,11 +1621,10 @@ public class SelectNode extends ResultSetNode
 			for (int i = sz - 1; i >= 0; i--)
 			{
 				// We can tell if a predicate was pushed into this select
-				// node because it will have been "scoped" for this node;
-				// see Predicate.getScopedPredForResultSet() for more on
-				// what scoping is and how it's done.
+				// node because it will have been "scoped" for this node
+				// or for some result set below this one.
 				pred = (Predicate)predicateList.getOptPredicate(i);
-				if (pred.isScopedForPush())
+				if (pred.isScopedToSourceResultSet())
 				{
 					// If we're pushing the predicate down here, we have to
 					// remove it from the predicate list of the node above
@@ -1652,6 +1651,26 @@ public class SelectNode extends ResultSetNode
 			}
 		}
 
+		/* When we're done optimizing, any scoped predicates that
+		 * we pushed down the tree should now be sitting again
+		 * in our wherePredicates list.  Put those back in the
+		 * the list from which we received them, to allow them
+		 * to be "pulled" back up to where they came from.
+		 */
+		if (wherePredicates != null)
+		{
+			Predicate pred = null;
+			for (int i = wherePredicates.size() - 1; i >= 0; i--)
+			{
+				pred = (Predicate)wherePredicates.getOptPredicate(i);
+				if (pred.isScopedForPush())
+				{
+					predicateList.addOptPredicate(pred);
+					wherePredicates.removeOptPredicate(pred);
+				}
+			}
+		}
+
 		/* Get the cost */
 		costEstimate = optimizer.getOptimizedCost();
 
@@ -1698,7 +1717,7 @@ public class SelectNode extends ResultSetNode
 				"modifying access paths.");
 		}
 
-		((OptimizerImpl)optimizer).addPredicatesToList(predList);
+		((OptimizerImpl)optimizer).addScopedPredicatesToList(predList);
 		return modifyAccessPaths();
 	}
 
diff --git a/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java b/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
index 074e24d09..9ba711ca9 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
@@ -305,33 +305,6 @@ abstract class SetOperatorNode extends TableOperatorNode
 		if (!canPush)
 			return false;
 
-		BinaryRelationalOperatorNode opNode =
-			(BinaryRelationalOperatorNode)pred.getAndNode().getLeftOperand();
-
-		// Note: we assume we only get here for predicates with col refs on
-		// both sides; if that ever changes, the following cast will need
-		// to be updated accordingly.
-		boolean opWasRemapped = 
-			((ColumnReference)opNode.getLeftOperand()).hasBeenRemapped();
-
-		/* If there is a ProjectRestrictNode directly above this node,
-		 * then the predicate in question may have been remapped to this
-		 * SetOperatorNode before we got here (see pushOptPredicate() in
-		 * ProjectRestrictNode).  If we leave it mapped when we try to
-		 * get scoped predicates for the left and right result sets, the
-		 * underlying column references of the scoped predicates will
-		 * effectively be doubly-mapped (i.e. mapped more than once), which
-		 * can cause problems at code generation time.  So we 1) un-remap
-		 * the predicate here, 2) get the scoped predicates, and then
-		 * 3) remap the predicate again at the end of this method.
-		 */
-		RemapCRsVisitor rcrv = null;
-		if (opWasRemapped)
-		{
-			rcrv = new RemapCRsVisitor(false);
-			pred.getAndNode().accept(rcrv);
-		}
-
 		// Get a list of all of the underlying base tables that this node
 		// references.  We pass this down when scoping so that we can tell
 		// if the operands are actually supposed to be scoped to _this_
@@ -359,6 +332,10 @@ abstract class SetOperatorNode extends TableOperatorNode
 		 * in the following code does.
 		 */
 
+		// For details on how this whichRC variable is used, see the
+		// comments in BinaryRelationalOperatorNode.getScopedOperand().
+		int [] whichRC = new int[] { -1 };
+
 		// See if we already have a scoped version of the predicate cached,
 		// and if so just use that.
 		Predicate scopedPred = null;
@@ -369,7 +346,7 @@ abstract class SetOperatorNode extends TableOperatorNode
 		if (scopedPred == null)
 		{
 			scopedPred = pred.getPredScopedForResultSet(
-				tableNums, leftResultSet);
+				tableNums, leftResultSet, whichRC);
 			leftScopedPreds.put(pred, scopedPred);
 		}
 
@@ -384,21 +361,13 @@ abstract class SetOperatorNode extends TableOperatorNode
 		if (scopedPred == null)
 		{
 			scopedPred = pred.getPredScopedForResultSet(
-				tableNums, rightResultSet);
+				tableNums, rightResultSet, whichRC);
 			rightScopedPreds.put(pred, scopedPred);
 		}
 
 		// Add the scoped predicate to our list for the right child.
 		getRightOptPredicateList().addOptPredicate(scopedPred);
 
-		// Restore the original predicate to the way it was before we got
-		// here--i.e. remap it again if needed.
-		if (opWasRemapped)
-		{
-			rcrv = new RemapCRsVisitor(true);
-			pred.getAndNode().accept(rcrv);
-		}
-
 		// Add the predicate (in its original form) to our list of predicates
 		// that we've pushed during this phase of optimization.  We need to
 		// keep this list of pushed predicates around so that we can do
@@ -453,11 +422,22 @@ abstract class SetOperatorNode extends TableOperatorNode
 		 * push that predicate elsewhere
 		 */
 		Predicate pred = null;
+		RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
 		for (int i = 0; i < pushedPredicates.size(); i++)
 		{
 			pred = (Predicate)pushedPredicates.getOptPredicate(i);
 			if (pred.isScopedForPush())
+			{
+				/* We don't need to pull the predicate if it's scoped, but
+				 * since scoped predicates are cached between rounds of
+				 * optimization, it's possible that we'll reuse the scoped
+				 * predicate again in a later round.  So to make sure we
+				 * get a "fresh start" in later rounds, we un-remap the
+				 * predicate here.
+				 */
+ 				pred.getAndNode().accept(rcrv);
 				continue;
+			}
 			optimizablePredicates.addOptPredicate(pred);
 		}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out b/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
index b3c09fd31..88924a557 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
@@ -1321,6 +1321,11 @@ ij> create view vz2 (z1, z2, z3, z4) as
   select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
     (select c1, c, c2, c3 from tc) xx1;
 0 rows inserted/updated/deleted
+ij> create view vz3 (z1, z2, z3, z4) as
+  select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
+    (select c1, c, c2, 28 from tc) xx1
+      union select 'i','j','j',i from t2;
+0 rows inserted/updated/deleted
 ij> -- Both sides of predicate reference aggregates.
 select x1.c1 from
   (select count(*) from t1 union select count(*) from t2) x1 (c1),
@@ -1486,6 +1491,21 @@ Z4
 4          
 2          
 4          
+ij> -- Same as above but with an expression ("i+1") instead of
+-- a numeric literal.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3),
+  (select distinct j from t2 union select j from t1) x2 (c2)
+where x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+4          |4          
+6          |6          
+2          |2          
+4          |4          
 ij> -- Same as previous query but with a different nested
 -- view (vz2) that is missing the nested union found
 -- in vz.
@@ -1498,11 +1518,195 @@ where x1.z4 = x2.c2;
 Z4         
 -----------
 4          
+ij> -- Queries with Select->Union->Select chains having differently-
+-- ordered result column lists with some non-column reference
+-- expressions.  In all of these queries we specify LEFT join
+-- and force NESTEDLOOP in order to coerce the optimizer to
+-- push predicates to a specific subquery.  We do this to
+-- ensure that we test predicate pushdown during compilation
+-- AND during execution.  It's the execution-time testing
+-- that is particular important for verifying DERBY-1633
+-- functionality.
+-- Push predicate to union whose left child has a Select
+-- within a Select, both of which have the same result column
+-- ordering.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3)
+  left join
+  (select distinct i,j from (select distinct i,j from t2) x3
+    union select i, j from t1
+  ) x2 (c1, c2) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP  
+on x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+3          |NULL       
+4          |4          
+5          |NULL       
+6          |6          
+1          |NULL       
+2          |2          
+3          |NULL       
+4          |4          
+5          |NULL       
+ij> -- Push predicate to union whose left child has a Select
+-- within a Select, where the result column lists for the
+-- two Selects are different ("i,j" vs "j,i").
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3)
+  left join
+  (select distinct i,j from (select distinct j,i from t2) x3
+   union select i, j from t1
+  ) x2 (c1, c2) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP  
+on x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+3          |NULL       
+4          |4          
+5          |NULL       
+6          |6          
+1          |NULL       
+2          |2          
+3          |NULL       
+4          |4          
+5          |NULL       
+ij> -- Push predicate to union whose left child is itself a
+-- nested subquery (through use of the view "vz") and
+-- whose right child has an expression in its result
+-- column list.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+2          |2          
+NULL       |-4         
+4          |4          
+4          |4          
+6          |6          
+NULL       |-8         
+NULL       |8          
+NULL       |10         
+ij> -- Same as previous but with a different expression.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', sin(i), '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4                    |C2         
+----------------------------------
+2.0                   |2          
+NULL                  |-4         
+4.0                   |4          
+NULL                  |6          
+NULL                  |-8         
+NULL                  |8          
+NULL                  |10         
+ij> -- Same as previous but expression replaced with a regular
+-- column reference.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', i, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+2          |2          
+NULL       |-4         
+4          |4          
+4          |4          
+NULL       |6          
+NULL       |-8         
+NULL       |8          
+NULL       |10         
+ij> -- Same as previous but with a different expression and
+-- a different subquery (this time using view "vz3").
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz3
+    union select '1', sin(i), '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4                    |C2         
+----------------------------------
+2.0                   |2          
+NULL                  |-4         
+4.0                   |4          
+NULL                  |6          
+NULL                  |-8         
+NULL                  |8          
+NULL                  |10         
+ij> -- Push predicate to chain of unions whose left-most child
+-- is itself a nested subquery (through use of the view "vz")
+-- and in which the other unions have expressions in their
+-- result column lists.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', sin(i), '3' from t1
+    union select '1', 14, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4                    |C2         
+----------------------------------
+2.0                   |2          
+NULL                  |-4         
+4.0                   |4          
+NULL                  |6          
+NULL                  |-8         
+NULL                  |8          
+NULL                  |10         
+ij> -- Push predicate to chain of unions whose right-most child
+-- is itself a nested subquery (through use of the view "vz")
+-- and in which the other unions have expressions in their
+-- result column lists.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select '1', sin(i), '3' from t1
+    union select '1', 14, '3' from t1
+    union select z1, z4, z3 from vz
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+Z4                    |C2         
+----------------------------------
+2.0                   |2          
+NULL                  |-4         
+4.0                   |4          
+NULL                  |6          
+NULL                  |-8         
+NULL                  |8          
+NULL                  |10         
 ij> -- Cleanup from this set of tests.
 drop view vz;
 0 rows inserted/updated/deleted
 ij> drop view vz2;
 0 rows inserted/updated/deleted
+ij> drop view vz3;
+0 rows inserted/updated/deleted
 ij> drop table tc;
 0 rows inserted/updated/deleted
 ij> -- Now bump up the size of tables T3 and T4 to the point where
@@ -1768,101 +1972,75 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (10):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 7
 			Rows seen = 2
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 2
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 2
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 7
 			Rows seen = 0
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 0
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 0
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> select * from V2, V1 where V1.j = V2.b;
 A          |B          |I          |J          
@@ -1887,7 +2065,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (14):
+Project-Restrict ResultSet (12):
 Number of opens = 1
 Rows seen = 2
 Rows filtered = 0
@@ -2003,101 +2181,75 @@ None
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
 			Left result set:
-				Project-Restrict ResultSet (10):
+				Index Row to Base Row ResultSet for T3:
 				Number of opens = 7
 				Rows seen = 2
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T3:
+					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 7
 					Rows seen = 2
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 7
-						Rows seen = 2
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-							next time in milliseconds/row = 0
-						scan information: 
-							Bit set of columns fetched=All
-							Number of columns fetched=2
-							Number of deleted rows visited=0
-							Number of pages visited=3
-							Number of rows qualified=0
-							Number of rows visited=1
-							Scan type=btree
-							Tree height=3
-							start position: 
+						next time in milliseconds/row = 0
+					scan information: 
+						Bit set of columns fetched=All
+						Number of columns fetched=2
+						Number of deleted rows visited=0
+						Number of pages visited=3
+						Number of rows qualified=0
+						Number of rows visited=1
+						Scan type=btree
+						Tree height=3
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 			Right result set:
-				Project-Restrict ResultSet (13):
+				Index Row to Base Row ResultSet for T4:
 				Number of opens = 7
 				Rows seen = 0
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T4:
+					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 7
 					Rows seen = 0
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 7
-						Rows seen = 0
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-						scan information: 
-							Bit set of columns fetched=All
-							Number of columns fetched=2
-							Number of deleted rows visited=0
-							Number of pages visited=3
-							Number of rows qualified=0
-							Number of rows visited=1
-							Scan type=btree
-							Tree height=3
-							start position: 
+					scan information: 
+						Bit set of columns fetched=All
+						Number of columns fetched=2
+						Number of deleted rows visited=0
+						Number of pages visited=3
+						Number of rows qualified=0
+						Number of rows visited=1
+						Scan type=btree
+						Tree height=3
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 ij> -- Changes for DERBY-805 don't affect non-join predicates (ex. "IN" or one-
 -- sided predicates), but make sure things still behave--i.e. these queries
@@ -2779,101 +2931,75 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 4
 			Rows seen = 1
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 4
 				Rows seen = 1
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 4
-					Rows seen = 1
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (16):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 4
 			Rows seen = 0
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 4
 				Rows seen = 0
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 4
-					Rows seen = 0
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> -- Make sure predicates are pushed even if the subquery is explicit (as
 -- opposed to a view). Should see index scans on T3 and T4.
@@ -3018,102 +3144,76 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (10):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 7
 			Rows seen = 6
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 6
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 6
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 7
 			Rows seen = 3
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 3
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 3
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> -- In this case optimizer will consider pushing predicate to X1 but will
 -- choose not to because it's cheaper to push the predicate to T3.
@@ -3400,102 +3500,76 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (9):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 10
 			Rows seen = 8
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 10
 				Rows seen = 8
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 10
-					Rows seen = 8
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (12):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 10
 			Rows seen = 4
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 10
 				Rows seen = 4
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 10
-					Rows seen = 4
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> select * from
   (select * from t1 union all select * from t2) x1,
@@ -3611,102 +3685,76 @@ Right result set:
 		next time (milliseconds) = 0
 		close time (milliseconds) = 0
 	Left result set:
-		Project-Restrict ResultSet (8):
+		Index Row to Base Row ResultSet for T3:
 		Number of opens = 10
 		Rows seen = 8
-		Rows filtered = 0
-		restriction = false
-		projection = false
+		Columns accessed from heap = {1}
 			constructor time (milliseconds) = 0
 			open time (milliseconds) = 0
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
-			restriction time (milliseconds) = 0
-			projection time (milliseconds) = 0
-		Source result set:
-			Index Row to Base Row ResultSet for T3:
+			Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 			Number of opens = 10
 			Rows seen = 8
-			Columns accessed from heap = {1}
+			Rows filtered = 0
+			Fetch Size = 1
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-				Number of opens = 10
-				Rows seen = 8
-				Rows filtered = 0
-				Fetch Size = 1
-					constructor time (milliseconds) = 0
-					open time (milliseconds) = 0
-					next time (milliseconds) = 0
-					close time (milliseconds) = 0
-					next time in milliseconds/row = 0
-				scan information: 
-					Bit set of columns fetched=All
-					Number of columns fetched=2
-					Number of deleted rows visited=0
-					Number of pages visited=3
-					Number of rows qualified=0
-					Number of rows visited=1
-					Scan type=btree
-					Tree height=3
-					start position: 
+				next time in milliseconds/row = 0
+			scan information: 
+				Bit set of columns fetched=All
+				Number of columns fetched=2
+				Number of deleted rows visited=0
+				Number of pages visited=3
+				Number of rows qualified=0
+				Number of rows visited=1
+				Scan type=btree
+				Tree height=3
+				start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-					stop position: 
+				stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-					qualifiers:
+				qualifiers:
 None
 	Right result set:
-		Project-Restrict ResultSet (11):
+		Index Row to Base Row ResultSet for T4:
 		Number of opens = 10
 		Rows seen = 4
-		Rows filtered = 0
-		restriction = false
-		projection = false
+		Columns accessed from heap = {1}
 			constructor time (milliseconds) = 0
 			open time (milliseconds) = 0
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
-			restriction time (milliseconds) = 0
-			projection time (milliseconds) = 0
-		Source result set:
-			Index Row to Base Row ResultSet for T4:
+			Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 			Number of opens = 10
 			Rows seen = 4
-			Columns accessed from heap = {1}
+			Rows filtered = 0
+			Fetch Size = 1
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-				Number of opens = 10
-				Rows seen = 4
-				Rows filtered = 0
-				Fetch Size = 1
-					constructor time (milliseconds) = 0
-					open time (milliseconds) = 0
-					next time (milliseconds) = 0
-					close time (milliseconds) = 0
-					next time in milliseconds/row = 0
-				scan information: 
-					Bit set of columns fetched=All
-					Number of columns fetched=2
-					Number of deleted rows visited=0
-					Number of pages visited=3
-					Number of rows qualified=0
-					Number of rows visited=1
-					Scan type=btree
-					Tree height=3
-					start position: 
+				next time in milliseconds/row = 0
+			scan information: 
+				Bit set of columns fetched=All
+				Number of columns fetched=2
+				Number of deleted rows visited=0
+				Number of pages visited=3
+				Number of rows qualified=0
+				Number of rows visited=1
+				Scan type=btree
+				Tree height=3
+				start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-					stop position: 
+				stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-					qualifiers:
+				qualifiers:
 None
 ij> -- Predicate with both sides referencing same UNION isn't a join predicate, so
 -- no pushing should happen.  So should see regular table scans on all tables.
@@ -3744,124 +3792,85 @@ Rows returned = 0
 	next time (milliseconds) = 0
 	close time (milliseconds) = 0
 Left result set:
-	Sort ResultSet:
+	Project-Restrict ResultSet (6):
 	Number of opens = 1
-	Rows input = 0
-	Rows returned = 0
-	Eliminate duplicates = true
-	In sorted order = false
-	Sort information: 
-		Number of rows input=0
-		Number of rows output=0
+	Rows seen = 7
+	Rows filtered = 7
+	restriction = true
+	projection = true
 		constructor time (milliseconds) = 0
 		open time (milliseconds) = 0
 		next time (milliseconds) = 0
 		close time (milliseconds) = 0
+		restriction time (milliseconds) = 0
+		projection time (milliseconds) = 0
 	Source result set:
-		Union ResultSet:
+		Sort ResultSet:
 		Number of opens = 1
-		Rows seen from the left = 0
-		Rows seen from the right = 0
-		Rows returned = 0
+		Rows input = 10
+		Rows returned = 7
+		Eliminate duplicates = true
+		In sorted order = false
+		Sort information: 
+			Number of rows input=10
+			Number of rows output=7
 			constructor time (milliseconds) = 0
 			open time (milliseconds) = 0
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
-		Left result set:
-			Project-Restrict ResultSet (6):
+		Source result set:
+			Union ResultSet:
 			Number of opens = 1
-			Rows seen = 0
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Rows seen from the left = 5
+			Rows seen from the right = 5
+			Rows returned = 10
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Project-Restrict ResultSet (5):
+			Left result set:
+				Table Scan ResultSet for T1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 1
 				Rows seen = 5
-				Rows filtered = 5
-				restriction = true
-				projection = false
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Table Scan ResultSet for T1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 1
-					Rows seen = 5
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of pages visited=1
-						Number of rows qualified=5
-						Number of rows visited=5
-						Scan type=heap
-						start position: 
-null						stop position: 
-null						qualifiers:
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of pages visited=1
+					Number of rows qualified=5
+					Number of rows visited=5
+					Scan type=heap
+					start position: 
+null					stop position: 
+null					qualifiers:
 None
-		Right result set:
-			Project-Restrict ResultSet (9):
-			Number of opens = 1
-			Rows seen = 0
-			Rows filtered = 0
-			restriction = false
-			projection = false
-				constructor time (milliseconds) = 0
-				open time (milliseconds) = 0
-				next time (milliseconds) = 0
-				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Project-Restrict ResultSet (8):
+			Right result set:
+				Table Scan ResultSet for T2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 1
 				Rows seen = 5
-				Rows filtered = 5
-				restriction = true
-				projection = false
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Table Scan ResultSet for T2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 1
-					Rows seen = 5
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of pages visited=1
-						Number of rows qualified=5
-						Number of rows visited=5
-						Scan type=heap
-						start position: 
-null						stop position: 
-null						qualifiers:
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of pages visited=1
+					Number of rows qualified=5
+					Number of rows visited=5
+					Scan type=heap
+					start position: 
+null					stop position: 
+null					qualifiers:
 None
 Right result set:
 	Sort ResultSet:
@@ -4058,102 +4067,76 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (10):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 7
 			Rows seen = 6
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 6
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 6
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 7
 			Rows seen = 3
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 3
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 3
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> select * from
   (select * from t1 union select * from t2) x1 (a, b),
@@ -4294,102 +4277,76 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (10):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 7
 			Rows seen = 6
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 6
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 6
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 7
 			Rows seen = 3
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 3
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 3
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> -- In this query the optimizer will consider pushing, but will find
 -- that it's cheaper to do a hash join and thus will _not_ push.  So
@@ -4857,117 +4814,42 @@ Right result set:
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
 			Left result set:
-				Project-Restrict ResultSet (15):
+				Index Row to Base Row ResultSet for T3:
 				Number of opens = 7
 				Rows seen = 6
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {1}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T3:
+					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 7
 					Rows seen = 6
-					Columns accessed from heap = {1}
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 7
-						Rows seen = 6
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-							next time in milliseconds/row = 0
-						scan information: 
-							Bit set of columns fetched=All
-							Number of columns fetched=2
-							Number of deleted rows visited=0
-							Number of pages visited=3
-							Number of rows qualified=0
-							Number of rows visited=1
-							Scan type=btree
-							Tree height=3
-							start position: 
-	>= on first 1 column(s).
-	Ordered null semantics on the following columns: 
-							stop position: 
-	> on first 1 column(s).
-	Ordered null semantics on the following columns: 
-							qualifiers:
-None
-			Right result set:
-				Project-Restrict ResultSet (18):
-				Number of opens = 7
-				Rows seen = 3
-				Rows filtered = 0
-				restriction = false
-				projection = false
-					constructor time (milliseconds) = 0
-					open time (milliseconds) = 0
-					next time (milliseconds) = 0
-					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T4:
-					Number of opens = 7
-					Rows seen = 3
-					Columns accessed from heap = {1}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 7
-						Rows seen = 3
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-							next time in milliseconds/row = 0
-						scan information: 
-							Bit set of columns fetched=All
-							Number of columns fetched=2
-							Number of deleted rows visited=0
-							Number of pages visited=3
-							Number of rows qualified=0
-							Number of rows visited=1
-							Scan type=btree
-							Tree height=3
-							start position: 
+						next time in milliseconds/row = 0
+					scan information: 
+						Bit set of columns fetched=All
+						Number of columns fetched=2
+						Number of deleted rows visited=0
+						Number of pages visited=3
+						Number of rows qualified=0
+						Number of rows visited=1
+						Scan type=btree
+						Tree height=3
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
-		Right result set:
-			Project-Restrict ResultSet (21):
-			Number of opens = 7
-			Rows seen = 3
-			Rows filtered = 0
-			restriction = false
-			projection = false
-				constructor time (milliseconds) = 0
-				open time (milliseconds) = 0
-				next time (milliseconds) = 0
-				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
+			Right result set:
 				Index Row to Base Row ResultSet for T4:
 				Number of opens = 7
 				Rows seen = 3
@@ -5002,6 +4884,42 @@ None
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
 						qualifiers:
+None
+		Right result set:
+			Index Row to Base Row ResultSet for T4:
+			Number of opens = 7
+			Rows seen = 3
+			Columns accessed from heap = {1}
+				constructor time (milliseconds) = 0
+				open time (milliseconds) = 0
+				next time (milliseconds) = 0
+				close time (milliseconds) = 0
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
+				Number of opens = 7
+				Rows seen = 3
+				Rows filtered = 0
+				Fetch Size = 1
+					constructor time (milliseconds) = 0
+					open time (milliseconds) = 0
+					next time (milliseconds) = 0
+					close time (milliseconds) = 0
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
+	>= on first 1 column(s).
+	Ordered null semantics on the following columns: 
+					stop position: 
+	> on first 1 column(s).
+	Ordered null semantics on the following columns: 
+					qualifiers:
 None
 ij> -- Nested unions with non-join predicates should work as usual (no change
 -- with DERBY-805).  So should see scalar qualifiers on scans for all
@@ -5562,101 +5480,75 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (10):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 7
 			Rows seen = 2
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 2
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 2
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (13):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 7
 			Rows seen = 0
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {0}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 7
 				Rows seen = 0
-				Columns accessed from heap = {0}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 7
-					Rows seen = 0
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> -- Can't push predicates into VALUES clauses.  Predicate should end up
 -- at V2 (T3 and T4).
@@ -5885,102 +5777,76 @@ Right result set:
 			next time (milliseconds) = 0
 			close time (milliseconds) = 0
 		Left result set:
-			Project-Restrict ResultSet (18):
+			Index Row to Base Row ResultSet for T3:
 			Number of opens = 11
 			Rows seen = 10
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T3:
+				Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 11
 				Rows seen = 10
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 11
-					Rows seen = 10
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 		Right result set:
-			Project-Restrict ResultSet (21):
+			Index Row to Base Row ResultSet for T4:
 			Number of opens = 11
 			Rows seen = 5
-			Rows filtered = 0
-			restriction = false
-			projection = false
+			Columns accessed from heap = {1}
 				constructor time (milliseconds) = 0
 				open time (milliseconds) = 0
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
-				restriction time (milliseconds) = 0
-				projection time (milliseconds) = 0
-			Source result set:
-				Index Row to Base Row ResultSet for T4:
+				Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 				Number of opens = 11
 				Rows seen = 5
-				Columns accessed from heap = {1}
+				Rows filtered = 0
+				Fetch Size = 1
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-					Number of opens = 11
-					Rows seen = 5
-					Rows filtered = 0
-					Fetch Size = 1
-						constructor time (milliseconds) = 0
-						open time (milliseconds) = 0
-						next time (milliseconds) = 0
-						close time (milliseconds) = 0
-						next time in milliseconds/row = 0
-					scan information: 
-						Bit set of columns fetched=All
-						Number of columns fetched=2
-						Number of deleted rows visited=0
-						Number of pages visited=3
-						Number of rows qualified=0
-						Number of rows visited=1
-						Scan type=btree
-						Tree height=3
-						start position: 
+					next time in milliseconds/row = 0
+				scan information: 
+					Bit set of columns fetched=All
+					Number of columns fetched=2
+					Number of deleted rows visited=0
+					Number of pages visited=3
+					Number of rows qualified=0
+					Number of rows visited=1
+					Scan type=btree
+					Tree height=3
+					start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						stop position: 
+					stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-						qualifiers:
+					qualifiers:
 None
 ij> -- Can't push predicates into VALUES clauses.  Optimizer might consider pushing
 -- but shouldn't do it; in the end we'll do a hash join between X1 and T2.
@@ -6402,7 +6268,7 @@ null				stop position:
 null				qualifiers:
 None
 Right result set:
-	Project-Restrict ResultSet (26):
+	Project-Restrict ResultSet (25):
 	Number of opens = 11
 	Rows seen = 1127
 	Rows filtered = 1108
@@ -6515,53 +6381,40 @@ None
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
 			Right result set:
-				Project-Restrict ResultSet (25):
+				Index Row to Base Row ResultSet for T4:
 				Number of opens = 11
 				Rows seen = 5
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {1}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
-					next time (milliseconds) = 0
-					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T4:
+					next time (milliseconds) = 0
+					close time (milliseconds) = 0
+					Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 11
 					Rows seen = 5
-					Columns accessed from heap = {1}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 11
-						Rows seen = 5
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-							next time in milliseconds/row = 0
-						scan information: 
-							Bit set of columns fetched=All
-							Number of columns fetched=2
-							Number of deleted rows visited=0
-							Number of pages visited=3
-							Number of rows qualified=0
-							Number of rows visited=1
-							Scan type=btree
-							Tree height=3
-							start position: 
+						next time in milliseconds/row = 0
+					scan information: 
+						Bit set of columns fetched=All
+						Number of columns fetched=2
+						Number of deleted rows visited=0
+						Number of pages visited=3
+						Number of rows qualified=0
+						Number of rows visited=1
+						Scan type=btree
+						Tree height=3
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 ij> -- Make sure optimizer is still considering predicates for other, non-UNION
 -- nodes.  Here we should use the predicate to do a hash join between X0 and
@@ -6866,7 +6719,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (21):
+Project-Restrict ResultSet (19):
 Number of opens = 1
 Rows seen = 1
 Rows filtered = 0
@@ -6888,7 +6741,7 @@ Source result set:
 		close time (milliseconds) = 0
 	Index Key Optimization = false
 	Source result set:
-		Project-Restrict ResultSet (20):
+		Project-Restrict ResultSet (18):
 		Number of opens = 1
 		Rows seen = 909
 		Rows filtered = 0
@@ -7015,102 +6868,76 @@ None
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
 						Left result set:
-							Project-Restrict ResultSet (12):
+							Index Row to Base Row ResultSet for T4:
 							Number of opens = 7
 							Rows seen = 3
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {1}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T4:
+								Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 3
-								Columns accessed from heap = {1}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 3
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-										next time in milliseconds/row = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+									next time in milliseconds/row = 0
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 						Right result set:
-							Project-Restrict ResultSet (15):
+							Index Row to Base Row ResultSet for T3:
 							Number of opens = 7
 							Rows seen = 6
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {1}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T3:
+								Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 6
-								Columns accessed from heap = {1}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 6
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-										next time in milliseconds/row = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+									next time in milliseconds/row = 0
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 			Right result set:
 				Sort ResultSet:
@@ -7214,7 +7041,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (25):
+Project-Restrict ResultSet (21):
 Number of opens = 1
 Rows seen = 1
 Rows filtered = 0
@@ -7236,7 +7063,7 @@ Source result set:
 		close time (milliseconds) = 0
 	Index Key Optimization = false
 	Source result set:
-		Project-Restrict ResultSet (24):
+		Project-Restrict ResultSet (20):
 		Number of opens = 1
 		Rows seen = 9
 		Rows filtered = 0
@@ -7363,102 +7190,76 @@ None
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
 						Left result set:
-							Project-Restrict ResultSet (12):
+							Index Row to Base Row ResultSet for T4:
 							Number of opens = 7
 							Rows seen = 3
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {1}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T4:
+								Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 3
-								Columns accessed from heap = {1}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T4 using index T4_IX1 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 3
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-										next time in milliseconds/row = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+									next time in milliseconds/row = 0
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 						Right result set:
-							Project-Restrict ResultSet (15):
+							Index Row to Base Row ResultSet for T3:
 							Number of opens = 7
 							Rows seen = 6
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {1}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T3:
+								Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 6
-								Columns accessed from heap = {1}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T3 using index T3_IX1 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 6
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-										next time in milliseconds/row = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+									next time in milliseconds/row = 0
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 			Right result set:
 				Sort ResultSet:
@@ -7485,102 +7286,76 @@ None
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
 					Left result set:
-						Project-Restrict ResultSet (20):
+						Index Row to Base Row ResultSet for T3:
 						Number of opens = 9
 						Rows seen = 6
-						Rows filtered = 0
-						restriction = false
-						projection = false
+						Columns accessed from heap = {0}
 							constructor time (milliseconds) = 0
 							open time (milliseconds) = 0
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
-							restriction time (milliseconds) = 0
-							projection time (milliseconds) = 0
-						Source result set:
-							Index Row to Base Row ResultSet for T3:
+							Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 							Number of opens = 9
 							Rows seen = 6
-							Columns accessed from heap = {0}
+							Rows filtered = 0
+							Fetch Size = 1
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-								Number of opens = 9
-								Rows seen = 6
-								Rows filtered = 0
-								Fetch Size = 1
-									constructor time (milliseconds) = 0
-									open time (milliseconds) = 0
-									next time (milliseconds) = 0
-									close time (milliseconds) = 0
-									next time in milliseconds/row = 0
-								scan information: 
-									Bit set of columns fetched=All
-									Number of columns fetched=2
-									Number of deleted rows visited=0
-									Number of pages visited=3
-									Number of rows qualified=0
-									Number of rows visited=1
-									Scan type=btree
-									Tree height=3
-									start position: 
+								next time in milliseconds/row = 0
+							scan information: 
+								Bit set of columns fetched=All
+								Number of columns fetched=2
+								Number of deleted rows visited=0
+								Number of pages visited=3
+								Number of rows qualified=0
+								Number of rows visited=1
+								Scan type=btree
+								Tree height=3
+								start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-									stop position: 
+								stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-									qualifiers:
+								qualifiers:
 None
 					Right result set:
-						Project-Restrict ResultSet (23):
+						Index Row to Base Row ResultSet for T4:
 						Number of opens = 9
 						Rows seen = 3
-						Rows filtered = 0
-						restriction = false
-						projection = false
+						Columns accessed from heap = {0}
 							constructor time (milliseconds) = 0
 							open time (milliseconds) = 0
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
-							restriction time (milliseconds) = 0
-							projection time (milliseconds) = 0
-						Source result set:
-							Index Row to Base Row ResultSet for T4:
+							Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 							Number of opens = 9
 							Rows seen = 3
-							Columns accessed from heap = {0}
+							Rows filtered = 0
+							Fetch Size = 1
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-								Number of opens = 9
-								Rows seen = 3
-								Rows filtered = 0
-								Fetch Size = 1
-									constructor time (milliseconds) = 0
-									open time (milliseconds) = 0
-									next time (milliseconds) = 0
-									close time (milliseconds) = 0
-									next time in milliseconds/row = 0
-								scan information: 
-									Bit set of columns fetched=All
-									Number of columns fetched=2
-									Number of deleted rows visited=0
-									Number of pages visited=3
-									Number of rows qualified=1
-									Number of rows visited=2
-									Scan type=btree
-									Tree height=3
-									start position: 
+								next time in milliseconds/row = 0
+							scan information: 
+								Bit set of columns fetched=All
+								Number of columns fetched=2
+								Number of deleted rows visited=0
+								Number of pages visited=3
+								Number of rows qualified=1
+								Number of rows visited=2
+								Scan type=btree
+								Tree height=3
+								start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-									stop position: 
+								stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-									qualifiers:
+								qualifiers:
 None
 ij> -- Predicates pushed from outer queries shouldn't interfere with inner
 -- predicates for subqueries.  Mostly checking for correct results here.
@@ -8486,7 +8261,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (17):
+Project-Restrict ResultSet (15):
 Number of opens = 1
 Rows seen = 1
 Rows filtered = 0
@@ -8508,7 +8283,7 @@ Source result set:
 		close time (milliseconds) = 0
 	Index Key Optimization = false
 	Source result set:
-		Project-Restrict ResultSet (16):
+		Project-Restrict ResultSet (14):
 		Number of opens = 1
 		Rows seen = 2
 		Rows filtered = 0
@@ -8521,7 +8296,7 @@ Source result set:
 			restriction time (milliseconds) = 0
 			projection time (milliseconds) = 0
 		Source result set:
-			Project-Restrict ResultSet (15):
+			Project-Restrict ResultSet (13):
 			Number of opens = 1
 			Rows seen = 2
 			Rows filtered = 0
@@ -8637,101 +8412,75 @@ None
 							next time (milliseconds) = 0
 							close time (milliseconds) = 0
 						Left result set:
-							Project-Restrict ResultSet (11):
+							Index Row to Base Row ResultSet for T3:
 							Number of opens = 7
 							Rows seen = 2
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {0}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T3:
+								Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 2
-								Columns accessed from heap = {0}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 2
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-										next time in milliseconds/row = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+									next time in milliseconds/row = 0
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 						Right result set:
-							Project-Restrict ResultSet (14):
+							Index Row to Base Row ResultSet for T4:
 							Number of opens = 7
 							Rows seen = 0
-							Rows filtered = 0
-							restriction = false
-							projection = false
+							Columns accessed from heap = {0}
 								constructor time (milliseconds) = 0
 								open time (milliseconds) = 0
 								next time (milliseconds) = 0
 								close time (milliseconds) = 0
-								restriction time (milliseconds) = 0
-								projection time (milliseconds) = 0
-							Source result set:
-								Index Row to Base Row ResultSet for T4:
+								Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 								Number of opens = 7
 								Rows seen = 0
-								Columns accessed from heap = {0}
+								Rows filtered = 0
+								Fetch Size = 1
 									constructor time (milliseconds) = 0
 									open time (milliseconds) = 0
 									next time (milliseconds) = 0
 									close time (milliseconds) = 0
-									Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-									Number of opens = 7
-									Rows seen = 0
-									Rows filtered = 0
-									Fetch Size = 1
-										constructor time (milliseconds) = 0
-										open time (milliseconds) = 0
-										next time (milliseconds) = 0
-										close time (milliseconds) = 0
-									scan information: 
-										Bit set of columns fetched=All
-										Number of columns fetched=2
-										Number of deleted rows visited=0
-										Number of pages visited=3
-										Number of rows qualified=0
-										Number of rows visited=1
-										Scan type=btree
-										Tree height=3
-										start position: 
+								scan information: 
+									Bit set of columns fetched=All
+									Number of columns fetched=2
+									Number of deleted rows visited=0
+									Number of pages visited=3
+									Number of rows qualified=0
+									Number of rows visited=1
+									Scan type=btree
+									Tree height=3
+									start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										stop position: 
+									stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-										qualifiers:
+									qualifiers:
 None
 ij> -- Multiple subqueries but NO UNIONs.  All predicates are used for joins
 -- at their current level (no pushing).
@@ -9386,7 +9135,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (17):
+Project-Restrict ResultSet (15):
 Number of opens = 1
 Rows seen = 0
 Rows filtered = 0
@@ -9552,84 +9301,58 @@ Negate comparison result: false
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
 			Left result set:
-				Project-Restrict ResultSet (13):
+				Index Row to Base Row ResultSet for T4:
 				Number of opens = 0
 				Rows seen = 0
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T4:
+					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 0
 					Rows seen = 0
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 0
-						Rows seen = 0
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-						scan information: 
-							start position: 
+					scan information: 
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 			Right result set:
-				Project-Restrict ResultSet (16):
+				Index Row to Base Row ResultSet for T3:
 				Number of opens = 0
 				Rows seen = 0
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T3:
+					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 0
 					Rows seen = 0
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 0
-						Rows seen = 0
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-						scan information: 
-							start position: 
+					scan information: 
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 ij> -- Same as above but without the inner predicate (so no
 -- hash on T6).
@@ -9669,7 +9392,7 @@ End Compilation Timestamp : null
 Begin Execution Timestamp : null
 End Execution Timestamp : null
 Statement Execution Plan Text: 
-Project-Restrict ResultSet (16):
+Project-Restrict ResultSet (14):
 Number of opens = 1
 Rows seen = 0
 Rows filtered = 0
@@ -9815,84 +9538,58 @@ None
 				next time (milliseconds) = 0
 				close time (milliseconds) = 0
 			Left result set:
-				Project-Restrict ResultSet (12):
+				Index Row to Base Row ResultSet for T4:
 				Number of opens = 0
 				Rows seen = 0
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T4:
+					Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 0
 					Rows seen = 0
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T4 using index T4_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 0
-						Rows seen = 0
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-						scan information: 
-							start position: 
+					scan information: 
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 			Right result set:
-				Project-Restrict ResultSet (15):
+				Index Row to Base Row ResultSet for T3:
 				Number of opens = 0
 				Rows seen = 0
-				Rows filtered = 0
-				restriction = false
-				projection = false
+				Columns accessed from heap = {0}
 					constructor time (milliseconds) = 0
 					open time (milliseconds) = 0
 					next time (milliseconds) = 0
 					close time (milliseconds) = 0
-					restriction time (milliseconds) = 0
-					projection time (milliseconds) = 0
-				Source result set:
-					Index Row to Base Row ResultSet for T3:
+					Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
 					Number of opens = 0
 					Rows seen = 0
-					Columns accessed from heap = {0}
+					Rows filtered = 0
+					Fetch Size = 1
 						constructor time (milliseconds) = 0
 						open time (milliseconds) = 0
 						next time (milliseconds) = 0
 						close time (milliseconds) = 0
-						Index Scan ResultSet for T3 using index T3_IX2 at read committed isolation level using share row locking chosen by the optimizer
-						Number of opens = 0
-						Rows seen = 0
-						Rows filtered = 0
-						Fetch Size = 1
-							constructor time (milliseconds) = 0
-							open time (milliseconds) = 0
-							next time (milliseconds) = 0
-							close time (milliseconds) = 0
-						scan information: 
-							start position: 
+					scan information: 
+						start position: 
 	>= on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							stop position: 
+						stop position: 
 	> on first 1 column(s).
 	Ordered null semantics on the following columns: 
-							qualifiers:
+						qualifiers:
 None
 ij> -- Same as above, but without the outer predicate.  Should see
 -- table scan on T3 and T4 (because nothing is pushed).
@@ -10227,4 +9924,638 @@ ij> drop table xx1;
 0 rows inserted/updated/deleted
 ij> drop table yy1;
 0 rows inserted/updated/deleted
+ij> -- DERBY-1633: Nested UNIONs of views with different column orderings
+-- leads to incorrectly scoped predicates.  We have a lot of different
+-- tables and views here to try to cover several different situations.
+-- Note that all of the views use DISTINCT because we don't want
+-- the views to be flattened and Derby doesn't flatten select
+-- queries with DISTINCT in them.
+CREATE TABLE "APP"."T1" ("I" INTEGER, "D" DOUBLE, "C" CHAR(10));
+0 rows inserted/updated/deleted
+ij> CREATE TABLE "APP"."T2" ("I2" INTEGER, "D2" DOUBLE, "C2" CHAR(10));
+0 rows inserted/updated/deleted
+ij> CREATE TABLE "APP"."T3" ("I3" INTEGER, "D3" DOUBLE, "C3" CHAR(10));
+0 rows inserted/updated/deleted
+ij> insert into t1 values (1, -1, '1'), (2, -2, '2');
+2 rows inserted/updated/deleted
+ij> insert into t2 values (2, -2, '2'), (4, -4, '4'), (8, -8, '8');
+3 rows inserted/updated/deleted
+ij> insert into t3 values (3, -3, '3'), (6, -6, '6'), (9, -9, '9');
+3 rows inserted/updated/deleted
+ij> CREATE TABLE "APP"."T4" ("C4" CHAR(10));
+0 rows inserted/updated/deleted
+ij> insert into t4 values '1', '2', '3', '4', '5', '6', '7', '8', '9';
+9 rows inserted/updated/deleted
+ij> insert into t4 select rtrim(c4) || rtrim(c4) from t4;
+9 rows inserted/updated/deleted
+ij> CREATE TABLE "APP"."T5" ("I5" INTEGER, "D5" DOUBLE, "C5" CHAR(10));
+0 rows inserted/updated/deleted
+ij> CREATE TABLE "APP"."T6" ("I6" INTEGER, "D6" DOUBLE, "C6" CHAR(10));
+0 rows inserted/updated/deleted
+ij> insert into t5
+  values (100, 100.0, '100'), (200, 200.0, '200'), (300, 300.0, '300');
+3 rows inserted/updated/deleted
+ij> insert into t6
+  values (400, 400.0, '400'), (200, 200.0, '200'), (300, 300.0, '300');
+3 rows inserted/updated/deleted
+ij> create view v_keycol_at_pos_3 as
+  select distinct i col1, d col2, c col3 from t1;
+0 rows inserted/updated/deleted
+ij> create view v1_keycol_at_pos_2 as
+  select distinct i2 col1, c2 col3, d2 col2 from t2;
+0 rows inserted/updated/deleted
+ij> create view v2_keycol_at_pos_2 as
+  select distinct i3 col1, c3 col3, d3 col2 from t3;
+0 rows inserted/updated/deleted
+ij> create view v1_intersect as
+  select distinct i5 col1, c5 col3, d5 col2 from t5;
+0 rows inserted/updated/deleted
+ij> create view v2_intersect as
+  select distinct i6 col1, c6 col3, d6 col2 from t6;
+0 rows inserted/updated/deleted
+ij> create view v1_values as
+  select distinct vals1 col1, vals2 col2, vals3 col3 from
+    (values (321, 321.0, '321'), (432, 432.0, '432'),
+      (654, 654.0, '654')
+    ) VT(vals1, vals2, vals3);
+0 rows inserted/updated/deleted
+ij> create view v_union as
+  select distinct i col1, d col2, c col3 from t1
+    union select distinct i3 col1, d3 col2, c3 col3 from t3;
+0 rows inserted/updated/deleted
+ij> -- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The right child of the top-level
+-- node is a view that is a simple select from a table.
+create view topview as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   union
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+  );
+0 rows inserted/updated/deleted
+ij> -- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The right child of the top-level
+-- node is a view that is a select from yet another
+-- UNION node.
+create view topview2 as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   union
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+     from v_union vu
+  );
+0 rows inserted/updated/deleted
+ij> -- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is an INTERSECT node to which
+-- predicates cannot (currently) be pushed.  In this
+-- case the intersect returns an empty result set.
+create view topview3 (col0, col3, col1) as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   intersect
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+     from v_union vu
+  );
+0 rows inserted/updated/deleted
+ij> -- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is an INTERSECT node to which
+-- predicates cannot (currently) be pushed.  In this
+-- case the intersect returns a couple of rows.
+create view topview4 (col0, col3, col1) as
+  (select distinct 'intersect:' col0, vi1.col3, vi1.col1
+    from v1_intersect vi1
+   intersect
+    select distinct 'intersect:' col0, vi2.col3, vi2.col1
+     from v2_intersect vi2
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+   from v_union vu
+  );
+0 rows inserted/updated/deleted
+ij> -- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is a view that is a selet from
+-- a VALUES list (i.e. no base table).
+create view topview5 (col0, col3, col1) as
+  (select distinct 'values:' col0, vv1.col3, vv1.col1
+    from v1_values vv1
+   union
+    select distinct 'intersect:' col0, vi2.col3, vi2.col1
+     from v2_intersect vi2
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+   from v_union vu
+  );
+0 rows inserted/updated/deleted
+ij> -- All of the following queries failed at some point while finalizing
+-- the fix for DERBY-1633; some failed with error 42818, others
+-- failed with execution-time NPEs caused by incorrect (esp. double)
+-- remapping.  The point here is to see how the top-level
+-- predicates are pushed through the nested unions to the
+-- bottom-most children.  Use of LEFT JOINs with NESTEDLOOP
+-- effectively allows us to force the join order and thus to
+-- ensure the predicates are pushed to the desired top-level
+-- at execution time.  All such queries are run once with
+-- NESTEDLOOP and once without, to make sure things work
+-- in both cases.
+select * from t4, topview where t4.c4 = topview.col3;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+4         |t2stuff:|4         |4          
+8         |t2stuff:|8         |8          
+3         |t3stuff:|3         |3          
+6         |t3stuff:|6         |6          
+9         |t3stuff:|9         |9          
+ij> select * from t4, topview where topview.col3 = t4.c4;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+4         |t2stuff:|4         |4          
+8         |t2stuff:|8         |8          
+3         |t3stuff:|3         |3          
+6         |t3stuff:|6         |6          
+9         |t3stuff:|9         |9          
+ij> select * from topview x1, topview where topview.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0    |COL3      |COL1       
+---------------------------------------------------------------
+other:  |1         |1          |other:  |1         |1          
+other:  |2         |2          |other:  |2         |2          
+other:  |2         |2          |t2stuff:|2         |2          
+t2stuff:|2         |2          |other:  |2         |2          
+t2stuff:|2         |2          |t2stuff:|2         |2          
+t2stuff:|4         |4          |t2stuff:|4         |4          
+t2stuff:|8         |8          |t2stuff:|8         |8          
+t3stuff:|3         |3          |t3stuff:|3         |3          
+t3stuff:|6         |6          |t3stuff:|6         |6          
+t3stuff:|9         |9          |t3stuff:|9         |9          
+ij> select * from t4, topview2 where t4.c4 = topview2.col3;
+C4        |COL0      |COL3      |COL1       
+--------------------------------------------
+1         |morestuff:|1         |1          
+2         |morestuff:|2         |2          
+3         |morestuff:|3         |3          
+6         |morestuff:|6         |6          
+9         |morestuff:|9         |9          
+1         |other:    |1         |1          
+2         |other:    |2         |2          
+2         |t2stuff:  |2         |2          
+4         |t2stuff:  |4         |4          
+8         |t2stuff:  |8         |8          
+3         |t3stuff:  |3         |3          
+6         |t3stuff:  |6         |6          
+9         |t3stuff:  |9         |9          
+ij> select * from topview2 x1, topview where topview.col3 = x1.col3;
+COL0      |COL3      |COL1       |COL0    |COL3      |COL1       
+-----------------------------------------------------------------
+morestuff:|1         |1          |other:  |1         |1          
+morestuff:|2         |2          |other:  |2         |2          
+morestuff:|2         |2          |t2stuff:|2         |2          
+morestuff:|3         |3          |t3stuff:|3         |3          
+morestuff:|6         |6          |t3stuff:|6         |6          
+morestuff:|9         |9          |t3stuff:|9         |9          
+other:    |1         |1          |other:  |1         |1          
+other:    |2         |2          |other:  |2         |2          
+other:    |2         |2          |t2stuff:|2         |2          
+t2stuff:  |2         |2          |other:  |2         |2          
+t2stuff:  |2         |2          |t2stuff:|2         |2          
+t2stuff:  |4         |4          |t2stuff:|4         |4          
+t2stuff:  |8         |8          |t2stuff:|8         |8          
+t3stuff:  |3         |3          |t3stuff:|3         |3          
+t3stuff:  |6         |6          |t3stuff:|6         |6          
+t3stuff:  |9         |9          |t3stuff:|9         |9          
+ij> select * from t4
+  left join topview
+  on t4.c4 = topview.col3;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+3         |t3stuff:|3         |3          
+4         |t2stuff:|4         |4          
+5         |NULL    |NULL      |NULL       
+6         |t3stuff:|6         |6          
+7         |NULL    |NULL      |NULL       
+8         |t2stuff:|8         |8          
+9         |t3stuff:|9         |9          
+11        |NULL    |NULL      |NULL       
+22        |NULL    |NULL      |NULL       
+33        |NULL    |NULL      |NULL       
+44        |NULL    |NULL      |NULL       
+55        |NULL    |NULL      |NULL       
+66        |NULL    |NULL      |NULL       
+77        |NULL    |NULL      |NULL       
+88        |NULL    |NULL      |NULL       
+99        |NULL    |NULL      |NULL       
+ij> select * from t4
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on t4.c4 = topview.col3;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+3         |t3stuff:|3         |3          
+4         |t2stuff:|4         |4          
+5         |NULL    |NULL      |NULL       
+6         |t3stuff:|6         |6          
+7         |NULL    |NULL      |NULL       
+8         |t2stuff:|8         |8          
+9         |t3stuff:|9         |9          
+11        |NULL    |NULL      |NULL       
+22        |NULL    |NULL      |NULL       
+33        |NULL    |NULL      |NULL       
+44        |NULL    |NULL      |NULL       
+55        |NULL    |NULL      |NULL       
+66        |NULL    |NULL      |NULL       
+77        |NULL    |NULL      |NULL       
+88        |NULL    |NULL      |NULL       
+99        |NULL    |NULL      |NULL       
+ij> select * from t4
+  left join topview
+  on topview.col3 = t4.c4;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+3         |t3stuff:|3         |3          
+4         |t2stuff:|4         |4          
+5         |NULL    |NULL      |NULL       
+6         |t3stuff:|6         |6          
+7         |NULL    |NULL      |NULL       
+8         |t2stuff:|8         |8          
+9         |t3stuff:|9         |9          
+11        |NULL    |NULL      |NULL       
+22        |NULL    |NULL      |NULL       
+33        |NULL    |NULL      |NULL       
+44        |NULL    |NULL      |NULL       
+55        |NULL    |NULL      |NULL       
+66        |NULL    |NULL      |NULL       
+77        |NULL    |NULL      |NULL       
+88        |NULL    |NULL      |NULL       
+99        |NULL    |NULL      |NULL       
+ij> select * from t4
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = t4.c4;
+C4        |COL0    |COL3      |COL1       
+------------------------------------------
+1         |other:  |1         |1          
+2         |other:  |2         |2          
+2         |t2stuff:|2         |2          
+3         |t3stuff:|3         |3          
+4         |t2stuff:|4         |4          
+5         |NULL    |NULL      |NULL       
+6         |t3stuff:|6         |6          
+7         |NULL    |NULL      |NULL       
+8         |t2stuff:|8         |8          
+9         |t3stuff:|9         |9          
+11        |NULL    |NULL      |NULL       
+22        |NULL    |NULL      |NULL       
+33        |NULL    |NULL      |NULL       
+44        |NULL    |NULL      |NULL       
+55        |NULL    |NULL      |NULL       
+66        |NULL    |NULL      |NULL       
+77        |NULL    |NULL      |NULL       
+88        |NULL    |NULL      |NULL       
+99        |NULL    |NULL      |NULL       
+ij> select * from topview x1
+  left join topview
+  on topview.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0    |COL3      |COL1       
+---------------------------------------------------------------
+other:  |1         |1          |other:  |1         |1          
+other:  |2         |2          |other:  |2         |2          
+other:  |2         |2          |t2stuff:|2         |2          
+t2stuff:|2         |2          |other:  |2         |2          
+t2stuff:|2         |2          |t2stuff:|2         |2          
+t2stuff:|4         |4          |t2stuff:|4         |4          
+t2stuff:|8         |8          |t2stuff:|8         |8          
+t3stuff:|3         |3          |t3stuff:|3         |3          
+t3stuff:|6         |6          |t3stuff:|6         |6          
+t3stuff:|9         |9          |t3stuff:|9         |9          
+ij> select * from topview x1
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0    |COL3      |COL1       
+---------------------------------------------------------------
+other:  |1         |1          |other:  |1         |1          
+other:  |2         |2          |other:  |2         |2          
+other:  |2         |2          |t2stuff:|2         |2          
+t2stuff:|2         |2          |other:  |2         |2          
+t2stuff:|2         |2          |t2stuff:|2         |2          
+t2stuff:|4         |4          |t2stuff:|4         |4          
+t2stuff:|8         |8          |t2stuff:|8         |8          
+t3stuff:|3         |3          |t3stuff:|3         |3          
+t3stuff:|6         |6          |t3stuff:|6         |6          
+t3stuff:|9         |9          |t3stuff:|9         |9          
+ij> select * from t4
+  left join topview2
+  on t4.c4 = topview2.col3;
+C4        |COL0      |COL3      |COL1       
+--------------------------------------------
+1         |morestuff:|1         |1          
+1         |other:    |1         |1          
+2         |morestuff:|2         |2          
+2         |other:    |2         |2          
+2         |t2stuff:  |2         |2          
+3         |morestuff:|3         |3          
+3         |t3stuff:  |3         |3          
+4         |t2stuff:  |4         |4          
+5         |NULL      |NULL      |NULL       
+6         |morestuff:|6         |6          
+6         |t3stuff:  |6         |6          
+7         |NULL      |NULL      |NULL       
+8         |t2stuff:  |8         |8          
+9         |morestuff:|9         |9          
+9         |t3stuff:  |9         |9          
+11        |NULL      |NULL      |NULL       
+22        |NULL      |NULL      |NULL       
+33        |NULL      |NULL      |NULL       
+44        |NULL      |NULL      |NULL       
+55        |NULL      |NULL      |NULL       
+66        |NULL      |NULL      |NULL       
+77        |NULL      |NULL      |NULL       
+88        |NULL      |NULL      |NULL       
+99        |NULL      |NULL      |NULL       
+ij> select * from t4
+  left join topview2 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on t4.c4 = topview2.col3;
+C4        |COL0      |COL3      |COL1       
+--------------------------------------------
+1         |morestuff:|1         |1          
+1         |other:    |1         |1          
+2         |morestuff:|2         |2          
+2         |other:    |2         |2          
+2         |t2stuff:  |2         |2          
+3         |morestuff:|3         |3          
+3         |t3stuff:  |3         |3          
+4         |t2stuff:  |4         |4          
+5         |NULL      |NULL      |NULL       
+6         |morestuff:|6         |6          
+6         |t3stuff:  |6         |6          
+7         |NULL      |NULL      |NULL       
+8         |t2stuff:  |8         |8          
+9         |morestuff:|9         |9          
+9         |t3stuff:  |9         |9          
+11        |NULL      |NULL      |NULL       
+22        |NULL      |NULL      |NULL       
+33        |NULL      |NULL      |NULL       
+44        |NULL      |NULL      |NULL       
+55        |NULL      |NULL      |NULL       
+66        |NULL      |NULL      |NULL       
+77        |NULL      |NULL      |NULL       
+88        |NULL      |NULL      |NULL       
+99        |NULL      |NULL      |NULL       
+ij> select * from topview2 x1
+  left join topview
+  on topview.col3 = x1.col3;
+COL0      |COL3      |COL1       |COL0    |COL3      |COL1       
+-----------------------------------------------------------------
+morestuff:|1         |1          |other:  |1         |1          
+morestuff:|2         |2          |other:  |2         |2          
+morestuff:|2         |2          |t2stuff:|2         |2          
+morestuff:|3         |3          |t3stuff:|3         |3          
+morestuff:|6         |6          |t3stuff:|6         |6          
+morestuff:|9         |9          |t3stuff:|9         |9          
+other:    |1         |1          |other:  |1         |1          
+other:    |2         |2          |other:  |2         |2          
+other:    |2         |2          |t2stuff:|2         |2          
+t2stuff:  |2         |2          |other:  |2         |2          
+t2stuff:  |2         |2          |t2stuff:|2         |2          
+t2stuff:  |4         |4          |t2stuff:|4         |4          
+t2stuff:  |8         |8          |t2stuff:|8         |8          
+t3stuff:  |3         |3          |t3stuff:|3         |3          
+t3stuff:  |6         |6          |t3stuff:|6         |6          
+t3stuff:  |9         |9          |t3stuff:|9         |9          
+ij> select * from topview2 x1
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = x1.col3;
+COL0      |COL3      |COL1       |COL0    |COL3      |COL1       
+-----------------------------------------------------------------
+morestuff:|1         |1          |other:  |1         |1          
+morestuff:|2         |2          |other:  |2         |2          
+morestuff:|2         |2          |t2stuff:|2         |2          
+morestuff:|3         |3          |t3stuff:|3         |3          
+morestuff:|6         |6          |t3stuff:|6         |6          
+morestuff:|9         |9          |t3stuff:|9         |9          
+other:    |1         |1          |other:  |1         |1          
+other:    |2         |2          |other:  |2         |2          
+other:    |2         |2          |t2stuff:|2         |2          
+t2stuff:  |2         |2          |other:  |2         |2          
+t2stuff:  |2         |2          |t2stuff:|2         |2          
+t2stuff:  |4         |4          |t2stuff:|4         |4          
+t2stuff:  |8         |8          |t2stuff:|8         |8          
+t3stuff:  |3         |3          |t3stuff:|3         |3          
+t3stuff:  |6         |6          |t3stuff:|6         |6          
+t3stuff:  |9         |9          |t3stuff:|9         |9          
+ij> select * from topview x1
+  left join topview2
+  on topview2.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |1         |1          |other:    |1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+other:  |2         |2          |other:    |2         |2          
+other:  |2         |2          |t2stuff:  |2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |other:    |2         |2          
+t2stuff:|2         |2          |t2stuff:  |2         |2          
+t2stuff:|4         |4          |t2stuff:  |4         |4          
+t2stuff:|8         |8          |t2stuff:  |8         |8          
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview2 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview2.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |1         |1          |other:    |1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+other:  |2         |2          |other:    |2         |2          
+other:  |2         |2          |t2stuff:  |2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |other:    |2         |2          
+t2stuff:|2         |2          |t2stuff:  |2         |2          
+t2stuff:|4         |4          |t2stuff:  |4         |4          
+t2stuff:|8         |8          |t2stuff:  |8         |8          
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview3
+  on topview3.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview3 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview3.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview4
+  on topview4.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview4 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview4.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview5
+  on topview5.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> select * from topview x1
+  left join topview5 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview5.col3 = x1.col3;
+COL0    |COL3      |COL1       |COL0      |COL3      |COL1       
+-----------------------------------------------------------------
+other:  |1         |1          |morestuff:|1         |1          
+other:  |2         |2          |morestuff:|2         |2          
+t2stuff:|2         |2          |morestuff:|2         |2          
+t2stuff:|4         |4          |NULL      |NULL      |NULL       
+t2stuff:|8         |8          |NULL      |NULL      |NULL       
+t3stuff:|3         |3          |morestuff:|3         |3          
+t3stuff:|3         |3          |t3stuff:  |3         |3          
+t3stuff:|6         |6          |morestuff:|6         |6          
+t3stuff:|6         |6          |t3stuff:  |6         |6          
+t3stuff:|9         |9          |morestuff:|9         |9          
+t3stuff:|9         |9          |t3stuff:  |9         |9          
+ij> -- Clean-up from DERBY-1633.
+drop view topview;
+0 rows inserted/updated/deleted
+ij> drop view topview2;
+0 rows inserted/updated/deleted
+ij> drop view topview3;
+0 rows inserted/updated/deleted
+ij> drop view topview4;
+0 rows inserted/updated/deleted
+ij> drop view topview5;
+0 rows inserted/updated/deleted
+ij> drop view v_keycol_at_pos_3;
+0 rows inserted/updated/deleted
+ij> drop view v1_keycol_at_pos_2;
+0 rows inserted/updated/deleted
+ij> drop view v2_keycol_at_pos_2;
+0 rows inserted/updated/deleted
+ij> drop view v1_intersect;
+0 rows inserted/updated/deleted
+ij> drop view v2_intersect;
+0 rows inserted/updated/deleted
+ij> drop view v1_values;
+0 rows inserted/updated/deleted
+ij> drop view v_union;
+0 rows inserted/updated/deleted
+ij> drop table t1;
+0 rows inserted/updated/deleted
+ij> drop table t2;
+0 rows inserted/updated/deleted
+ij> drop table t3;
+0 rows inserted/updated/deleted
+ij> drop table t4;
+0 rows inserted/updated/deleted
+ij> drop table t5;
+0 rows inserted/updated/deleted
+ij> drop table t6;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
index 43a4217da..02365ab2e 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
@@ -102,6 +102,11 @@ create view vz2 (z1, z2, z3, z4) as
   select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
     (select c1, c, c2, c3 from tc) xx1;
 
+create view vz3 (z1, z2, z3, z4) as
+  select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
+    (select c1, c, c2, 28 from tc) xx1
+      union select 'i','j','j',i from t2;
+
 -- Both sides of predicate reference aggregates.
 select x1.c1 from
   (select count(*) from t1 union select count(*) from t2) x1 (c1),
@@ -242,6 +247,15 @@ select x1.z4 from
   (select distinct j from t2 union select j from t1) x2 (c2)
 where x1.z4 = x2.c2;
 
+-- Same as above but with an expression ("i+1") instead of
+-- a numeric literal.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3),
+  (select distinct j from t2 union select j from t1) x2 (c2)
+where x1.z4 = x2.c2;
+
 -- Same as previous query but with a different nested
 -- view (vz2) that is missing the nested union found
 -- in vz.
@@ -252,9 +266,119 @@ select x1.z4 from
   (select distinct j from t2 union select j from t1) x2 (c2)
 where x1.z4 = x2.c2;
 
+-- Queries with Select->Union->Select chains having differently-
+-- ordered result column lists with some non-column reference
+-- expressions.  In all of these queries we specify LEFT join
+-- and force NESTEDLOOP in order to coerce the optimizer to
+-- push predicates to a specific subquery.  We do this to
+-- ensure that we test predicate pushdown during compilation
+-- AND during execution.  It's the execution-time testing
+-- that is particular important for verifying DERBY-1633
+-- functionality.
+
+-- Push predicate to union whose left child has a Select
+-- within a Select, both of which have the same result column
+-- ordering.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3)
+  left join
+  (select distinct i,j from (select distinct i,j from t2) x3
+    union select i, j from t1
+  ) x2 (c1, c2) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP  
+on x1.z4 = x2.c2;
+
+-- Push predicate to union whose left child has a Select
+-- within a Select, where the result column lists for the
+-- two Selects are different ("i,j" vs "j,i").
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3)
+  left join
+  (select distinct i,j from (select distinct j,i from t2) x3
+   union select i, j from t1
+  ) x2 (c1, c2) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP  
+on x1.z4 = x2.c2;
+
+-- Push predicate to union whose left child is itself a
+-- nested subquery (through use of the view "vz") and
+-- whose right child has an expression in its result
+-- column list.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
+-- Same as previous but with a different expression.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', sin(i), '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
+-- Same as previous but expression replaced with a regular
+-- column reference.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', i, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
+-- Same as previous but with a different expression and
+-- a different subquery (this time using view "vz3").
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz3
+    union select '1', sin(i), '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
+-- Push predicate to chain of unions whose left-most child
+-- is itself a nested subquery (through use of the view "vz")
+-- and in which the other unions have expressions in their
+-- result column lists.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select z1, z4, z3 from vz
+    union select '1', sin(i), '3' from t1
+    union select '1', 14, '3' from t1
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
+-- Push predicate to chain of unions whose right-most child
+-- is itself a nested subquery (through use of the view "vz")
+-- and in which the other unions have expressions in their
+-- result column lists.
+select x1.z4, x2.c2 from
+  (select distinct i,j from (select distinct j,i from t2) x3
+    union select i, j from t1) x2 (c1, c2)
+  left join
+  (select '1', sin(i), '3' from t1
+    union select '1', 14, '3' from t1
+    union select z1, z4, z3 from vz
+  ) x1 (z1, z4, z3) --DERBY-PROPERTIES joinStrategy=NESTEDLOOP 
+on x1.z4 = x2.c2;
+
 -- Cleanup from this set of tests.
 drop view vz;
 drop view vz2;
+drop view vz3;
 drop table tc;
 
 -- Now bump up the size of tables T3 and T4 to the point where
@@ -744,3 +868,263 @@ drop view yyunion;
 drop table xx1;
 drop table yy1;
 
+
+-- DERBY-1633: Nested UNIONs of views with different column orderings
+-- leads to incorrectly scoped predicates.  We have a lot of different
+-- tables and views here to try to cover several different situations.
+-- Note that all of the views use DISTINCT because we don't want
+-- the views to be flattened and Derby doesn't flatten select
+-- queries with DISTINCT in them.
+
+CREATE TABLE "APP"."T1" ("I" INTEGER, "D" DOUBLE, "C" CHAR(10));
+CREATE TABLE "APP"."T2" ("I2" INTEGER, "D2" DOUBLE, "C2" CHAR(10));
+CREATE TABLE "APP"."T3" ("I3" INTEGER, "D3" DOUBLE, "C3" CHAR(10));
+
+insert into t1 values (1, -1, '1'), (2, -2, '2');
+insert into t2 values (2, -2, '2'), (4, -4, '4'), (8, -8, '8');
+insert into t3 values (3, -3, '3'), (6, -6, '6'), (9, -9, '9');
+
+CREATE TABLE "APP"."T4" ("C4" CHAR(10));
+insert into t4 values '1', '2', '3', '4', '5', '6', '7', '8', '9';
+insert into t4 select rtrim(c4) || rtrim(c4) from t4;
+
+CREATE TABLE "APP"."T5" ("I5" INTEGER, "D5" DOUBLE, "C5" CHAR(10));
+CREATE TABLE "APP"."T6" ("I6" INTEGER, "D6" DOUBLE, "C6" CHAR(10));
+
+insert into t5
+  values (100, 100.0, '100'), (200, 200.0, '200'), (300, 300.0, '300');
+
+insert into t6
+  values (400, 400.0, '400'), (200, 200.0, '200'), (300, 300.0, '300');
+
+create view v_keycol_at_pos_3 as
+  select distinct i col1, d col2, c col3 from t1;
+
+create view v1_keycol_at_pos_2 as
+  select distinct i2 col1, c2 col3, d2 col2 from t2;
+
+create view v2_keycol_at_pos_2 as
+  select distinct i3 col1, c3 col3, d3 col2 from t3;
+
+create view v1_intersect as
+  select distinct i5 col1, c5 col3, d5 col2 from t5;
+
+create view v2_intersect as
+  select distinct i6 col1, c6 col3, d6 col2 from t6;
+
+create view v1_values as
+  select distinct vals1 col1, vals2 col2, vals3 col3 from
+    (values (321, 321.0, '321'), (432, 432.0, '432'),
+      (654, 654.0, '654')
+    ) VT(vals1, vals2, vals3);
+
+create view v_union as
+  select distinct i col1, d col2, c col3 from t1
+    union select distinct i3 col1, d3 col2, c3 col3 from t3;
+
+-- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The right child of the top-level
+-- node is a view that is a simple select from a table.
+create view topview as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   union
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+  );
+
+-- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The right child of the top-level
+-- node is a view that is a select from yet another
+-- UNION node.
+create view topview2 as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   union
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+     from v_union vu
+  );
+
+-- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is an INTERSECT node to which
+-- predicates cannot (currently) be pushed.  In this
+-- case the intersect returns an empty result set.
+create view topview3 (col0, col3, col1) as
+  (select distinct 'other:' col0, vpos3.col3, vpos3.col1
+    from v_keycol_at_pos_3 vpos3
+   intersect
+    select distinct 't2stuff:' col0, vpos2_1.col3, vpos2_1.col1
+     from v1_keycol_at_pos_2 vpos2_1
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+     from v_union vu
+  );
+
+-- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is an INTERSECT node to which
+-- predicates cannot (currently) be pushed.  In this
+-- case the intersect returns a couple of rows.
+create view topview4 (col0, col3, col1) as
+  (select distinct 'intersect:' col0, vi1.col3, vi1.col1
+    from v1_intersect vi1
+   intersect
+    select distinct 'intersect:' col0, vi2.col3, vi2.col1
+     from v2_intersect vi2
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+   from v_union vu
+  );
+
+-- Chain of UNIONs with left-most child as a view with a
+-- an RCL that is ordered differently than that of the
+-- UNIONs above it.  The left-most child of the last
+-- UNION in the chain is a view that is a selet from
+-- a VALUES list (i.e. no base table).
+create view topview5 (col0, col3, col1) as
+  (select distinct 'values:' col0, vv1.col3, vv1.col1
+    from v1_values vv1
+   union
+    select distinct 'intersect:' col0, vi2.col3, vi2.col1
+     from v2_intersect vi2
+   union
+    select distinct 't3stuff:' col0, vpos2_2.col3, vpos2_2.col1
+     from v2_keycol_at_pos_2 vpos2_2
+   union
+    select distinct 'morestuff:' col0, vu.col3, vu.col1
+   from v_union vu
+  );
+
+-- All of the following queries failed at some point while finalizing
+-- the fix for DERBY-1633; some failed with error 42818, others
+-- failed with execution-time NPEs caused by incorrect (esp. double)
+-- remapping.  The point here is to see how the top-level
+-- predicates are pushed through the nested unions to the
+-- bottom-most children.  Use of LEFT JOINs with NESTEDLOOP
+-- effectively allows us to force the join order and thus to
+-- ensure the predicates are pushed to the desired top-level
+-- at execution time.  All such queries are run once with
+-- NESTEDLOOP and once without, to make sure things work
+-- in both cases.
+
+select * from t4, topview where t4.c4 = topview.col3;
+select * from t4, topview where topview.col3 = t4.c4;
+select * from topview x1, topview where topview.col3 = x1.col3;
+
+select * from t4, topview2 where t4.c4 = topview2.col3;
+select * from topview2 x1, topview where topview.col3 = x1.col3;
+
+select * from t4
+  left join topview
+  on t4.c4 = topview.col3;
+
+select * from t4
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on t4.c4 = topview.col3;
+
+select * from t4
+  left join topview
+  on topview.col3 = t4.c4;
+
+select * from t4
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = t4.c4;
+
+select * from topview x1
+  left join topview
+  on topview.col3 = x1.col3;
+
+select * from topview x1
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = x1.col3;
+
+select * from t4
+  left join topview2
+  on t4.c4 = topview2.col3;
+
+select * from t4
+  left join topview2 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on t4.c4 = topview2.col3;
+
+select * from topview2 x1
+  left join topview
+  on topview.col3 = x1.col3;
+
+select * from topview2 x1
+  left join topview --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview.col3 = x1.col3;
+
+select * from topview x1
+  left join topview2
+  on topview2.col3 = x1.col3;
+
+select * from topview x1
+  left join topview2 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview2.col3 = x1.col3;
+
+select * from topview x1
+  left join topview3
+  on topview3.col3 = x1.col3;
+
+select * from topview x1
+  left join topview3 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview3.col3 = x1.col3;
+
+select * from topview x1
+  left join topview4
+  on topview4.col3 = x1.col3;
+
+select * from topview x1
+  left join topview4 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview4.col3 = x1.col3;
+
+select * from topview x1
+  left join topview5
+  on topview5.col3 = x1.col3;
+
+select * from topview x1
+  left join topview5 --DERBY-PROPERTIES joinStrategy=NESTEDLOOP
+  on topview5.col3 = x1.col3;
+
+-- Clean-up from DERBY-1633.
+
+drop view topview;
+drop view topview2;
+drop view topview3;
+drop view topview4;
+drop view topview5;
+
+drop view v_keycol_at_pos_3;
+drop view v1_keycol_at_pos_2;
+drop view v2_keycol_at_pos_2;
+drop view v1_intersect;
+drop view v2_intersect;
+drop view v1_values;
+drop view v_union;
+
+drop table t1;
+drop table t2;
+drop table t3;
+drop table t4;
+drop table t5;
+drop table t6;
