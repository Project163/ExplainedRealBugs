diff --git a/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java b/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
index ea74ed93f..2593accd4 100644
--- a/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
+++ b/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
@@ -2790,13 +2790,98 @@ abstract class FileContainer
 		return p;
 	}
 
+    /**
+     * Get candidate page to move a row for compressing the table.
+     * <p>
+     * The caller is moving rows from the end of the table toward the beginning,
+     * with the goal of freeing up a block of empty pages at the end of the
+     * container which can be returned to the OS.
+     * <p>
+     * On entry pageno will be latched by the caller.  Only return pages with
+     * numbers below pageno.  Attempting to return pageno will result in a
+     * latch/latch deadlock on the same thread.
+     *
+	 * @exception  StandardException  Standard exception policy.
+     **/
 	protected BasePage getPageForCompress(
     BaseContainerHandle handle,
     int                 flag,
     long                pageno)
 		 throws StandardException
 	{
-        return(getPageForInsert(handle, flag));
+		BasePage p = null;
+		boolean getLastInserted = 
+            (flag & ContainerHandle.GET_PAGE_UNFILLED) == 0;
+
+		if (getLastInserted)
+		{
+			// There is nothing protecting lastInsertePage from being changed
+			// by another thread.  Make a local copy.
+			long localLastInsertedPage = getLastInsertedPage();
+
+            if ((localLastInsertedPage < pageno) &&
+                (localLastInsertedPage != ContainerHandle.INVALID_PAGE_NUMBER))
+            {
+                // First try getting last inserted page.
+
+                p = getInsertablePage(
+                        handle, 
+                        localLastInsertedPage,
+                        true, /* wait */
+                        false /* no overflow page */);
+
+                // if localLastInsertedPage is not an insertable page, 
+                // don't waste time getting it again.
+                if (p == null)
+                {
+                    // There is a slight possibility that lastUnfilledPage and
+                    // lastInsertedPage will change between the if and the
+                    // assignment.  The worse that will happen is we lose the
+                    // optimization.  Don't want to slow down allocation by 
+                    // adding more synchronization.
+
+                    if (localLastInsertedPage == getLastUnfilledPage())
+                        setLastUnfilledPage(
+                            ContainerHandle.INVALID_PAGE_NUMBER);
+
+                    if (localLastInsertedPage == getLastInsertedPage())
+                        setLastInsertedPage(
+                            ContainerHandle.INVALID_PAGE_NUMBER);
+                }
+            }
+		}
+		else					
+		{
+            // get a relatively unfilled page that is not the last Inserted page
+
+			long localLastUnfilledPage = getLastUnfilledPage();
+
+			if (localLastUnfilledPage == ContainerHandle.INVALID_PAGE_NUMBER ||
+                localLastUnfilledPage >= pageno ||
+				localLastUnfilledPage == getLastInsertedPage())
+            {
+                // get an unfilled page, searching from beginning of container.
+				localLastUnfilledPage = 
+                    getUnfilledPageNumber(handle, 0);
+            }
+
+			if ((localLastUnfilledPage != 
+                    ContainerHandle.INVALID_PAGE_NUMBER) &&
+                (localLastUnfilledPage < pageno))
+			{
+				p = getInsertablePage(
+                        handle, localLastUnfilledPage, true, false);
+			}
+
+			// return this page for insert
+			if (p != null)
+			{
+				setLastUnfilledPage(localLastUnfilledPage);
+				setLastInsertedPage(localLastUnfilledPage);
+			}
+		}
+
+		return p;
     }
 
 	/**
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/st_derby1189.out b/java/testing/org/apache/derbyTesting/functionTests/master/st_derby1189.out
new file mode 100644
index 000000000..2e4bf1507
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/st_derby1189.out
@@ -0,0 +1,44 @@
+ij> drop table t1;
+ERROR 42Y55: 'DROP TABLE' cannot be performed on 'T1' because it does not exist.
+ij> create table t1 (i integer primary key, j integer, c char(200));
+0 rows inserted/updated/deleted
+ij> insert into t1 values (1, 1, 'a');
+1 row inserted/updated/deleted
+ij> insert into t1 (select t1.i + 2,    t1.j + 2,    t1.c from t1);
+1 row inserted/updated/deleted
+ij> insert into t1 (select t1.i + 4,    t1.j + 4,    t1.c from t1);
+2 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 8,    t1.j + 8,    t1.c from t1);
+4 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 16,   t1.j + 16,   t1.c from t1);
+8 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 32,   t1.j + 32,   t1.c from t1);
+16 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 64,   t1.j + 64,   t1.c from t1);
+32 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 128,  t1.j + 128,  t1.c from t1);
+64 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 256,  t1.j + 256,  t1.c from t1);
+128 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 512,  t1.j + 512,  t1.c from t1);
+256 rows inserted/updated/deleted
+ij> insert into t1 (select t1.i + 1024, t1.j + 1024, t1.c from t1);
+512 rows inserted/updated/deleted
+ij> delete from t1 where j=1;
+1 row inserted/updated/deleted
+ij> CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+0 rows inserted/updated/deleted
+ij> delete from t1 where j=2;
+0 rows inserted/updated/deleted
+ij> CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+0 rows inserted/updated/deleted
+ij> delete from t1 where i > 1024;
+512 rows inserted/updated/deleted
+ij> CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+0 rows inserted/updated/deleted
+ij> delete from t1 where i < 512;
+255 rows inserted/updated/deleted
+ij> -- prior to the fix the following compress would result in a deadlock
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+0 rows inserted/updated/deleted
+ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/suites/storetests.runall b/java/testing/org/apache/derbyTesting/functionTests/suites/storetests.runall
index ac40585a4..024cf70f5 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/suites/storetests.runall
+++ b/java/testing/org/apache/derbyTesting/functionTests/suites/storetests.runall
@@ -1,4 +1,5 @@
 storetests/st_schema.sql
+storetests/st_derby1189.sql
 storetests/st_reclaim_longcol.java
 storetests/st_derby715.java
 storetests/st_1.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/copyfiles.ant b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/copyfiles.ant
index 0e985d820..6ac801ce0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/copyfiles.ant
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/copyfiles.ant
@@ -11,3 +11,4 @@ derby94_app.properties
 derby94_derby.properties
 onlineCompressTable.sql
 derby94_derby.properties
+st_derby1189.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql
new file mode 100644
index 000000000..28e047237
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189.sql
@@ -0,0 +1,30 @@
+drop table t1;
+create table t1 (i integer primary key, j integer, c char(200));
+insert into t1 values (1, 1, 'a');
+insert into t1 (select t1.i + 2,    t1.j + 2,    t1.c from t1);
+insert into t1 (select t1.i + 4,    t1.j + 4,    t1.c from t1);
+insert into t1 (select t1.i + 8,    t1.j + 8,    t1.c from t1);
+insert into t1 (select t1.i + 16,   t1.j + 16,   t1.c from t1);
+insert into t1 (select t1.i + 32,   t1.j + 32,   t1.c from t1);
+insert into t1 (select t1.i + 64,   t1.j + 64,   t1.c from t1);
+insert into t1 (select t1.i + 128,  t1.j + 128,  t1.c from t1);
+insert into t1 (select t1.i + 256,  t1.j + 256,  t1.c from t1);
+insert into t1 (select t1.i + 512,  t1.j + 512,  t1.c from t1);
+insert into t1 (select t1.i + 1024, t1.j + 1024, t1.c from t1);
+
+delete from t1 where j=1;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where j=2;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where i > 1024;
+
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
+
+delete from t1 where i < 512;
+
+-- prior to the fix the following compress would result in a deadlock
+CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('APP', 'T1', 1, 1, 1);
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189_app.properties b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189_app.properties
new file mode 100644
index 000000000..34cdc9157
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/storetests/st_derby1189_app.properties
@@ -0,0 +1,2 @@
+usedefaults=true
+
