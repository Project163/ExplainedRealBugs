diff --git a/java/engine/org/apache/derby/iapi/error/StandardException.java b/java/engine/org/apache/derby/iapi/error/StandardException.java
index a7587501f..42e64306f 100644
--- a/java/engine/org/apache/derby/iapi/error/StandardException.java
+++ b/java/engine/org/apache/derby/iapi/error/StandardException.java
@@ -723,4 +723,29 @@ public class StandardException extends Exception
 
 		return sqlw;
 	}
+
+    /**
+     * Is this a lock timeout exception.
+     * <p>
+     *
+     * @return true if this exception is a lock timeout.
+     *
+     **/
+    public final boolean isLockTimeout() {
+
+        return(SQLState.LOCK_TIMEOUT.equals(getSQLState()));
+    }
+
+    /**
+     * Is this a lock timeout or lock deadlock exception.
+     * <p>
+     *
+     * @return true if this exception is a lock timeout or lock deadlock.
+     *
+     **/
+    public final boolean isLockTimeoutOrDeadlock() {
+
+        return(SQLState.LOCK_TIMEOUT.equals(getSQLState()) ||
+               SQLState.DEADLOCK.equals(getSQLState()));
+    }
 }
diff --git a/java/engine/org/apache/derby/iapi/sql/dictionary/SPSDescriptor.java b/java/engine/org/apache/derby/iapi/sql/dictionary/SPSDescriptor.java
index 72eb18fe9..e80b2d0de 100644
--- a/java/engine/org/apache/derby/iapi/sql/dictionary/SPSDescriptor.java
+++ b/java/engine/org/apache/derby/iapi/sql/dictionary/SPSDescriptor.java
@@ -691,11 +691,14 @@ public class SPSDescriptor extends TupleDescriptor
 
 			if (!lcc.getDataDictionary().isReadOnlyUpgrade()) {
 
-				//bug 4821 - First try compiling on a nested transaction so we can release
-				//the locks after the compilation. But if we get lock time out on the
-				//nested transaction, then go ahead and do the compilation on the user
-				//transaction. When doing the compilation on user transaction, the locks
-				//acquired for recompilation will be released at the end of the user transaction.
+				// First try compiling in a nested transaction so we can 
+                // release the locks after the compilation, and not have them
+                // sit around in the parent transaction. But if we get lock 
+                // time out in the nested transaction, then go ahead and do 
+                // the compilation in the user transaction. When doing the 
+                // compilation in the user transaction, the locks acquired for 
+                // recompilation will be released at the end of the user 
+                // transaction (commit or abort).
 				TransactionController nestedTC;
 				try
 				{
@@ -711,8 +714,8 @@ public class SPSDescriptor extends TupleDescriptor
 				}
 				catch (StandardException se)
 				{
-					// If I cannot start a Nested User Transaction use the parent
-					// transaction to do all the work.
+					// If I cannot start a Nested User Transaction use the 
+                    // parent transaction to do all the work.
 					nestedTC = null;
 				}
 
@@ -729,27 +732,39 @@ public class SPSDescriptor extends TupleDescriptor
 				}
 				catch (StandardException se)
 				{
-					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
+					if (se.isLockTimeout())
 					{
+                        // Locks were set nowait, so a lock timeout here
+                        // means that some lock request in the nested 
+                        // transaction immediately conflicted.  A conflict
+                        // with a parent lock would lead to a undetected 
+                        // deadlock so must give up trying in the nested
+                        // transaction and retry with parent transaction.
 						if (nestedTC != null)
 						{
-						nestedTC.commit();
-						nestedTC.destroy();
-						nestedTC = null;
+                            nestedTC.commit();
+                            nestedTC.destroy();
+                            nestedTC = null;
 						}
-						// if we couldn't do this with a nested xaction, retry with
-						// parent-- we need to wait this time!
+
+						// if we couldn't do this with a nested transaction, 
+                        // retry with parent-- we need to wait this time!
+                        // Lock conflicts at this point are with other 
+                        // transactions, so must wait.
 						initiallyCompilable = compilable;
 						prepareAndRelease(lcc, null, null);
 						updateSYSSTATEMENTS(lcc, RECOMPILE, null);
 					}
-					else throw se;
+					else 
+                    {
+                        throw se;
+                    }
 				}
 				finally
 				{
-					// no matter what, commit the nested transaction; if something
-					// bad happened in the child xaction lets not abort the parent
-					// here.
+					// no matter what, commit the nested transaction; 
+                    // if something bad happened in the child transaction lets
+                    // not abort the parent here.
 					if (nestedTC != null)
 					{
 						nestedTC.commit();
diff --git a/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java b/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
index d8ef11067..51967d3d1 100644
--- a/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
+++ b/java/engine/org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java
@@ -323,6 +323,7 @@ public class IndexStatisticsDaemonImpl
                 updateIndexStatsMinion(lcc, td, cds, AS_BACKGROUND_TASK);
                 break;
             } catch (StandardException se) {
+
                 // At this level, we retry the whole operation. If this happens,
                 // it normally means that a lengthy operation, or possibly DDL,
                 // is taking place (for instance compress table). We retry only
@@ -330,12 +331,14 @@ public class IndexStatisticsDaemonImpl
                 // Note that some lower level operations may have tried to
                 // aquire the locks several times already, and we may not be
                 // able to complete the work if we get here.
-                if (SQLState.LOCK_TIMEOUT.equals(se.getMessageId()) &&
-                        !lockConflictSeen) {
+
+                if (se.isLockTimeout() && !lockConflictSeen) {
+
                     trace(1, "locks unavailable, retrying");
                     lockConflictSeen = true;
                     lcc.internalRollback(); // Get rid of any locks
                     sleep(1000);
+
                 } else {
                     // Rethrow exception, because:
                     //   o error is not a lock timeout
@@ -508,9 +511,10 @@ public class IndexStatisticsDaemonImpl
                             cmp.getRowCount(), cardinality, asBackgroundTask);
                     break;
                 } catch (StandardException se) {
+
                     retries++;
-                    if (SQLState.LOCK_TIMEOUT.equals(se.getMessageId()) &&
-                            retries < 3) {
+
+                    if (se.isLockTimeout() && retries < 3) {
                         trace(2, "lock timeout when writing stats, retrying");
                         sleep(100*retries);
                     } else {
@@ -632,8 +636,8 @@ public class IndexStatisticsDaemonImpl
                 break;
             } catch (StandardException se) {
                 // Special handling when running as background task.
-                if (SQLState.LOCK_TIMEOUT.equals(se.getMessageId()) &&
-                        asBackgroundTask && retries < 3) {
+
+                if (se.isLockTimeout() && asBackgroundTask && retries < 3) {
                     retries++;
                     // If this is the first time we retry, don't roll back.
                     // If we already waited once, but still didn't get the
@@ -995,9 +999,10 @@ public class IndexStatisticsDaemonImpl
         // Accept that the heap/index/conglomerate has been deleted since the
         // work for it was scheduled. Just ignore the unit of work and continue.
         if (SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST.equals(state) ||
-                SQLState.HEAP_CONTAINER_NOT_FOUND.equals(state) ||
-                SQLState.FILE_IO_INTERRUPTED.equals(state) ||
-                SQLState.LOCK_TIMEOUT.equals(state)) {
+            SQLState.HEAP_CONTAINER_NOT_FOUND.equals(state) ||
+            SQLState.FILE_IO_INTERRUPTED.equals(state) ||
+            se.isLockTimeout()) {
+
             errorsKnown++;
             log(AS_BACKGROUND_TASK, td, "generation aborted (reason: " +
                     state + ") {" + extractIstatInfo(se) + "}");
diff --git a/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java b/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
index d08b68659..38dbabe01 100644
--- a/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
+++ b/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
@@ -473,7 +473,7 @@ public abstract class SequenceUpdater implements Cacheable
             }
             catch (StandardException se)
             {
-                if ( !se.getMessageId().equals( SQLState.LOCK_TIMEOUT ) ) { throw se; }
+                if ( !se.isLockTimeout() ) { throw se; }
             }
             finally
             {
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
index 84f87c705..317e5c362 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
@@ -190,22 +190,28 @@ abstract class DDLConstantAction implements ConstantAction
 			try {
 				csca.executeConstantAction(activation, useTc);
 			} catch (StandardException se) {
-				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
-					// We don't test for SQLState.DEADLOCK or
-					// .LOCK_TIMEOUT_LOG here because a) if it is a
-					// deadlock, it may be better to expose it, and b)
-					// LOCK_TIMEOUT_LOG happens when the app has set
-					// derby.locks.deadlockTrace=true, in which case we
-					// don't want to mask the timeout.  So in both the
-					// latter cases we just throw.
-					if (useTc == nestedTc) {
-
-						// clean up after use of nested transaction,
-						// then try again in outer transaction
-						useTc = tc;
-						nestedTc.destroy();
-						continue;
-					}
+
+				if (se.isLockTimeout()) {
+                    // We don't test for SQLState.DEADLOCK because if it is a
+                    // deadlock, it may be better to expose it.  Just go ahead
+                    // and throw it.
+
+                    if (!se.getMessageId().equals(SQLState.LOCK_TIMEOUT_LOG)) {
+                        // In case of a LOCK_TIMEOUT_LOG also just throw it.
+                        // LOCK_TIMEOUT_LOG happens when the app has set
+                        // derby.locks.deadlockTrace=true, in which case we
+                        // don't want to mask the timeout. 
+
+                        if (useTc == nestedTc) {
+
+                            // clean up after use of nested transaction,
+                            // then try again in outer transaction
+                            useTc = tc;
+                            nestedTc.destroy();
+                            continue;
+                        }
+                    }
+
 				} else if (se.getMessageId()
 							   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
 					// Ignore "Schema already exists". Another thread has
diff --git a/java/engine/org/apache/derby/impl/sql/execute/LockTableConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/LockTableConstantAction.java
index cb37104a8..8072ad9d3 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/LockTableConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/LockTableConstantAction.java
@@ -111,9 +111,11 @@ class LockTableConstantAction implements ConstantAction
 		catch (StandardException se)
 		{
 			String msgId = se.getMessageId();
-			if (msgId.equals(SQLState.DEADLOCK) || msgId.equals(SQLState.LOCK_TIMEOUT) || msgId.equals(SQLState.LOCK_TIMEOUT_LOG)) {
+            if (se.isLockTimeoutOrDeadlock())
+            {
 				String mode = (exclusiveMode) ? "EXCLUSIVE" : "SHARE";
-				se = StandardException.newException(SQLState.LANG_CANT_LOCK_TABLE, se, fullTableName, mode);
+				se = StandardException.newException(
+                        SQLState.LANG_CANT_LOCK_TABLE, se, fullTableName, mode);
 			}
 
 			throw se;
diff --git a/java/engine/org/apache/derby/impl/store/access/btree/BTreePostCommit.java b/java/engine/org/apache/derby/impl/store/access/btree/BTreePostCommit.java
index 9507692ea..12da8e065 100644
--- a/java/engine/org/apache/derby/impl/store/access/btree/BTreePostCommit.java
+++ b/java/engine/org/apache/derby/impl/store/access/btree/BTreePostCommit.java
@@ -257,8 +257,7 @@ class BTreePostCommit implements Serviceable
             // call will return null - in this case just return assuming no 
             // work to be done.
 
-			if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) ||
-				se.getMessageId().equals(SQLState.DEADLOCK))
+            if (se.isLockTimeoutOrDeadlock())
 			{
                 // Could not get exclusive table lock, so try row level
                 // reclaim of just the rows on this page.  No merge is 
@@ -277,8 +276,7 @@ class BTreePostCommit implements Serviceable
                 }
                 catch (StandardException se2)
                 {
-                    if (se2.getMessageId().equals(SQLState.LOCK_TIMEOUT) ||
-                        se2.getMessageId().equals(SQLState.DEADLOCK))
+                    if (se2.isLockTimeoutOrDeadlock())
                     {
                         // Could not get intended exclusive table lock, so 
                         // requeue and hope other user gives up table level
diff --git a/java/engine/org/apache/derby/impl/store/access/heap/HeapPostCommit.java b/java/engine/org/apache/derby/impl/store/access/heap/HeapPostCommit.java
index 3c34d4ba4..12cd08cb8 100644
--- a/java/engine/org/apache/derby/impl/store/access/heap/HeapPostCommit.java
+++ b/java/engine/org/apache/derby/impl/store/access/heap/HeapPostCommit.java
@@ -351,15 +351,16 @@ class HeapPostCommit implements Serviceable
         }
         catch (StandardException se)
         {
-            // exception might have occured either container got dropper or lock not granted.
+            // exception might have occured either because the container got 
+            // dropper or the lock was not granted.
             // It is possible by the time this post commit work gets scheduled 
             // that the container has been dropped and that the open container 
             // call will return null - in this case just return assuming no 
             // work to be done.
 
-			//If this expcetion is because lock could not be obtained , work is requeued.
-			if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) || 
-				se.getMessageId().equals(SQLState.DEADLOCK))
+			// If this expcetion is because lock could not be obtained, 
+            // work is requeued.
+			if (se.isLockTimeoutOrDeadlock())
 			{
 				requeue_work = true;
 			}
diff --git a/java/engine/org/apache/derby/impl/store/raw/data/ReclaimSpaceHelper.java b/java/engine/org/apache/derby/impl/store/raw/data/ReclaimSpaceHelper.java
index cb673aa2e..a3dae95b7 100644
--- a/java/engine/org/apache/derby/impl/store/raw/data/ReclaimSpaceHelper.java
+++ b/java/engine/org/apache/derby/impl/store/raw/data/ReclaimSpaceHelper.java
@@ -537,7 +537,7 @@ public class ReclaimSpaceHelper
 			// DERBY-4059
 			// if this is a lock timeout just return null.
 			// otherwise throw the exception
-			if (!se.getSQLState().equals(SQLState.LOCK_TIMEOUT)) {
+			if (!se.isLockTimeout()) {
 				throw se;
 			}
 		}
diff --git a/java/engine/org/apache/derby/impl/store/raw/xact/Xact.java b/java/engine/org/apache/derby/impl/store/raw/xact/Xact.java
index a2387272e..e70614582 100644
--- a/java/engine/org/apache/derby/impl/store/raw/xact/Xact.java
+++ b/java/engine/org/apache/derby/impl/store/raw/xact/Xact.java
@@ -2468,7 +2468,7 @@ public class Xact extends RawTransaction implements Limit, LockOwner {
             }
             catch (StandardException se)
             {
-                if (!se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
+                if (!se.isLockTimeout())
                 {
                     // if it is a timeout then escalate did not happen and
                     // just fall through.
diff --git a/java/engine/org/apache/derby/jdbc/XATransactionState.java b/java/engine/org/apache/derby/jdbc/XATransactionState.java
index f765e1c96..dd1d40b36 100644
--- a/java/engine/org/apache/derby/jdbc/XATransactionState.java
+++ b/java/engine/org/apache/derby/jdbc/XATransactionState.java
@@ -153,8 +153,8 @@ final class XATransactionState extends ContextImpl {
 					associationState = TRO_FAIL;
 					if (SQLState.DEADLOCK.equals(se.getMessageId()))
 						rollbackOnlyCode = XAException.XA_RBDEADLOCK;
-					else if (SQLState.LOCK_TIMEOUT.equals(se.getMessageId()))
-						rollbackOnlyCode = XAException.XA_RBTIMEOUT;					
+					else if (se.isLockTimeout())
+						rollbackOnlyCode = XAException.XA_RBTIMEOUT;
 					else
 						rollbackOnlyCode = XAException.XA_RBOTHER;
 				}
diff --git a/java/engine/org/apache/derby/loc/messages.xml b/java/engine/org/apache/derby/loc/messages.xml
index ae113d6aa..ba036e4f6 100644
--- a/java/engine/org/apache/derby/loc/messages.xml
+++ b/java/engine/org/apache/derby/loc/messages.xml
@@ -1025,7 +1025,7 @@ Guide.
             </msg>
 
             <msg>
-                <name>40XL2</name>
+                <name>40XL1.T.1</name>
                 <text>A lock could not be obtained within the time requested.  The lockTable dump is: {0}</text>
                 <arg>tableDump</arg>
             </msg>
diff --git a/java/engine/org/apache/derby/loc/messages_cs.properties b/java/engine/org/apache/derby/loc/messages_cs.properties
index 945d355d4..2dd2bff56 100644
--- a/java/engine/org/apache/derby/loc/messages_cs.properties
+++ b/java/engine/org/apache/derby/loc/messages_cs.properties
@@ -61,7 +61,7 @@ XCW00.D=Nepodporovan\u00fd p\u0159echod z ''{0}'' na ''{1}''.
 40001=Uzam\u010den\u00ed nebylo z\u00edsk\u00e1no kv\u016fli uv\u00e1znut\u00ed; cyklus uzam\u010den\u00ed a \u010dekaj\u00edc\u00edch je:\n{0}. Vybran\u00e1 ob\u011b\u0165 je XID: {1}.
 
 40XL1=Uzam\u010den\u00ed nebylo z\u00edsk\u00e1no v po\u017eadovan\u00e9m \u010dase
-40XL2=Uzam\u010den\u00ed nebylo z\u00edsk\u00e1no v po\u017eadovan\u00e9m \u010dase. V\u00fdpis lockTable je: {0}
+40XL1.T.1=Uzam\u010den\u00ed nebylo z\u00edsk\u00e1no v po\u017eadovan\u00e9m \u010dase. V\u00fdpis lockTable je: {0}
 
 # ClassManager
 XBCM1.S=Do\u0161lo k chyb\u011b propojov\u00e1n\u00ed Javy b\u011bhem zav\u00e1d\u011bn\u00ed generovan\u00e9 t\u0159\u00eddy {0}.
diff --git a/java/engine/org/apache/derby/loc/messages_de_DE.properties b/java/engine/org/apache/derby/loc/messages_de_DE.properties
index c2f339e6e..c4dfd37c3 100644
--- a/java/engine/org/apache/derby/loc/messages_de_DE.properties
+++ b/java/engine/org/apache/derby/loc/messages_de_DE.properties
@@ -163,7 +163,7 @@
 40XD1=Der Container wurde im Schreibschutzmodus ge\u00F6ffnet.
 40XD2=Der Container {0} kann nicht ge\u00F6ffnet werden. Er wurde gel\u00F6scht oder ist nicht vorhanden.
 40XL1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden.
-40XL2=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden. Speicherauszug der Sperrentabelle\: {0}
+40XL1.T.1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden. Speicherauszug der Sperrentabelle\: {0}
 40XT0=Das Modul RawStore hat einen internen Fehler festgestellt.
 40XT1=Beim Festschreiben der Transaktion wurde eine Ausnahme ausgel\u00F6st.
 40XT2=Beim Zur\u00FCcksetzen eines Sicherungspunktes wurde eine Ausnahme ausgel\u00F6st.
diff --git a/java/engine/org/apache/derby/loc/messages_es.properties b/java/engine/org/apache/derby/loc/messages_es.properties
index 93f31783f..08b214c79 100644
--- a/java/engine/org/apache/derby/loc/messages_es.properties
+++ b/java/engine/org/apache/derby/loc/messages_es.properties
@@ -163,7 +163,7 @@
 40XD1=El contenedor se ha abierto en modalidad de s\u00F3lo lectura.
 40XD2=El contenedor {0} no se puede abrir; o bien se ha eliminado o bien no existe.
 40XL1=No se ha podido obtener un bloqueo dentro del tiempo solicitado
-40XL2=No se ha podido obtener un bloqueo dentro del tiempo solicitado.  El vuelco de lockTable es\: {0}
+40XL1.T.1=No se ha podido obtener un bloqueo dentro del tiempo solicitado.  El vuelco de lockTable es\: {0}
 40XT0=El m\u00F3dulo RawSotre ha identificado un error interno.
 40XT1=Se ha generado una excepci\u00F3n al comprometer la transacci\u00F3n.
 40XT2=Se ha generado una excepci\u00F3n al retrotraer un SAVEPOINT.
diff --git a/java/engine/org/apache/derby/loc/messages_fr.properties b/java/engine/org/apache/derby/loc/messages_fr.properties
index 235264206..5b80a57bd 100644
--- a/java/engine/org/apache/derby/loc/messages_fr.properties
+++ b/java/engine/org/apache/derby/loc/messages_fr.properties
@@ -163,7 +163,7 @@
 40XD1=Le conteneur a \u00E9t\u00E9 ouvert en mode lecture seule.
 40XD2=Impossible d''ouvrir le conteneur {0} ; soit il a \u00E9t\u00E9 supprim\u00E9, soit il n''existe pas.
 40XL1=Aucun verrou n''a pu \u00EAtre obtenu dans le d\u00E9lai demand\u00E9
-40XL2=Aucun verrou n''a pu \u00EAtre obtenu dans le d\u00E9lai demand\u00E9.  La liste lockTable est \: {0}
+40XL1.T.1=Aucun verrou n''a pu \u00EAtre obtenu dans le d\u00E9lai demand\u00E9.  La liste lockTable est \: {0}
 40XT0=Une erreur interne a \u00E9t\u00E9 identifi\u00E9e par le module RawStore.
 40XT1=Une exception a \u00E9t\u00E9 \u00E9mise au cours de la validation de la transaction.
 40XT2=Une exception a \u00E9t\u00E9 \u00E9mise au cours de l''annulation d''un POINT DE SAUVEGARDE.
diff --git a/java/engine/org/apache/derby/loc/messages_hu.properties b/java/engine/org/apache/derby/loc/messages_hu.properties
index 66d37c706..5f8d571e6 100644
--- a/java/engine/org/apache/derby/loc/messages_hu.properties
+++ b/java/engine/org/apache/derby/loc/messages_hu.properties
@@ -61,7 +61,7 @@ XCW00.D=A(z) ''{0}'' ''{1}'' v\u00e1ltozatra friss\u00edt\u00e9se nem t\u00e1mog
 40001=Holtpont miatt nem foganatos\u00edthat\u00f3 z\u00e1rol\u00e1s, a z\u00e1rak \u00e9s v\u00e1rakoz\u00f3k ciklusa: \n {0}. A kijel\u00f6lt \u00e1ldozat XID azonos\u00edt\u00f3ja: {1}.
 
 40XL1=A k\u00e9rt id\u0151n bel\u00fcl nem foganatos\u00edthat\u00f3 z\u00e1rol\u00e1s
-40XL2=A k\u00e9rt id\u0151n bel\u00fcl nem foganatos\u00edthat\u00f3 z\u00e1rol\u00e1s.  A lockTable ki\u00edrat\u00e1sa: {0}
+40XL1.T.1=A k\u00e9rt id\u0151n bel\u00fcl nem foganatos\u00edthat\u00f3 z\u00e1rol\u00e1s.  A lockTable ki\u00edrat\u00e1sa: {0}
 
 # ClassManager
 XBCM1.S=Java l\u00e1ncol\u00e1si hiba a(z) {0} el\u0151\u00e1ll\u00edtott oszt\u00e1ly bet\u00f6lt\u00e9se sor\u00e1n.
diff --git a/java/engine/org/apache/derby/loc/messages_it.properties b/java/engine/org/apache/derby/loc/messages_it.properties
index 94d3664c0..965b35115 100644
--- a/java/engine/org/apache/derby/loc/messages_it.properties
+++ b/java/engine/org/apache/derby/loc/messages_it.properties
@@ -163,7 +163,7 @@
 40XD1=Il contenitore \u00E8 stato aperto in modalit\u00E0 sola lettura.
 40XD2=Impossibile aprire il contenitore {0}; il contenitore \u00E8 stato eliminato o non esiste.
 40XL1=Impossibile ottenere un blocco nel tempo richiesto
-40XL2=Impossibile ottenere un blocco nel tempo richiesto.  Il dump lockTable \u00E8\: {0}
+40XL1.T.1=Impossibile ottenere un blocco nel tempo richiesto.  Il dump lockTable \u00E8\: {0}
 40XT0=\u00C8 stato identificato un errore interno dal modulo RawStore.
 40XT1=Si \u00E8 verificata un''eccezione durante l''operazione di commit della transazione.
 40XT2=Si \u00E8 verificata un''eccezione durante l''operazione di rollback di SAVEPOINT.
diff --git a/java/engine/org/apache/derby/loc/messages_ja_JP.properties b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
index 8e42dd3ed..aa08e6110 100644
--- a/java/engine/org/apache/derby/loc/messages_ja_JP.properties
+++ b/java/engine/org/apache/derby/loc/messages_ja_JP.properties
@@ -163,7 +163,7 @@
 40XD1=\u30B3\u30F3\u30C6\u30CA\u30FC\u304C\u8AAD\u307F\u53D6\u308A\u5C02\u7528\u30E2\u30FC\u30C9\u3067\u30AA\u30FC\u30D7\u30F3\u3055\u308C\u307E\u3057\u305F\u3002
 40XD2=\u30B3\u30F3\u30C6\u30CA\u30FC {0} \u3092\u30AA\u30FC\u30D7\u30F3\u3067\u304D\u307E\u305B\u3093\u3002\u30C9\u30ED\u30C3\u30D7\u3055\u308C\u305F\u304B\u3001\u5B58\u5728\u3057\u307E\u305B\u3093\u3002
 40XL1=\u8981\u6C42\u6642\u9593\u5185\u306B\u30ED\u30C3\u30AF\u3092\u7372\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F
-40XL2=\u8981\u6C42\u6642\u9593\u5185\u306B\u30ED\u30C3\u30AF\u3092\u7372\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002  lockTable \u30C0\u30F3\u30D7\: {0}
+40XL1.T.1=\u8981\u6C42\u6642\u9593\u5185\u306B\u30ED\u30C3\u30AF\u3092\u7372\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002  lockTable \u30C0\u30F3\u30D7\: {0}
 40XT0=RawStore \u30E2\u30B8\u30E5\u30FC\u30EB\u3067\u5185\u90E8\u30A8\u30E9\u30FC\u304C\u78BA\u8A8D\u3055\u308C\u307E\u3057\u305F\u3002
 40XT1=\u30C8\u30E9\u30F3\u30B6\u30AF\u30B7\u30E7\u30F3\u306E\u30B3\u30DF\u30C3\u30C8\u4E2D\u306B\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F\u3002
 40XT2=SAVEPOINT \u306E\u30ED\u30FC\u30EB\u30D0\u30C3\u30AF\u4E2D\u306B\u4F8B\u5916\u304C\u30B9\u30ED\u30FC\u3055\u308C\u307E\u3057\u305F\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_ko_KR.properties b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
index 5eea856d0..ef5968b21 100644
--- a/java/engine/org/apache/derby/loc/messages_ko_KR.properties
+++ b/java/engine/org/apache/derby/loc/messages_ko_KR.properties
@@ -163,7 +163,7 @@
 40XD1=\uCEE8\uD14C\uC774\uB108\uAC00 \uC77D\uAE30 \uC804\uC6A9 \uBAA8\uB4DC\uB85C \uC5F4\uB838\uC2B5\uB2C8\uB2E4. 
 40XD2={0} \uCEE8\uD14C\uC774\uB108\uB97C \uC5F4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC0AD\uC81C\uB418\uC5C8\uAC70\uB098 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.
 40XL1=\uC694\uCCAD\uB41C \uC2DC\uAC04 \uB0B4\uC5D0 \uC7A0\uAE08\uC744 \uD655\uBCF4\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.
-40XL2=\uC694\uCCAD\uB41C \uC2DC\uAC04 \uB0B4\uC5D0 \uC7A0\uAE08\uC744 \uD655\uBCF4\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. lockTable \uB364\uD504\uB294 {0}\uC785\uB2C8\uB2E4.
+40XL1.T.1=\uC694\uCCAD\uB41C \uC2DC\uAC04 \uB0B4\uC5D0 \uC7A0\uAE08\uC744 \uD655\uBCF4\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. lockTable \uB364\uD504\uB294 {0}\uC785\uB2C8\uB2E4.
 40XT0=RawStore \uBAA8\uB4C8\uC5D0 \uC758\uD574 \uB0B4\uBD80 \uC624\uB958\uAC00 \uC2DD\uBCC4\uB418\uC5C8\uC2B5\uB2C8\uB2E4.
 40XT1=\uD2B8\uB79C\uC7AD\uC158 \uD655\uC57D \uC911\uC5D0 \uC608\uC678\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.
 40XT2=SAVEPOINT\uC758 \uB864\uBC31 \uC911\uC5D0 \uC608\uC678\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.
diff --git a/java/engine/org/apache/derby/loc/messages_pl.properties b/java/engine/org/apache/derby/loc/messages_pl.properties
index 1f9dffa1c..4c19943df 100644
--- a/java/engine/org/apache/derby/loc/messages_pl.properties
+++ b/java/engine/org/apache/derby/loc/messages_pl.properties
@@ -61,7 +61,7 @@ XCW00.D=Nieobs\u0142ugiwana aktualizacja z ''{0}'' na ''{1}''.
 40001=Nie mo\u017cna uzyska\u0107 blokady z powodu zakleszczenia, cykl blokad i oczekiwa\u0144:\n{0}. Wybrana ofiara to XID: {1}.
 
 40XL1=Nie mo\u017cna uzyska\u0107 blokady w czasie jej \u017c\u0105dania
-40XL2=Nie mo\u017cna uzyska\u0107 blokady w czasie jej \u017c\u0105dania  Zrzut tabeli blokad: {0}
+40XL1.T.1=Nie mo\u017cna uzyska\u0107 blokady w czasie jej \u017c\u0105dania  Zrzut tabeli blokad: {0}
 
 # ClassManager
 XBCM1.S=Podczas \u0142adowania wygenerowanej klasy {0} zosta\u0142 zg\u0142oszony b\u0142\u0105d \u0142\u0105czenia Java.
diff --git a/java/engine/org/apache/derby/loc/messages_pt_BR.properties b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
index 2438ce5cc..f6d0d1ee9 100644
--- a/java/engine/org/apache/derby/loc/messages_pt_BR.properties
+++ b/java/engine/org/apache/derby/loc/messages_pt_BR.properties
@@ -62,7 +62,7 @@ XCW00.D=Atualiza\u00e7\u00e3o de ''{0}'' para ''{1}'' n\u00e3o suportada.
 40001=N\u00e3o foi poss\u00edvel obter o bloqueio devido a um impasse, o ciclo de bloqueios e aguardos \u00e9:\n{0}. A v\u00edtima selecionada foi XID: {1}.
 
 40XL1=N\u00e3o foi poss\u00edvel obter o bloqueio dentro do tempo requerido.
-40XL2=N\u00e3o foi poss\u00edvel obter o bloqueio dentro do tempo requerido. O dump de lockTable \u00e9: {0}
+40XL1.T.1=N\u00e3o foi poss\u00edvel obter o bloqueio dentro do tempo requerido. O dump de lockTable \u00e9: {0}
 
 # ClassManager
 XBCM1.S=Erro de liga\u00e7\u00e3o Java lan\u00e7ado durante o carregamento da classe {0} gerada.
diff --git a/java/engine/org/apache/derby/loc/messages_ru.properties b/java/engine/org/apache/derby/loc/messages_ru.properties
index a2581bb6a..d26b295dc 100644
--- a/java/engine/org/apache/derby/loc/messages_ru.properties
+++ b/java/engine/org/apache/derby/loc/messages_ru.properties
@@ -61,7 +61,7 @@ XCW00.D=\u041d\u0435\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430
 40001=\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0443 \u0438\u0437-\u0437\u0430 \u0442\u0443\u043f\u0438\u043a\u043e\u0432\u043e\u0439 \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u0438; \u0446\u0438\u043a\u043b \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043e\u043a \u0438 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0439:\n{0}. XID \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430, \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0433\u043e \u043c\u0435\u0445\u0430\u043d\u0438\u0437\u043c\u043e\u043c \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u0430\u043d\u043d\u0443\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: {1}.
 
 40XL1=\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0443 \u0432 \u0442\u0435\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438
-40XL2=\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0443 \u0432 \u0442\u0435\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438.  \u0414\u0430\u043c\u043f lockTable: {0}
+40XL1.T.1=\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0443 \u0432 \u0442\u0435\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0442\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438.  \u0414\u0430\u043c\u043f lockTable: {0}
 
 # ClassManager
 XBCM1.S=\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u044f Java \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430 {0}.
diff --git a/java/engine/org/apache/derby/loc/messages_zh_CN.properties b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
index 36b2fee29..6582da65b 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_CN.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_CN.properties
@@ -162,7 +162,7 @@
 40XD1=\u4EE5\u53EA\u8BFB\u65B9\u5F0F\u6253\u5F00\u5BB9\u5668\u3002
 40XD2=\u65E0\u6CD5\u6253\u5F00\u5BB9\u5668 {0}\uFF1B\u8BE5\u5BB9\u5668\u88AB\u5220\u9664\u6216\u4E0D\u5B58\u5728\u3002
 40XL1=\u8BF7\u6C42\u7684\u65F6\u95F4\u5185\u65E0\u6CD5\u83B7\u53D6\u9501
-40XL2=\u8BF7\u6C42\u7684\u65F6\u95F4\u5185\u65E0\u6CD5\u83B7\u53D6\u9501\u3002lockTable \u8F6C\u50A8\u4E3A\uFF1A{0}
+40XL1.T.1=\u8BF7\u6C42\u7684\u65F6\u95F4\u5185\u65E0\u6CD5\u83B7\u53D6\u9501\u3002lockTable \u8F6C\u50A8\u4E3A\uFF1A{0}
 40XT0=RawStore \u6A21\u5757\u6807\u8BC6\u5185\u90E8\u9519\u8BEF\u3002
 40XT1=\u4E8B\u52A1\u843D\u5B9E\u671F\u95F4\u629B\u51FA\u5F02\u5E38\u3002
 40XT2=SAVEPOINT \u56DE\u6EDA\u671F\u95F4\u629B\u51FA\u5F02\u5E38\u3002
diff --git a/java/engine/org/apache/derby/loc/messages_zh_TW.properties b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
index 6e5f2f15c..6f1a54d3f 100644
--- a/java/engine/org/apache/derby/loc/messages_zh_TW.properties
+++ b/java/engine/org/apache/derby/loc/messages_zh_TW.properties
@@ -163,7 +163,7 @@
 40XD1=\u5DF2\u5728\u552F\u8B80\u6A21\u5F0F\u4E2D\u958B\u555F\u5132\u5B58\u5668\u3002
 40XD2=\u7121\u6CD5\u958B\u555F\u5132\u5B58\u5340 {0}\uFF1B\u4E0D\u662F\u5DF2\u9664\u53BB\u5C31\u662F\u4E0D\u5B58\u5728\u3002
 40XL1=\u7121\u6CD5\u5728\u8981\u6C42\u7684\u6642\u9593\u5167\u53D6\u5F97\u9396\u5B9A
-40XL2=\u7121\u6CD5\u5728\u8981\u6C42\u7684\u6642\u9593\u5167\u53D6\u5F97\u9396\u5B9A\u3002lockTable \u50BE\u5370\u5982\u4E0B\uFF1A{0}
+40XL1.T.1=\u7121\u6CD5\u5728\u8981\u6C42\u7684\u6642\u9593\u5167\u53D6\u5F97\u9396\u5B9A\u3002lockTable \u50BE\u5370\u5982\u4E0B\uFF1A{0}
 40XT0=RawStore \u6A21\u7D44\u6307\u51FA\u4E86\u5167\u90E8\u932F\u8AA4\u3002
 40XT1=\u5728\u4EA4\u6613\u78BA\u5B9A\u671F\u9593\uFF0C\u64F2\u51FA\u7570\u5E38\u72C0\u6CC1\u3002
 40XT2=\u5728 SAVEPOINT \u56DE\u5FA9\u671F\u9593\uFF0C\u64F2\u51FA\u7570\u5E38\u72C0\u6CC1\u3002
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index ca17c072c..2585b8fe4 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -267,7 +267,7 @@ public interface SQLState {
 	*/
 	String DEADLOCK = "40001";
 	String LOCK_TIMEOUT = "40XL1";
-    String LOCK_TIMEOUT_LOG = "40XL2";
+    String LOCK_TIMEOUT_LOG = "40XL1.T.1";
 
 	/*
 	** Store - access.protocol.Interface statement exceptions
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ErrorMessageTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ErrorMessageTest.java
index 4d299f893..cc68ba859 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ErrorMessageTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ErrorMessageTest.java
@@ -74,6 +74,9 @@ public class ErrorMessageTest extends BaseJDBCTestCase {
     /**
      * Test that a wait timeout prints the lock table correctly when the
      * <code>derby.locks.deadlockTrace</code> property is set. DERBY-2817
+     *
+     * After fix for DERBY-5564, the sql state for a lock timeout will be
+     * the same whether diagnostics are on or not (ie. 40XL1).  
      */
     public void testWaitTimeout() throws SQLException {
         getConnection().setAutoCommit(false);
@@ -88,7 +91,7 @@ public class ErrorMessageTest extends BaseJDBCTestCase {
                     s2.executeQuery("select * from t where id=1"));
             fail("Expected lock timeout");
         } catch (SQLException e) {
-            assertSQLState("Not a timeout", "40XL2", e);
+            assertSQLState("Not a timeout", "40XL1", e);
 
             // check that information about the victim is printed
             String[] msg = e.getMessage().split("\n");
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
index a187ffbba..ea3a94242 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
@@ -42,7 +42,6 @@ import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
 public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
 
     final private static String LOCK_TIMEOUT = "40XL1";
-    final private static String LOCK_TIMEOUT_LOG = "40XL2";
 
     /**
      * Creates a new {@code LazyDefaultSchemaCreationTest} instance.
@@ -149,6 +148,9 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
      * nested transaction (cf solution for DERBY-48) when deadlock
      * detection is on, i.e. 40XL2 (LOCK_TIMEOUT_LOG) rather than
      * 40XL1 (LOCK_TIMEOUT) happens.
+     *
+     * After fix for DERBY-5564 LOCK_TIMEOUT will be returned whether
+     * diagnostics are on or not.
      */
     public void testDerby48SelfLockingRecoveryDeadlockDetectionOn ()
             throws SQLException
@@ -166,9 +168,9 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
         // in outer transaction:
         try {
             s1.executeUpdate("create table t1(i int)");
-            fail("Expected exception " + LOCK_TIMEOUT_LOG);
+            fail("Expected exception " + LOCK_TIMEOUT);
         } catch (SQLException e) {
-            assertSQLState("Expected state: ", LOCK_TIMEOUT_LOG, e);
+            assertSQLState("Expected state: ", LOCK_TIMEOUT, e);
         }
 
         JDBC.assertEmpty(
@@ -184,6 +186,9 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
      * use case will not cause an infinite recursion after the fix to
      * DERBY-48). The scenario in this test case does create the
      * infinite recursion prior to the fix of DERBY-3678, however.
+     *
+     * After fix for DERBY-5564 LOCK_TIMEOUT SQL state should be returned
+     * for a lock timeout whether diagnostics are on or not.
      */
     public void testDerby3678 ()
             throws SQLException
@@ -201,9 +206,9 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
         // ..which conflicts with the next connect
         try {
             c2 = openUserConnection("newuser");
-            fail("Expected exception " + LOCK_TIMEOUT_LOG);
+            fail("Expected exception " + LOCK_TIMEOUT);
         } catch (SQLException e) {
-            assertSQLState("Expected state: ", LOCK_TIMEOUT_LOG, e);
+            assertSQLState("Expected state: ", LOCK_TIMEOUT, e);
         } finally {
             c1.rollback();
         }
