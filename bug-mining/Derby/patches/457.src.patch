diff --git a/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
index a2846bda1..d462fe9b0 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
@@ -1124,10 +1124,13 @@ public class ScrollInsensitiveResultSet extends NoPutResultSetImpl
 	 * @exception StandardException on error
 	 */
 	public boolean isDeleted() throws StandardException  {
-		positionInHashTable.setValue(currentPosition);
-		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
-				ht.get(positionInHashTable);
-		return hashRowArray[POS_ROWDELETED].getBoolean();
+		if (currentPosition <= positionInSource && currentPosition > 0) {
+			positionInHashTable.setValue(currentPosition);
+			DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
+					ht.get(positionInHashTable);
+			return hashRowArray[POS_ROWDELETED].getBoolean();
+		}
+		return false;
 	}
 
 	/**
@@ -1139,10 +1142,13 @@ public class ScrollInsensitiveResultSet extends NoPutResultSetImpl
 	 * @exception StandardException on error
 	 */
 	public boolean isUpdated() throws StandardException {
-		positionInHashTable.setValue(currentPosition);
-		DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
-				ht.get(positionInHashTable);
-		return hashRowArray[POS_ROWUPDATED].getBoolean();			
+		if (currentPosition <= positionInSource && currentPosition > 0) {
+			positionInHashTable.setValue(currentPosition);
+			DataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) 
+					ht.get(positionInHashTable);
+			return hashRowArray[POS_ROWUPDATED].getBoolean();
+		}
+		return false;
 	}
 
 	public boolean isForUpdate() {
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out
new file mode 100644
index 000000000..f336e8091
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out
@@ -0,0 +1,161 @@
+CONNECTION0* - 	jdbc:derby://xxxFILTERED_HOSTNAMExxx:1527/SURTest;create=true
+* = current connection
+ij> connect 'SURTest;create=true;';
+ij(CONNECTION1)> autocommit off;
+ij(CONNECTION1)> create table t1 (c1 int primary key, c2 int);
+0 rows inserted/updated/deleted
+ij(CONNECTION1)> insert into t1 values 
+    (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), 
+    (6, 6), (7, 7), (8, 8), (9, 9), (10, 10);
+10 rows inserted/updated/deleted
+ij(CONNECTION1)> get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+ij(CONNECTION1)> next sc1;
+C1 |C2         
+-----
+1 |1          
+ij(CONNECTION1)> next sc1;
+C1 |C2         
+-----
+2 |2          
+ij(CONNECTION1)> -- update row nr. 2 after positioning with next
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> absolute 5 sc1;
+C1 |C2         
+-----
+5 |5          
+ij(CONNECTION1)> -- update row nr. 5 after positioning with absolute
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative 2 sc1;
+C1 |C2         
+-----
+7 |7          
+ij(CONNECTION1)> -- update row nr. 7 after positioning with relative
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> previous sc1;
+C1 |C2         
+-----
+6 |6          
+ij(CONNECTION1)> -- update row nr. 6 after positioning with previous
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative -1 sc1;
+C1 |C2         
+-----
+5 |25         
+ij(CONNECTION1)> last sc1;
+C1 |C2         
+-----
+10 |10         
+ij(CONNECTION1)> -- update row nr. 10 after positioning with last
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> after last sc1;
+No current row
+ij(CONNECTION1)> -- update when positioned after last should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ij(CONNECTION1)> first sc1;
+C1 |C2         
+-----
+1 |1          
+ij(CONNECTION1)> -- update row nr. 1 after positioning with first
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> before first sc1;
+No current row
+ij(CONNECTION1)> -- update when positioned before first should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ij(CONNECTION1)> close sc1;
+ij(CONNECTION1)> commit;
+ij(CONNECTION1)> -- check that row where correctly updated
+select * from t1;
+C1 |C2         
+-----
+1 |21         
+2 |22         
+3 |3          
+4 |4          
+5 |25         
+6 |26         
+7 |27         
+8 |8          
+9 |9          
+10 |30         
+10 rows selected
+ij(CONNECTION1)> get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+ij(CONNECTION1)> next sc1;
+C1 |C2         
+-----
+1 |21         
+ij(CONNECTION1)> next sc1;
+C1 |C2         
+-----
+2 |22         
+ij(CONNECTION1)> -- delete row nr. 2 after positioning with next
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> absolute 5 sc1;
+C1 |C2         
+-----
+5 |25         
+ij(CONNECTION1)> -- delete row nr. 5 after positioning with absolute
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative 2 sc1;
+C1 |C2         
+-----
+7 |27         
+ij(CONNECTION1)> -- delete row nr. 7 after positioning with relative
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> previous sc1;
+C1 |C2         
+-----
+6 |26         
+ij(CONNECTION1)> -- delete row nr. 6 after positioning with previous
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative -1 sc1;
+C1 |C2         
+-----
+NULL |NULL       
+ij(CONNECTION1)> last sc1;
+C1 |C2         
+-----
+10 |30         
+ij(CONNECTION1)> -- delete row nr. 10 after positioning with last
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> after last sc1;
+No current row
+ij(CONNECTION1)> -- delete when positioned after last should cause an error
+delete from t1 where current of sc1;
+ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ij(CONNECTION1)> first sc1;
+C1 |C2         
+-----
+1 |21         
+ij(CONNECTION1)> -- delete row nr. 1 after positioning with first
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> before first sc1;
+No current row
+ij(CONNECTION1)> -- delete when positioned before first should cause an error
+delete from t1 where current of sc1;
+ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ij(CONNECTION1)> close sc1;
+ij(CONNECTION1)> commit;
+ij(CONNECTION1)> -- check that row where correctly updated
+select * from t1;
+C1 |C2         
+-----
+3 |3          
+4 |4          
+8 |8          
+9 |9          
+4 rows selected
+ij(CONNECTION1)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out b/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out
new file mode 100644
index 000000000..22d004149
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out
@@ -0,0 +1,162 @@
+CONNECTION0* - 	jdbc:derby:SURTest
+* = current connection
+ij> connect 'SURTest;create=true;';
+WARNING 01J01: Database 'SURTest' not created, connection made to existing database instead.
+ij(CONNECTION1)> autocommit off;
+ij(CONNECTION1)> create table t1 (c1 int primary key, c2 int);
+0 rows inserted/updated/deleted
+ij(CONNECTION1)> insert into t1 values 
+    (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), 
+    (6, 6), (7, 7), (8, 8), (9, 9), (10, 10);
+10 rows inserted/updated/deleted
+ij(CONNECTION1)> get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+ij(CONNECTION1)> next sc1;
+C1         |C2         
+-----------------------
+1          |1          
+ij(CONNECTION1)> next sc1;
+C1         |C2         
+-----------------------
+2          |2          
+ij(CONNECTION1)> -- update row nr. 2 after positioning with next
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> absolute 5 sc1;
+C1         |C2         
+-----------------------
+5          |5          
+ij(CONNECTION1)> -- update row nr. 5 after positioning with absolute
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative 2 sc1;
+C1         |C2         
+-----------------------
+7          |7          
+ij(CONNECTION1)> -- update row nr. 7 after positioning with relative
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> previous sc1;
+C1         |C2         
+-----------------------
+6          |6          
+ij(CONNECTION1)> -- update row nr. 6 after positioning with previous
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative -1 sc1;
+C1         |C2         
+-----------------------
+5          |25         
+ij(CONNECTION1)> last sc1;
+C1         |C2         
+-----------------------
+10         |10         
+ij(CONNECTION1)> -- update row nr. 10 after positioning with last
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> after last sc1;
+No current row
+ij(CONNECTION1)> -- update when positioned after last should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+ERROR XCL08: Cursor 'SC1' is not on a row.
+ij(CONNECTION1)> first sc1;
+C1         |C2         
+-----------------------
+1          |1          
+ij(CONNECTION1)> -- update row nr. 1 after positioning with first
+update t1 set c2 = c1 + 20 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> before first sc1;
+No current row
+ij(CONNECTION1)> -- update when positioned before first should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+ERROR XCL08: Cursor 'SC1' is not on a row.
+ij(CONNECTION1)> close sc1;
+ij(CONNECTION1)> commit;
+ij(CONNECTION1)> -- check that row where correctly updated
+select * from t1;
+C1         |C2         
+-----------------------
+1          |21         
+2          |22         
+3          |3          
+4          |4          
+5          |25         
+6          |26         
+7          |27         
+8          |8          
+9          |9          
+10         |30         
+10 rows selected
+ij(CONNECTION1)> get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+ij(CONNECTION1)> next sc1;
+C1         |C2         
+-----------------------
+1          |21         
+ij(CONNECTION1)> next sc1;
+C1         |C2         
+-----------------------
+2          |22         
+ij(CONNECTION1)> -- delete row nr. 2 after positioning with next
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> absolute 5 sc1;
+C1         |C2         
+-----------------------
+5          |25         
+ij(CONNECTION1)> -- delete row nr. 5 after positioning with absolute
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative 2 sc1;
+C1         |C2         
+-----------------------
+7          |27         
+ij(CONNECTION1)> -- delete row nr. 7 after positioning with relative
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> previous sc1;
+C1         |C2         
+-----------------------
+6          |26         
+ij(CONNECTION1)> -- delete row nr. 6 after positioning with previous
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> relative -1 sc1;
+C1         |C2         
+-----------------------
+NULL       |NULL       
+ij(CONNECTION1)> last sc1;
+C1         |C2         
+-----------------------
+10         |30         
+ij(CONNECTION1)> -- delete row nr. 10 after positioning with last
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> after last sc1;
+No current row
+ij(CONNECTION1)> -- delete when positioned after last should cause an error
+delete from t1 where current of sc1;
+ERROR XCL08: Cursor 'SC1' is not on a row.
+ij(CONNECTION1)> first sc1;
+C1         |C2         
+-----------------------
+1          |21         
+ij(CONNECTION1)> -- delete row nr. 1 after positioning with first
+delete from t1 where current of sc1;
+1 row inserted/updated/deleted
+ij(CONNECTION1)> before first sc1;
+No current row
+ij(CONNECTION1)> -- delete when positioned before first should cause an error
+delete from t1 where current of sc1;
+ERROR XCL08: Cursor 'SC1' is not on a row.
+ij(CONNECTION1)> close sc1;
+ij(CONNECTION1)> commit;
+ij(CONNECTION1)> -- check that row where correctly updated
+select * from t1;
+C1         |C2         
+-----------------------
+3          |3          
+4          |4          
+8          |8          
+9          |9          
+4 rows selected
+ij(CONNECTION1)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/suites/DerbyNet.exclude b/java/testing/org/apache/derbyTesting/functionTests/suites/DerbyNet.exclude
index f5384363c..81354d21e 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/suites/DerbyNet.exclude
+++ b/java/testing/org/apache/derbyTesting/functionTests/suites/DerbyNet.exclude
@@ -46,3 +46,4 @@ jdbcapi/HoldabilityTest.junit
 # Excluding checkDataSource and checkDataSource30 because JCC has no XA
 jdbcapi/checkDataSource30.java
 jdbcapi/checkDataSource.java
+jdbcapi/SURTest_ij.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/suites/jdbcapi.runall b/java/testing/org/apache/derbyTesting/functionTests/suites/jdbcapi.runall
index b67afb4b3..02b9911b0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/suites/jdbcapi.runall
+++ b/java/testing/org/apache/derbyTesting/functionTests/suites/jdbcapi.runall
@@ -25,3 +25,4 @@ jdbcapi/UpdateXXXTest.junit
 jdbcapi/SURQueryMixTest.junit
 jdbcapi/SURTest.junit
 jdbcapi/URCoveringIndexTest.junit
+jdbcapi/SURTest_ij.sql
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij.sql
new file mode 100644
index 000000000..2b6a079c4
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij.sql
@@ -0,0 +1,68 @@
+connect 'SURTest;create=true;';
+autocommit off;
+create table t1 (c1 int primary key, c2 int);
+insert into t1 values 
+    (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), 
+    (6, 6), (7, 7), (8, 8), (9, 9), (10, 10);
+get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+next sc1;
+next sc1;
+-- update row nr. 2 after positioning with next
+update t1 set c2 = c1 + 20 where current of sc1;
+absolute 5 sc1;
+-- update row nr. 5 after positioning with absolute
+update t1 set c2 = c1 + 20 where current of sc1;
+relative 2 sc1;
+-- update row nr. 7 after positioning with relative
+update t1 set c2 = c1 + 20 where current of sc1;
+previous sc1;
+-- update row nr. 6 after positioning with previous
+update t1 set c2 = c1 + 20 where current of sc1;
+relative -1 sc1;
+last sc1;
+-- update row nr. 10 after positioning with last
+update t1 set c2 = c1 + 20 where current of sc1;
+after last sc1;
+-- update when positioned after last should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+first sc1;
+-- update row nr. 1 after positioning with first
+update t1 set c2 = c1 + 20 where current of sc1;
+before first sc1;
+-- update when positioned before first should cause an error
+update t1 set c2 = c1 + 20 where current of sc1;
+close sc1;
+commit;
+-- check that row where correctly updated
+select * from t1;
+get scroll insensitive cursor sc1 as 'SELECT * FROM t1 FOR UPDATE';
+next sc1;
+next sc1;
+-- delete row nr. 2 after positioning with next
+delete from t1 where current of sc1;
+absolute 5 sc1;
+-- delete row nr. 5 after positioning with absolute
+delete from t1 where current of sc1;
+relative 2 sc1;
+-- delete row nr. 7 after positioning with relative
+delete from t1 where current of sc1;
+previous sc1;
+-- delete row nr. 6 after positioning with previous
+delete from t1 where current of sc1;
+relative -1 sc1;
+last sc1;
+-- delete row nr. 10 after positioning with last
+delete from t1 where current of sc1;
+after last sc1;
+-- delete when positioned after last should cause an error
+delete from t1 where current of sc1;
+first sc1;
+-- delete row nr. 1 after positioning with first
+delete from t1 where current of sc1;
+before first sc1;
+-- delete when positioned before first should cause an error
+delete from t1 where current of sc1;
+close sc1;
+commit;
+-- check that row where correctly updated
+select * from t1;
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij_app.properties b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij_app.properties
new file mode 100644
index 000000000..5e0907a96
--- /dev/null
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest_ij_app.properties
@@ -0,0 +1,2 @@
+ij.protocol=jdbc:derby:
+ij.database=SURTest;create=true;
