diff --git a/java/engine/org/apache/derby/impl/sql/compile/ModifyColumnNode.java b/java/engine/org/apache/derby/impl/sql/compile/ModifyColumnNode.java
index 5d0745598..27b1779a8 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ModifyColumnNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ModifyColumnNode.java
@@ -35,6 +35,7 @@ import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
 import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
 
 import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.types.DataTypeDescriptor;
 
 import org.apache.derby.iapi.reference.SQLState;
 
@@ -93,7 +94,7 @@ public class ModifyColumnNode extends ColumnDefinitionNode
 	{
 		ColumnDescriptor cd;
 		TypeDescriptor oldType;
-		TypeDescriptor newType = dataTypeServices;
+		DataTypeDescriptor newType = dataTypeServices;
 		TypeId oldTypeId;
 		TypeId newTypeId;
 
@@ -110,6 +111,7 @@ public class ModifyColumnNode extends ColumnDefinitionNode
 		oldType = cd.getType();
 		oldTypeId = cd.getType().getTypeId();
 		newTypeId = dataTypeServices.getTypeId();
+		newType.setNullability(oldType.isNullable());
 
 		// can't change types yet.
 		if (!(oldTypeId.equals(newTypeId)))
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/modifyColumn.out b/java/testing/org/apache/derbyTesting/functionTests/master/modifyColumn.out
index f2f958fd7..3bc807c66 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/modifyColumn.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/modifyColumn.out
@@ -126,32 +126,78 @@ insert into t1 values ('pe','pe', x'01');
 ERROR 23505: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'UQ' defined on 'T1'.
 ij> -- do some selects to ensure consistency of data.
 select * from t1 where vc='pe';
-VC  |NVC |BV  
---------------
-pe  |p   |01  
-pe  |pe  |01  
-pe  |pe  |1000
+VC|N&|BV  
+----------
+pe|p |01  
+pe|pe|01  
+pe|pe|1000
 ij> select * from t1 where vc='pe';
-VC  |NVC |BV  
---------------
-pe  |p   |01  
-pe  |pe  |01  
-pe  |pe  |1000
+VC|N&|BV  
+----------
+pe|p |01  
+pe|pe|01  
+pe|pe|1000
 ij> alter table t1 alter vc set data type varchar(3);
 0 rows inserted/updated/deleted
 ij> select * from t1 where vc='pe';
-VC  |NVC |BV  
---------------
-pe  |p   |01  
-pe  |pe  |01  
-pe  |pe  |1000
+VC |N&|BV  
+-----------
+pe |p |01  
+pe |pe|01  
+pe |pe|1000
 ij> select * from t1 where vc='pe';
-VC  |NVC |BV  
---------------
-pe  |p   |01  
-pe  |pe  |01  
-pe  |pe  |1000
+VC |N&|BV  
+-----------
+pe |p |01  
+pe |pe|01  
+pe |pe|1000
 ij> -- clean up
 drop table t1;
 0 rows inserted/updated/deleted
+ij> -- DERBY-882
+-- ALTER TABLE to increase size of varchar could convert a non-null column to nullable
+-- before fix for DERBY-882
+create table a (id integer not null, name varchar(20) not null, primary key(name));
+0 rows inserted/updated/deleted
+ij> insert into a values (1, 'abc');
+1 row inserted/updated/deleted
+ij> -- Should fail
+insert into a values (2, null);
+ERROR 23502: Column 'NAME'  cannot accept a NULL value.
+ij> alter table a alter name set data type varchar(50);
+0 rows inserted/updated/deleted
+ij> insert into a values (3, 'hijk');
+1 row inserted/updated/deleted
+ij> -- Used to pass before the fix
+insert into a values (4, null);
+ERROR 23502: Column 'NAME'  cannot accept a NULL value.
+ij> select * from a;
+ID         |NAME                                              
+--------------------------------------------------------------
+1          |abc                                               
+3          |hijk                                              
+ij> drop table a;
+0 rows inserted/updated/deleted
+ij> -- Now test the otherway, nullable column to start with
+create table a (id integer not null, name varchar(20));
+0 rows inserted/updated/deleted
+ij> insert into a values (1, 'abc');
+1 row inserted/updated/deleted
+ij> insert into a values (2, null);
+1 row inserted/updated/deleted
+ij> alter table a alter name set data type varchar(50);
+0 rows inserted/updated/deleted
+ij> insert into a values (3, 'hijk');
+1 row inserted/updated/deleted
+ij> insert into a values (4, null);
+1 row inserted/updated/deleted
+ij> select * from a;
+ID         |NAME                                              
+--------------------------------------------------------------
+1          |abc                                               
+2          |NULL                                              
+3          |hijk                                              
+4          |NULL                                              
+ij> drop table a;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/modifyColumn.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/modifyColumn.sql
index bc5e5bfb2..b7a6e7ad3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/modifyColumn.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/modifyColumn.sql
@@ -91,3 +91,31 @@ select * from t1 where vc='pe';
 
 -- clean up
 drop table t1;
+
+-- DERBY-882
+-- ALTER TABLE to increase size of varchar could convert a non-null column to nullable
+-- before fix for DERBY-882
+
+create table a (id integer not null, name varchar(20) not null, primary key(name)); 
+insert into a values (1, 'abc'); 
+-- Should fail
+insert into a values (2, null); 
+alter table a alter name set data type varchar(50);
+insert into a values (3, 'hijk'); 
+-- Used to pass before the fix
+insert into a values (4, null);
+select * from a; 
+
+drop table a;
+
+-- Now test the otherway, nullable column to start with
+create table a (id integer not null, name varchar(20)); 
+insert into a values (1, 'abc'); 
+insert into a values (2, null); 
+alter table a alter name set data type varchar(50);
+insert into a values (3, 'hijk'); 
+insert into a values (4, null);
+select * from a; 
+
+drop table a;
+
