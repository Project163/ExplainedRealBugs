diff --git a/java/engine/org/apache/derby/iapi/reference/SQLState.java b/java/engine/org/apache/derby/iapi/reference/SQLState.java
index c89e8fd7c..edc87942d 100755
--- a/java/engine/org/apache/derby/iapi/reference/SQLState.java
+++ b/java/engine/org/apache/derby/iapi/reference/SQLState.java
@@ -1456,9 +1456,12 @@ public interface SQLState {
 	String UU_INVALID_PARAMETER										= "XCZ02.S";
 
 	/*
+	** SQL Java DDL 46xxx
 	** SQLJ jar file support
 	*/
 	String SQLJ_INVALID_JAR				= "46001";
+	String SQLJ_SIGNATURE_INVALID	    		= "46J01";
+	String SQLJ_SIGNATURE_PARAMETER_COUNT	    = "46J02";
 
 	/*
 	** Import/Export
diff --git a/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java b/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
index 6545c4e44..79d5d16f4 100755
--- a/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
+++ b/java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java
@@ -316,41 +316,6 @@ public final class ClassInspector
 						primParamClasses, isParam, staticMethod, repeatLastParameter, methodList);
 	}
 
-    public Method findPublicMethod(String className, String signature, boolean isStatic) throws ClassNotFoundException {
-        Class javaClass = getClass(className);
-        StringTokenizer tokenizer = new StringTokenizer(signature, "(,)", true);
-        try {
-            String methodName = tokenizer.nextToken();
-            if (!tokenizer.nextToken().equals("(")) {
-                return null;
-            }
-            List paramTypes;
-            String token = tokenizer.nextToken();
-            if (")".equals(token)) {
-                paramTypes = Collections.EMPTY_LIST;
-            } else {
-                paramTypes = new ArrayList();
-                paramTypes.add(getClass(token));
-                while ((token = tokenizer.nextToken()).equals(",")) {
-                    token = tokenizer.nextToken();
-                    paramTypes.add(getClass(token));
-                }
-            }
-
-            Method method;
-            try {
-                method = javaClass.getMethod(methodName, (Class[])paramTypes.toArray(new Class[paramTypes.size()]));
-                if (isStatic != Modifier.isStatic(method.getModifiers())) {
-                    return null;
-                }
-            } catch (NoSuchMethodException e) {
-                return null;
-            }
-            return method;
-        } catch (NoSuchElementException e) {
-            return null;
-        }
-    }
 
 	/**
 	 * Find a public field  for a class.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java b/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
index 2e6de0e1a..cdc69f7f9 100755
--- a/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
@@ -56,6 +56,7 @@ import org.apache.derby.catalog.types.RoutineAliasInfo;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Member;
 
+import java.util.StringTokenizer;
 import java.util.Vector;
 
 /**
@@ -671,7 +672,8 @@ public abstract class MethodCallNode extends JavaValueNode
 
 		ClassInspector classInspector = getClassFactory().getClassInspector();
 
-		String[]		parmTypeNames = getObjectSignature();
+		
+		String[]		parmTypeNames;
 		String[]		primParmTypeNames = null;
 		boolean[]		isParam = getIsParam();
 
@@ -680,16 +682,27 @@ public abstract class MethodCallNode extends JavaValueNode
         /*
         ** Find the matching method that is public.
         */
-        try
-        {
+
+        	int signatureOffset = methodName.indexOf('(');
+        	
             // support Java signatures by checking if the method name contains a '('
-            if (methodName.indexOf('(') != -1) {
-                method = classInspector.findPublicMethod(javaClassName, methodName, staticMethod);
-                methodName = method.getName();
+            if (signatureOffset != -1) {
+               	parmTypeNames = parseValidateSignature(methodName, signatureOffset, hasDynamicResultSets);
+               methodName = methodName.substring(0, signatureOffset);
+               
+               // If the signature is specified then Derby resolves to exactly
+               // that method. Setting this flag to false disables the method
+               // resolution from automatically optionally repeating the last
+               // parameter as needed.
+               hasDynamicResultSets = false;
+              	 
             }
             else
             {
-                /* First try with built-in types and mappings */
+            	parmTypeNames = getObjectSignature();
+            }
+        try
+        {                      	
                 method = classInspector.findPublicMethod(javaClassName,
                                                     methodName,
                                                     parmTypeNames,
@@ -702,7 +715,8 @@ public abstract class MethodCallNode extends JavaValueNode
                 // DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
                 // and these are the only types that can map to a primitive or an object type according
                 // to SQL part 13. So we never have a second chance match.
-                if (routineInfo == null) {
+                // Also if the DDL specified a signature, then no alternate resolution
+                if (signatureOffset == -1 && routineInfo == null) {
 
                     /* If no match, then retry with combinations of object and
                      * primitive types.
@@ -720,7 +734,6 @@ public abstract class MethodCallNode extends JavaValueNode
                                                     hasDynamicResultSets);
                     }
                 }
-            }
         }
         catch (ClassNotFoundException e)
         {
@@ -829,7 +842,7 @@ public abstract class MethodCallNode extends JavaValueNode
 				}
 			}
 
-			if (classInspector.primitiveType(methodParameter))
+			if (ClassInspector.primitiveType(methodParameter))
 				methodParms[i].castToPrimitive(true);
 		}
 
@@ -853,6 +866,137 @@ public abstract class MethodCallNode extends JavaValueNode
 			getCompilerContext().getParameterTypes()[0] = dts;
 		}
   }
+	
+	/**
+	 * Parse the user supplied signature for a method and validate
+	 * it, need to match the number of parameters passed in and match
+	 * the valid types for the parameter.
+	 * @param signature complete external name with signature
+	 * @param offset Character offset of first paren
+	 * @param hasDynamicResultSets Can ResultSet[] parameters be specified.
+	 * @return The valid array of types for resolution.
+	 * @throws StandardException
+	 */
+	private String[] parseValidateSignature(String externalName, int offset,
+			boolean hasDynamicResultSets)
+		throws StandardException
+	{
+		int siglen = externalName.length();
+
+		// Ensure the opening paren is not the last
+		// character and that the last character is a close paren
+		if (((offset + 1) == siglen)
+			|| (externalName.charAt(siglen - 1) != ')'))
+			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
+		
+        StringTokenizer st = new StringTokenizer(externalName.substring(offset + 1, siglen - 1), ",", true);
+        
+        String[] signatureTypes = new String[signature.length];
+        int count;
+        boolean seenClass = false;
+        for (count = 0; st.hasMoreTokens();)
+        {
+           	String type = st.nextToken().trim();
+ 
+           	// check sequence is <class><comma>class> etc.
+           	if (",".equals(type))
+           	{
+           		if (!seenClass)
+           			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
+           		seenClass = false;
+           		continue;
+           	}
+           	else
+           	{
+           		if (type.length() == 0)
+           			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
+           		seenClass = true;
+           		count++;
+           	}
+           	           	           	           
+           	if (count > signature.length)
+        	{
+        		if (hasDynamicResultSets)
+        		{
+        			// Allow any number of dynamic result set holders
+        			// but they must match the exact type.
+        			String rsType = signature[signature.length - 1].getSQLType().
+						getTypeId().getCorrespondingJavaTypeName();
+        			
+        			if (!type.equals(rsType))
+        				throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
+                				type, rsType);
+
+        			if (signatureTypes.length == signature.length)
+        			{
+        				// expand once
+        				String[] sigs = new String[st.countTokens()];
+        				System.arraycopy(signatureTypes, 0, sigs, 0, signatureTypes.length);
+        				signatureTypes = sigs;
+        			}
+        			
+            		signatureTypes[count - 1] = type;
+            		continue;
+       			
+        		}
+    			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
+        				Integer.toString(count),
+        				Integer.toString(signature.length)); // too many types
+        	}
+
+        	       	
+        	TypeId	paramTypeId = signature[count - 1].getSQLType().getTypeId();
+        	        	
+        	// Does it match the object name
+        	if (type.equals(paramTypeId.getCorrespondingJavaTypeName()))
+        	{
+        		signatureTypes[count - 1] = type;
+        		continue;
+        	}
+      	
+        	// how about the primitive name
+			if ((paramTypeId.isNumericTypeId() && !paramTypeId.isDecimalTypeId())
+					|| paramTypeId.isBooleanTypeId())
+			{
+				TypeCompiler tc = getTypeCompiler(paramTypeId);
+				if (type.equals(tc.getCorrespondingPrimitiveTypeName()))
+				{
+		       		signatureTypes[count - 1] = type;
+	        		continue;					
+				}
+			}
+        	throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
+        				type, paramTypeId.getSQLTypeName()); // type conversion error
+        }
+        
+        // Did signature end with trailing comma?
+        if (count != 0 && !seenClass)
+        	throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
+        
+        if (count < signatureTypes.length)
+        {
+        	if (hasDynamicResultSets)
+        	{
+        		// we can tolerate a count of one less than the
+        		// expected count, which means the procedure is declared
+        		// to have dynamic result sets, but the explict signature
+        		// doesn't have any ResultSet[] types.
+        		// So accept, and procedure will automatically have 0
+        		// dynamic results at runtime
+        		if (count == (signature.length - 1))
+        		{
+        			String[] sigs = new String[count];
+        			System.arraycopy(signatureTypes, 0, sigs, 0, count);
+        			return sigs;
+        		}
+        	}
+			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
+    				Integer.toString(count),
+    				Integer.toString(signature.length)); // too few types
+        }
+
+        return signatureTypes;
+	}
 
 	/**
 	  *	Return true if some parameters are null, false otherwise.
diff --git a/java/engine/org/apache/derby/loc/messages_en.properties b/java/engine/org/apache/derby/loc/messages_en.properties
index 56a1fd7cf..0d4449779 100755
--- a/java/engine/org/apache/derby/loc/messages_en.properties
+++ b/java/engine/org/apache/derby/loc/messages_en.properties
@@ -1135,6 +1135,8 @@ XCZ02.S=Invalid parameter ''{0}''=''{1}''.
 
 # SQL J Jar support
 46001=Exception while accessing jar file using URL ''{0}''.
+46J01=Java method signature has invalid format.
+46J02=Java method signature contains incorrect number ({0}) of parameters, expected {1}.
 
 ###############################################################################
 #
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/procedure.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/procedure.out
index 5eba439f1..cb6545ff6 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/procedure.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/procedure.out
@@ -51,6 +51,27 @@ CALL APP.NSP(?, ?)
 EXPECTED SQL Exception: (42Y03) 'APP.NSP' is not recognized as a function or procedure.
 call syscs_util.syscs_set_database_property("foo", "bar")
 EXPECTED SQL Exception: (42X15) Column name 'foo' appears in a statement without a FROM list.
+signature mismatched types
+CALL APP.SIGNATURE_BUG_DERBY_258_A(4)
+EXPECTED SQL Exception: (22005) An attempt was made to get a data value of type 'java.lang.String' from a data value of type 'INTEGER'.
+signature too many parameters
+VALUES APP.SIGNATURE_BUG_DERBY_258_B(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (2) of parameters, expected 1.
+signature too few parameters
+CALL APP.SIGNATURE_BUG_DERBY_258_C(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (0) of parameters, expected 1.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_F(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_G(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_H(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_I(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
 testDelayedClassChecking
 call noclass()
 EXPECTED SQL Exception: (42X51) The class 'asdf' does not exist or is inaccessible. This can happen if the class is not public. SQLSTATE: XJ001: Java exception: 'asdf: java.lang.ClassNotFoundException'.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/procedure.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/procedure.out
index 3cbd866ba..6c221d6ba 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/procedure.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/procedure.out
@@ -51,6 +51,27 @@ CALL APP.NSP(?, ?)
 EXPECTED SQL Exception: (42Y03) 'APP.NSP' is not recognized as a function or procedure.
 call syscs_util.syscs_set_database_property("foo", "bar")
 EXPECTED SQL Exception: (42X15) Column name 'foo' appears in a statement without a FROM list.
+signature mismatched types
+CALL APP.SIGNATURE_BUG_DERBY_258_A(4)
+EXPECTED SQL Exception: (22005) An attempt was made to get a data value of type 'java.lang.String' from a data value of type 'INTEGER'.
+signature too many parameters
+VALUES APP.SIGNATURE_BUG_DERBY_258_B(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (2) of parameters, expected 1.
+signature too few parameters
+CALL APP.SIGNATURE_BUG_DERBY_258_C(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (0) of parameters, expected 1.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_F(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_G(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_H(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_I(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
 testDelayedClassChecking
 call noclass()
 EXPECTED SQL Exception: (42X51) The class 'asdf' does not exist or is inaccessible. This can happen if the class is not public. SQLSTATE: XJ001: Java exception: 'asdf: java.lang.ClassNotFoundException'.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/functions.out b/java/testing/org/apache/derbyTesting/functionTests/master/functions.out
index 965dc9698..27d5b2d70 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/functions.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/functions.out
@@ -488,4 +488,43 @@ MODIFIES SQL DATA
 EXTERNAL NAME 'org.apache.derbyTesting.functionTests.util.ProcedureTest.countRows'
 LANGUAGE JAVA PARAMETER STYLE JAVA;
 ERROR 42X01: Syntax error: MODIFIES SQL DATA.
+ij> CREATE FUNCTION SIGNATURE_BUG_DERBY_258_D(P_VAL INT, P_RADIX INT) RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toString(int, int)';
+0 rows inserted/updated/deleted
+ij> CREATE FUNCTION SIGNATURE_BUG_DERBY_258_NS(P_VAL INT, P_RADIX INT) RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toString';
+0 rows inserted/updated/deleted
+ij> CREATE FUNCTION SIGNATURE_BUG_DERBY_258_E() RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toXXString()';
+0 rows inserted/updated/deleted
+ij> -- these are ok
+VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 16);
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+934                                                                                                                             
+ij> VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 10);
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+2356                                                                                                                            
+ij> VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 2);
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+100100110100                                                                                                                    
+ij> -- Must resolve as above
+VALUES SIGNATURE_BUG_DERBY_258_D(2356, 16);
+1                                                                                                                               
+--------------------------------------------------------------------------------------------------------------------------------
+934                                                                                                                             
+ij> -- no method to resolve to (with specified signature)
+VALUES SIGNATURE_BUG_DERBY_258_E();
+ERROR 42X50: No method was found that matched the method call java.lang.Integer.toXXString(), tried all combinations of object and primitive types and any possible type conversion for any  parameters the method call may have. The method might exist but it is not public and/or static, or the parameter types are not method invocation convertible.
+ij> DROP FUNCTION SIGNATURE_BUG_DERBY_258_D;
+0 rows inserted/updated/deleted
+ij> DROP FUNCTION SIGNATURE_BUG_DERBY_258_E;
+0 rows inserted/updated/deleted
+ij> DROP FUNCTION SIGNATURE_BUG_DERBY_258_NS;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/procedure.out b/java/testing/org/apache/derbyTesting/functionTests/master/procedure.out
index 68daa0fe4..d5b651379 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/procedure.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/procedure.out
@@ -51,6 +51,27 @@ CALL APP.NSP(?, ?)
 EXPECTED SQL Exception: (42Y03) 'APP.NSP' is not recognized as a function or procedure.
 call syscs_util.syscs_set_database_property("foo", "bar")
 EXPECTED SQL Exception: (42X15) Column name 'foo' appears in a statement without a FROM list.
+signature mismatched types
+CALL APP.SIGNATURE_BUG_DERBY_258_A(4)
+EXPECTED SQL Exception: (22005) An attempt was made to get a data value of type 'java.lang.String' from a data value of type 'INTEGER'.
+signature too many parameters
+VALUES APP.SIGNATURE_BUG_DERBY_258_B(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (2) of parameters, expected 1.
+signature too few parameters
+CALL APP.SIGNATURE_BUG_DERBY_258_C(4)
+EXPECTED SQL Exception: (46J02) Java method signature contains incorrect number (0) of parameters, expected 1.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_F(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_G(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_H(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
+signature invalid format
+CALL APP.SIGNATURE_BUG_DERBY_258_I(4)
+EXPECTED SQL Exception: (46J01) Java method signature has invalid format.
 testDelayedClassChecking
 call noclass()
 EXPECTED SQL Exception: (42X51) The class 'asdf' does not exist or is inaccessible. This can happen if the class is not public.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/functions.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/functions.sql
index 314946d8a..2b70f60cc 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/functions.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/functions.sql
@@ -199,3 +199,30 @@ MODIFIES SQL DATA
 EXTERNAL NAME 'org.apache.derbyTesting.functionTests.util.ProcedureTest.countRows'
 LANGUAGE JAVA PARAMETER STYLE JAVA;
 
+CREATE FUNCTION SIGNATURE_BUG_DERBY_258_D(P_VAL INT, P_RADIX INT) RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toString(int, int)';
+CREATE FUNCTION SIGNATURE_BUG_DERBY_258_NS(P_VAL INT, P_RADIX INT) RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toString';
+CREATE FUNCTION SIGNATURE_BUG_DERBY_258_E() RETURNS VARCHAR(20)
+LANGUAGE JAVA PARAMETER STYLE JAVA NO SQL
+EXTERNAL NAME 'java.lang.Integer.toXXString()';
+
+-- these are ok
+VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 16);
+VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 10);
+VALUES SIGNATURE_BUG_DERBY_258_NS(2356, 2);
+
+-- Must resolve as above
+VALUES SIGNATURE_BUG_DERBY_258_D(2356, 16);
+-- no method to resolve to (with specified signature)
+VALUES SIGNATURE_BUG_DERBY_258_E();
+
+DROP FUNCTION SIGNATURE_BUG_DERBY_258_D;
+DROP FUNCTION SIGNATURE_BUG_DERBY_258_E;
+DROP FUNCTION SIGNATURE_BUG_DERBY_258_NS;
+
+
+
+
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/procedure.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/procedure.java
index cf5c0bc0a..b9b8793e2 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/procedure.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/procedure.java
@@ -149,8 +149,51 @@ public class procedure
 
 		// bug 5760 - this caused a null pointer exception at one time.
 		statementExceptionExpected(s, "call syscs_util.syscs_set_database_property(\"foo\", \"bar\")");
-
+		
+		// Derby-258 specific signatures with types not matching JDBC spec.
+		System.out.println("signature mismatched types");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_A(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.load(java.lang.String)'");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_A(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_A");
+
+		// signature with wrong number of arguments, too many
+		System.out.println("signature too many parameters");
+		s.execute("CREATE FUNCTION SIGNATURE_BUG_DERBY_258_B(A INT) RETURNS VARCHAR(128) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.Integer.toString(int, int)'");
+		statementExceptionExpected(s, "VALUES APP.SIGNATURE_BUG_DERBY_258_B(4)");
+		s.execute("DROP FUNCTION SIGNATURE_BUG_DERBY_258_B");
+
+		// and too few
+		System.out.println("signature too few parameters");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_C(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.gc()'");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_C(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_C");
+
+		// only a leading paren
+		System.out.println("signature invalid format");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_F(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.gc('");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_F(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_F");
+
+		// signature of (,,)
+		System.out.println("signature invalid format");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_G(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.gc(,,)'");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_G(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_G");
+
+		// signature of (, ,)
+		System.out.println("signature invalid format");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_H(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.gc(, ,)'");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_H(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_H");
+
+		// signature of (int,)
+		System.out.println("signature invalid format");
+		s.execute("CREATE PROCEDURE SIGNATURE_BUG_DERBY_258_I(IN A INT) LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME 'java.lang.System.gc(int ,)'");
+		statementExceptionExpected(s, "CALL APP.SIGNATURE_BUG_DERBY_258_I(4)");
+		s.execute("DROP PROCEDURE SIGNATURE_BUG_DERBY_258_I");
+		
 		s.close();
+		
 	}
 	
    
