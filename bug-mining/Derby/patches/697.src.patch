diff --git a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index a2b7f61af..a31faef48 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -1069,10 +1069,20 @@ public class ColumnReference extends ValueNode
 		rcExpr = rc.getExpression();
 		colNum[0] = getColumnNumber();
 
-		while ((rcExpr != null) && (rcExpr instanceof ColumnReference))
+		/* We have to make sure we enter this loop if rc is redundant,
+		 * so that we can navigate down to the actual source result
+		 * set (DERBY-1777). If rc *is* redundant, then rcExpr is not
+		 * guaranteed to be a ColumnReference, so we have to check
+		 * for that case inside the loop.
+		 */
+		while ((rcExpr != null) &&
+			(rc.isRedundant() || (rcExpr instanceof ColumnReference)))
 		{
-			colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
-			rc = ((ColumnReference)rcExpr).getSource();
+			if (rcExpr instanceof ColumnReference)
+			{
+				colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
+				rc = ((ColumnReference)rcExpr).getSource();
+			}
 
 			/* If "rc" is redundant then that means it points to another
 			 * ResultColumn that in turn points to the source expression.
diff --git a/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java b/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
index ececd3a77..9980a0456 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/OptimizerImpl.java
@@ -454,18 +454,21 @@ public class OptimizerImpl implements Optimizer
 					firstLookOrder[i] = bestJoinOrder[i];
 				permuteState = JUMPING;
 
-				// If we were in the middle of a join order when this
-				// happened, then reset the join order before jumping.
-				// The call to rewindJoinOrder() here will put joinPosition
-				// back to 0.  But that said, we'll then end up incrementing 
-				// joinPosition before we start looking for the next join
-				// order (see below), which means we need to set it to -1
-				// here so that it gets incremented to "0" and then
-				// processing can continue as normal from there.  Note:
-				// we don't need to set reloadBestPlan to true here
-				// because we only get here if we have *not* found a
-				// best plan yet.
-				if (joinPosition > 0)
+				/* If we already assigned at least one position in the
+				 * join order when this happened (i.e. if joinPosition
+				 * is greater than *or equal* to zero; DERBY-1777), then 
+				 * reset the join order before jumping.  The call to
+				 * rewindJoinOrder() here will put joinPosition back
+				 * to 0.  But that said, we'll then end up incrementing
+				 * joinPosition before we start looking for the next
+				 * join order (see below), which means we need to set
+				 * it to -1 here so that it gets incremented to "0" and
+				 * then processing can continue as normal from there.  
+				 * Note: we don't need to set reloadBestPlan to true
+				 * here because we only get here if we have *not* found
+				 * a best plan yet.
+				 */
+				if (joinPosition >= 0)
 				{
 					rewindJoinOrder();
 					joinPosition = -1;
@@ -1674,6 +1677,18 @@ public class OptimizerImpl implements Optimizer
 						getBestAccessPath().getCostEstimate();
 		}
 
+		/* At this point outerCost should be non-null (DERBY-1777).
+		 * Do the assertion here so that we catch it right away;
+		 * otherwise we'd end up with an NPE somewhere further
+		 * down the tree and it'd be harder to figure out where
+		 * it came from.
+		 */
+		if (SanityManager.DEBUG)
+		{
+			SanityManager.ASSERT(outerCost != null,
+				"outerCost is not expected to be null");
+		}
+
 		Optimizable optimizable = optimizableList.getOptimizable(proposedJoinOrder[joinPosition]);
 
 		/*
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out b/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
index 742f4b3d1..a15054d7c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/predicatePushdown.out
@@ -1326,6 +1326,12 @@ ij> create view vz3 (z1, z2, z3, z4) as
     (select c1, c, c2, 28 from tc) xx1
       union select 'i','j','j',i from t2;
 0 rows inserted/updated/deleted
+ij> create view vz4 (z1, z2, z3, z4) as
+  select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
+    (select c1, c, c2, 28 from tc) xx1
+      union select 'i','j','j',i from t2
+      union select c1, c2, c3, c from tc;
+0 rows inserted/updated/deleted
 ij> -- Both sides of predicate reference aggregates.
 select x1.c1 from
   (select count(*) from t1 union select count(*) from t2) x1 (c1),
@@ -1518,6 +1524,22 @@ where x1.z4 = x2.c2;
 Z4         
 -----------
 4          
+ij> -- Same as previous query but with a different nested
+-- view (vz4) that has double-nested unions in it.
+-- This is a test case for DERBY-1777.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz4
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3),
+  (select distinct j from t2 union select j from t1) x2 (c2)
+where x1.z4 = x2.c2;
+Z4         |C2         
+-----------------------
+2          |2          
+4          |4          
+6          |6          
+2          |2          
+4          |4          
 ij> -- Queries with Select->Union->Select chains having differently-
 -- ordered result column lists with some non-column reference
 -- expressions.  In all of these queries we specify LEFT join
@@ -1707,6 +1729,8 @@ ij> drop view vz2;
 0 rows inserted/updated/deleted
 ij> drop view vz3;
 0 rows inserted/updated/deleted
+ij> drop view vz4;
+0 rows inserted/updated/deleted
 ij> drop table tc;
 0 rows inserted/updated/deleted
 ij> -- Now bump up the size of tables T3 and T4 to the point where
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
index aa8216b01..21a618ea3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/predicatePushdown.sql
@@ -107,6 +107,12 @@ create view vz3 (z1, z2, z3, z4) as
     (select c1, c, c2, 28 from tc) xx1
       union select 'i','j','j',i from t2;
 
+create view vz4 (z1, z2, z3, z4) as
+  select distinct xx1.c1, xx1.c2, 'bokibob' bb, xx1.c from
+    (select c1, c, c2, 28 from tc) xx1
+      union select 'i','j','j',i from t2
+      union select c1, c2, c3, c from tc;
+
 -- Both sides of predicate reference aggregates.
 select x1.c1 from
   (select count(*) from t1 union select count(*) from t2) x1 (c1),
@@ -266,6 +272,16 @@ select x1.z4 from
   (select distinct j from t2 union select j from t1) x2 (c2)
 where x1.z4 = x2.c2;
 
+-- Same as previous query but with a different nested
+-- view (vz4) that has double-nested unions in it.
+-- This is a test case for DERBY-1777.
+select x1.z4, x2.c2 from
+  (select z1, z4, z3 from vz4
+    union select '1', i+1, '3' from t1
+  ) x1 (z1, z4, z3),
+  (select distinct j from t2 union select j from t1) x2 (c2)
+where x1.z4 = x2.c2;
+
 -- Queries with Select->Union->Select chains having differently-
 -- ordered result column lists with some non-column reference
 -- expressions.  In all of these queries we specify LEFT join
@@ -379,6 +395,7 @@ on x1.z4 = x2.c2;
 drop view vz;
 drop view vz2;
 drop view vz3;
+drop view vz4;
 drop table tc;
 
 -- Now bump up the size of tables T3 and T4 to the point where
