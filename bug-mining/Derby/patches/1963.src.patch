diff --git a/java/engine/org/apache/derby/iapi/sql/LanguageFactory.java b/java/engine/org/apache/derby/iapi/sql/LanguageFactory.java
index f96265c5c..749601e4c 100644
--- a/java/engine/org/apache/derby/iapi/sql/LanguageFactory.java
+++ b/java/engine/org/apache/derby/iapi/sql/LanguageFactory.java
@@ -54,6 +54,22 @@ public interface LanguageFactory
 	 */
 	ParameterValueSet newParameterValueSet(ClassInspector ci, int numParms, boolean hasReturnParam);
 
+	/**
+	 * Get a new result description from the input result
+	 * description.  Picks only the columns in the column
+	 * array from the inputResultDescription.
+	 *
+ 	 * @param inputResultDescription the input rd
+	 * @param theCols non null array of ints
+	 *
+	 * @return ResultDescription the rd
+	 */
+	public ResultDescription getResultDescription
+	(
+		ResultDescription	inputResultDescription,
+		int[]				theCols
+	);
+
 	/**
 	 * Get a new result description
 	 *
diff --git a/java/engine/org/apache/derby/iapi/sql/ResultDescription.java b/java/engine/org/apache/derby/iapi/sql/ResultDescription.java
index 0612ed768..3ce978f6a 100644
--- a/java/engine/org/apache/derby/iapi/sql/ResultDescription.java
+++ b/java/engine/org/apache/derby/iapi/sql/ResultDescription.java
@@ -66,6 +66,22 @@ public interface ResultDescription
 	 *			column in the ResultSet.
 	 */
 	ResultColumnDescriptor	getColumnDescriptor(int position);
+
+	/**
+	 * Get a new result description that has been truncated
+	 * from input column number.   If the input column is
+	 * 5, then columns 5 to getColumnCount() are removed.
+	 * The new ResultDescription points to the same
+	 * ColumnDescriptors (this method performs a shallow
+	 * copy. The saved JDBC ResultSetMetaData will
+     * not be copied.
+	 *
+	 * @param truncateFrom the starting column to remove,
+	 * 1-based.
+	 *
+	 * @return a new ResultDescription
+	 */
+	public ResultDescription truncateColumns(int truncateFrom);
     
     /**
      * Set the JDBC ResultSetMetaData for this ResultDescription.
diff --git a/java/engine/org/apache/derby/iapi/sql/ResultSet.java b/java/engine/org/apache/derby/iapi/sql/ResultSet.java
index 247377eac..1f9ef8c61 100644
--- a/java/engine/org/apache/derby/iapi/sql/ResultSet.java
+++ b/java/engine/org/apache/derby/iapi/sql/ResultSet.java
@@ -84,6 +84,17 @@ public interface ResultSet
 	 * @return	The number of rows affect by the statement, so far.
 	 */
 	int	modifiedRowCount();
+
+	/**
+	 * Returns a ResultDescription object, which describes the results
+	 * of the statement this ResultSet is in. This will *not* be a
+	 * description of this particular ResultSet, if this is not the
+	 * outermost ResultSet.
+	 *
+	 * @return	A ResultDescription describing the results of the
+	 *		statement.
+	 */
+	ResultDescription	getResultDescription();
 	
 	Activation getActivation();
 
diff --git a/java/engine/org/apache/derby/iapi/sql/dictionary/DataDescriptorGenerator.java b/java/engine/org/apache/derby/iapi/sql/dictionary/DataDescriptorGenerator.java
index 255afa176..2e8e58fef 100644
--- a/java/engine/org/apache/derby/iapi/sql/dictionary/DataDescriptorGenerator.java
+++ b/java/engine/org/apache/derby/iapi/sql/dictionary/DataDescriptorGenerator.java
@@ -21,14 +21,30 @@
 
 package org.apache.derby.iapi.sql.dictionary;
 
-import java.sql.Timestamp;
+import org.apache.derby.iapi.services.monitor.Monitor;
+import org.apache.derby.iapi.error.StandardException;
+
+import org.apache.derby.iapi.sql.dictionary.*;
+
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.sql.depend.Dependent;
+import org.apache.derby.iapi.sql.depend.Provider;
+import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.sql.execute.ConstantAction;
+import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
+import org.apache.derby.iapi.services.uuid.UUIDFactory;
+import org.apache.derby.iapi.services.io.FormatableBitSet;
 
+import org.apache.derby.catalog.AliasInfo;
+import org.apache.derby.catalog.DefaultInfo;
+import org.apache.derby.catalog.Dependable;
+import org.apache.derby.catalog.DependableFinder;
 import org.apache.derby.catalog.ReferencedColumns;
-import org.apache.derby.catalog.UUID;
 import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.services.io.FormatableBitSet;
-import org.apache.derby.iapi.services.uuid.UUIDFactory;
+import org.apache.derby.catalog.UUID;
+import org.apache.derby.catalog.Statistics;
+import java.sql.Timestamp;
+import java.io.InputStream;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
 
 /**
@@ -53,7 +69,6 @@ public class DataDescriptorGenerator
 	public	DataDescriptorGenerator( DataDictionary dataDictionary )
 	{
 		this.dataDictionary = dataDictionary;
-        uuidf = dataDictionary.getUUIDFactory();
 	}
 
 	/**
@@ -399,6 +414,8 @@ public class DataDescriptorGenerator
 	  */
 	protected UUIDFactory getUUIDFactory()
 	{
+		if (uuidf == null)
+			uuidf = Monitor.getMonitor().getUUIDFactory();
 		return uuidf;
 	}
 
diff --git a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
index 186282e87..7948dc15d 100644
--- a/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
+++ b/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
@@ -256,7 +256,7 @@ public abstract class EmbedResultSet extends ConnectionChild
 		}
 
 		// Fill in the column types
-		resultDescription = theResults.getActivation().getResultDescription();
+		resultDescription = theResults.getResultDescription();
 		
 		// Only incur the cost of allocating and maintaining
 		// updated column information if the columns can be updated.
@@ -2220,19 +2220,20 @@ public abstract class EmbedResultSet extends ConnectionChild
       checksBeforeUpdateOrDelete(methodName, columnIndex);
 
       //1)Make sure for updateXXX methods, the column position is not out of range
-      if (columnIndex < 1 || columnIndex > resultDescription.getColumnCount())
+      ResultDescription rd = theResults.getResultDescription();
+      if (columnIndex < 1 || columnIndex > rd.getColumnCount())
         throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,
-					new Integer(columnIndex), String.valueOf(resultDescription.getColumnCount()));
+					new Integer(columnIndex), String.valueOf(rd.getColumnCount()));
 
       //2)Make sure the column corresponds to a column in the base table and it is not a derived column
-      if (resultDescription.getColumnDescriptor(columnIndex).getSourceTableName() == null)
+      if (rd.getColumnDescriptor(columnIndex).getSourceTableName() == null)
         throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE,
 					methodName);
 
       //3)If column not updatable then throw an exception
       if (!getMetaData().isWritable(columnIndex))
         throw Util.generateCsSQLException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR,
-					resultDescription.getColumnDescriptor(columnIndex).getName(),
+					theResults.getResultDescription().getColumnDescriptor(columnIndex).getName(),
 					getCursorName());
 	}
 
@@ -3585,11 +3586,12 @@ public abstract class EmbedResultSet extends ConnectionChild
                         activation.getPreparedStatement().getTargetTable();
                 // got the underlying (schema.)table name
                 insertSQL.append(getFullBaseTableName(targetTable));
+                ResultDescription rd = theResults.getResultDescription();
 
                 insertSQL.append(" (");
                 // in this for loop we are constructing list of column-names 
                 // and values (?) ,... part of the insert sql
-                for (int i=1; i<=resultDescription.getColumnCount(); i++) { 
+                for (int i=1; i<=rd.getColumnCount(); i++) { 
                     if (foundOneColumnAlready) {
                         insertSQL.append(",");
                         valuesSQL.append(",");
@@ -3597,7 +3599,7 @@ public abstract class EmbedResultSet extends ConnectionChild
                     // using quotes around the column name 
                     // to preserve case sensitivity
                     insertSQL.append(IdUtil.normalToDelimited(
-                            resultDescription.getColumnDescriptor(i).getName()));
+                            rd.getColumnDescriptor(i).getName()));
                     if (columnGotUpdated[i-1]) { 
                         valuesSQL.append("?");
                     } else {
@@ -3625,7 +3627,7 @@ public abstract class EmbedResultSet extends ConnectionChild
 
                 // in this for loop we are assigning values for parameters 
                 //in sql constructed earlier VALUES (?, ..)
-                for (int i=1, paramPosition=0; i<=resultDescription.getColumnCount(); i++) { 
+                for (int i=1, paramPosition=0; i<=rd.getColumnCount(); i++) { 
                     // if the column got updated, do following
                     if (columnGotUpdated[i-1]) {  
                         act.getParameterValueSet().
@@ -3682,14 +3684,15 @@ public abstract class EmbedResultSet extends ConnectionChild
             ExecCursorTableReference targetTable = activation.getPreparedStatement().getTargetTable();
             updateWhereCurrentOfSQL.append(getFullBaseTableName(targetTable));//got the underlying (schema.)table name
             updateWhereCurrentOfSQL.append(" SET ");
-      
-            for (int i=1; i<=resultDescription.getColumnCount(); i++) { //in this for loop we are constructing columnname=?,... part of the update sql
+            ResultDescription rd = theResults.getResultDescription();
+
+            for (int i=1; i<=rd.getColumnCount(); i++) { //in this for loop we are constructing columnname=?,... part of the update sql
                 if (columnGotUpdated[i-1]) { //if the column got updated, do following
                     if (foundOneColumnAlready)
                         updateWhereCurrentOfSQL.append(",");
                     //using quotes around the column name to preserve case sensitivity
                     updateWhereCurrentOfSQL.append(IdUtil.normalToDelimited(
-                            resultDescription.getColumnDescriptor(i).getName()) + "=?");
+                            rd.getColumnDescriptor(i).getName()) + "=?");
                     foundOneColumnAlready = true;
                 }
             }
@@ -3705,7 +3708,7 @@ public abstract class EmbedResultSet extends ConnectionChild
             statementContext.setActivation(act);
 
             //in this for loop we are assigning values for parameters in sql constructed earlier with columnname=?,... 
-            for (int i=1, paramPosition=0; i<=resultDescription.getColumnCount(); i++) { 
+            for (int i=1, paramPosition=0; i<=rd.getColumnCount(); i++) { 
                 if (columnGotUpdated[i-1])  //if the column got updated, do following
                     act.getParameterValueSet().getParameterForSet(paramPosition++).setValue(updateRow.getColumn(i));
             }
diff --git a/java/engine/org/apache/derby/impl/sql/GenericLanguageFactory.java b/java/engine/org/apache/derby/impl/sql/GenericLanguageFactory.java
index 75b92745d..6fddcc869 100644
--- a/java/engine/org/apache/derby/impl/sql/GenericLanguageFactory.java
+++ b/java/engine/org/apache/derby/impl/sql/GenericLanguageFactory.java
@@ -99,6 +99,25 @@ public class GenericLanguageFactory implements LanguageFactory, ModuleControl
 		return new GenericParameterValueSet(ci, numParms, hasReturnParam);
 	}
 
+	/**
+	 * Get a new result description from the input result
+	 * description.  Picks only the columns in the column
+	 * array from the inputResultDescription.
+	 *
+ 	 * @param inputResultDescription  the input rd
+	 * @param theCols array of ints, non null
+	 *
+	 * @return ResultDescription the rd
+	 */
+	public ResultDescription getResultDescription
+	(
+		ResultDescription	inputResultDescription,
+		int[]				theCols
+	)
+	{
+		return new GenericResultDescription(inputResultDescription, theCols);
+	} 
+
 	/**
 	 * Get a new result description
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/GenericResultDescription.java b/java/engine/org/apache/derby/impl/sql/GenericResultDescription.java
index d614111d8..96fa24ae5 100644
--- a/java/engine/org/apache/derby/impl/sql/GenericResultDescription.java
+++ b/java/engine/org/apache/derby/impl/sql/GenericResultDescription.java
@@ -79,7 +79,7 @@ public final class GenericResultDescription
      * A map which maps a column name to a column number.
      * Entries only added when accessing columns with the name.
      */
-    private transient Map columnNameMap;
+    private Map columnNameMap;
 	
 	/**
 	 * Niladic constructor for Formatable
@@ -101,6 +101,31 @@ public final class GenericResultDescription
 		this.statementType = statementType;
 	}
 
+	/**
+	 * Build a GenericResultDescription 
+	 *
+	 * @param rd the result description
+	 * @param theCols the columns to take from the input rd
+	 */
+	public GenericResultDescription
+	(
+		ResultDescription	rd, 
+		int[]				theCols
+	) 
+	{
+		if (SanityManager.DEBUG)
+		{
+			SanityManager.ASSERT(theCols != null, "theCols argument to GenericResultDescription is null");
+		}
+
+		this.columns = new ResultColumnDescriptor[theCols.length];
+		for (int i = 0; i < theCols.length; i++)
+		{
+			columns[i] = rd.getColumnDescriptor(theCols[i]);
+		}
+		this.statementType = rd.getStatementType();
+	}
+
 	//
 	// ResultDescription interface
 	//
@@ -131,6 +156,36 @@ public final class GenericResultDescription
 		return columns[position-1];
 	}
 
+	/**
+	 * Get a new result description that has been truncated
+	 * from input column number.   If the input column is
+	 * 5, then columns 5 to getColumnCount() are removed.
+	 * The new ResultDescription points to the same
+	 * ColumnDescriptors (this method performs a shallow
+	 * copy.
+	 *
+	 * @param truncateFrom the starting column to remove
+	 *
+	 * @return a new ResultDescription
+	 */
+	public ResultDescription truncateColumns(int truncateFrom)	
+	{
+		if (SanityManager.DEBUG) 
+		{
+			if (!(truncateFrom > 0 && columns != null))
+			{
+				SanityManager.THROWASSERT("bad truncate value: "+truncateFrom+" is too low");
+			}
+			if (truncateFrom > columns.length)
+			{
+				SanityManager.THROWASSERT("bad truncate value: "+truncateFrom+" is too high");
+			}
+		}
+		ResultColumnDescriptor[] newColumns = new ResultColumnDescriptor[truncateFrom-1];
+		System.arraycopy(columns, 0, newColumns, 0, newColumns.length);
+		return new GenericResultDescription(newColumns, statementType);
+	}
+
 
 	//////////////////////////////////////////////
 	//
diff --git a/java/engine/org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java b/java/engine/org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java
index 1898990d1..302f76534 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java
@@ -30,6 +30,7 @@ import org.apache.derby.iapi.services.i18n.MessageService;
 import org.apache.derby.iapi.services.io.FormatableBitSet;
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.sql.Activation;
+import org.apache.derby.iapi.sql.ResultDescription;
 import org.apache.derby.iapi.sql.ResultSet;
 import org.apache.derby.iapi.sql.Row;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
@@ -87,6 +88,8 @@ implements NoPutResultSet
 	protected final Activation	    activation;
 	private final boolean				statisticsTimingOn;
 
+	ResultDescription resultDescription;
+
 	private transient TransactionController	tc;
 
 	private int[] baseColumnMap;
@@ -96,6 +99,7 @@ implements NoPutResultSet
 	    <BR>
 		Sets beginTime for all children to use to measue constructor time.
 	 *
+	 *  @param  resultDescription the result description. May be null.
 	 *	@param	activation			The activation
 	 *	@param	optimizerEstimatedRowCount	The optimizer's estimate of the
 	 *										total number of rows for this
@@ -103,13 +107,15 @@ implements NoPutResultSet
 	 *	@param	optimizerEstimatedCost		The optimizer's estimated cost for
 	 *										this result set
 	 */
-	BasicNoPutResultSetImpl(Activation activation,
+	BasicNoPutResultSetImpl(ResultDescription resultDescription,
+							Activation activation,
 							double optimizerEstimatedRowCount,
 							double optimizerEstimatedCost)
 	{
 		this.activation = activation;
 		if (statisticsTimingOn = getLanguageConnectionContext().getStatisticsTiming())
 		    beginTime = startExecutionTime = getCurrentTimeMillis();
+		this.resultDescription = resultDescription;
 		this.optimizerEstimatedRowCount = optimizerEstimatedRowCount;
 		this.optimizerEstimatedCost = optimizerEstimatedCost;
 	}
@@ -624,6 +630,13 @@ implements NoPutResultSet
 	 * They are overriden in selected cases.
 	 */
 
+	/**
+     * Returns the description of the table's rows
+	 */
+	public ResultDescription getResultDescription() {
+	    return resultDescription;
+	}
+
 	/**
 	 * Get the execution time in milliseconds.
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DMLVTIResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DMLVTIResultSet.java
index b76d5f596..18668d3f9 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DMLVTIResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DMLVTIResultSet.java
@@ -51,9 +51,19 @@ abstract class DMLVTIResultSet extends DMLWriteResultSet
 	UpdatableVTIConstantAction	constants;
 	TransactionController 	tc;
 
+    ResultDescription 		resultDescription;
 	private int						numOpens;
 	boolean				firstExecute;
 
+	/**
+     * Returns the description of the inserted rows.
+     * REVISIT: Do we want this to return NULL instead?
+	 */
+	public ResultDescription getResultDescription()
+	{
+	    return resultDescription;
+	}
+
     /**
 	 *
 	 * @exception StandardException		Thrown on error
@@ -67,6 +77,8 @@ abstract class DMLVTIResultSet extends DMLWriteResultSet
 		constants = (UpdatableVTIConstantAction) constantAction;
 
         tc = activation.getTransactionController();
+
+        resultDescription = sourceResultSet.getResultDescription();
 	}
 	
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
index 81e9743ae..c651813b6 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java
@@ -53,12 +53,15 @@ import java.util.Enumeration;
  * it should be done based on whether the resultset has dependent resultsets or not.
  *
  */
-class DeleteCascadeResultSet extends DeleteResultSet
+public class DeleteCascadeResultSet extends DeleteResultSet
 {
 
 
 	public ResultSet[] dependentResultSets;
 	private int noDependents =0;
+	private CursorResultSet parentSource;
+	private FKInfo parentFKInfo;
+	private long fkIndexConglomNumber;
 	private String resultSetId;
 	private boolean mainNodeForTable = true;
 	private boolean affectedRows = false;
@@ -68,7 +71,7 @@ class DeleteCascadeResultSet extends DeleteResultSet
      * class interface
 	 * @exception StandardException		Thrown on error
      */
-    DeleteCascadeResultSet
+    public DeleteCascadeResultSet
 	(
 		NoPutResultSet		source,
 		Activation			activation,
@@ -84,8 +87,13 @@ class DeleteCascadeResultSet extends DeleteResultSet
 			  (ConstantAction)activation.getPreparedStatement().getSavedObject(constantActionItem)),
 			  activation);
 
-		if(constantActionItem != -1)
+		ConstantAction passedInConstantAction;
+		if(constantActionItem == -1)
+			passedInConstantAction = activation.getConstantAction(); //root table
+		else
 		{
+			passedInConstantAction = 
+				(ConstantAction) activation.getPreparedStatement().getSavedObject(constantActionItem);
 			resultDescription = constants.resultDescription;
 		}
 		cascadeDelete = true;
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
index 05f708a28..20353420b 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java
@@ -81,6 +81,15 @@ class DeleteResultSet extends DMLWriteResultSet
 	ExecRow		deferredRLRow = null;
 	int	numberOfBaseColumns = 0;
 
+	/**
+     * Returns the description of the deleted rows.
+     * REVISIT: Do we want this to return NULL instead?
+	 */
+	public ResultDescription getResultDescription()
+	{
+	    return resultDescription;
+	}
+
     /*
      * class interface
      *
@@ -121,7 +130,7 @@ class DeleteResultSet extends DMLWriteResultSet
 		noTriggersOrFks = ((fkInfoArray == null) && (triggerInfo == null));
 		baseRowReadList = constants.getBaseRowReadList();
 		if(source != null)
-			resultDescription = activation.getResultDescription();
+			resultDescription = source.getResultDescription();
 		else
 			resultDescription = constants.resultDescription;
 
@@ -291,13 +300,18 @@ class DeleteResultSet extends DMLWriteResultSet
 			if(cascadeDelete)
 			{
 				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
-						 false);
+						(resultDescription != null) ?
+							resultDescription.truncateColumns(rlColumnNumber) :
+							null, false);
 
 
 			}else
 			{
 
-				rowHolder = new TemporaryRowHolderImpl(activation, properties);
+				rowHolder = new TemporaryRowHolderImpl(activation, properties, 
+						(resultDescription != null) ?
+							resultDescription.truncateColumns(rlColumnNumber) :
+							null);
 
 			}
 
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DeleteVTIResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/DeleteVTIResultSet.java
index 9cdf682af..5e1d8e4f5 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DeleteVTIResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DeleteVTIResultSet.java
@@ -100,7 +100,8 @@ class DeleteVTIResultSet extends DMLVTIResultSet
 			activation.clearIndexScanInfo();
             if( null == rowHolder)
                 rowHolder =
-                    new TemporaryRowHolderImpl(activation, new Properties());
+                    new TemporaryRowHolderImpl(activation, new Properties(),
+                                               (ResultDescription) null);
 		}
 
         try
diff --git a/java/engine/org/apache/derby/impl/sql/execute/GenericTriggerExecutor.java b/java/engine/org/apache/derby/impl/sql/execute/GenericTriggerExecutor.java
index fffbac1ec..fd0097e9c 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/GenericTriggerExecutor.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/GenericTriggerExecutor.java
@@ -38,13 +38,17 @@ import org.apache.derby.iapi.reference.SQLState;
  * a trigger.  It is subclassed by row and statement
  * executors.
  */
-abstract class GenericTriggerExecutor
+public abstract class GenericTriggerExecutor
 {
-	final InternalTriggerExecutionContext	tec;
-	final TriggerDescriptor					triggerd;
-	final Activation						activation;
-	final LanguageConnectionContext			lcc;
+	protected InternalTriggerExecutionContext	tec;
+	protected TriggerDescriptor					triggerd;
+	protected Activation						activation;
+	protected LanguageConnectionContext			lcc;
 
+	private	boolean			whenClauseRetrieved;
+	private	boolean			actionRetrieved;
+	private SPSDescriptor	whenClause; 
+	private SPSDescriptor	action;
 
 	private ExecPreparedStatement	ps;
 	private Activation 				spsActivation;
@@ -90,12 +94,22 @@ abstract class GenericTriggerExecutor
 
 	protected SPSDescriptor getWhenClause() throws StandardException
 	{
-		return triggerd.getWhenClauseSPS();
+		if (!whenClauseRetrieved)
+		{
+			whenClauseRetrieved = true;
+			whenClause = triggerd.getWhenClauseSPS();
+		}
+		return whenClause;
 	}
 
 	protected SPSDescriptor getAction() throws StandardException
 	{
-		return triggerd.getActionSPS(lcc);
+		if (!actionRetrieved)
+		{
+			actionRetrieved = true;
+			action = triggerd.getActionSPS(lcc);
+		}
+		return action;
 	}
 
 	/**
diff --git a/java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java b/java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java
index b1c3d3712..cafdcb301 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java
@@ -408,7 +408,8 @@ public class IndexChanger
 			** row holder (the description is needed when the row
 			** holder is going to be handed to users for triggers).
 			*/
-			rowHolder = new TemporaryRowHolderImpl(activation, properties);
+			rowHolder = new TemporaryRowHolderImpl(activation, properties,
+												   (ResultDescription) null);
 		}
 
 		/*
diff --git a/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
index 0dc0d4a28..484a39bc9 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
@@ -98,6 +98,7 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 
 	// divined at run time
 
+    private	ResultDescription 		resultDescription;
 	private RowChanger 				rowChanger;
 
 	private	TransactionController 	tc;
@@ -167,6 +168,15 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 	private boolean					setIdentity;
 	
 
+	/**
+     * Returns the description of the inserted rows.
+     * REVISIT: Do we want this to return NULL instead?
+	 */
+	public ResultDescription getResultDescription()
+	{
+	    return resultDescription;
+	}
+
 	// TargetResultSet interface
 
 	/**
@@ -334,7 +344,7 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 				triggerInfo.hasTrigger(true, true) :
 				false;
 
-        ResultDescription resultDescription = activation.getResultDescription();
+        resultDescription = sourceResultSet.getResultDescription();
 
 		// Is this a bulkInsert or regular insert?
 		String insertMode = constants.getProperty("insertMode");
@@ -944,13 +954,15 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 			/*
 			** If deferred we save a copy of the entire row.
 			*/
-			rowHolder = new TemporaryRowHolderImpl(activation, properties);
+			rowHolder = new TemporaryRowHolderImpl(activation, properties,
+												   resultDescription);
 			rowChanger.setRowHolder(rowHolder);
 		}
 
 		int[] columnIndexes = null;
 		if (firstExecute && activation.getAutoGeneratedKeysResultsetMode())
 		{
+			ResultDescription rd;
 			Properties properties = new Properties();
 			columnIndexes = activation.getAutoGeneratedKeysColumnIndexes();
 
@@ -963,8 +975,9 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 				columnIndexes = generatedColumnPositionsArray();
 			}
 
+			rd = lcc.getLanguageFactory().getResultDescription(resultDescription,columnIndexes);
 			autoGeneratedKeysRowsHolder =
-				new TemporaryRowHolderImpl(activation, properties);
+				new TemporaryRowHolderImpl(activation, properties, rd);
 		}
 
 
@@ -1254,7 +1267,8 @@ class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
 		if (hasBeforeRowTrigger && rowHolder != null)
 		{
 			rowHolder =
-				new TemporaryRowHolderImpl(activation, properties);
+				new TemporaryRowHolderImpl(activation, properties,
+										   resultDescription);
 		}
 
 		// Add any new properties or change the values of any existing properties
diff --git a/java/engine/org/apache/derby/impl/sql/execute/InsertVTIResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/InsertVTIResultSet.java
index 47a568a0e..d22c53d1b 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/InsertVTIResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/InsertVTIResultSet.java
@@ -126,7 +126,8 @@ class InsertVTIResultSet extends DMLVTIResultSet
 			** If deferred we save a copy of the entire row.
 			*/
 			rowHolder =
-				new TemporaryRowHolderImpl(activation, properties);
+				new TemporaryRowHolderImpl(activation, properties,
+										   resultDescription);
 		}
 
 		while ( row != null )
diff --git a/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java b/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
index 2f381639f..0065ab1f5 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
@@ -93,7 +93,8 @@ extends BasicNoPutResultSetImpl
 						double optimizerEstimatedRowCount,
 						double optimizerEstimatedCost)
 	{
-		super(activation,
+		super(null,
+				activation,
 				optimizerEstimatedRowCount,
 				optimizerEstimatedCost);
 
@@ -106,6 +107,13 @@ extends BasicNoPutResultSetImpl
 
 	// NoPutResultSet interface
 
+	/**
+     * Returns the description of the table's rows
+	 */
+	public ResultDescription getResultDescription() {
+	    return activation.getResultDescription();
+	}
+
 	/**
 		Return my cursor name for JDBC. Can be null.
 	*/
diff --git a/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java b/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
index 27aa0d72f..247126bd4 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
@@ -130,6 +130,14 @@ abstract class NoRowsResultSetImpl implements ResultSet
 	 * Returns zero.
 	 */
 	public int	modifiedRowCount() { return 0; }
+
+	/**
+	 * Returns null.
+	 */
+	public ResultDescription	getResultDescription()
+	{
+	    return (ResultDescription)null;
+	}
 	
 	public final Activation getActivation()
 	{
diff --git a/java/engine/org/apache/derby/impl/sql/execute/RowTriggerExecutor.java b/java/engine/org/apache/derby/impl/sql/execute/RowTriggerExecutor.java
index 80fe64abd..0b64acd62 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/RowTriggerExecutor.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/RowTriggerExecutor.java
@@ -33,7 +33,7 @@ import org.apache.derby.iapi.sql.Activation;
  * a row trigger.  It is instantiated at execution time.
  * There is one per row trigger.
  */
-class RowTriggerExecutor extends GenericTriggerExecutor
+public class RowTriggerExecutor extends GenericTriggerExecutor
 {
 	/**
 	 * Constructor
diff --git a/java/engine/org/apache/derby/impl/sql/execute/StatementTriggerExecutor.java b/java/engine/org/apache/derby/impl/sql/execute/StatementTriggerExecutor.java
index 5da9ca6de..32e169d0f 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/StatementTriggerExecutor.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/StatementTriggerExecutor.java
@@ -33,7 +33,7 @@ import org.apache.derby.iapi.sql.Activation;
  * a statement trigger.  It is instantiated at execution
  * time.  There is one per statement trigger.
  */
-class StatementTriggerExecutor extends GenericTriggerExecutor
+public class StatementTriggerExecutor extends GenericTriggerExecutor
 {
 	/**
 	 * Constructor
diff --git a/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java b/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java
index 39846841c..b9ee9330a 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java
@@ -27,6 +27,7 @@ import org.apache.derby.iapi.sql.execute.CursorResultSet;
 import org.apache.derby.iapi.sql.execute.ExecRow;
 import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
 import org.apache.derby.iapi.sql.Activation;
+import org.apache.derby.iapi.sql.ResultDescription;
 import org.apache.derby.iapi.store.access.ConglomerateController;
 import org.apache.derby.iapi.store.access.ScanController;
 import org.apache.derby.iapi.store.access.TransactionController;
@@ -68,7 +69,7 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 	private ConglomerateController	cc;
 	private Properties				properties;
 	private ScanController			scan;
-
+	private	ResultDescription		resultDescription;
 	/** Activation object with local state information. */
 	Activation						activation;
 
@@ -99,14 +100,17 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 	 * @param activation the activation
 	 * @param properties the properties of the original table.  Used
 	 *		to help the store use optimal page size, etc.
+	 * @param resultDescription the result description.  Relevant for the getResultDescription
+	 * 		call on the result set returned by getResultSet.  May be null
 	 */
-	TemporaryRowHolderImpl
+	public TemporaryRowHolderImpl
 	(
 		Activation				activation, 
-		Properties 				properties
+		Properties 				properties, 
+		ResultDescription		resultDescription
 	) 
 	{
-		this(activation, properties,
+		this(activation, properties, resultDescription,
 			 DEFAULT_OVERFLOWTHRESHOLD, false, false);
 	}
 	
@@ -117,16 +121,19 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 	 * @param activation the activation
 	 * @param properties the properties of the original table.  Used
 	 *		to help the store use optimal page size, etc.
+	 * @param resultDescription the result description.  Relevant for the getResultDescription
+	 * 		call on the result set returned by getResultSet.  May be null
 	 * @param isUniqueStream - true , if it has to be temporary row holder unique stream
 	 */
-	TemporaryRowHolderImpl
+	public TemporaryRowHolderImpl
 	(
 		Activation				activation, 
 		Properties 				properties, 
+		ResultDescription		resultDescription,
 		boolean                 isUniqueStream
 	) 
 	{
-		this(activation, properties, 1, isUniqueStream,
+		this(activation, properties, resultDescription, 1, isUniqueStream,
 			 false);
 	}
 
@@ -137,14 +144,17 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 	 * @param activation the activation
 	 * @param properties the properties of the original table.  Used
 	 *		to help the store use optimal page size, etc.
+	 * @param resultDescription the result description.  Relevant for the getResultDescription
+	 * 		call on the result set returned by getResultSet.  May be null
 	 * @param overflowToConglomThreshold on an attempt to insert
 	 * 		this number of rows, the rows will be put
  	 *		into a temporary conglomerate.
 	 */
-	TemporaryRowHolderImpl
+	public TemporaryRowHolderImpl
 	(
 		Activation			 	activation, 
 		Properties				properties,
+		ResultDescription		resultDescription,
 		int 					overflowToConglomThreshold,
 		boolean                 isUniqueStream,
 		boolean					isVirtualMemHeap
@@ -163,6 +173,7 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 
 		this.activation = activation;
 		this.properties = properties;
+		this.resultDescription = resultDescription;
 		this.isUniqueStream = isUniqueStream;
 		this.isVirtualMemHeap = isVirtualMemHeap;
 		rowArray = new ExecRow[overflowToConglomThreshold];
@@ -473,12 +484,12 @@ class TemporaryRowHolderImpl implements TemporaryRowHolder
 		if(isUniqueStream)
 		{
 			return new TemporaryRowHolderResultSet(tc, rowArray,
-												   isVirtualMemHeap,
+												   resultDescription, isVirtualMemHeap,
 												   true, positionIndexConglomId, this);
 		}
 		else
 		{
-			return new TemporaryRowHolderResultSet(tc, rowArray, isVirtualMemHeap, this);
+			return new TemporaryRowHolderResultSet(tc, rowArray, resultDescription, isVirtualMemHeap, this);
 
 		}
 	}
diff --git a/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java
index ca4c1d7e0..5dc32f1df 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java
@@ -58,6 +58,7 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 	private boolean 				isOpen;
 	private boolean 				finished;
 	private ExecRow					currentRow;
+	private ResultDescription		resultDescription;
 	private boolean                 isAppendable = false;
 	private long                    positionIndexConglomId;
 	private boolean 				isVirtualMemHeap;
@@ -73,17 +74,19 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 	 *
 	 * @param tc the xact controller
 	 * @param rowArray the row array
+	 * @param resultDescription value returned by getResultDescription()
 	 */
-	TemporaryRowHolderResultSet
+	public TemporaryRowHolderResultSet
 	(
 		TransactionController		tc,
 		ExecRow[]					rowArray,
+		ResultDescription			resultDescription,
 		boolean						isVirtualMemHeap,
 		TemporaryRowHolderImpl		holder
    	)
 	{
 
-		this(tc, rowArray, isVirtualMemHeap, false, 0, holder);
+		this(tc, rowArray, resultDescription, isVirtualMemHeap, false, 0, holder);
 
 
 	}
@@ -93,14 +96,16 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 	 *
 	 * @param tc the xact controller
 	 * @param rowArray the row array
+	 * @param resultDescription value returned by getResultDescription()
 	 * @param isAppendable true,if we can insert rows after this result is created
 	 * @param positionIndexConglomId conglomId of the index which has order rows
 	 *                               are inserted and their row location 
 	 */
-	TemporaryRowHolderResultSet
+	public TemporaryRowHolderResultSet
 	(
 		TransactionController		tc,
 		ExecRow[]					rowArray,
+		ResultDescription			resultDescription,
 		boolean						isVirtualMemHeap,
 		boolean                     isAppendable,
 		long                        positionIndexConglomId,
@@ -109,6 +114,7 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 	{
 		this.tc = tc;
 		this.rowArray = rowArray;
+		this.resultDescription = resultDescription;
 		this.numRowsOut = 0;
 		isOpen = false;
 		finished = false;
@@ -178,14 +184,15 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 	 *
 	 * @exception StandardException on error
 	 */
-	static TemporaryRowHolderResultSet getNewRSOnCurrentRow
+	public static TemporaryRowHolderResultSet getNewRSOnCurrentRow
 	(
 		Activation				activation,
 		CursorResultSet 		rs
 	) throws StandardException
 	{
 		TemporaryRowHolderImpl singleRow =
-			new TemporaryRowHolderImpl(activation, null);
+			new TemporaryRowHolderImpl(activation, null,
+									   rs.getResultDescription());
 		singleRow.insert(rs.getCurrentRow());
 		return (TemporaryRowHolderResultSet) singleRow.getResultSet();
 	}
@@ -593,6 +600,20 @@ class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cl
 
 	public int modifiedRowCount() { return 0;};
 
+	/**
+	 * Returns a ResultDescription object, which describes the results
+	 * of the statement this ResultSet is in. This will *not* be a
+	 * description of this particular ResultSet, if this is not the
+	 * outermost ResultSet.
+	 *
+	 * @return	A ResultDescription describing the results of the
+	 *		statement.
+	 */
+	public ResultDescription	getResultDescription()
+	{
+		return resultDescription;
+	}
+
 	/**
 	 * Tells the system that there will be calls to getNextRow().
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/execute/TriggerEventActivator.java b/java/engine/org/apache/derby/impl/sql/execute/TriggerEventActivator.java
index 33d332e19..61219dd72 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/TriggerEventActivator.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/TriggerEventActivator.java
@@ -21,26 +21,34 @@
 
 package org.apache.derby.impl.sql.execute;
 
-import java.util.Vector;
-
-import org.apache.derby.catalog.UUID;
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.jdbc.ConnectionContext;
 import org.apache.derby.iapi.services.sanity.SanityManager;
-import org.apache.derby.iapi.sql.Activation;
-import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
-import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
+import org.apache.derby.iapi.error.StandardException;
+
 import org.apache.derby.iapi.sql.execute.CursorResultSet;
 import org.apache.derby.iapi.sql.execute.NoPutResultSet;
+import org.apache.derby.iapi.sql.execute.ExecRow; 
+import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
+import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
+
+import org.apache.derby.iapi.sql.Activation;
+
 import org.apache.derby.iapi.store.access.TransactionController;
+import org.apache.derby.impl.sql.execute.AutoincrementCounter;
+import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.jdbc.ConnectionContext;
+import org.apache.derby.catalog.UUID;
+
+import java.util.Vector;
+import java.sql.SQLException;
 
 /**
  * Responsible for firing a trigger or set of triggers
  * based on an event.
  */
-class TriggerEventActivator
+public class TriggerEventActivator
 {
 	private LanguageConnectionContext		lcc; 
+	private TransactionController 			tc; 
 	private TriggerInfo 					triggerInfo; 
 	private InternalTriggerExecutionContext	tec;
 	private	GenericTriggerExecutor[][]		executors;
@@ -64,7 +72,7 @@ class TriggerEventActivator
 	 *
 	 * @exception StandardException on error
 	 */
-	TriggerEventActivator
+	public TriggerEventActivator
 	(
 		LanguageConnectionContext	lcc, 
 		TransactionController 		tc, 
@@ -84,6 +92,7 @@ class TriggerEventActivator
 		tableName = triggerInfo.triggerArray[0].getTableDescriptor().getQualifiedName();
 	
 		this.lcc = lcc;
+		this.tc = tc;
 		this.activation = activation;
 		this.tableId = tableId;
 		this.dmlType = dmlType;
@@ -218,7 +227,7 @@ class TriggerEventActivator
 	 *
  	 * @exception StandardException on error
 	 */
-	void notifyEvent
+	public void notifyEvent
 	(
 		TriggerEvent 		event,
 		CursorResultSet		brs,
@@ -281,7 +290,7 @@ class TriggerEventActivator
 	 *
 	 * @exception StandardException on unexpected error
 	 */
-	void cleanup() throws StandardException
+	public void cleanup() throws StandardException
 	{
 		if (tec != null)
 		{
diff --git a/java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java b/java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java
index eb97b3d46..5c4b29e8e 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java
@@ -129,6 +129,21 @@ public final class TriggerInfo implements Formatable
 		}
 	}
 
+	/*
+	 * private constructor for TriggerInfo
+	 */
+	private TriggerInfo
+	(
+		TriggerDescriptor[]		triggers,
+		int[]					changedColsIds,
+		String[]				changedColsNames
+	) 
+	{
+		this.columnIds = changedColsIds;
+		this.columnNames = changedColsNames;
+		this.triggerArray = triggers;
+	}
+
 	/**
 	 * Do we have a trigger or triggers that meet
 	 * the criteria
diff --git a/java/engine/org/apache/derby/impl/sql/execute/UnionResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/UnionResultSet.java
index 4ed519d0f..fefe1d690 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/UnionResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/UnionResultSet.java
@@ -89,6 +89,15 @@ class UnionResultSet extends NoPutResultSetImpl
 	// ResultSet interface (leftover from NoPutResultSet)
 	//
 
+	/**
+     * Returns the description of the first source.
+     * Assumes the compiler ensured both sources
+     * had the same description.
+	 */
+	public ResultDescription getResultDescription() {
+	    return source1.getResultDescription();
+	}
+
 	/**
      * open the first source.
  	 *	@exception StandardException thrown on failure
diff --git a/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
index 4487d71f3..b2ea548cf 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java
@@ -34,6 +34,7 @@ import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.sql.Activation;
 import org.apache.derby.iapi.sql.ResultDescription;
 import org.apache.derby.iapi.sql.ResultSet;
+import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
 import org.apache.derby.iapi.sql.execute.ConstantAction;
 import org.apache.derby.iapi.sql.execute.CursorResultSet;
 import org.apache.derby.iapi.sql.execute.ExecRow;
@@ -61,6 +62,7 @@ class UpdateResultSet extends DMLWriteResultSet
 	private ExecRow 					deferredSparseRow;
 	UpdateConstantAction		constants;
 	
+    private ResultDescription 		resultDescription;
 	private NoPutResultSet			source;
 	NoPutResultSet			savedSource;
 	private RowChanger				rowChanger;
@@ -92,11 +94,20 @@ class UpdateResultSet extends DMLWriteResultSet
 	private ExecRow					deferredTempRow;
 	private ExecRow					deferredBaseRow;
 	private ExecRow					oldDeletedRow;
+	private ResultDescription		triggerResultDescription;
 
 	int lockMode;
 	boolean deferred;
 	boolean beforeUpdateCopyRequired = false;
 
+	/**
+     * Returns the description of the updated rows.
+     * REVISIT: Do we want this to return NULL instead?
+	 */
+	public ResultDescription getResultDescription()
+	{
+	    return resultDescription;
+	}
 
     /*
      * class interface
@@ -180,9 +191,8 @@ class UpdateResultSet extends DMLWriteResultSet
 		heapConglom = constants.conglomId;
 
 		baseRowReadList = constants.getBaseRowReadList();
-        ResultDescription resultDescription;
 		if(passedInRsd ==null)
-			resultDescription = activation.getResultDescription();
+			resultDescription = source.getResultDescription();
 		else
 			resultDescription = passedInRsd;
 		/*
@@ -370,6 +380,9 @@ class UpdateResultSet extends DMLWriteResultSet
 			{
 				deferredTempRow = RowUtil.getEmptyValueRow(numberOfBaseColumns+1, lcc);
 				oldDeletedRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
+				triggerResultDescription = (resultDescription != null) ?
+									resultDescription.truncateColumns(numberOfBaseColumns+1) :
+									null;
 			}
 
 			Properties properties = new Properties();
@@ -378,10 +391,12 @@ class UpdateResultSet extends DMLWriteResultSet
 			rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
 			if(beforeUpdateCopyRequired){
 				deletedRowHolder =
-					new TemporaryRowHolderImpl(activation, properties);
+					new TemporaryRowHolderImpl(activation, properties,
+											   triggerResultDescription);
 			}
 			insertedRowHolder =
-				new TemporaryRowHolderImpl(activation, properties);
+				new TemporaryRowHolderImpl(activation, properties,
+										   triggerResultDescription);
 
 			rowChanger.setRowHolder(insertedRowHolder);
 		}
@@ -730,7 +745,7 @@ class UpdateResultSet extends DMLWriteResultSet
 						// in-memory heap grows), hopefully we never spill temp table to disk.
 
 						tableScan.futureForUpdateRows = new TemporaryRowHolderImpl
-							(activation, null, 100, false, true);
+							(activation, null, null, 100, false, true);
 					}
 
 					rlRow.setColumn(1, rowLoc);
diff --git a/java/engine/org/apache/derby/impl/sql/execute/UpdateVTIResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/UpdateVTIResultSet.java
index adb275422..8959d7c02 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/UpdateVTIResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/UpdateVTIResultSet.java
@@ -96,7 +96,8 @@ class UpdateVTIResultSet extends DMLVTIResultSet
 			** If deferred we save a copy of the entire row.
 			*/
 			rowHolder =
-				new TemporaryRowHolderImpl(activation, properties);
+				new TemporaryRowHolderImpl(activation, properties,
+										   resultDescription);
 		}
 
         try
diff --git a/java/engine/org/apache/derby/impl/sql/execute/WriteCursorConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/WriteCursorConstantAction.java
index e42e6d7f3..504b2f22c 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/WriteCursorConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/WriteCursorConstantAction.java
@@ -63,14 +63,12 @@ abstract	class WriteCursorConstantAction implements ConstantAction, Formatable
 	**
 	**	This class implements Formatable. But it is NOT used
  	**	across either major or minor releases.  It is only
-	** 	written persistently in stored prepared statements.
-    *   SO, IT IS OK TO CHANGE ITS read/writeExternal.
+	** 	written persistently in stored prepared statements, 
+	**	not in the replication stage.  SO, IT IS OK TO CHANGE
+	**	ITS read/writeExternal.
 	**
 	********************************************************/
 
-    /**
-     * Heap conglomerate identifier.
-     */
 	long						conglomId;
 	StaticCompiledOpenConglomInfo heapSCOCI;
 	IndexRowGenerator[] 		irgs;
