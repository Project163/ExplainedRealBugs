diff --git a/java/client/org/apache/derby/client/am/ResultSet.java b/java/client/org/apache/derby/client/am/ResultSet.java
index 9df8e7452..d917ad3ba 100644
--- a/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/java/client/org/apache/derby/client/am/ResultSet.java
@@ -3835,7 +3835,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
         long rowToFetch = getRowUncast() - absolutePosition_;
 
         // if rowToFetch is zero, already positioned on the current row
-        if (rowToFetch != 0 || cursorUnpositionedOnServer_) {
+        if (rowToFetch != 0) {
             writePositioningFetch_((generatedSection_ == null) ? statement_.section_ : generatedSection_,
                     scrollOrientation_relative__,
                     rowToFetch);
diff --git a/java/engine/org/apache/derby/iapi/sql/ResultSet.java b/java/engine/org/apache/derby/iapi/sql/ResultSet.java
index be0262fc4..97f4ecdc0 100644
--- a/java/engine/org/apache/derby/iapi/sql/ResultSet.java
+++ b/java/engine/org/apache/derby/iapi/sql/ResultSet.java
@@ -210,6 +210,18 @@ public interface ResultSet
 	 */
 	ExecRow	setAfterLastRow() throws StandardException;
 
+	/**
+	 * Clear the current row. The cursor keeps it current position,
+	 * however it cannot be used for positioned updates or deletes
+	 * until a fetch is done.
+	 * This is done after a commit on holdable
+	 * result sets.
+	 * A fetch is achieved by calling one of the positioning 
+	 * methods: getLastRow(), getNextRow(), getPreviousRow(), 
+	 * getFirstRow(), getRelativeRow(..) or getAbsoluteRow(..).
+	 */
+	void clearCurrentRow();
+	 
     /**
 		Determine if the result set is at one of the positions
 		according to the constants above (ISBEFOREFIRST etc).
diff --git a/java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java b/java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java
index d1d31f5a7..6b46a044b 100644
--- a/java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java
+++ b/java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java
@@ -149,12 +149,6 @@ public interface NoPutResultSet extends ResultSet, RowLocationRetRowSource
 	 */
 	public void setCurrentRow(ExecRow row);
 
-	/**
-	 * Clear the current row
-	 *
-	 */
-	public void clearCurrentRow();
-
 	/**
 	 * Do we need to relock the row when going to the heap.
 	 *
diff --git a/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java b/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
index 7f2bffa8d..04c3ab377 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
@@ -361,12 +361,15 @@ public abstract class BaseActivation implements CursorActivation, GeneratedByteC
 	public void reset() throws StandardException
 	{
 		// if resultset holdability after commit is false, close it
-		if (resultSet != null && (!resultSetHoldability || !resultSet.returnsRows())) {
-			// would really like to check if it is open,
-			// this is as close as we can approximate that.
-			resultSet.close();
-			resultSet = null; // forget about it, prepare for next exec.
-
+		if (resultSet != null) {
+			if (!resultSetHoldability || !resultSet.returnsRows()) {			
+				// would really like to check if it is open,
+				// this is as close as we can approximate that.
+				resultSet.close();
+				resultSet = null; // forget about it, prepare for next exec.
+			} else if (resultSet.returnsRows()) {
+				resultSet.clearCurrentRow();
+			}
 		}
 		updateHeapCC = null;
 		// REMIND: do we need to get them to stop input as well?
diff --git a/java/engine/org/apache/derby/impl/sql/execute/CurrentOfResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/CurrentOfResultSet.java
index 4dda01614..351f960a3 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/CurrentOfResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/CurrentOfResultSet.java
@@ -114,7 +114,7 @@ public class CurrentOfResultSet extends NoPutResultSetImpl
 
 				// requalify the current row
 				if (cursorRow == null) {
-				     throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW, cursorName);
+					throw StandardException.newException(SQLState.NO_CURRENT_ROW);
 				}
 				// we know it will be requested, may as well get it now.
 				rowLocation = cursor.getRowLocation();
diff --git a/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java b/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
index 0fe9c33f0..b09aabea9 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java
@@ -358,6 +358,7 @@ extends BasicNoPutResultSetImpl
 	 */
 	public final void clearCurrentRow()
 	{
+		currentRow = null;
 		activation.clearCurrentRow(resultSetNumber);
 	}
 
diff --git a/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java b/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
index 98f1038c7..644f15ab2 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java
@@ -313,6 +313,16 @@ abstract class NoRowsResultSetImpl implements ResultSet
 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "afterLast");
 	}
 
+	/**
+	 * Clear the current row. This is done after a commit on holdable
+	 * result sets.
+	 * This is a no-op on result set which do not provide rows.
+	 */
+	public final void clearCurrentRow() 
+	{
+		
+	}
+
     /**
      * Determine if the cursor is before the first row in the result 
      * set.   
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/forupdate.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/forupdate.out
index 904b0bf77..d2374c0b3 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/forupdate.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/forupdate.out
@@ -171,7 +171,7 @@ get cursor c5 as 'select i as v from t1 for update of v';
 ij> -- i (renamed v in the select) is an integer; but v is still the
 ----- varchar column, so this compiles (gets a no current row error):
 update t1 set v='hello' where current of c5;
-ERROR XCL08: Cursor 'SQL_CURSH200C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> close c5;
 ij> -- . include duplicate column name
 ----- expect an error:
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/holdCursorIJ.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/holdCursorIJ.out
index 28bf6a074..660da8205 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/holdCursorIJ.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/holdCursorIJ.out
@@ -175,7 +175,7 @@ ij> -- sixth test - try positioned update with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 update t1 set c12=12 where current of jdk4;
-ERROR XCL08: Cursor 'SQL_CURSH200C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11 |C12        
 -----
@@ -225,7 +225,7 @@ ij> -- seventh test - try positioned delete with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 delete from t1 where current of jdk4;
-ERROR XCL08: Cursor 'SQL_CURSH200C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11 |C12        
 -----
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
index 9f5e61bc2..04675dc7c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNet/updatableResultSet.out
@@ -61,8 +61,8 @@ Got expected exception This method cannot be invoked while the cursor is on the
 Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row
 Make sure that we got CONCUR_UPDATABLE? true
 Now attempt a deleteRow without first doing next on the resultset.
-SQL State : XCL08
-Got expected exception Cursor 'SQL_CURSH200C7' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Now attempt a updateRow without first doing next on the resultset.
 In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
 In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out
index f336e8091..e69cd88bd 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/SURTest_ij.out
@@ -56,7 +56,7 @@ ij(CONNECTION1)> after last sc1;
 No current row
 ij(CONNECTION1)> -- update when positioned after last should cause an error
 update t1 set c2 = c1 + 20 where current of sc1;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> first sc1;
 C1 |C2         
 -----
@@ -68,7 +68,7 @@ ij(CONNECTION1)> before first sc1;
 No current row
 ij(CONNECTION1)> -- update when positioned before first should cause an error
 update t1 set c2 = c1 + 20 where current of sc1;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> close sc1;
 ij(CONNECTION1)> commit;
 ij(CONNECTION1)> -- check that row where correctly updated
@@ -134,7 +134,7 @@ ij(CONNECTION1)> after last sc1;
 No current row
 ij(CONNECTION1)> -- delete when positioned after last should cause an error
 delete from t1 where current of sc1;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> first sc1;
 C1 |C2         
 -----
@@ -146,7 +146,7 @@ ij(CONNECTION1)> before first sc1;
 No current row
 ij(CONNECTION1)> -- delete when positioned before first should cause an error
 delete from t1 where current of sc1;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> close sc1;
 ij(CONNECTION1)> commit;
 ij(CONNECTION1)> -- check that row where correctly updated
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/forupdate.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/forupdate.out
index 4a8035281..8ad61430f 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/forupdate.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/forupdate.out
@@ -171,7 +171,7 @@ get cursor c5 as 'select i as v from t1 for update of v';
 ij> -- i (renamed v in the select) is an integer; but v is still the
 ----- varchar column, so this compiles (gets a no current row error):
 update t1 set v='hello' where current of c5;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> close c5;
 ij> -- . include duplicate column name
 ----- expect an error:
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/holdCursorIJ.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/holdCursorIJ.out
index d2d4e5f2a..673a9c579 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/holdCursorIJ.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/holdCursorIJ.out
@@ -175,7 +175,7 @@ ij> -- sixth test - try positioned update with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 update t1 set c12=12 where current of jdk4;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11 |C12        
 -----
@@ -225,7 +225,7 @@ ij> -- seventh test - try positioned delete with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 delete from t1 where current of jdk4;
-ERROR XCL08: Cursor 'SQL_CURLH000C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11 |C12        
 -----
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
index 36f6dd06f..b858d0db0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
@@ -45,8 +45,8 @@ Got expected exception 'updateRow' not allowed because the ResultSet is not an u
 Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row
 Make sure that we got CONCUR_UPDATABLE? true
 Now attempt a deleteRow without first doing next on the resultset.
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Now attempt a updateRow without first doing next on the resultset.
 updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
 SQL State : XJ121
@@ -111,8 +111,8 @@ Since after deleteRow(), in embedded mode and Network Server mode using Derby Ne
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test1b - request updatable resultset for forward only type resultset
@@ -137,8 +137,8 @@ column 2 on this row before positioned delete aa
 column 1 on this deleted row is 234
 column 2 on this deleted row is aa                  
 doing positioned delete again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to do positioned delete on the current row now
 Positive Test1d - updatable resultset to do positioned update
@@ -176,8 +176,8 @@ Since after deleteRow(), ResultSet is positioned before the next row, getXXX wil
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test3b - use prepared statement with concur updatable status to test updateXXX
@@ -207,8 +207,8 @@ Since after deleteRow(), ResultSet is positioned before the next row, getXXX wil
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test5 - donot have to select primary key to get an updatable resultset
@@ -311,8 +311,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
index bbce30732..9a501a4ac 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
@@ -45,8 +45,8 @@ Got expected exception 'updateRow' not allowed because the ResultSet is not an u
 Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row
 Make sure that we got CONCUR_UPDATABLE? true
 Now attempt a deleteRow without first doing next on the resultset.
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Now attempt a updateRow without first doing next on the resultset.
 updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX
 SQL State : XJ121
@@ -111,8 +111,8 @@ Since after deleteRow(), in embedded mode and Network Server mode using Derby Ne
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test1b - request updatable resultset for forward only type resultset
@@ -137,8 +137,8 @@ column 2 on this row before positioned delete aa
 column 1 on this deleted row is 234
 column 2 on this deleted row is aa                  
 doing positioned delete again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to do positioned delete on the current row now
 Positive Test1d - updatable resultset to do positioned update
@@ -176,8 +176,8 @@ Since after deleteRow(), ResultSet is positioned before the next row, getXXX wil
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test3b - use prepared statement with concur updatable status to test updateXXX
@@ -207,8 +207,8 @@ Since after deleteRow(), ResultSet is positioned before the next row, getXXX wil
 SQL State : XJ121
 Got expected exception Invalid operation at current cursor position.
 calling deleteRow again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to deletRow() on the current row now
 Positive Test5 - donot have to select primary key to get an updatable resultset
@@ -311,8 +311,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor '<xxx-cursor-name-xxx>' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out b/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out
index 22d004149..418cc2939 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/SURTest_ij.out
@@ -57,7 +57,7 @@ ij(CONNECTION1)> after last sc1;
 No current row
 ij(CONNECTION1)> -- update when positioned after last should cause an error
 update t1 set c2 = c1 + 20 where current of sc1;
-ERROR XCL08: Cursor 'SC1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> first sc1;
 C1         |C2         
 -----------------------
@@ -69,7 +69,7 @@ ij(CONNECTION1)> before first sc1;
 No current row
 ij(CONNECTION1)> -- update when positioned before first should cause an error
 update t1 set c2 = c1 + 20 where current of sc1;
-ERROR XCL08: Cursor 'SC1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> close sc1;
 ij(CONNECTION1)> commit;
 ij(CONNECTION1)> -- check that row where correctly updated
@@ -135,7 +135,7 @@ ij(CONNECTION1)> after last sc1;
 No current row
 ij(CONNECTION1)> -- delete when positioned after last should cause an error
 delete from t1 where current of sc1;
-ERROR XCL08: Cursor 'SC1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> first sc1;
 C1         |C2         
 -----------------------
@@ -147,7 +147,7 @@ ij(CONNECTION1)> before first sc1;
 No current row
 ij(CONNECTION1)> -- delete when positioned before first should cause an error
 delete from t1 where current of sc1;
-ERROR XCL08: Cursor 'SC1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij(CONNECTION1)> close sc1;
 ij(CONNECTION1)> commit;
 ij(CONNECTION1)> -- check that row where correctly updated
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/currentof.out b/java/testing/org/apache/derbyTesting/functionTests/master/currentof.out
index b60802125..22a31bf0c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/currentof.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/currentof.out
@@ -13,7 +13,7 @@ Row: 3,you are the one
 Have 4 rows in table at start
 ERROR 42X28: Delete table 'S' is not target of cursor 'SQLCUR0'.
 PASS: delete table and cursor table mismatch caught
-ERROR XCL08: Cursor 'SQLCUR0' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 PASS: Attempt to delete cursor before first row caught
 PASS: expected and got true
 Row: 1956,hello world                                       
@@ -26,7 +26,7 @@ PASS: expected and got 1 rowon stmt: <delete after skipping>
 PASS: expected and got true
 Row: 3,you are the one                                   
 PASS: expected and got false
-ERROR XCL08: Cursor 'SQLCUR0' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 PASS: Attempt to delete cursor past last row caught
 ERROR XCL07: Cursor 'SQLCUR0' is closed. Verify that autocommit is OFF.
 PASS: Attempt to delete closed cursor caught
@@ -59,7 +59,7 @@ PASS: update of values clause cursor caught
 PASS: update of subquery cursor caught
 ERROR 42X29: Update table 'S' is not the target of cursor 'SQLCUR2'.
 PASS: update table and cursor table mismatch caught
-ERROR XCL08: Cursor 'SQLCUR2' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 PASS: Attempt to update cursor before first row caught
 PASS: expected and got true
 Row: 1956,hello world                                       
@@ -73,7 +73,7 @@ PASS: expected and got 1 rowon stmt: update after skipping
 PASS: expected and got true
 Row: 3,you are the one                                   
 PASS: expected and got false
-ERROR XCL08: Cursor 'SQLCUR2' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 PASS: Attempt to update cursor past last row caught
 ERROR 42X30: Cursor 'SQLCUR2' not found. Verify that autocommit is OFF.
 PASS: Attempt to update closed cursor caught
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/forupdate.out b/java/testing/org/apache/derbyTesting/functionTests/master/forupdate.out
index b51a3841c..8a29d5b27 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/forupdate.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/forupdate.out
@@ -171,7 +171,7 @@ get cursor c5 as 'select i as v from t1 for update of v';
 ij> -- i (renamed v in the select) is an integer; but v is still the
 -- varchar column, so this compiles (gets a no current row error):
 update t1 set v='hello' where current of c5;
-ERROR XCL08: Cursor 'C5' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> close c5;
 ij> -- . include duplicate column name
 -- expect an error:
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/holdCursorIJ.out b/java/testing/org/apache/derbyTesting/functionTests/master/holdCursorIJ.out
index 82683a809..af54b2f9e 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/holdCursorIJ.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/holdCursorIJ.out
@@ -175,7 +175,7 @@ ij> -- sixth test - try positioned update with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 update t1 set c12=12 where current of jdk4;
-ERROR XCL08: Cursor 'JDK4' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11        |C12        
 -----------------------
@@ -225,7 +225,7 @@ ij> -- seventh test - try positioned delete with hold cursor
 get with hold cursor jdk4 as 'SELECT * FROM t1 FOR UPDATE';
 ij> -- following should give error because cursor is not positioned on any row
 delete from t1 where current of jdk4;
-ERROR XCL08: Cursor 'JDK4' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 C11        |C12        
 -----------------------
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/j9_13/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/j9_13/updatableResultSet.out
index a0a940340..f278bedae 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/j9_13/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/j9_13/updatableResultSet.out
@@ -303,8 +303,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR19' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/j9_foundation/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/j9_foundation/updatableResultSet.out
index 4399edf6b..e1495b0c1 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/j9_foundation/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/j9_foundation/updatableResultSet.out
@@ -137,8 +137,8 @@ column 2 on this row before positioned delete aa
 column 1 on this deleted row is 234
 column 2 on this deleted row is aa                  
 doing positioned delete again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR4' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to do positioned delete on the current row now
 Positive Test1d - updatable resultset to do positioned update
@@ -308,8 +308,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR21' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
index 57e9b8dab..6a97423c8 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/jdk14/updatableResultSet.out
@@ -137,8 +137,8 @@ column 2 on this row before positioned delete aa
 column 1 on this deleted row is 234
 column 2 on this deleted row is aa                  
 doing positioned delete again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR4' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to do positioned delete on the current row now
 Positive Test1d - updatable resultset to do positioned update
@@ -308,8 +308,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR21' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/positionedDelUpd.out b/java/testing/org/apache/derbyTesting/functionTests/master/positionedDelUpd.out
index d308e28a9..c69875afe 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/positionedDelUpd.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/positionedDelUpd.out
@@ -52,7 +52,7 @@ ij> -- .same table name
 get cursor c1 as 'select * from t2 for update';
 ij> -- 'cursor not on a row' expected
 delete from t2 where current of c1;
-ERROR XCL08: Cursor 'C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> -- .different table name
 delete from t1 where current of c1;
 ERROR 42X28: Delete table 'T1' is not target of cursor 'C1'.
@@ -73,7 +73,7 @@ ij> -- .delete from  base table, not exposed table name
 -- (this one should work, since base table)
 get cursor c2 as 'select * from t2 asdf for update';
 ij> delete from t2 where current of c2;
-ERROR XCL08: Cursor 'C2' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> -- restore t1
 delete from t1;
 1 row inserted/updated/deleted
@@ -108,7 +108,7 @@ No current row
 ij> next c4;
 No current row
 ij> delete from t1 where current of c4;
-ERROR XCL08: Cursor 'C4' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> close c4;
 ij> -- .target cursor exists, closed
 get cursor c5 as 'select * from t1';
@@ -150,7 +150,7 @@ I          |V         |D                     |T
 ij> delete from t1 where current of c7;
 1 row inserted/updated/deleted
 ij> delete from t1 where current of c8;
-ERROR XCL08: Cursor 'C8' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -174,7 +174,7 @@ I          |V         |D                     |T
 ij> delete from t1 where current of c9;
 1 row inserted/updated/deleted
 ij> delete from t1 where current of c9;
-ERROR XCL08: Cursor 'C9' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -230,7 +230,7 @@ I          |V         |D                     |T
 ------------------------------------------------------
 2          |1111111111|1.1E12                |11:11:11
 ij> delete from t1 where current of c10a;
-ERROR XCL08: Cursor 'C10A' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -259,7 +259,7 @@ I          |V         |D                     |T
 ------------------------------------------------------
 2          |1111111111|1.1E12                |11:11:11
 ij> delete from t1 where current of c11;
-ERROR XCL08: Cursor 'C11' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -425,7 +425,7 @@ ij> -- .same table name
 get cursor c1 as 'select * from t2 for update';
 ij> -- 'cursor not on a row' expected
 update t2 set s = s where current of c1;
-ERROR XCL08: Cursor 'C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> -- .different table name
 update t1 set i = i where current of c1;
 ERROR 42X29: Update table 'T1' is not the target of cursor 'C1'.
@@ -437,7 +437,7 @@ ij> -- .update base table, not exposed table name
 -- (this one should work, since base table)
 get cursor c2 as 'select * from t2 asdf for update';
 ij> update t2 set s = s where current of c2;
-ERROR XCL08: Cursor 'C2' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> -- .match correlation name
 -- (this one should fail, since correlation name)
 update asdf set s = s where current of c2;
@@ -463,7 +463,7 @@ No current row
 ij> next c4;
 No current row
 ij> update t1 set i = i where current of c4;
-ERROR XCL08: Cursor 'C4' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> close c4;
 ij> -- .target cursor exists, closed
 get cursor c5 as 'select * from t1';
@@ -513,7 +513,7 @@ I          |V         |D                     |T
 ij> delete from t1 where current of c7;
 1 row inserted/updated/deleted
 ij> update t1 set i = i + 1 where current of c8;
-ERROR XCL08: Cursor 'C8' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -537,7 +537,7 @@ I          |V         |D                     |T
 ij> delete from t1 where current of c9;
 1 row inserted/updated/deleted
 ij> update t1 set i = i + 1 where current of c9;
-ERROR XCL08: Cursor 'C9' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -594,7 +594,7 @@ I          |V         |D                     |T
 ------------------------------------------------------
 2          |1111111111|1.1E12                |11:11:11
 ij> update t1 set i = i + 2 where current of c10a;
-ERROR XCL08: Cursor 'C10A' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
@@ -623,7 +623,7 @@ I          |V         |D                     |T
 ------------------------------------------------------
 2          |1111111111|1.1E12                |11:11:11
 ij> update t1 set i = i + 2 where current of c11;
-ERROR XCL08: Cursor 'C11' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> select * from t1;
 I          |V         |D                     |T       
 ------------------------------------------------------
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
index c2bf505c9..e86ed886a 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/updatableResultSet.out
@@ -137,8 +137,8 @@ column 2 on this row before positioned delete aa
 column 1 on this deleted row is 234
 column 2 on this deleted row is aa                  
 doing positioned delete again w/o first positioning the ResultSet on the next row will fail
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR4' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Position the ResultSet with next()
 Should be able to do positioned delete on the current row now
 Positive Test1d - updatable resultset to do positioned update
@@ -308,8 +308,8 @@ Table t1 has following rows
 Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?
 delete using first resultset
 attempt to send deleteRow on the same row through a different resultset should throw an exception
-SQL State : XCL08
-Got expected exception Cursor 'SQLCUR21' is not on a row.
+SQL State : 24000
+Got expected exception Invalid cursor state - no current row.
 Move to next row in the 2nd resultset and then delete using the second resultset
 Positive Test11 - setting the fetch size to > 1 will be ignored by updatable resultset. Same as updatable cursors
 Notice the Fetch Size in run time statistics output.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/update.out b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
index 9c008fcff..0c17a1927 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/update.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/update.out
@@ -382,7 +382,7 @@ ij> -- test extra state in update
 get cursor c1 as 'select * from x for update of x';
 ij> prepare p1 as 'update x set x = x where current of c1';
 ij> execute p1;
-ERROR XCL08: Cursor 'C1' is not on a row.
+ERROR 24000: Invalid cursor state - no current row.
 ij> next c1;
 X          |Y          
 -----------------------
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest.java
index 081c257d0..33b3b4537 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest.java
@@ -18,6 +18,7 @@
  * language governing permissions and limitations under the License.
  */
 package org.apache.derbyTesting.functionTests.tests.jdbcapi;
+import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -244,6 +245,125 @@ public class SURTest extends SURBaseTest {
         assertFailOnUpdate(rs);
     }
 
+    /** 
+     * Test that when doing an update immediately after
+     * a commit, the update fails, because the cursor has been 
+     * postioned between the current row and the next row.
+     * The test uses a FORWARD_ONLY resultset and ResultSet update methods
+     * when doing the update.
+     */
+    public void testCursorStateAfterCommit1() 
+        throws SQLException
+    {
+        testCursorStateAfterCommit(false, ResultSet.TYPE_FORWARD_ONLY);
+    }
+
+    /** 
+     * Test that when doing an update immediately after
+     * a commit, the update fails, because the cursor has been 
+     * postioned between the current row and the next row.
+     * The test uses a SCROLL_INSENSITIVE resultset and ResultSet update methods
+     * when doing the update.
+     */
+    public void testCursorStateAfterCommit2() 
+        throws SQLException
+    {
+        testCursorStateAfterCommit(false, ResultSet.TYPE_SCROLL_INSENSITIVE);
+    }
+    
+     /** 
+     * Test that when doing an update immediately after
+     * a commit, the update fails, because the cursor has been 
+     * postioned between the current row and the next row.
+     * The test uses a FORWARD_ONLY resultset and positioned updates.
+     */
+    public void testCursorStateAfterCommit3() 
+        throws SQLException
+    {
+        testCursorStateAfterCommit(true, ResultSet.TYPE_FORWARD_ONLY);
+    }
+
+    /** 
+     * Test that when doing an update immediately after
+     * a commit, the update fails, because the cursor has been 
+     * postioned between the current row and the next row.
+     * The test uses a SCROLL_INSENSITIVE resultset and positioned updates.
+     */
+    public void testCursorStateAfterCommit4() 
+        throws SQLException
+    {
+        testCursorStateAfterCommit(true, ResultSet.TYPE_SCROLL_INSENSITIVE);
+    }
+    
+    /** 
+     * Test that when doing an update immediately after
+     * a commit, the update fails, because the cursor has been 
+     * postioned between the current row and the next row.
+     * If the cursor gets repositioned, it allows an update.
+     * @param positioned true to use positioned update, otherwise use 
+     *                   ResultSet.updateRow()
+     * @param resultSetType type of result set (as in ResultSet.getType())
+     */
+    private void testCursorStateAfterCommit(final boolean positioned, 
+                                            final int resultSetType) 
+        throws SQLException
+    {
+        final Statement s = con.createStatement(resultSetType, 
+                                                ResultSet.CONCUR_UPDATABLE);
+        final String cursorName = getNextCursorName();
+        s.setCursorName(cursorName);
+        
+        final ResultSet rs = s.executeQuery("select a from t1");
+        final int recordToUpdate = 5;
+        
+        if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
+            for (int i = 0; i < recordToUpdate; i++) {
+                rs.next();
+            }
+        } else {
+            rs.absolute(recordToUpdate);
+        }
+        
+        con.commit();
+        
+        PreparedStatement ps = 
+            con.prepareStatement("update t1 set a=? where current of " +
+                                 cursorName);
+        // First: check that we get an exception on update without repositioning:
+        try {
+            if (positioned) {
+                ps.setInt(1, -1);
+                ps.executeUpdate();                
+                fail("Expected exception to be thrown on positioned update " + 
+                     "since cursor is not positioned");
+            } else {
+                rs.updateInt(1, -1);
+                rs.updateRow();
+                fail("Expected exception to be thrown on updateRow() since " +
+                     "cursor is not positioned");
+            }
+        } catch (SQLException e) {
+            assertSQLState("Unexpected SQLState when updating row after commit",
+                           SQLStateConstants.INVALID_CURSOR_STATE_NO_SUBCLASS,
+                           e);
+        }
+        
+        // Check that we after a repositioning can update:
+        if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
+            rs.next();
+        } else {
+            rs.relative(0);
+        }
+        if (positioned) {
+            ps.setInt(1, -1);
+            ps.executeUpdate();                
+        } else {
+            rs.updateInt(1, -1);
+            rs.updateRow();
+        }
+        
+    }
+
     /**
      * Test that you can correctly run multiple updateXXX() + updateRow() 
      * combined with cancelRowUpdates().
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/currentof.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/currentof.java
index ee2d3eca8..add59e813 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/currentof.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/currentof.java
@@ -238,7 +238,7 @@ public class currentof {
    		} catch (SQLException se) {
 			String m = se.getSQLState();
 			JDBCDisplayUtil.ShowSQLException(System.out,se);
-			if ("XCL08".equals(m)) {
+			if ("24000".equals(m)) {
 				caught = true;
 				System.out.println("PASS: Attempt to delete cursor before first row caught");
 			} else {
@@ -296,7 +296,7 @@ public class currentof {
    		} catch (SQLException se) {
 			String m = se.getSQLState();
 			JDBCDisplayUtil.ShowSQLException(System.out,se);
-			if ("XCL08".equals(m)) {
+			if ("24000".equals(m)) {
 				caught = true;
 				System.out.println("PASS: Attempt to delete cursor past last row caught");
 			} else {
@@ -593,7 +593,7 @@ public class currentof {
    		} catch (SQLException se) {
 			String m = se.getSQLState();
 			JDBCDisplayUtil.ShowSQLException(System.out,se);
-			if ("XCL08".equals(m)) {
+			if ("24000".equals(m)) {
 				caught = true;
 				System.out.println("PASS: Attempt to update cursor before first row caught");
 			} else {
@@ -628,7 +628,7 @@ public class currentof {
    		} catch (SQLException se) {
 			String m = se.getSQLState();
 			JDBCDisplayUtil.ShowSQLException(System.out,se);
-			if ("XCL08".equals(m)) {
+			if ("24000".equals(m)) {
 				caught = true;
 				System.out.println("PASS: Attempt to update cursor past last row caught");
 			} else {
diff --git a/java/testing/org/apache/derbyTesting/functionTests/util/BaseJDBCTestCase.java b/java/testing/org/apache/derbyTesting/functionTests/util/BaseJDBCTestCase.java
index 4bde1b270..41064c30b 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/util/BaseJDBCTestCase.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/util/BaseJDBCTestCase.java
@@ -130,10 +130,8 @@ public class BaseJDBCTestCase
                                       SQLException exception) {
         // Make sure exception is not null. We want to separate between a
         // null-exception object, and a null-SQLState.
-        if (exception == null) {
-            throw new IllegalArgumentException("Exception cannot be null " +
-                                               "when asserting SQLState");
-        }
+        assertNotNull("Exception cannot be null when asserting on SQLState", 
+                      exception);
         
         String state = exception.getSQLState();
         
