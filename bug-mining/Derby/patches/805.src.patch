diff --git a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index 98a2a4193..a485c122c 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -2868,7 +2868,14 @@ public class ResultColumnList extends QueryTreeNodeVector
 		{
 			ResultColumn rc = (ResultColumn) elementAt(index);
 
-			rc.setExpression(rc.getExpression().remapColumnReferencesToExpressions());
+			// The expression may be null if this column is an identity
+			// column generated always. If the expression is not null, it
+			// is a ColumnReference; we call through to the ColumnReference
+			// to give it a chance to remap itself from the outer query
+			// node to this one.
+			if (rc.getExpression() != null)
+				rc.setExpression(
+					rc.getExpression().remapColumnReferencesToExpressions());
 		}
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/joins.out b/java/testing/org/apache/derbyTesting/functionTests/master/joins.out
index 1a4ab25d5..6f8a99076 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/joins.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/joins.out
@@ -386,6 +386,26 @@ A1         |B1         |C1         |C3         |D1         |D3
 -----------------------------------------------------------------------
 1          |1          |1          |1          |1          |2          
 7          |7          |8          |9          |1          |3          
+ij> -- JIRA 1089: demonstrate that a table with an identity column generated
+-- always can be used as the target of an insert-as-select join:
+create table j1089_source (source_id int);
+0 rows inserted/updated/deleted
+ij> insert into j1089_source values (0);
+1 row inserted/updated/deleted
+ij> create table j1089_dest (
+    dest_id int not null primary key generated always as identity,
+    source_id_1 int not null,
+    source_id_2 int not null);
+0 rows inserted/updated/deleted
+ij> insert into j1089_dest (source_id_1, source_id_2)
+    select s1.source_id, s2.source_id
+        from j1089_source as s1
+            join j1089_source as s2 on 1 = 1;
+1 row inserted/updated/deleted
+ij> select * from j1089_dest;
+DEST_ID    |SOURCE_ID_1|SOURCE_ID_2
+-----------------------------------
+1          |0          |0          
 ij> -----------------------------------
 -- clean up
 ----------------------------------
@@ -411,4 +431,8 @@ ij> drop table x;
 0 rows inserted/updated/deleted
 ij> drop table y;
 0 rows inserted/updated/deleted
+ij> drop table j1089_source;
+0 rows inserted/updated/deleted
+ij> drop table j1089_dest;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/joins.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/joins.sql
index a09a96203..bff422c74 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/joins.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/joins.sql
@@ -186,6 +186,21 @@ select a1,b1,c1,c3,d1,d3
   from D join ((B join C on b2=c2) right outer join A on a1=b1) 
     on d3=b3 and d1=a2;
 
+-- JIRA 1089: demonstrate that a table with an identity column generated
+-- always can be used as the target of an insert-as-select join:
+create table j1089_source (source_id int);
+insert into j1089_source values (0);
+create table j1089_dest (
+    dest_id int not null primary key generated always as identity,
+    source_id_1 int not null,
+    source_id_2 int not null);
+
+insert into j1089_dest (source_id_1, source_id_2)
+    select s1.source_id, s2.source_id
+        from j1089_source as s1
+            join j1089_source as s2 on 1 = 1;
+select * from j1089_dest;
+
 -----------------------------------
 -- clean up
 ----------------------------------
@@ -200,3 +215,5 @@ drop table t4;
 drop table instab;
 drop table x;
 drop table y;
+drop table j1089_source;
+drop table j1089_dest;
