diff --git a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
index 912955206..151e5d8db 100644
--- a/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
+++ b/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
@@ -1810,13 +1810,31 @@ public class GenericLanguageConnectionContext
 
 	/**
 	 * Push a CompilerContext on the context stack with
-	 * the passed in default schema as the default schema
+	 * the passed in schema sd as the default schema
 	 * we compile against.
 	 *
 	 * @param sd the default schema 
 	 *
 	 * @return the compiler context
 	 *
+	 * For the parameter sd, there are 3 possible values(of interest) that can 
+	 * get passed into this method:
+	 * 
+	 * a) A null SchemaDescriptor which indicates to the system to use the 
+	 *    CURRENT SCHEMA as the compilation schema.
+	 *    
+	 * b) A SchemaDescriptor with its UUID == null, this indicates that either 
+	 *    the schema has not been physically created yet or that the LCC's 
+	 *    getDefaultSchema() is not yet up-to-date with its actual UUID. 
+	 *    The system will use the CURRENT SCHEMA as the compilation schema. 
+	 *    
+	 * c) A SchemaDescriptor with its UUID != null, this means that the schema 
+	 *    has been physically created.  The system will use this schema as the 
+	 *    compilation schema (e.g.: for trigger or view recompilation cases, 
+	 *    etc.). 
+	 *    
+	 * The compiler context's compilation schema will be set accordingly based 
+	 * on the given input above.   
 	 */
 	public	CompilerContext pushCompilerContext(SchemaDescriptor sd)
 	{
@@ -1855,6 +1873,24 @@ public class GenericLanguageConnectionContext
 		if (sc.getSystemCode())
 			cc.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
 
+		/*
+		 * Set the compilation schema when its UUID is available.
+		 * i.e.:  Schema may not have been physically created yet, so
+		 *        its UUID will be null.
+		 * 
+		 * o For trigger SPS recompilation, the system must use its
+		 *   compilation schema to recompile the statement. 
+		 * 
+		 * o For view recompilation, we set the compilation schema
+		 *   for this compiler context if its UUID is available.
+		 *   Otherwise, the compilation schema will be determined
+		 *   at execution time of view creation.
+		 */
+		if (sd != null && sd.getUUID() != null)
+		{
+			cc.setCompilationSchema(sd);
+		}
+		
 		return	cc;
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/triggerGeneral.out b/java/testing/org/apache/derbyTesting/functionTests/master/triggerGeneral.out
index aa869f9bb..a7bf9ece0 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/triggerGeneral.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/triggerGeneral.out
@@ -1509,4 +1509,115 @@ ij(USER1)> drop table x;
 0 rows inserted/updated/deleted
 ij(USER1)> drop table y;
 0 rows inserted/updated/deleted
-ij(USER1)> 
+ij(USER1)> -- DERBY-2183
+-- trigger recompilation test
+disconnect user1;
+ij> connect 'jdbc:derby:wombat' user 'user1' as user1;
+ij(USER1)> set schema app;
+0 rows inserted/updated/deleted
+ij(USER1)> drop trigger app.tr1;
+ERROR 42X94: TRIGGER 'APP.TR1' does not exist.
+ij(USER1)> drop table app.t1;
+0 rows inserted/updated/deleted
+ij(USER1)> create table app.t1 (i int, j int);
+0 rows inserted/updated/deleted
+ij(USER1)> insert into app.t1 values (1,10);
+1 row inserted/updated/deleted
+ij(USER1)> create trigger app.tr1 after update of i on app.t1 referencing old as old for each row update t1 set j = old.j+1;
+0 rows inserted/updated/deleted
+ij(USER1)> update app.t1 set i=i+1;
+1 row inserted/updated/deleted
+ij(USER1)> select * from app.t1;
+I          |J          
+-----------------------
+2          |11         
+ij(USER1)> call sqlj.install_jar('file:dcl_emc1.jar', 'APP.dcl_emc1', 0);
+0 rows inserted/updated/deleted
+ij(USER1)> connect 'jdbc:derby:wombat' user 'user2' as user2;
+ij(USER2)> -- ok
+update app.t1 set i=i+1;
+1 row inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+I          |J          
+-----------------------
+3          |12         
+ij(USER2)> call sqlj.replace_jar('file:dcl_emc1.jar', 'APP.dcl_emc1');
+0 rows inserted/updated/deleted
+ij(USER2)> update app.t1 set i=i+1;
+1 row inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+I          |J          
+-----------------------
+4          |13         
+ij(USER2)> call sqlj.remove_jar('APP.dcl_emc1', 0);
+0 rows inserted/updated/deleted
+ij(USER2)> update app.t1 set i=i+1;
+1 row inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+I          |J          
+-----------------------
+5          |14         
+ij(USER2)> drop trigger app.tr1;
+0 rows inserted/updated/deleted
+ij(USER2)> drop table app.t1;
+0 rows inserted/updated/deleted
+ij(USER2)> set connection user1;
+ij(USER1)> set schema app;
+0 rows inserted/updated/deleted
+ij(USER1)> create table app.t1 (id int, i int, j int);
+0 rows inserted/updated/deleted
+ij(USER1)> insert into app.t1 values (1,10, 100);
+1 row inserted/updated/deleted
+ij(USER1)> insert into app.t1 values (2,20, 200);
+1 row inserted/updated/deleted
+ij(USER1)> insert into app.t1 values (3,30, 300);
+1 row inserted/updated/deleted
+ij(USER1)> create trigger app.tr1 after update on app.t1 referencing old as oldt  new as newt 
+for each row update t1 set t1.j = CASE WHEN (oldt.j < 100) THEN (oldt.j + 1) ELSE 1 END WHERE
+((newt.j is null) OR (oldt.j = newt.j)) AND newt.id = t1.id;
+0 rows inserted/updated/deleted
+ij(USER1)> update app.t1 set i=i+1;
+3 rows inserted/updated/deleted
+ij(USER1)> select * from app.t1;
+ID         |I          |J          
+-----------------------------------
+1          |11         |1          
+2          |21         |1          
+3          |31         |1          
+ij(USER1)> call sqlj.install_jar('file:dcl_emc1.jar', 'APP.dcl_emc1', 0);
+0 rows inserted/updated/deleted
+ij(USER1)> set connection user2;
+ij(USER2)> -- ok
+update app.t1 set i=i+1;
+3 rows inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+ID         |I          |J          
+-----------------------------------
+1          |12         |2          
+2          |22         |2          
+3          |32         |2          
+ij(USER2)> call sqlj.replace_jar('file:dcl_emc1.jar', 'APP.dcl_emc1');
+0 rows inserted/updated/deleted
+ij(USER2)> update app.t1 set i=i+1;
+3 rows inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+ID         |I          |J          
+-----------------------------------
+1          |13         |3          
+2          |23         |3          
+3          |33         |3          
+ij(USER2)> call sqlj.remove_jar('APP.dcl_emc1', 0);
+0 rows inserted/updated/deleted
+ij(USER2)> update app.t1 set i=i+1;
+3 rows inserted/updated/deleted
+ij(USER2)> select * from app.t1;
+ID         |I          |J          
+-----------------------------------
+1          |14         |4          
+2          |24         |4          
+3          |34         |4          
+ij(USER2)> drop trigger app.tr1;
+0 rows inserted/updated/deleted
+ij(USER2)> drop table app.t1;
+0 rows inserted/updated/deleted
+ij(USER2)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral.sql
index 7f6d6830c..a6892f98c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral.sql
@@ -827,3 +827,56 @@ drop trigger tgood;
 drop table x;
 drop table y;
 
+-- DERBY-2183
+-- trigger recompilation test
+disconnect user1;
+connect 'jdbc:derby:wombat' user 'user1' as user1;
+set schema app;
+drop trigger app.tr1;
+drop table app.t1;
+create table app.t1 (i int, j int);
+insert into app.t1 values (1,10);
+create trigger app.tr1 after update of i on app.t1 referencing old as old for each row update t1 set j = old.j+1;
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.install_jar('file:dcl_emc1.jar', 'APP.dcl_emc1', 0);
+
+connect 'jdbc:derby:wombat' user 'user2' as user2;
+-- ok
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.replace_jar('file:dcl_emc1.jar', 'APP.dcl_emc1');
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.remove_jar('APP.dcl_emc1', 0);
+update app.t1 set i=i+1;
+select * from app.t1;
+drop trigger app.tr1;
+drop table app.t1;
+
+set connection user1;
+set schema app;
+create table app.t1 (id int, i int, j int);
+insert into app.t1 values (1,10, 100);
+insert into app.t1 values (2,20, 200);
+insert into app.t1 values (3,30, 300);
+create trigger app.tr1 after update on app.t1 referencing old as oldt  new as newt 
+for each row update t1 set t1.j = CASE WHEN (oldt.j < 100) THEN (oldt.j + 1) ELSE 1 END WHERE
+((newt.j is null) OR (oldt.j = newt.j)) AND newt.id = t1.id;
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.install_jar('file:dcl_emc1.jar', 'APP.dcl_emc1', 0);
+
+set connection user2;
+-- ok
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.replace_jar('file:dcl_emc1.jar', 'APP.dcl_emc1');
+update app.t1 set i=i+1;
+select * from app.t1;
+call sqlj.remove_jar('APP.dcl_emc1', 0);
+update app.t1 set i=i+1;
+select * from app.t1;
+drop trigger app.tr1;
+drop table app.t1;
+
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral_app.properties b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral_app.properties
index 690eb2527..00b03f6da 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral_app.properties
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/triggerGeneral_app.properties
@@ -1,5 +1,9 @@
 ij.protocol=jdbc:derby:
 usedefaults=true
+supportfiles=tests/lang/dcl_emc1.jar
 
 #Exclude for J2ME/Foundation - test requires java.sql.DriverManager
-runwithfoundation=false
\ No newline at end of file
+runwithfoundation=false
+
+# disable security manager for now 
+noSecurityManager=true
