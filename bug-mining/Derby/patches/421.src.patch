diff --git a/java/build/org/apache/derbyBuild/splitmessages.java b/java/build/org/apache/derbyBuild/splitmessages.java
index ea4459f10..1c08a970e 100644
--- a/java/build/org/apache/derbyBuild/splitmessages.java
+++ b/java/build/org/apache/derbyBuild/splitmessages.java
@@ -83,7 +83,7 @@ public class splitmessages {
         clientMessageIds.add(SQLState.NUMBER_OF_ROWS_TOO_LARGE_FOR_INT);
         clientMessageIds.add(SQLState.NOGETCONN_ON_CLOSED_POOLED_CONNECTION);
         clientMessageIds.add(SQLState.LOB_METHOD_ON_CLOSED_CONNECTION);
-	clientMessageIds.add(SQLState.QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
+        clientMessageIds.add(SQLState.QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
         clientMessageIds.add(SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
         clientMessageIds.add(SQLState.LANG_CANT_INVALIDATE_OPEN_RESULT_SET);
         clientMessageIds.add(SQLState.YEAR_EXCEEDS_MAXIMUM);
@@ -104,6 +104,7 @@ public class splitmessages {
         clientMessageIds.add(SQLState.SECMECH_NOT_SUPPORTED);
         clientMessageIds.add(SQLState.DRDA_COMMAND_NOT_IMPLEMENTED);
         clientMessageIds.add(SQLState.JDBC_DRIVER_REGISTER);
+        clientMessageIds.add(SQLState.NO_CURRENT_ROW);
     }
 
 	public static void main(String[] args) throws Exception {
diff --git a/java/client/org/apache/derby/client/am/ResultSet.java b/java/client/org/apache/derby/client/am/ResultSet.java
index 05aaf8f0c..7e68e8f4d 100644
--- a/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/java/client/org/apache/derby/client/am/ResultSet.java
@@ -3483,7 +3483,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
         
         if (isOnInsertRow_) {
             throw new SqlException(agent_.logWriter_, 
-                new ClientMessageId(SQLState.CURSOR_NOT_POSITIONED_ON_INSERT_ROW));
+                new ClientMessageId(SQLState.NO_CURRENT_ROW));
         }
 
         //if not on a valid row, then do not accept updateXXX calls
@@ -3609,7 +3609,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
 
         if (isOnInsertRow_) {
             throw new SqlException(agent_.logWriter_, 
-                new ClientMessageId(SQLState.CURSOR_NOT_POSITIONED_ON_INSERT_ROW));
+                new ClientMessageId(SQLState.NO_CURRENT_ROW));
         }
 
         if (preparedStatementForDelete_ == null) {
@@ -3655,7 +3655,7 @@ public abstract class ResultSet implements java.sql.ResultSet,
 	checkForUpdatableResultSet("refreshRow");
         if (isBeforeFirstX() || isAfterLastX() || isOnInsertRow_) {
             throw new SqlException(agent_.logWriter_,
-                new ClientMessageId(SQLState.CURSOR_CANNOT_INVOKE_ON_INSROW_OR_INVALIDROW_OR_READONLY));
+                new ClientMessageId(SQLState.NO_CURRENT_ROW));
         }
 	
         // this method does nothing if ResultSet is TYPE_SCROLL_INSENSITIVE
diff --git a/java/engine/org/apache/derby/loc/messages_en.properties b/java/engine/org/apache/derby/loc/messages_en.properties
index 604eacfc5..7de773958 100644
--- a/java/engine/org/apache/derby/loc/messages_en.properties
+++ b/java/engine/org/apache/derby/loc/messages_en.properties
@@ -1193,7 +1193,6 @@ XJ115.S=Unable to open resultSet with requested holdability {0}.
 XJ116.S=No more than {0} commands may be added to a single batch.
 XJ117.S=Batching of queries not allowed by J2EE compliance.
 XJ118.S=Query batch requested on a non-query statement.
-XJ120.S=This method cannot be invoked while the cursor is on the insert row, if the cursor is not on a valid row, or if this ResultSet object has a concurrency of CONCUR_READ_ONLY.
 XJ121.S=Invalid operation at current cursor position.
 XJ122.S=No updateXXX methods were called on this row.
 XJ123.S=This method must be called to update values in the current row or the insert row.
diff --git a/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 5e348dda7..132810483 100644
--- a/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -1488,7 +1488,6 @@ public interface SQLState {
     String TOO_MANY_COMMANDS_FOR_BATCH = "XJ116.S";
     String CANNOT_BATCH_QUERIES = "XJ117.S";
     String QUERY_BATCH_ON_NON_QUERY_STATEMENT = "XJ118.S";
-    String CURSOR_CANNOT_INVOKE_ON_INSROW_OR_INVALIDROW_OR_READONLY = "XJ120.S";
     String CURSOR_INVALID_OPERATION_AT_CURRENT_POSITION = "XJ121.S";
     String CURSOR_NO_UPDATE_CALLS_ON_CURRENT_ROW = "XJ122.S";
     String CURSOR_NOT_ON_CURRENT_OR_INSERT_ROW = "XJ123.S";
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
index 656782ad8..5767feb1c 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/jdk14/updatableResultSet.out
@@ -3167,11 +3167,11 @@ SQL State: 23502
 Got expected exception: Column 'C41'  cannot accept a NULL value.
 Negative Test 39 - run updateRow and deleterow when positioned at insertRow
 Negative Test 39.a - run updateRow on insertRow
-SQL State: XJ086
-Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+SQL State: 24000
+Got expected exception: Invalid cursor state - no current row.
 Negative Test 39.a - run deleteRow on insertRow
-SQL State: XJ086
-Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+SQL State: 24000
+Got expected exception: Invalid cursor state - no current row.
 Negative test 40 - Try to insert row from currentRow
 SQL State: XJ086
 Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
index 5a36477e1..4ab115175 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/updatableResultSet.out
@@ -2899,11 +2899,11 @@ SQL State: 23502
 Got expected exception: Column 'C41'  cannot accept a NULL value.
 Negative Test 39 - run updateRow and deleterow when positioned at insertRow
 Negative Test 39.a - run updateRow on insertRow
-SQL State: XJ086
-Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+SQL State: 24000
+Got expected exception: Invalid cursor state - no current row.
 Negative Test 39.a - run deleteRow on insertRow
-SQL State: XJ086
-Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
+SQL State: 24000
+Got expected exception: Invalid cursor state - no current row.
 Negative test 40 - Try to insert row from currentRow
 SQL State: XJ086
 Got expected exception: This method cannot be invoked while the cursor is not on the insert row or if the concurrency of this ResultSet object is CONCUR_READ_ONLY.
