diff --git a/java/engine/org/apache/derby/impl/sql/compile/FKConstraintDefinitionNode.java b/java/engine/org/apache/derby/impl/sql/compile/FKConstraintDefinitionNode.java
index 39f48dbad..236ef3a4c 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/FKConstraintDefinitionNode.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/FKConstraintDefinitionNode.java
@@ -107,6 +107,10 @@ public final class FKConstraintDefinitionNode extends ConstraintDefinitionNode
 		// Verify if REFERENCES_PRIV is granted to columns referenced
 		getCompilerContext().pushCurrentPrivType(getPrivType());
 
+		// Indicate that this statement has a dependency on the
+		// table which is referenced by this foreign key:
+		getCompilerContext().createDependency(td);
+
 		// If references clause doesn't have columnlist, get primary key info
 		if (refRcl.size()==0 && (td.getPrimaryKey() != null))
 		{
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/grantRevokeDDL.out b/java/testing/org/apache/derbyTesting/functionTests/master/grantRevokeDDL.out
index 743baa89c..e7032ae15 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/grantRevokeDDL.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/grantRevokeDDL.out
@@ -3045,4 +3045,36 @@ ij(MAMTA1)> update mamta2.ttt1 set i = 888;
 2 rows inserted/updated/deleted
 ij(MAMTA1)> commit;
 ij(MAMTA1)> autocommit on;
-ij(MAMTA1)> 
+ij(MAMTA1)> -- Simple test case for DERBY-1589. The problem here involves dependency
+-- management between the FOREIGN KEY clause in the CREATE TABLE statement
+-- and the underlying table that the FK refers to. The statement must
+-- declare a dependency on the referenced table so that changes to the table
+-- cause invalidation of the statement's compiled plan. The test case below
+-- sets up such a situation by dropping the referenced table and recreating
+-- it and then re-issuing a statement with identical text to one which
+-- was issued earlier.
+set connection mamta1;
+ij(MAMTA1)> create table d1589t11ConstraintTest (c111 int not null, c112 int not null, primary key (c111, c112));
+0 rows inserted/updated/deleted
+ij(MAMTA1)> grant references on d1589t11ConstraintTest to mamta3;
+0 rows inserted/updated/deleted
+ij(MAMTA1)> set connection mamta3;
+ij(MAMTA3)> drop table d1589t31ConstraintTest;
+ERROR: Failed with SQLSTATE 42Y55
+ij(MAMTA3)> create table d1589t31ConstraintTest (c311 int, c312 int, foreign key(c311, c312) references mamta1.d1589t11ConstraintTest);
+0 rows inserted/updated/deleted
+ij(MAMTA3)> drop table d1589t31ConstraintTest;
+0 rows inserted/updated/deleted
+ij(MAMTA3)> set connection mamta1;
+ij(MAMTA1)> drop table d1589t11ConstraintTest;
+0 rows inserted/updated/deleted
+ij(MAMTA1)> create table d1589t11ConstraintTest (c111 int not null, c112 int not null, primary key (c111, c112));
+0 rows inserted/updated/deleted
+ij(MAMTA1)> grant references(c111) on d1589t11ConstraintTest to mamta3;
+0 rows inserted/updated/deleted
+ij(MAMTA1)> grant references(c112) on d1589t11ConstraintTest to PUBLIC;
+0 rows inserted/updated/deleted
+ij(MAMTA1)> set connection mamta3;
+ij(MAMTA3)> create table d1589t31ConstraintTest (c311 int, c312 int, foreign key(c311, c312) references mamta1.d1589t11ConstraintTest);
+0 rows inserted/updated/deleted
+ij(MAMTA3)> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/grantRevokeDDL.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/grantRevokeDDL.sql
index ea9b5ea69..5954f6ea9 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/grantRevokeDDL.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/grantRevokeDDL.sql
@@ -1924,3 +1924,27 @@ insert into mamta2.ttt1 values 2;
 update mamta2.ttt1 set i = 888;
 commit;
 autocommit on;
+
+-- Simple test case for DERBY-1589. The problem here involves dependency
+-- management between the FOREIGN KEY clause in the CREATE TABLE statement
+-- and the underlying table that the FK refers to. The statement must
+-- declare a dependency on the referenced table so that changes to the table
+-- cause invalidation of the statement's compiled plan. The test case below
+-- sets up such a situation by dropping the referenced table and recreating
+-- it and then re-issuing a statement with identical text to one which
+-- was issued earlier.
+
+set connection mamta1;
+create table d1589t11ConstraintTest (c111 int not null, c112 int not null, primary key (c111, c112));
+grant references on d1589t11ConstraintTest to mamta3;
+set connection mamta3;
+drop table d1589t31ConstraintTest;
+create table d1589t31ConstraintTest (c311 int, c312 int, foreign key(c311, c312) references mamta1.d1589t11ConstraintTest);
+drop table d1589t31ConstraintTest;
+set connection mamta1;
+drop table d1589t11ConstraintTest;
+create table d1589t11ConstraintTest (c111 int not null, c112 int not null, primary key (c111, c112));
+grant references(c111) on d1589t11ConstraintTest to mamta3;
+grant references(c112) on d1589t11ConstraintTest to PUBLIC;
+set connection mamta3;
+create table d1589t31ConstraintTest (c311 int, c312 int, foreign key(c311, c312) references mamta1.d1589t11ConstraintTest); 
