diff --git a/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java b/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
index 2cb75d9c0..fad3172b9 100644
--- a/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
+++ b/java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java
@@ -502,7 +502,7 @@ public interface LanguageConnectionContext extends Context {
 	/**
 	 * Return true if this schema name is the initial default schema for the
 	 * current session.
-	 * @param schemaName 
+	 * @param schemaName
 	 * @return true
 	 */
 	public boolean isInitialDefaultSchema(String schemaName);
diff --git a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
index 41b95698a..54bfbcacd 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/DDLConstantAction.java
@@ -101,88 +101,20 @@ abstract class DDLConstantAction implements ConstantAction
 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, false);
 
 		if (sd == null || sd.getUUID() == null) {
-            CreateSchemaConstantAction csca
-                = new CreateSchemaConstantAction(schemaName, (String) null);
+			CreateSchemaConstantAction csca
+				= new CreateSchemaConstantAction(schemaName, (String) null);
 
 			if (activation.getLanguageConnectionContext().
 					isInitialDefaultSchema(schemaName)) {
-				// DERBY-48: This operation creates the user's initial default
-				// schema and we don't want to hold a lock for SYSSCHEMAS for
-				// the duration of the user transaction, so we perform the
-				// creation in a nested transaction if possible.
-				TransactionController useTc    = null;
-				TransactionController nestedTc = null;
-
-				try {
-					nestedTc = tc.startNestedUserTransaction(false);
-					useTc = nestedTc;
-				} catch (StandardException e) {
-					if (SanityManager.DEBUG) {
-						SanityManager.THROWASSERT(
-							"Unexpected: not able to start nested transaction " +
-							"to auto-create schema", e);
-					}
-					useTc = tc;
-				}
-
-				// Try max twice: if nested transaction times out, try
-				// again in the outer transaction because it may be a
-				// self-lock, that is, the outer transaction may hold some
-				// lock(s) that make the nested transaction attempt to set
-				// a write lock time out.  Trying it again in the outer
-				// transaction will then succeed. If the reason is some
-				// other transaction barring us, trying again in the outer
-				// transaction will possibly time out again.
-				//
-				// Also, if creating a nested transaction failed, only try
-				// once in the outer transaction.
-				while (true) {
-					try {
-						csca.executeConstantAction(activation, useTc);
-					} catch (StandardException se) {
-						if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
-							// We don't test for SQLState.DEADLOCK or
-							// .LOCK_TIMEOUT_LOG here because a) if it is a
-							// deadlock, it may be better to expose it, and b)
-							// LOCK_TIMEOUT_LOG happens when the app has set
-							// derby.locks.deadlockTrace=true, in which case we
-							// don't want to mask the timeout.  So in both the
-							// latter cases we just throw.
-							if (useTc == nestedTc) {
-
-								// clean up after use of nested transaction,
-								// then try again in outer transaction
-								useTc = tc;
-								nestedTc.destroy();
-								continue;
-							}
-						} else if (se.getMessageId()
-									   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
-							// Ignore "Schema already exists". Another thread has
-							// probably created it after we checked for it
-							break;
-						}
-
-						// We got an non-expected exception, either in
-						// the nested transaction or in the outer
-						// transaction; we had better pass that on
-						if (useTc == nestedTc) {
-							nestedTc.destroy();
-						}
-
-						throw se;
-					}
-					break;
-				}
-
-				// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
-				// Clean up if we did this in a nested transaction.
-				if (useTc == nestedTc) {
-					nestedTc.commit();
-					nestedTc.destroy();
-				}
+				// DERBY-48: This operation creates the user's initial
+				// default schema and we don't want to hold a lock for
+				// SYSSCHEMAS for the duration of the user transaction
+				// since connection attempts may block, so we perform
+				// the creation in a nested transaction (if possible)
+				// so we can commit at once and release locks.
+				executeCAPreferSubTrans(csca, tc, activation);
 			} else {
-				// create the schema in the user transaction always
+				// create the schema in the user transaction
 				try {
 					csca.executeConstantAction(activation);
 				} catch (StandardException se) {
@@ -204,6 +136,85 @@ abstract class DDLConstantAction implements ConstantAction
 	}
 
 
+	private static void executeCAPreferSubTrans
+		(CreateSchemaConstantAction csca,
+		 TransactionController tc,
+		 Activation activation) throws StandardException {
+
+		TransactionController useTc    = null;
+		TransactionController nestedTc = null;
+
+		try {
+			nestedTc = tc.startNestedUserTransaction(false);
+			useTc = nestedTc;
+		} catch (StandardException e) {
+			if (SanityManager.DEBUG) {
+				SanityManager.THROWASSERT(
+					"Unexpected: not able to start nested transaction " +
+					"to auto-create schema", e);
+			}
+			useTc = tc;
+		}
+
+		// Try max twice: if nested transaction times out, try
+		// again in the outer transaction because it may be a
+		// self-lock, that is, the outer transaction may hold some
+		// lock(s) that make the nested transaction attempt to set
+		// a write lock time out.  Trying it again in the outer
+		// transaction will then succeed. If the reason is some
+		// other transaction barring us, trying again in the outer
+		// transaction will possibly time out again.
+		//
+		// Also, if creating a nested transaction failed, only try
+		// once in the outer transaction.
+		while (true) {
+			try {
+				csca.executeConstantAction(activation, useTc);
+			} catch (StandardException se) {
+				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
+					// We don't test for SQLState.DEADLOCK or
+					// .LOCK_TIMEOUT_LOG here because a) if it is a
+					// deadlock, it may be better to expose it, and b)
+					// LOCK_TIMEOUT_LOG happens when the app has set
+					// derby.locks.deadlockTrace=true, in which case we
+					// don't want to mask the timeout.  So in both the
+					// latter cases we just throw.
+					if (useTc == nestedTc) {
+
+						// clean up after use of nested transaction,
+						// then try again in outer transaction
+						useTc = tc;
+						nestedTc.destroy();
+						continue;
+					}
+				} else if (se.getMessageId()
+							   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
+					// Ignore "Schema already exists". Another thread has
+					// probably created it after we checked for it
+					break;
+				}
+
+				// We got an non-expected exception, either in
+				// the nested transaction or in the outer
+				// transaction; we had better pass that on
+				if (useTc == nestedTc) {
+					nestedTc.destroy();
+				}
+
+				throw se;
+			}
+			break;
+		}
+
+		// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
+		// Clean up if we did this in a nested transaction.
+		if (useTc == nestedTc) {
+			nestedTc.commit();
+			nestedTc.destroy();
+		}
+	}
+
+
 	/**
 	 * Lock the table in exclusive or share mode to prevent deadlocks.
 	 *
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
index 10c0af867..1c901d552 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/LazyDefaultSchemaCreationTest.java
@@ -221,7 +221,7 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
         // Will auto-create schema OTHERSCHEMA:
         s1.executeUpdate("create table otherschema.t1(i int)");
         s1.close();
-        
+
         JDBC.assertSingleValueResultSet(
             c1.createStatement().executeQuery(
                 "select schemaname from sys.sysschemas " +
@@ -234,7 +234,7 @@ public class LazyDefaultSchemaCreationTest extends BaseJDBCTestCase {
             c1.createStatement().executeQuery(
                 "select schemaname from sys.sysschemas " +
                 "where schemaname='OTHERSCHEMA'"));
-        
+
         c1.rollback();
         c1.close();
     }
