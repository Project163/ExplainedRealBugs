diff --git a/java/engine/org/apache/derby/catalog/SystemProcedures.java b/java/engine/org/apache/derby/catalog/SystemProcedures.java
index 6a70b9250..cb0585d72 100644
--- a/java/engine/org/apache/derby/catalog/SystemProcedures.java
+++ b/java/engine/org/apache/derby/catalog/SystemProcedures.java
@@ -31,21 +31,27 @@ import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Timestamp;
+import java.util.ArrayList;
 import java.util.NoSuchElementException;
 import java.util.Random;
 import java.util.StringTokenizer;
 
+import org.apache.derby.catalog.AliasInfo;
 import org.apache.derby.iapi.db.Factory;
 import org.apache.derby.iapi.db.PropertyInfo;
 import org.apache.derby.iapi.error.PublicAPI;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.Property;
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
 import org.apache.derby.iapi.services.cache.CacheManager;
 import org.apache.derby.iapi.services.i18n.MessageService;
 import org.apache.derby.iapi.services.property.PropertyUtil;
+import org.apache.derby.iapi.sql.conn.Authorizer;
 import org.apache.derby.iapi.sql.conn.ConnectionUtil;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
+import org.apache.derby.iapi.sql.Activation;
 import org.apache.derby.iapi.util.IdUtil;
 import org.apache.derby.iapi.util.StringUtil;
 import org.apache.derby.impl.jdbc.EmbedDatabaseMetaData;
@@ -62,10 +68,13 @@ import org.apache.derby.impl.sql.catalog.XPLAINStatementTimingsDescriptor;
 import org.apache.derby.impl.sql.execute.JarUtil;
 import org.apache.derby.jdbc.InternalDriver;
 import org.apache.derby.iapi.store.access.TransactionController;
+import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
 import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
+import org.apache.derby.iapi.sql.dictionary.StatementPermission;
+import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
 import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
 import org.apache.derby.iapi.sql.dictionary.UserDescriptor;
 
@@ -684,9 +693,31 @@ public class SystemProcedures  {
     String  value)
         throws SQLException
     {
-        PropertyInfo.setDatabaseProperty(key, value);
+        setDatabaseProperty( key, value, Securable.SET_DATABASE_PROPERTY );
     }
 
+    private static void setDatabaseProperty( String key, String value, Securable authorizationCheck )
+        throws SQLException
+	{
+		LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
+
+		try {
+            if ( authorizationCheck != null )
+            {
+                SecurityUtil.authorize( authorizationCheck );
+            }
+            
+            Authorizer a = lcc.getAuthorizer();
+            a.authorize((Activation) null, Authorizer.PROPERTY_WRITE_OP);
+
+            // Get the current transaction controller
+            TransactionController tc = lcc.getTransactionExecute();
+
+            tc.setProperty(key, value, false);
+		} catch (StandardException se) {throw PublicAPI.wrapStandardException( se ); }
+	}
+
+
     /**
      * Get the value of a property of the database in current connection.
      * <p>
@@ -699,10 +730,27 @@ public class SystemProcedures  {
     public static String SYSCS_GET_DATABASE_PROPERTY(
     String  key)
         throws SQLException
+    {
+        return getProperty( key, Securable.GET_DATABASE_PROPERTY );
+    }
+
+    /**
+     * This method exists so that we can get a property value without performing
+     * authorization checks.
+     */
+    private static  String  getProperty( String key, Securable authorizationCheck )
+        throws SQLException
     {
         LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
 
         try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            if ( authorizationCheck != null )
+            {
+                SecurityUtil.authorize( authorizationCheck );
+            }
+            
             return PropertyUtil.getDatabaseProperty(lcc.getTransactionExecute(), key);
         } catch (StandardException se) {
             throw PublicAPI.wrapStandardException(se);
@@ -1009,7 +1057,6 @@ public class SystemProcedures  {
     short     deleteOnlineArchivedLogFiles)
 		throws SQLException
     {
-
         Factory.getDatabaseOfConnection().backupAndEnableLogArchiveMode(
                 backupDir, 
                 (deleteOnlineArchivedLogFiles != 0),
@@ -1045,7 +1092,6 @@ public class SystemProcedures  {
     short     deleteOnlineArchivedLogFiles)
 		throws SQLException
     {
-
         Factory.getDatabaseOfConnection().backupAndEnableLogArchiveMode(
                 backupDir,
                 (deleteOnlineArchivedLogFiles != 0),
@@ -1439,6 +1485,11 @@ public class SystemProcedures  {
 	String  codeset)
         throws SQLException
     {
+        //
+        // In case this routine is called directly by the application,
+        // authorization is performed by Export.exportTable().
+        //
+
 		Connection conn = getDefaultConn();
 		Export.exportTable(conn, schemaName , tableName , fileName ,
 							  columnDelimiter , characterDelimiter, codeset);
@@ -1735,6 +1786,13 @@ public class SystemProcedures  {
 	)
         throws SQLException
     {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.BULK_INSERT );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
 		Connection conn = getDefaultConn();
 
         // Use default schema if schemaName is null. This isn't consistent
@@ -1769,13 +1827,22 @@ public class SystemProcedures  {
     public static void SYSCS_RELOAD_SECURITY_POLICY()
         throws SQLException
     {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.RELOAD_SECURITY_POLICY );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
         // If no security manager installed then there
         // is no policy to refresh. Calling Policy.getPolicy().refresh()
         // without a SecurityManager seems to lock in a policy with
         // no permissions thus ignoring the system property java.security.policy
         // when later installing a SecurityManager.
         if (System.getSecurityManager() == null)
+        {
             return;
+        }
         
         try {
             AccessController.doPrivileged(
@@ -1862,8 +1929,10 @@ public class SystemProcedures  {
                 addListProperty = null;
             }
             else
+            {
                 throw StandardException.newException(SQLState.UU_UNKNOWN_PERMISSION,
                         connectionPermission);
+            }
 
             // Always remove from both lists to avoid any repeated
             // user on list errors.
@@ -1874,9 +1943,13 @@ public class SystemProcedures  {
             
             
             if (addListProperty != null) {
-                String addList = SYSCS_GET_DATABASE_PROPERTY(addListProperty);
-                SYSCS_SET_DATABASE_PROPERTY(addListProperty,
-                    IdUtil.appendNormalToList(userName, addList));
+                String addList = getProperty( addListProperty, Securable.SET_USER_ACCESS );
+                setDatabaseProperty
+                    (
+                     addListProperty,
+                     IdUtil.appendNormalToList(userName, addList),
+                     null
+                     );
             }
             
         } catch (StandardException se) {
@@ -1892,11 +1965,10 @@ public class SystemProcedures  {
             String listProperty, String userName)
         throws SQLException, StandardException
     {
-        String removeList = SYSCS_GET_DATABASE_PROPERTY(listProperty);
+        String removeList = getProperty( listProperty, Securable.SET_USER_ACCESS );
         if (removeList != null)
         {
-            SYSCS_SET_DATABASE_PROPERTY(listProperty,
-                    IdUtil.deleteId(userName, removeList));
+            setDatabaseProperty( listProperty, IdUtil.deleteId( userName, removeList ), null );
         }
     }
     
@@ -1913,25 +1985,35 @@ public class SystemProcedures  {
         try {
             
             if (userName == null)
+            {
                 throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME,
                         userName);
+            }
            
             String fullUserList =
-                SYSCS_GET_DATABASE_PROPERTY(Property.FULL_ACCESS_USERS_PROPERTY);
+                getProperty( Property.FULL_ACCESS_USERS_PROPERTY, Securable.GET_USER_ACCESS );
             if (IdUtil.idOnList(userName, fullUserList))
+            {
                 return Property.FULL_ACCESS;
+            }
             
             String readOnlyUserList =
-                SYSCS_GET_DATABASE_PROPERTY(Property.READ_ONLY_ACCESS_USERS_PROPERTY);
+                getProperty( Property.READ_ONLY_ACCESS_USERS_PROPERTY, Securable.GET_USER_ACCESS );
             if (IdUtil.idOnList(userName, readOnlyUserList))
+            {
                 return Property.READ_ONLY_ACCESS;
+            }
             
             String defaultAccess = 
-                SYSCS_GET_DATABASE_PROPERTY(Property.DEFAULT_CONNECTION_MODE_PROPERTY);
+                getProperty( Property.DEFAULT_CONNECTION_MODE_PROPERTY, Securable.GET_USER_ACCESS );
             if (defaultAccess != null)
+            {
                 defaultAccess = StringUtil.SQLToUpperCase(defaultAccess);
+            }
             else
+            {
                 defaultAccess = Property.FULL_ACCESS; // is the default.
+            }
             
             return defaultAccess;
             
@@ -1951,6 +2033,10 @@ public class SystemProcedures  {
         
         DataDictionary dd = lcc.getDataDictionary();
         try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.INVALIDATE_STORED_STATEMENTS );
+
         	dd.invalidateAllSPSPlans(lcc);
         } catch (StandardException se) {
             throw PublicAPI.wrapStandardException(se);
@@ -1966,13 +2052,22 @@ public class SystemProcedures  {
     public static void SYSCS_EMPTY_STATEMENT_CACHE()
        throws SQLException
     {
-       LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.EMPTY_STATEMENT_CACHE );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
+        LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
        
-       CacheManager statementCache =
+        CacheManager statementCache =
            lcc.getLanguageConnectionFactory().getStatementCache();
        
-       if (statementCache != null)
-           statementCache.ageOut();
+        if (statementCache != null)
+        {
+            statementCache.ageOut();
+        }
     }
   
 	 /**
@@ -1981,10 +2076,18 @@ public class SystemProcedures  {
      * @throws SQLException
      */
     public static void SYSCS_SET_XPLAIN_MODE(int mode)
-                throws SQLException, StandardException
-            {
+        throws SQLException, StandardException
+    {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.SET_XPLAIN_MODE );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
 		ConnectionUtil.getCurrentLCC().setXplainOnlyMode(mode != 0 ? true : false);
-            }
+    }
+    
     /**
      * This procedure returns the current status of the xplain mode.
      *
@@ -1995,10 +2098,17 @@ public class SystemProcedures  {
      * @throws SQLException
      */
     public static int SYSCS_GET_XPLAIN_MODE()
-                throws SQLException, StandardException
-           {
-                return ConnectionUtil.getCurrentLCC().getXplainOnlyMode()?1:0;
-           }
+        throws SQLException, StandardException
+    {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.GET_XPLAIN_MODE );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
+        return ConnectionUtil.getCurrentLCC().getXplainOnlyMode()?1:0;
+    }
     
     /**
      * This procedure sets the current xplain schema.
@@ -2011,6 +2121,13 @@ public class SystemProcedures  {
     public static void SYSCS_SET_XPLAIN_SCHEMA(String schemaName)
                 throws SQLException, StandardException
     {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.SET_XPLAIN_SCHEMA );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
         LanguageConnectionContext lcc       = ConnectionUtil.getCurrentLCC();
         TransactionController     tc        = lcc.getTransactionExecute();
 
@@ -2105,6 +2222,13 @@ public class SystemProcedures  {
     public static String SYSCS_GET_XPLAIN_SCHEMA()
                 throws SQLException, StandardException
     {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.GET_XPLAIN_SCHEMA );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
         String sd = ConnectionUtil.getCurrentLCC().getXplainSchema();
         if (sd == null)
             return "";
@@ -2129,6 +2253,10 @@ public class SystemProcedures  {
         // the first credentials must be those of the DBO and only the DBO
         // can add them
         try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.CREATE_USER );
+
             DataDictionary dd = lcc.getDataDictionary();
             String  dbo = dd.getAuthorizationDatabaseOwner();
 
@@ -2164,6 +2292,11 @@ public class SystemProcedures  {
          )
         throws SQLException
     {
+        //
+        // Application code can call this method, and that is a security hole until
+        // we prevent the application from getting its hands on a transaction controller.
+        // DERBY-6648 may help prevent that.
+        //
         try {
             LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
             DataDictionary dd = lcc.getDataDictionary();
@@ -2230,6 +2363,13 @@ public class SystemProcedures  {
          )
         throws SQLException
     {
+        try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.RESET_PASSWORD );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+
         resetAuthorizationIDPassword( normalizeUserName( userName ), password );
     }
 
@@ -2294,6 +2434,10 @@ public class SystemProcedures  {
         userName = normalizeUserName( userName );
             
         try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.DROP_USER );
+            
             LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
             DataDictionary dd = lcc.getDataDictionary();
             String  dbo = dd.getAuthorizationDatabaseOwner();
diff --git a/java/engine/org/apache/derby/iapi/db/ConsistencyChecker.java b/java/engine/org/apache/derby/iapi/db/ConsistencyChecker.java
index 1ddb7040c..e88851276 100644
--- a/java/engine/org/apache/derby/iapi/db/ConsistencyChecker.java
+++ b/java/engine/org/apache/derby/iapi/db/ConsistencyChecker.java
@@ -24,6 +24,9 @@ package org.apache.derby.iapi.db;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.error.PublicAPI;
 
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
+
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
 import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
@@ -135,6 +138,9 @@ public class ConsistencyChecker
 		tc = lcc.getTransactionExecute();
 
 		try {
+            // make sure that application code doesn't bypass security checks
+            // by calling this public entry point
+            SecurityUtil.authorize( Securable.CHECK_TABLE );           
 
             dd = lcc.getDataDictionary();
 
diff --git a/java/engine/org/apache/derby/iapi/db/PropertyInfo.java b/java/engine/org/apache/derby/iapi/db/PropertyInfo.java
index 29dbf58d0..c238f325b 100644
--- a/java/engine/org/apache/derby/iapi/db/PropertyInfo.java
+++ b/java/engine/org/apache/derby/iapi/db/PropertyInfo.java
@@ -24,6 +24,9 @@ package org.apache.derby.iapi.db;
 import org.apache.derby.iapi.error.PublicAPI;
 import org.apache.derby.iapi.error.StandardException;
 
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
+
 import org.apache.derby.iapi.sql.Activation;
 import org.apache.derby.iapi.sql.conn.Authorizer;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
@@ -47,6 +50,7 @@ public final class PropertyInfo
 
 	/**
 		Set or delete the value of a property of the database on the current connection.
+        For security reasons (see DERBY-6616), this code is duplicated in SystemProcedures.
 
 		@param key the property key
 		@param value the new value, if null the property is deleted.
@@ -59,6 +63,8 @@ public final class PropertyInfo
 		LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
 
 		try {
+            SecurityUtil.authorize( Securable.SET_DATABASE_PROPERTY );
+            
 		Authorizer a = lcc.getAuthorizer();
 		a.authorize((Activation) null, Authorizer.PROPERTY_WRITE_OP);
 
diff --git a/java/engine/org/apache/derby/iapi/security/Securable.java b/java/engine/org/apache/derby/iapi/security/Securable.java
new file mode 100644
index 000000000..b547a386c
--- /dev/null
+++ b/java/engine/org/apache/derby/iapi/security/Securable.java
@@ -0,0 +1,281 @@
+/*
+
+   Derby - Class org.apache.derby.iapi.security.Securable
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.iapi.security;
+
+import org.apache.derby.catalog.AliasInfo;
+import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
+
+/**
+ * Operations which can be secured. SQL authorization is one way to control
+ * who can access these operations.
+ */
+public enum Securable
+{
+        SET_DATABASE_PROPERTY
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_SET_DATABASE_PROPERTY",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        GET_DATABASE_PROPERTY
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_GET_DATABASE_PROPERTY",
+             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
+             ),
+            
+        FREEZE_DATABASE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_FREEZE_DATABASE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        UNFREEZE_DATABASE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_UNFREEZE_DATABASE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        CHECKPOINT_DATABASE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_CHECKPOINT_DATABASE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        BACKUP_DATABASE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_BACKUP_DATABASE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        BACKUP_DATABASE_NOWAIT
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_BACKUP_DATABASE_NOWAIT",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        DISABLE_LOG_ARCHIVE_MODE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_DISABLE_LOG_ARCHIVE_MODE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        CHECK_TABLE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_CHECK_TABLE",
+             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
+             ),
+            
+        INSTALL_JAR
+            (
+             SchemaDescriptor.SQLJ_SCHEMA_UUID,
+             "INSTALL_JAR",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        REPLACE_JAR
+            (
+             SchemaDescriptor.SQLJ_SCHEMA_UUID,
+             "REPLACE_JAR",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        REMOVE_JAR
+            (
+             SchemaDescriptor.SQLJ_SCHEMA_UUID,
+             "REMOVE_JAR",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        EXPORT_TABLE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_EXPORT_TABLE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        IMPORT_TABLE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_IMPORT_TABLE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        IMPORT_TABLE_LOBS_FROM_EXTFILE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        IMPORT_DATA
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_IMPORT_DATA",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        IMPORT_DATA_LOBS_FROM_EXTFILE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        BULK_INSERT
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_BULK_INSERT",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        RELOAD_SECURITY_POLICY
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_RELOAD_SECURITY_POLICY",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        SET_USER_ACCESS
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_SET_USER_ACCESS",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        GET_USER_ACCESS
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_GET_USER_ACCESS",
+             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
+             ),
+            
+        INVALIDATE_STORED_STATEMENTS
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_INVALIDATE_STORED_STATEMENTS",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        EMPTY_STATEMENT_CACHE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_EMPTY_STATEMENT_CACHE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        SET_XPLAIN_MODE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_SET_XPLAIN_MODE",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        GET_XPLAIN_MODE
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_GET_XPLAIN_MODE",
+             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
+             ),
+            
+        SET_XPLAIN_SCHEMA
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_SET_XPLAIN_SCHEMA",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        GET_XPLAIN_SCHEMA
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_GET_XPLAIN_SCHEMA",
+             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
+             ),
+            
+        CREATE_USER
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_CREATE_USER",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        RESET_PASSWORD
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_RESET_PASSWORD",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+        DROP_USER
+            (
+             SchemaDescriptor.SYSCS_UTIL_SCHEMA_UUID,
+             "SYSCS_DROP_USER",
+             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
+             ),
+            
+            ;
+
+        /** UUID string of schema holding the system routine associated with the operation */
+        public  final   String  routineSchemaID;
+
+        /** Name of the associated system routine */
+        public  final   String  routineName;
+        
+        /** Type of routine (function or procedure) */
+        public  final   char    routineType;
+
+        /** Construct a Securable from its attributes */
+        private Securable
+            (
+             String routineSchemaID,
+             String routineName,
+             char   routineType
+             )
+        {
+            this.routineSchemaID = routineSchemaID;
+            this.routineName = routineName;
+            this.routineType = routineType;
+        }
+
+}
diff --git a/java/engine/org/apache/derby/iapi/security/SecurityUtil.java b/java/engine/org/apache/derby/iapi/security/SecurityUtil.java
index 3ce3aab2f..34e381976 100644
--- a/java/engine/org/apache/derby/iapi/security/SecurityUtil.java
+++ b/java/engine/org/apache/derby/iapi/security/SecurityUtil.java
@@ -21,6 +21,7 @@
 
 package org.apache.derby.iapi.security;
 
+import java.util.ArrayList;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -35,9 +36,16 @@ import java.security.Permission;
 import javax.security.auth.Subject;
 
 import org.apache.derby.authentication.SystemPrincipal;
-import org.apache.derby.iapi.util.IdUtil;
+import org.apache.derby.catalog.AliasInfo;
 import org.apache.derby.iapi.error.StandardException;
-
+import org.apache.derby.iapi.services.context.ContextService;
+import org.apache.derby.iapi.sql.conn.Authorizer;
+import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
+import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
+import org.apache.derby.iapi.sql.dictionary.DataDictionary;
+import org.apache.derby.iapi.sql.dictionary.StatementPermission;
+import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
+import org.apache.derby.iapi.util.IdUtil;
 
 /**
  * This class provides helper functions for security-related features.
@@ -164,4 +172,36 @@ public class SecurityUtil {
         final Subject subject = createSystemPrincipalSubject(user);
         checkSubjectHasPermission(subject, perm);
     }
+
+    /**
+     * Raise an exception if the current user does not have permission
+     * to perform the indicated operation.
+     */
+    public  static  void    authorize( Securable operation )
+        throws StandardException
+    {
+        LanguageConnectionContext lcc = (LanguageConnectionContext)
+				ContextService.getContextOrNull( LanguageConnectionContext.CONTEXT_ID );
+
+        if ( lcc.usesSqlAuthorization() )
+        {
+            Authorizer   authorizer = lcc.getAuthorizer();
+
+            DataDictionary dd = lcc.getDataDictionary();
+            AliasDescriptor ad = dd.getRoutineList
+                (
+                 operation.routineSchemaID,
+                 operation.routineName,
+                 operation.routineType
+                 ).get( 0 );
+            ArrayList<StatementPermission>   requiredPermissions = new ArrayList<StatementPermission>();
+            StatementRoutinePermission  executePermission = new StatementRoutinePermission( ad.getObjectID() );
+
+            requiredPermissions.add( executePermission );
+
+            authorizer.authorize( requiredPermissions, lcc.getLastActivation() );
+        }
+    }
+
+
 }
diff --git a/java/engine/org/apache/derby/iapi/sql/conn/Authorizer.java b/java/engine/org/apache/derby/iapi/sql/conn/Authorizer.java
index e95b528e4..a7d011e64 100644
--- a/java/engine/org/apache/derby/iapi/sql/conn/Authorizer.java
+++ b/java/engine/org/apache/derby/iapi/sql/conn/Authorizer.java
@@ -21,8 +21,12 @@
 
 package org.apache.derby.iapi.sql.conn;
 
+import java.util.List;
+
 import org.apache.derby.iapi.sql.Activation;
+import org.apache.derby.iapi.sql.dictionary.StatementPermission;
 import org.apache.derby.iapi.error.StandardException;
+
 /**
   The Authorizer verifies a connected user has the authorization 
   to perform a requested database operation using the current
@@ -122,6 +126,21 @@ public interface Authorizer
 	public void authorize(Activation activation, int operation)
 				throws StandardException;
 
+	/**
+	  Verify the connected user possesses the indicated permissions
+
+	  @param requiredPermissionsList    the required permissions
+	  @param activation holds the execution logic
+
+	  @exception StandardException Thrown if the operation is not allowed
+	*/
+	public void authorize
+        (
+         List<StatementPermission> requiredPermissionsList,
+         Activation activation
+         )
+        throws StandardException;
+
    /**
 	 Get the readOnly status for this authorizer's connection.
 	 */
diff --git a/java/engine/org/apache/derby/impl/load/Export.java b/java/engine/org/apache/derby/impl/load/Export.java
index f1c679f29..949fb7684 100644
--- a/java/engine/org/apache/derby/impl/load/Export.java
+++ b/java/engine/org/apache/derby/impl/load/Export.java
@@ -31,7 +31,8 @@ import org.apache.derby.iapi.error.PublicAPI;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.services.io.FileUtil;
-
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
 
 /**
  * This class provides ways to export data from
@@ -182,6 +183,12 @@ public class Export extends ExportAbstract{
 							  String columnDelimeter, String characterDelimeter,
 							  String codeset)
 		throws SQLException {
+
+        /** Make sure that the current user has permission to perform this operation */
+        try {
+            SecurityUtil.authorize( Securable.EXPORT_TABLE );
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
 		
 		Export fex = new Export(con, schemaName, tableName, null,
 										outputFileName,	characterDelimeter,   
diff --git a/java/engine/org/apache/derby/impl/load/Import.java b/java/engine/org/apache/derby/impl/load/Import.java
index f1f4931f2..b233e684b 100644
--- a/java/engine/org/apache/derby/impl/load/Import.java
+++ b/java/engine/org/apache/derby/impl/load/Import.java
@@ -30,6 +30,8 @@ import java.util.*;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.error.PublicAPI;
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
 import org.apache.derby.iapi.util.IdUtil;
 import org.apache.derby.iapi.util.StringUtil;
 
@@ -123,6 +125,19 @@ public class Import extends ImportAbstract{
 		throws SQLException {
 
 
+        /** Make sure that the current user has permission to perform this operation */
+        try {
+            if ( lobsInExtFile )
+            {
+                SecurityUtil.authorize( Securable.IMPORT_TABLE_LOBS_FROM_EXTFILE );
+            }
+            else
+            {
+                SecurityUtil.authorize( Securable.IMPORT_TABLE );
+            }
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
+		
 		performImport(connection,  schemaName,  null, //No columnList 
 					  null , //No column indexes
 					  tableName, inputFileName, columnDelimiter, 
@@ -161,7 +176,18 @@ public class Import extends ImportAbstract{
                                   boolean lobsInExtFile)
 		throws SQLException 
 	{
-		
+        /** Make sure that the current user has permission to perform this operation */
+        try {
+            if ( lobsInExtFile )
+            {
+                SecurityUtil.authorize( Securable.IMPORT_DATA_LOBS_FROM_EXTFILE );
+            }
+            else
+            {
+                SecurityUtil.authorize( Securable.IMPORT_DATA );
+            }
+        }
+        catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
 
 			performImport(connection,  schemaName,  insertColumnList,columnIndexes, 
 						  tableName, inputFileName, columnDelimiter, 
diff --git a/java/engine/org/apache/derby/impl/sql/conn/GenericAuthorizer.java b/java/engine/org/apache/derby/impl/sql/conn/GenericAuthorizer.java
index a4a65b940..ba2450105 100644
--- a/java/engine/org/apache/derby/impl/sql/conn/GenericAuthorizer.java
+++ b/java/engine/org/apache/derby/impl/sql/conn/GenericAuthorizer.java
@@ -134,64 +134,79 @@ class GenericAuthorizer implements Authorizer
         {
             List<StatementPermission> requiredPermissionsList =
                 activation.getPreparedStatement().getRequiredPermissionsList();
-            DataDictionary dd = lcc.getDataDictionary();
-
-            // Database Owner can access any object. Ignore 
-            // requiredPermissionsList for Database Owner
-            if( requiredPermissionsList != null    && 
-                !requiredPermissionsList.isEmpty() && 
-                !lcc.getCurrentUserId(activation).equals(
-                    dd.getAuthorizationDatabaseOwner()))
-            {
-                int ddMode = dd.startReading(lcc);
+
+            authorize( requiredPermissionsList, activation );
+        }
+    }
+
+	public void authorize
+        (
+         List<StatementPermission> requiredPermissionsList,
+         Activation activation
+         )
+        throws StandardException
+    {
+        DataDictionary dd = lcc.getDataDictionary();
+
+        // Database Owner can access any object. Ignore 
+        // requiredPermissionsList for Database Owner
+        if( requiredPermissionsList != null    && 
+            !requiredPermissionsList.isEmpty() && 
+            !lcc.getCurrentUserId(activation).equals(
+                                                     dd.getAuthorizationDatabaseOwner()))
+        {
+            int ddMode = dd.startReading(lcc);
                 
-                 /*
-                  * The system may need to read the permission descriptor(s) 
-                  * from the system table(s) if they are not available in the 
-                  * permission cache.  So start an internal read-only nested 
-                  * transaction for this.
-                  * 
-                  * The reason to use a nested transaction here is to not hold
-                  * locks on system tables on a user transaction.  e.g.:  when
-                  * attempting to revoke an user, the statement may time out
-                  * since the user-to-be-revoked transaction may have acquired 
-                  * shared locks on the permission system tables; hence, this
-                  * may not be desirable.  
-                  * 
-                  * All locks acquired by StatementPermission object's check()
-                  * method will be released when the system ends the nested 
-                  * transaction.
-                  * 
-                  * In Derby, the locks from read nested transactions come from
-                  * the same space as the parent transaction; hence, they do not
-                  * conflict with parent locks.
-                  */  
-                lcc.beginNestedTransaction(true);
+            /*
+             * The system may need to read the permission descriptor(s) 
+             * from the system table(s) if they are not available in the 
+             * permission cache.  So start an internal read-only nested 
+             * transaction for this.
+             * 
+             * The reason to use a nested transaction here is to not hold
+             * locks on system tables on a user transaction.  e.g.:  when
+             * attempting to revoke an user, the statement may time out
+             * since the user-to-be-revoked transaction may have acquired 
+             * shared locks on the permission system tables; hence, this
+             * may not be desirable.  
+             * 
+             * All locks acquired by StatementPermission object's check()
+             * method will be released when the system ends the nested 
+             * transaction.
+             * 
+             * In Derby, the locks from read nested transactions come from
+             * the same space as the parent transaction; hence, they do not
+             * conflict with parent locks.
+             */  
+            lcc.beginNestedTransaction(true);
             	
+            try 
+            {
                 try 
                 {
-                    try 
+                    // perform the permission checking
+                    for (StatementPermission rp : requiredPermissionsList)
                     {
-                    	// perform the permission checking
-                        for (StatementPermission rp : requiredPermissionsList)
-                        {
-                            rp.check(lcc, false, activation);
-                        }
-                    } 
-                    finally 
-                    {
-                        dd.doneReading(ddMode, lcc);
+                        rp.check(lcc, false, activation);
                     }
                 } 
                 finally 
                 {
-                	// make sure we commit; otherwise, we will end up with 
-                	// mismatch nested level in the language connection context.
-                    lcc.commitNestedTransaction();
+                    dd.doneReading(ddMode, lcc);
                 }
+            } 
+            finally 
+            {
+                // make sure we commit; otherwise, we will end up with 
+                // mismatch nested level in the language connection context.
+                lcc.commitNestedTransaction();
             }
         }
     }
+    
+    /**
+     * Throw an exception if the user does not have all of the required permissions.
+     */
 
 	private static StandardException externalRoutineException(int operation, int sqlAllowed) {
 
diff --git a/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java b/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
index 5c9265e7d..cdbb4a53a 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
@@ -37,6 +37,8 @@ import org.apache.derby.catalog.UUID;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.Property;
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
 import org.apache.derby.iapi.services.context.ContextService;
 import org.apache.derby.iapi.services.io.FileUtil;
 import org.apache.derby.iapi.services.loader.ClassFactory;
@@ -97,6 +99,10 @@ public class JarUtil
             String schemaName, String sqlName, String externalPath)
 		 throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.INSTALL_JAR );
+            
 		JarUtil jutil = new JarUtil(lcc, schemaName, sqlName);
 		InputStream is = null;
 		
@@ -166,6 +172,10 @@ public class JarUtil
 	drop(LanguageConnectionContext lcc, String schemaName, String sqlName)
 		 throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.REMOVE_JAR );
+            
 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
 		jutil.drop();
 	}
@@ -243,6 +253,10 @@ public class JarUtil
 			String externalPath)
 		 throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.REPLACE_JAR );
+            
 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
 		InputStream is = null;
 		
diff --git a/java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java b/java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java
index 588fc0cec..121eaf3fc 100644
--- a/java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java
+++ b/java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java
@@ -21,6 +21,9 @@
 
 package org.apache.derby.impl.store.access;
 
+import org.apache.derby.iapi.security.Securable;
+import org.apache.derby.iapi.security.SecurityUtil;
+
 import org.apache.derby.iapi.services.cache.Cacheable;
 import org.apache.derby.iapi.services.cache.CacheableFactory;
 import org.apache.derby.iapi.services.cache.CacheFactory;
@@ -929,11 +932,19 @@ public abstract class RAMAccessManager
 
 	public void freeze() throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.FREEZE_DATABASE );
+            
 		rawstore.freeze();
 	}
 
 	public void unfreeze() throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.UNFREEZE_DATABASE );
+            
 		rawstore.unfreeze();
 	}
 
@@ -942,6 +953,14 @@ public abstract class RAMAccessManager
     boolean wait) 
         throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize
+            (
+             wait ?
+             Securable.BACKUP_DATABASE :
+             Securable.BACKUP_DATABASE_NOWAIT
+             );
 		rawstore.backup(backupDir, wait);
 	}
 
@@ -952,6 +971,14 @@ public abstract class RAMAccessManager
     boolean wait)
 		throws StandardException 
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize
+            (
+             wait ?
+             Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE :
+             Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT
+             );
 		rawstore.backupAndEnableLogArchiveMode(backupDir, 
                                                deleteOnlineArchivedLogFiles, 
                                                wait);
@@ -960,6 +987,10 @@ public abstract class RAMAccessManager
 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
 		throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.DISABLE_LOG_ARCHIVE_MODE );
+            
 		rawstore.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
 	}
 
@@ -967,6 +998,10 @@ public abstract class RAMAccessManager
 
 	public void checkpoint() throws StandardException
 	{
+        // make sure that application code doesn't bypass security checks
+        // by calling this public entry point
+        SecurityUtil.authorize( Securable.CHECKPOINT_DATABASE );
+            
 		rawstore.checkpoint();
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DBOAccessTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DBOAccessTest.java
index 2e562cb95..6e2a498da 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DBOAccessTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/DBOAccessTest.java
@@ -21,13 +21,18 @@
 
 package org.apache.derbyTesting.functionTests.tests.lang;
 
+import java.security.AccessControlException;
+import java.sql.CallableStatement;
 import java.sql.Connection;
+import java.sql.SQLException;
 import junit.framework.Test;
 import org.apache.derbyTesting.junit.BaseTestSuite;
 import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
 import org.apache.derbyTesting.junit.SupportFilesSetup;
 import org.apache.derbyTesting.junit.TestConfiguration;
 
+import org.apache.derby.catalog.SystemProcedures;
+
 /**
  * Tests that certain operations can only be performed by the DBO.
  */
@@ -48,6 +53,45 @@ public class DBOAccessTest extends GeneratedColumnsHelper
 
     private static  final   String      ONLY_DBO = "4251D";
     private static  final   String      HIDDEN_COLUMN = "4251E";
+    private static  final   String      NULL_BACKUP_DIRECTORY = "XSRS6";
+    private static  final   String      FIRST_CREDENTIALS = "4251K";
+    private static  final   String      MISSING_OBJECT = "X0X13";
+    private static  final   String      MISSING_TABLE = "42X05";
+    private static  final   String      NO_SUCH_TABLE = "XIE0M";
+    private static  final   String      UNKNOWN_USER = "XK001";
+
+    private static  final   String      SYSCS_SET_DATABASE_PROPERTY = "SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY";
+    private static  final   String      SYSCS_GET_DATABASE_PROPERTY = "SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY";
+    private static  final   String      SYSCS_FREEZE_DATABASE = "SYSCS_UTIL.SYSCS_FREEZE_DATABASE";
+    private static  final   String      SYSCS_UNFREEZE_DATABASE = "SYSCS_UTIL.SYSCS_UNFREEZE_DATABASE";
+    private static  final   String      SYSCS_CHECKPOINT_DATABASE = "SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE";
+    private static  final   String      SYSCS_BACKUP_DATABASE = "SYSCS_UTIL.SYSCS_BACKUP_DATABASE";
+    private static  final   String      SYSCS_BACKUP_DATABASE_NOWAIT = "SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT";
+    private static  final   String      SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE = "SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE";
+    private static  final   String      SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT = "SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT";
+    private static  final   String      SYSCS_DISABLE_LOG_ARCHIVE_MODE = "SYSCS_UTIL.SYSCS_DISABLE_LOG_ARCHIVE_MODE";
+    private static  final   String      SYSCS_CHECK_TABLE = "SYSCS_UTIL.SYSCS_CHECK_TABLE";
+    private static  final   String      INSTALL_JAR = "SQLJ.INSTALL_JAR";
+    private static  final   String      REPLACE_JAR = "SQLJ.REPLACE_JAR";
+    private static  final   String      REMOVE_JAR = "SQLJ.REMOVE_JAR";
+    private static  final   String      SYSCS_EXPORT_TABLE = "SYSCS_UTIL.SYSCS_EXPORT_TABLE";
+    private static  final   String      SYSCS_IMPORT_TABLE = "SYSCS_UTIL.SYSCS_IMPORT_TABLE";
+    private static  final   String      SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE = "SYSCS_UTIL.SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE";
+    private static  final   String      SYSCS_IMPORT_DATA = "SYSCS_UTIL.SYSCS_IMPORT_DATA";
+    private static  final   String      SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE = "SYSCS_UTIL.SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE";
+    private static  final   String      SYSCS_BULK_INSERT = "SYSCS_UTIL.SYSCS_BULK_INSERT";
+    private static  final   String      SYSCS_RELOAD_SECURITY_POLICY = "SYSCS_UTIL.SYSCS_RELOAD_SECURITY_POLICY";
+    private static  final   String      SYSCS_SET_USER_ACCESS = "SYSCS_UTIL.SYSCS_SET_USER_ACCESS";
+    private static  final   String      SYSCS_GET_USER_ACCESS = "SYSCS_UTIL.SYSCS_GET_USER_ACCESS";
+    private static  final   String      SYSCS_INVALIDATE_STORED_STATEMENTS = "SYSCS_UTIL.SYSCS_INVALIDATE_STORED_STATEMENTS";
+    private static  final   String      SYSCS_EMPTY_STATEMENT_CACHE = "SYSCS_UTIL.SYSCS_EMPTY_STATEMENT_CACHE";
+    private static  final   String      SYSCS_SET_XPLAIN_MODE = "SYSCS_UTIL.SYSCS_SET_XPLAIN_MODE";
+    private static  final   String      SYSCS_GET_XPLAIN_MODE = "SYSCS_UTIL.SYSCS_GET_XPLAIN_MODE";
+    private static  final   String      SYSCS_SET_XPLAIN_SCHEMA = "SYSCS_UTIL.SYSCS_SET_XPLAIN_SCHEMA";
+    private static  final   String      SYSCS_GET_XPLAIN_SCHEMA = "SYSCS_UTIL.SYSCS_GET_XPLAIN_SCHEMA";
+    private static  final   String      SYSCS_CREATE_USER = "SYSCS_UTIL.SYSCS_CREATE_USER";
+    private static  final   String      SYSCS_RESET_PASSWORD = "SYSCS_UTIL.SYSCS_RESET_PASSWORD";
+    private static  final   String      SYSCS_DROP_USER = "SYSCS_UTIL.SYSCS_DROP_USER";
 
     ///////////////////////////////////////////////////////////////////////////////////
     //
@@ -234,8 +278,320 @@ public class DBOAccessTest extends GeneratedColumnsHelper
         }
     }
 
-}
+    /**
+     * <p>
+     * Tests that you can't subvert sql authorization by directly calling
+     * the entry points in SystemProcedures.
+     * </p>
+     */
+    public  void    test_6616() throws Exception
+    {
+        Connection  dboConnection = openUserConnection( TEST_DBO );
+        Connection  janetConnection = openUserConnection( JANET );
 
+        goodStatement
+            (
+             dboConnection,
+             "create procedure runSystemRoutine( routineName varchar( 32672 ) )\n" +
+             "language java parameter style java modifies sql data\n" +
+             "external name 'org.apache.derbyTesting.functionTests.tests.lang.DBOAccessTest.runSystemRoutine'\n"
+             );
+        if ( authorizationIsOn() )
+        {
+            goodStatement
+                (
+                 dboConnection,
+                 "grant execute on procedure runSystemRoutine to public"
+                 );
+        }
+
+        vet6616( dboConnection, janetConnection, SYSCS_SET_DATABASE_PROPERTY, false );
+        vet6616( dboConnection, janetConnection, SYSCS_GET_DATABASE_PROPERTY, true );
+        vet6616( dboConnection, janetConnection, SYSCS_FREEZE_DATABASE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_UNFREEZE_DATABASE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_CHECKPOINT_DATABASE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_BACKUP_DATABASE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_BACKUP_DATABASE_NOWAIT, false );
+        vet6616( dboConnection, janetConnection, SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT, false );
+        vet6616( dboConnection, janetConnection, SYSCS_DISABLE_LOG_ARCHIVE_MODE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_CHECK_TABLE, true );
+        vet6616( dboConnection, janetConnection, INSTALL_JAR, false );
+        vet6616( dboConnection, janetConnection, REPLACE_JAR, false );
+        vet6616( dboConnection, janetConnection, REMOVE_JAR, false );
+        vet6616( dboConnection, janetConnection, SYSCS_EXPORT_TABLE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_IMPORT_TABLE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_IMPORT_DATA, false );
+        vet6616( dboConnection, janetConnection, SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_BULK_INSERT, false );
+        vet6616( dboConnection, janetConnection, SYSCS_RELOAD_SECURITY_POLICY, false );
+        vet6616( dboConnection, janetConnection, SYSCS_SET_USER_ACCESS, false );
+        vet6616( dboConnection, janetConnection, SYSCS_GET_USER_ACCESS, true );
+        vet6616( dboConnection, janetConnection, SYSCS_INVALIDATE_STORED_STATEMENTS, false );
+        vet6616( dboConnection, janetConnection, SYSCS_EMPTY_STATEMENT_CACHE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_SET_XPLAIN_MODE, false );
+        vet6616( dboConnection, janetConnection, SYSCS_GET_XPLAIN_MODE, true );
+        vet6616( dboConnection, janetConnection, SYSCS_SET_XPLAIN_SCHEMA, false );
+        vet6616( dboConnection, janetConnection, SYSCS_GET_XPLAIN_SCHEMA, true );
+        vet6616( dboConnection, janetConnection, SYSCS_CREATE_USER, false );
+        vet6616( dboConnection, janetConnection, SYSCS_RESET_PASSWORD, false );
+        vet6616( dboConnection, janetConnection, SYSCS_DROP_USER, false );
+    }
+    private void    vet6616
+        ( Connection dboConnection, Connection janetConnection, String routineName, boolean isFunction )
+        throws Exception
+    {
+        vet6616( dboConnection, true, routineName );
+        vet6616( janetConnection, !authorizationIsOn(), routineName );
+
+        if ( authorizationIsOn() )
+        {
+            boolean isFreeze = SYSCS_FREEZE_DATABASE.equals( routineName );
+            String  routineType = isFunction ? "function" : "procedure";
+            goodStatement( dboConnection, "grant execute on " + routineType + " " + routineName + " to public" );
+
+            if ( isFreeze )
+            {
+                goodStatement( dboConnection, "grant execute on " + routineType + " " + SYSCS_UNFREEZE_DATABASE + " to public" );
+            }
+        
+            vet6616( janetConnection, true, routineName );
+            
+            goodStatement( dboConnection, "revoke execute on " + routineType + " " + routineName + " from public restrict" );
+
+            if ( isFreeze )
+            {
+                goodStatement
+                    ( dboConnection, "revoke execute on " + routineType + " " + SYSCS_UNFREEZE_DATABASE + " from public restrict" );
+            }
+        }
+    }
+    private void    vet6616( Connection conn, boolean shouldSucceed, String routineName )
+        throws Exception
+    {
+        CallableStatement   cs = conn.prepareCall( "call test_dbo.runSystemRoutine( ? )" );
+        cs.setString( 1, routineName );
+
+        try {
+            cs.execute();
+            if ( !shouldSucceed ) { fail( routineName + " should have failed!" ); }
+        }
+        catch (SQLException se)
+        {
+            if ( shouldSucceed ) { fail( routineName + " should have succeeded: " + se.getSQLState() + " " + se.getMessage() ); }
+            else
+            {
+                assertSQLState( LACK_EXECUTE_PRIV, se );
+            }
+        }
+    }
 
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // SQL ROUTINES
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
 
+    /** Run various system procedures and functions by calling them directly */
+    public  static  void    runSystemRoutine( String routineName )
+        throws Exception
+    {
+        if ( SYSCS_SET_DATABASE_PROPERTY.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_SET_DATABASE_PROPERTY( "foo.bar.wibble", "wibble.bar.foo" );
+        }
+        else if ( SYSCS_GET_DATABASE_PROPERTY.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_GET_DATABASE_PROPERTY( "la.dee.dah" );
+        }
+        else if ( SYSCS_FREEZE_DATABASE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_FREEZE_DATABASE();
 
+            // if that succeeded, then unfreeze the database immediately
+            SystemProcedures.SYSCS_UNFREEZE_DATABASE();
+        }
+        else if ( SYSCS_UNFREEZE_DATABASE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_UNFREEZE_DATABASE();
+        }
+        else if ( SYSCS_CHECKPOINT_DATABASE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_CHECKPOINT_DATABASE();
+        }
+        else if ( SYSCS_BACKUP_DATABASE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_BACKUP_DATABASE( null );
+            }
+            catch (SQLException se) { vetError( NULL_BACKUP_DIRECTORY, se ); }
+        }
+        else if ( SYSCS_BACKUP_DATABASE_NOWAIT.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_BACKUP_DATABASE_NOWAIT( null );
+            }
+            catch (SQLException se) { vetError( NULL_BACKUP_DIRECTORY, se ); }
+        }
+        else if (SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE( null, (short) 0 );
+            }
+            catch (SQLException se) { vetError( NULL_BACKUP_DIRECTORY, se ); }
+        }
+        else if (SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT( null, (short) 0 );
+            }
+            catch (SQLException se) { vetError( NULL_BACKUP_DIRECTORY, se ); }
+        }
+        else if ( SYSCS_DISABLE_LOG_ARCHIVE_MODE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_DISABLE_LOG_ARCHIVE_MODE( (short) 0 );
+        }
+        else if ( SYSCS_CHECK_TABLE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_CHECK_TABLE( "SYS", "SYSTABLES" );
+        }
+        else if (INSTALL_JAR.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.INSTALL_JAR( "foo", "bar", 1 );
+            }
+            catch (AccessControlException se) { println( "Caught expected AccessControlException" ); }
+        }
+        else if (REPLACE_JAR.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.REPLACE_JAR( "foo", "bar" );
+            }
+            catch (AccessControlException se) { println( "Caught expected AccessControlException" ); }
+        }
+        else if (REMOVE_JAR.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.REMOVE_JAR( "test_dbo.foo", 0 );
+            }
+            catch (SQLException se) { vetError( MISSING_OBJECT, se ); }
+        }
+        else if ( SYSCS_EXPORT_TABLE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_EXPORT_TABLE( "TEST_DBO", "BAR", "WIBBLE", null, null, null );
+            }
+            catch (SQLException se) { vetError( JAVA_EXCEPTION, se ); }
+        }
+        else if ( SYSCS_IMPORT_TABLE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_IMPORT_TABLE( "TEST_DBO", "BAR", "WIBBLE", null, null, null, (short) 1 );
+            }
+            catch (SQLException se) { vetError( NO_SUCH_TABLE, se ); }
+        }
+        else if ( SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE( "TEST_DBO", "BAR", "WIBBLE", null, null, null, (short) 1 );
+            }
+            catch (SQLException se) { vetError( NO_SUCH_TABLE, se ); }
+        }
+        else if ( SYSCS_IMPORT_DATA.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_IMPORT_DATA
+                    ( "TEST_DBO", "BAR", null, "1,3,4", "WIBBLE", null, null, null, (short) 1 );
+            }
+            catch (SQLException se) { vetError( NO_SUCH_TABLE, se ); }
+        }
+        else if ( SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE
+                    ( "TEST_DBO", "BAR", null, "1,3,4", "WIBBLE", null, null, null, (short) 1 );
+            }
+            catch (SQLException se) { vetError( NO_SUCH_TABLE, se ); }
+        }
+        else if ( SYSCS_BULK_INSERT.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_BULK_INSERT
+                    ( "TEST_DBO", "BAR", "WIBBLE", "wombat" );
+            }
+            catch (SQLException se) { vetError( SYNTAX_ERROR, se ); }
+        }
+        else if ( SYSCS_RELOAD_SECURITY_POLICY.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_RELOAD_SECURITY_POLICY();
+        }
+        else if ( SYSCS_SET_USER_ACCESS.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_SET_USER_ACCESS( "FOO", "FULLACCESS" );
+        }
+        else if ( SYSCS_GET_USER_ACCESS.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_GET_USER_ACCESS( "FOO" );
+        }
+        else if ( SYSCS_INVALIDATE_STORED_STATEMENTS.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_INVALIDATE_STORED_STATEMENTS();
+        }
+        else if ( SYSCS_EMPTY_STATEMENT_CACHE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_EMPTY_STATEMENT_CACHE();
+        }
+        else if ( SYSCS_SET_XPLAIN_MODE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_SET_XPLAIN_MODE( 0 );
+        }
+        else if ( SYSCS_GET_XPLAIN_MODE.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_GET_XPLAIN_MODE();
+        }
+        else if ( SYSCS_SET_XPLAIN_SCHEMA.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_SET_XPLAIN_SCHEMA( "" );
+        }
+        else if ( SYSCS_GET_XPLAIN_SCHEMA.equals( routineName ) )
+        {
+            SystemProcedures.SYSCS_GET_XPLAIN_SCHEMA();
+        }
+        else if (SYSCS_CREATE_USER.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_CREATE_USER( "foo", "bar" );
+            }
+            catch (SQLException se) { vetError( FIRST_CREDENTIALS, se ); }
+        }
+        else if (SYSCS_RESET_PASSWORD.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_RESET_PASSWORD( "foo", "bar" );
+            }
+            catch (SQLException se) { vetError( UNKNOWN_USER, se ); }
+        }
+        else if (SYSCS_DROP_USER.equals( routineName ) )
+        {
+            try {
+                SystemProcedures.SYSCS_DROP_USER( "foo" );
+            }
+            catch (SQLException se) { vetError( UNKNOWN_USER, se ); }
+        }
+        else
+        {
+            throw new Exception( "Unknown routine name: " + routineName );
+        }
+    }
+    private static  void    vetError( String sqlState, SQLException se )
+        throws SQLException
+    {
+        if ( sqlState.equals( se.getSQLState() ) )
+        {
+            println( "Caught expected error: " + sqlState );
+        }
+        else { throw se; }
+    }
+
+}
