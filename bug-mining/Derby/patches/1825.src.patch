diff --git a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
index 24110e1db..0c6d65a68 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
+++ b/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
@@ -1638,7 +1638,16 @@ public class PredicateList extends QueryTreeNodeVector implements OptimizablePre
 		for (Enumeration e = colRefs.elements(); e.hasMoreElements(); )
 		{
 			ColumnReference ref = (ColumnReference)e.nextElement();
-			ref.getSource().markAllRCsInChainReferenced();
+			ResultColumn source = ref.getSource();
+
+            // DERBY-4391: Don't try to call markAllRCsInChainReferenced() if
+            // source is null. This can happen if the ColumnReference is
+            // pointing to a column that is not from a base table. For instance
+            // if we have a VALUES clause like (VALUES (1, 2), (3, 4)) V1(I, J)
+            // then a column reference to V1.I won't have a source.
+			if (source != null) {
+				source.markAllRCsInChainReferenced();
+			}
 		}
 	}
 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/union.out b/java/testing/org/apache/derbyTesting/functionTests/master/union.out
index 324d5ab16..3afa0cf7f 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/union.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/union.out
@@ -1217,4 +1217,38 @@ drop table t1;
 0 rows inserted/updated/deleted
 ij> drop table t2;
 0 rows inserted/updated/deleted
+ij> -- Regression test for DERBY-4391. These UNION queries used to throw a
+-- NullPointerException during compilation. Now all of them should compile
+-- successfully, but some of them fail during execution if their subqueries
+-- return more than one row.
+create table d4391(a int not null primary key, b int);
+0 rows inserted/updated/deleted
+ij> insert into d4391 values (0, 4), (1, 3), (2, 2), (3, 1), (4, 0);
+5 rows inserted/updated/deleted
+ij> select * from d4391 where a < (values 2 union values 2);
+A          |B          
+-----------------------
+0          |4          
+1          |3          
+ij> select * from d4391 where a < (select 4 from d4391 union select b from d4391);
+ERROR 21000: Scalar subquery is only allowed to return a single row.
+ij> select * from d4391 where a < (select a+b from d4391 union select 4 from d4391);
+A          |B          
+-----------------------
+0          |4          
+1          |3          
+2          |2          
+3          |1          
+ij> select * from d4391 where a < (select a+b from d4391 union select a from d4391);
+ERROR 21000: Scalar subquery is only allowed to return a single row.
+ij> select * from d4391 where a < (select sum(a) from d4391 union select sum(b) from d4391);
+A          |B          
+-----------------------
+0          |4          
+1          |3          
+2          |2          
+3          |1          
+4          |0          
+ij> drop table d4391;
+0 rows inserted/updated/deleted
 ij> 
\ No newline at end of file
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/union.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/union.sql
index f96709979..1ecaaee47 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/union.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/union.sql
@@ -489,3 +489,16 @@ select * from
 -- cleanup.
 drop table t1;
 drop table t2;
+
+-- Regression test for DERBY-4391. These UNION queries used to throw a
+-- NullPointerException during compilation. Now all of them should compile
+-- successfully, but some of them fail during execution if their subqueries
+-- return more than one row.
+create table d4391(a int not null primary key, b int);
+insert into d4391 values (0, 4), (1, 3), (2, 2), (3, 1), (4, 0);
+select * from d4391 where a < (values 2 union values 2);
+select * from d4391 where a < (select 4 from d4391 union select b from d4391);
+select * from d4391 where a < (select a+b from d4391 union select 4 from d4391);
+select * from d4391 where a < (select a+b from d4391 union select a from d4391);
+select * from d4391 where a < (select sum(a) from d4391 union select sum(b) from d4391);
+drop table d4391;
