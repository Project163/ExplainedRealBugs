diff --git a/java/engine/org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java b/java/engine/org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java
index fc80625df..a825a111f 100644
--- a/java/engine/org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java
+++ b/java/engine/org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java
@@ -121,7 +121,7 @@ class GroupedAggregateResultSet extends GenericAggregateResultSet
 	private boolean resultsComplete;
 	private List<ExecRow> finishedResults;
 	private ExecIndexRow[]			resultRows;
-    private List<List<Set<String>>> distinctValues;
+    private List<List<Set<DataValueDescriptor>>> distinctValues;
 
 	private boolean rollup;
 	private boolean usingAggregateObserver = false;
@@ -239,8 +239,8 @@ class GroupedAggregateResultSet extends GenericAggregateResultSet
 				resultRows = new ExecIndexRow[1];
 			if (aggInfoList.hasDistinct())
             {
-                distinctValues =
-                        new ArrayList<List<Set<String>>>(resultRows.length);
+                distinctValues = new ArrayList<List<Set<DataValueDescriptor>>>(
+                        resultRows.length);
             }
 			for (int r = 0; r < resultRows.length; r++)
 			{
@@ -249,8 +249,8 @@ class GroupedAggregateResultSet extends GenericAggregateResultSet
 				initializeVectorAggregation(resultRows[r]);
 				if (aggInfoList.hasDistinct())
                 {
-                    distinctValues.add(
-                            new ArrayList<Set<String>>(aggregates.length));
+                    distinctValues.add(new ArrayList<Set<DataValueDescriptor>>(
+                            aggregates.length));
                     initializeDistinctMaps(r, true);
                 }
 			}
@@ -762,12 +762,24 @@ class GroupedAggregateResultSet extends GenericAggregateResultSet
             AggregatorInfo aInfo = aggInfoList.elementAt(i);
 			if (aInfo.isDistinct())
 			{
+                if (SanityManager.DEBUG) {
+                    // Distinct aggregates currently always use the sorter.
+                    // Assert that it is so.
+                    SanityManager.ASSERT(!isInSortedOrder);
+                    SanityManager.ASSERT(scanController != null);
+
+                    // If we ever start reading directly from the source
+                    // result set, we should call source.needsToClone() to
+                    // check if we need to clone the value before adding it
+                    // to the set of distinct values. Don't clone it for now.
+                }
+
 				DataValueDescriptor newValue = currAggregate.getInputColumnValue(newRow);
 				// A NULL value is always distinct, so we only
 				// have to check for duplicate values for
 				// non-NULL values.
-                String str = newValue.getString();
-                if (str != null && !distinctValues.get(level).get(i).add(str))
+                if (!newValue.isNull()
+                        && !distinctValues.get(level).get(i).add(newValue))
 				{
                     // The value was already in the set, and we only look
                     // for distinct values. Skip this value.
@@ -792,44 +804,18 @@ class GroupedAggregateResultSet extends GenericAggregateResultSet
                 // Otherwise, insert null so that the list is of the right
                 // size and the indexes match those in aggregates[].
                 distinctValues.get(r).add(aInfo.isDistinct() ?
-                        new HashSet<String>() : null);
+                        new HashSet<DataValueDescriptor>() : null);
             }
 
 			if (aInfo.isDistinct())
 			{
-                Set<String> set = distinctValues.get(r).get(a);
+                Set<DataValueDescriptor> set = distinctValues.get(r).get(a);
                 set.clear();
 				DataValueDescriptor newValue =
 					aggregates[a].getInputColumnValue(resultRows[r]);
-                set.add(newValue.getString());
+                set.add(newValue);
 			}
 		}
 	}
 
-        private void dumpAllRows(int cR)
-            throws StandardException
-        {
-            System.out.println("dumpAllRows("+cR+"/"+resultRows.length+"):");
-            for (int r = 0; r < resultRows.length; r++)
-                System.out.println(dumpRow(resultRows[r]));
-        }
-	private String dumpRow(ExecRow r)
-		throws StandardException
-	{
-            if (r == null)
-                return "<NULL ROW>";
-        StringBuilder buf = new StringBuilder();
-	    int nCols = r.nColumns();
-	    for (int d = 0; d < nCols; d++)
-	    {
-		if (d > 0) buf.append(",");
-                DataValueDescriptor o = r.getColumn(d+1);
-                buf.append(o.getString());
-                if (o instanceof ExecAggregator)
-                    buf.append("[").
-                        append(((ExecAggregator)o).getResult().getString()).
-                        append("]");
-	    }
-	    return buf.toString();
-	}
 }
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
index bfc0dcc11..52afac66a 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
@@ -76,6 +76,7 @@ public class CollationTest extends BaseJDBCTestCase {
     private final static String[] ENGLISH_CASE_INSENSITIVE = {
         "testUsingClauseAndNaturalJoin",
         "testNullColumnInInsert",
+        "testDerby6227",
     };
 
     /** Test cases to run with Norwegian case-sensitive collation. */
@@ -2264,4 +2265,29 @@ public void testMissingCollatorSupport() throws SQLException {
         assertStatementError(INVALID_ESCAPE, s,
                 "select * from d6030 where x like y escape 'aa'");
     }
+
+    /**
+     * Regression test case for DERBY-6227. Distinct grouped aggregates used
+     * to eliminate duplicates by comparing the string representation of the
+     * values using {@code String.equals()}. That does not give the right
+     * results if the database collation defines equality in a different way
+     * than {@code String.equals()}, for example when running with case
+     * insensitive collation ({@code collation=TERRITORY_BASED:PRIMARY}).
+     */
+    public void testDerby6227() throws SQLException {
+        String sql = "select i, count(distinct s) "
+                + "from (values (1, 'a'), (1, 'a'), (2, 'b'), (2, 'B'), "
+                + "(3, 'a'), (3, 'A'), (3, 'b'), (3, 'B'), (3, 'c')) v(i, s) "
+                + "group by i order by i";
+
+        // These are the expected results of the query when running with
+        // case-insensitive collation. Before the fix, the query would return
+        // (1, 1), (2, 2), (3, 5).
+        String[][] expectedRows = {
+            { "1", "1" }, { "2", "1" }, { "3", "3" }
+        };
+
+        Statement s = createStatement();
+        JDBC.assertFullResultSet(s.executeQuery(sql), expectedRows);
+    }
 }
