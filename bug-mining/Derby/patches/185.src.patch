diff --git a/java/engine/org/apache/derby/iapi/reference/SQLState.java b/java/engine/org/apache/derby/iapi/reference/SQLState.java
index 859a083a6..8958290c1 100644
--- a/java/engine/org/apache/derby/iapi/reference/SQLState.java
+++ b/java/engine/org/apache/derby/iapi/reference/SQLState.java
@@ -1160,6 +1160,10 @@ public interface SQLState {
 	String LANG_STOP_AFTER_BINDING                                     = "42Z56.U";
 	String LANG_STOP_AFTER_OPTIMIZING                                  = "42Z57.U";
 	String LANG_STOP_AFTER_GENERATING                                  = "42Z58.U";
+
+	// PARSER EXCEPTIONS
+	String LANG_UNBINDABLE_REWRITE                                     = "X0A00.S";
+	
 	// EXECUTION EXCEPTIONS
 	String LANG_CANT_LOCK_TABLE                                        = "X0X02.S";
 	String LANG_TABLE_NOT_FOUND_DURING_EXECUTION                       = "X0X05.S";
diff --git a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
index eca671067..920799fb4 100644
--- a/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
+++ b/java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj
@@ -148,6 +148,7 @@ import org.apache.derby.iapi.services.io.FormatableBitSet;
 import org.apache.derby.iapi.util.StringUtil;
 
 import java.sql.Types;
+import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
 import java.lang.Character;
@@ -310,6 +311,89 @@ public class SQLParser
 				version, feature);
 	}
 
+	/*
+	** Make sure that a select list in a parser-rewritten tree does
+	** not contain two columns by the same name. This is the patch
+	** to bug 280. In this case, the bind phase cannot tell the
+	** difference between the two columns and so the query may
+	** return wrong results.
+	**
+	** This issue is caused by parser rewriting of group by/having clauses
+	** into table expressions. (See function tableExpression() in this file)
+	** There is an improvement request filed under DERBY-681 to eliminate this
+	** rewrite, after which it should be possible to allow multiple columns to
+	** have same name in the select list.
+	*/
+	private	void	vetSelectList280( ResultColumnList selectList )
+		throws StandardException
+	{
+		Hashtable	allNames = new Hashtable();
+		int			count = selectList.size();
+
+		for ( int i = 0; i < count; i++ )
+		{
+			ResultColumn	rc = (ResultColumn) selectList.elementAt( i );
+			String			duplicateName = ambiguousDuplicateName( allNames, rc );
+
+			if ( duplicateName != null )
+			{
+				throw StandardException.newException
+				( SQLState.LANG_UNBINDABLE_REWRITE, duplicateName );
+			}
+
+		}
+	}
+
+	// allow two references to the same column. disallow aliasing
+	// two different expressions to the same name. returns the
+	// ambiguous column name if two result columns cannot be distinguished.
+	private	String	ambiguousDuplicateName( Hashtable allNames, ResultColumn rc )
+		throws StandardException
+	{
+		String			columnName = rc.getName();
+		ValueNode		newExpression = rc.getExpression();
+
+		// no column name means that the compiler will generate a
+		// unique name. that's ok and avoids bug 280
+		if ( columnName == null ) { return null; }
+
+		ValueNode		oldExpression = (ValueNode) allNames.get( columnName );
+
+		// no problem yet if we haven't seen this column
+		if ( oldExpression == null )
+		{
+			allNames.put( columnName, newExpression );
+			return null;
+		}
+
+		// if the two identically named references aren't both the
+		// same table column, then the bug occurs
+		if (
+				!(newExpression instanceof ColumnReference) ||
+				!(oldExpression instanceof ColumnReference)
+		   )
+		{ return columnName; }
+
+		ColumnReference		 newCR = (ColumnReference) newExpression;
+		ColumnReference		 oldCR = (ColumnReference) oldExpression;
+		TableName			 newTableName = newCR.getTableNameNode();
+		TableName			 oldTableName = oldCR.getTableNameNode();
+
+		if (
+				( (newTableName == null) && (oldTableName == null) ) ||
+				( (newTableName != null) && (newTableName.equals( oldTableName )) )
+		   )
+		{
+			// same table but different column aliased to same column name
+			if ( !newCR.getColumnName().equals( oldCR.getColumnName() ) )
+			{ return columnName; }
+			else { return null; }
+		}
+
+		// different tables
+		return null;
+	}
+
 	/**
 		Check that the current mode supports internal extensions.
 
@@ -7736,6 +7820,8 @@ tableExpression(ResultColumnList selectList) throws StandardException :
 		 */
 		if (groupByList != null || havingClause != null)
 		{
+			vetSelectList280( selectList );
+
 			FromSubquery		fromSubquery;
 			ResultColumnList	outerRCL =
 										(ResultColumnList) nodeFactory.getNode(
diff --git a/java/engine/org/apache/derby/loc/messages_en.properties b/java/engine/org/apache/derby/loc/messages_en.properties
index f5c321c4f..a5a693afd 100644
--- a/java/engine/org/apache/derby/loc/messages_en.properties
+++ b/java/engine/org/apache/derby/loc/messages_en.properties
@@ -907,6 +907,8 @@ XSDG8.D=Unable to copy directory ''{0}'' to ''{1}'' during restore. Please make
 44X00.U=SQL Type Name
 44X05.U=next error
 
+X0A00.S=The select list mentions column ''{0}'' twice. This is not allowed in queries with GROUP BY or HAVING clauses. Try aliasing one of the conflicting columns to a unique name.
+
 X0X02.S=Table ''{0}'' cannot be locked in ''{1}'' mode.
 X0X03.S=Invalid transaction state - held cursor requires same isolation level
 X0X05.S=Table ''{0}'' does not exist.
diff --git a/java/testing/org/apache/derbyTesting/functionTests/master/aggregate.out b/java/testing/org/apache/derbyTesting/functionTests/master/aggregate.out
index 34e184733..7c2758eab 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/master/aggregate.out
+++ b/java/testing/org/apache/derbyTesting/functionTests/master/aggregate.out
@@ -889,4 +889,85 @@ ij> select i from tmax where substr('abc', sum(1), 3) = 'abc';
 ERROR 42903: Invalid use of an aggregate function.
 ij> drop table tmax;
 0 rows inserted/updated/deleted
+ij> --
+-- JIRA Bug 280.
+--
+-- Giving two columns the same name confuses the wacky
+-- query rewriting which the parser undertakes for grouped
+-- and aggregated queries.
+--
+create table bug280
+(
+   a int,
+   b int
+);
+0 rows inserted/updated/deleted
+ij> insert into bug280( a, b )
+values ( 1, 1 ), ( 1, 2 ), ( 1, 3 ), ( 2, 1 ), ( 2, 2 );
+5 rows inserted/updated/deleted
+ij> --
+-- This is bug 280. The alias confused the grouping.
+-- The second query should return the same results
+-- as the first. However, this bug cannot be fixed
+-- until we clean up the query rewriting done by
+-- the parser (see bug 681). Until then, the second
+-- query will raise an exception advising the customer
+-- to rewrite the query.
+--
+select a, count( a )
+from bug280
+group by a;
+A          |2          
+-----------------------
+1          |3          
+2          |2          
+ij> -- should raise an error
+select a, count( a ) as a
+from bug280
+group by a;
+ERROR X0A00: The select list mentions column 'A' twice. This is not allowed in queries with GROUP BY or HAVING clauses. Try aliasing one of the conflicting columns to a unique name.
+ij> -- should return same results as first query (but with extra column)
+select a, count( a ), a
+from bug280
+group by a;
+A          |2          |A          
+-----------------------------------
+1          |3          |1          
+2          |2          |2          
+ij> -- different tables with same column name ok
+select t.t_i, m.t_i from
+(select a, b from bug280 group by a, b) t (t_i, t_dt),
+(select a, b from bug280 group by a, b) m (t_i, t_dt)
+where t.t_i = m.t_i and t.t_dt = m.t_dt
+group by t.t_i, t.t_dt, m.t_i, m.t_dt order by t.t_i,m.t_i;
+T_I        |T_I        
+-----------------------
+1          |1          
+1          |1          
+1          |1          
+2          |2          
+2          |2          
+ij> -- should be allowed
+select a, a from bug280 group by a;
+A          |A          
+-----------------------
+2          |2          
+1          |1          
+ij> select bug280.a, a from bug280 group by a;
+A          |A          
+-----------------------
+2          |2          
+1          |1          
+ij> select bug280.a, bug280.a from bug280 group by a;
+A          |A          
+-----------------------
+2          |2          
+1          |1          
+ij> select a, bug280.a from bug280 group by a;
+A          |A          
+-----------------------
+2          |2          
+1          |1          
+ij> drop table bug280;
+0 rows inserted/updated/deleted
 ij> 
diff --git a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/aggregate.sql b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/aggregate.sql
index 803e65c6b..27a1b139d 100644
--- a/java/testing/org/apache/derbyTesting/functionTests/tests/lang/aggregate.sql
+++ b/java/testing/org/apache/derbyTesting/functionTests/tests/lang/aggregate.sql
@@ -403,3 +403,57 @@ select i from tmax where substr('abc', sum(1), 3) = 'abc';
 
 drop table tmax;
 
+--
+-- JIRA Bug 280.
+--
+-- Giving two columns the same name confuses the wacky
+-- query rewriting which the parser undertakes for grouped
+-- and aggregated queries.
+--
+
+create table bug280
+(
+   a int,
+   b int
+);
+
+insert into bug280( a, b )
+values ( 1, 1 ), ( 1, 2 ), ( 1, 3 ), ( 2, 1 ), ( 2, 2 );
+
+--
+-- This is bug 280. The alias confused the grouping.
+-- The second query should return the same results
+-- as the first. However, this bug cannot be fixed
+-- until we clean up the query rewriting done by
+-- the parser (see bug 681). Until then, the second
+-- query will raise an exception advising the customer
+-- to rewrite the query.
+--
+select a, count( a )
+from bug280
+group by a;
+
+-- should raise an error
+select a, count( a ) as a
+from bug280
+group by a;
+
+-- should return same results as first query (but with extra column)
+select a, count( a ), a
+from bug280
+group by a;
+
+-- different tables with same column name ok
+select t.t_i, m.t_i from
+(select a, b from bug280 group by a, b) t (t_i, t_dt),
+(select a, b from bug280 group by a, b) m (t_i, t_dt)
+where t.t_i = m.t_i and t.t_dt = m.t_dt
+group by t.t_i, t.t_dt, m.t_i, m.t_dt order by t.t_i,m.t_i;
+
+-- should be allowed
+select a, a from bug280 group by a;
+select bug280.a, a from bug280 group by a;
+select bug280.a, bug280.a from bug280 group by a;
+select a, bug280.a from bug280 group by a;
+
+drop table bug280;
