diff --git a/burst/src/main/java/com/squareup/burst/Burst.java b/burst/src/main/java/com/squareup/burst/Burst.java
index 11c8f52..eeb56eb 100644
--- a/burst/src/main/java/com/squareup/burst/Burst.java
+++ b/burst/src/main/java/com/squareup/burst/Burst.java
@@ -1,6 +1,5 @@
 package com.squareup.burst;
 
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 
 import static com.squareup.burst.Util.checkNotNull;
@@ -16,10 +15,10 @@ public final class Burst {
    * Explode a list of argument values for invoking the specified constructor with all combinations
    * of its parameters.
    */
-  public static Enum<?>[][] explodeArguments(Constructor<?> constructor) {
+  public static Enum<?>[][] explodeArguments(TestConstructor constructor) {
     checkNotNull(constructor, "constructor");
 
-    return explodeParameters(constructor.getParameterTypes(),
+    return explodeParameters(constructor.getVariationTypes(),
         constructor.getName() + " constructor");
   }
 
diff --git a/burst/src/main/java/com/squareup/burst/BurstableConstructor.java b/burst/src/main/java/com/squareup/burst/BurstableConstructor.java
index d1d6f78..042efb8 100644
--- a/burst/src/main/java/com/squareup/burst/BurstableConstructor.java
+++ b/burst/src/main/java/com/squareup/burst/BurstableConstructor.java
@@ -1,6 +1,13 @@
 package com.squareup.burst;
 
+import com.squareup.burst.annotation.Burst;
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
 
 final class BurstableConstructor {
 
@@ -10,8 +17,8 @@ final class BurstableConstructor {
    *
    * @throws IllegalStateException if there are multiple parameterized constructors
    */
-  public static Constructor<?> findSingle(Class<?> cls) {
-    final Constructor<?>[] constructors = cls.getConstructors();
+  public static TestConstructor findSingle(Class<?> cls) {
+    final TestConstructor[] constructors = findAll(cls);
 
     if (constructors.length == 0) {
       throw new IllegalStateException(cls.getName() + " requires at least 1 public constructor");
@@ -26,18 +33,44 @@ final class BurstableConstructor {
     }
   }
 
+  /**
+   * Finds all constructors of {@code cls} that are burstable.
+   * A burstable constructor is public, and may or may not be the default constructor.
+   *
+   * @throws IllegalStateException if cls has public fields and a non-default constructor
+   */
+  private static TestConstructor[] findAll(Class<?> cls) {
+    final Constructor<?>[] constructors = cls.getConstructors();
+    final Field[] fields = getBurstableFields(cls);
+    final List<TestConstructor> filteredConstructors = new ArrayList<>();
+
+    for (Constructor<?> constructor : constructors) {
+      if (constructor.getParameterTypes().length > 0 && fields.length > 0) {
+        throw new IllegalStateException(
+            "Class "
+            + cls.getName()
+            + " has a parameterized constructor, so cannot also be parameterized on fields");
+      }
+
+      filteredConstructors.add(new TestConstructor(constructor, fields));
+    }
+
+    return filteredConstructors.toArray(new TestConstructor[filteredConstructors.size()]);
+  }
+
   /**
    * Finds the constructor that has parameters.
+   * Assumes at least one non-default constructor is present.
    * E.g. Given [Ctor(), Ctor(Object)], returns Ctor(Object).
    *
    * @throws IllegalStateException if more than one constructor has parameters
    */
-  private static Constructor<?> singleParameterizedConstructorOrThrow(
-      final Constructor<?>[] constructors, final String message) {
-    Constructor<?> parameterizedConstructor = null;
+  private static TestConstructor singleParameterizedConstructorOrThrow(
+      final TestConstructor[] constructors, final String message) {
+    TestConstructor parameterizedConstructor = null;
 
-    for (Constructor<?> constructor : constructors) {
-      if (constructor.getParameterTypes().length > 0) {
+    for (TestConstructor constructor : constructors) {
+      if (constructor.getVariationTypes().length > 0) {
         if (null == parameterizedConstructor) {
           parameterizedConstructor = constructor;
         } else {
@@ -46,9 +79,54 @@ final class BurstableConstructor {
       }
     }
 
+    if (null == parameterizedConstructor) {
+      throw new IllegalArgumentException("Must pass at least one parameterized constructor");
+    }
+
     return parameterizedConstructor;
   }
 
+  /**
+   * Get all the {@link Burst}-annotated fields.
+   * Validates that the field is non-static and non-final, but doesn't check type (types are
+   * validated by static methods in {@link com.squareup.burst.Burst}).
+   */
+  private static Field[] getBurstableFields(Class<?> cls) {
+    final List<Field> fields = new ArrayList<>();
+
+    for (Field field : getAllFields(cls)) {
+      if (field.isAnnotationPresent(Burst.class)) {
+
+        if (Modifier.isStatic(field.getModifiers())) {
+          throw new IllegalStateException("Burstable field must not be static: " + field.getName());
+        }
+
+        if (Modifier.isFinal(field.getModifiers())) {
+          throw new IllegalStateException("Burstable field must not be final: " + field.getName());
+        }
+
+        fields.add(field);
+      }
+    }
+
+    return fields.toArray(new Field[fields.size()]);
+  }
+
+  /**
+   * Returns all fields of any visibility on type and all of type's superclasses.
+   * Aka {@link Class#getFields()}, but returns all fields, not just public ones.
+   */
+  private static Collection<Field> getAllFields(Class<?> type) {
+    final Collection<Field> allFields = new ArrayList<>();
+
+    while (type != Object.class) {
+      Collections.addAll(allFields, type.getDeclaredFields());
+      type = type.getSuperclass();
+    }
+
+    return Collections.unmodifiableCollection(allFields);
+  }
+
   private BurstableConstructor() {
     throw new AssertionError("No instances.");
   }
diff --git a/burst/src/main/java/com/squareup/burst/TestConstructor.java b/burst/src/main/java/com/squareup/burst/TestConstructor.java
new file mode 100644
index 0000000..f35b59a
--- /dev/null
+++ b/burst/src/main/java/com/squareup/burst/TestConstructor.java
@@ -0,0 +1,84 @@
+package com.squareup.burst;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+
+import static com.squareup.burst.Util.checkNotNull;
+
+/**
+ * A wrapper around {@link Constructor} that can also set fields reflectively.
+ */
+final class TestConstructor {
+  private final Constructor<?> constructor;
+  private final Field[] fields;
+
+  public TestConstructor(Constructor<?> constructor, Field... fields) {
+    this.constructor = checkNotNull(constructor, "constructor");
+    this.fields = fields;
+
+    for (Field field : fields) {
+      field.setAccessible(true);
+    }
+  }
+
+  public String getName() {
+    return constructor.getName();
+  }
+
+  /**
+   * Returns an array of the Class objects associated with the fields this constructor was
+   * initialized with, followed by the parameter types of this constructor.
+   * If the constructor was declared with no fields and no parameters, an empty array will be
+   * returned.
+   */
+  public Class<?>[] getVariationTypes() {
+    final Class<?>[] ctorTypes = constructor.getParameterTypes();
+    final Class<?>[] allTypes = new Class<?>[ctorTypes.length + fields.length];
+
+    System.arraycopy(ctorTypes, 0, allTypes, 0, ctorTypes.length);
+
+    for (int i = 0; i < fields.length; i++) {
+      allTypes[i + ctorTypes.length] = fields[i].getType();
+    }
+
+    return allTypes;
+  }
+
+  /**
+   * Calls {@link Constructor#newInstance(java.lang.Object...)}, as
+   * well as initializing all the fields passed to
+   * {@link TestConstructor#TestConstructor(Constructor, Field...)}.
+   * <p>
+   * Constructor arguments should be first in the array, followed by field arguments.
+   */
+  public Object newInstance(Object[] args)
+      throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    // Partition arg list
+    final int ctorArgCount = constructor.getParameterTypes().length;
+    final Object[] ctorArgs = Arrays.copyOfRange(args, 0, ctorArgCount);
+    final Object[] fieldArgs = Arrays.copyOfRange(args, ctorArgCount, args.length);
+
+    return newInstance(ctorArgs, fieldArgs);
+  }
+
+  private Object newInstance(Object[] ctorArgs, Object[] fieldArgs)
+      throws IllegalAccessException, InvocationTargetException, InstantiationException {
+    final Object instance = constructor.newInstance(ctorArgs);
+    initializeFieldsOnInstance(instance, fieldArgs);
+    return instance;
+  }
+
+  private void initializeFieldsOnInstance(final Object instance, final Object[] args)
+      throws IllegalAccessException {
+    if (fields.length != args.length) {
+      throw new IllegalArgumentException(String.format(
+          "Requires values for %d fields, only %d values passed", fields.length, args.length));
+    }
+
+    for (int i = 0; i < fields.length; i++) {
+      fields[i].set(instance, args[i]);
+    }
+  }
+}
diff --git a/burst/src/main/java/com/squareup/burst/annotation/Burst.java b/burst/src/main/java/com/squareup/burst/annotation/Burst.java
new file mode 100644
index 0000000..fba4ccc
--- /dev/null
+++ b/burst/src/main/java/com/squareup/burst/annotation/Burst.java
@@ -0,0 +1,40 @@
+package com.squareup.burst.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a field to be injected by Burst when unit tests are run.
+ * If a test class has fields annotated with this, it must have a default constructor,
+ * and no other constructors.
+ * <p>
+ * The following are equivalent:
+ * <pre>
+ *   public class MyTests {
+ *     enum Color { RED, BLUE }
+ *
+ *     private final Color color;
+ *
+ *     public MyTests(Color color) {
+ *       this.color = color;
+ *     }
+ *
+ *     …
+ *   }
+ * </pre>
+ * <pre>
+ *   public class MyTests {
+ *     enum Color { RED, BLUE }
+ *
+ *     {@literal @}Burst private Color color;
+ *
+ *     …
+ *   }
+ * </pre>
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Burst {
+}
diff --git a/burst/src/test/java/com/squareup/burst/BurstTest.java b/burst/src/test/java/com/squareup/burst/BurstTest.java
index b11d121..977a377 100644
--- a/burst/src/test/java/com/squareup/burst/BurstTest.java
+++ b/burst/src/test/java/com/squareup/burst/BurstTest.java
@@ -1,6 +1,5 @@
 package com.squareup.burst;
 
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import org.junit.Rule;
 import org.junit.Test;
@@ -29,7 +28,7 @@ public class BurstTest {
   @Rule public final ExpectedException thrown = ExpectedException.none();
 
   @Test public void nonEnumConstructorParameter() {
-    Constructor<?> constructor = Bad.class.getConstructors()[0];
+    TestConstructor constructor = new TestConstructor(Bad.class.getConstructors()[0]);
 
     thrown.expect(IllegalStateException.class);
     thrown.expectMessage(Bad.class.getName()
@@ -39,7 +38,7 @@ public class BurstTest {
   }
 
   @Test public void singleConstructorParameter() {
-    Constructor<?> constructor = One.class.getConstructors()[0];
+    TestConstructor constructor = new TestConstructor(One.class.getConstructors()[0]);
     Object[][] objects = Burst.explodeArguments(constructor);
     assertThat(objects).containsExactly(
         new Object[] { First.APPLE },
@@ -49,7 +48,7 @@ public class BurstTest {
   }
 
   @Test public void multipleConstructorParameters() {
-    Constructor<?> constructor = Three.class.getConstructors()[0];
+    TestConstructor constructor = new TestConstructor(Three.class.getConstructors()[0]);
     Object[][] objects = Burst.explodeArguments(constructor);
     assertThat(objects).containsExactly(
         new Object[] { First.APPLE, Second.DINGO, Third.FRANK },
diff --git a/burst/src/test/java/com/squareup/burst/BurstableConstructorTest.java b/burst/src/test/java/com/squareup/burst/BurstableConstructorTest.java
index 5c6c628..5d39945 100644
--- a/burst/src/test/java/com/squareup/burst/BurstableConstructorTest.java
+++ b/burst/src/test/java/com/squareup/burst/BurstableConstructorTest.java
@@ -1,6 +1,6 @@
 package com.squareup.burst;
 
-import java.lang.reflect.Constructor;
+import com.squareup.burst.annotation.Burst;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -16,27 +16,24 @@ public class BurstableConstructorTest {
   public static class None {
   }
   @Test public void noConstructor() {
-    Constructor<?> ctor = BurstableConstructor.findSingle(None.class);
-    assertThat(ctor).isNotNull();
-    assertThat(ctor.getParameterTypes()).isEmpty();
+    TestConstructor ctor = BurstableConstructor.findSingle(None.class);
+    assertThat(ctor.getVariationTypes()).isEmpty();
   }
 
   public static class Default {
     public Default() {}
   }
   @Test public void defaultConstructor() {
-    Constructor<?> ctor = BurstableConstructor.findSingle(Default.class);
-    assertThat(ctor).isNotNull();
-    assertThat(ctor.getParameterTypes()).isEmpty();
+    TestConstructor ctor = BurstableConstructor.findSingle(Default.class);
+    assertThat(ctor.getVariationTypes()).isEmpty();
   }
 
   public static class One {
     public One(First first) {}
   }
   @Test public void singleParameterizedConstructor() {
-    Constructor<?> ctor = BurstableConstructor.findSingle(One.class);
-    assertThat(ctor).isNotNull();
-    assertThat(ctor.getParameterTypes()).containsExactly(First.class);
+    TestConstructor ctor = BurstableConstructor.findSingle(One.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(First.class);
   }
 
   public static class DefaultAndOne {
@@ -44,19 +41,18 @@ public class BurstableConstructorTest {
     public DefaultAndOne(First first) {}
   }
   @Test public void defaultAndParameterizedConstructor() {
-    Constructor<?> ctor = BurstableConstructor.findSingle(DefaultAndOne.class);
-    assertThat(ctor).isNotNull();
-    assertThat(ctor.getParameterTypes()).containsExactly(First.class);
+    TestConstructor ctor = BurstableConstructor.findSingle(DefaultAndOne.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(First.class);
   }
 
-  public static class NonPublic {
-    NonPublic() {}
+  public static class NonPublicConstructor {
+    NonPublicConstructor() {}
   }
   @Test public void nonPublic() {
     thrown.expect(IllegalStateException.class);
     thrown.expectMessage("requires at least 1 public constructor");
 
-    BurstableConstructor.findSingle(NonPublic.class);
+    BurstableConstructor.findSingle(NonPublicConstructor.class);
   }
 
   public static class TooMany {
@@ -75,7 +71,105 @@ public class BurstableConstructorTest {
     public NonEnumInConstructor(Object first) {}
   }
   @Test public void nonEnumInConstructor() {
-    Constructor<?> ctor = BurstableConstructor.findSingle(NonEnumInConstructor.class);
-    assertThat(ctor.getParameterTypes()).containsExactly(Object.class);
+    TestConstructor ctor = BurstableConstructor.findSingle(NonEnumInConstructor.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(Object.class);
+  }
+
+  public static class NotAnEnumInConstructor {
+    public NotAnEnumInConstructor(Object first) {}
+  }
+  @Test public void notAnEnumInConstructor() {
+    TestConstructor ctor = BurstableConstructor.findSingle(NotAnEnumInConstructor.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(Object.class);
+  }
+
+  public static class DefaultWithField {
+    @Burst First first;
+  }
+  @Test public void defaultConstructorWithField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(DefaultWithField.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(First.class);
+  }
+
+  public static class NoneWithField {
+    @Burst First first;
+    public NoneWithField() {}
+  }
+  @Test public void singleEmptyConstructorWithField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(NoneWithField.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(First.class);
+  }
+
+  public static class MultipleFields {
+    @Burst First first;
+    @Burst Second second;
+  }
+  @Test public void emptyConstructorMultipleFields() {
+    TestConstructor ctor = BurstableConstructor.findSingle(MultipleFields.class);
+    assertThat(ctor.getVariationTypes()).containsOnly(First.class, Second.class);
+  }
+
+  public static class OneWithField {
+    @Burst Second second;
+    public OneWithField(First first) {}
+  }
+  @Test public void singleParameterizedConstructorWithField() {
+    thrown.expectMessage(
+        "has a parameterized constructor, so cannot also be parameterized on fields");
+
+    BurstableConstructor.findSingle(OneWithField.class);
+  }
+
+  public static class PrivateField {
+    @Burst private First first;
+  }
+  @Test public void privateAnnotatedField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(PrivateField.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(First.class);
+  }
+
+  public static class InheritedField extends PrivateField {
+    @Burst Second second;
+  }
+  @Test public void inheritedField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(InheritedField.class);
+    assertThat(ctor.getVariationTypes()).containsOnly(First.class, Second.class);
+  }
+
+  public static class StaticField {
+    @Burst static First first;
+  }
+  @Test public void StaticField() {
+    thrown.expect(IllegalStateException.class);
+    thrown.expectMessage("Burstable field must not be static");
+
+    BurstableConstructor.findSingle(StaticField.class);
+  }
+
+  public static class FinalField {
+    @Burst final First first = null;
+  }
+  @Test public void finalField() {
+    thrown.expect(IllegalStateException.class);
+    thrown.expectMessage("Burstable field must not be final");
+
+    BurstableConstructor.findSingle(FinalField.class);
+  }
+
+  public static class NotAnEnumField {
+    @Burst Object first;
+  }
+  @Test public void notAnEnumField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(NotAnEnumField.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(Object.class);
+  }
+
+  public static class UnannotatedField {
+    First first;
+    @Burst Second second;
+  }
+  @Test public void unannotatedField() {
+    TestConstructor ctor = BurstableConstructor.findSingle(UnannotatedField.class);
+    assertThat(ctor.getVariationTypes()).containsExactly(Second.class);
   }
 }
