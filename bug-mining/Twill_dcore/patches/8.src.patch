diff --git a/twill-discovery-core/src/main/java/org/apache/twill/discovery/DefaultServiceDiscovered.java b/twill-discovery-core/src/main/java/org/apache/twill/discovery/DefaultServiceDiscovered.java
index dbb0f7c..ca55390 100644
--- a/twill-discovery-core/src/main/java/org/apache/twill/discovery/DefaultServiceDiscovered.java
+++ b/twill-discovery-core/src/main/java/org/apache/twill/discovery/DefaultServiceDiscovered.java
@@ -20,6 +20,8 @@ package org.apache.twill.discovery;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import org.apache.twill.common.Cancellable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.Iterator;
 import java.util.List;
@@ -36,6 +38,8 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
  */
 final class DefaultServiceDiscovered implements ServiceDiscovered {
 
+  private static final Logger LOG = LoggerFactory.getLogger(DefaultServiceDiscovered.class);
+
   private final String name;
   private final AtomicReference<Set<Discoverable>> discoverables;
   private final List<ListenerCaller> listenerCallers;
@@ -49,7 +53,10 @@ final class DefaultServiceDiscovered implements ServiceDiscovered {
   }
 
   void setDiscoverables(Set<Discoverable> discoverables) {
-    this.discoverables.set(ImmutableSet.copyOf(discoverables));
+    Set<Discoverable> newDiscoverables = ImmutableSet.copyOf(discoverables);
+    LOG.debug("Discoverables changed: {}={}", name, newDiscoverables);
+
+    this.discoverables.set(newDiscoverables);
 
     // Collect all listeners with a read lock to the listener list.
     List<ListenerCaller> callers = Lists.newArrayList();
diff --git a/twill-discovery-core/src/main/java/org/apache/twill/discovery/ZKDiscoveryService.java b/twill-discovery-core/src/main/java/org/apache/twill/discovery/ZKDiscoveryService.java
index 4f2d0f7..6a3f64d 100644
--- a/twill-discovery-core/src/main/java/org/apache/twill/discovery/ZKDiscoveryService.java
+++ b/twill-discovery-core/src/main/java/org/apache/twill/discovery/ZKDiscoveryService.java
@@ -20,6 +20,8 @@ package org.apache.twill.discovery;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
+import com.google.common.cache.RemovalListener;
+import com.google.common.cache.RemovalNotification;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
@@ -47,14 +49,18 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
+import javax.annotation.Nullable;
 
 /**
  * Zookeeper implementation of {@link DiscoveryService} and {@link DiscoveryServiceClient}.
@@ -93,19 +99,21 @@ import java.util.concurrent.locks.ReentrantLock;
  *   </pre>
  * </blockquote>
  */
-public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceClient {
+public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceClient, AutoCloseable {
   private static final Logger LOG = LoggerFactory.getLogger(ZKDiscoveryService.class);
 
   private static final long RETRY_MILLIS = 1000;
 
+  private final AtomicBoolean closed;
   // In memory map for recreating ephemeral nodes after session expires.
   // It map from discoverable to the corresponding Cancellable
   private final Multimap<Discoverable, DiscoveryCancellable> discoverables;
   private final Lock lock;
 
-  private final LoadingCache<String, ServiceDiscovered> services;
+  private final LoadingCache<String, ServiceDiscoveredCacheEntry> services;
   private final ZKClient zkClient;
   private final ScheduledExecutorService retryExecutor;
+  private final Cancellable watcherCancellable;
 
   /**
    * Constructs ZKDiscoveryService using the provided zookeeper client for storing service registry.
@@ -122,13 +130,24 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
    *                  If namespace is {@code null}, no namespace will be used.
    */
   public ZKDiscoveryService(ZKClient zkClient, String namespace) {
+    this.closed = new AtomicBoolean();
     this.discoverables = HashMultimap.create();
     this.lock = new ReentrantLock();
     this.retryExecutor = Executors.newSingleThreadScheduledExecutor(
       Threads.createDaemonThreadFactory("zk-discovery-retry"));
     this.zkClient = namespace == null ? zkClient : ZKClients.namespace(zkClient, namespace);
-    this.services = CacheBuilder.newBuilder().build(createServiceLoader());
-    this.zkClient.addConnectionWatcher(createConnectionWatcher());
+    this.services = CacheBuilder.newBuilder()
+      .removalListener(new RemovalListener<String, ServiceDiscoveredCacheEntry>() {
+        @Override
+        public void onRemoval(RemovalNotification<String, ServiceDiscoveredCacheEntry> notification) {
+          ServiceDiscoveredCacheEntry entry = notification.getValue();
+          if (entry != null) {
+            entry.cancel();
+          }
+        }
+      })
+      .build(createServiceLoader());
+    this.watcherCancellable = this.zkClient.addConnectionWatcher(createConnectionWatcher());
   }
 
   /**
@@ -146,6 +165,10 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
    */
   @Override
   public Cancellable register(final Discoverable discoverable) {
+    if (closed.get()) {
+      throw new IllegalStateException("Cannot register discoverable through a closed ZKDiscoveryService");
+    }
+
     final SettableFuture<String> future = SettableFuture.create();
     final DiscoveryCancellable cancellable = new DiscoveryCancellable(discoverable);
 
@@ -157,7 +180,11 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
         cancellable.setPath(result);
         lock.lock();
         try {
-          discoverables.put(discoverable, cancellable);
+          if (!closed.get()) {
+            discoverables.put(discoverable, cancellable);
+          } else {
+            cancellable.asyncCancel();
+          }
         } finally {
           lock.unlock();
         }
@@ -182,9 +209,47 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
 
   @Override
   public ServiceDiscovered discover(String service) {
+    if (closed.get()) {
+      throw new IllegalStateException("Cannot discover through a closed ZKDiscoveryService");
+    }
     return services.getUnchecked(service);
   }
 
+  @Override
+  public void close() {
+    if (!closed.compareAndSet(false, true)) {
+      return;
+    }
+
+    // Stop the registration retry executor
+    retryExecutor.shutdownNow();
+
+    // Cancel the connection watcher
+    watcherCancellable.cancel();
+
+    // Cancel all registered services
+    List<ListenableFuture<?>> futures = new ArrayList<>();
+    lock.lock();
+    try {
+      for (Map.Entry<Discoverable, DiscoveryCancellable> entry : discoverables.entries()) {
+        LOG.debug("Un-registering service {} - {}", entry.getKey().getName(), entry.getKey().getSocketAddress());
+        futures.add(entry.getValue().asyncCancel());
+      }
+    } finally {
+      lock.unlock();
+    }
+    try {
+      Futures.successfulAsList(futures).get();
+      LOG.debug("All services unregistered");
+    } catch (Exception e) {
+      // This is not expected to happen
+      LOG.warn("Unexpected exception when waiting for all services to get unregistered", e);
+    }
+
+    // Cancel all services being watched
+    services.invalidateAll();
+  }
+
   /**
    * Handle registration failure.
    *
@@ -197,11 +262,14 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
                                      final SettableFuture<String> completion,
                                      final FutureCallback<String> creationCallback,
                                      final Throwable failureCause) {
+    if (closed.get()) {
+      return;
+    }
 
     final String path = getNodePath(discoverable);
     Futures.addCallback(zkClient.exists(path), new FutureCallback<Stat>() {
       @Override
-      public void onSuccess(Stat result) {
+      public void onSuccess(@Nullable Stat result) {
         if (result == null) {
           // If the node is gone, simply retry.
           LOG.info("Node {} is gone. Retry registration for {}.", path, discoverable);
@@ -244,16 +312,21 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
   }
 
   private void retryRegister(final Discoverable discoverable, final FutureCallback<String> creationCallback) {
+    if (closed.get()) {
+      return;
+    }
+
     retryExecutor.schedule(new Runnable() {
 
       @Override
       public void run() {
-        Futures.addCallback(doRegister(discoverable), creationCallback, Threads.SAME_THREAD_EXECUTOR);
+        if (!closed.get()) {
+          Futures.addCallback(doRegister(discoverable), creationCallback, Threads.SAME_THREAD_EXECUTOR);
+        }
       }
     }, RETRY_MILLIS, TimeUnit.MILLISECONDS);
   }
 
-
   /**
    * Generate unique node path for a given {@link Discoverable}.
    * @param discoverable An instance of {@link Discoverable}.
@@ -288,6 +361,11 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
           lock.lock();
           try {
             for (final Map.Entry<Discoverable, DiscoveryCancellable> entry : discoverables.entries()) {
+              if (closed.get()) {
+                entry.getValue().asyncCancel();
+                continue;
+              }
+
               LOG.info("Re-registering service: {}", entry.getKey());
 
               // Must be non-blocking in here.
@@ -318,22 +396,22 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
   /**
    * Creates a CacheLoader for creating live Iterable for watching instances changes for a given service.
    */
-  private CacheLoader<String, ServiceDiscovered> createServiceLoader() {
-    return new CacheLoader<String, ServiceDiscovered>() {
+  private CacheLoader<String, ServiceDiscoveredCacheEntry> createServiceLoader() {
+    return new CacheLoader<String, ServiceDiscoveredCacheEntry>() {
       @Override
-      public ServiceDiscovered load(String service) throws Exception {
+      public ServiceDiscoveredCacheEntry load(String service) throws Exception {
         final DefaultServiceDiscovered serviceDiscovered = new DefaultServiceDiscovered(service);
-        final String serviceBase = "/" + service;
+        final String pathBase = "/" + service;
 
         // Watch for children changes in /service
-        ZKOperations.watchChildren(zkClient, serviceBase, new ZKOperations.ChildrenCallback() {
+        Cancellable cancellable = ZKOperations.watchChildren(zkClient, pathBase, new ZKOperations.ChildrenCallback() {
           @Override
           public void updated(NodeChildren nodeChildren) {
             // Fetch data of all children nodes in parallel.
             List<String> children = nodeChildren.getChildren();
             List<OperationFuture<NodeData>> dataFutures = Lists.newArrayListWithCapacity(children.size());
             for (String child : children) {
-              dataFutures.add(zkClient.getData(serviceBase + "/" + child));
+              dataFutures.add(zkClient.getData(pathBase + "/" + child));
             }
 
             // Update the service map when all fetching are done.
@@ -356,7 +434,7 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
             }, Threads.SAME_THREAD_EXECUTOR);
           }
         });
-        return serviceDiscovered;
+        return new ServiceDiscoveredCacheEntry(serviceDiscovered, cancellable);
       }
     };
   }
@@ -394,18 +472,23 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
 
     @Override
     public void cancel() {
+      Futures.getUnchecked(asyncCancel());
+      LOG.debug("Service unregistered: {} {}", discoverable, path);
+    }
+
+    ListenableFuture<?> asyncCancel() {
       if (!cancelled.compareAndSet(false, true)) {
-        return;
+        return Futures.immediateFuture(null);
       }
 
       // Take a snapshot of the volatile path.
       String path = this.path;
 
-      // If it is null, meaning cancel() is called before the ephemeral node is created, hence
+      // If it is null, meaning cancel is called before the ephemeral node is created, hence
       // setPath() will be called in future (through zk callback when creation is completed)
       // so that deletion will be done in setPath().
       if (path == null) {
-        return;
+        return Futures.immediateFuture(null);
       }
 
       // Remove this Cancellable from the map so that upon session expiration won't try to register.
@@ -418,9 +501,49 @@ public class ZKDiscoveryService implements DiscoveryService, DiscoveryServiceCli
 
       // Delete the path. It's ok if the path not exists
       // (e.g. what session expired and before node has been re-created)
-      Futures.getUnchecked(ZKOperations.ignoreError(zkClient.delete(path),
-                                                    KeeperException.NoNodeException.class, path));
-      LOG.debug("Service unregistered: {} {}", discoverable, path);
+      try {
+        return ZKOperations.ignoreError(zkClient.delete(path), KeeperException.NoNodeException.class, path);
+      } catch (Exception e) {
+        return Futures.immediateFailedFuture(e);
+      }
+    }
+  }
+
+  /**
+   * Class to be used as the service discovered cache entry.
+   */
+  private static final class ServiceDiscoveredCacheEntry implements Cancellable, ServiceDiscovered {
+    private final ServiceDiscovered serviceDiscovered;
+    private final Cancellable cancellable;
+
+    private ServiceDiscoveredCacheEntry(ServiceDiscovered serviceDiscovered, Cancellable cancellable) {
+      this.serviceDiscovered = serviceDiscovered;
+      this.cancellable = cancellable;
+    }
+
+    @Override
+    public void cancel() {
+      cancellable.cancel();
+    }
+
+    @Override
+    public String getName() {
+      return serviceDiscovered.getName();
+    }
+
+    @Override
+    public Cancellable watchChanges(ChangeListener listener, Executor executor) {
+      return serviceDiscovered.watchChanges(listener, executor);
+    }
+
+    @Override
+    public boolean contains(Discoverable discoverable) {
+      return serviceDiscovered.contains(discoverable);
+    }
+
+    @Override
+    public Iterator<Discoverable> iterator() {
+      return serviceDiscovered.iterator();
     }
   }
 }
diff --git a/twill-discovery-core/src/test/java/org/apache/twill/discovery/DiscoveryServiceTestBase.java b/twill-discovery-core/src/test/java/org/apache/twill/discovery/DiscoveryServiceTestBase.java
index 8fe5a37..f2d2a83 100644
--- a/twill-discovery-core/src/test/java/org/apache/twill/discovery/DiscoveryServiceTestBase.java
+++ b/twill-discovery-core/src/test/java/org/apache/twill/discovery/DiscoveryServiceTestBase.java
@@ -25,8 +25,11 @@ import org.apache.twill.common.Cancellable;
 import org.apache.twill.common.Threads;
 import org.junit.Assert;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
+import java.nio.charset.StandardCharsets;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -41,225 +44,260 @@ import java.util.concurrent.TimeUnit;
  */
 public abstract class DiscoveryServiceTestBase {
 
+  private static final Logger LOG = LoggerFactory.getLogger(DiscoveryServiceTestBase.class);
+
   protected abstract Map.Entry<DiscoveryService, DiscoveryServiceClient> create();
 
   @Test
   public void simpleDiscoverable() throws Exception {
-    final String payload = "data";
+    final byte[] payload = "data".getBytes(StandardCharsets.UTF_8);
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
 
-    // Register one service running on one host:port
-    Cancellable cancellable = register(discoveryService, "foo", "localhost", 8090, payload.getBytes());
+      // Register one service running on one host:port
+      Cancellable cancellable = register(discoveryService, "foo", "localhost", 8090, payload);
 
-    // Discover that registered host:port.
-    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("foo");
-    Assert.assertTrue(waitTillExpected(1, serviceDiscovered));
+      // Discover that registered host:port.
+      ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("foo");
+      Assert.assertTrue(waitTillExpected(1, serviceDiscovered));
 
-    Discoverable discoverable = new Discoverable("foo", new InetSocketAddress("localhost", 8090), payload.getBytes());
+      Discoverable discoverable = new Discoverable("foo", new InetSocketAddress("localhost", 8090), payload);
 
-    // Check it exists.
-    Assert.assertTrue(serviceDiscovered.contains(discoverable));
+      // Check it exists.
+      Assert.assertTrue(serviceDiscovered.contains(discoverable));
 
-    // Remove the service
-    cancellable.cancel();
+      // Remove the service
+      cancellable.cancel();
 
-    // There should be no service.
-    Assert.assertTrue(waitTillExpected(0, serviceDiscovered));
+      // There should be no service.
+      Assert.assertTrue(waitTillExpected(0, serviceDiscovered));
 
-    Assert.assertFalse(serviceDiscovered.contains(discoverable));
+      Assert.assertFalse(serviceDiscovered.contains(discoverable));
+    } finally {
+      closeServices(entry);
+    }
   }
 
   @Test
   public void testChangeListener() throws InterruptedException {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
-
-    // Start discovery
-    String serviceName = "listener_test";
-    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover(serviceName);
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+
+      // Start discovery
+      final String serviceName = "listener_test";
+      ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover(serviceName);
+
+      // Watch for changes.
+      final BlockingQueue<List<Discoverable>> events = new ArrayBlockingQueue<List<Discoverable>>(10);
+      serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
+        @Override
+        public void onChange(ServiceDiscovered serviceDiscovered) {
+          List<Discoverable> discoverables = ImmutableList.copyOf(serviceDiscovered);
+          LOG.info("ServiceDiscovered callback: {}={}", serviceName, discoverables);
+          events.add(discoverables);
+        }
+      }, Threads.SAME_THREAD_EXECUTOR);
 
-    // Watch for changes.
-    final BlockingQueue<List<Discoverable>> events = new ArrayBlockingQueue<List<Discoverable>>(10);
-    serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
-      @Override
-      public void onChange(ServiceDiscovered serviceDiscovered) {
-        events.add(ImmutableList.copyOf(serviceDiscovered));
-      }
-    }, Threads.SAME_THREAD_EXECUTOR);
+      // An empty list will be received first, as no endpoint has been registered.
+      List<Discoverable> discoverables = events.poll(20, TimeUnit.SECONDS);
+      Assert.assertNotNull(discoverables);
+      Assert.assertTrue(discoverables.isEmpty());
 
-    // An empty list will be received first, as no endpoint has been registered.
-    List<Discoverable> discoverables = events.poll(20, TimeUnit.SECONDS);
-    Assert.assertNotNull(discoverables);
-    Assert.assertTrue(discoverables.isEmpty());
+      // Register a service
+      Cancellable cancellable = register(discoveryService, serviceName, "localhost", 10000);
 
-    // Register a service
-    Cancellable cancellable = register(discoveryService, serviceName, "localhost", 10000);
+      discoverables = events.poll(20, TimeUnit.SECONDS);
+      Assert.assertNotNull(discoverables);
 
-    discoverables = events.poll(20, TimeUnit.SECONDS);
-    Assert.assertNotNull(discoverables);
-    Assert.assertEquals(1, discoverables.size());
+      // It's possible that the list retrieved is empty in ZK case due to the creation of the parent node
+      // when creating the service discovery ZK node
+      if (discoverables.isEmpty()) {
+        // If that's the case, poll it again and it should be non-empty
+        discoverables = events.poll(20, TimeUnit.SECONDS);
+      }
+      Assert.assertEquals(1, discoverables.size());
 
-    // Register another service endpoint
-    Cancellable cancellable2 = register(discoveryService, serviceName, "localhost", 10001);
+      // Register another service endpoint
+      Cancellable cancellable2 = register(discoveryService, serviceName, "localhost", 10001);
 
-    discoverables = events.poll(20, TimeUnit.SECONDS);
-    Assert.assertNotNull(discoverables);
-    Assert.assertEquals(2, discoverables.size());
+      discoverables = events.poll(20, TimeUnit.SECONDS);
+      Assert.assertNotNull(discoverables);
+      Assert.assertEquals(2, discoverables.size());
 
-    // Cancel both of them
-    cancellable.cancel();
-    cancellable2.cancel();
+      // Cancel both of them
+      cancellable.cancel();
+      cancellable2.cancel();
 
-    // There could be more than one event triggered, but the last event should be an empty list.
-    discoverables = events.poll(20, TimeUnit.SECONDS);
-    Assert.assertNotNull(discoverables);
-    if (!discoverables.isEmpty()) {
+      // There could be more than one event triggered, but the last event should be an empty list.
       discoverables = events.poll(20, TimeUnit.SECONDS);
-    }
+      Assert.assertNotNull(discoverables);
+      if (!discoverables.isEmpty()) {
+        discoverables = events.poll(20, TimeUnit.SECONDS);
+      }
 
-    Assert.assertTrue(discoverables.isEmpty());
+      Assert.assertTrue(discoverables.isEmpty());
+    } finally {
+      closeServices(entry);
+    }
   }
 
   @Test
   public void testCancelChangeListener() throws InterruptedException {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
-
-    String serviceName = "cancel_listener";
-    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover(serviceName);
-
-    // An executor that delay execute a Runnable. It's for testing race because listener cancel and discovery changes.
-    Executor delayExecutor = new Executor() {
-      @Override
-      public void execute(final Runnable command) {
-        Thread t = new Thread() {
-          @Override
-          public void run() {
-            try {
-              TimeUnit.SECONDS.sleep(2);
-              command.run();
-            } catch (InterruptedException e) {
-              throw Throwables.propagate(e);
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+
+      String serviceName = "cancel_listener";
+      ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover(serviceName);
+
+      // An executor that delay execute a Runnable. It's for testing race because listener cancel and discovery changes.
+      Executor delayExecutor = new Executor() {
+        @Override
+        public void execute(final Runnable command) {
+          Thread t = new Thread() {
+            @Override
+            public void run() {
+              try {
+                TimeUnit.SECONDS.sleep(2);
+                command.run();
+              } catch (InterruptedException e) {
+                throw Throwables.propagate(e);
+              }
             }
-          }
-        };
-        t.start();
-      }
-    };
+          };
+          t.start();
+        }
+      };
 
-    final BlockingQueue<List<Discoverable>> events = new ArrayBlockingQueue<List<Discoverable>>(10);
-    Cancellable cancelWatch = serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
-      @Override
-      public void onChange(ServiceDiscovered serviceDiscovered) {
-        events.add(ImmutableList.copyOf(serviceDiscovered));
-      }
-    }, delayExecutor);
+      final BlockingQueue<List<Discoverable>> events = new ArrayBlockingQueue<List<Discoverable>>(10);
+      Cancellable cancelWatch = serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
+        @Override
+        public void onChange(ServiceDiscovered serviceDiscovered) {
+          events.add(ImmutableList.copyOf(serviceDiscovered));
+        }
+      }, delayExecutor);
 
-    // Wait for the init event call
-    Assert.assertNotNull(events.poll(3, TimeUnit.SECONDS));
+      // Wait for the init event call
+      Assert.assertNotNull(events.poll(3, TimeUnit.SECONDS));
 
-    // Register a new service endpoint, wait a short while and then cancel the listener
-    register(discoveryService, serviceName, "localhost", 1);
-    TimeUnit.SECONDS.sleep(1);
-    cancelWatch.cancel();
+      // Register a new service endpoint, wait a short while and then cancel the listener
+      register(discoveryService, serviceName, "localhost", 1);
+      TimeUnit.SECONDS.sleep(1);
+      cancelWatch.cancel();
 
-    // The change listener shouldn't get any event, since the invocation is delayed by the executor.
-    Assert.assertNull(events.poll(3, TimeUnit.SECONDS));
+      // The change listener shouldn't get any event, since the invocation is delayed by the executor.
+      Assert.assertNull(events.poll(3, TimeUnit.SECONDS));
+    } finally {
+      closeServices(entry);
+    }
   }
 
   @Test
   public void manySameDiscoverable() throws Exception {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
 
-    List<Cancellable> cancellables = Lists.newArrayList();
+      List<Cancellable> cancellables = Lists.newArrayList();
 
-    cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 1));
-    cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 2));
-    cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 3));
-    cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 4));
-    cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 5));
+      cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 1));
+      cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 2));
+      cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 3));
+      cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 4));
+      cancellables.add(register(discoveryService, "manyDiscoverable", "localhost", 5));
 
-    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("manyDiscoverable");
-    Assert.assertTrue(waitTillExpected(5, serviceDiscovered));
+      ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("manyDiscoverable");
+      Assert.assertTrue(waitTillExpected(5, serviceDiscovered));
 
-    for (int i = 0; i < 5; i++) {
-      cancellables.get(i).cancel();
-      Assert.assertTrue(waitTillExpected(4 - i, serviceDiscovered));
+      for (int i = 0; i < 5; i++) {
+        cancellables.get(i).cancel();
+        Assert.assertTrue(waitTillExpected(4 - i, serviceDiscovered));
+      }
+    } finally {
+      closeServices(entry);
     }
   }
 
   @Test
   public void multiServiceDiscoverable() throws Exception {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
 
-    List<Cancellable> cancellables = Lists.newArrayList();
+      List<Cancellable> cancellables = Lists.newArrayList();
 
-    cancellables.add(register(discoveryService, "service1", "localhost", 1));
-    cancellables.add(register(discoveryService, "service1", "localhost", 2));
-    cancellables.add(register(discoveryService, "service1", "localhost", 3));
-    cancellables.add(register(discoveryService, "service1", "localhost", 4));
-    cancellables.add(register(discoveryService, "service1", "localhost", 5));
+      cancellables.add(register(discoveryService, "service1", "localhost", 1));
+      cancellables.add(register(discoveryService, "service1", "localhost", 2));
+      cancellables.add(register(discoveryService, "service1", "localhost", 3));
+      cancellables.add(register(discoveryService, "service1", "localhost", 4));
+      cancellables.add(register(discoveryService, "service1", "localhost", 5));
 
-    cancellables.add(register(discoveryService, "service2", "localhost", 1));
-    cancellables.add(register(discoveryService, "service2", "localhost", 2));
-    cancellables.add(register(discoveryService, "service2", "localhost", 3));
+      cancellables.add(register(discoveryService, "service2", "localhost", 1));
+      cancellables.add(register(discoveryService, "service2", "localhost", 2));
+      cancellables.add(register(discoveryService, "service2", "localhost", 3));
 
-    cancellables.add(register(discoveryService, "service3", "localhost", 1));
-    cancellables.add(register(discoveryService, "service3", "localhost", 2));
+      cancellables.add(register(discoveryService, "service3", "localhost", 1));
+      cancellables.add(register(discoveryService, "service3", "localhost", 2));
 
-    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("service1");
-    Assert.assertTrue(waitTillExpected(5, serviceDiscovered));
+      ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover("service1");
+      Assert.assertTrue(waitTillExpected(5, serviceDiscovered));
 
-    serviceDiscovered = discoveryServiceClient.discover("service2");
-    Assert.assertTrue(waitTillExpected(3, serviceDiscovered));
+      serviceDiscovered = discoveryServiceClient.discover("service2");
+      Assert.assertTrue(waitTillExpected(3, serviceDiscovered));
 
-    serviceDiscovered = discoveryServiceClient.discover("service3");
-    Assert.assertTrue(waitTillExpected(2, serviceDiscovered));
+      serviceDiscovered = discoveryServiceClient.discover("service3");
+      Assert.assertTrue(waitTillExpected(2, serviceDiscovered));
 
-    cancellables.add(register(discoveryService, "service3", "localhost", 3));
-    Assert.assertTrue(waitTillExpected(3, serviceDiscovered)); // Shows live iterator.
+      cancellables.add(register(discoveryService, "service3", "localhost", 3));
+      Assert.assertTrue(waitTillExpected(3, serviceDiscovered)); // Shows live iterator.
 
-    for (Cancellable cancellable : cancellables) {
-      cancellable.cancel();
-    }
+      for (Cancellable cancellable : cancellables) {
+        cancellable.cancel();
+      }
 
-    Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service1")));
-    Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service2")));
-    Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service3")));
+      Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service1")));
+      Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service2")));
+      Assert.assertTrue(waitTillExpected(0, discoveryServiceClient.discover("service3")));
+    } finally {
+      closeServices(entry);
+    }
   }
 
   @Test
   public void testIterator() throws InterruptedException {
     // This test is to verify TWILL-75
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    final DiscoveryService service = entry.getKey();
-    DiscoveryServiceClient client = entry.getValue();
+    try {
+      final DiscoveryService service = entry.getKey();
+      DiscoveryServiceClient client = entry.getValue();
 
-    final String serviceName = "iterator";
-    ServiceDiscovered discovered = client.discover(serviceName);
+      final String serviceName = "iterator";
+      ServiceDiscovered discovered = client.discover(serviceName);
 
-    // Create a thread for performing registration.
-    Thread t = new Thread() {
-      @Override
-      public void run() {
-        service.register(new Discoverable(serviceName, new InetSocketAddress(12345), new byte[]{}));
-      }
-    };
+      // Create a thread for performing registration.
+      Thread t = new Thread() {
+        @Override
+        public void run() {
+          service.register(new Discoverable(serviceName, new InetSocketAddress(12345), new byte[]{}));
+        }
+      };
 
-    Iterator<Discoverable> iterator = discovered.iterator();
-    t.start();
-    t.join();
+      Iterator<Discoverable> iterator = discovered.iterator();
+      t.start();
+      t.join();
 
-    // This would throw exception if there is race condition.
-    Assert.assertFalse(iterator.hasNext());
+      // This would throw exception if there is race condition.
+      Assert.assertFalse(iterator.hasNext());
+    } finally {
+      closeServices(entry);
+    }
   }
 
   protected Cancellable register(DiscoveryService service, final String name, final String host, final int port) {
@@ -288,4 +326,21 @@ public abstract class DiscoveryServiceTestBase {
       throw Throwables.propagate(e);
     }
   }
+
+  protected final void closeServices(Map.Entry<DiscoveryService, DiscoveryServiceClient> entry) {
+    if (entry.getKey() instanceof AutoCloseable) {
+      try {
+        ((AutoCloseable) entry.getKey()).close();
+      } catch (Exception e) {
+        LOG.warn("Failed to close DiscoveryService {}", entry.getKey(), e);
+      }
+    }
+    if (entry.getValue() instanceof AutoCloseable) {
+      try {
+        ((AutoCloseable) entry.getValue()).close();
+      } catch (Exception e) {
+        LOG.warn("Failed to close DiscoveryServiceClient {}", entry.getValue(), e);
+      }
+    }
+  }
 }
diff --git a/twill-discovery-core/src/test/java/org/apache/twill/discovery/ZKDiscoveryServiceTest.java b/twill-discovery-core/src/test/java/org/apache/twill/discovery/ZKDiscoveryServiceTest.java
index 7d6e369..dcf3935 100644
--- a/twill-discovery-core/src/test/java/org/apache/twill/discovery/ZKDiscoveryServiceTest.java
+++ b/twill-discovery-core/src/test/java/org/apache/twill/discovery/ZKDiscoveryServiceTest.java
@@ -66,80 +66,86 @@ public class ZKDiscoveryServiceTest extends DiscoveryServiceTestBase {
   @Test (timeout = 30000)
   public void testDoubleRegister() throws Exception {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
-
-    // Register on the same host port, it shouldn't fail.
-    Cancellable cancellable = register(discoveryService, "test_double_reg", "localhost", 54321);
-    Cancellable cancellable2 = register(discoveryService, "test_double_reg", "localhost", 54321);
-
-    ServiceDiscovered discoverables = discoveryServiceClient.discover("test_double_reg");
-
-    Assert.assertTrue(waitTillExpected(1, discoverables));
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
 
-    cancellable.cancel();
-    cancellable2.cancel();
+      // Register on the same host port, it shouldn't fail.
+      Cancellable cancellable = register(discoveryService, "test_double_reg", "localhost", 54321);
+      Cancellable cancellable2 = register(discoveryService, "test_double_reg", "localhost", 54321);
 
-    // Register again with two different clients, but killing session of the first one.
-    final ZKClientService zkClient2 = ZKClientServices.delegate(
-      ZKClients.retryOnFailure(
-        ZKClients.reWatchOnExpire(
-          ZKClientService.Builder.of(zkServer.getConnectionStr()).build()),
-        RetryStrategies.fixDelay(1, TimeUnit.SECONDS)));
-    zkClient2.startAndWait();
+      ServiceDiscovered discoverables = discoveryServiceClient.discover("test_double_reg");
 
-    try {
-      DiscoveryService discoveryService2 = new ZKDiscoveryService(zkClient2);
-      cancellable2 = register(discoveryService2, "test_multi_client", "localhost", 54321);
-
-      // Schedule a thread to shutdown zkClient2.
-      new Thread() {
-        @Override
-        public void run() {
-          try {
-            TimeUnit.SECONDS.sleep(2);
-            zkClient2.stopAndWait();
-          } catch (InterruptedException e) {
-            LOG.error(e.getMessage(), e);
-          }
-        }
-      }.start();
+      Assert.assertTrue(waitTillExpected(1, discoverables));
 
-      // This call would block until zkClient2 is shutdown.
-      cancellable = register(discoveryService, "test_multi_client", "localhost", 54321);
       cancellable.cancel();
-
+      cancellable2.cancel();
+
+      // Register again with two different clients, but killing session of the first one.
+      final ZKClientService zkClient2 = ZKClientServices.delegate(
+        ZKClients.retryOnFailure(
+          ZKClients.reWatchOnExpire(
+            ZKClientService.Builder.of(zkServer.getConnectionStr()).build()),
+          RetryStrategies.fixDelay(1, TimeUnit.SECONDS)));
+      zkClient2.startAndWait();
+
+      try (ZKDiscoveryService discoveryService2 = new ZKDiscoveryService(zkClient2)) {
+        cancellable2 = register(discoveryService2, "test_multi_client", "localhost", 54321);
+
+        // Schedule a thread to shutdown zkClient2.
+        new Thread() {
+          @Override
+          public void run() {
+            try {
+              TimeUnit.SECONDS.sleep(2);
+              zkClient2.stopAndWait();
+            } catch (InterruptedException e) {
+              LOG.error(e.getMessage(), e);
+            }
+          }
+        }.start();
+
+        // This call would block until zkClient2 is shutdown.
+        cancellable = register(discoveryService, "test_multi_client", "localhost", 54321);
+        cancellable.cancel();
+      } finally {
+        zkClient2.stopAndWait();
+      }
     } finally {
-      zkClient2.stopAndWait();
+      closeServices(entry);
     }
   }
 
   @Test
   public void testSessionExpires() throws Exception {
     Map.Entry<DiscoveryService, DiscoveryServiceClient> entry = create();
-    DiscoveryService discoveryService = entry.getKey();
-    DiscoveryServiceClient discoveryServiceClient = entry.getValue();
+    try {
+      DiscoveryService discoveryService = entry.getKey();
+      DiscoveryServiceClient discoveryServiceClient = entry.getValue();
 
-    Cancellable cancellable = register(discoveryService, "test_expires", "localhost", 54321);
+      Cancellable cancellable = register(discoveryService, "test_expires", "localhost", 54321);
 
-    ServiceDiscovered discoverables = discoveryServiceClient.discover("test_expires");
+      ServiceDiscovered discoverables = discoveryServiceClient.discover("test_expires");
 
-    // Discover that registered host:port.
-    Assert.assertTrue(waitTillExpected(1, discoverables));
+      // Discover that registered host:port.
+      Assert.assertTrue(waitTillExpected(1, discoverables));
 
-    KillZKSession.kill(zkClient.getZooKeeperSupplier().get(), zkServer.getConnectionStr(), 10000);
+      KillZKSession.kill(zkClient.getZooKeeperSupplier().get(), zkServer.getConnectionStr(), 10000);
 
-    // Register one more endpoint to make sure state has been reflected after reconnection
-    Cancellable cancellable2 = register(discoveryService, "test_expires", "localhost", 54322);
+      // Register one more endpoint to make sure state has been reflected after reconnection
+      Cancellable cancellable2 = register(discoveryService, "test_expires", "localhost", 54322);
 
-    // Reconnection would trigger re-registration.
-    Assert.assertTrue(waitTillExpected(2, discoverables));
+      // Reconnection would trigger re-registration.
+      Assert.assertTrue(waitTillExpected(2, discoverables));
 
-    cancellable.cancel();
-    cancellable2.cancel();
+      cancellable.cancel();
+      cancellable2.cancel();
 
-    // Verify that both are now gone.
-    Assert.assertTrue(waitTillExpected(0, discoverables));
+      // Verify that both are now gone.
+      Assert.assertTrue(waitTillExpected(0, discoverables));
+    } finally {
+      closeServices(entry);
+    }
   }
 
   @Override
