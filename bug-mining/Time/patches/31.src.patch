diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 6dd6bac3..9783116e 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -93,6 +93,9 @@ Bug fixes since 2.3
 - Ensure isLeap() returns correct result for day fields [#110]
   Day-of-month and day-of-year fields should report leap days
 
+- Insist that year > weekyear when creating Partial [#96,#98]
+  As these compare equal code previously allowed either order
+
 - Handle weird TimeZone implementations with null ID [#133]
   Calling DateTimeZone.forTimeZone() would break if the ID was null
 
diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index cd4383bd..a9731165 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -164,6 +164,8 @@ public final class Partial
     /**
      * Constructs a Partial with the specified fields and values.
      * The fields must be specified in the order largest to smallest.
+     * For year and weekyear fields with equal duration, year is defined
+     * as being larger than weekyear.
      * <p>
      * The constructor uses the specified chronology.
      * 
@@ -178,6 +180,8 @@ public final class Partial
     /**
      * Constructs a Partial with the specified fields and values.
      * The fields must be specified in the order largest to smallest.
+     * For year and weekyear fields with equal duration, year is defined
+     * as being larger than weekyear.
      * <p>
      * The constructor uses the specified chronology.
      * 
@@ -227,26 +231,36 @@ public final class Partial
                 if (compare < 0) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
-                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
-                    if (types[i - 1].getRangeDurationType() == null) {
-                        if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                } else if (compare == 0) {
+                    if (lastUnitField.equals(loopUnitField)) {
+                        DurationFieldType lastRangeType = types[i - 1].getRangeDurationType();
+                        DurationFieldType loopRangeType = loopType.getRangeDurationType();
+                        if (lastRangeType == null) {
+                            if (loopRangeType == null) {
+                                throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                                types[i - 1].getName() + " and " + loopType.getName());
+                            }
+                        } else {
+                            if (loopRangeType == null) {
+                                throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
+                                        types[i - 1].getName() + " < " + loopType.getName());
+                            }
+                            DurationField lastRangeField = lastRangeType.getField(iChronology);
+                            DurationField loopRangeField = loopRangeType.getField(iChronology);
+                            if (lastRangeField.compareTo(loopRangeField) < 0) {
+                                throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
+                                        types[i - 1].getName() + " < " + loopType.getName());
+                            }
+                            if (lastRangeField.compareTo(loopRangeField) == 0) {
+                                throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                                types[i - 1].getName() + " and " + loopType.getName());
+                            }
                         }
                     } else {
-                        if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
-                                    types[i - 1].getName() + " < " + loopType.getName());
-                        }
-                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
-                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
-                        if (lastRangeField.compareTo(loopRangeField) < 0) {
-                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
-                                    types[i - 1].getName() + " < " + loopType.getName());
-                        }
-                        if (lastRangeField.compareTo(loopRangeField) == 0) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                        if (lastUnitField.isSupported() && lastUnitField.getType() != DurationFieldType.YEARS_TYPE) {
+                            throw new IllegalArgumentException("Types array must be in order largest-smallest," +
+                                            " for year-based fields, years is defined as being largest: " +
+                                            types[i - 1].getName() + " < " + loopType.getName());
                         }
                     }
                 }
diff --git a/src/test/java/org/joda/time/TestPartial_Constructors.java b/src/test/java/org/joda/time/TestPartial_Constructors.java
index 9a91bfad..8d5e2027 100644
--- a/src/test/java/org/joda/time/TestPartial_Constructors.java
+++ b/src/test/java/org/joda/time/TestPartial_Constructors.java
@@ -189,6 +189,28 @@ public class TestPartial_Constructors extends TestCase {
         assertEquals(true, Arrays.equals(test.getValues(), values));
     }
 
+    /**
+     * Test constructor
+     */
+    public void testConstructor_TypeArray_intArray_year_weekyear() throws Throwable {
+        DateTimeFieldType[] types = new DateTimeFieldType[] {
+            DateTimeFieldType.year(),
+            DateTimeFieldType.weekyear()
+        };
+        int[] values = new int[] {2005, 2006};
+        Partial test = new Partial(types, values);
+        assertEquals(ISO_UTC, test.getChronology());
+        assertEquals(2, test.size());
+        assertEquals(2005, test.getValue(0));
+        assertEquals(2005, test.get(DateTimeFieldType.year()));
+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));
+        assertEquals(2006, test.getValue(1));
+        assertEquals(2006, test.get(DateTimeFieldType.weekyear()));
+        assertEquals(true, test.isSupported(DateTimeFieldType.weekyear()));
+        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));
+        assertEquals(true, Arrays.equals(test.getValues(), values));
+    }
+
     /**
      * Test constructor
      */
@@ -257,7 +279,7 @@ public class TestPartial_Constructors extends TestCase {
     /**
      * Test constructor
      */
-    public void testConstructorEx7_TypeArray_intArray() throws Throwable {
+    public void testConstructorEx7_TypeArray_intArray_inOrder() throws Throwable {
         int[] values = new int[] {1, 1, 1};
         DateTimeFieldType[] types = new DateTimeFieldType[] {
             DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
@@ -312,12 +334,30 @@ public class TestPartial_Constructors extends TestCase {
         } catch (IllegalArgumentException ex) {
             assertMessageContains(ex, "must be in order", "largest-smallest");
         }
+        
+        types = new DateTimeFieldType[] {
+            DateTimeFieldType.weekyear(), DateTimeFieldType.yearOfCentury(), DateTimeFieldType.dayOfMonth() };
+        try {
+            new Partial(types, values);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            assertMessageContains(ex, "must be in order", "largest-smallest");
+        }
+        
+        types = new DateTimeFieldType[] {
+            DateTimeFieldType.weekyear(), DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth() };
+        try {
+            new Partial(types, values);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            assertMessageContains(ex, "must be in order", "largest-smallest");
+        }
     }
 
     /**
      * Test constructor
      */
-    public void testConstructorEx8_TypeArray_intArray() throws Throwable {
+    public void testConstructorEx8_TypeArray_intArray_duplicate() throws Throwable {
         int[] values = new int[] {1, 1, 1};
         DateTimeFieldType[] types = new DateTimeFieldType[] {
             DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };
@@ -367,7 +407,7 @@ public class TestPartial_Constructors extends TestCase {
             new Partial(types, values);
             fail();
         } catch (IllegalArgumentException ex) {
-            // expected
+            assertMessageContains(ex, "Value 0");
         }
     }
 
