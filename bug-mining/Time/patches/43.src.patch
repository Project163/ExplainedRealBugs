diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 709d0225..9291aa99 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -49,6 +49,14 @@ Bug fixes since 2.5
 - Attempt to tackle an Android deadlock [#196]
   Use dedicated lock objects instead of locking on the class object
 
+- Fix name provider [#176]
+  Name provider relied on tzdb short names matching JDK data names
+  This has ceased to be true due to recent changes in tzdb, so changed to a different algorithm
+  Data returned still depends on the JDK data, not the tzdb
+  Thus, tzdb may say AEST for Sydney Australia, but if the JDK still has EST, then that is what you get
+
+- Fix time-zone compilation tests
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java
index a45a7c6b..eab959d8 100644
--- a/src/main/java/org/joda/time/DateTimeZone.java
+++ b/src/main/java/org/joda/time/DateTimeZone.java
@@ -695,7 +695,13 @@ public abstract class DateTimeZone implements Serializable {
         if (nameKey == null) {
             return iID;
         }
-        String name = getNameProvider().getShortName(locale, iID, nameKey);
+        String name;
+        NameProvider np = getNameProvider();
+        if (np instanceof DefaultNameProvider) {
+            name = ((DefaultNameProvider) np).getShortName(locale, iID, nameKey, isStandardOffset(instant));
+        } else {
+            name = np.getShortName(locale, iID, nameKey);
+        }
         if (name != null) {
             return name;
         }
@@ -735,7 +741,13 @@ public abstract class DateTimeZone implements Serializable {
         if (nameKey == null) {
             return iID;
         }
-        String name = getNameProvider().getName(locale, iID, nameKey);
+        String name;
+        NameProvider np = getNameProvider();
+        if (np instanceof DefaultNameProvider) {
+            name = ((DefaultNameProvider) np).getName(locale, iID, nameKey, isStandardOffset(instant));
+        } else {
+            name = np.getName(locale, iID, nameKey);
+        }
         if (name != null) {
             return name;
         }
diff --git a/src/main/java/org/joda/time/tz/DefaultNameProvider.java b/src/main/java/org/joda/time/tz/DefaultNameProvider.java
index 89e67398..da17cd00 100644
--- a/src/main/java/org/joda/time/tz/DefaultNameProvider.java
+++ b/src/main/java/org/joda/time/tz/DefaultNameProvider.java
@@ -35,10 +35,14 @@ import org.joda.time.DateTimeUtils;
 public class DefaultNameProvider implements NameProvider {
     // locale -> (id -> (nameKey -> [shortName, name]))
     private HashMap<Locale, Map<String, Map<String, Object>>> iByLocaleCache = createCache();
+    private HashMap<Locale, Map<String, Map<Boolean, Object>>> iByLocaleCache2 = createCache();
 
     public DefaultNameProvider() {
     }
 
+    //-----------------------------------------------------------------------
+    // retained original code for name lookup, not used in normal code
+    // this code could be refactored to avoid duplication, but leaving it as is ensures backward compatibility
     public String getShortName(Locale locale, String id, String nameKey) {
         String[] nameSet = getNameSet(locale, id, nameKey);
         return nameSet == null ? null : nameSet[0];
@@ -95,6 +99,59 @@ public class DefaultNameProvider implements NameProvider {
         return (String[]) byNameKeyCache.get(nameKey);
     }
 
+    //-----------------------------------------------------------------------
+    // change lookup to operate on boolean standard/summer time flag
+    // handles changes to the nameKey better
+    public String getShortName(Locale locale, String id, String nameKey, boolean standardTime) {
+        String[] nameSet = getNameSet(locale, id, nameKey, standardTime);
+        return nameSet == null ? null : nameSet[0];
+    }
+    
+    public String getName(Locale locale, String id, String nameKey, boolean standardTime) {
+        String[] nameSet = getNameSet(locale, id, nameKey, standardTime);
+        return nameSet == null ? null : nameSet[1];
+    }
+
+    private synchronized String[] getNameSet(Locale locale, String id, String nameKey, boolean standardTime) {
+        if (locale == null || id == null || nameKey == null) {
+            return null;
+        }
+
+        Map<String, Map<Boolean, Object>> byIdCache = iByLocaleCache2.get(locale);
+        if (byIdCache == null) {
+            iByLocaleCache2.put(locale, byIdCache = createCache());
+        }
+
+        Map<Boolean, Object> byNameKeyCache = byIdCache.get(id);
+        if (byNameKeyCache == null) {
+            byIdCache.put(id, byNameKeyCache = createCache());
+            
+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
+            String[] setEn = null;
+            for (String[] strings : zoneStringsEn) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setEn = strings;
+                break;
+              }
+            }
+            String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
+            String[] setLoc = null;
+            for (String[] strings : zoneStringsLoc) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setLoc = strings;
+                break;
+              }
+            }
+            
+            if (setEn != null && setLoc != null) {
+              byNameKeyCache.put(Boolean.TRUE, new String[] {setLoc[2], setLoc[1]});
+              byNameKeyCache.put(Boolean.FALSE, new String[] {setLoc[4], setLoc[3]});
+            }
+        }
+        return (String[]) byNameKeyCache.get(Boolean.valueOf(standardTime));
+    }
+
+    //-----------------------------------------------------------------------
     private HashMap createCache() {
         return new HashMap(7);
     }
