diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 0e086e53..869e3f64 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -8,6 +8,12 @@
   <body>
 
     <!-- types are add, fix, remove, update -->
+    <release version="2.10.1" date="SNAPSHOT" description="v2.10.1">
+      <action dev="jodastephen" type="fix">
+        Fix time-zone compiler for Namibia. Oh I do love tzdb.
+        Fixes #485.
+      </action>
+    </release>
     <release version="2.10" date="2018-05-30" description="v2.10">
       <action dev="jodastephen" type="update">
         DateTimeZone data updated to version 2018e.
diff --git a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
index 4036b55a..f0b7afd3 100644
--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -722,6 +722,17 @@ public class ZoneInfoCompiler {
             iLetterS = parseOptional(st.nextToken());
         }
 
+        // creates a rule to go before the specified rule
+        Rule(Rule after) {
+            iName = after.iName;
+            iFromYear = 1800;
+            iToYear = after.iFromYear;
+            iType = null;
+            iDateTimeOfYear = after.iDateTimeOfYear;  // does not matter
+            iSaveMillis = 0;
+            iLetterS = after.iLetterS;
+        }
+
         /**
          * Adds a recurring savings rule to the builder.
          */
@@ -800,9 +811,10 @@ public class ZoneInfoCompiler {
                     negativeSave = Math.min(negativeSave, rule.iSaveMillis);
                 }
             }
-            
+
             // if negative SAVE values, then patch standard millis and name format
             if (negativeSave < 0) {
+                System.out.println("Fixed negative save values for rule '" + iRules.get(0).iName + "'");
                 standardMillis += negativeSave;
                 int slashPos = nameFormat.indexOf("/");
                 if (slashPos > 0) {
@@ -810,7 +822,13 @@ public class ZoneInfoCompiler {
                 }
             }
             builder.setStandardOffset(standardMillis);
-            
+
+            // add a fake rule that predates all other rules to ensure standard=summer (see Namibia)
+            if (negativeSave < 0) {
+                Rule rule = new Rule(iRules.get(0));
+                rule.addRecurring(builder, negativeSave, nameFormat);
+            }
+
             // add each rule, passing through the negative save to alter the actual iSaveMillis value that is used
             for (int i = 0; i < iRules.size(); i++) {
                 Rule rule = iRules.get(i);
@@ -892,6 +910,7 @@ public class ZoneInfoCompiler {
                         builder.setFixedSavings(zone.iFormat, saveMillis);
                     }
                     catch (Exception e) {
+                        // Zone is using a RuleSet for this segment of the timeline
                         RuleSet rs = ruleSets.get(zone.iRules);
                         if (rs == null) {
                             throw new IllegalArgumentException
diff --git a/src/test/java/org/joda/time/TestDateTimeZone.java b/src/test/java/org/joda/time/TestDateTimeZone.java
index 59654dca..85ce20d8 100644
--- a/src/test/java/org/joda/time/TestDateTimeZone.java
+++ b/src/test/java/org/joda/time/TestDateTimeZone.java
@@ -1097,6 +1097,25 @@ public class TestDateTimeZone extends TestCase {
         assertEquals("IST", zone.getNameKey(summer.getMillis()));
     }
     
+    //-----------------------------------------------------------------------
+    public void testWindhoek() {
+        DateTimeZone zone = DateTimeZone.forID("Africa/Windhoek");
+        DateTime dtDec1990 = new DateTime(1990, 12, 1, 0, 0, 0, 0, zone);
+        assertEquals(3600000, zone.getStandardOffset(dtDec1990.getMillis()));
+        assertEquals(7200000, zone.getOffset(dtDec1990.getMillis()));
+        assertEquals(false, zone.isStandardOffset(dtDec1990.getMillis()));
+        
+        DateTime dtDec1994 = new DateTime(1994, 12, 1, 0, 0, 0, 0, zone);
+        assertEquals(3600000, zone.getStandardOffset(dtDec1994.getMillis()));
+        assertEquals(7200000, zone.getOffset(dtDec1994.getMillis()));
+        assertEquals(false, zone.isStandardOffset(dtDec1994.getMillis()));
+        
+        DateTime dtJun1995 = new DateTime(1995, 6, 1, 0, 0, 0, 0, zone);
+        assertEquals(3600000, zone.getStandardOffset(dtJun1995.getMillis()));
+        assertEquals(3600000, zone.getOffset(dtJun1995.getMillis()));
+        assertEquals(true, zone.isStandardOffset(dtJun1995.getMillis()));
+    }
+    
     //-----------------------------------------------------------------------
     public void testSerialization1() throws Exception {
         DateTimeZone zone = DateTimeZone.forID("Europe/Paris");
