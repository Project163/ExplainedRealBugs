diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 7a11099f..42f31caf 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -20,6 +20,11 @@ Changes in 2.9.5
  - Add Duration.dividedBy(long,RoundingMode) [#69, #379]
 
  - DateTimeZone data updated to version 2016f
+ 
+ - Fix bug in time-zone binary search [#332, #386]
+  The fix in v2.9.2 caused problems when the time-zone being parsed
+  was not the last element in the input string. New approach uses a
+  different approach to the problem.
 
 
 Changes in 2.9.4
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 51ae9f48..b3fe7a3d 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -18,6 +18,7 @@ package org.joda.time.format;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -2315,17 +2316,38 @@ public class DateTimeFormatterBuilder {
 
         INSTANCE;
         private static final List<String> ALL_IDS;
+        // groups are "Europe/A", "Europe/B", "Europe/C", etc
+        // group of "" is for zones that do not have a "/" in the name
+        private static final Map<String, List<String>> GROUPED_IDS;
+        private static final List<String> BASE_GROUPED_IDS = new ArrayList<String>();
+        static final int MAX_LENGTH;
+        static final int MAX_PREFIX_LENGTH;
         static {
             ALL_IDS = new ArrayList<String>(DateTimeZone.getAvailableIDs());
             Collections.sort(ALL_IDS);
-        }
-        static final int MAX_LENGTH;
-        static {
+            GROUPED_IDS = new HashMap<String, List<String>>();
             int max = 0;
+            int maxPrefix = 0;
             for (String id : ALL_IDS) {
+                int pos = id.indexOf('/');
+                if (pos >= 0) {
+                    if (pos < id.length()) {
+                        pos++;
+                    }
+                    maxPrefix = Math.max(maxPrefix, pos);
+                    String prefix = id.substring(0, pos + 1);
+                    String suffix = id.substring(pos);
+                    if (!GROUPED_IDS.containsKey(prefix)) {
+                        GROUPED_IDS.put(prefix, new ArrayList<String>());
+                    }
+                    GROUPED_IDS.get(prefix).add(suffix);
+                } else {
+                    BASE_GROUPED_IDS.add(id);
+                }
                 max = Math.max(max, id.length());
             }
             MAX_LENGTH = max;
+            MAX_PREFIX_LENGTH = maxPrefix;
         }
 
         public int estimatePrintedLength() {
@@ -2347,43 +2369,47 @@ public class DateTimeFormatterBuilder {
         }
 
         public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
-            String best = null;
-            int pos = prefixedStartPosition(text, position);
-            for (int i = pos; i < ALL_IDS.size(); i++) {
-                String id = ALL_IDS.get(i);
-                if (csStartsWith(text, position, id)) {
-                    if (best == null || id.length() > best.length()) {
-                        best = id;
+            // select the base set of identifiers that do not have a slash
+            List<String> suffixSet = BASE_GROUPED_IDS;
+            // hunt for a slash only as far as the max prefix length
+            int textLen = text.length();
+            int matchLen = Math.min(textLen, position + MAX_PREFIX_LENGTH);
+            int pos = position;
+            String prefix = "";
+            for (int i = pos; i < matchLen; i++) {
+                if (text.charAt(i) == '/') {
+                    // when a slash is found, determine the prefix, such as "Europe/A" and lookup to get suffixes
+                    prefix = text.subSequence(pos, i + 1).toString();
+                    pos += prefix.length();
+                    String prefixLookup = prefix;
+                    if (i < textLen) {
+                        prefixLookup += text.charAt(i + 1);
+                    }
+                    suffixSet = GROUPED_IDS.get(prefixLookup);
+                    if (suffixSet == null) {
+                        return ~position;
                     }
-                } else {
                     break;
                 }
             }
+            // search all suffixes, hopefully a relatively small number due to prefix search
+            String best = null;
+            for (int i = 0; i < suffixSet.size(); i++) {
+                String suffix = suffixSet.get(i);
+                if (csStartsWith(text, pos, suffix)) {
+                    if (best == null || suffix.length() > best.length()) {
+                        best = suffix;
+                    }
+                }
+            }
+            // if found then store, else fail
             if (best != null) {
-                bucket.setZone(DateTimeZone.forID(best));
-                return position + best.length();
+                bucket.setZone(DateTimeZone.forID(prefix + best));
+                return pos + best.length();
             }
             return ~position;
         }
 
-        private static int prefixedStartPosition(CharSequence text, int position) {
-            int lo = 0;
-            int hi = ALL_IDS.size() - 1;
-
-            while (lo <= hi) {
-                int mid = (lo + hi) >>> 1;
-                String value = ALL_IDS.get(mid);
-                int compare = csCompare(text, position, value);
-                if (compare > 0) {
-                    hi = mid - 1;
-                } else if (compare < 0) {
-                    lo = mid + 1;
-                } else {
-                    return mid;
-                }
-            }
-            return lo;
-        }
     }
 
     //-----------------------------------------------------------------------
@@ -2617,19 +2643,6 @@ public class DateTimeFormatterBuilder {
         }
     }
 
-    static int csCompare(CharSequence text, int position, String search) {
-        int matchLen = text.length() - position;
-        int searchLen = search.length();
-        int compareLen = Math.min(matchLen, searchLen);
-        for (int i = 0; i < compareLen; i++) {
-            int result = search.charAt(i) - text.charAt(position + i);
-            if (result != 0) {
-                return result;
-            }
-        }
-        return searchLen - matchLen;
-    }
-
     static boolean csStartsWith(CharSequence text, int position, String search) {
         int searchLen = search.length();
         if ((text.length() - position) < searchLen) {
diff --git a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
index 482eb75b..d9f6f58a 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
@@ -425,6 +425,26 @@ public class TestDateTimeFormatterBuilder extends TestCase {
         assertEquals(dt, f.withOffsetParsed().parseDateTime("2007-03-04 12:30 Europe/Paris"));
     }
 
+    public void test_printParseZoneDawson() {  // clashes with shorter Dawson
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+            .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId();
+        DateTimeFormatter f = bld.toFormatter();
+        
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("America/Dawson"));
+        assertEquals("2007-03-04 12:30 America/Dawson", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Dawson"));
+    }
+
+    public void test_printParseZoneDawson_suffix() {  // clashes with shorter Dawson
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+            .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId().appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+        
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("America/Dawson"));
+        assertEquals("2007-03-04 12:30 America/Dawson]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Dawson]"));
+    }
+
     public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
             .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId();
@@ -435,6 +455,16 @@ public class TestDateTimeFormatterBuilder extends TestCase {
         assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Dawson_Creek"));
     }
 
+    public void test_printParseZoneDawsonCreek_suffix() {  // clashes with shorter Dawson
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+            .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId().appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+        
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("America/Dawson_Creek"));
+        assertEquals("2007-03-04 12:30 America/Dawson_Creek]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Dawson_Creek]"));
+    }
+
     public void test_printParseZoneEtcGMT() {
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
                 .appendPattern("yyyy-MM-dd HH:mm ZZZ");
@@ -445,6 +475,16 @@ public class TestDateTimeFormatterBuilder extends TestCase {
         assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT"));
     }
 
+    public void test_printParseZoneEtcGMT_suffix() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ").appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("Etc/GMT"));
+        assertEquals("2007-03-04 12:30 Etc/GMT]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT]"));
+    }
+
     public void test_printParseZoneGMT() {
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
                 .appendPattern("yyyy-MM-dd HH:mm ZZZ");
@@ -455,6 +495,16 @@ public class TestDateTimeFormatterBuilder extends TestCase {
         assertEquals(dt, f.parseDateTime("2007-03-04 12:30 GMT"));
     }
 
+    public void test_printParseZoneGMT_suffix() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ").appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("GMT"));
+        assertEquals("2007-03-04 12:30 Etc/GMT]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 GMT]"));
+    }
+
     public void test_printParseZoneEtcGMT1() {
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
                 .appendPattern("yyyy-MM-dd HH:mm ZZZ");
@@ -465,6 +515,56 @@ public class TestDateTimeFormatterBuilder extends TestCase {
         assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT+1"));
     }
 
+    public void test_printParseZoneEtcGMT1_suffix() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ").appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("Etc/GMT+1"));
+        assertEquals("2007-03-04 12:30 Etc/GMT+1]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT+1]"));
+    }
+
+    public void test_printParseZoneEtcGMT10() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ");
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("Etc/GMT+10"));
+        assertEquals("2007-03-04 12:30 Etc/GMT+10", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT+10"));
+    }
+
+    public void test_printParseZoneEtcGMT10_suffix() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ").appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("Etc/GMT+10"));
+        assertEquals("2007-03-04 12:30 Etc/GMT+10]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Etc/GMT+10]"));
+    }
+
+    public void test_printParseZoneMET() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ");
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("MET"));
+        assertEquals("2007-03-04 12:30 MET", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 MET"));
+    }
+
+    public void test_printParseZoneMET_suffix() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
+                .appendPattern("yyyy-MM-dd HH:mm ZZZ").appendLiteral(']');
+        DateTimeFormatter f = bld.toFormatter();
+
+        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("MET"));
+        assertEquals("2007-03-04 12:30 MET]", f.print(dt));
+        assertEquals(dt, f.parseDateTime("2007-03-04 12:30 MET]"));
+    }
+
     public void test_printParseZoneBahiaBanderas() {
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()
             .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId();
