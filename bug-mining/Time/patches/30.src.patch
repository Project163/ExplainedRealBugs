diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index d68f4e4f..57ccac50 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -35,6 +35,9 @@ Enhancements since 2.3
 - Increased performance of formatter lookup [#127,#129]
   No API change
 
+- Increased performance of symbols lookup [#143]
+  No API change
+
 
 Compatibility with 2.3
 ----------------------
diff --git a/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java b/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
index 2c8fa154..137c7414 100644
--- a/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
+++ b/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -15,11 +15,11 @@
  */
 package org.joda.time.chrono;
 
-import java.lang.ref.WeakReference;
 import java.text.DateFormatSymbols;
 import java.util.Locale;
 import java.util.TreeMap;
-import java.util.WeakHashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DateTimeUtils;
@@ -32,29 +32,27 @@ import org.joda.time.IllegalFieldValueException;
  * @since 1.0
  */
 class GJLocaleSymbols {
-    private static final int FAST_CACHE_SIZE = 64;
 
-    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
+    private static ConcurrentMap<Locale, GJLocaleSymbols> cCache = new ConcurrentHashMap<Locale, GJLocaleSymbols>();
 
-    private static WeakHashMap<Locale, GJLocaleSymbols> cCache = new WeakHashMap<Locale, GJLocaleSymbols>();
-
-    public static GJLocaleSymbols forLocale(Locale locale) {
+    /**
+     * Obtains the symbols for a locale.
+     * 
+     * @param locale  the locale, null returns default
+     * @return the symbols, not null
+     */
+    static GJLocaleSymbols forLocale(Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
-        GJLocaleSymbols symbols = cFastCache[index];
-        if (symbols != null && symbols.iLocale.get() == locale) {
-            return symbols;
-        }
-        synchronized (cCache) {
-            symbols = cCache.get(locale);
-            if (symbols == null) {
-                symbols = new GJLocaleSymbols(locale);
-                cCache.put(locale, symbols);
+        GJLocaleSymbols symbols = cCache.get(locale);
+        if (symbols == null) {
+            symbols = new GJLocaleSymbols(locale);
+            GJLocaleSymbols oldSymbols = cCache.putIfAbsent(locale, symbols);
+            if (oldSymbols != null) {
+                symbols = oldSymbols;
             }
         }
-        cFastCache[index] = symbols;
         return symbols;
     }
 
@@ -103,8 +101,6 @@ class GJLocaleSymbols {
         return max;
     }
 
-    private final WeakReference<Locale> iLocale;
-
     private final String[] iEras;
     private final String[] iDaysOfWeek;
     private final String[] iShortDaysOfWeek;
@@ -127,8 +123,6 @@ class GJLocaleSymbols {
      * @param locale must not be null
      */
     private GJLocaleSymbols(Locale locale) {
-        iLocale = new WeakReference<Locale>(locale);
-        
         DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale);
         
         iEras = dfs.getEras();
diff --git a/src/test/java/org/joda/time/chrono/ThreadContention.java b/src/test/java/org/joda/time/chrono/ThreadContention.java
index 5f25086a..7de1e225 100644
--- a/src/test/java/org/joda/time/chrono/ThreadContention.java
+++ b/src/test/java/org/joda/time/chrono/ThreadContention.java
@@ -16,8 +16,10 @@
 package org.joda.time.chrono;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 
 import junit.framework.Assert;
@@ -30,10 +32,80 @@ import org.joda.time.DateTimeZone;
 public class ThreadContention {
 
     public static void main(String[] args) {
+        multiThreadGJLocale();
+        singleThreadGJLocale2();
+        singleThreadGJLocale();
         multiThreadZones();
         singleThreadZones();
     }
 
+    //-------------------------------------------------------------------------
+    private static void multiThreadGJLocale() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final List<Locale> locales = createLocales();
+        List<Runnable> runnables = new ArrayList<Runnable>();
+        for (int i = 0; i < 100; i++) { 
+            Runnable r = new Runnable() {
+                public void run() {
+                    try {
+                        latch.await();
+                        List<Locale> shuffled = new ArrayList<Locale>(locales);
+                        Collections.shuffle(shuffled);
+                        String name = Thread.currentThread().getName();
+                        for (int j = 0; j < 100; j++) { 
+                            for (Locale locale : shuffled) {
+                                GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(locale);
+                                Assert.assertEquals(GJLocaleSymbols.class, symbols.getClass());
+                            }
+                        }
+                      System.out.println("Finished: " + name);
+                        
+                    } catch (Exception ex) {
+                        ex.printStackTrace();
+                        System.exit(1);
+                    }
+                }
+            };
+            new Thread(r).start();
+            runnables.add(r);
+        }
+        latch.countDown();
+    }
+
+    private static void singleThreadGJLocale() {
+        List<Locale> locales = createLocales();
+        List<Locale> shuffled = new ArrayList<Locale>(locales);
+        Collections.shuffle(shuffled);
+        long start = System.nanoTime();
+        int count = 0;
+        for (int j = 0; j < 10000; j++) { 
+            for (Locale locale : shuffled) {
+                GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(locale);
+                count = count + symbols.getDayOfWeekMaxShortTextLength();
+            }
+        }
+        long end = System.nanoTime();
+        System.out.println("Finished " + count + " " + (end - start) / 1000000);
+    }
+
+    private static void singleThreadGJLocale2() {
+        List<Locale> locales = createLocales();
+        List<Locale> shuffled = new ArrayList<Locale>(locales);
+        Collections.shuffle(shuffled);
+        long start = System.nanoTime();
+        int count = 0;
+        for (int j = 0; j < 1000000; j++) { 
+            GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(Locale.US);
+            count = count + symbols.getDayOfWeekMaxShortTextLength() + symbols.hashCode();
+        }
+        long end = System.nanoTime();
+        System.out.println("Finished " + count + " " + (end - start) / 1000000);
+    }
+
+    private static List<Locale> createLocales() {
+        return Arrays.asList(Locale.getAvailableLocales());
+    }
+
     //-------------------------------------------------------------------------
     private static void multiThreadZones() {
         final CountDownLatch latch = new CountDownLatch(1);
