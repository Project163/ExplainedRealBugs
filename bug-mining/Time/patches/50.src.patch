diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index e3ad6faa..20ba6081 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -1,4 +1,4 @@
-Joda-Time version 2.7
+Joda-Time version 2.8
 ---------------------
 
 Joda-Time is a date and time handling library that seeks to replace the JDK
@@ -16,27 +16,11 @@ of restrictions. If the license causes you problems please contact the mailing l
 ** http://www.joda.org/joda-time/related.html **
 
 
-Enhancements since 2.6
+Enhancements since 2.7
 ----------------------
-- Add DateTime.withDate(LocalDate) and DateTime.withTime(LocalTime) [#213]
-  This was possible using DateTime.withFields(ReadablePartial) but the new methods are clearer
 
-- Added new system property for time-zone loading [#37]
-  Added system property "org.joda.time.DateTimeZone.Folder".
-  If set, then it is treated as a file system folder to load time-zone data from.
-  The folder is loaded using ZoneInfoProvider and must be the unzipped output of ZoneInfoCompiler.
-  The default behaviour is unchanged, with default time-zone data included in the jar file.
 
-- Produce jar file without time-zone data [#220]
-  A second jar file is now located in Maven Central with the classifier "no-tzdb".
-  This is the same as the main joda-time jar file, except that the tzdb data and ZoneInfoCompiler are omitted.
-  This is intended for use by Android, but could be used in other environments.
-  If using this alternative jar, a time-zone system property must be set, either
-  "org.joda.time.DateTimeZone.Provider" or "org.joda.time.DateTimeZone.Folder".
-  The default behaviour in the standard jar file is unchanged, with time-zone data included in the jar file.
-
-
-Compatibility with 2.6
+Compatibility with 2.7
 ----------------------
 Build system - Yes
 
@@ -52,21 +36,14 @@ Data compatible - Yes
 Semantic compatible - Yes
 
 
-Deprecations since 2.6
+Deprecations since 2.7
 ----------------------
 
 
-Bug fixes since 2.6
+Bug fixes since 2.7
 -------------------
-- Fix Asia/Dhaka time-zone [#208]
-  Problem caused by time-zone ending at 24:00 on December 31st
-  Model change as being as 23:59:59.999
-
-- Fix PeriodFormatter.withLocale to operate on word-based formatting [#187, #191]
-  Previously, PeriodFormatter.withLocale() had no effect on word-based formatting
-  Now, the locale used when calling PeriodFormat.wordBased(locale) is passed to the PeriodFormatter.
-  In addition, if PeriodFormatter.withLocale(locale) is called, then the word-based pattern will
-  change to a pattern appropriate for that locale.
+- Fix MonthDay.plusDays() [#227]
+  The algorithm was incorrect when adding enough days to cause the month to change twice.
 
 
 Scala
diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
index 051caedd..6ac87c20 100644
--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
@@ -209,7 +209,7 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {
         }
         if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
             // month is largest field and being added to, such as month-day
-            int curMonth0 = partial.getValue(0) - 1;
+            int curMonth0 = values[0] - 1;
             int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
             return set(partial, 0, values, newMonth);
         }
diff --git a/src/test/java/org/joda/time/TestMonthDay_Basics.java b/src/test/java/org/joda/time/TestMonthDay_Basics.java
index 58183d9d..e8a8cede 100644
--- a/src/test/java/org/joda/time/TestMonthDay_Basics.java
+++ b/src/test/java/org/joda/time/TestMonthDay_Basics.java
@@ -503,28 +503,28 @@ public class TestMonthDay_Basics extends TestCase {
         MonthDay expected = new MonthDay(5, 11, BuddhistChronology.getInstance());
         assertEquals(expected, result);
     }
-    
+
     public void testPlusDays_int_wrapMonth() {
         MonthDay test = new MonthDay(11, 1, ISOChronology.getInstanceUTC());
-        MonthDay result = test.plusDays(30);
-        MonthDay expected = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
+        MonthDay result = test.plusDays(31);
+        MonthDay expected = new MonthDay(12, 2, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testPlusDays_int_wrapMonthTwice() {
         MonthDay test = new MonthDay(10, 31, ISOChronology.getInstanceUTC());
-        MonthDay result = test.plusDays(31);
-        MonthDay expected = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
+        MonthDay result = test.plusDays(32);
+        MonthDay expected = new MonthDay(12, 2, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testPlusDays_int_wrapMonthIntoNextYear() {
         MonthDay test = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
         MonthDay result = test.plusDays(31);
         MonthDay expected = new MonthDay(1, 1, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testPlusDays_int_wrapMonthTwiceIntoNextYear() {
         MonthDay test = new MonthDay(11, 30, ISOChronology.getInstanceUTC());
         MonthDay result = test.plusDays(32);
@@ -532,6 +532,13 @@ public class TestMonthDay_Basics extends TestCase {
         assertEquals(expected, result);
     }
 
+    public void testPlusDays_int_wrap50() {
+        MonthDay test = new MonthDay(5, 15, ISOChronology.getInstanceUTC());
+        MonthDay result = test.plusDays(50);
+        MonthDay expected = new MonthDay(7, 4, ISOChronology.getInstanceUTC());
+        assertEquals(expected, result);
+    }
+
     public void testPlusDays_int_toLeap() {
         MonthDay test = new MonthDay(2, 28, ISOChronology.getInstanceUTC());
         MonthDay result = test.plusDays(1);
@@ -632,28 +639,28 @@ public class TestMonthDay_Basics extends TestCase {
         MonthDay expected = new MonthDay(5, 10, BuddhistChronology.getInstance());
         assertEquals(expected, result);
     }
-    
+
     public void testMinusDays_int_wrapMonth() {
         MonthDay test = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
         MonthDay result = test.minusDays(30);
         MonthDay expected = new MonthDay(11, 1, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testMinusDays_int_wrapMonthTwice() {
         MonthDay test = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
         MonthDay result = test.minusDays(31);
         MonthDay expected = new MonthDay(10, 31, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testMinusDays_int_wrapMonthIntoLastYear() {
         MonthDay test = new MonthDay(1, 1, ISOChronology.getInstanceUTC());
         MonthDay result = test.minusDays(31);
         MonthDay expected = new MonthDay(12, 1, ISOChronology.getInstanceUTC());
         assertEquals(expected, result);
     }
-    
+
     public void testMinusDays_int_wrapMonthTwiceIntoLastYear() {
         MonthDay test = new MonthDay(1, 1, ISOChronology.getInstanceUTC());
         MonthDay result = test.minusDays(32);
