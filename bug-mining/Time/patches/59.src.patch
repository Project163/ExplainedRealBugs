diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 71a901ba..420c90c7 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -18,6 +18,9 @@ Changes in 2.8.3
 ================
 - Faster parsing of time-zone identifiers [#282]
 
+- Added Interval.parseWithOffset(String) [#299, #296]
+  Provides a way to parse the fixed offset in an interval string
+
 
 Changes in 2.8.2
 ================
diff --git a/src/main/java/org/joda/time/DateTime.java b/src/main/java/org/joda/time/DateTime.java
index bbc17e95..9cc6b1eb 100644
--- a/src/main/java/org/joda/time/DateTime.java
+++ b/src/main/java/org/joda/time/DateTime.java
@@ -123,11 +123,11 @@ public final class DateTime
     /**
      * Parses a {@code DateTime} from the specified string.
      * <p>
-     * This uses {@link ISODateTimeFormat#dateTimeParser().withOffsetParsed()}
+     * This uses {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}
      * which is different to passing a {@code String} to the constructor.
      * <p>
      * Sometimes this method and {@code new DateTime(str)} return different results.
-     * This can be confusing as the different is not visible in {@link #toString()}.
+     * This can be confusing as the difference is not visible in {@link #toString()}.
      * <p>
      * When passed a date-time string without an offset, such as '2010-06-30T01:20',
      * both the constructor and this method use the default time-zone.
diff --git a/src/main/java/org/joda/time/Interval.java b/src/main/java/org/joda/time/Interval.java
index 99397eba..eb072efc 100644
--- a/src/main/java/org/joda/time/Interval.java
+++ b/src/main/java/org/joda/time/Interval.java
@@ -19,8 +19,10 @@ import java.io.Serializable;
 
 import org.joda.time.base.BaseInterval;
 import org.joda.time.chrono.ISOChronology;
+import org.joda.time.format.DateTimeFormatter;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.format.ISOPeriodFormat;
+import org.joda.time.format.PeriodFormatter;
 
 /**
  * Interval is the standard implementation of an immutable time interval.
@@ -61,6 +63,10 @@ public final class Interval
      * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}
      * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',
      * 'datetime/period' or 'period/datetime'.
+     * <p>
+     * This method operates by parsing in the default time-zone.
+     * Any offset contained within the string being parsed will be normalised to the
+     * offset of the default time-zone. See also {@link #parseWithOffset(String)}.
      * 
      * @param str  the string to parse, not null
      * @since 2.0
@@ -69,6 +75,77 @@ public final class Interval
         return new Interval(str);
     }
 
+    /**
+     * Parses a {@code Interval} from the specified string, using any offset it contains.
+     * <p>
+     * The String formats are described by
+     * {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}
+     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',
+     * 'datetime/period' or 'period/datetime'.
+     * <p>
+     * Sometimes this method and {@code new Interval(str)} return different results.
+     * This can be confusing as the difference is not visible in {@link #toString()}.
+     * <p>
+     * When passed a string without an offset, such as '2010-06-30T01:20/P1D',
+     * both the constructor and this method use the default time-zone.
+     * As such, {@code Interval.parseWithOffset("2010-06-30T01:20/P1D")} and
+     * {@code new Interval("2010-06-30T01:20/P1D"))} are equal.
+     * <p>
+     * However, when this method is passed a string with an offset,
+     * the offset is directly parsed and stored.
+     * As such, {@code Interval.parseWithOffset("2010-06-30T01:20+02:00/P1D")} and
+     * {@code new Interval("2010-06-30T01:20+02:00/P1D"))} are NOT equal.
+     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(2)}.
+     * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
+     * 
+     * @param str  the string to parse, not null
+     * @since 2.9
+     */
+    public static Interval parseWithOffset(String str) {
+        int separator = str.indexOf('/');
+        if (separator < 0) {
+            throw new IllegalArgumentException("Format requires a '/' separator: " + str);
+        }
+        String leftStr = str.substring(0, separator);
+        if (leftStr.length() <= 0) {
+            throw new IllegalArgumentException("Format invalid: " + str);
+        }
+        String rightStr = str.substring(separator + 1);
+        if (rightStr.length() <= 0) {
+            throw new IllegalArgumentException("Format invalid: " + str);
+        }
+
+        DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser().withOffsetParsed();
+        PeriodFormatter periodParser = ISOPeriodFormat.standard();
+        DateTime start = null;
+        Period period = null;
+        
+        // before slash
+        char c = leftStr.charAt(0);
+        if (c == 'P' || c == 'p') {
+            period = periodParser.withParseType(PeriodType.standard()).parsePeriod(leftStr);
+        } else {
+            start = dateTimeParser.parseDateTime(leftStr);
+        }
+        
+        // after slash
+        c = rightStr.charAt(0);
+        if (c == 'P' || c == 'p') {
+            if (period != null) {
+                throw new IllegalArgumentException("Interval composed of two durations: " + str);
+            }
+            period = periodParser.withParseType(PeriodType.standard()).parsePeriod(rightStr);
+            return new Interval(start, period);
+        } else {
+            DateTime end = dateTimeParser.parseDateTime(rightStr);
+            if (period != null) {
+                return new Interval(period, end);
+            } else {
+                return new Interval(start, end);
+            }
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Constructs an interval from a start and end instant with the ISO
diff --git a/src/test/java/org/joda/time/TestInterval_Constructors.java b/src/test/java/org/joda/time/TestInterval_Constructors.java
index 905b2637..5392ca0b 100644
--- a/src/test/java/org/joda/time/TestInterval_Constructors.java
+++ b/src/test/java/org/joda/time/TestInterval_Constructors.java
@@ -39,6 +39,7 @@ public class TestInterval_Constructors extends TestCase {
 
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
+    private static final DateTimeZone OFFSET_04_00 = DateTimeZone.forOffsetHours(4);
     
     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
@@ -102,7 +103,7 @@ public class TestInterval_Constructors extends TestCase {
     }
 
     //-----------------------------------------------------------------------
-    public void testParse_noFormatter() throws Throwable {
+    public void testParse_noOffsetInString() throws Throwable {
         DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS));
         DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS));
         assertEquals(new Interval(start, end), Interval.parse("2010-06-30T12:30/2010-07-01T14:30"));
@@ -110,6 +111,45 @@ public class TestInterval_Constructors extends TestCase {
         assertEquals(new Interval(start, end), Interval.parse("P1DT2H/2010-07-01T14:30"));
     }
 
+    public void testParse_offsetInString() throws Throwable {
+        DateTime start = new DateTime(2010, 6, 30, 10, 30, ISOChronology.getInstance(PARIS));
+        DateTime end = new DateTime(2010, 7, 1, 12, 30, ISOChronology.getInstance(PARIS));
+        assertEquals(new Interval(start, end), Interval.parse("2010-06-30T12:30+04:00/2010-07-01T14:30+04:00"));
+        assertEquals(new Interval(start, end), Interval.parse("2010-06-30T12:30+04:00/P1DT2H"));
+        assertEquals(new Interval(start, end), Interval.parse("P1DT2H/2010-07-01T14:30+04:00"));
+    }
+
+    public void testParseWithOffset_noOffsetInString() throws Throwable {
+        DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS));
+        DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("2010-06-30T12:30/2010-07-01T14:30"));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("2010-06-30T12:30/P1DT2H"));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("P1DT2H/2010-07-01T14:30"));
+    }
+
+    public void testParseWithOffset_offsetInString() throws Throwable {
+        DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(OFFSET_04_00));
+        DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(OFFSET_04_00));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("2010-06-30T12:30+04:00/2010-07-01T14:30+04:00"));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("2010-06-30T12:30+04:00/p1DT2H"));
+        assertEquals(new Interval(start, end), Interval.parseWithOffset("p1DT2H/2010-07-01T14:30+04:00"));
+    }
+
+    public void testParseWithOffset_invalid() throws Throwable {
+        try {
+            Interval.parseWithOffset("2010-06-30T12:30");
+            fail();
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+        try {
+            Interval.parseWithOffset("P1D/P1D");
+            fail();
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+    }
+
     //-----------------------------------------------------------------------
     public void testConstructor_long_long1() throws Throwable {
         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
