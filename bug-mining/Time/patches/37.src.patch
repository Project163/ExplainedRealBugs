diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index d824b7cf..412da1a2 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -40,7 +40,13 @@ Serialization compatible - Yes
 Data compatible - Yes, except
  - DateTimeZone data updated to version 2014e
 
-Semantic compatible - Yes
+Semantic compatible - Yes, except
+ - LocalDate.toDateTime(LocalTime) and LocalDate.toDateTime(LocalTime, DateTimeZone)
+   If you pass a null LocalTime to the method, no changes have been made
+   If you pass a non-null LocalTime then behaviour during daylight saving gap and overlap has changed
+   During a daylight saving gap the exception has changed from IllegalFieldValueException to IllegalInstantException
+   During a daylight saving overlap the earlier offset is selected
+   Previously, the earlier offset was chosen east of Greenwich and the later offset west of Greenwich
 
 
 Deprecations since 2.4
diff --git a/src/main/java/org/joda/time/LocalDate.java b/src/main/java/org/joda/time/LocalDate.java
index 9806eb32..b0c2b5af 100644
--- a/src/main/java/org/joda/time/LocalDate.java
+++ b/src/main/java/org/joda/time/LocalDate.java
@@ -902,16 +902,22 @@ public final class LocalDate
      * <p>
      * The resulting chronology is determined by the chronology of this
      * LocalDate. The chronology of the time must match.
-     * If the time is null, the current time in the date's chronology is used.
      * <p>
-     * This method will throw an exception if the datetime that would be
-     * created does not exist when the time zone is taken into account.
+     * If the time is null, this method delegates to {@link #toDateTimeAtCurrentTime(DateTimeZone)}
+     * and the following documentation does not apply.
+     * <p>
+     * When the time zone is applied, the local date-time may be affected by daylight saving.
+     * In a daylight saving gap, when the local time does not exist,
+     * this method will throw an exception.
+     * In a daylight saving overlap, when the same local time occurs twice,
+     * this method returns the first occurrence of the local time.
      * <p>
      * This instance is immutable and unaffected by this method call.
      *
-     * @param time  the time of day to use, null means current time
+     * @param time  the time of day to use, null uses current time
      * @return the DateTime instance
      * @throws IllegalArgumentException if the chronology of the time does not match
+     * @throws IllegalInstantException if the local time does not exist when the time zone is applied
      */
     public DateTime toDateTime(LocalTime time) {
         return toDateTime(time, null);
@@ -923,29 +929,36 @@ public final class LocalDate
      * <p>
      * The resulting chronology is determined by the chronology of this
      * LocalDate plus the time zone. The chronology of the time must match.
-     * If the time is null, the current time in the date's chronology is used.
      * <p>
-     * This method will throw an exception if the datetime that would be
-     * created does not exist when the time zone is taken into account.
+     * If the time is null, this method delegates to {@link #toDateTimeAtCurrentTime(DateTimeZone)}
+     * and the following documentation does not apply.
+     * <p>
+     * When the time zone is applied, the local date-time may be affected by daylight saving.
+     * In a daylight saving gap, when the local time does not exist,
+     * this method will throw an exception.
+     * In a daylight saving overlap, when the same local time occurs twice,
+     * this method returns the first occurrence of the local time.
      * <p>
      * This instance is immutable and unaffected by this method call.
      *
-     * @param time  the time of day to use, null means current time
+     * @param time  the time of day to use, null uses current time
      * @param zone  the zone to get the DateTime in, null means default
      * @return the DateTime instance
      * @throws IllegalArgumentException if the chronology of the time does not match
+     * @throws IllegalInstantException if the local time does not exist when the time zone is applied
      */
     public DateTime toDateTime(LocalTime time, DateTimeZone zone) {
-        if (time != null && getChronology() != time.getChronology()) {
+        if (time == null) {
+            return toDateTimeAtCurrentTime(zone);
+        }
+        if (getChronology() != time.getChronology()) {
             throw new IllegalArgumentException("The chronology of the time does not match");
         }
         Chronology chrono = getChronology().withZone(zone);
-        long instant = DateTimeUtils.currentTimeMillis();
-        instant = chrono.set(this, instant);
-        if (time != null) {
-            instant = chrono.set(time, instant);
-        }
-        return new DateTime(instant, chrono);
+        return new DateTime(
+                        getYear(), getMonthOfYear(), getDayOfMonth(),
+                        time.getHourOfDay(), time.getMinuteOfHour(),
+                        time.getSecondOfMinute(), time.getMillisOfSecond(), chrono);
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/main/java/org/joda/time/LocalDateTime.java b/src/main/java/org/joda/time/LocalDateTime.java
index 44d2ee9c..b31ee6cb 100644
--- a/src/main/java/org/joda/time/LocalDateTime.java
+++ b/src/main/java/org/joda/time/LocalDateTime.java
@@ -718,10 +718,14 @@ public final class LocalDateTime
     /**
      * Converts this object to a DateTime using the default zone.
      * <p>
-     * This method will throw an exception if the datetime that would be
-     * created does not exist when the time zone is taken into account.
+     * When the time zone is applied, the local date-time may be affected by daylight saving.
+     * In a daylight saving gap, when the local time does not exist,
+     * this method will throw an exception.
+     * In a daylight saving overlap, when the same local time occurs twice,
+     * this method returns the first occurrence of the local time.
      * 
      * @return <code>this</code>
+     * @throws IllegalInstantException if the local time does not exist when the time zone is applied
      */
     public DateTime toDateTime() {
         return toDateTime((DateTimeZone) null);
@@ -730,11 +734,15 @@ public final class LocalDateTime
     /**
      * Converts this object to a DateTime using the specified zone.
      * <p>
-     * This method will throw an exception if the datetime that would be
-     * created does not exist when the time zone is taken into account.
+     * When the time zone is applied, the local date-time may be affected by daylight saving.
+     * In a daylight saving gap, when the local time does not exist,
+     * this method will throw an exception.
+     * In a daylight saving overlap, when the same local time occurs twice,
+     * this method returns the first occurrence of the local time.
      * 
      * @param zone time zone to apply, or default if null
      * @return a DateTime using the same millis
+     * @throws IllegalInstantException if the local time does not exist when the time zone is applied
      */
     public DateTime toDateTime(DateTimeZone zone) {
         zone = DateTimeUtils.getZone(zone);
diff --git a/src/test/java/org/joda/time/TestLocalDateTime_Basics.java b/src/test/java/org/joda/time/TestLocalDateTime_Basics.java
index 315a4124..a32532ce 100644
--- a/src/test/java/org/joda/time/TestLocalDateTime_Basics.java
+++ b/src/test/java/org/joda/time/TestLocalDateTime_Basics.java
@@ -48,12 +48,14 @@ public class TestLocalDateTime_Basics extends TestCase {
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
     private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");
+    private static final DateTimeZone NEW_YORK = DateTimeZone.forID("America/New_York");
     private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC();
     private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);
     private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON);
     private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO);
     private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();
     private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);
+    private static final Chronology ISO_NEW_YORK = ISOChronology.getInstance(NEW_YORK);
     private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();
     private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC();
     private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON);
@@ -789,6 +791,28 @@ public class TestLocalDateTime_Basics extends TestCase {
         assertEquals(expected, test);
     }
 
+    public void testToDateTime_Zone_dstGap() {
+        LocalDateTime base = new LocalDateTime(2014, 3, 30, 1, 30, 0, 0, ISO_LONDON);
+        try {
+            base.toDateTime(LONDON);
+            fail();
+        } catch (IllegalInstantException ex) {}
+    }
+
+    public void testToDateTime_Zone_dstOverlap() {
+        LocalDateTime base = new LocalDateTime(2014, 10, 26, 1, 30, 0, 0, ISO_LONDON);
+        DateTime test = base.toDateTime(LONDON);
+        DateTime expected = new DateTime(2014, 10, 26, 1, 30, ISO_LONDON).withEarlierOffsetAtOverlap();
+        assertEquals(expected, test);
+    }
+
+    public void testToDateTime_Zone_dstOverlap_NewYork() {
+        LocalDateTime base = new LocalDateTime(2007, 11, 4, 1, 30, 0, 0, ISO_NEW_YORK);
+        DateTime test = base.toDateTime(NEW_YORK);
+        DateTime expected = new DateTime(2007, 11, 4, 1, 30, ISO_NEW_YORK).withEarlierOffsetAtOverlap();
+        assertEquals(expected, test);
+    }
+
     //-----------------------------------------------------------------------
     public void testToLocalDate() {
         LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant
diff --git a/src/test/java/org/joda/time/TestLocalDate_Basics.java b/src/test/java/org/joda/time/TestLocalDate_Basics.java
index 732e4ea4..6dd7db4c 100644
--- a/src/test/java/org/joda/time/TestLocalDate_Basics.java
+++ b/src/test/java/org/joda/time/TestLocalDate_Basics.java
@@ -50,6 +50,7 @@ public class TestLocalDate_Basics extends TestCase {
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
     private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");
+    private static final DateTimeZone NEW_YORK = DateTimeZone.forID("America/New_York");
 //    private static final int OFFSET = 1;
     private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC();
     private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);
@@ -58,6 +59,7 @@ public class TestLocalDate_Basics extends TestCase {
     private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();
 //    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);
     private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON);
+    private static final Chronology ISO_NEW_YORK = ISOChronology.getInstance(NEW_YORK);
 //    private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO);
 //    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();
     private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);
@@ -861,6 +863,31 @@ public class TestLocalDate_Basics extends TestCase {
         assertEquals(expected, test);
     }
 
+    public void testToDateTime_LocalTime_Zone_dstGap() {
+        LocalDate base = new LocalDate(2014, 3, 30, ISO_LONDON);
+        LocalTime tod = new LocalTime(1, 30, 0, 0, ISO_LONDON);
+        try {
+            base.toDateTime(tod, LONDON);
+            fail();
+        } catch (IllegalInstantException ex) {}
+    }
+
+    public void testToDateTime_LocalTime_Zone_dstOverlap() {
+        LocalDate base = new LocalDate(2014, 10, 26, ISO_LONDON);
+        LocalTime tod = new LocalTime(1, 30, 0, 0, ISO_LONDON);
+        DateTime test = base.toDateTime(tod, LONDON);
+        DateTime expected = new DateTime(2014, 10, 26, 1, 30, ISO_LONDON).withEarlierOffsetAtOverlap();
+        assertEquals(expected, test);
+    }
+
+    public void testToDateTime_LocalTime_Zone_dstOverlap_NewYork() {
+        LocalDate base = new LocalDate(2007, 11, 4, ISO_NEW_YORK);
+        LocalTime tod = new LocalTime(1, 30, 0, 0, ISO_NEW_YORK);
+        DateTime test = base.toDateTime(tod, NEW_YORK);
+        DateTime expected = new DateTime(2007, 11, 4, 1, 30, ISO_NEW_YORK).withEarlierOffsetAtOverlap();
+        assertEquals(expected, test);
+    }
+
     public void testToDateTime_wrongChronoLocalTime_Zone() {
         LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant
         LocalTime tod = new LocalTime(12, 13, 14, 15, BUDDHIST_TOKYO);
