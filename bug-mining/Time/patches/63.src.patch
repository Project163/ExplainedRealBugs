diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 117545fa..8d277ff7 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -31,6 +31,10 @@ Changes in 2.8.3
 
 - Add Czech period translations [#313]
 
+- Allow DateTime and Interval to refer to values at Long.MIN_VALUE and Long.MAX_VALUE [#297, #190]
+  A DateTime may be created with any millisecond value, however at the very edges there may be
+  some undesirable effects, for example alway using UTC instead of the time-zone
+
 - Fix overflow bug in intervals [#315]
 
 - Better error message for malformed tzdb files [#319]
diff --git a/src/main/java/org/joda/time/DateTimeField.java b/src/main/java/org/joda/time/DateTimeField.java
index acf01c33..5246cefd 100644
--- a/src/main/java/org/joda/time/DateTimeField.java
+++ b/src/main/java/org/joda/time/DateTimeField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -378,6 +378,20 @@ public abstract class DateTimeField {
      */
     public abstract long set(long instant, int value);
 
+    /**
+     * Sets a value in the milliseconds supplied, allowing a little leniency at the margins.
+     * <p>
+     * This is primarily an internal method used by parsing.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  the value to set, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public long setExtended(long instant, int value) {
+        return set(instant, value);
+    }
+
     /**
      * Sets a value using the specified partial instant.
      * <p>
diff --git a/src/main/java/org/joda/time/base/BaseDateTime.java b/src/main/java/org/joda/time/base/BaseDateTime.java
index 4b00e77c..0fe829fd 100644
--- a/src/main/java/org/joda/time/base/BaseDateTime.java
+++ b/src/main/java/org/joda/time/base/BaseDateTime.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -124,10 +124,7 @@ public abstract class BaseDateTime
         super();
         iChronology = checkChronology(chronology);
         iMillis = checkInstant(instant, iChronology);
-        // validate not over maximum
-        if (iChronology.year().isSupported()) {
-            iChronology.year().set(iMillis, iChronology.year().get(iMillis));
-        }
+        adjustForMinMax();
     }
 
     //-----------------------------------------------------------------------
@@ -152,6 +149,7 @@ public abstract class BaseDateTime
         Chronology chrono = checkChronology(converter.getChronology(instant, zone));
         iChronology = chrono;
         iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);
+        adjustForMinMax();
     }
 
     /**
@@ -173,6 +171,7 @@ public abstract class BaseDateTime
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
         iChronology = checkChronology(converter.getChronology(instant, chronology));
         iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology);
+        adjustForMinMax();
     }
 
     //-----------------------------------------------------------------------
@@ -258,6 +257,13 @@ public abstract class BaseDateTime
         long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,
             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         iMillis = checkInstant(instant, iChronology);
+        adjustForMinMax();
+    }
+
+    private void adjustForMinMax() {
+        if (iMillis == Long.MIN_VALUE || iMillis == Long.MAX_VALUE) {
+            iChronology = iChronology.withUTC();
+        }
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/main/java/org/joda/time/chrono/BasicChronology.java b/src/main/java/org/joda/time/chrono/BasicChronology.java
index d3442485..e0ec9237 100644
--- a/src/main/java/org/joda/time/chrono/BasicChronology.java
+++ b/src/main/java/org/joda/time/chrono/BasicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2014 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -146,6 +146,7 @@ abstract class BasicChronology extends AssembledChronology {
         return DateTimeZone.UTC;
     }
 
+    @Override
     public long getDateTimeMillis(
             int year, int monthOfYear, int dayOfMonth, int millisOfDay)
             throws IllegalArgumentException {
@@ -156,9 +157,10 @@ abstract class BasicChronology extends AssembledChronology {
 
         FieldUtils.verifyValueBounds
             (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1);
-        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
+        return getDateTimeMillis0(year, monthOfYear, dayOfMonth, millisOfDay);
     }
 
+    @Override
     public long getDateTimeMillis(
             int year, int monthOfYear, int dayOfMonth,
             int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)
@@ -173,12 +175,29 @@ abstract class BasicChronology extends AssembledChronology {
         FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);
         FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);
         FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);
-
-        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)
-            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
-            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
-            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
-            + millisOfSecond;
+        long millisOfDay = hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
+                        + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
+                        + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
+                        + millisOfSecond;
+        return getDateTimeMillis0(year, monthOfYear, dayOfMonth, (int) millisOfDay);
+    }
+
+    private long getDateTimeMillis0(int year, int monthOfYear, int dayOfMonth, int millisOfDay) {
+        long dayInstant = getDateMidnightMillis(year, monthOfYear, dayOfMonth);
+        // try reversed calculation from next day for MIN
+        if (dayInstant == Long.MIN_VALUE) {
+            dayInstant = getDateMidnightMillis(year, monthOfYear, dayOfMonth + 1);
+            millisOfDay  = millisOfDay - 86400000;
+        }
+        // check for limit caused by millisOfDay addition
+        // even if dayInstant already MIN or MAX, this still works fine with int math
+        long result = dayInstant + millisOfDay;
+        if (result  < 0 && dayInstant > 0) {
+            return Long.MAX_VALUE;
+        } else if (result  > 0 && dayInstant < 0) {
+            return Long.MIN_VALUE;
+        }
+        return result;
     }
 
     public int getMinimumDaysInFirstWeek() {
@@ -608,10 +627,17 @@ abstract class BasicChronology extends AssembledChronology {
      * @return the milliseconds
      */
     long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {
-        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());
+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear() - 1, getMaxYear() + 1);
         FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));
         FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));
-        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);
+        long instant = getYearMonthDayMillis(year, monthOfYear, dayOfMonth);
+        // check for limit caused by min/max year +1/-1
+        if (instant < 0 && year == getMaxYear() + 1) {
+            return Long.MAX_VALUE;
+        } else if (instant > 0 && year == getMinYear() - 1) {
+            return Long.MIN_VALUE;
+        }
+        return instant;
     }
 
     /**
diff --git a/src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java
index 6ded862c..e7f2516d 100644
--- a/src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -85,6 +85,13 @@ class BasicYearDateTimeField extends ImpreciseDateTimeField {
         return iChronology.setYear(instant, year);
     }
 
+    @Override
+    public long setExtended(long instant, int year) {
+        FieldUtils.verifyValueBounds(
+                this, year, iChronology.getMinYear() - 1, iChronology.getMaxYear() + 1);
+        return iChronology.setYear(instant, year);
+    }
+
     public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
         if (minuendInstant < subtrahendInstant) {
             return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);
diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java
index 31e67ed3..0acbf689 100644
--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java
+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -135,9 +135,19 @@ public final class ZonedChronology extends AssembledChronology {
      * @return the instant from 1970-01-01T00:00:00Z
      */
     private long localToUTC(long localInstant) {
+        if (localInstant == Long.MAX_VALUE) {
+            return Long.MAX_VALUE;
+        } else if (localInstant == Long.MIN_VALUE) {
+            return Long.MIN_VALUE;
+        }
         DateTimeZone zone = getZone();
         int offset = zone.getOffsetFromLocal(localInstant);
         long utcInstant = localInstant - offset;
+        if (localInstant > 0 && utcInstant < 0) {
+            return Long.MAX_VALUE;
+        } else if (localInstant < 0 && utcInstant > 0) {
+            return Long.MIN_VALUE;
+        }
         int offsetBasedOnUtc = zone.getOffset(utcInstant);
         if (offset != offsetBasedOnUtc) {
             throw new IllegalInstantException(localInstant, zone.getID());
diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
index a71a6db0..552d888d 100644
--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2014 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -565,7 +565,7 @@ public class DateTimeParserBucket {
         
         long set(long millis, boolean reset) {
             if (iText == null) {
-                millis = iField.set(millis, iValue);
+                millis = iField.setExtended(millis, iValue);
             } else {
                 millis = iField.set(millis, iText, iLocale);
             }
diff --git a/src/test/java/org/joda/time/TestAll.java b/src/test/java/org/joda/time/TestAll.java
index 3a7fb645..3a579c75 100644
--- a/src/test/java/org/joda/time/TestAll.java
+++ b/src/test/java/org/joda/time/TestAll.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -129,6 +129,7 @@ public class TestAll extends TestCase {
         suite.addTest(TestStringConvert.suite());
         suite.addTest(TestSerialization.suite());
         suite.addTest(TestIllegalFieldValueException.suite());
+        suite.addTest(TestMinMaxLong.suite());
         return suite;
     }
 
diff --git a/src/test/java/org/joda/time/TestDateTime_Constructors.java b/src/test/java/org/joda/time/TestDateTime_Constructors.java
index 24f2b1d0..7c617bfc 100644
--- a/src/test/java/org/joda/time/TestDateTime_Constructors.java
+++ b/src/test/java/org/joda/time/TestDateTime_Constructors.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -243,36 +243,6 @@ public class TestDateTime_Constructors extends TestCase {
         assertEquals(TEST_TIME2, test.getMillis());
     }
 
-    /**
-     * Test constructor (long)
-     */
-    public void testConstructor_long_max() throws Throwable {
-        DateTime dt = new DateTime(292278993, 12, 31, 23, 59, 59, 999);
-        DateTime test = new DateTime(dt.getMillis());
-        assertEquals(dt, test);
-        try {
-            new DateTime(dt.getMillis() + 1);
-            fail();
-        } catch (IllegalFieldValueException ex) {
-            // expected
-        }
-    }
-
-    /**
-     * Test constructor (long)
-     */
-    public void testConstructor_long_min() throws Throwable {
-        DateTime dt = new DateTime(-292275054, 1, 1, 0, 0);
-        DateTime test = new DateTime(dt.getMillis());
-        assertEquals(dt, test);
-        try {
-            new DateTime(dt.getMillis() - 1);
-            fail();
-        } catch (IllegalFieldValueException ex) {
-            // expected
-        }
-    }
-
     /**
      * Test constructor (long, DateTimeZone)
      */
diff --git a/src/test/java/org/joda/time/TestInterval_Constructors.java b/src/test/java/org/joda/time/TestInterval_Constructors.java
index 5392ca0b..5e36cdb4 100644
--- a/src/test/java/org/joda/time/TestInterval_Constructors.java
+++ b/src/test/java/org/joda/time/TestInterval_Constructors.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2006 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -177,6 +177,56 @@ public class TestInterval_Constructors extends TestCase {
         } catch (IllegalArgumentException ex) {}
     }
 
+    public void testConstructor_long_long_minMax() throws Throwable {
+        Interval test = new Interval(Long.MIN_VALUE, Long.MAX_VALUE);
+        assertEquals(Long.MIN_VALUE, test.getStartMillis());
+        assertEquals(Long.MAX_VALUE, test.getEndMillis());
+        assertEquals(new DateTime(Long.MIN_VALUE), test.getStart());
+        assertEquals(new DateTime(Long.MAX_VALUE), test.getEnd());
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(test, test.toInterval());
+        assertEquals("-292275055-05-16T16:56:25.192+00:09:21/292278994-08-17T07:12:55.807Z", test.toString());
+        try {
+            test.toDuration();
+            fail();
+        } catch (ArithmeticException ex) {}
+        try {
+            test.toDurationMillis();
+            fail();
+        } catch (ArithmeticException ex) {}
+        try {
+            test.toPeriod();
+            fail();
+        } catch (RuntimeException ex) {}
+    }
+
+    public void testConstructor_long_long_min() throws Throwable {
+        Interval test = new Interval(Long.MIN_VALUE, Long.MIN_VALUE + 9);
+        assertEquals(Long.MIN_VALUE, test.getStartMillis());
+        assertEquals(Long.MIN_VALUE + 9, test.getEndMillis());
+        assertEquals(new DateTime(Long.MIN_VALUE), test.getStart());
+        assertEquals(new DateTime(Long.MIN_VALUE + 9), test.getEnd());
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(test, test.toInterval());
+        assertEquals("-292275055-05-16T16:56:25.192+00:09:21/-292275055-05-16T16:56:25.201+00:09:21", test.toString());
+        assertEquals(9, test.toDurationMillis());
+        assertEquals(new Duration(9), test.toDuration());
+        assertEquals(new Period(9), test.toPeriod());
+    }
+
+    public void testConstructor_long_long_max() throws Throwable {
+        Interval test = new Interval(Long.MAX_VALUE - 9, Long.MAX_VALUE);
+        assertEquals(Long.MAX_VALUE - 9, test.getStartMillis());
+        assertEquals(Long.MAX_VALUE, test.getEndMillis());
+        assertEquals(new DateTime(Long.MAX_VALUE - 9), test.getStart());
+        assertEquals(new DateTime(Long.MAX_VALUE), test.getEnd());
+        assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(test, test.toInterval());
+        assertEquals("292278994-08-17T07:12:55.798Z/292278994-08-17T07:12:55.807Z", test.toString());
+        assertEquals(9, test.toDurationMillis());
+        assertEquals(new Duration(9), test.toDuration());
+    }
+
     //-----------------------------------------------------------------------
     public void testConstructor_long_long_Zone() throws Throwable {
         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);
diff --git a/src/test/java/org/joda/time/TestMinMaxLong.java b/src/test/java/org/joda/time/TestMinMaxLong.java
new file mode 100644
index 00000000..85cbe79d
--- /dev/null
+++ b/src/test/java/org/joda/time/TestMinMaxLong.java
@@ -0,0 +1,317 @@
+/*
+ *  Copyright 2001-2015 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time;
+
+import java.util.Locale;
+
+import org.joda.time.chrono.ISOChronology;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+/**
+ * This class is a Junit unit test for min/max long values.
+ *
+ * @author Stephen Colebourne
+ */
+public class TestMinMaxLong extends TestCase {
+
+    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
+    private static final int ACTUAL_MAX_YEAR = 292278994;
+    private static final int ACTUAL_MIN_YEAR = -292275055;
+
+    private DateTimeZone zone = null;
+    private Locale locale = null;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestMinMaxLong.class);
+    }
+
+    public TestMinMaxLong(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        zone = DateTimeZone.getDefault();
+        locale = Locale.getDefault();
+        DateTimeZone.setDefault(LONDON);
+        java.util.TimeZone.setDefault(LONDON.toTimeZone());
+        Locale.setDefault(Locale.UK);
+    }
+
+    protected void tearDown() throws Exception {
+        DateTimeZone.setDefault(zone);
+        java.util.TimeZone.setDefault(zone.toTimeZone());
+        Locale.setDefault(locale);
+        zone = null;
+    }
+
+    //-----------------------------------------------------------------------
+    public void testDateTime_max() throws Throwable {
+        // toString adjusts to UTC rather than overflow
+        DateTime dt = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 807, DateTimeZone.UTC);
+        assertEquals(Long.MAX_VALUE, dt.getMillis());
+        assertEquals(ISOChronology.getInstanceUTC(), dt.getChronology());
+        DateTime test = new DateTime(Long.MAX_VALUE);
+        assertEquals(Long.MAX_VALUE, test.getMillis());
+        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());
+    }
+
+    public void testDateTime_max_math() throws Throwable {
+        DateTime test = new DateTime(Long.MAX_VALUE);  // always in UTC
+        assertEquals("292278994-08-17T07:12:55.807Z", test.toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 807, DateTimeZone.UTC), test.minus(807));
+        assertEquals("292278994-08-17T07:12:55.000Z", test.minus(807).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 1000, DateTimeZone.UTC), test.minusSeconds(1));
+        assertEquals("292278994-08-17T07:12:54.807Z", test.minusSeconds(1).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 60000, DateTimeZone.UTC), test.minusMinutes(1));
+        assertEquals("292278994-08-17T07:11:55.807Z", test.minusMinutes(1).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 3600000, DateTimeZone.UTC), test.minusHours(1));
+        assertEquals("292278994-08-17T06:12:55.807Z", test.minusHours(1).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 3600000, DateTimeZone.UTC), test.minusHours(1));
+        assertEquals("292278994-08-17T06:12:55.808Z", test.minusHours(1).plusMillis(1).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - (3600000 - 60000), DateTimeZone.UTC), test.minusMinutes(59));
+        assertEquals("292278994-08-17T06:13:55.807Z", test.minusMinutes(59).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - (3600000 - 60000) + 1, DateTimeZone.UTC), test.minusMinutes(59).plusMillis(1));
+        assertEquals("292278994-08-17T06:13:55.808Z", test.minusMinutes(59).plusMillis(1).toString());
+        
+        assertEquals(new DateTime(Long.MAX_VALUE - 3600000, DateTimeZone.UTC), test.minusMinutes(61).plusMinutes(1));
+        assertEquals("292278994-08-17T06:12:55.807Z", test.minusHours(1).toString());
+        
+        try {
+            test.plusMillis(1);
+            fail();
+        } catch (ArithmeticException ex) {
+            // expected
+        }
+    }
+
+    public void testDateTime_max_fields() {
+        assertEquals(ACTUAL_MAX_YEAR, ISOChronology.getInstanceUTC().year().getMaximumValue() + 1);
+        // ensure time-zone correct in previous year
+        assertEquals("292278992-06-30T00:00:00.000+01:00", new DateTime(292278992, 6, 30, 0, 0).toString());
+        assertEquals("292278992-12-31T00:00:00.000Z", new DateTime(292278992, 12, 31, 0, 0).toString());
+//        assertEquals("292278993-06-30T00:00:00.000+01:00", new DateTime(292278993, 6, 30, 0, 0).toString());
+        assertEquals("292278993-12-31T00:00:00.000Z", new DateTime(292278993, 12, 31, 0, 0).toString());
+        // permitted
+        DateTime a = new DateTime(ACTUAL_MAX_YEAR, 1, 1, 0, 0, 0, 0);
+        assertEquals("292278994-01-01T00:00:00.000Z", a.toString());
+        // permitted
+        DateTime b = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 0, 0, 0);
+        assertEquals("292278994-08-17T07:00:00.000+01:00", b.toString());
+        // permitted
+        DateTime c = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 0);
+        assertEquals("292278994-08-17T07:12:55.000+01:00", c.toString());
+        // permitted
+        DateTime d = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 806);
+        assertEquals(new DateTime(Long.MAX_VALUE - 1 - 3600000), d);
+        assertEquals("292278994-08-17T07:12:55.806+01:00", d.toString());
+        // clamp to max
+        DateTime e = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 807);
+        assertEquals(new DateTime(Long.MAX_VALUE), e);
+        assertEquals("292278994-08-17T07:12:55.807Z", e.toString());
+        // clamp to max
+        DateTime f = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 808);
+        assertEquals(new DateTime(Long.MAX_VALUE), f);
+        assertEquals("292278994-08-17T07:12:55.807Z", f.toString());
+        // clamp to max
+        DateTime g = new DateTime(ACTUAL_MAX_YEAR, 12, 31, 23, 59, 59, 999);
+        assertEquals(new DateTime(Long.MAX_VALUE), g);
+        assertEquals("292278994-08-17T07:12:55.807Z", g.toString());
+    }
+
+    public void testDateTime_max_fieldsUTC() {
+        DateTimeZone.setDefault(DateTimeZone.UTC);
+        assertEquals(ACTUAL_MAX_YEAR, ISOChronology.getInstanceUTC().year().getMaximumValue() + 1);
+        // ensure time-zone correct in previous year
+        assertEquals("292278992-06-30T00:00:00.000Z", new DateTime(292278992, 6, 30, 0, 0).toString());
+        assertEquals("292278992-12-31T00:00:00.000Z", new DateTime(292278992, 12, 31, 0, 0).toString());
+        assertEquals("292278993-06-30T00:00:00.000Z", new DateTime(292278993, 6, 30, 0, 0).toString());
+        assertEquals("292278993-12-31T00:00:00.000Z", new DateTime(292278993, 12, 31, 0, 0).toString());
+        // permitted
+        DateTime a = new DateTime(ACTUAL_MAX_YEAR, 1, 1, 0, 0, 0, 0);
+        assertEquals("292278994-01-01T00:00:00.000Z", a.toString());
+        // permitted
+        DateTime b = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 0, 0, 0);
+        assertEquals("292278994-08-17T07:00:00.000Z", b.toString());
+        // permitted
+        DateTime c = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 0);
+        assertEquals("292278994-08-17T07:12:55.000Z", c.toString());
+        // permitted
+        DateTime d = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 806);
+        assertEquals(new DateTime(Long.MAX_VALUE - 1), d);
+        assertEquals("292278994-08-17T07:12:55.806Z", d.toString());
+        // clamp to max
+        DateTime e = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 807);
+        assertEquals(new DateTime(Long.MAX_VALUE), e);
+        assertEquals("292278994-08-17T07:12:55.807Z", e.toString());
+        // clamp to max
+        DateTime f = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 808);
+        assertEquals(new DateTime(Long.MAX_VALUE), f);
+        assertEquals("292278994-08-17T07:12:55.807Z", f.toString());
+        // clamp to max
+        DateTime g = new DateTime(ACTUAL_MAX_YEAR, 12, 31, 23, 59, 59, 999);
+        assertEquals(new DateTime(Long.MAX_VALUE), g);
+        assertEquals("292278994-08-17T07:12:55.807Z", g.toString());
+    }
+
+    public void testDateTime_max_fieldsNewYork() {
+        DateTimeZone.setDefault(DateTimeZone.forID("America/New_York"));
+        assertEquals(ACTUAL_MAX_YEAR, ISOChronology.getInstanceUTC().year().getMaximumValue() + 1);
+        // ensure time-zone correct in previous year
+        assertEquals("292278992-06-30T00:00:00.000-04:00", new DateTime(292278992, 6, 30, 0, 0).toString());
+        assertEquals("292278992-12-31T00:00:00.000-05:00", new DateTime(292278992, 12, 31, 0, 0).toString());
+//        assertEquals("292278993-06-30T00:00:00.000-04:00", new DateTime(292278993, 6, 30, 0, 0).toString());
+        assertEquals("292278993-12-31T00:00:00.000-05:00", new DateTime(292278993, 12, 31, 0, 0).toString());
+        // permitted
+        DateTime a = new DateTime(ACTUAL_MAX_YEAR, 1, 1, 0, 0, 0, 0);
+        assertEquals("292278994-01-01T00:00:00.000-05:00", a.toString());
+        // permitted
+        DateTime b = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 3, 0, 0, 0);
+        assertEquals("292278994-08-17T03:00:00.000-04:00", b.toString());
+        // permitted
+        DateTime c = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 3, 12, 55, 0);
+        assertEquals("292278994-08-17T03:12:55.000-04:00", c.toString());
+        // permitted
+        DateTime d = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 3, 12, 55, 806);
+        assertEquals(new DateTime(Long.MAX_VALUE - 1), d);
+        assertEquals("292278994-08-17T03:12:55.806-04:00", d.toString());
+        // clamp to max
+        DateTime e = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 3, 12, 55, 807);
+        assertEquals(new DateTime(Long.MAX_VALUE), e);
+        assertEquals("292278994-08-17T07:12:55.807Z", e.toString());
+        // clamp to max
+        DateTime f = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 807);
+        assertEquals(new DateTime(Long.MAX_VALUE), f);
+        assertEquals("292278994-08-17T07:12:55.807Z", f.toString());
+        // clamp to max
+        DateTime g = new DateTime(ACTUAL_MAX_YEAR, 12, 31, 23, 59, 59, 999);
+        assertEquals(new DateTime(Long.MAX_VALUE), g);
+        assertEquals("292278994-08-17T07:12:55.807Z", g.toString());
+    }
+
+    public void testDateTime_max_long() {
+        assertEquals("292278994-08-17T07:12:55.807+01:00", new DateTime(Long.MAX_VALUE - 3600000).toString());
+        assertEquals("292278994-08-17T06:12:55.808Z", new DateTime(Long.MAX_VALUE - 3599999).toString());
+        assertEquals("292278994-08-17T07:11:55.807Z", new DateTime(Long.MAX_VALUE - 60000).toString());
+        assertEquals("292278994-08-17T07:12:55.000Z", new DateTime(Long.MAX_VALUE - 807).toString());
+        assertEquals("292278994-08-17T07:12:55.806Z", new DateTime(Long.MAX_VALUE - 1).toString());
+        assertEquals("292278994-08-17T07:12:55.807Z", new DateTime(Long.MAX_VALUE).toString());
+    }
+
+    public void testPrintParseMax() {
+        DateTime test1 = new DateTime(Long.MAX_VALUE);
+        assertEquals(test1, DateTime.parse(test1.toString()));
+        DateTime test2 = new DateTime(Long.valueOf(Long.MAX_VALUE));
+        assertEquals(test2, DateTime.parse(test2.toString()));
+        assertEquals(test2, test1);
+    }
+
+    //-----------------------------------------------------------------------
+    public void testDateTime_min() throws Throwable {
+        DateTime dt = new DateTime(-292275054, 1, 1, 0, 0);
+        DateTime test = new DateTime(dt.getMillis());
+        assertEquals(dt, test);
+        assertEquals("-292275054-01-01T00:00:00.000-00:01:15", test.toString());
+    }
+
+    public void testDateTime_min_math() throws Throwable {
+        DateTime test = new DateTime(Long.MIN_VALUE);  // always in UTC
+        assertEquals("-292275055-05-16T16:47:04.192Z", test.toString());
+
+        assertEquals(new DateTime(Long.MIN_VALUE + 808, DateTimeZone.UTC), test.plus(808));
+        assertEquals("-292275055-05-16T16:47:05.000Z", test.plus(808).toString());
+        
+        assertEquals(new DateTime(Long.MIN_VALUE + 808, DateTimeZone.UTC), test.plusMillis(808));
+        assertEquals("-292275055-05-16T16:47:05.000Z", test.plusMillis(808).toString());
+        
+        assertEquals(new DateTime(Long.MIN_VALUE + 1000, DateTimeZone.UTC), test.plusSeconds(1));
+        assertEquals("-292275055-05-16T16:47:05.192Z", test.plusSeconds(1).toString());
+        
+        assertEquals(new DateTime(Long.MIN_VALUE + 60000, DateTimeZone.UTC), test.plusMinutes(1));
+        assertEquals("-292275055-05-16T16:48:04.192Z", test.plusMinutes(1).toString());
+        
+        assertEquals(new DateTime(Long.MIN_VALUE + 80000, DateTimeZone.UTC), test.plusSeconds(80));
+        assertEquals("-292275055-05-16T16:48:24.192Z", test.plusSeconds(80).toString());
+        
+        try {
+            test.minusMillis(1);
+            fail();
+        } catch (ArithmeticException ex) {
+            // expected
+        }
+    }
+
+    public void testDateTime_min_fields() {
+        assertEquals(ACTUAL_MIN_YEAR, ISOChronology.getInstanceUTC().year().getMinimumValue() - 1);
+        // ensure previous year
+        assertEquals("-292275053-01-01T00:00:00.000-00:01:15", new DateTime(-292275053, 1, 1, 0, 0).toString());
+        assertEquals("-292275054-01-01T00:00:00.000-00:01:15", new DateTime(-292275054, 1, 1, 0, 0).toString());
+        // permitted
+        DateTime a = new DateTime(ACTUAL_MIN_YEAR, 12, 31, 23, 59, 59, 999);
+        assertEquals("-292275055-12-31T23:59:59.999-00:01:15", a.toString());
+        // permitted
+        DateTime b = new DateTime(ACTUAL_MIN_YEAR, 5, 17, 0, 0, 0, 0);
+        assertEquals("-292275055-05-17T00:00:00.000-00:01:15", b.toString());
+        // permitted
+        DateTime c = new DateTime(ACTUAL_MIN_YEAR, 5, 16, 17, 0, 0, 0);
+        assertEquals("-292275055-05-16T17:00:00.000-00:01:15", c.toString());
+        // permitted
+        DateTime d = new DateTime(ACTUAL_MIN_YEAR, 5, 16, 16, 47, 4, 193);
+        assertEquals("-292275055-05-16T16:47:04.193-00:01:15", d.toString());
+        // clamp to max
+        DateTime e = new DateTime(ACTUAL_MIN_YEAR, 5, 16, 16, 47, 4, 192);
+        assertEquals(new DateTime(Long.MIN_VALUE), e);
+        assertEquals("-292275055-05-16T16:47:04.192Z", e.toString());
+        // clamp to max
+        DateTime f = new DateTime(ACTUAL_MIN_YEAR, 5, 16, 16, 47, 4, 191);
+        assertEquals(new DateTime(Long.MIN_VALUE), f);
+        assertEquals("-292275055-05-16T16:47:04.192Z", f.toString());
+        // clamp to max
+        DateTime g = new DateTime(ACTUAL_MIN_YEAR, 1, 1, 0, 0, 0, 0);
+        assertEquals(new DateTime(Long.MIN_VALUE), g);
+        assertEquals("-292275055-05-16T16:47:04.192Z", g.toString());
+    }
+
+    public void testDateTime_min_long() {
+        assertEquals("-292275055-05-16T16:47:04.192-00:01:15", new DateTime(Long.MIN_VALUE + 75000).toString());
+        assertEquals("-292275055-05-16T16:48:19.191Z", new DateTime(Long.MIN_VALUE + 74999).toString());
+        assertEquals("-292275055-05-16T16:48:04.192Z", new DateTime(Long.MIN_VALUE + 60000).toString());
+        assertEquals("-292275055-05-16T16:47:05.192Z", new DateTime(Long.MIN_VALUE + 1000).toString());
+        assertEquals("-292275055-05-16T16:47:04.193Z", new DateTime(Long.MIN_VALUE + 1).toString());
+        assertEquals("-292275055-05-16T16:47:04.192Z", new DateTime(Long.MIN_VALUE).toString());
+    }
+
+    public void testPrintParseMin() {
+        DateTime test1 = new DateTime(Long.MIN_VALUE);
+        assertEquals(test1, DateTime.parse(test1.toString()));
+        DateTime test2 = new DateTime(Long.valueOf(Long.MIN_VALUE));
+        assertEquals(test2, DateTime.parse(test2.toString()));
+        assertEquals(test2, test1);
+    }
+
+}
