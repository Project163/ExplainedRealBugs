{"url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36","repository_url":"https://api.github.com/repos/JodaOrg/joda-time","labels_url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36/labels{/name}","comments_url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36/comments","events_url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36/events","html_url":"https://github.com/JodaOrg/joda-time/issues/36","id":16151139,"node_id":"MDU6SXNzdWUxNjE1MTEzOQ==","number":36,"title":"Problems with equals() methods in Chronology classes","user":{"login":"mstevens83","id":2787305,"node_id":"MDQ6VXNlcjI3ODczMDU=","avatar_url":"https://avatars.githubusercontent.com/u/2787305?v=4","gravatar_id":"","url":"https://api.github.com/users/mstevens83","html_url":"https://github.com/mstevens83","followers_url":"https://api.github.com/users/mstevens83/followers","following_url":"https://api.github.com/users/mstevens83/following{/other_user}","gists_url":"https://api.github.com/users/mstevens83/gists{/gist_id}","starred_url":"https://api.github.com/users/mstevens83/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mstevens83/subscriptions","organizations_url":"https://api.github.com/users/mstevens83/orgs","repos_url":"https://api.github.com/users/mstevens83/repos","events_url":"https://api.github.com/users/mstevens83/events{/privacy}","received_events_url":"https://api.github.com/users/mstevens83/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":42317739,"node_id":"MDU6TGFiZWw0MjMxNzczOQ==","url":"https://api.github.com/repos/JodaOrg/joda-time/labels/RFE","name":"RFE","color":"006b75","default":false,"description":null},{"id":42318930,"node_id":"MDU6TGFiZWw0MjMxODkzMA==","url":"https://api.github.com/repos/JodaOrg/joda-time/labels/Fixed","name":"Fixed","color":"009800","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2013-06-28T16:59:26Z","updated_at":"2013-08-01T11:33:53Z","closed_at":"2013-07-20T12:43:36Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Hello I've come across a number of problems related to the equals() methods (or lack thereof) in Chronology classes.\n\nI was comparing 2 DateTime instances which have the same date, time and timezone but still DateTime.equals() returns false.\nSo I started to investigate...\n\nDateTime.equals is in fact inherited from AbstractInstant. Looking at the docs and code of AbstractInstant.equals() I found out it checks both the milliseconds and the chronology. The millisecond comparison works fine (and returns true for my test data), however the comparison of chronologies does not work as it should.\nEven though the Chronology objects of my DateTime objects were both \"ISOChronology[Africa/Brazzaville]\" (result of toString()) they were not considered equal.\n\nSo I dug deeper. In the code of AbstractInstant I saw that the Chronology comparison is performed using FieldUtils.equals(object, object), which in turns calls the object1.equals(object2) -- i.e. the method ISOChronology.equals() is called, which reads as follows:\n\n``` java\npublic boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n```\n- The direct super class of ISOChronology is AssembledChronology, but that one does not contain an equals() method;\n- The super class of AssembledChronology is BaseChronology, but that one does not contain an equals() method either;\n- The super class of BaseChronology is Chronology, but, you guessed it, that one also lacks an equals() method\n- The super class of Chronology is Object, and there the implementation of equals() defaults to references comparison (i.e.: this == obj)\n\nHence, when super.equals(obj) is called in ISOChronology none of the chronology fields are compared, and the result is solely based on object comparison. This is clearly a bug I would argue.\n\n**Note:** You might wonder how I ever got to have 2 instances of ISOChronology for the same timezone. The reason is that I use an object database (DB4O) to store DateTime instances, and sometimes I need to handle finding duplicates cross multiple dumps of the database (containing largely the same data, but stored in _different_ objects).\n","closed_by":{"login":"jodastephen","id":213212,"node_id":"MDQ6VXNlcjIxMzIxMg==","avatar_url":"https://avatars.githubusercontent.com/u/213212?v=4","gravatar_id":"","url":"https://api.github.com/users/jodastephen","html_url":"https://github.com/jodastephen","followers_url":"https://api.github.com/users/jodastephen/followers","following_url":"https://api.github.com/users/jodastephen/following{/other_user}","gists_url":"https://api.github.com/users/jodastephen/gists{/gist_id}","starred_url":"https://api.github.com/users/jodastephen/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jodastephen/subscriptions","organizations_url":"https://api.github.com/users/jodastephen/orgs","repos_url":"https://api.github.com/users/jodastephen/repos","events_url":"https://api.github.com/users/jodastephen/events{/privacy}","received_events_url":"https://api.github.com/users/jodastephen/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/JodaOrg/joda-time/issues/36/timeline","performed_via_github_app":null,"state_reason":"completed"}