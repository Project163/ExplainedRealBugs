diff --git a/src/main/java/com/helger/jcodemodel/JAnnotationArrayMember.java b/src/main/java/com/helger/jcodemodel/JAnnotationArrayMember.java
index bf8f8a12..9fe82ebd 100644
--- a/src/main/java/com/helger/jcodemodel/JAnnotationArrayMember.java
+++ b/src/main/java/com/helger/jcodemodel/JAnnotationArrayMember.java
@@ -42,7 +42,6 @@ package com.helger.jcodemodel;
 
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -417,7 +416,7 @@ public class JAnnotationArrayMember extends AbstractJAnnotationValueOwned implem
    */
   @SuppressWarnings ({ "unchecked", "rawtypes" })
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotations ()
   {
     // FIXME this invocation is invalid if the caller isn't adding annotations
     // into an array so this potentially type-unsafe conversion would be
@@ -426,9 +425,15 @@ public class JAnnotationArrayMember extends AbstractJAnnotationValueOwned implem
   }
 
   @Nonnull
-  public Collection <AbstractJAnnotationValue> getAllAnnotations ()
+  public List <AbstractJAnnotationValue> annotationsMutable ()
   {
-    return Collections.unmodifiableList (m_aValues);
+    return m_aValues;
+  }
+
+  @Nonnull
+  public List <AbstractJAnnotationValue> getAllAnnotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   @Nonnegative
diff --git a/src/main/java/com/helger/jcodemodel/JAnnotationUse.java b/src/main/java/com/helger/jcodemodel/JAnnotationUse.java
index 5d5ca5e8..c21d6cf9 100644
--- a/src/main/java/com/helger/jcodemodel/JAnnotationUse.java
+++ b/src/main/java/com/helger/jcodemodel/JAnnotationUse.java
@@ -44,7 +44,6 @@ import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -76,7 +75,7 @@ public class JAnnotationUse extends AbstractJAnnotationValueOwned
   /**
    * Map of member aValues.
    */
-  private Map <String, AbstractJAnnotationValue> m_aMemberValues;
+  private final Map <String, AbstractJAnnotationValue> m_aMemberValues = new LinkedHashMap <> ();
 
   public JAnnotationUse (@Nonnull final AbstractJClass aAnnotationClass)
   {
@@ -95,21 +94,27 @@ public class JAnnotationUse extends AbstractJAnnotationValueOwned
     return m_aAnnotationClass.owner ();
   }
 
+  @Nonnull
+  public Map <String, AbstractJAnnotationValue> annotationMembersMutable ()
+  {
+    return m_aMemberValues;
+  }
+
   @Nonnull
   public Map <String, AbstractJAnnotationValue> getAnnotationMembers ()
   {
-    return m_aMemberValues == null ? new HashMap <> () : Collections.unmodifiableMap (m_aMemberValues);
+    return Collections.unmodifiableMap (annotationMembersMutable ());
   }
 
   public boolean hasAnnotationMembers ()
   {
-    return m_aMemberValues != null && !m_aMemberValues.isEmpty ();
+    return !m_aMemberValues.isEmpty ();
   }
 
   @Nullable
   public AbstractJAnnotationValue getParam (@Nullable final String sName)
   {
-    return m_aMemberValues == null ? null : m_aMemberValues.get (sName);
+    return m_aMemberValues.get (sName);
   }
 
   @SuppressWarnings ("unchecked")
@@ -192,16 +197,13 @@ public class JAnnotationUse extends AbstractJAnnotationValueOwned
   }
 
   @Nonnull
-  private JAnnotationUse _addValue (@Nonnull final String sName,
-                                    @Nonnull final AbstractJAnnotationValue aAnnotationValue)
+  private JAnnotationUse _addValue (@Nonnull final String sName, @Nonnull final AbstractJAnnotationValue aAnnotationValue)
   {
     JCValueEnforcer.notEmpty (sName, "Name");
     JCValueEnforcer.notNull (aAnnotationValue, "AnnotationValue");
 
     // Use ordered map to keep the code generation the same on any JVM.
     // Lazily created.
-    if (m_aMemberValues == null)
-      m_aMemberValues = new LinkedHashMap <> ();
     m_aMemberValues.put (sName, aAnnotationValue);
 
     return this;
@@ -769,8 +771,7 @@ public class JAnnotationUse extends AbstractJAnnotationValueOwned
    * @return <code>this</code> for chaining
    */
   @Nonnull
-  public JAnnotationUse annotationParam (@Nonnull final String sName,
-                                         @Nonnull final Class <? extends Annotation> aValue)
+  public JAnnotationUse annotationParam (@Nonnull final String sName, @Nonnull final Class <? extends Annotation> aValue)
   {
     return annotationParam (sName, owner ().ref (aValue));
   }
@@ -808,7 +809,7 @@ public class JAnnotationUse extends AbstractJAnnotationValueOwned
   public void generate (final IJFormatter f)
   {
     f.print ('@').generable (m_aAnnotationClass);
-    if (m_aMemberValues != null && !m_aMemberValues.isEmpty ())
+    if (!m_aMemberValues.isEmpty ())
     {
       f.print ('(');
       if (isDefaultOnly ())
diff --git a/src/main/java/com/helger/jcodemodel/JArray.java b/src/main/java/com/helger/jcodemodel/JArray.java
index 2b977456..4dfcc74d 100644
--- a/src/main/java/com/helger/jcodemodel/JArray.java
+++ b/src/main/java/com/helger/jcodemodel/JArray.java
@@ -106,11 +106,17 @@ public class JArray implements IJExpression
   }
 
   @Nonnull
-  public List <IJExpression> exprs ()
+  public List <IJExpression> exprsMutable ()
   {
     if (m_aExprs == null)
       m_aExprs = new ArrayList <> ();
-    return Collections.unmodifiableList (m_aExprs);
+    return m_aExprs;
+  }
+
+  @Nonnull
+  public List <IJExpression> exprs ()
+  {
+    return Collections.unmodifiableList (exprsMutable ());
   }
 
   public boolean hasExprs ()
@@ -158,9 +164,7 @@ public class JArray implements IJExpression
     if (o == null || getClass () != o.getClass ())
       return false;
     final JArray rhs = (JArray) o;
-    return isEqual (m_aType.fullName (), rhs.m_aType.fullName ()) &&
-           isEqual (m_aSize, rhs.m_aSize) &&
-           isEqual (m_aExprs, rhs.m_aExprs);
+    return isEqual (m_aType.fullName (), rhs.m_aType.fullName ()) && isEqual (m_aSize, rhs.m_aSize) && isEqual (m_aExprs, rhs.m_aExprs);
   }
 
   @Override
diff --git a/src/main/java/com/helger/jcodemodel/JBlock.java b/src/main/java/com/helger/jcodemodel/JBlock.java
index 011026c9..81173ef7 100644
--- a/src/main/java/com/helger/jcodemodel/JBlock.java
+++ b/src/main/java/com/helger/jcodemodel/JBlock.java
@@ -134,6 +134,16 @@ public class JBlock implements IJGenerable, IJStatement
     return this;
   }
 
+  /**
+   * @return The contained list of {@link IJStatement}s and
+   *         {@link IJDeclaration} in this block.
+   */
+  @Nonnull
+  public List <IJObject> contentsMutable ()
+  {
+    return m_aContentList;
+  }
+
   /**
    * @return a read-only view of {@link IJStatement}s and {@link IJDeclaration}
    *         in this block.
@@ -141,7 +151,7 @@ public class JBlock implements IJGenerable, IJStatement
   @Nonnull
   public List <IJObject> getContents ()
   {
-    return Collections.unmodifiableList (m_aContentList);
+    return Collections.unmodifiableList (contentsMutable ());
   }
 
   @Nonnull
@@ -212,8 +222,7 @@ public class JBlock implements IJGenerable, IJStatement
   @Nonnegative
   public int pos (@Nonnegative final int nNewPos)
   {
-    JCValueEnforcer.isTrue (nNewPos >= 0 && nNewPos <= m_aContentList.size (),
-                            () -> "Illegal position provided: " + nNewPos);
+    JCValueEnforcer.isTrue (nNewPos >= 0 && nNewPos <= m_aContentList.size (), () -> "Illegal position provided: " + nNewPos);
 
     final int nOldPos = m_nPos;
     m_nPos = nNewPos;
@@ -305,10 +314,7 @@ public class JBlock implements IJGenerable, IJStatement
    * @return Newly generated {@link JVar}
    */
   @Nonnull
-  public JVar decl (final int nMods,
-                    @Nonnull final AbstractJType aType,
-                    @Nonnull final String sName,
-                    @Nullable final IJExpression aInit)
+  public JVar decl (final int nMods, @Nonnull final AbstractJType aType, @Nonnull final String sName, @Nullable final IJExpression aInit)
   {
     final JVar v = new JVar (JMods.forVar (nMods), aType, sName, aInit);
     internalInsert (v);
@@ -605,9 +611,7 @@ public class JBlock implements IJGenerable, IJStatement
    * @return Newly generated {@link JConditional} statement
    */
   @Nonnull
-  public JConditional _if (@Nonnull final IJExpression aTestExpr,
-                           @Nonnull final IJStatement aThen,
-                           @Nonnull final IJStatement aElse)
+  public JConditional _if (@Nonnull final IJExpression aTestExpr, @Nonnull final IJStatement aThen, @Nonnull final IJStatement aElse)
   {
     final JConditional aCond = new JConditional (aTestExpr);
     aCond._then ().add (aThen);
@@ -850,9 +854,7 @@ public class JBlock implements IJGenerable, IJStatement
    * @return Newly generated enhanced For statement per j2se 1.5 specification
    */
   @Nonnull
-  public JForEach forEach (@Nonnull final AbstractJType aVarType,
-                           @Nonnull final String sName,
-                           @Nonnull final IJExpression aCollection)
+  public JForEach forEach (@Nonnull final AbstractJType aVarType, @Nonnull final String sName, @Nonnull final IJExpression aCollection)
   {
     return forEach (0, aVarType, sName, aCollection);
   }
diff --git a/src/main/java/com/helger/jcodemodel/JDefinedClass.java b/src/main/java/com/helger/jcodemodel/JDefinedClass.java
index 29e9bbf2..031d21be 100644
--- a/src/main/java/com/helger/jcodemodel/JDefinedClass.java
+++ b/src/main/java/com/helger/jcodemodel/JDefinedClass.java
@@ -69,10 +69,7 @@ import com.helger.jcodemodel.writer.JFormatter;
  * {@link #method(int, AbstractJType, String)} and
  * {@link #field(int, AbstractJType, String)}.
  */
-public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> implements
-                           IJGenerifiable,
-                           IJAnnotatable,
-                           IJDocCommentable
+public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> implements IJGenerifiable, IJAnnotatable, IJDocCommentable
 {
   /**
    * The optional header that is emitted prior to the package (Issue #47)
@@ -413,6 +410,17 @@ public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> imple
     return field (nMods, owner ()._ref (aType), sName, aInit);
   }
 
+  /**
+   * Returns all the fields declared in this class.
+   *
+   * @return always non-null.
+   */
+  @Nonnull
+  public Map <String, JFieldVar> fieldsMutable ()
+  {
+    return m_aFields;
+  }
+
   /**
    * Returns all the fields declared in this class. The returned {@link Map} is
    * a read-only live view.
@@ -422,7 +430,7 @@ public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> imple
   @Nonnull
   public Map <String, JFieldVar> fields ()
   {
-    return Collections.unmodifiableMap (m_aFields);
+    return Collections.unmodifiableMap (fieldsMutable ());
   }
 
   /**
@@ -450,9 +458,7 @@ public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> imple
     return sName != null && m_aFields.containsKey (sName);
   }
 
-  void internalRenameField (@Nonnull final String sOldName,
-                            @Nonnull final String sNewName,
-                            @Nonnull final JFieldVar aField)
+  void internalRenameField (@Nonnull final String sOldName, @Nonnull final String sNewName, @Nonnull final JFieldVar aField)
   {
     if (m_aFields.remove (sOldName) == null)
       throw new IllegalArgumentException ("Failed to remove field with name '" +
@@ -774,8 +780,7 @@ public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> imple
   }
 
   @Override
-  protected AbstractJClass substituteParams (final JTypeVar [] aVariables,
-                                             final List <? extends AbstractJClass> aBindings)
+  protected AbstractJClass substituteParams (final JTypeVar [] aVariables, final List <? extends AbstractJClass> aBindings)
   {
     return this;
   }
@@ -797,28 +802,35 @@ public class JDefinedClass extends AbstractJClassContainer <JDefinedClass> imple
   }
 
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotationsMutable ()
   {
     if (m_aAnnotations == null)
       m_aAnnotations = new ArrayList <> ();
-    return Collections.unmodifiableCollection (m_aAnnotations);
+    return m_aAnnotations;
+  }
+
+  @Nonnull
+  public Collection <JAnnotationUse> annotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   @Nullable
   public JAnnotationUse getAnnotation (final Class <?> aAnnotationClass)
   {
-    for (final JAnnotationUse jannotation : m_aAnnotations)
-    {
-      final AbstractJClass jannotationClass = jannotation.getAnnotationClass ();
-      if (!jannotationClass.isError ())
+    if (m_aAnnotations != null)
+      for (final JAnnotationUse jannotation : m_aAnnotations)
       {
-        final String sQualifiedName = jannotationClass.fullName ();
-        if (sQualifiedName != null && sQualifiedName.equals (aAnnotationClass.getName ()))
+        final AbstractJClass jannotationClass = jannotation.getAnnotationClass ();
+        if (!jannotationClass.isError ())
         {
-          return jannotation;
+          final String sQualifiedName = jannotationClass.fullName ();
+          if (sQualifiedName != null && sQualifiedName.equals (aAnnotationClass.getName ()))
+          {
+            return jannotation;
+          }
         }
       }
-    }
     return null;
   }
 
diff --git a/src/main/java/com/helger/jcodemodel/JEnumConstant.java b/src/main/java/com/helger/jcodemodel/JEnumConstant.java
index 5a2ea4c0..42cd78b9 100644
--- a/src/main/java/com/helger/jcodemodel/JEnumConstant.java
+++ b/src/main/java/com/helger/jcodemodel/JEnumConstant.java
@@ -194,15 +194,18 @@ public class JEnumConstant implements IJExpression, IJDeclaration, IJAnnotatable
     return annotate (m_aType.owner ().ref (aClazz));
   }
 
-  /**
-   * {@link IJAnnotatable#annotations()}
-   */
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotationsMutable ()
   {
     if (m_aAnnotations == null)
       m_aAnnotations = new ArrayList <> ();
-    return Collections.unmodifiableList (m_aAnnotations);
+    return m_aAnnotations;
+  }
+
+  @Nonnull
+  public Collection <JAnnotationUse> annotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   public void declare (@Nonnull final IJFormatter f)
diff --git a/src/main/java/com/helger/jcodemodel/JForLoop.java b/src/main/java/com/helger/jcodemodel/JForLoop.java
index b781cb01..741ff4f8 100644
--- a/src/main/java/com/helger/jcodemodel/JForLoop.java
+++ b/src/main/java/com/helger/jcodemodel/JForLoop.java
@@ -54,7 +54,7 @@ import com.helger.jcodemodel.util.JCValueEnforcer;
  */
 public class JForLoop implements IJStatement
 {
-  private final List <Object> m_aInitExprs = new ArrayList <> ();
+  private final List <IJObject> m_aInitExprs = new ArrayList <> ();
   private IJExpression m_aTestExpr;
   private final List <IJExpression> m_aUpdateExprs = new ArrayList <> ();
   private JBlock m_aBody;
@@ -74,9 +74,7 @@ public class JForLoop implements IJStatement
   }
 
   @Nonnull
-  public JVar init (@Nonnull final AbstractJType aType,
-                    @Nonnull final String sVarName,
-                    @Nullable final IJExpression aInitExpr)
+  public JVar init (@Nonnull final AbstractJType aType, @Nonnull final String sVarName, @Nullable final IJExpression aInitExpr)
   {
     return init (JMod.NONE, aType, sVarName, aInitExpr);
   }
@@ -91,9 +89,18 @@ public class JForLoop implements IJStatement
    * @return List of {@link IJExpression} or {@link JVar}
    */
   @Nonnull
-  public List <Object> inits ()
+  public List <IJObject> initsMutable ()
   {
-    return Collections.unmodifiableList (m_aInitExprs);
+    return m_aInitExprs;
+  }
+
+  /**
+   * @return List of {@link IJExpression} or {@link JVar}
+   */
+  @Nonnull
+  public List <IJObject> inits ()
+  {
+    return Collections.unmodifiableList (initsMutable ());
   }
 
   public void test (@Nullable final IJExpression aTestExpr)
@@ -113,10 +120,16 @@ public class JForLoop implements IJStatement
     m_aUpdateExprs.add (aUpdate);
   }
 
+  @Nonnull
+  public List <IJExpression> updatesMutable ()
+  {
+    return m_aUpdateExprs;
+  }
+
   @Nonnull
   public List <IJExpression> updates ()
   {
-    return Collections.unmodifiableList (m_aUpdateExprs);
+    return Collections.unmodifiableList (updatesMutable ());
   }
 
   @Nonnull
diff --git a/src/main/java/com/helger/jcodemodel/JLambda.java b/src/main/java/com/helger/jcodemodel/JLambda.java
index d1419a21..661a47bb 100644
--- a/src/main/java/com/helger/jcodemodel/JLambda.java
+++ b/src/main/java/com/helger/jcodemodel/JLambda.java
@@ -99,6 +99,16 @@ public class JLambda implements IJExpression
     return aParam;
   }
 
+  /**
+   * @return An modifiable list with all parameters present. Never
+   *         <code>null</code>.
+   */
+  @Nonnull
+  public List <JLambdaParam> paramsMutable ()
+  {
+    return m_aParams;
+  }
+
   /**
    * @return An unmodifiable list with all parameters present. Never
    *         <code>null</code>.
@@ -106,7 +116,7 @@ public class JLambda implements IJExpression
   @Nonnull
   public List <JLambdaParam> params ()
   {
-    return Collections.unmodifiableList (m_aParams);
+    return Collections.unmodifiableList (paramsMutable ());
   }
 
   @Nonnegative
@@ -157,8 +167,7 @@ public class JLambda implements IJExpression
     f.print (" -> ");
 
     // Print body
-    final boolean bBraces = m_aBodyStatement.size () != 1 ||
-                            !(m_aBodyStatement.getContents ().get (0) instanceof IJExpression);
+    final boolean bBraces = m_aBodyStatement.size () != 1 || !(m_aBodyStatement.getContents ().get (0) instanceof IJExpression);
     m_aBodyStatement.bracesRequired (bBraces);
     f.statement (m_aBodyStatement);
   }
diff --git a/src/main/java/com/helger/jcodemodel/JMethod.java b/src/main/java/com/helger/jcodemodel/JMethod.java
index f1498a50..2f3b3071 100644
--- a/src/main/java/com/helger/jcodemodel/JMethod.java
+++ b/src/main/java/com/helger/jcodemodel/JMethod.java
@@ -84,7 +84,7 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
    * Set of exceptions that this method may throw. A set instance lazily
    * created.
    */
-  private Set <AbstractJClass> m_aThrows;
+  private final Set <AbstractJClass> m_aThrows = new TreeSet <> (ClassNameComparator.getInstance ());
 
   /**
    * JBlock of statements that makes up the body this method
@@ -161,12 +161,16 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
     return m_aReturnType == null;
   }
 
+  @Nonnull
+  public Set <AbstractJClass> throwsMutable ()
+  {
+    return m_aThrows;
+  }
+
   @Nonnull
   public Collection <AbstractJClass> getThrows ()
   {
-    if (m_aThrows == null)
-      return Collections.emptySet ();
-    return Collections.unmodifiableSet (m_aThrows);
+    return Collections.unmodifiableSet (throwsMutable ());
   }
 
   /**
@@ -179,8 +183,6 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
   @Nonnull
   public JMethod _throws (@Nonnull final AbstractJClass aException)
   {
-    if (m_aThrows == null)
-      m_aThrows = new TreeSet <> (ClassNameComparator.getInstance ());
     m_aThrows.add (aException);
     return this;
   }
@@ -191,6 +193,17 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
     return _throws (m_aOwningClass.owner ().ref (aException));
   }
 
+  /**
+   * Returns the list of variable of this method.
+   *
+   * @return List of parameters of this method. This list is modifiable.
+   */
+  @Nonnull
+  public List <JVar> paramsMutable ()
+  {
+    return m_aParams;
+  }
+
   /**
    * Returns the list of variable of this method.
    *
@@ -199,7 +212,7 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
   @Nonnull
   public List <JVar> params ()
   {
-    return Collections.unmodifiableList (m_aParams);
+    return Collections.unmodifiableList (paramsMutable ());
   }
 
   @Nonnull
@@ -391,11 +404,17 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
   }
 
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotationsMutable ()
   {
     if (m_aAnnotations == null)
       return Collections.emptyList ();
-    return Collections.unmodifiableList (m_aAnnotations);
+    return m_aAnnotations;
+  }
+
+  @Nonnull
+  public Collection <JAnnotationUse> annotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   public String name ()
@@ -573,14 +592,11 @@ public class JMethod extends AbstractJGenerifiableImpl implements IJAnnotatable,
       }
       for (final JAnnotationUse annotation : m_aVarParam.annotations ())
         f.generable (annotation).print (' ');
-      f.generable (m_aVarParam.mods ())
-       .generable (m_aVarParam.type ().elementType ())
-       .print ("... ")
-       .id (m_aVarParam.name ());
+      f.generable (m_aVarParam.mods ()).generable (m_aVarParam.type ().elementType ()).print ("... ").id (m_aVarParam.name ());
     }
 
     f.outdent ().print (')');
-    if (m_aThrows != null && !m_aThrows.isEmpty ())
+    if (!m_aThrows.isEmpty ())
     {
       f.newline ().indent ().print ("throws").generable (m_aThrows).newline ().outdent ();
     }
diff --git a/src/main/java/com/helger/jcodemodel/JPackage.java b/src/main/java/com/helger/jcodemodel/JPackage.java
index a2eb9ce1..ac51047c 100644
--- a/src/main/java/com/helger/jcodemodel/JPackage.java
+++ b/src/main/java/com/helger/jcodemodel/JPackage.java
@@ -65,12 +65,7 @@ import com.helger.jcodemodel.util.JCValueEnforcer;
 /**
  * A Java package.
  */
-public class JPackage implements
-                      IJDeclaration,
-                      IJGenerable,
-                      IJClassContainer <JDefinedClass>,
-                      IJAnnotatable,
-                      IJDocCommentable
+public class JPackage implements IJDeclaration, IJGenerable, IJClassContainer <JDefinedClass>, IJAnnotatable, IJDocCommentable
 {
   public static final char SEPARATOR = '.';
   public static final Pattern VALID_PACKAGE_NAME_ANYCASE = Pattern.compile ("[A-Za-z_][A-Za-z0-9_]*");
@@ -417,8 +412,7 @@ public class JPackage implements
   @Nonnull
   public AbstractJClass ref (@Nonnull final String sClassLocalName) throws ClassNotFoundException
   {
-    JCValueEnforcer.isTrue (sClassLocalName.indexOf (SEPARATOR) < 0,
-                            () -> "JClass name contains '.': " + sClassLocalName);
+    JCValueEnforcer.isTrue (sClassLocalName.indexOf (SEPARATOR) < 0, () -> "JClass name contains '.': " + sClassLocalName);
 
     final String sFQCN = isUnnamed () ? sClassLocalName : m_sName + SEPARATOR + sClassLocalName;
     return m_aOwner.ref (Class.forName (sFQCN));
@@ -514,11 +508,17 @@ public class JPackage implements
   }
 
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotationsMutable ()
   {
     if (m_aAnnotations == null)
       m_aAnnotations = new ArrayList <> ();
-    return Collections.unmodifiableList (m_aAnnotations);
+    return m_aAnnotations;
+  }
+
+  @Nonnull
+  public Collection <JAnnotationUse> annotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   /**
diff --git a/src/main/java/com/helger/jcodemodel/JTypeVar.java b/src/main/java/com/helger/jcodemodel/JTypeVar.java
index 34b9a920..0ffacd5c 100644
--- a/src/main/java/com/helger/jcodemodel/JTypeVar.java
+++ b/src/main/java/com/helger/jcodemodel/JTypeVar.java
@@ -110,6 +110,17 @@ public class JTypeVar extends AbstractJClass implements IJDeclaration
     return this;
   }
 
+  /**
+   * Return all bounds of this type-parameter.
+   *
+   * @return this
+   */
+  @Nonnull
+  public List <AbstractJClass> boundsMutable ()
+  {
+    return m_aBounds;
+  }
+
   /**
    * Return all bounds of this type-parameter.
    *
@@ -118,7 +129,7 @@ public class JTypeVar extends AbstractJClass implements IJDeclaration
   @Nonnull
   public Collection <? extends AbstractJClass> bounds ()
   {
-    return Collections.unmodifiableList (new ArrayList <> (m_aBounds));
+    return Collections.unmodifiableList (boundsMutable ());
   }
 
   /**
diff --git a/src/main/java/com/helger/jcodemodel/JVar.java b/src/main/java/com/helger/jcodemodel/JVar.java
index 4ad1f679..6ced7bdc 100644
--- a/src/main/java/com/helger/jcodemodel/JVar.java
+++ b/src/main/java/com/helger/jcodemodel/JVar.java
@@ -45,7 +45,6 @@ import static com.helger.jcodemodel.util.JCHashCodeGenerator.getHashCode;
 
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -222,11 +221,17 @@ public class JVar implements IJAssignmentTarget, IJDeclaration, IJAnnotatable
   }
 
   @Nonnull
-  public Collection <JAnnotationUse> annotations ()
+  public List <JAnnotationUse> annotationsMutable ()
   {
     if (m_aAnnotations == null)
       m_aAnnotations = new ArrayList <> ();
-    return Collections.unmodifiableList (m_aAnnotations);
+    return m_aAnnotations;
+  }
+
+  @Nonnull
+  public List <JAnnotationUse> annotations ()
+  {
+    return Collections.unmodifiableList (annotationsMutable ());
   }
 
   protected boolean isAnnotated ()
