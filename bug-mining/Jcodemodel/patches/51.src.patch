diff --git a/src/main/java/com/helger/jcodemodel/JPackage.java b/src/main/java/com/helger/jcodemodel/JPackage.java
index 838770f5..32340a0f 100644
--- a/src/main/java/com/helger/jcodemodel/JPackage.java
+++ b/src/main/java/com/helger/jcodemodel/JPackage.java
@@ -72,6 +72,7 @@ public class JPackage implements
                       IJAnnotatable,
                       IJDocCommentable
 {
+  public static final char SEPARATOR = '.';
   public static final Pattern VALID_PACKAGE_NAME_ANYCASE = Pattern.compile ("[A-Za-z_][A-Za-z0-9_]*");
   public static final Pattern VALID_PACKAGE_NAME_LOWERCASE = Pattern.compile ("[a-z_][a-z0-9_]*");
   private static final AtomicBoolean FORCE_PACKAGE_NAME_LOWERCASE = new AtomicBoolean (false);
@@ -188,7 +189,7 @@ public class JPackage implements
     // An empty package name is okay
     if (sName.length () > 0)
     {
-      final String [] aParts = JCStringHelper.getExplodedArray ('.', sName);
+      final String [] aParts = JCStringHelper.getExplodedArray (SEPARATOR, sName);
       for (final String sPart : aParts)
         if (isForbiddenPackageNamePart (sPart))
           throw new IllegalArgumentException ("Part '" + sPart + "' of the package name '" + sName + "' is invalid");
@@ -218,7 +219,7 @@ public class JPackage implements
     if (isUnnamed ())
       return null;
 
-    final int idx = m_sName.lastIndexOf ('.');
+    final int idx = m_sName.lastIndexOf (SEPARATOR);
     if (idx < 0)
       return m_aOwner.rootPackage ();
     return m_aOwner._package (m_sName.substring (0, idx));
@@ -261,13 +262,13 @@ public class JPackage implements
 
     // Okay, the class name is unique inside this package
     // Check if a resource with the same name already exists
-    JResourceDir aRD = m_aOwner.resourceDir (m_sName.replace ('.', '/'));
+    JResourceDir aRD = m_aOwner.resourceDir (m_sName.replace (SEPARATOR, JResourceDir.SEPARATOR));
     if (aRD.hasResourceFile (sClassName + ".java"))
       throw new JResourceAlreadyExistsException (aRD.fullChildName (sClassName + ".java"));
 
     if (m_aUpperCaseClassMap != null)
     {
-      aRD = m_aOwner.resourceDir (m_sName.toUpperCase (Locale.ROOT).replace ('.', '/'));
+      aRD = m_aOwner.resourceDir (m_sName.toUpperCase (Locale.ROOT).replace (SEPARATOR, JResourceDir.SEPARATOR));
       if (aRD.hasResourceFile (sUpperClassName + ".java"))
         throw new JResourceAlreadyExistsException (aRD.fullChildName (sUpperClassName + ".java"));
     }
@@ -427,13 +428,14 @@ public class JPackage implements
   @Nonnull
   public AbstractJClass ref (@Nonnull final String sClassLocalName) throws ClassNotFoundException
   {
-    JCValueEnforcer.isTrue (sClassLocalName.indexOf ('.') < 0, () -> "JClass name contains '.': " + sClassLocalName);
+    JCValueEnforcer.isTrue (sClassLocalName.indexOf (SEPARATOR) < 0,
+                            () -> "JClass name contains '.': " + sClassLocalName);
 
     String sFQCN;
     if (isUnnamed ())
       sFQCN = "";
     else
-      sFQCN = m_sName + '.';
+      sFQCN = m_sName + SEPARATOR;
     sFQCN += sClassLocalName;
 
     return m_aOwner.ref (Class.forName (sFQCN));
@@ -451,7 +453,7 @@ public class JPackage implements
   {
     if (isUnnamed ())
       return owner ()._package (sSubPackageName);
-    return owner ()._package (m_sName + '.' + sSubPackageName);
+    return owner ()._package (m_sName + SEPARATOR + sSubPackageName);
   }
 
   /**
@@ -545,7 +547,7 @@ public class JPackage implements
   {
     if (isUnnamed ())
       return aDir;
-    return new File (aDir, m_sName.replace ('.', File.separatorChar));
+    return new File (aDir, m_sName.replace (SEPARATOR, File.separatorChar));
   }
 
   public void declare (@Nonnull final IJFormatter f)
diff --git a/src/main/java/com/helger/jcodemodel/JResourceDir.java b/src/main/java/com/helger/jcodemodel/JResourceDir.java
index df0cc7a7..0eef01f8 100644
--- a/src/main/java/com/helger/jcodemodel/JResourceDir.java
+++ b/src/main/java/com/helger/jcodemodel/JResourceDir.java
@@ -65,6 +65,8 @@ import com.helger.jcodemodel.util.JCValueEnforcer;
 public class JResourceDir implements IJOwned
 {
   public static final char SEPARATOR = JCFilenameHelper.UNIX_SEPARATOR;
+  public static final String SEPARATOR_STR = Character.toString (SEPARATOR);
+  private static final String SEPARATOR_TWICE = SEPARATOR_STR + SEPARATOR_STR;
 
   /**
    * Check if the resource directory name part is valid or not.
@@ -128,10 +130,12 @@ public class JResourceDir implements IJOwned
     {
       // Convert "\" to "/"
       String sCleanPath = JCFilenameHelper.getPathUsingUnixSeparator (sName);
+      // Replace all double separators with a single one
+      sCleanPath = JCStringHelper.replaceAllRepeatedly (sCleanPath, SEPARATOR_TWICE, SEPARATOR_STR);
       // Ensure last part is not a "/"
       sCleanPath = JCFilenameHelper.ensurePathEndingWithoutSeparator (sCleanPath);
 
-      if (sCleanPath.startsWith ("/"))
+      if (sCleanPath.startsWith (SEPARATOR_STR))
         throw new IllegalArgumentException ("A resource directory may not be an absolute path: '" + sName + "'");
 
       final String [] aParts = JCStringHelper.getExplodedArray (SEPARATOR, sCleanPath);
@@ -186,7 +190,7 @@ public class JResourceDir implements IJOwned
     if (isUnnamed ())
       return null;
 
-    final int idx = m_sName.lastIndexOf ('/');
+    final int idx = m_sName.lastIndexOf (SEPARATOR);
     if (idx < 0)
       return m_aOwner.rootResourceDir ();
     return m_aOwner.resourceDir (m_sName.substring (0, idx));
@@ -229,7 +233,8 @@ public class JResourceDir implements IJOwned
       bIsPotentiallyJavaSrcFile = sName.endsWith (".java");
     if (bIsPotentiallyJavaSrcFile)
     {
-      final JPackage aPackage = owner ()._package (m_sName.replace ('/', '.'));
+      final JPackage aPackage = owner ()._package (m_sName.replace (SEPARATOR, JPackage.SEPARATOR));
+      // Cut trailing ".java"
       final JDefinedClass aDC = aPackage.getClassResource (sName.substring (0, sName.length () - 5));
       if (aDC != null)
         throw new JClassAlreadyExistsException (aDC);
@@ -289,7 +294,7 @@ public class JResourceDir implements IJOwned
   {
     if (isUnnamed ())
       return owner ().resourceDir (sSubDirName);
-    return owner ().resourceDir (m_sName + '/' + sSubDirName);
+    return owner ().resourceDir (m_sName + SEPARATOR + sSubDirName);
   }
 
   /**
@@ -322,6 +327,6 @@ public class JResourceDir implements IJOwned
   @Nonnull
   String fullChildName (@Nonnull final String sChildName)
   {
-    return isUnnamed () ? sChildName : m_sName + '/' + sChildName;
+    return isUnnamed () ? sChildName : m_sName + SEPARATOR + sChildName;
   }
 }
diff --git a/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java b/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
index 1caf956e..ad49c050 100644
--- a/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
+++ b/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
@@ -249,6 +249,46 @@ public final class JCStringHelper
     return ret.toString ();
   }
 
+  /**
+   * Just calls <code>replaceAll</code> as long as there are still replacements
+   * found
+   *
+   * @param sInputString
+   *        The input string where the text should be replace. If this parameter
+   *        is <code>null</code> or empty, no replacement is done.
+   * @param sSearchText
+   *        The string to be replaced. May neither be <code>null</code> nor
+   *        empty.
+   * @param sReplacementText
+   *        The string with the replacement. May not be <code>null</code> but
+   *        may be empty.
+   * @return The input string as is, if the input string is empty or if the
+   *         string to be replaced is not contained.
+   */
+  @Nullable
+  public static String replaceAllRepeatedly (@Nullable final String sInputString,
+                                             @Nonnull final String sSearchText,
+                                             @Nonnull final String sReplacementText)
+  {
+    JCValueEnforcer.notEmpty (sSearchText, "SearchText");
+    JCValueEnforcer.notNull (sReplacementText, "ReplacementText");
+    JCValueEnforcer.isFalse (sReplacementText.contains (sSearchText),
+                             "Loop detection: replacementText must not contain searchText");
+
+    // Is input string empty?
+    if (hasNoText (sInputString))
+      return sInputString;
+
+    String sRet = sInputString;
+    String sLastLiteral;
+    do
+    {
+      sLastLiteral = sRet;
+      sRet = sRet.replace (sSearchText, sReplacementText);
+    } while (!sLastLiteral.equals (sRet));
+    return sRet;
+  }
+
   /**
    * Get the first character of the passed character sequence
    *
diff --git a/src/test/java/com/helger/jcodemodel/JResourceDirTest.java b/src/test/java/com/helger/jcodemodel/JResourceDirTest.java
index 79de2945..bd40d6f8 100644
--- a/src/test/java/com/helger/jcodemodel/JResourceDirTest.java
+++ b/src/test/java/com/helger/jcodemodel/JResourceDirTest.java
@@ -25,11 +25,21 @@ public final class JResourceDirTest
   }
 
   @Test (expected = IllegalArgumentException.class)
-  public void testDoubleSlash ()
+  public void testAbsolutePath2 ()
   {
     final JCodeModel cm = new JCodeModel ();
-    // this should fail because of empty "in-between" directory
+    // this should fail
+    cm.resourceDir ("\\usr");
+  }
+
+  public void testMultiSeparator ()
+  {
+    final JCodeModel cm = new JCodeModel ();
+    // works because of internal unification
     cm.resourceDir ("usr//bla");
+    cm.resourceDir ("usr////////////////////////////////////////////////////bla");
+    cm.resourceDir ("usr//bla///////////////////////////////////////");
+    cm.resourceDir ("usr//\\\\\\\\\\\\\\\\\\\\\\///\\\\\\\\bla\\\\\\\\\\\\/////");
   }
 
   @Test (expected = JResourceAlreadyExistsException.class)
