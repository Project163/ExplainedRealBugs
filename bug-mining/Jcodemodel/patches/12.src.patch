diff --git a/src/main/java/com/helger/jcodemodel/JFieldRef.java b/src/main/java/com/helger/jcodemodel/JFieldRef.java
index 4a1cdcbb..c123e2c5 100644
--- a/src/main/java/com/helger/jcodemodel/JFieldRef.java
+++ b/src/main/java/com/helger/jcodemodel/JFieldRef.java
@@ -171,6 +171,7 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
     return _explicitThis;
   }
 
+  @Nonnull
   public JFieldRef explicitThis (final boolean explicitThis)
   {
     this._explicitThis = explicitThis;
@@ -182,7 +183,13 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
     final String name = name ();
 
     if (_object != null)
-      f.generable (_object).print ('.').print (name);
+    {
+      if (_object instanceof AbstractJType)
+        f.type ((AbstractJType) _object);
+      else
+        f.generable (_object);
+      f.print ('.').print (name);
+    }
     else
       if (_explicitThis)
         f.print ("this.").print (name);
@@ -198,13 +205,15 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
     if (o == null || getClass () != o.getClass ())
       return false;
     final JFieldRef rhs = (JFieldRef) o;
-    return isEqual (_object, rhs._object) && isEqual (name (), rhs.name ());
+    return isEqual (_object, rhs._object) &&
+           isEqual (name (), rhs.name ()) &&
+           isEqual (_explicitThis, rhs._explicitThis);
   }
 
   @Override
   public int hashCode ()
   {
-    return getHashCode (this, _object, name ());
+    return getHashCode (this, _object, name (), Boolean.valueOf (_explicitThis));
   }
 
   @Override
diff --git a/src/main/java/com/helger/jcodemodel/JFieldVar.java b/src/main/java/com/helger/jcodemodel/JFieldVar.java
index 22977b88..87706cbb 100644
--- a/src/main/java/com/helger/jcodemodel/JFieldVar.java
+++ b/src/main/java/com/helger/jcodemodel/JFieldVar.java
@@ -113,4 +113,12 @@ public class JFieldVar extends JVar implements IJDocCommentable
       f.generable (_jdoc);
     super.declare (f);
   }
+
+  @Override
+  public void generate (@Nonnull final JFormatter f)
+  {
+    // Ensure the type is collected - see issue #30
+    f.type (_owner).print ('.');
+    super.generate (f);
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JFormatter.java b/src/main/java/com/helger/jcodemodel/JFormatter.java
index b17c8b78..f283c52c 100644
--- a/src/main/java/com/helger/jcodemodel/JFormatter.java
+++ b/src/main/java/com/helger/jcodemodel/JFormatter.java
@@ -53,6 +53,7 @@ import java.util.Map;
 import java.util.Set;
 
 import javax.annotation.Nonnull;
+import javax.annotation.concurrent.NotThreadSafe;
 
 import com.helger.jcodemodel.util.ClassNameComparator;
 import com.helger.jcodemodel.util.NullWriter;
@@ -61,6 +62,7 @@ import com.helger.jcodemodel.util.NullWriter;
  * This is a utility class for managing indentation and other basic formatting
  * for PrintWriter.
  */
+@NotThreadSafe
 public class JFormatter implements Closeable
 {
   public static boolean containsErrorTypes (@Nonnull final JDefinedClass c)
@@ -74,23 +76,23 @@ public class JFormatter implements Closeable
 
   private static enum EMode
   {
-    /**
-     * Collect all the type names and identifiers. In this mode we don't
-     * actually generate anything.
-     */
+   /**
+    * Collect all the type names and identifiers. In this mode we don't actually
+    * generate anything.
+    */
     COLLECTING,
-    /**
-     * Print the actual source code.
-     */
+   /**
+    * Print the actual source code.
+    */
     PRINTING,
 
-    /**
-     * Find any error types in output code. In this mode we don't actually
-     * generate anything.
-     * <p>
-     * Only used by {@link JFormatter#containsErrorTypes(JDefinedClass)
-     * containsErrorTypes} method
-     */
+   /**
+    * Find any error types in output code. In this mode we don't actually
+    * generate anything.
+    * <p>
+    * Only used by {@link JFormatter#containsErrorTypes(JDefinedClass)
+    * containsErrorTypes} method
+    */
     FIND_ERROR_TYPES
   }
 
diff --git a/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue30FuncTest.java b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue30FuncTest.java
new file mode 100644
index 00000000..c42c48fc
--- /dev/null
+++ b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue30FuncTest.java
@@ -0,0 +1,55 @@
+package com.helger.jcodemodel.supplementary.issues;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import com.helger.jcodemodel.JClassAlreadyExistsException;
+import com.helger.jcodemodel.JCodeModel;
+import com.helger.jcodemodel.JDefinedClass;
+import com.helger.jcodemodel.JExpr;
+import com.helger.jcodemodel.JFieldVar;
+import com.helger.jcodemodel.JMethod;
+import com.helger.jcodemodel.JMod;
+import com.helger.jcodemodel.JPackage;
+import com.helger.jcodemodel.writer.SingleStreamCodeWriter;
+
+/**
+ * Test for https://github.com/phax/jcodemodel/issues/30
+ *
+ * @author Philip Helger
+ */
+public final class Issue30FuncTest
+{
+  @Test
+  public void test () throws JClassAlreadyExistsException, IOException
+  {
+    final JCodeModel cm = new JCodeModel ();
+
+    final JPackage aPkg1 = cm._package ("id.myapp");
+    final JDefinedClass aClass_R = aPkg1._class ("R");
+    final JDefinedClass aClass_id = aClass_R._class (JMod.PUBLIC | JMod.STATIC, "id");
+    final JFieldVar aFieldItem = aClass_id.field (JMod.PUBLIC |
+                                                  JMod.STATIC |
+                                                  JMod.FINAL,
+                                                  cm.INT,
+                                                  "myItem",
+                                                  JExpr.lit (1));
+    final JDefinedClass aClass_menu = aClass_R._class (JMod.PUBLIC | JMod.STATIC, "menu");
+    final JFieldVar aFieldMenu = aClass_menu.field (JMod.PUBLIC |
+                                                    JMod.STATIC |
+                                                    JMod.FINAL,
+                                                    cm.INT,
+                                                    "myMenu",
+                                                    JExpr.lit (2));
+
+    final JPackage aPkg2 = cm._package ("demo");
+    final JDefinedClass aClassAct = aPkg2._class ("HelloAndroidActivity_");
+    final JMethod aMethodCreate = aClassAct.method (JMod.PUBLIC, cm.BOOLEAN, "onCreateOptionsMenu");
+    aMethodCreate.body ().add (JExpr.ref ("menuInflater").invoke ("inflate").arg (aFieldMenu));
+    final JMethod aMethodSelected = aClassAct.method (JMod.PUBLIC, cm.BOOLEAN, "onOptionsItemSelected");
+    aMethodSelected.body ()._if (JExpr.ref ("itemId_").eq (aFieldItem));
+
+    cm.build (new SingleStreamCodeWriter (System.out));
+  }
+}
