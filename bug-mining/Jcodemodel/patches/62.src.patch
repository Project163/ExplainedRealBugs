diff --git a/src/main/java/com/helger/jcodemodel/JReferencedClass.java b/src/main/java/com/helger/jcodemodel/JReferencedClass.java
index 6c25813d..08c2dc36 100644
--- a/src/main/java/com/helger/jcodemodel/JReferencedClass.java
+++ b/src/main/java/com/helger/jcodemodel/JReferencedClass.java
@@ -76,6 +76,11 @@ class JReferencedClass extends AbstractJClass implements IJDeclaration
     assert !m_aClass.isArray ();
   }
 
+  public Class <?> getReferencedClass ()
+  {
+    return m_aClass;
+  }
+
   @Override
   public String name ()
   {
@@ -142,17 +147,20 @@ class JReferencedClass extends AbstractJClass implements IJDeclaration
     {
       private int m_nIdx = 0;
 
+      @Override
       public boolean hasNext ()
       {
         return m_nIdx < aInterfaces.length;
       }
 
+      @Override
       @Nonnull
       public AbstractJClass next ()
       {
         return owner ().ref (aInterfaces[m_nIdx++]);
       }
 
+      @Override
       public void remove ()
       {
         throw new UnsupportedOperationException ();
@@ -189,6 +197,7 @@ class JReferencedClass extends AbstractJClass implements IJDeclaration
     return m_aPrimitiveType;
   }
 
+  @Override
   public void declare (final IJFormatter f)
   {
     // Nothing to do here...
@@ -203,7 +212,7 @@ class JReferencedClass extends AbstractJClass implements IJDeclaration
 
   @Override
   protected AbstractJClass substituteParams (@Nonnull final JTypeVar [] aVariables,
-                                             @Nonnull final List <? extends AbstractJClass> aBindings)
+      @Nonnull final List <? extends AbstractJClass> aBindings)
   {
     // TODO: does JDK 1.5 reflection provides these information?
     return this;
diff --git a/src/main/java/com/helger/jcodemodel/JTypeVarClass.java b/src/main/java/com/helger/jcodemodel/JTypeVarClass.java
index 16468ea8..01d96284 100644
--- a/src/main/java/com/helger/jcodemodel/JTypeVarClass.java
+++ b/src/main/java/com/helger/jcodemodel/JTypeVarClass.java
@@ -59,6 +59,11 @@ public class JTypeVarClass extends JTypeVar
     m_aClass = aClass;
   }
 
+  public AbstractJClass getRefClass ()
+  {
+    return m_aClass;
+  }
+
   @Override
   @Nonnull
   public String name ()
@@ -68,10 +73,8 @@ public class JTypeVarClass extends JTypeVar
     {
       final JTypeVar [] aTypeParams = ((JDefinedClass) m_aClass).typeParams ();
       if (aTypeParams.length > 0)
-      {
         // We need the type params here!
         return new JNarrowedClass (m_aClass, aTypeParams).name ();
-      }
     }
     return m_aClass.name ();
   }
@@ -82,10 +85,8 @@ public class JTypeVarClass extends JTypeVar
   {
     // This method is e.g. used for import statements
     if (m_aClass instanceof JNarrowedClass)
-    {
       // Avoid the type parameters
       return ((JNarrowedClass) m_aClass).erasure ().fullName ();
-    }
     return m_aClass.fullName ();
   }
 
diff --git a/src/main/java/com/helger/jcodemodel/ModelCopy.java b/src/main/java/com/helger/jcodemodel/ModelCopy.java
index 70902b1d..c1c2bf33 100644
--- a/src/main/java/com/helger/jcodemodel/ModelCopy.java
+++ b/src/main/java/com/helger/jcodemodel/ModelCopy.java
@@ -1,6 +1,8 @@
 package com.helger.jcodemodel;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map.Entry;
 
 import com.helger.jcodemodel.exceptions.JCodeModelException;
@@ -28,6 +30,7 @@ public class ModelCopy extends JCodeModel
     }
   }
 
+
   private HashMap <JPackage, JPackage> translatedPackages = new HashMap <> ();
 
   public JPackage translate (JPackage pack)
@@ -35,33 +38,165 @@ public class ModelCopy extends JCodeModel
     return translatedPackages.computeIfAbsent (pack, o -> _package (pack.name ()));
   }
 
+  //
+  // translate types
+  //
+
   private HashMap <JDefinedClass, JDefinedClass> translatedJDefinedClass = new HashMap <> ();
 
-  public JDefinedClass translate (JDefinedClass cl)
+  public JDefinedClass translate (JDefinedClass type)
   {
-    JDefinedClass ret = translatedJDefinedClass.get (cl);
+    JDefinedClass ret = translatedJDefinedClass.get (type);
     if (ret == null)
     {
       try
       {
-        ret = _class (cl.mods ().getValue (), cl.fullName (), cl.getClassType ());
+        ret = _class (type.mods ().getValue (), type.fullName (), type.getClassType ());
       }
       catch (JCodeModelException e1)
       {
         throw new UnsupportedOperationException ("catch this", e1);
       }
       // put it in the map before building it, for recursive calls.
-      translatedJDefinedClass.put (cl, ret);
-      for (Entry <String, JFieldVar> e : cl.fields ().entrySet ())
-      {
-        JFieldVar f = e.getValue ();
-        ret.field (f.mods ().getValue (), f.type (), e.getKey (), translate (f.init ()));
-      }
-      // TODO what else ?
+      translatedJDefinedClass.put (type, ret);
+      copyClass (type, ret);
+    }
+    return type;
+  }
+
+  protected void copyClass (JDefinedClass type, JDefinedClass ret)
+  {
+    for (Entry <String, JFieldVar> e : type.fields ().entrySet ())
+    {
+      JFieldVar f = e.getValue ();
+      ret.field (f.mods ().getValue (), f.type (), e.getKey (), translate (f.init ()));
     }
-    return cl;
+    // TODO what else ?
+  }
+
+  public JAnonymousClass translate (JAnonymousClass type)
+  {
+    JAnonymousClass ret = new JAnonymousClass (translate (type.base ()));
+    copyClass (type, ret);
+    return ret;
+  }
+
+  public AbstractJType translate (AbstractJType type)
+  {
+    if (type.getClass () == JPrimitiveType.class)
+    {
+      JPrimitiveType real = (JPrimitiveType) type;
+      return new JPrimitiveType (this, real.fullName (), ((JReferencedClass) real.boxify ()).getReferencedClass (),
+          real.useValueOf ());
+    }
+    if (type instanceof AbstractJClass)
+      return translate ((AbstractJClass) type);
+
+    throw new UnsupportedOperationException ("not done " + type.getClass ());
+  }
+
+  public JReferencedClass translate (JReferencedClass type)
+  {
+    return new JReferencedClass (this, type.getReferencedClass ());
+  }
+
+  public AbstractJClass translate (AbstractJClass type)
+  {
+    if (type.getClass () == JDefinedClass.class)
+      return translate ((JDefinedClass) type);
+
+    if (type.getClass () == JAnonymousClass.class)
+      return translate ((JAnonymousClass) type);
+
+    if (type.getClass () == JDirectClass.class)
+      return translate((JDirectClass) type);
+
+    if (type.getClass () == JArrayClass.class)
+      return translate((JArrayClass) type);
+
+    if (type.getClass () == JErrorClass.class)
+      return translate ((JErrorClass) type);
+
+    if (type.getClass () == JNarrowedClass.class)
+      return translate ((JNarrowedClass) type);
+
+    if (type.getClass () == JNullType.class)
+      return translate ((JNullType) type);
+
+    if (type.getClass () == JReferencedClass.class)
+      return translate ((JReferencedClass) type);
+
+    if (type.getClass () == JTypeVar.class)
+      return translate ((JTypeVar) type);
+
+    if (type.getClass () == JTypeVarClass.class)
+      return translate ((JTypeVarClass) type);
+
+    if (type instanceof JTypeWildcard)
+      return translate ((JTypeWildcard) type);
+
+    throw new UnsupportedOperationException ("not done " + type.getClass ());
+
+  }
+
+  public JDirectClass translate (JDirectClass type)
+  {
+    return new JDirectClass (this, translate (type.getOuter ()), type.getClassType (), type.fullName ());
+  }
+
+  public JArrayClass translate (JArrayClass type)
+  {
+    return new JArrayClass (this, translate (type.elementType ()));
   }
 
+  public JErrorClass translate (JErrorClass type)
+  {
+    return new JErrorClass (this, type.getMessage ());
+  }
+
+  public JNarrowedClass translate (JNarrowedClass type)
+  {
+    List <AbstractJClass> args = new ArrayList <> ();
+    for (AbstractJClass arg : type.getTypeParameters ())
+      args.add (translate(arg));
+    return new JNarrowedClass (translate (type.erasure ()), args);
+  }
+
+  public JNullType translate (JNullType type)
+  {
+    return new JNullType (this);
+  }
+
+  public JTypeVar translate (JTypeVar type)
+  {
+    return new JTypeVar (this, type.name ());
+  }
+
+  public JTypeVarClass translate (JTypeVarClass type)
+  {
+    return new JTypeVarClass (translate (type.getRefClass ()));
+  }
+
+  public JTypeWildcard translate (JTypeWildcard type)
+  {
+    return new JTypeWildcard (translate (type.bound ()), type.boundMode ());
+  }
+
+  private IJClassContainer <?> translate (IJClassContainer <?> type)
+  {
+    if (type instanceof JPackage)
+      return translate ((JPackage) type);
+    if (type instanceof JDefinedClass)
+      return translate ((JDefinedClass) type);
+    if (type instanceof JDirectClass)
+      return translate ((JDirectClass) type);
+    throw new UnsupportedOperationException ("not done " + type.getClass ());
+  }
+
+  //
+  // translate expressions
+  //
+
   protected IJExpression translate (IJExpression expr)
   {
     Class <? extends IJExpression> cl = expr.getClass ();
@@ -75,8 +210,33 @@ public class ModelCopy extends JCodeModel
       JAtom atom = (JAtom) expr;
       return new JAtom (atom.what ());
     }
+    if (cl == JAtomDouble.class)
+    {
+      JAtomDouble atom = (JAtomDouble) expr;
+      return new JAtomDouble (atom.what ());
+    }
+    if (cl == JAtomFloat.class)
+    {
+      JAtomFloat atom = (JAtomFloat) expr;
+      return new JAtomFloat (atom.what ());
+    }
+    if (cl == JAtomInt.class)
+    {
+      JAtomInt atom = (JAtomInt) expr;
+      return new JAtomInt (atom.what ());
+    }
+    if (cl == JAtomLong.class)
+    {
+      JAtomLong atom = (JAtomLong) expr;
+      return new JAtomLong (atom.what ());
+    }
+    if (cl == JCast.class)
+    {
+      JCast real = (JCast) expr;
+      return new JCast (translate (real.type ()), translate (real.object ()));
+    }
     // TODO
-    return null;
+    throw new UnsupportedOperationException ("not done " + cl.getClass ());
   }
 
 }
