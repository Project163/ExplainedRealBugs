diff --git a/src/main/java/com/helger/jcodemodel/JCodeModel.java b/src/main/java/com/helger/jcodemodel/JCodeModel.java
index d8618170..51e197b0 100644
--- a/src/main/java/com/helger/jcodemodel/JCodeModel.java
+++ b/src/main/java/com/helger/jcodemodel/JCodeModel.java
@@ -45,11 +45,14 @@ import java.io.IOException;
 import java.io.PrintStream;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import javax.annotation.Nonnegative;
 import javax.annotation.Nonnull;
@@ -197,11 +200,13 @@ public final class JCodeModel
   private AbstractJClass m_aWildcard;
 
   /** The charset used for building the output - null means system default */
-  private Charset m_aBuildingCharset = null;
+  private Charset m_aBuildingCharset;
 
   /** The newline string to be used. Defaults to system default */
   private String m_sBuildingNewLine = AbstractCodeWriter.getDefaultNewLine ();
 
+  private final Set <AbstractJClass> m_aDontImportClasses = new HashSet <> ();
+
   public JCodeModel ()
   {}
 
@@ -555,26 +560,26 @@ public final class JCodeModel
    * Generates Java source code. A convenience method that calls
    * {@link #build(AbstractCodeWriter,AbstractCodeWriter)}.
    *
-   * @param srcDir
+   * @param aSrcDir
    *        Java source files are generated into this directory.
-   * @param resourceDir
+   * @param aResourceDir
    *        Other resource files are generated into this directory.
-   * @param status
+   * @param aStatus
    *        Progress stream. May be <code>null</code>.
    * @throws IOException
    *         on IO error if non-null, progress indication will be sent to this
    *         stream.
    */
-  public void build (@Nonnull final File srcDir,
-                     @Nonnull final File resourceDir,
-                     @Nullable final PrintStream status) throws IOException
+  public void build (@Nonnull final File aSrcDir,
+                     @Nonnull final File aResourceDir,
+                     @Nullable final PrintStream aStatus) throws IOException
   {
-    AbstractCodeWriter res = new FileCodeWriter (resourceDir, m_aBuildingCharset, m_sBuildingNewLine);
-    AbstractCodeWriter src = new FileCodeWriter (srcDir, m_aBuildingCharset, m_sBuildingNewLine);
-    if (status != null)
+    AbstractCodeWriter res = new FileCodeWriter (aResourceDir, m_aBuildingCharset, m_sBuildingNewLine);
+    AbstractCodeWriter src = new FileCodeWriter (aSrcDir, m_aBuildingCharset, m_sBuildingNewLine);
+    if (aStatus != null)
     {
-      src = new ProgressCodeWriter (src, status);
-      res = new ProgressCodeWriter (res, status);
+      src = new ProgressCodeWriter (src, aStatus);
+      res = new ProgressCodeWriter (res, aStatus);
     }
     build (src, res);
   }
@@ -582,68 +587,68 @@ public final class JCodeModel
   /**
    * A convenience method for <code>build(destDir,System.out)</code>.
    *
-   * @param destDir
+   * @param aDestDir
    *        source files and resources are generated into this directory.
    * @throws IOException
    *         on IO error
    */
-  public void build (@Nonnull final File destDir) throws IOException
+  public void build (@Nonnull final File aDestDir) throws IOException
   {
-    build (destDir, System.out);
+    build (aDestDir, System.out);
   }
 
   /**
    * A convenience method for <code>build(srcDir,resourceDir,System.out)</code>.
    *
-   * @param srcDir
+   * @param aSrcDir
    *        Java source files are generated into this directory.
-   * @param resourceDir
+   * @param aResourceDir
    *        Other resource files are generated into this directory.
    * @throws IOException
    *         on IO error
    */
-  public void build (@Nonnull final File srcDir, @Nonnull final File resourceDir) throws IOException
+  public void build (@Nonnull final File aSrcDir, @Nonnull final File aResourceDir) throws IOException
   {
-    build (srcDir, resourceDir, System.out);
+    build (aSrcDir, aResourceDir, System.out);
   }
 
   /**
    * A convenience method for <code>build(out,out)</code>.
    *
-   * @param out
+   * @param aWriter
    *        Source code and resource writer
    * @throws IOException
    *         on IO error
    */
-  public void build (@Nonnull final AbstractCodeWriter out) throws IOException
+  public void build (@Nonnull final AbstractCodeWriter aWriter) throws IOException
   {
-    build (out, out);
+    build (aWriter, aWriter);
   }
 
   /**
    * Generates Java source code.
    *
-   * @param source
+   * @param aSource
    *        Source code writer
-   * @param resource
+   * @param aResource
    *        Resource writer
    * @throws IOException
    *         on IO error
    */
-  public void build (@Nonnull final AbstractCodeWriter source,
-                     @Nonnull final AbstractCodeWriter resource) throws IOException
+  public void build (@Nonnull final AbstractCodeWriter aSource,
+                     @Nonnull final AbstractCodeWriter aResource) throws IOException
   {
     try
     {
-      final JPackage [] pkgs = m_aPackages.values ().toArray (new JPackage [m_aPackages.size ()]);
-      // avoid concurrent modification exception
+      // Copy to avoid concurrent modification exception
+      final List <JPackage> pkgs = new ArrayList <> (m_aPackages.values ());
       for (final JPackage pkg : pkgs)
-        pkg.build (source, resource);
+        pkg.build (aSource, aResource);
     }
     finally
     {
-      source.close ();
-      resource.close ();
+      aSource.close ();
+      aResource.close ();
     }
   }
 
@@ -1009,4 +1014,44 @@ public final class JCodeModel
       }
     }
   }
+
+  /**
+   * Add a class that should <strong>NOT</strong> be imported.
+   *
+   * @param aClass
+   *        The class to use. May not be <code>null</code>.
+   * @return <code>true</code> if it was added, <code>false</code> if it was
+   *         already contained.
+   * @since 3.0.0
+   */
+  public boolean addDontImportClass (@Nonnull final Class <?> aClass)
+  {
+    return addDontImportClass (ref (aClass));
+  }
+
+  /**
+   * Add a class that should <strong>NOT</strong> be imported.
+   *
+   * @param aClass
+   *        The class to use. May not be <code>null</code>.
+   * @return <code>true</code> if it was added, <code>false</code> if it was
+   *         already contained.
+   * @since 3.0.0
+   */
+  public boolean addDontImportClass (@Nonnull final AbstractJClass aClass)
+  {
+    JCValueEnforcer.notNull (aClass, "Class");
+    return m_aDontImportClasses.add (aClass);
+  }
+
+  /**
+   * @return A copy all classes that should not be imported. Never
+   *         <code>null</code> but maybe empty.
+   * @since 3.0.0
+   */
+  @Nonnull
+  public Collection <AbstractJClass> getAllDontImportClasses ()
+  {
+    return new HashSet <> (m_aDontImportClasses);
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JFormatter.java b/src/main/java/com/helger/jcodemodel/JFormatter.java
index ee8d2b8c..68908972 100644
--- a/src/main/java/com/helger/jcodemodel/JFormatter.java
+++ b/src/main/java/com/helger/jcodemodel/JFormatter.java
@@ -225,6 +225,7 @@ public class JFormatter implements Closeable
 
   private final class ImportedClasses
   {
+    private final Set <AbstractJClass> m_aDontImportClasses = new HashSet <> ();
     private final Set <AbstractJClass> m_aClasses = new HashSet <> ();
     private final Set <String> m_aNames = new HashSet <> ();
 
@@ -248,10 +249,23 @@ public class JFormatter implements Closeable
       return aRealClass;
     }
 
+    public void addDontImportClass (@Nonnull final AbstractJClass aClass)
+    {
+      final AbstractJClass aRealClass = _getClassForImport (aClass);
+      m_aDontImportClasses.add (aRealClass);
+    }
+
     public boolean add (@Nonnull final AbstractJClass aClass)
     {
       final AbstractJClass aRealClass = _getClassForImport (aClass);
 
+      if (m_aDontImportClasses.contains (aRealClass))
+      {
+        if (m_bImportDebug)
+          System.out.println ("The class '" + aRealClass.fullName () + "' should not be imported!");
+        return false;
+      }
+
       // Avoid importing 2 classes with the same class name
       if (!m_aNames.add (aRealClass.name ()))
       {
@@ -1067,6 +1081,20 @@ public class JFormatter implements Closeable
     declaration (aClassToBeWritten);
   }
 
+  /**
+   * Add classes that should not be imported.
+   * 
+   * @param aClasses
+   *        The classes to not be used in "import" statements. May be
+   *        <code>null</code>.
+   */
+  public void addDontImportClasses (@Nullable final Iterable <? extends AbstractJClass> aClasses)
+  {
+    if (aClasses != null)
+      for (final AbstractJClass aClass : aClasses)
+        m_aImportedClasses.addDontImportClass (aClass);
+  }
+
   public static boolean containsErrorTypes (@Nonnull final JDefinedClass c)
   {
     final JFormatter aFormatter = new JFormatter (NullWriter.getInstance ());
diff --git a/src/main/java/com/helger/jcodemodel/JPackage.java b/src/main/java/com/helger/jcodemodel/JPackage.java
index 2030ff42..268f09d1 100644
--- a/src/main/java/com/helger/jcodemodel/JPackage.java
+++ b/src/main/java/com/helger/jcodemodel/JPackage.java
@@ -58,6 +58,7 @@ import java.util.TreeMap;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import javax.annotation.WillNotClose;
 
 import com.helger.jcodemodel.util.JCValueEnforcer;
 
@@ -548,7 +549,19 @@ public class JPackage implements
     f.print (m_sName);
   }
 
-  void build (final AbstractCodeWriter src, final AbstractCodeWriter res) throws IOException
+  @Nonnull
+  private JFormatter _createJavaSourceFileWriter (@Nonnull final AbstractCodeWriter src,
+                                                  @Nonnull final String className) throws IOException
+  {
+    final SourcePrintWriter aWriter = src.openSource (this, className + ".java");
+    final JFormatter ret = new JFormatter (aWriter);
+    // Add all classes to not be imported (may be empty)
+    ret.addDontImportClasses (m_aOwner.getAllDontImportClasses ());
+    return ret;
+  }
+
+  void build (@Nonnull @WillNotClose final AbstractCodeWriter aSrcWriter,
+              @Nonnull @WillNotClose final AbstractCodeWriter aResWriter) throws IOException
   {
     // write classes
     for (final JDefinedClass c : m_aClasses.values ())
@@ -559,7 +572,7 @@ public class JPackage implements
         continue;
       }
 
-      try (final JFormatter f = _createJavaSourceFileWriter (src, c.name ()))
+      try (final JFormatter f = _createJavaSourceFileWriter (aSrcWriter, c.name ()))
       {
         f.write (c);
       }
@@ -568,7 +581,7 @@ public class JPackage implements
     // write package annotations
     if (m_aAnnotations != null || m_aJavaDoc != null)
     {
-      try (final JFormatter f = _createJavaSourceFileWriter (src, "package-info"))
+      try (final JFormatter f = _createJavaSourceFileWriter (aSrcWriter, "package-info"))
       {
         if (m_aJavaDoc != null)
           f.generable (m_aJavaDoc);
@@ -586,7 +599,7 @@ public class JPackage implements
     // write resources
     for (final AbstractJResourceFile rsrc : m_aResources)
     {
-      final AbstractCodeWriter cw = rsrc.isResource () ? res : src;
+      final AbstractCodeWriter cw = rsrc.isResource () ? aResWriter : aSrcWriter;
       try (final OutputStream os = new BufferedOutputStream (cw.openBinary (this, rsrc.name ())))
       {
         rsrc.build (os);
@@ -634,12 +647,4 @@ public class JPackage implements
 
     return ret;
   }
-
-  @Nonnull
-  private JFormatter _createJavaSourceFileWriter (@Nonnull final AbstractCodeWriter src,
-                                                  @Nonnull final String className) throws IOException
-  {
-    final SourcePrintWriter aWriter = src.openSource (this, className + ".java");
-    return new JFormatter (aWriter);
-  }
 }
diff --git a/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue51FuncTest.java b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue51FuncTest.java
new file mode 100644
index 00000000..e8454dbe
--- /dev/null
+++ b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue51FuncTest.java
@@ -0,0 +1,78 @@
+/**
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
+ * Portions Copyright 2013-2017 Philip Helger + contributors
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the "Classpath"
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * "Portions Copyright [year] [name of copyright owner]"
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+package com.helger.jcodemodel.supplementary.issues;
+
+import java.net.URI;
+import java.net.URL;
+
+import org.junit.Test;
+
+import com.helger.jcodemodel.JCodeModel;
+import com.helger.jcodemodel.JDefinedClass;
+import com.helger.jcodemodel.JExpr;
+import com.helger.jcodemodel.JMethod;
+import com.helger.jcodemodel.JMod;
+import com.helger.jcodemodel.util.CodeModelTestsHelper;
+
+/**
+ * Test for https://github.com/phax/jcodemodel/issues/51
+ *
+ * @author Philip Helger
+ */
+public final class Issue51FuncTest
+{
+  @Test
+  public void testDefaultMethod () throws Exception
+  {
+    final JCodeModel generator = new JCodeModel ();
+
+    final JDefinedClass aInterface = generator._package ("issue51")._class ("Test");
+    JMethod m = aInterface.method (JMod.PUBLIC, generator.ref (URI.class), "noURI");
+    m.body ()._return (JExpr._null ());
+
+    m = aInterface.method (JMod.PUBLIC, generator.ref (URL.class), "noURL");
+    m.body ()._return (JExpr._null ());
+
+    CodeModelTestsHelper.parseCodeModel (generator);
+    generator.addDontImportClass (URI.class);
+    CodeModelTestsHelper.parseCodeModel (generator);
+  }
+}
diff --git a/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java b/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
index bb07d5ba..23c78cfc 100644
--- a/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
+++ b/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
@@ -45,6 +45,7 @@ import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 
 import javax.annotation.Nonnull;
 
@@ -67,7 +68,7 @@ import com.helger.jcodemodel.writer.SingleStreamCodeWriter;
  */
 public final class CodeModelTestsHelper
 {
-  public static final Charset DEFAULT_ENCODING = Charset.forName ("UTF-8");
+  public static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
 
   /** Hidden constructor. */
   private CodeModelTestsHelper ()
@@ -76,19 +77,18 @@ public final class CodeModelTestsHelper
   /**
    * Prints an expression into a string.
    *
-   * @param aExpression
+   * @param aGenerable
    *        expression to print into a string.
    * @return Expression formatted as a string.
    */
   @Nonnull
-  public static String toString (@Nonnull final IJExpression aExpression)
+  public static String toString (@Nonnull final IJExpression aGenerable)
   {
-    if (aExpression == null)
-      throw new IllegalArgumentException ("Generable must not be null.");
+    JCValueEnforcer.notNull (aGenerable, "Generable");
 
     final StringWriter aSW = new StringWriter ();
     final JFormatter formatter = new JFormatter (aSW);
-    aExpression.generate (formatter);
+    aGenerable.generate (formatter);
     return aSW.toString ();
   }
 
@@ -102,8 +102,7 @@ public final class CodeModelTestsHelper
   @Nonnull
   public static String toString (@Nonnull final IJDeclaration aDeclaration)
   {
-    if (aDeclaration == null)
-      throw new IllegalArgumentException ("Declaration must not be null.");
+    JCValueEnforcer.notNull (aDeclaration, "Declaration");
 
     final StringWriter aSW = new StringWriter ();
     final JFormatter formatter = new JFormatter (aSW);
@@ -121,8 +120,7 @@ public final class CodeModelTestsHelper
   @Nonnull
   public static String toString (@Nonnull final IJStatement aStatement)
   {
-    if (aStatement == null)
-      throw new IllegalArgumentException ("Statement must not be null.");
+    JCValueEnforcer.notNull (aStatement, "Statement");
 
     final StringWriter aSW = new StringWriter ();
     final JFormatter formatter = new JFormatter (aSW);
@@ -131,26 +129,24 @@ public final class CodeModelTestsHelper
   }
 
   @Nonnull
-  public static String declare (@Nonnull final IJDeclaration declaration)
+  public static String declare (@Nonnull final IJDeclaration aDeclaration)
   {
-    if (declaration == null)
-      throw new IllegalArgumentException ("Declaration must not be null.");
+    JCValueEnforcer.notNull (aDeclaration, "Declaration");
 
     final StringWriter aSW = new StringWriter ();
     final JFormatter formatter = new JFormatter (aSW);
-    declaration.declare (formatter);
+    aDeclaration.declare (formatter);
     return aSW.toString ();
   }
 
   @Nonnull
-  public static String generate (@Nonnull final IJGenerable generable)
+  public static String generate (@Nonnull final IJGenerable aGenerable)
   {
-    if (generable == null)
-      throw new IllegalArgumentException ("Generable must not be null.");
+    JCValueEnforcer.notNull (aGenerable, "Generable");
 
     final StringWriter aSW = new StringWriter ();
     final JFormatter formatter = new JFormatter (aSW);
-    generable.generate (formatter);
+    aGenerable.generate (formatter);
     return aSW.toString ();
   }
 
@@ -179,7 +175,7 @@ public final class CodeModelTestsHelper
   {
     final byte [] aBytes = getAllBytes (cm);
     if (true)
-      System.out.println (new String (aBytes, DEFAULT_ENCODING.name ()));
+      System.out.println (new String (aBytes, DEFAULT_ENCODING));
 
     final ByteArrayInputStream bis = new ByteArrayInputStream (aBytes);
 
