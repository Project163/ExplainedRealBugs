diff --git a/README.md b/README.md
index fba3317b..d3bf8d8c 100644
--- a/README.md
+++ b/README.md
@@ -14,6 +14,8 @@ A site with the links to the [API docs](http://phax.github.io/jcodemodel/) etc.
 
 # News and noteworthy
 
+* v3.3.1 - work in progress
+    * Added special top-level construct `JResourceDir` to represent pure resource directories ([issue #74](https://github.com/phax/jcodemodel/issues/74) from @guiguilechat)
 * v3.3.0 - 2019-11-24
     * Added check for package names so that no invalid package names can be created ([issue #70](https://github.com/phax/jcodemodel/issues/70) from @guiguilechat)
     * Added check to avoid creating classes existing in the "java.lang" package ([issue #71](https://github.com/phax/jcodemodel/issues/71) from @guiguilechat)
diff --git a/src/main/java/com/helger/jcodemodel/JCodeModel.java b/src/main/java/com/helger/jcodemodel/JCodeModel.java
index cabb2e8e..6d0ae1c6 100644
--- a/src/main/java/com/helger/jcodemodel/JCodeModel.java
+++ b/src/main/java/com/helger/jcodemodel/JCodeModel.java
@@ -57,6 +57,7 @@ import java.util.Set;
 import javax.annotation.Nonnegative;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import javax.annotation.Resource;
 import javax.annotation.concurrent.NotThreadSafe;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
@@ -144,7 +145,8 @@ public class JCodeModel implements Serializable
 
   /**
    * Conversion from primitive type {@link Class} (such as {@link Integer#TYPE})
-   * to its boxed type (such as <tt>Integer.class</tt>). It's an unmodifiable map.
+   * to its boxed type (such as <tt>Integer.class</tt>). It's an unmodifiable
+   * map.
    */
   public static final Map <Class <?>, Class <?>> primitiveToBox;
 
@@ -179,6 +181,9 @@ public class JCodeModel implements Serializable
   /** The packages that this JCodeWriter contains. */
   private final Map <String, JPackage> m_aPackages = new HashMap <> ();
 
+  /** The resource directories that this JCodeWriter contains. */
+  private final Map <String, JResourceDir> m_aResourceDirs = new HashMap <> ();
+
   /** All JReferencedClasses are pooled here. */
   private final Map <Class <?>, JReferencedClass> m_aRefClasses = new HashMap <> ();
 
@@ -218,7 +223,8 @@ public class JCodeModel implements Serializable
    *
    * @param sName
    *        Name of the package. Use "" to indicate the root package.
-   * @return Newly generated package
+   * @return Newly generated package. Never <code>null</code>.
+   * @see #rootPackage()
    */
   @Nonnull
   public JPackage _package (@Nonnull final String sName)
@@ -226,6 +232,10 @@ public class JCodeModel implements Serializable
     return m_aPackages.computeIfAbsent (sName, k -> new JPackage (k, this));
   }
 
+  /**
+   * @return The root package. Never <code>null</code>. This is a shortcut for
+   *         <code>_package ("")</code>.
+   */
   @Nonnull
   public JPackage rootPackage ()
   {
@@ -251,6 +261,55 @@ public class JCodeModel implements Serializable
     return new ArrayList <> (m_aPackages.values ());
   }
 
+  /**
+   * Add a {@link Resource} directory to the list of resource directories to be
+   * generated
+   *
+   * @param sName
+   *        Name of the resource directory. Use "" to indicate the root
+   *        directory.
+   * @return Newly generated resource directory. Never <code>null</code>.
+   * @see #rootResourceDir()
+   * @since 3.3.1
+   */
+  @Nonnull
+  public JResourceDir resourceDir (@Nonnull final String sName)
+  {
+    return m_aResourceDirs.computeIfAbsent (sName, k -> new JResourceDir (k, this));
+  }
+
+  /**
+   * @return The root resource directory. Never <code>null</code>. This is a
+   *         shortcut for <code>resourceDir ("")</code>.
+   * @since 3.3.1
+   */
+  @Nonnull
+  public JResourceDir rootResourceDir ()
+  {
+    return resourceDir ("");
+  }
+
+  /**
+   * @return an iterator that walks the packages defined using this code writer.
+   * @since 3.3.1
+   */
+  @Nonnull
+  public Iterator <JResourceDir> resourceDirs ()
+  {
+    return m_aResourceDirs.values ().iterator ();
+  }
+
+  /**
+   * @return a list with all packages. The list is mutable. Never
+   *         <code>null</code>.
+   * @since 3.3.1
+   */
+  @Nonnull
+  public List <JResourceDir> getAllResourceDirs ()
+  {
+    return new ArrayList <> (m_aResourceDirs.values ());
+  }
+
   /**
    * Creates a new generated class.
    *
@@ -333,8 +392,8 @@ public class JCodeModel implements Serializable
    * Creates a dummy, unknown {@link JDirectClass} that represents a given name.
    * <br>
    * This method is useful when the code generation needs to include the
-   * user-specified class that may or may not exist, and only thing known about it
-   * is a class name.
+   * user-specified class that may or may not exist, and only thing known about
+   * it is a class name.
    *
    * @param sName
    *        The fully qualified name of the class. When using type parameters
@@ -351,8 +410,8 @@ public class JCodeModel implements Serializable
    * Creates a dummy, unknown {@link JDirectClass} that represents a given name.
    * <br>
    * This method is useful when the code generation needs to include the
-   * user-specified class that may or may not exist, and only thing known about it
-   * is a class name.
+   * user-specified class that may or may not exist, and only thing known about
+   * it is a class name.
    *
    * @param eClassType
    *        Class type to use.
@@ -375,18 +434,18 @@ public class JCodeModel implements Serializable
    * class that should never leak into actually written code.
    * <p>
    * Error-types represents holes or place-holders that can't be filled.
-   * References to error-classes can be used in hidden class-models. Such classes
-   * should never be actually written but can be somehow used during code
-   * generation. Use {@code JCodeModel#buildsErrorTypeRefs} method to test if your
-   * generated Java-sources contains references to error-types.
+   * References to error-classes can be used in hidden class-models. Such
+   * classes should never be actually written but can be somehow used during
+   * code generation. Use {@code JCodeModel#buildsErrorTypeRefs} method to test
+   * if your generated Java-sources contains references to error-types.
    * <p>
    * You should probably always check generated code with
    * {@code JCodeModel#buildsErrorTypeRefs} method if you use any error-types.
    * <p>
-   * Most of error-types methods throws {@code JErrorClassUsedException} unchecked
-   * exceptions. Be careful and use {@link AbstractJType#isError()
-   * AbstractJType#isError} method to check for error-types before actually using
-   * it's methods.
+   * Most of error-types methods throws {@code JErrorClassUsedException}
+   * unchecked exceptions. Be careful and use {@link AbstractJType#isError()
+   * AbstractJType#isError} method to check for error-types before actually
+   * using it's methods.
    *
    * @param sMessage
    *        some free form text message to identify source of error
@@ -408,18 +467,18 @@ public class JCodeModel implements Serializable
    * class that should never leak into actually written code.
    * <p>
    * Error-types represents holes or place-holders that can't be filled.
-   * References to error-classes can be used in hidden class-models. Such classes
-   * should never be actually written but can be somehow used during code
-   * generation. Use {@code JCodeModel#buildsErrorTypeRefs} method to test if your
-   * generated Java-sources contains references to error-types.
+   * References to error-classes can be used in hidden class-models. Such
+   * classes should never be actually written but can be somehow used during
+   * code generation. Use {@code JCodeModel#buildsErrorTypeRefs} method to test
+   * if your generated Java-sources contains references to error-types.
    * <p>
    * You should probably always check generated code with
    * {@code JCodeModel#buildsErrorTypeRefs} method if you use any error-types.
    * <p>
-   * Most of error-types methods throws {@code JErrorClassUsedException} unchecked
-   * exceptions. Be careful and use {@link AbstractJType#isError()
-   * AbstractJType#isError} method to check for error-types before actually using
-   * it's methods.
+   * Most of error-types methods throws {@code JErrorClassUsedException}
+   * unchecked exceptions. Be careful and use {@link AbstractJType#isError()
+   * AbstractJType#isError} method to check for error-types before actually
+   * using it's methods.
    *
    * @param sName
    *        name of missing class if it is known
@@ -495,8 +554,8 @@ public class JCodeModel implements Serializable
   }
 
   /**
-   * @return The default charset used for building. <code>null</code> means system
-   *         default.
+   * @return The default charset used for building. <code>null</code> means
+   *         system default.
    * @deprecated In favor of the new {@link JCMWriter} class offering more
    *             configuration flexibility.
    */
@@ -676,16 +735,18 @@ public class JCodeModel implements Serializable
   }
 
   /**
-   * @return the number of files to be generated if {@link #build} is invoked now.
+   * @return the number of files to be generated if {@link #build} is invoked
+   *         now.
    */
   @Nonnegative
   public int countArtifacts ()
   {
     int r = 0;
-    final JPackage [] pkgs = m_aPackages.values ().toArray (new JPackage [m_aPackages.size ()]);
     // avoid concurrent modification exception
-    for (final JPackage pkg : pkgs)
-      r += pkg.countArtifacts ();
+    for (final JPackage aItem : new ArrayList <> (m_aPackages.values ()))
+      r += aItem.countArtifacts ();
+    for (final JResourceDir aItem : new ArrayList <> (m_aResourceDirs.values ()))
+      r += aItem.countArtifacts ();
     return r;
   }
 
@@ -726,20 +787,21 @@ public class JCodeModel implements Serializable
   }
 
   /**
-   * Obtains a reference to a processable class from its TypeElement description.
+   * Obtains a reference to a processable class from its TypeElement
+   * description.
    * <p>
    * Annotation processors can get access of {@link TypeElement} objects during
-   * annotation processing. These TypeElement objects can be used with jcodemodel
-   * as a references to classes.
+   * annotation processing. These TypeElement objects can be used with
+   * jcodemodel as a references to classes.
    * <p>
    * This method result-class definition can never include references to
-   * "error"-types. Error-types araise during annotation processing when something
-   * is not fully defined.
+   * "error"-types. Error-types araise during annotation processing when
+   * something is not fully defined.
    * <p>
    * You can post-pond annotation processing for later stages of annotation
-   * processor hoping that all error-types will become defined on some annotation
-   * processing stage at last. You can catch {@link ErrorTypeFound} exception to
-   * achieve this.
+   * processor hoping that all error-types will become defined on some
+   * annotation processing stage at last. You can catch {@link ErrorTypeFound}
+   * exception to achieve this.
    *
    * @param aElement
    *        Processable class to reference
@@ -762,20 +824,21 @@ public class JCodeModel implements Serializable
   }
 
   /**
-   * Obtains a reference to a processable class from its TypeElement description.
+   * Obtains a reference to a processable class from its TypeElement
+   * description.
    * <p>
-   * Annotation processors can get access of TypeElement objects during annotation
-   * processing. These TypeElement objects can be used with jcodemodel as a
-   * references to classes.
+   * Annotation processors can get access of TypeElement objects during
+   * annotation processing. These TypeElement objects can be used with
+   * jcodemodel as a references to classes.
    * <p>
-   * This method result-class definition can include references to "error"-types.
-   * Error-types araise during annotation processing when something is not fully
-   * defined.
+   * This method result-class definition can include references to
+   * "error"-types. Error-types araise during annotation processing when
+   * something is not fully defined.
    * <p>
    * Sometimes direct treatment of error-types is required. You can use
-   * {@link AbstractJType#isError()} and {@link JCodeModel#buildsErrorTypeRefs()}
-   * methods to handle error-types and to prevent error-types to leak into
-   * generated code.
+   * {@link AbstractJType#isError()} and
+   * {@link JCodeModel#buildsErrorTypeRefs()} methods to handle error-types and
+   * to prevent error-types to leak into generated code.
    *
    * @param aElement
    *        Processable class to reference
@@ -802,8 +865,8 @@ public class JCodeModel implements Serializable
    *
    * @param aClass
    *        Class to be referenced
-   * @return Might be a <code>JReferencedClass</code> or a {@link JArrayClass} or
-   *         a {@link JPrimitiveType}
+   * @return Might be a <code>JReferencedClass</code> or a {@link JArrayClass}
+   *         or a {@link JPrimitiveType}
    * @see #ref(Class)
    */
   @Nonnull
@@ -815,11 +878,11 @@ public class JCodeModel implements Serializable
   }
 
   /**
-   * Obtains a reference to an existing class from its fully-qualified class name.
-   * <br>
+   * Obtains a reference to an existing class from its fully-qualified class
+   * name. <br>
    * First, this method attempts to load the class of the given name. If that
-   * fails, we assume that the class is derived straight from {@link Object}, and
-   * return a {@link AbstractJClass}.
+   * fails, we assume that the class is derived straight from {@link Object},
+   * and return a {@link AbstractJClass}.
    *
    * @param sFullyQualifiedClassName
    *        FQCN
@@ -968,8 +1031,8 @@ public class JCodeModel implements Serializable
     }
 
     /**
-     * Parses additional left-associative suffixes, like type arguments and array
-     * specifiers.
+     * Parses additional left-associative suffixes, like type arguments and
+     * array specifiers.
      */
     @Nonnull
     private AbstractJClass _parseSuffix (@Nonnull final AbstractJClass aClazz)
diff --git a/src/main/java/com/helger/jcodemodel/JPackage.java b/src/main/java/com/helger/jcodemodel/JPackage.java
index 7ad0b4be..2ef6feb5 100644
--- a/src/main/java/com/helger/jcodemodel/JPackage.java
+++ b/src/main/java/com/helger/jcodemodel/JPackage.java
@@ -282,8 +282,11 @@ public class JPackage implements
    * @param rsrc
    *        Resource file to add
    * @return Parameter resource file
+   * @deprecated Use the API from {@link JResourceDir} instead. Deprecated since
+   *             v3.3.1
    */
   @Nonnull
+  @Deprecated
   public AbstractJResourceFile addResourceFile (@Nonnull final AbstractJResourceFile rsrc)
   {
     JCValueEnforcer.notNull (rsrc, "ResourceFile");
@@ -297,7 +300,10 @@ public class JPackage implements
    * @param sName
    *        Filename to check
    * @return <code>true</code> if contained
+   * @deprecated Use the API from {@link JResourceDir} instead. Deprecated since
+   *             v3.3.1
    */
+  @Deprecated
   public boolean hasResourceFile (@Nullable final String sName)
   {
     for (final AbstractJResourceFile r : m_aResources)
@@ -310,7 +316,7 @@ public class JPackage implements
    * Iterates all resource files in this package.
    *
    * @return Iterator
-   * @deprecated Use {@link #resourceFiles()} instead
+   * @deprecated Use {@link #resourceFiles()} instead. Deprecated since v3.3.1
    */
   @Deprecated
   @Nonnull
@@ -324,13 +330,22 @@ public class JPackage implements
    *
    * @return Iterator
    * @since 3.2.0
+   * @deprecated Use the API from {@link JResourceDir} instead. Deprecated since
+   *             v3.3.1
    */
+  @Deprecated
   @Nonnull
   public Iterator <AbstractJResourceFile> resourceFiles ()
   {
     return m_aResources.iterator ();
   }
 
+  /**
+   * @return A copy of all contained resource files. Never <code>null</code>.
+   * @deprecated Use the API from {@link JResourceDir} instead. Deprecated since
+   *             v3.3.1
+   */
+  @Deprecated
   @Nonnull
   public List <AbstractJResourceFile> getAllResourceFiles ()
   {
@@ -501,14 +516,14 @@ public class JPackage implements
   @Nonnull
   File toPath (@Nonnull final File aDir)
   {
-    if (m_sName == null)
+    if (isUnnamed ())
       return aDir;
     return new File (aDir, m_sName.replace ('.', File.separatorChar));
   }
 
   public void declare (@Nonnull final IJFormatter f)
   {
-    if (m_sName.length () != 0)
+    if (!isUnnamed ())
       f.print ("package").print (m_sName).print (';').newline ();
   }
 
diff --git a/src/main/java/com/helger/jcodemodel/JResourceDir.java b/src/main/java/com/helger/jcodemodel/JResourceDir.java
new file mode 100644
index 00000000..4402387b
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/JResourceDir.java
@@ -0,0 +1,272 @@
+/**
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
+ * Portions Copyright 2013-2020 Philip Helger + contributors
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the "Classpath"
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * "Portions Copyright [year] [name of copyright owner]"
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+package com.helger.jcodemodel;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.Nonnegative;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+import com.helger.jcodemodel.fmt.AbstractJResourceFile;
+import com.helger.jcodemodel.util.JCFilenameHelper;
+import com.helger.jcodemodel.util.JCStringHelper;
+import com.helger.jcodemodel.util.JCValueEnforcer;
+
+/**
+ * A Java resource directory - complementary to a {@link JPackage}.
+ *
+ * @since 3.3.1
+ */
+public class JResourceDir implements IJOwned
+{
+  public static final char SEPARATOR = JCFilenameHelper.UNIX_SEPARATOR;
+
+  /**
+   * Check if the resource directory name part is valid or not.
+   *
+   * @param sName
+   *        The name part to check
+   * @return <code>true</code> if it is invalid, <code>false</code> if it is
+   *         valid
+   */
+  public static boolean isForbiddenDirectoryNamePart (@Nonnull final String sName)
+  {
+    // Empty is not allowed
+    if (sName == null || sName.length () == 0)
+      return true;
+
+    // Java keywords are now allowed
+    if (!JCFilenameHelper.isValidFilename (sName))
+      return true;
+
+    // not forbidden -> allowed
+    return false;
+  }
+
+  /**
+   * Name of the package. May be the empty string for the root package.
+   */
+  private final String m_sName;
+
+  private final JCodeModel m_aOwner;
+
+  /**
+   * List of resources files inside this package.
+   */
+  private final Set <AbstractJResourceFile> m_aResources = new HashSet <> ();
+
+  /**
+   * Constructor
+   *
+   * @param sName
+   *        Name of directory. May not be <code>null</code> but empty.
+   * @param aOwner
+   *        The code writer being used to create this package
+   * @throws IllegalArgumentException
+   *         If each part of the package name is not a valid filename part.
+   */
+  protected JResourceDir (@Nonnull final String sName, @Nonnull final JCodeModel aOwner)
+  {
+    JCValueEnforcer.notNull (sName, "Name");
+    JCValueEnforcer.notNull (aOwner, "CodeModel");
+
+    m_aOwner = aOwner;
+
+    // An empty directory name is okay
+    if (sName.length () > 0)
+    {
+      // Convert "\" to "/"
+      String sCleanPath = JCFilenameHelper.getPathUsingUnixSeparator (sName);
+      // Ensure last part is not a "/"
+      sCleanPath = JCFilenameHelper.ensurePathEndingWithoutSeparator (sCleanPath);
+      final String [] aParts = JCStringHelper.getExplodedArray (SEPARATOR, sCleanPath);
+      for (final String sPart : aParts)
+        if (isForbiddenDirectoryNamePart (sPart))
+          throw new IllegalArgumentException ("Part '" +
+                                              sPart +
+                                              "' of the resource directory name '" +
+                                              sName +
+                                              "' is invalid");
+      m_sName = sCleanPath;
+    }
+    else
+      m_sName = "";
+  }
+
+  /**
+   * @return the code model root object being used to create this resource
+   *         directory.
+   */
+  @Nonnull
+  public final JCodeModel owner ()
+  {
+    return m_aOwner;
+  }
+
+  /**
+   * Get the name of this resource directory
+   *
+   * @return The name of this resource directory, or the empty string if this is
+   *         the root directory. For example, this method returns strings like
+   *         <code>"dir1/dir2/dir3"</code>
+   */
+  @Nonnull
+  public final String name ()
+  {
+    return m_sName;
+  }
+
+  /**
+   * @return the parent package, or <code>null</code> if this class is the root
+   *         package.
+   */
+  @Nullable
+  public JResourceDir parent ()
+  {
+    if (isUnnamed ())
+      return null;
+
+    final int idx = m_sName.lastIndexOf ('/');
+    if (idx < 0)
+      return m_aOwner.rootResourceDir ();
+    return m_aOwner.resourceDir (m_sName.substring (0, idx));
+  }
+
+  /**
+   * Adds a new resource file to this package.
+   *
+   * @param rsrc
+   *        Resource file to add
+   * @return Parameter resource file
+   * @param <T>
+   *        The implementation type used
+   */
+  @Nonnull
+  public <T extends AbstractJResourceFile> T addResourceFile (@Nonnull final T rsrc)
+  {
+    JCValueEnforcer.notNull (rsrc, "ResourceFile");
+    m_aResources.add (rsrc);
+    return rsrc;
+  }
+
+  /**
+   * Checks if a resource of the given name exists.
+   *
+   * @param sName
+   *        Filename to check
+   * @return <code>true</code> if contained
+   */
+  public boolean hasResourceFile (@Nullable final String sName)
+  {
+    for (final AbstractJResourceFile r : m_aResources)
+      if (r.name ().equals (sName))
+        return true;
+    return false;
+  }
+
+  /**
+   * Iterates all resource files in this package.
+   *
+   * @return Iterator
+   */
+  @Nonnull
+  public Iterator <AbstractJResourceFile> resourceFiles ()
+  {
+    return m_aResources.iterator ();
+  }
+
+  /**
+   * @return A copy of all contained resource files and never <code>null</code>.
+   */
+  @Nonnull
+  public List <AbstractJResourceFile> getAllResourceFiles ()
+  {
+    return new ArrayList <> (m_aResources);
+  }
+
+  /**
+   * Gets a reference to a sub directory of this package.
+   *
+   * @param sSubDirName
+   *        Name of the sub-directory
+   * @return New sub-directory
+   */
+  @Nonnull
+  public JResourceDir subDir (@Nonnull final String sSubDirName)
+  {
+    if (isUnnamed ())
+      return owner ().resourceDir (sSubDirName);
+    return owner ().resourceDir (m_sName + '/' + sSubDirName);
+  }
+
+  /**
+   * Checks if this package is the root, unnamed package.
+   *
+   * @return <code>true</code> if this is the root package
+   */
+  public final boolean isUnnamed ()
+  {
+    return m_sName.length () == 0;
+  }
+
+  /**
+   * Convert the package name to directory path equivalent
+   */
+  @Nonnull
+  File toPath (@Nonnull final File aDir)
+  {
+    if (isUnnamed ())
+      return aDir;
+    return new File (aDir, m_sName);
+  }
+
+  @Nonnegative
+  int countArtifacts ()
+  {
+    return m_aResources.size ();
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/util/JCArrayHelper.java b/src/main/java/com/helger/jcodemodel/util/JCArrayHelper.java
new file mode 100644
index 00000000..89467055
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/util/JCArrayHelper.java
@@ -0,0 +1,139 @@
+/**
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
+ * Portions Copyright 2013-2020 Philip Helger + contributors
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the "Classpath"
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * "Portions Copyright [year] [name of copyright owner]"
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+package com.helger.jcodemodel.util;
+
+import java.util.function.Predicate;
+
+import javax.annotation.Nonnegative;
+import javax.annotation.Nullable;
+
+public final class JCArrayHelper
+{
+  private JCArrayHelper ()
+  {}
+
+  /**
+   * @param aArray
+   *        The array who's size is to be queried. May be <code>null</code>.
+   * @return 0 if the passed array is <code>null</code> - it's length otherwise.
+   */
+  @Nonnegative
+  public static int getSize (@Nullable final char... aArray)
+  {
+    return aArray == null ? 0 : aArray.length;
+  }
+
+  /**
+   * @param <ELEMENTTYPE>
+   *        Array element type
+   * @param aArray
+   *        The array who's size is to be queried. May be <code>null</code>.
+   * @return 0 if the passed array is <code>null</code> - it's length otherwise.
+   */
+  @Nonnegative
+  @SafeVarargs
+  public static <ELEMENTTYPE> int getSize (@Nullable final ELEMENTTYPE... aArray)
+  {
+    return aArray == null ? 0 : aArray.length;
+  }
+
+  /**
+   * @param <ELEMENTTYPE>
+   *        Array element type
+   * @param aArray
+   *        The array to be queried if it is empty. May be <code>null</code>.
+   * @return <code>false</code> if the passed array is <code>null</code> or
+   *         empty.
+   */
+  @SafeVarargs
+  public static <ELEMENTTYPE> boolean isNotEmpty (@Nullable final ELEMENTTYPE... aArray)
+  {
+    return getSize (aArray) > 0;
+  }
+
+  /**
+   * Get the index of the passed search value in the passed value array.
+   *
+   * @param aValues
+   *        The value array to be searched. May be <code>null</code>.
+   * @param aSearchValue
+   *        The value to be searched. May be <code>null</code>.
+   * @return <code>-1</code> if the searched value is not contained, a value
+   *         &ge; 0 otherwise.
+   */
+  public static int getFirstIndex (@Nullable final char [] aValues, final char aSearchValue)
+  {
+    final int nLength = getSize (aValues);
+    if (nLength > 0)
+      for (int nIndex = 0; nIndex < nLength; ++nIndex)
+        if (JCEqualsHelper.isEqual (aValues[nIndex], aSearchValue))
+          return nIndex;
+    return -1;
+  }
+
+  /**
+   * Check if the passed search value is contained in the passed value array.
+   *
+   * @param aValues
+   *        The value array to be searched. May be <code>null</code>.
+   * @param aSearchValue
+   *        The value to be searched. May be <code>null</code>.
+   * @return <code>true</code> if the value array is not empty and the search
+   *         value is contained - false otherwise.
+   */
+  public static boolean contains (@Nullable final char [] aValues, final char aSearchValue)
+  {
+    return getFirstIndex (aValues, aSearchValue) >= 0;
+  }
+
+  public static <ELEMENTTYPE> boolean containsAny (@Nullable final ELEMENTTYPE [] aArray,
+                                                   @Nullable final Predicate <? super ELEMENTTYPE> aFilter)
+  {
+    if (aFilter == null)
+      return isNotEmpty (aArray);
+
+    if (isNotEmpty (aArray))
+      for (final ELEMENTTYPE aElement : aArray)
+        if (aFilter.test (aElement))
+          return true;
+    return false;
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/util/JCFilenameHelper.java b/src/main/java/com/helger/jcodemodel/util/JCFilenameHelper.java
new file mode 100644
index 00000000..e9d1c91c
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/util/JCFilenameHelper.java
@@ -0,0 +1,986 @@
+/**
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
+ * Portions Copyright 2013-2020 Philip Helger + contributors
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the "Classpath"
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * "Portions Copyright [year] [name of copyright owner]"
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+package com.helger.jcodemodel.util;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.Locale;
+
+import javax.annotation.CheckReturnValue;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.Immutable;
+
+/**
+ * All kind of file name handling stuff. This class gives you platform
+ * independent file name handling.
+ *
+ * @author Philip Helger
+ */
+@Immutable
+public final class JCFilenameHelper
+{
+  /** The file extension separation character. */
+  public static final char EXTENSION_SEPARATOR = '.';
+
+  /** The replacement character used for illegal file name characters. */
+  public static final char ILLEGAL_FILENAME_CHAR_REPLACEMENT = '_';
+
+  /** Special name of the current path */
+  public static final String PATH_CURRENT = ".";
+
+  /** Special name of the parent path */
+  public static final String PATH_PARENT = "..";
+
+  /** The Unix path separator character. */
+  public static final char UNIX_SEPARATOR = '/';
+
+  /** The Unix path separator string. */
+  public static final String UNIX_SEPARATOR_STR = Character.toString (UNIX_SEPARATOR);
+
+  /** The Windows separator character. */
+  public static final char WINDOWS_SEPARATOR = '\\';
+
+  /** The Windows separator string. */
+  public static final String WINDOWS_SEPARATOR_STR = Character.toString (WINDOWS_SEPARATOR);
+
+  /** The prefix to identify UNC paths on Unix based systems */
+  public static final String UNIX_UNC_PREFIX = "//";
+
+  /** The prefix to identify UNC paths on Windows based systems */
+  public static final String WINDOWS_UNC_PREFIX = "\\\\";
+
+  /** The prefix to identify local UNC paths on Windows based systems */
+  public static final String WINDOWS_UNC_PREFIX_LOCAL1 = "\\\\.\\";
+  /** The prefix to identify local UNC paths on Windows based systems */
+  public static final String WINDOWS_UNC_PREFIX_LOCAL2 = "\\\\?\\";
+
+  /** The prefix used for Unix hidden files */
+  public static final char HIDDEN_FILE_PREFIX = '.';
+
+  public static final boolean IS_WINDOWS = System.getProperty ("os.name").toLowerCase (Locale.US).contains ("windows");
+
+  /**
+   * Illegal characters in Windows file names.<br>
+   * see http://en.wikipedia.org/wiki/Filename
+   */
+  private static final char [] ILLEGAL_CHARACTERS_WINDOWS = { 0, '<', '>', '?', '*', ':', '|', '"' };
+  private static final char [] ILLEGAL_CHARACTERS_OTHERS = { 0, '<', '>', '?', '*', '|', '"' };
+  // separate by OS - allow ":" as name part on Linux
+  private static final char [] ILLEGAL_CHARACTERS = IS_WINDOWS ? ILLEGAL_CHARACTERS_WINDOWS : ILLEGAL_CHARACTERS_OTHERS;
+
+  /**
+   * see http://www.w3.org/TR/widgets/#zip-relative <br>
+   * see http://forum.java.sun.com/thread.jspa?threadID=544334&tstart=165<br>
+   * see http://en.wikipedia.org/wiki/Filename
+   */
+  private static final String [] ILLEGAL_PREFIXES = { "CLOCK$",
+                                                      "CON",
+                                                      "PRN",
+                                                      "AUX",
+                                                      "NUL",
+                                                      "COM2",
+                                                      "COM3",
+                                                      "COM4",
+                                                      "COM5",
+                                                      "COM6",
+                                                      "COM7",
+                                                      "COM8",
+                                                      "COM9",
+                                                      "LPT1",
+                                                      "LPT2",
+                                                      "LPT3",
+                                                      "LPT4",
+                                                      "LPT5",
+                                                      "LPT6",
+                                                      "LPT7",
+                                                      "LPT8",
+                                                      "LPT9" };
+
+  private static final char [] ILLEGAL_SUFFIXES = new char [] { '.', ' ', '\t' };
+
+  static
+  {
+    if (!isSecureFilenameCharacter (ILLEGAL_FILENAME_CHAR_REPLACEMENT))
+      throw new IllegalStateException ("The illegal filename replacement character must be a valid ASCII character!");
+  }
+
+  private JCFilenameHelper ()
+  {}
+
+  /**
+   * Returns the index of the last extension separator character, which is a
+   * dot.
+   * <p>
+   * This method also checks that there is no directory separator after the last
+   * dot. To do this it uses {@link #getIndexOfLastSeparator(String)} which will
+   * handle a file in either Unix or Windows format.
+   * <p>
+   * The output will be the same irrespective of the machine that the code is
+   * running on.
+   *
+   * @param sFilename
+   *        The filename to find the last path separator in. May be
+   *        <code>null</code>.
+   * @return the index of the last separator character, or -1 if there is no
+   *         such character or the input parameter is <code>null</code>.
+   * @see #getIndexOfLastSeparator(String)
+   */
+  public static int getIndexOfExtension (@Nullable final String sFilename)
+  {
+    if (sFilename == null)
+      return -1;
+
+    final int nExtensionIndex = sFilename.lastIndexOf (EXTENSION_SEPARATOR);
+    final int nLastSepIndex = getIndexOfLastSeparator (sFilename);
+    return nLastSepIndex > nExtensionIndex ? -1 : nExtensionIndex;
+  }
+
+  /**
+   * Get the name of the passed file without the extension. If the file name
+   * contains a leading absolute path, the path is returned as well.
+   *
+   * @param aFile
+   *        The file to extract the extension from. May be <code>null</code>.
+   * @return An empty string if no extension was found, the extension without
+   *         the leading dot otherwise. If the input file is <code>null</code>
+   *         the return value is <code>null</code>.
+   * @see #getWithoutExtension(String)
+   */
+  @Nullable
+  public static String getWithoutExtension (@Nullable final File aFile)
+  {
+    return aFile == null ? null : getWithoutExtension (aFile.getPath ());
+  }
+
+  /**
+   * Get the passed filename without the extension. If the file name contains a
+   * leading absolute path, the path is returned as well.
+   *
+   * @param sFilename
+   *        The filename to extract the extension from. May be <code>null</code>
+   *        or empty.
+   * @return An empty string if no extension was found, the extension without
+   *         the leading dot otherwise. If the input string is <code>null</code>
+   *         the return value is <code>null</code>.
+   * @see #getIndexOfExtension(String)
+   */
+  @Nullable
+  public static String getWithoutExtension (@Nullable final String sFilename)
+  {
+    final int nIndex = getIndexOfExtension (sFilename);
+    return nIndex == -1 ? sFilename : sFilename.substring (0, nIndex);
+  }
+
+  /**
+   * Get the extension of the passed file.
+   *
+   * @param aFile
+   *        The file to extract the extension from. May be <code>null</code>.
+   * @return An empty string if no extension was found, the extension without
+   *         the leading dot otherwise. Never <code>null</code>.
+   * @see #getExtension(String)
+   */
+  @Nonnull
+  public static String getExtension (@Nullable final File aFile)
+  {
+    return aFile == null ? "" : getExtension (aFile.getName ());
+  }
+
+  /**
+   * Get the extension of the passed filename.
+   *
+   * @param sFilename
+   *        The filename to extract the extension from. May be <code>null</code>
+   *        or empty.
+   * @return An empty string if no extension was found, the extension without
+   *         the leading dot otherwise. Never <code>null</code>.
+   * @see #getIndexOfExtension(String)
+   */
+  @Nonnull
+  public static String getExtension (@Nullable final String sFilename)
+  {
+    final int nIndex = getIndexOfExtension (sFilename);
+    if (nIndex == -1)
+      return "";
+    return sFilename.substring (nIndex + 1);
+  }
+
+  /**
+   * Check if the passed file has one of the passed extensions. The comparison
+   * is done case insensitive even on Unix machines.
+   *
+   * @param aFile
+   *        The file to check the extension from. May be <code>null</code> or
+   *        empty.
+   * @param aExtensions
+   *        An array of extensions (without the leading dot) which are matched
+   *        case insensitive. May not be <code>null</code>.
+   * @return <code>true</code> if the file has one of the passed extensions,
+   *         else <code>false</code>.
+   * @see #getExtension(File)
+   */
+  public static boolean hasExtension (@Nullable final File aFile, @Nonnull final String... aExtensions)
+  {
+    JCValueEnforcer.notNull (aExtensions, "Extensions");
+
+    // determine current extension.
+    final String sExt = getExtension (aFile);
+    for (final String sExtension : aExtensions)
+      if (sExt.equalsIgnoreCase (sExtension))
+        return true;
+    return false;
+  }
+
+  /**
+   * Check if the passed filename has one of the passed extensions. The
+   * comparison is done case insensitive even on Unix machines.
+   *
+   * @param sFilename
+   *        The filename to check the extension from. May be <code>null</code>
+   *        or empty.
+   * @param aExtensions
+   *        An array of extensions (without the leading dot) which are matched
+   *        case insensitive. May not be <code>null</code>.
+   * @return <code>true</code> if the filename has one of the passed extensions,
+   *         else <code>false</code>.
+   * @see #getExtension(String)
+   */
+  public static boolean hasExtension (@Nullable final String sFilename, @Nonnull final String... aExtensions)
+  {
+    JCValueEnforcer.notNull (aExtensions, "Extensions");
+
+    // determine current extension.
+    final String sExt = getExtension (sFilename);
+    for (final String sExtension : aExtensions)
+      if (sExt.equalsIgnoreCase (sExtension))
+        return true;
+    return false;
+  }
+
+  /**
+   * Returns the index of the last directory separator character. This method
+   * will handle a file in either Unix or Windows format. The position of the
+   * last forward or backslash is returned. The output will be the same
+   * irrespective of the machine that the code is running on.
+   *
+   * @param sFilename
+   *        The filename to find the last path separator in, <code>null</code>
+   *        returns -1.
+   * @return The index of the last separator character, or -1 if there is no
+   *         such character
+   */
+  public static int getIndexOfLastSeparator (@Nullable final String sFilename)
+  {
+    return sFilename == null ? -1 : Math.max (sFilename.lastIndexOf (UNIX_SEPARATOR),
+                                              sFilename.lastIndexOf (WINDOWS_SEPARATOR));
+  }
+
+  /**
+   * Get the name of the passed file without any eventually leading path. Note:
+   * if the passed file is a directory, the name of the directory is returned.
+   *
+   * @param aFile
+   *        The file. May be <code>null</code>.
+   * @return The name only or <code>null</code> if the passed parameter is
+   *         <code>null</code>.
+   */
+  @Nullable
+  public static String getWithoutPath (@Nullable final File aFile)
+  {
+    return aFile == null ? null : aFile.getName ();
+  }
+
+  /**
+   * Get the name of the passed file without any eventually leading path.
+   *
+   * @param sAbsoluteFilename
+   *        The fully qualified file name. May be <code>null</code>.
+   * @return The name only or <code>null</code> if the passed parameter is
+   *         <code>null</code>.
+   * @see #getIndexOfLastSeparator(String)
+   */
+  @Nullable
+  public static String getWithoutPath (@Nullable final String sAbsoluteFilename)
+  {
+    /**
+     * Note: do not use <code>new File (sFilename).getName ()</code> since this
+     * only invokes the underlying FileSystem implementation which handles path
+     * handling only correctly on the native platform. Problem arose when
+     * running application on a Linux server and making a file upload from a
+     * Windows machine.
+     */
+    if (sAbsoluteFilename == null)
+      return null;
+    final int nLastSepIndex = getIndexOfLastSeparator (sAbsoluteFilename);
+    return nLastSepIndex == -1 ? sAbsoluteFilename : sAbsoluteFilename.substring (nLastSepIndex + 1);
+  }
+
+  /**
+   * Get the path of the passed file name without any eventually contained
+   * filename.
+   *
+   * @param sAbsoluteFilename
+   *        The fully qualified file name. May be <code>null</code>.
+   * @return The path only including the last trailing path separator character.
+   *         Returns <code>null</code> if the passed parameter is
+   *         <code>null</code>.
+   * @see #getIndexOfLastSeparator(String)
+   */
+  @Nullable
+  public static String getPath (@Nullable final String sAbsoluteFilename)
+  {
+    /**
+     * Note: do not use <code>new File (sFilename).getPath ()</code> since this
+     * only invokes the underlying FileSystem implementation which handles path
+     * handling only correctly on the native platform. Problem arose when
+     * running application on a Linux server and making a file upload from a
+     * Windows machine.
+     */
+    if (sAbsoluteFilename == null)
+      return null;
+    final int nLastSepIndex = getIndexOfLastSeparator (sAbsoluteFilename);
+    return nLastSepIndex == -1 ? "" : sAbsoluteFilename.substring (0, nLastSepIndex + 1);
+  }
+
+  /**
+   * Get the passed filename without path and without extension.<br>
+   * Example: <code>/dir1/dir2/file.txt</code> becomes <code>file</code>
+   *
+   * @param aFile
+   *        The file to get the base name from. May be <code>null</code>.
+   * @return The base name of the passed parameter. May be <code>null</code> if
+   *         the parameter was <code>null</code>.
+   * @see #getWithoutExtension(String)
+   */
+  @Nullable
+  public static String getBaseName (@Nullable final File aFile)
+  {
+    return aFile == null ? null : getWithoutExtension (aFile.getName ());
+  }
+
+  /**
+   * Get the passed filename without path and without extension.<br>
+   * Example: <code>/dir1/dir2/file.txt</code> becomes <code>file</code>
+   *
+   * @param sAbsoluteFilename
+   *        The filename to get the base name from. May be <code>null</code>.
+   * @return The base name of the passed parameter. May be <code>null</code> if
+   *         the parameter was <code>null</code>.
+   * @see #getWithoutPath(String)
+   * @see #getWithoutExtension(String)
+   */
+  @Nullable
+  public static String getBaseName (@Nullable final String sAbsoluteFilename)
+  {
+    return getWithoutExtension (getWithoutPath (sAbsoluteFilename));
+  }
+
+  /**
+   * Ensure that the path (not the absolute path!) of the passed file is using
+   * the Unix style separator "/" instead of the Operating System dependent one.
+   *
+   * @param aFile
+   *        The file to use. May be <code>null</code>
+   * @return <code>null</code> if the passed file is <code>null</code>.
+   * @see #getPathUsingUnixSeparator(String)
+   */
+  @Nullable
+  public static String getPathUsingUnixSeparator (@Nullable final File aFile)
+  {
+    return aFile == null ? null : getPathUsingUnixSeparator (aFile.getPath ());
+  }
+
+  /**
+   * Ensure that the passed path is using the Unix style separator "/" instead
+   * of the Operating System dependent one.
+   *
+   * @param sAbsoluteFilename
+   *        The file name to use. May be <code>null</code>
+   * @return <code>null</code> if the passed path is <code>null</code>.
+   * @see #getPathUsingUnixSeparator(File)
+   */
+  @Nullable
+  public static String getPathUsingUnixSeparator (@Nullable final String sAbsoluteFilename)
+  {
+    return sAbsoluteFilename == null ? null
+                                     : JCStringHelper.replaceAll (sAbsoluteFilename, WINDOWS_SEPARATOR, UNIX_SEPARATOR);
+  }
+
+  /**
+   * Ensure that the path (not the absolute path!) of the passed file is using
+   * the Windows style separator "\" instead of the Operating System dependent
+   * one.
+   *
+   * @param aFile
+   *        The file to use. May be <code>null</code>
+   * @return <code>null</code> if the passed file is <code>null</code>.
+   * @see #getPathUsingWindowsSeparator(String)
+   */
+  @Nullable
+  public static String getPathUsingWindowsSeparator (@Nullable final File aFile)
+  {
+    return aFile == null ? null : getPathUsingWindowsSeparator (aFile.getPath ());
+  }
+
+  /**
+   * Ensure that the passed path is using the Windows style separator "\"
+   * instead of the Operating System dependent one.
+   *
+   * @param sAbsoluteFilename
+   *        The file name to use. May be <code>null</code>
+   * @return <code>null</code> if the passed path is <code>null</code>.
+   * @see #getPathUsingWindowsSeparator(File)
+   */
+  @Nullable
+  public static String getPathUsingWindowsSeparator (@Nullable final String sAbsoluteFilename)
+  {
+    return sAbsoluteFilename == null ? null
+                                     : JCStringHelper.replaceAll (sAbsoluteFilename, UNIX_SEPARATOR, WINDOWS_SEPARATOR);
+  }
+
+  /**
+   * Check whether the two passed file names are equal, independent of the used
+   * separators (/ or \).
+   *
+   * @param sAbsoluteFilename1
+   *        First file name. May be <code>null</code>.
+   * @param sAbsoluteFilename2
+   *        Second file name. May be <code>null</code>.
+   * @return <code>true</code> if they are equal, <code>false</code> otherwise.
+   * @see #getPathUsingUnixSeparator(String)
+   */
+  public static boolean isEqualIgnoreFileSeparator (@Nullable final String sAbsoluteFilename1,
+                                                    @Nullable final String sAbsoluteFilename2)
+  {
+    return JCEqualsHelper.isEqual (getPathUsingUnixSeparator (sAbsoluteFilename1),
+                                   getPathUsingUnixSeparator (sAbsoluteFilename2));
+  }
+
+  /**
+   * Avoid 0 byte attack. E.g. file name "test.java\u0000.txt" is internally
+   * represented as "test.java" but ends with ".txt".<br>
+   * Note: the passed file name is <b>NOT</b> decoded (e.g. %20 stays %20 and
+   * will not be converted to a space).
+   *
+   * @param sFilename
+   *        The file name to check. May be <code>null</code>.
+   * @return <code>null</code> if the input string is <code>null</code> or
+   *         everything up to the 0-byte.
+   */
+  @Nullable
+  public static String getSecureFilename (@Nullable final String sFilename)
+  {
+    if (sFilename == null)
+      return null;
+    final int nIdx0 = sFilename.indexOf ('\0');
+    return nIdx0 == -1 ? sFilename : sFilename.substring (0, nIdx0);
+  }
+
+  /**
+   * Check if the passed file name is valid. It checks for illegal prefixes that
+   * affects compatibility to Windows, illegal characters within a filename and
+   * forbidden suffixes. This method fits only for filenames on one level. If
+   * you want to check a full path, use
+   * {@link #isValidFilenameWithPaths(String)}.
+   *
+   * @param sFilename
+   *        The filename to check. May be <code>null</code>.
+   * @return <code>false</code> if the passed filename is <code>null</code> or
+   *         empty or invalid. <code>true</code> if the filename is not empty
+   *         and valid.
+   * @see #containsPathSeparatorChar(String)
+   */
+  public static boolean isValidFilename (@Nullable final String sFilename)
+  {
+    // empty not allowed
+    if (JCStringHelper.hasNoText (sFilename))
+      return false;
+
+    // path separator chars are not allowed in filenames!
+    if (containsPathSeparatorChar (sFilename))
+      return false;
+
+    // check for illegal last characters
+    if (JCStringHelper.endsWithAny (sFilename, ILLEGAL_SUFFIXES))
+      return false;
+
+    // Check if file name contains any of the illegal characters
+    for (final char cIllegal : ILLEGAL_CHARACTERS)
+      if (sFilename.indexOf (cIllegal) != -1)
+        return false;
+
+    // check prefixes directly
+    for (final String sIllegalPrefix : ILLEGAL_PREFIXES)
+      if (sFilename.equalsIgnoreCase (sIllegalPrefix))
+        return false;
+
+    // check if filename is prefixed with it
+    // Note: we can use the default locale, since all fixed names are pure ANSI
+    // names
+    final String sUCFilename = sFilename.toUpperCase (Locale.ROOT);
+    for (final String sIllegalPrefix : ILLEGAL_PREFIXES)
+      if (sUCFilename.startsWith (sIllegalPrefix + "."))
+        return false;
+
+    return true;
+  }
+
+  /**
+   * Check if the passed filename path is valid. In contrast to
+   * {@link #isValidFilename(String)} this method can also handle filenames
+   * including paths.
+   *
+   * @param sFilename
+   *        The filename to be checked for validity.
+   * @return <code>true</code> if all path elements of the filename are valid,
+   *         <code>false</code> if at least one element is invalid
+   * @see #isValidFilename(String)
+   */
+  public static boolean isValidFilenameWithPaths (@Nullable final String sFilename)
+  {
+    if (JCStringHelper.hasNoText (sFilename))
+      return false;
+
+    // Iterate filename path by path
+    File aFile = new File (sFilename);
+    while (aFile != null)
+    {
+      final String sCurFilename = aFile.getName ();
+      final File aParentFile = aFile.getParentFile ();
+      if (sCurFilename.length () == 0 && aParentFile == null)
+      {
+        // The last part of an absolute path can be skipped!
+        break;
+      }
+      if (!isValidFilename (sCurFilename))
+        return false;
+      aFile = aParentFile;
+    }
+    return true;
+  }
+
+  /**
+   * Convert the passed filename into a valid filename by performing the
+   * following actions:
+   * <ol>
+   * <li>Remove everything after a potential \0 character</li>
+   * <li>Remove all characters that are invalid at the end of a file name</li>
+   * <li>Replace all characters that are invalid inside a filename with a
+   * underscore</li>
+   * <li>If the filename is invalid on Windows platforms it is prefixed with an
+   * underscore.</li>
+   * </ol>
+   * Note: this method does not handle Windows full path like
+   * "c:\autoexec.bat"<br>
+   *
+   * @param sFilename
+   *        The filename to be made value. May be <code>null</code>.
+   * @return <code>null</code> if the input filename was <code>null</code> or if
+   *         it consisted only of characters invalid for a filename; the
+   *         potentially modified filename otherwise but <b>never</b> an empy
+   *         string.
+   * @see #getSecureFilename(String)
+   */
+  @Nullable
+  public static String getAsSecureValidFilename (@Nullable final String sFilename)
+  {
+    // First secure it, by cutting everything behind the '\0'
+    String ret = getSecureFilename (sFilename);
+
+    // empty not allowed
+    if (JCStringHelper.hasText (ret))
+    {
+      // Remove all trailing invalid suffixes
+      while (ret.length () > 0 && JCStringHelper.endsWithAny (ret, ILLEGAL_SUFFIXES))
+        ret = ret.substring (0, ret.length () - 1);
+
+      // Replace all characters that are illegal inside a filename
+      for (final char cIllegal : ILLEGAL_CHARACTERS)
+        ret = JCStringHelper.replaceAll (ret, cIllegal, ILLEGAL_FILENAME_CHAR_REPLACEMENT);
+
+      // Check if a file matches an illegal prefix
+      final String sTempRet = ret;
+      if (JCArrayHelper.containsAny (ILLEGAL_PREFIXES, sTempRet::equalsIgnoreCase))
+        ret = ILLEGAL_FILENAME_CHAR_REPLACEMENT + ret;
+
+      // check if filename is prefixed with an illegal prefix
+      // Note: we can use the default locale, since all fixed names are pure
+      // ANSI names
+      final String sUCFilename = ret.toUpperCase (Locale.ROOT);
+      if (JCArrayHelper.containsAny (ILLEGAL_PREFIXES, x -> sUCFilename.startsWith (x + ".")))
+        ret = ILLEGAL_FILENAME_CHAR_REPLACEMENT + ret;
+    }
+
+    // Avoid returning an empty string as valid file name
+    return JCStringHelper.hasNoText (ret) ? null : ret;
+  }
+
+  /**
+   * Check if the passed character is secure to be used in filenames. Therefore
+   * it must be &ge; 0x20 and &lt; 0x80.
+   *
+   * @param c
+   *        The character to check
+   * @return <code>true</code> if it is valid, <code>false</code> if not
+   */
+  public static boolean isSecureFilenameCharacter (final char c)
+  {
+    return c >= 0x20 && c < 0x80;
+  }
+
+  /**
+   * Replace all non-ASCII characters from the filename (e.g. German Umlauts)
+   * with underscores. Before replacing non-ASCII characters the filename is
+   * made valid using {@link #getAsSecureValidFilename(String)}.
+   *
+   * @param sFilename
+   *        Input file name. May not be <code>null</code>.
+   * @return <code>null</code> if the input filename was <code>null</code>. The
+   *         file name containing only ASCII characters. The returned value is
+   *         never an empty String.
+   * @see #getAsSecureValidASCIIFilename(String, char)
+   */
+  @Nullable
+  public static String getAsSecureValidASCIIFilename (@Nullable final String sFilename)
+  {
+    return getAsSecureValidASCIIFilename (sFilename, ILLEGAL_FILENAME_CHAR_REPLACEMENT);
+  }
+
+  /**
+   * Replace all non-ASCII characters from the filename (e.g. German Umlauts)
+   * with a replacement char. Before replacing non-ASCII characters the filename
+   * is made valid using {@link #getAsSecureValidFilename(String)}.
+   *
+   * @param sFilename
+   *        Input file name. May not be <code>null</code>.
+   * @param cReplacementChar
+   *        The replacement character to be used for insecure filenames.
+   * @return <code>null</code> if the input filename was <code>null</code>. The
+   *         file name containing only ASCII characters. The returned value is
+   *         never an empty String.
+   * @see #getAsSecureValidASCIIFilename(String)
+   * @see #getAsSecureValidFilename(String)
+   * @see #isSecureFilenameCharacter(char)
+   */
+  @Nullable
+  public static String getAsSecureValidASCIIFilename (@Nullable final String sFilename, final char cReplacementChar)
+  {
+    // Make it valid according to the general rules
+    final String sValid = getAsSecureValidFilename (sFilename);
+    if (sValid == null)
+      return null;
+
+    // Start replacing all non-ASCII characters with '_'
+    final StringBuilder ret = new StringBuilder (sValid.length ());
+    for (final char c : sValid.toCharArray ())
+      if (isSecureFilenameCharacter (c))
+        ret.append (c);
+      else
+        ret.append (cReplacementChar);
+    return ret.toString ();
+  }
+
+  /**
+   * Check if the passed character is a path separation character. This method
+   * handles both Windows- and Unix-style path separation characters.
+   *
+   * @param c
+   *        The character to check.
+   * @return <code>true</code> if the character is a path separation character,
+   *         <code>false</code> otherwise.
+   */
+  public static boolean isPathSeparatorChar (final char c)
+  {
+    return c == UNIX_SEPARATOR || c == WINDOWS_SEPARATOR;
+  }
+
+  /**
+   * Check if the passed character sequence starts with a path separation
+   * character.
+   *
+   * @param s
+   *        The character sequence to check. May be <code>null</code> or empty.
+   * @return <code>true</code> if the character sequences starts with a Windows-
+   *         or Unix-style path character.
+   * @see #isPathSeparatorChar(char)
+   */
+  public static boolean startsWithPathSeparatorChar (@Nullable final CharSequence s)
+  {
+    return isPathSeparatorChar (JCStringHelper.getFirstChar (s));
+  }
+
+  /**
+   * Check if the passed character sequence ends with a path separation
+   * character.
+   *
+   * @param s
+   *        The character sequence to check. May be <code>null</code> or empty.
+   * @return <code>true</code> if the character sequences ends with a Windows-
+   *         or Unix-style path character.
+   * @see #isPathSeparatorChar(char)
+   */
+  public static boolean endsWithPathSeparatorChar (@Nullable final CharSequence s)
+  {
+    return isPathSeparatorChar (JCStringHelper.getLastChar (s));
+  }
+
+  /**
+   * Check if the passed String contains at least one path separator char
+   * (either Windows or Unix style).
+   *
+   * @param s
+   *        The string to check. May be <code>null</code>.
+   * @return <code>true</code> if the passed string is not <code>null</code> and
+   *         contains at least one separator.
+   */
+  public static boolean containsPathSeparatorChar (@Nullable final String s)
+  {
+    // This is a tick faster than iterating the s.toCharArray() chars
+    return s != null && (s.indexOf (UNIX_SEPARATOR) >= 0 || s.indexOf (WINDOWS_SEPARATOR) >= 0);
+  }
+
+  /**
+   * Check if the passed file is a system directory. A system directory is
+   * either {@value #PATH_CURRENT} or {@value #PATH_PARENT}.
+   *
+   * @param aFile
+   *        The file to be checked. May be <code>null</code>.
+   * @return <code>true</code> if the passed file name (not the path) matches
+   *         any of the special directory names, <code>false</code> of the
+   *         passed file is <code>null</code> or does not denote a special
+   *         directory.
+   * @see #isSystemInternalDirectory(CharSequence)
+   */
+  public static boolean isSystemInternalDirectory (@Nullable final File aFile)
+  {
+    return aFile != null && isSystemInternalDirectory (aFile.getName ());
+  }
+
+  /**
+   * Check if the passed file is a system directory. A system directory is
+   * either {@value #PATH_CURRENT} or {@value #PATH_PARENT}.
+   *
+   * @param aFile
+   *        The file to be checked. May be <code>null</code>.
+   * @return <code>true</code> if the passed file name (not the path) matches
+   *         any of the special directory names, <code>false</code> of the
+   *         passed file is <code>null</code> or does not denote a special
+   *         directory.
+   * @see #isSystemInternalDirectory(CharSequence)
+   */
+  public static boolean isSystemInternalDirectory (@Nullable final Path aFile)
+  {
+    if (aFile == null)
+      return false;
+    final Path aPureFile = aFile.getFileName ();
+    return aPureFile != null && isSystemInternalDirectory (aPureFile.toString ());
+  }
+
+  /**
+   * Check if the passed string is a system directory. A system directory is
+   * either {@value #PATH_CURRENT} or {@value #PATH_PARENT}.
+   *
+   * @param s
+   *        The value to be checked. May be <code>null</code>.
+   * @return <code>true</code> if the passed string matches any of the special
+   *         directory names, <code>false</code> of the passed string is
+   *         <code>null</code> or does not denote a special directory.
+   * @see #isSystemInternalDirectory(File)
+   */
+  public static boolean isSystemInternalDirectory (@Nullable final CharSequence s)
+  {
+    return s != null && (s.equals (PATH_CURRENT) || s.equals (PATH_PARENT));
+  }
+
+  /**
+   * Check if the passed file is an UNC path. UNC paths are identified by
+   * starting with "//" or "\\".
+   *
+   * @param aFile
+   *        The file to be checked. May not be <code>null</code>.
+   * @return <code>true</code> if the file points to an UNC path,
+   *         <code>false</code> if not.
+   * @see #isUNCPath(String)
+   */
+  public static boolean isUNCPath (@Nonnull final File aFile)
+  {
+    final String sPath = aFile.getAbsolutePath ();
+    return isUNCPath (sPath);
+  }
+
+  /**
+   * Check if the passed file is an UNC path. UNC paths are identified by
+   * starting with "//" or "\\".
+   *
+   * @param sFilename
+   *        The absolute filename to be checked. May not be <code>null</code>.
+   * @return <code>true</code> if the file points to an UNC path,
+   *         <code>false</code> if not.
+   * @see #isUNCPath(File)
+   */
+  public static boolean isUNCPath (@Nonnull final String sFilename)
+  {
+    return sFilename.startsWith (WINDOWS_UNC_PREFIX) || sFilename.startsWith (UNIX_UNC_PREFIX);
+  }
+
+  /**
+   * Check if the passed file is a Windows local UNC path. This type is
+   * identified by starting with "\\?\" or "\\.\".
+   *
+   * @param aFile
+   *        The file to be checked. May not be <code>null</code>.
+   * @return <code>true</code> if the file points to an UNC path,
+   *         <code>false</code> if not.
+   * @see #isWindowsLocalUNCPath(String)
+   */
+  public static boolean isWindowsLocalUNCPath (@Nonnull final File aFile)
+  {
+    final String sPath = aFile.getAbsolutePath ();
+    return isWindowsLocalUNCPath (sPath);
+  }
+
+  /**
+   * Check if the passed file is a Windows local UNC path. This type is
+   * identified by starting with "\\?\" or "\\.\".
+   *
+   * @param sFilename
+   *        The absolute filename to be checked. May not be <code>null</code>.
+   * @return <code>true</code> if the file points to a Windows local UNC path,
+   *         <code>false</code> if not.
+   * @see #isWindowsLocalUNCPath(File)
+   */
+  public static boolean isWindowsLocalUNCPath (@Nonnull final String sFilename)
+  {
+    return sFilename.startsWith (WINDOWS_UNC_PREFIX_LOCAL1) || sFilename.startsWith (WINDOWS_UNC_PREFIX_LOCAL2);
+  }
+
+  /**
+   * Ensure that the passed path starts with a directory separator character. If
+   * the passed path starts with either {@value #WINDOWS_SEPARATOR} or
+   * {@value #UNIX_SEPARATOR} no changes are performed.
+   *
+   * @param sPath
+   *        The path to be checked.
+   * @return The path that is ensured to start with the directory separator of
+   *         the current operating system.
+   * @see #startsWithPathSeparatorChar(CharSequence)
+   */
+  @Nullable
+  @CheckReturnValue
+  public static String ensurePathStartingWithSeparator (@Nullable final String sPath)
+  {
+    if (sPath == null)
+      return null;
+    return startsWithPathSeparatorChar (sPath) ? sPath : File.separator + sPath;
+  }
+
+  /**
+   * Ensure that the passed path does NOT end with a directory separator
+   * character. Any number of trailing {@value #WINDOWS_SEPARATOR} or
+   * {@value #UNIX_SEPARATOR} are removed.
+   *
+   * @param sPath
+   *        The path to be checked.
+   * @return The path that is ensured to NOT end with the directory separator.
+   * @see #endsWithPathSeparatorChar(CharSequence)
+   */
+  @Nullable
+  @CheckReturnValue
+  public static String ensurePathEndingWithoutSeparator (@Nullable final String sPath)
+  {
+    if (sPath == null)
+      return null;
+
+    String sRet = sPath;
+    while (endsWithPathSeparatorChar (sRet))
+      sRet = sRet.substring (0, sRet.length () - 1);
+    return sRet;
+  }
+
+  /**
+   * Ensure that the passed path ends with a directory separator character. If
+   * the passed path ends with either {@value #WINDOWS_SEPARATOR} or
+   * {@value #UNIX_SEPARATOR} no changes are performed.
+   *
+   * @param sPath
+   *        The path to be checked.
+   * @return The path that is ensured to end with the directory separator of the
+   *         current operating system.
+   * @see #endsWithPathSeparatorChar(CharSequence)
+   */
+  @Nullable
+  @CheckReturnValue
+  public static String ensurePathEndingWithSeparator (@Nullable final String sPath)
+  {
+    if (sPath == null)
+      return null;
+    return endsWithPathSeparatorChar (sPath) ? sPath : sPath + File.separator;
+  }
+
+  /**
+   * Check if the passed filename is a Unix hidden filename.
+   *
+   * @param aFile
+   *        The file to check. May be <code>null</code>.
+   * @return <code>true</code> if the file is not <code>null</code> and the name
+   *         starts with a dot.
+   * @see #isHiddenFilename(String)
+   */
+  public static boolean isHiddenFilename (@Nullable final File aFile)
+  {
+    return aFile != null && isHiddenFilename (aFile.getName ());
+  }
+
+  /**
+   * Check if the passed filename is a Unix hidden filename.
+   *
+   * @param sFilename
+   *        The filename to check. May be <code>null</code>.
+   * @return <code>true</code> if the filename is neither <code>null</code> nor
+   *         empty and starts with a dot.
+   * @see #isHiddenFilename(File)
+   */
+  public static boolean isHiddenFilename (@Nullable final String sFilename)
+  {
+    return JCStringHelper.hasText (sFilename) && sFilename.charAt (0) == HIDDEN_FILE_PREFIX;
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java b/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
index f5aba021..1caf956e 100644
--- a/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
+++ b/src/main/java/com/helger/jcodemodel/util/JCStringHelper.java
@@ -50,9 +50,47 @@ public final class JCStringHelper
   /** Constant empty String array */
   public static final String [] EMPTY_STRING_ARRAY = new String [0];
 
+  /**
+   * The constant to be returned if an String.indexOf call did not find a match!
+   */
+  public static final int STRING_NOT_FOUND = -1;
+
+  /**
+   * Represents an illegal character (\0).
+   */
+  public static final char ILLEGAL_CHAR = '\0';
+
   private JCStringHelper ()
   {}
 
+  /**
+   * Get the length of the passed character sequence.
+   *
+   * @param aCS
+   *        The character sequence who's length is to be determined. May be
+   *        <code>null</code>.
+   * @return 0 if the parameter is <code>null</code>, its length otherwise.
+   * @see CharSequence#length()
+   */
+  @Nonnegative
+  public static int getLength (@Nullable final CharSequence aCS)
+  {
+    return aCS == null ? 0 : aCS.length ();
+  }
+
+  /**
+   * Check if the string contains any char.
+   *
+   * @param aCS
+   *        The character sequence to check. May be <code>null</code>.
+   * @return <code>true</code> if the string contains at least one,
+   *         <code>false</code> otherwise
+   */
+  public static boolean hasText (@Nullable final CharSequence aCS)
+  {
+    return aCS != null && aCS.length () > 0;
+  }
+
   /**
    * Check if the string is <code>null</code> or empty.
    *
@@ -159,4 +197,88 @@ public final class JCStringHelper
       throw new IllegalStateException ("Added " + nItemsAdded + " but expected " + ret.length);
     return ret;
   }
+
+  /**
+   * This is a fast replacement for {@link String#replace(char, char)} for
+   * characters. The problem with the mentioned String method is, that is uses
+   * internally regular expressions which use a synchronized block to compile
+   * the patterns. This method is inherently thread safe since {@link String} is
+   * immutable and we're operating on different temporary {@link StringBuilder}
+   * objects.
+   *
+   * @param sInputString
+   *        The input string where the text should be replace. If this parameter
+   *        is <code>null</code> or empty, no replacement is done.
+   * @param cSearchChar
+   *        The character to be replaced.
+   * @param cReplacementChar
+   *        The character with the replacement.
+   * @return The input string as is, if the input string is empty or if the
+   *         search pattern and the replacement are equal or if the string to be
+   *         replaced is not contained.
+   */
+  @Nullable
+  public static String replaceAll (@Nullable final String sInputString,
+                                   final char cSearchChar,
+                                   final char cReplacementChar)
+  {
+    // Is input string empty?
+    if (hasNoText (sInputString))
+      return sInputString;
+
+    // Replace old with the same new?
+    if (cSearchChar == cReplacementChar)
+      return sInputString;
+
+    // Does the old text occur anywhere?
+    int nIndex = sInputString.indexOf (cSearchChar, 0);
+    if (nIndex == STRING_NOT_FOUND)
+      return sInputString;
+
+    // build output buffer
+    final StringBuilder ret = new StringBuilder (sInputString.length ());
+    int nOldIndex = 0;
+    do
+    {
+      ret.append (sInputString, nOldIndex, nIndex).append (cReplacementChar);
+      nIndex++;
+      nOldIndex = nIndex;
+      nIndex = sInputString.indexOf (cSearchChar, nIndex);
+    } while (nIndex != STRING_NOT_FOUND);
+    ret.append (sInputString, nOldIndex, sInputString.length ());
+    return ret.toString ();
+  }
+
+  /**
+   * Get the first character of the passed character sequence
+   *
+   * @param aCS
+   *        The source character sequence
+   * @return {@link #ILLEGAL_CHAR} if the passed sequence was empty
+   */
+  public static char getFirstChar (@Nullable final CharSequence aCS)
+  {
+    return hasText (aCS) ? aCS.charAt (0) : ILLEGAL_CHAR;
+  }
+
+  /**
+   * Get the last character of the passed character sequence
+   *
+   * @param aCS
+   *        The source character sequence
+   * @return {@link #ILLEGAL_CHAR} if the passed sequence was empty
+   */
+  public static char getLastChar (@Nullable final CharSequence aCS)
+  {
+    final int nLength = getLength (aCS);
+    return nLength > 0 ? aCS.charAt (nLength - 1) : ILLEGAL_CHAR;
+  }
+
+  public static boolean endsWithAny (@Nullable final CharSequence aCS, @Nullable final char [] aChars)
+  {
+    if (hasText (aCS) && aChars != null)
+      if (JCArrayHelper.contains (aChars, getLastChar (aCS)))
+        return true;
+    return false;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/writer/AbstractCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/AbstractCodeWriter.java
index 71b4764b..cc909e81 100644
--- a/src/main/java/com/helger/jcodemodel/writer/AbstractCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/AbstractCodeWriter.java
@@ -96,6 +96,34 @@ public abstract class AbstractCodeWriter implements Closeable
     return m_sNewLine;
   }
 
+  /**
+   * Called by CodeModel to store the specified file. The callee must allocate a
+   * storage to store the specified file.<br>
+   * The returned stream will be closed before the next file is stored. So the
+   * callee can assume that only one OutputStream is active at any given time.
+   *
+   * @param sDirName
+   *        The directory name, relative to the target directory. May not be
+   *        <code>null</code> but maybe empty.
+   * @param sFilename
+   *        File name without the path. Something like "Foo.java" or
+   *        "Bar.properties"
+   * @return OutputStream to write to
+   * @throws IOException
+   *         On IO error
+   * @since v3.3.1
+   */
+  @Nonnull
+  public abstract OutputStream openBinary (@Nonnull String sDirName, @Nonnull String sFilename) throws IOException;
+
+  @Nonnull
+  protected static String toDirName (@Nonnull final JPackage aPackage)
+  {
+    // Convert package name to directory name
+    // Forward slash works for Windows, Linux and ZIP files
+    return aPackage.isUnnamed () ? "" : aPackage.name ().replace ('.', '/');
+  }
+
   /**
    * Called by CodeModel to store the specified file. The callee must allocate a
    * storage to store the specified file. <br>
@@ -112,7 +140,11 @@ public abstract class AbstractCodeWriter implements Closeable
    *         On IO error
    */
   @Nonnull
-  public abstract OutputStream openBinary (@Nonnull JPackage aPackage, @Nonnull String sFilename) throws IOException;
+  public final OutputStream openBinary (@Nonnull final JPackage aPackage,
+                                        @Nonnull final String sFilename) throws IOException
+  {
+    return openBinary (toDirName (aPackage), sFilename);
+  }
 
   /**
    * Called by CodeModel to store the specified file. The callee must allocate a
diff --git a/src/main/java/com/helger/jcodemodel/writer/FileCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/FileCodeWriter.java
index 0934eb08..bf645f3f 100644
--- a/src/main/java/com/helger/jcodemodel/writer/FileCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/FileCodeWriter.java
@@ -51,7 +51,7 @@ import java.util.Set;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
-import com.helger.jcodemodel.JPackage;
+import com.helger.jcodemodel.util.JCStringHelper;
 
 /**
  * Writes all the source files under the specified file folder.
@@ -115,34 +115,34 @@ public class FileCodeWriter extends AbstractCodeWriter
 
   @Override
   @Nonnull
-  public OutputStream openBinary (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    return new FileOutputStream (getFile (pkg, fileName));
+    return new FileOutputStream (getFile (sDirName, sFilename));
   }
 
   @Nonnull
-  protected File getFile (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  protected File getFile (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    File dir;
-    if (pkg.isUnnamed ())
-      dir = m_aTargetDir;
+    final File aDir;
+    if (JCStringHelper.hasNoText (sDirName))
+      aDir = m_aTargetDir;
     else
-      dir = new File (m_aTargetDir, _toDirName (pkg));
+      aDir = new File (m_aTargetDir, sDirName);
 
-    if (!dir.exists ())
-      if (!dir.mkdirs ())
-        throw new IOException (dir + ": failed to create directory");
+    if (!aDir.exists ())
+      if (!aDir.mkdirs ())
+        throw new IOException (aDir + ": failed to create directory");
 
-    final File fn = new File (dir, fileName);
-    if (fn.exists ())
+    final File aFile = new File (aDir, sFilename);
+    if (aFile.exists ())
     {
-      if (!fn.delete ())
-        throw new IOException (fn + ": Can't delete previous version");
+      if (!aFile.delete ())
+        throw new IOException (aFile + ": Can't delete previous version");
     }
 
     if (m_bMarkReadOnly)
-      m_aReadOnlyFiles.add (fn);
-    return fn;
+      m_aReadOnlyFiles.add (aFile);
+    return aFile;
   }
 
   @Override
@@ -153,11 +153,4 @@ public class FileCodeWriter extends AbstractCodeWriter
       if (!f.setReadOnly ())
         throw new IOException (f + ": Can't make file read-only");
   }
-
-  /** Converts a package name to the directory name. */
-  @Nonnull
-  private static String _toDirName (@Nonnull final JPackage aPkg)
-  {
-    return aPkg.name ().replace ('.', File.separatorChar);
-  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/writer/FilterCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/FilterCodeWriter.java
index 86505d34..01626bff 100644
--- a/src/main/java/com/helger/jcodemodel/writer/FilterCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/FilterCodeWriter.java
@@ -65,21 +65,21 @@ public class FilterCodeWriter extends AbstractCodeWriter
   }
 
   @Nonnull
-  protected AbstractCodeWriter core ()
+  protected final AbstractCodeWriter core ()
   {
     return m_aCore;
   }
 
   @Override
-  public OutputStream openBinary (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    return m_aCore.openBinary (pkg, fileName);
+    return m_aCore.openBinary (sDirName, sFilename);
   }
 
   @Override
-  public SourcePrintWriter openSource (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public SourcePrintWriter openSource (@Nonnull final JPackage aPkg, @Nonnull final String sFilename) throws IOException
   {
-    return m_aCore.openSource (pkg, fileName);
+    return m_aCore.openSource (aPkg, sFilename);
   }
 
   @Override
diff --git a/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java b/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
index 97adde00..db066a3c 100644
--- a/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
@@ -58,6 +58,7 @@ import com.helger.jcodemodel.JCodeModel;
 import com.helger.jcodemodel.JDefinedClass;
 import com.helger.jcodemodel.JDocComment;
 import com.helger.jcodemodel.JPackage;
+import com.helger.jcodemodel.JResourceDir;
 import com.helger.jcodemodel.SourcePrintWriter;
 import com.helger.jcodemodel.fmt.AbstractJResourceFile;
 import com.helger.jcodemodel.util.JCValueEnforcer;
@@ -286,6 +287,11 @@ public class JCMWriter
       final List <JPackage> aPackages = m_aCM.getAllPackages ();
       for (final JPackage aPackage : aPackages)
         buildPackage (aSourceWriter, aResourceWriter, aPackage);
+
+      // Write resources only
+      final List <JResourceDir> aResourceDirs = m_aCM.getAllResourceDirs ();
+      for (final JResourceDir aResourceDir : aResourceDirs)
+        buildResourceDir (aResourceWriter, aResourceDir);
     }
     finally
     {
@@ -306,6 +312,7 @@ public class JCMWriter
     return ret;
   }
 
+  @SuppressWarnings ("deprecation")
   public void buildPackage (@Nonnull final AbstractCodeWriter aSrcWriter,
                             @Nonnull final AbstractCodeWriter aResWriter,
                             @Nonnull final JPackage aPackage) throws IOException
@@ -354,4 +361,18 @@ public class JCMWriter
       }
     }
   }
+
+  public void buildResourceDir (@Nonnull final AbstractCodeWriter aResWriter,
+                                @Nonnull final JResourceDir aResourceDir) throws IOException
+  {
+    // write resources
+    for (final AbstractJResourceFile rsrc : aResourceDir.getAllResourceFiles ())
+    {
+      try (final OutputStream os = aResWriter.openBinary (aResourceDir.name (), rsrc.name ());
+           final OutputStream bos = new BufferedOutputStream (os))
+      {
+        rsrc.build (bos);
+      }
+    }
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/writer/OutputStreamCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/OutputStreamCodeWriter.java
index 82183dbb..607b64ca 100644
--- a/src/main/java/com/helger/jcodemodel/writer/OutputStreamCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/OutputStreamCodeWriter.java
@@ -58,8 +58,6 @@ import java.nio.charset.Charset;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
-import com.helger.jcodemodel.JPackage;
-
 public class OutputStreamCodeWriter extends AbstractCodeWriter
 {
   private final PrintStream m_aPS;
@@ -99,7 +97,7 @@ public class OutputStreamCodeWriter extends AbstractCodeWriter
   }
 
   @Override
-  public OutputStream openBinary (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
     return new FilterOutputStream (m_aPS)
     {
diff --git a/src/main/java/com/helger/jcodemodel/writer/ProgressCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/ProgressCodeWriter.java
index 64f90345..a1140fbf 100644
--- a/src/main/java/com/helger/jcodemodel/writer/ProgressCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/ProgressCodeWriter.java
@@ -40,7 +40,6 @@
  */
 package com.helger.jcodemodel.writer;
 
-import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Serializable;
@@ -49,6 +48,7 @@ import javax.annotation.Nonnull;
 
 import com.helger.jcodemodel.JPackage;
 import com.helger.jcodemodel.SourcePrintWriter;
+import com.helger.jcodemodel.util.JCStringHelper;
 import com.helger.jcodemodel.util.JCValueEnforcer;
 
 /**
@@ -74,26 +74,26 @@ public class ProgressCodeWriter extends FilterCodeWriter
     m_aPT = progress;
   }
 
-  protected void report (@Nonnull final JPackage aPackage, @Nonnull final String sFilename)
+  protected void report (@Nonnull final String sDirName, @Nonnull final String sFilename)
   {
-    if (aPackage.isUnnamed ())
+    if (JCStringHelper.hasNoText (sDirName))
       m_aPT.println (sFilename);
     else
-      m_aPT.println (aPackage.name ().replace ('.', File.separatorChar) + File.separatorChar + sFilename);
+      m_aPT.println (sDirName + '/' + sFilename);
   }
 
   @Override
-  public OutputStream openBinary (@Nonnull final JPackage aPackage, @Nonnull final String sFilename) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    report (aPackage, sFilename);
-    return super.openBinary (aPackage, sFilename);
+    report (sDirName, sFilename);
+    return super.openBinary (sDirName, sFilename);
   }
 
   @Override
   public SourcePrintWriter openSource (@Nonnull final JPackage aPackage,
                                        @Nonnull final String sFilename) throws IOException
   {
-    report (aPackage, sFilename);
+    report (toDirName (aPackage), sFilename);
     return super.openSource (aPackage, sFilename);
   }
 }
diff --git a/src/main/java/com/helger/jcodemodel/writer/PrologCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/PrologCodeWriter.java
index 8a231a81..52aa1d9e 100644
--- a/src/main/java/com/helger/jcodemodel/writer/PrologCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/PrologCodeWriter.java
@@ -77,9 +77,9 @@ public class PrologCodeWriter extends FilterCodeWriter
   }
 
   @Override
-  public SourcePrintWriter openSource (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public SourcePrintWriter openSource (@Nonnull final JPackage pkg, @Nonnull final String sFilename) throws IOException
   {
-    final SourcePrintWriter w = super.openSource (pkg, fileName);
+    final SourcePrintWriter w = super.openSource (pkg, sFilename);
 
     // write prolog if this is a java source file
     if (m_sProlog != null)
diff --git a/src/main/java/com/helger/jcodemodel/writer/SingleStreamCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/SingleStreamCodeWriter.java
index 921a1473..003acc03 100644
--- a/src/main/java/com/helger/jcodemodel/writer/SingleStreamCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/SingleStreamCodeWriter.java
@@ -47,8 +47,6 @@ import java.io.PrintStream;
 
 import javax.annotation.Nonnull;
 
-import com.helger.jcodemodel.JPackage;
-
 /**
  * Output all source files into a single stream with a little formatting header
  * in front of each file. This is primarily for human consumption of the
@@ -88,11 +86,11 @@ public class SingleStreamCodeWriter extends AbstractCodeWriter
   }
 
   @Override
-  public OutputStream openBinary (@Nonnull final JPackage aPkg, @Nonnull final String sFilename) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    String sPkgName = aPkg.name ();
+    String sPkgName = sDirName;
     if (sPkgName.length () > 0)
-      sPkgName += '.';
+      sPkgName += '/';
 
     m_aPS.println ("-----------------------------------" +
                    sPkgName +
diff --git a/src/main/java/com/helger/jcodemodel/writer/ZipCodeWriter.java b/src/main/java/com/helger/jcodemodel/writer/ZipCodeWriter.java
index 8447b9bf..58c5f1a9 100644
--- a/src/main/java/com/helger/jcodemodel/writer/ZipCodeWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/ZipCodeWriter.java
@@ -48,7 +48,7 @@ import java.util.zip.ZipOutputStream;
 
 import javax.annotation.Nonnull;
 
-import com.helger.jcodemodel.JPackage;
+import com.helger.jcodemodel.util.JCStringHelper;
 
 /**
  * Writes all the files into a zip file.
@@ -91,22 +91,18 @@ public class ZipCodeWriter extends AbstractCodeWriter
   }
 
   @Override
-  public OutputStream openBinary (@Nonnull final JPackage pkg, @Nonnull final String fileName) throws IOException
+  public OutputStream openBinary (@Nonnull final String sDirName, @Nonnull final String sFilename) throws IOException
   {
-    String name = fileName;
-    if (!pkg.isUnnamed ())
-      name = _toDirName (pkg) + name;
+    final String sFullName;
+    if (JCStringHelper.hasText (sDirName))
+      sFullName = sDirName + '/' + sFilename;
+    else
+      sFullName = sFilename;
 
-    m_aZOS.putNextEntry (new ZipEntry (name));
+    m_aZOS.putNextEntry (new ZipEntry (sFullName));
     return m_aFOS;
   }
 
-  /** Converts a package name to the directory name. */
-  private static String _toDirName (@Nonnull final JPackage pkg)
-  {
-    return pkg.name ().replace ('.', '/') + '/';
-  }
-
   @Override
   public void close () throws IOException
   {
diff --git a/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java
index c19268f4..3ed4617c 100644
--- a/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java
+++ b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue61FuncTest.java
@@ -45,6 +45,7 @@ import static org.junit.Assert.assertTrue;
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 
 import org.junit.Test;
 
@@ -64,11 +65,12 @@ public class Issue61FuncTest
   public void testIssue () throws Exception
   {
     final JCodeModel cm = new JCodeModel ();
-    final Charset ascii = Charset.forName ("US-ASCII");
-    final ByteArrayOutputStream resOut = new ByteArrayOutputStream ();
-    final JTextFile res = (JTextFile) cm.rootPackage ().addResourceFile (new JTextFile ("example.txt", ascii));
+    final Charset ascii = StandardCharsets.US_ASCII;
+    final JTextFile res = cm.rootResourceDir ().addResourceFile (new JTextFile ("example.txt", ascii));
 
     res.setContents ("Testing");
+
+    final ByteArrayOutputStream resOut = new ByteArrayOutputStream ();
     new JCMWriter (cm).build (new SingleStreamCodeWriter (new ByteArrayOutputStream ()),
                               new SingleStreamCodeWriter (resOut));
     final String txtRes = ascii.decode (ByteBuffer.wrap (resOut.toByteArray ())).toString ();
diff --git a/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue74FuncTest.java b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue74FuncTest.java
new file mode 100644
index 00000000..0c17874b
--- /dev/null
+++ b/src/test/java/com/helger/jcodemodel/supplementary/issues/Issue74FuncTest.java
@@ -0,0 +1,75 @@
+/**
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
+ * Portions Copyright 2013-2020 Philip Helger + contributors
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License.  You can
+ * obtain a copy of the License at
+ * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
+ * or packager/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at packager/legal/LICENSE.txt.
+ *
+ * GPL Classpath Exception:
+ * Oracle designates this particular file as subject to the "Classpath"
+ * exception as provided by Oracle in the GPL Version 2 section of the License
+ * file that accompanied this code.
+ *
+ * Modifications:
+ * If applicable, add the following below the License Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * "Portions Copyright [year] [name of copyright owner]"
+ *
+ * Contributor(s):
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+package com.helger.jcodemodel.supplementary.issues;
+
+import java.nio.charset.StandardCharsets;
+
+import org.junit.Test;
+
+import com.helger.jcodemodel.JCodeModel;
+import com.helger.jcodemodel.fmt.JTextFile;
+import com.helger.jcodemodel.writer.JCMWriter;
+import com.helger.jcodemodel.writer.SingleStreamCodeWriter;
+
+/**
+ * Test for https://github.com/phax/jcodemodel/issues/74
+ *
+ * @author Philip Helger
+ */
+public final class Issue74FuncTest
+{
+  @Test
+  public void testIssue () throws Exception
+  {
+    final JCodeModel cm = new JCodeModel ();
+    cm.resourceDir ("META-INF/services/")
+      .addResourceFile (new JTextFile ("Interface1", StandardCharsets.UTF_8))
+      .setContents ("Testing\n");
+    cm.resourceDir ("META-INF/services/")
+      .addResourceFile (new JTextFile ("Interface2", StandardCharsets.UTF_8))
+      .setContents ("Testing again\n");
+    cm.resourceDir ("META-INF/services/another/and/so/on/and/so/forth")
+      .addResourceFile (new JTextFile ("Interface3", StandardCharsets.UTF_8))
+      .setContents ("Testing 3\n");
+
+    new JCMWriter (cm).build (new SingleStreamCodeWriter (System.out), new SingleStreamCodeWriter (System.out));
+  }
+}
diff --git a/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java b/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
index a596319a..8daf58c9 100644
--- a/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
+++ b/src/test/java/com/helger/jcodemodel/util/CodeModelTestsHelper.java
@@ -71,7 +71,6 @@ import com.helger.jcodemodel.IJFormatter;
 import com.helger.jcodemodel.IJGenerable;
 import com.helger.jcodemodel.IJStatement;
 import com.helger.jcodemodel.JCodeModel;
-import com.helger.jcodemodel.JPackage;
 import com.helger.jcodemodel.SourcePrintWriter;
 import com.helger.jcodemodel.writer.AbstractCodeWriter;
 import com.helger.jcodemodel.writer.JCMWriter;
@@ -225,14 +224,14 @@ public final class CodeModelTestsHelper
 
   @Nonnull
   private static CompilationUnit _parseWithJavaParser (final byte [] aBytes,
-                                                       final JPackage aPackage,
+                                                       @Nonnull final String sDirName,
                                                        final String sFilename) throws IOException
   {
     if (false)
       System.out.println (new String (aBytes, DEFAULT_ENCODING));
 
     System.out.println ("Parsing " +
-                        (aPackage == null || aPackage.isUnnamed () ? "" : aPackage.name () + ".") +
+                        JCStringHelper.replaceAll (sDirName, '/', '.') +
                         (sFilename.endsWith (".java") ? sFilename.substring (0, sFilename.length () - 5) : sFilename));
 
     try (final ByteArrayInputStream bis = new ByteArrayInputStream (aBytes))
@@ -246,7 +245,7 @@ public final class CodeModelTestsHelper
   @Nonnull
   private static org.eclipse.jdt.core.dom.CompilationUnit _parseWithJDT (final String sUnitName, final char [] aCode)
   {
-    final ASTParser parser = ASTParser.newParser (AST.JLS11);
+    final ASTParser parser = ASTParser.newParser (AST.JLS13);
     parser.setResolveBindings (true);
     parser.setStatementsRecovery (true);
     parser.setBindingsRecovery (true);
@@ -276,7 +275,7 @@ public final class CodeModelTestsHelper
       new JCMWriter (cm).build (new AbstractCodeWriter (DEFAULT_ENCODING, "\n")
       {
         @Override
-        public OutputStream openBinary (final JPackage aPackage, final String sFilename) throws IOException
+        public OutputStream openBinary (final String sDirName, final String sFilename) throws IOException
         {
           return new ByteArrayOutputStream ()
           {
@@ -288,7 +287,7 @@ public final class CodeModelTestsHelper
               final byte [] aBytes = toByteArray ();
 
               // Get result as bytes and parse
-              _parseWithJavaParser (aBytes, aPackage, sFilename);
+              _parseWithJavaParser (aBytes, sDirName, sFilename);
               _parseWithJDT (sFilename, new String (aBytes, DEFAULT_ENCODING).toCharArray ());
             }
           };
