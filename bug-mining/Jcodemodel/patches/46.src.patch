diff --git a/README.md b/README.md
index 9684aaca..d9ce6546 100644
--- a/README.md
+++ b/README.md
@@ -16,6 +16,7 @@ A site with the links to the [API docs](http://phax.github.io/jcodemodel/) etc.
 
 * v3.3.0 - work in progress
     * Added check for package names so that no invalid package names can be created ([issue #70](https://github.com/phax/jcodemodel/issues/70) from @guiguilechat)
+    * Added check to avoid creating classes existing in the "java.lang" package ([issue #71](https://github.com/phax/jcodemodel/issues/71) from @guiguilechat)
 * v3.2.4 - 2019-07-15
     * Made class `JavaUnicodeEscapeWriter` publicly accessible
     * Extended enum constant ref APU ([issue #68](https://github.com/phax/jcodemodel/issues/68) from @guiguilechat)
diff --git a/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java b/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
index dbe5effc..d97261ee 100644
--- a/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/JCMWriter.java
@@ -64,7 +64,7 @@ import com.helger.jcodemodel.util.JCValueEnforcer;
 import com.helger.jcodemodel.writer.ProgressCodeWriter.IProgressTracker;
 
 /**
- * Java Code Model Builder
+ * Java Code Model Writer
  *
  * @author Philip Helger
  * @since 3.2.0
@@ -347,9 +347,10 @@ public class JCMWriter
     for (final AbstractJResourceFile rsrc : aPackage.getAllResourceFiles ())
     {
       final AbstractCodeWriter cw = rsrc.isResource () ? aResWriter : aSrcWriter;
-      try (final OutputStream os = new BufferedOutputStream (cw.openBinary (aPackage, rsrc.name ())))
+      try (final OutputStream os = cw.openBinary (aPackage, rsrc.name ());
+           final OutputStream bos = new BufferedOutputStream (os))
       {
-        rsrc.build (os);
+        rsrc.build (bos);
       }
     }
   }
diff --git a/src/main/java/com/helger/jcodemodel/writer/JFormatter.java b/src/main/java/com/helger/jcodemodel/writer/JFormatter.java
index 9eac9b66..f29e26b6 100644
--- a/src/main/java/com/helger/jcodemodel/writer/JFormatter.java
+++ b/src/main/java/com/helger/jcodemodel/writer/JFormatter.java
@@ -43,7 +43,6 @@ package com.helger.jcodemodel.writer;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -234,6 +233,39 @@ public class JFormatter implements IJFormatter
     FIND_ERROR_TYPES
   }
 
+  private static final Map <String, Boolean> RESERVERD_JAVA_LANG_NAME = new HashMap <> ();
+
+  /**
+   * check if a name already represents a class in the "java.lang" package. e.g.
+   * "String" should return <code>true</code>, but "blub" should return
+   * <code>false</code>. See https://github.com/phax/jcodemodel/issues/71
+   *
+   * @param sSimpleClassName
+   *        simple class name to test (without the package).
+   * @return the existence of such a class in the java.lang (cached)
+   */
+  static boolean isJavaLangClass (final String sSimpleClassName)
+  {
+    if (sSimpleClassName == null)
+      return false;
+
+    final Boolean ret = RESERVERD_JAVA_LANG_NAME.get (sSimpleClassName);
+    if (ret != null)
+      return ret.booleanValue ();
+
+    boolean bIsJavaLang = true;
+    try
+    {
+      Class.forName ("java.lang." + sSimpleClassName);
+    }
+    catch (final Exception ex)
+    {
+      bIsJavaLang = false;
+    }
+    RESERVERD_JAVA_LANG_NAME.put (sSimpleClassName, Boolean.valueOf (bIsJavaLang));
+    return bIsJavaLang;
+  }
+
   private final class ImportedClasses
   {
     private final Set <AbstractJClass> m_aDontImportClasses = new HashSet <> ();
@@ -285,6 +317,15 @@ public class JFormatter implements IJFormatter
         return false;
       }
 
+      if (isJavaLangClass (aRealClass.name ()))
+      {
+        if (m_bDebugImport)
+          System.out.println ("A class with local name '" +
+                              aRealClass.name () +
+                              "' exists in package 'java.lang' and is therefore not imported.");
+        return false;
+      }
+
       if (!m_aClasses.add (aRealClass))
       {
         if (m_bDebugImport)
@@ -315,7 +356,7 @@ public class JFormatter implements IJFormatter
     {
       // Copy and sort
       final List <AbstractJClass> aImports = new ArrayList <> (m_aClasses);
-      Collections.sort (aImports, ClassNameComparator.getInstance ());
+      aImports.sort (ClassNameComparator.getInstance ());
       return aImports;
     }
   }
diff --git a/src/test/java/com/helger/jcodemodel/JCodeModelTest.java b/src/test/java/com/helger/jcodemodel/JCodeModelTest.java
index 845d68e9..fe4ae953 100644
--- a/src/test/java/com/helger/jcodemodel/JCodeModelTest.java
+++ b/src/test/java/com/helger/jcodemodel/JCodeModelTest.java
@@ -103,4 +103,18 @@ public final class JCodeModelTest
     jClass.field (JMod.PRIVATE, cm.ref (Map.class).narrow (String.class), "strMap", JExpr._new (hashMap));
     CodeModelTestsHelper.parseCodeModel (cm);
   }
+
+  @Test
+  public void testIssue71 () throws Exception
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass aOtherByteClass = cm._package ("com.helger.issue71")._class ("Byte");
+    final JDefinedClass aFooClass = cm._package ("com.helger.issue71")._class ("Foo");
+    final JDefinedClass aClass2 = cm._package ("com.helger.issue71.second")._class ("Class2");
+    // The reference in the second class may not be imported:
+    aClass2.method (JMod.PUBLIC, aOtherByteClass, "testByte").body ()._return (JExpr._null ());
+    // Whereas the Foo class may be imported
+    aClass2.method (JMod.PUBLIC, aFooClass, "testFoo").body ()._return (JExpr._null ());
+    CodeModelTestsHelper.printCodeModel (cm);
+  }
 }
