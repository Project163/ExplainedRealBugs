diff --git a/src/main/java/com/helger/jcodemodel/AbstractJExpressionImpl.java b/src/main/java/com/helger/jcodemodel/AbstractJExpressionImpl.java
index 9425b234..6c37415c 100644
--- a/src/main/java/com/helger/jcodemodel/AbstractJExpressionImpl.java
+++ b/src/main/java/com/helger/jcodemodel/AbstractJExpressionImpl.java
@@ -40,6 +40,9 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+
 import javax.annotation.Nonnull;
 
 /**
@@ -47,6 +50,20 @@ import javax.annotation.Nonnull;
  */
 public abstract class AbstractJExpressionImpl implements IJExpression
 {
+
+  static boolean visitWithSubExpressions(ExpressionCallback callback,
+                                         ExpressionAccessor accessor)
+  {
+    IJExpression expression = accessor.get ();
+    if (!callback.visitExpression (expression, accessor))
+      return false;
+    return expression.forAllSubExpressions (callback);
+  }
+
+
+  private AbstractJType hintType;
+  private String hintName;
+
   protected AbstractJExpressionImpl ()
   {}
 
@@ -435,4 +452,48 @@ public abstract class AbstractJExpressionImpl implements IJExpression
   {
     return this;
   }
+
+  public final AbstractJType expressionType ()
+  {
+    if (hintType != null)
+      return hintType;
+    return derivedType ();
+  }
+
+  public final AbstractJExpressionImpl hintType(AbstractJType hintType)
+  {
+    this.hintType = hintType;
+    return this;
+  }
+
+  //TODO remove this default and implement for all subclasses!
+  AbstractJType derivedType()
+  {
+    return null;
+  }
+
+  public final String expressionName ()
+  {
+    if (hintName != null)
+      return hintName;
+    return derivedName ();
+  }
+
+  public final AbstractJExpressionImpl hintName(String hintName)
+  {
+    this.hintName = hintName;
+    return this;
+  }
+
+  //TODO remove this default and implement for all subclasses!
+  String derivedName()
+  {
+    return null;
+  }
+
+  //TODO remove this default and implement for all subclasses!
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    return true;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/IJExpression.java b/src/main/java/com/helger/jcodemodel/IJExpression.java
index d695d367..bf52551d 100644
--- a/src/main/java/com/helger/jcodemodel/IJExpression.java
+++ b/src/main/java/com/helger/jcodemodel/IJExpression.java
@@ -40,6 +40,8 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionContainer;
+
 import javax.annotation.Nonnull;
 
 /**
@@ -54,7 +56,7 @@ import javax.annotation.Nonnull;
  * parameters. For example, you can build "5+2" by
  * <tt>JExpr.lit(5).add(JExpr.lit(2))</tt>
  */
-public interface IJExpression extends IJGenerable
+public interface IJExpression extends IJGenerable, ExpressionContainer
 {
   /**
    * @return <code>-[this]" from "[this]</code>.
@@ -466,4 +468,8 @@ public interface IJExpression extends IJGenerable
    * subexpression elimination.
    */
   boolean equals (Object o);
+
+  String expressionName();
+
+  AbstractJType expressionType();
 }
diff --git a/src/main/java/com/helger/jcodemodel/JArray.java b/src/main/java/com/helger/jcodemodel/JArray.java
index 7cd572e6..0b044d34 100644
--- a/src/main/java/com/helger/jcodemodel/JArray.java
+++ b/src/main/java/com/helger/jcodemodel/JArray.java
@@ -40,6 +40,10 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.util.StringUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -55,8 +59,8 @@ import static com.helger.jcodemodel.util.HashCodeGenerator.getHashCode;
  */
 public class JArray extends AbstractJExpressionImpl
 {
-  private final AbstractJType _type;
-  private final IJExpression _size;
+  private AbstractJType _type;
+  private IJExpression _size;
   private List <IJExpression> _exprs;
 
   protected JArray (@Nonnull final AbstractJType type, @Nullable final IJExpression size)
@@ -166,4 +170,56 @@ public class JArray extends AbstractJExpressionImpl
   {
     return getHashCode (this, _type.fullName (), _size, _exprs);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    return _type.array ();
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return StringUtils.lower (_type.name ()) + "ArrayOfSize" +
+        _size.expressionName ();
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (_size != null)
+    {
+      if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+      {
+        public void set (IJExpression newExpression)
+        {
+          _size = newExpression;
+        }
+
+        public IJExpression get ()
+        {
+          return _size;
+        }
+      }))
+        return false;
+    }
+    for (int i = 0; i < (_exprs != null ? _exprs.size () : 0); i++)
+    {
+      IJExpression expr = _exprs.get (i);
+      final int finalI = i;
+      if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+          {
+            public void set (IJExpression newExpression)
+            {
+              _exprs.set (finalI, newExpression);
+            }
+
+            public IJExpression get ()
+            {
+              return _exprs.get (finalI);
+            }
+          }))
+        return false;
+    }
+    return true;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JArrayCompRef.java b/src/main/java/com/helger/jcodemodel/JArrayCompRef.java
index 8ad2175a..daf2f356 100644
--- a/src/main/java/com/helger/jcodemodel/JArrayCompRef.java
+++ b/src/main/java/com/helger/jcodemodel/JArrayCompRef.java
@@ -40,10 +40,15 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.util.StringUtils;
+
 import javax.annotation.Nonnull;
 
 import static com.helger.jcodemodel.util.EqualsUtils.isEqual;
 import static com.helger.jcodemodel.util.HashCodeGenerator.getHashCode;
+import static com.helger.jcodemodel.util.StringUtils.upper;
 
 /**
  * array component reference.
@@ -53,12 +58,12 @@ public class JArrayCompRef extends AbstractJExpressionAssignmentTargetImpl
   /**
    * JArray expression upon which this component will be accessed.
    */
-  private final IJExpression _array;
+  private IJExpression _array;
 
   /**
    * Integer expression representing index of the component
    */
-  private final IJExpression _index;
+  private IJExpression _index;
 
   /**
    * JArray component reference constructor given an array expression and index.
@@ -110,4 +115,46 @@ public class JArrayCompRef extends AbstractJExpressionAssignmentTargetImpl
   {
     return getHashCode (this, _array, _index);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    return _array.expressionType ().elementType ();
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return _array.expressionName () + "ElementAt" +
+        upper (_index.expressionName ());
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+    {
+      public void set (IJExpression newExpression)
+      {
+        _array = newExpression;
+      }
+
+      public IJExpression get ()
+      {
+        return _array;
+      }
+    }))
+      return false;
+    return visitWithSubExpressions (callback, new ExpressionAccessor ()
+    {
+      public void set (IJExpression newExpression)
+      {
+        _index = newExpression;
+      }
+
+      public IJExpression get ()
+      {
+        return _index;
+      }
+    });
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JAssignment.java b/src/main/java/com/helger/jcodemodel/JAssignment.java
index 4c8df6be..d391da9f 100644
--- a/src/main/java/com/helger/jcodemodel/JAssignment.java
+++ b/src/main/java/com/helger/jcodemodel/JAssignment.java
@@ -40,6 +40,9 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+
 import javax.annotation.Nonnull;
 
 import static com.helger.jcodemodel.util.EqualsUtils.isEqual;
@@ -51,7 +54,7 @@ import static com.helger.jcodemodel.util.HashCodeGenerator.getHashCode;
 public class JAssignment extends AbstractJExpressionImpl implements IJExpressionStatement
 {
   private final IJAssignmentTarget _lhs;
-  private final IJExpression _rhs;
+  private IJExpression _rhs;
   private final String _op;
 
   /**
@@ -135,4 +138,39 @@ public class JAssignment extends AbstractJExpressionImpl implements IJExpression
   {
     return getHashCode (this, _lhs, _rhs, _op);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    AbstractJType type = _lhs.expressionType ();
+    if (type != null)
+      return type;
+    return _rhs.expressionType ();
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return _lhs.expressionName () + "AssignedTo" + _rhs.expressionName ();
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (!_lhs.forAllSubExpressions (callback))
+      return false;
+    if (!callback.visitAssignmentTarget (_lhs))
+      return false;
+    return visitWithSubExpressions (callback, new ExpressionAccessor ()
+    {
+      public void set (IJExpression newExpression)
+      {
+        _rhs = newExpression;
+      }
+
+      public IJExpression get ()
+      {
+        return _rhs;
+      }
+    });
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JAtomInt.java b/src/main/java/com/helger/jcodemodel/JAtomInt.java
index c94ae9c8..e996eb2e 100644
--- a/src/main/java/com/helger/jcodemodel/JAtomInt.java
+++ b/src/main/java/com/helger/jcodemodel/JAtomInt.java
@@ -84,4 +84,10 @@ public class JAtomInt extends AbstractJExpressionImpl
   {
     return getHashCode (this, _what);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    return JPrimitiveType.INT;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JBlock.java b/src/main/java/com/helger/jcodemodel/JBlock.java
index ecd86de2..3ad84cbd 100644
--- a/src/main/java/com/helger/jcodemodel/JBlock.java
+++ b/src/main/java/com/helger/jcodemodel/JBlock.java
@@ -176,6 +176,12 @@ public class JBlock implements IJGenerable, IJStatement
     return decl (JMod.NONE, type, name, null);
   }
 
+  @Nonnull
+  public JVar decl (@Nonnull final String name, @Nonnull final IJExpression init)
+  {
+    return decl (JMod.NONE, init.expressionType (), name, init);
+  }
+
   /**
    * Adds a local variable declaration to this block
    * 
@@ -236,6 +242,16 @@ public class JBlock implements IJGenerable, IJStatement
     return v;
   }
 
+  public JBlock insertBefore(JVar var, Object before)
+  {
+    int i = _content.indexOf (before);
+    _content.add (i, var);
+    _pos++;
+    _bracesRequired = true;
+    _indentRequired = true;
+    return this;
+  }
+
   /**
    * Creates an assignment statement and adds it to this block.
    * 
diff --git a/src/main/java/com/helger/jcodemodel/JConditional.java b/src/main/java/com/helger/jcodemodel/JConditional.java
index 1b128898..f92efbe7 100644
--- a/src/main/java/com/helger/jcodemodel/JConditional.java
+++ b/src/main/java/com/helger/jcodemodel/JConditional.java
@@ -40,12 +40,18 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.BranchingStatement;
+import com.helger.jcodemodel.optimize.BranchingStatementVisitor;
+
 import javax.annotation.Nonnull;
 
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+
 /**
  * If statement, with optional else clause
  */
-public class JConditional implements IJStatement
+public class JConditional implements IJStatement, BranchingStatement
 {
   /**
    * JExpression to test to determine branching
@@ -138,4 +144,11 @@ public class JConditional implements IJStatement
       f.print ("else").generable (_else);
     f.newline ();
   }
+
+  public void apply (BranchingStatementVisitor visitor)
+  {
+    visitor.visit (_test);
+    visitor.visit (_else != null ? asList (_then, _else) :
+        singletonList (_then));
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JFieldRef.java b/src/main/java/com/helger/jcodemodel/JFieldRef.java
index f6cb4443..e83b9845 100644
--- a/src/main/java/com/helger/jcodemodel/JFieldRef.java
+++ b/src/main/java/com/helger/jcodemodel/JFieldRef.java
@@ -40,6 +40,10 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.util.StringUtils;
+
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
@@ -57,7 +61,7 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
    * Object expression upon which this field will be accessed, or null for the
    * implicit 'this'.
    */
-  private final IJGenerable _object;
+  private IJGenerable _object;
 
   /**
    * Name of the field to be accessed. Either this or {@link #_var} is set.
@@ -72,7 +76,7 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
   /**
    * Indicates if an explicit this should be generated
    */
-  private final boolean _explicitThis;
+  private boolean _explicitThis;
 
   /**
    * Field reference constructor given an object expression and field name.
@@ -167,6 +171,12 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
     return _explicitThis;
   }
 
+  public JFieldRef explicitThis (boolean explicitThis)
+  {
+    this._explicitThis = explicitThis;
+    return this;
+  }
+
   public void generate (@Nonnull final JFormatter f)
   {
     final String name = name ();
@@ -197,4 +207,48 @@ public class JFieldRef extends AbstractJExpressionAssignmentTargetImpl implement
   {
     return getHashCode (this, _object, name ());
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    if (_var != null)
+    {
+      return _var.type ();
+    }
+    return null;
+  }
+
+  @Override
+  String derivedName ()
+  {
+    if (_object instanceof IJExpression)
+    {
+      return ((IJExpression) _object).expressionName () +
+          StringUtils.upper (name ());
+    }
+    else
+    {
+      return name ();
+    }
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (_object instanceof IJExpression)
+    {
+      return visitWithSubExpressions (callback, new ExpressionAccessor ()
+      {
+        public void set (IJExpression newExpression)
+        {
+          _object = newExpression;
+        }
+
+        public IJExpression get ()
+        {
+          return (IJExpression) _object;
+        }
+      });
+    }
+    return true;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JForEach.java b/src/main/java/com/helger/jcodemodel/JForEach.java
index d4993b03..e35b614a 100644
--- a/src/main/java/com/helger/jcodemodel/JForEach.java
+++ b/src/main/java/com/helger/jcodemodel/JForEach.java
@@ -40,6 +40,11 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.optimize.ExpressionContainer;
+import com.helger.jcodemodel.optimize.Loop;
+
 import javax.annotation.Nonnull;
 
 /**
@@ -48,12 +53,12 @@ import javax.annotation.Nonnull;
  * 
  * @author Bhakti
  */
-public class JForEach implements IJStatement
+public class JForEach implements IJStatement, Loop
 {
   private final AbstractJType _type;
   private final String _var;
   private JBlock _body; // lazily created
-  private final IJExpression _collection;
+  private IJExpression _collection;
   private final JVar _loopVar;
 
   protected JForEach (@Nonnull final AbstractJType vartype,
@@ -87,6 +92,40 @@ public class JForEach implements IJStatement
     return _collection;
   }
 
+  public ExpressionContainer statementsExecutedOnce ()
+  {
+    return new ExpressionContainer ()
+    {
+      public boolean forAllSubExpressions (ExpressionCallback callback)
+      {
+        return AbstractJExpressionImpl.visitWithSubExpressions (callback,
+            new ExpressionAccessor ()
+        {
+          public void set (IJExpression newExpression)
+          {
+            _collection = newExpression;
+          }
+
+          public IJExpression get ()
+          {
+            return _collection;
+          }
+        });
+      }
+    };
+  }
+
+  public ExpressionContainer statementsExecutedOnEachIteration ()
+  {
+    return new ExpressionContainer ()
+    {
+      public boolean forAllSubExpressions (ExpressionCallback callback)
+      {
+        return callback.visitAssignmentTarget (_loopVar);
+      }
+    };
+  }
+
   @Nonnull
   public JBlock body ()
   {
diff --git a/src/main/java/com/helger/jcodemodel/JForLoop.java b/src/main/java/com/helger/jcodemodel/JForLoop.java
index 2ab8223f..beb76a3b 100644
--- a/src/main/java/com/helger/jcodemodel/JForLoop.java
+++ b/src/main/java/com/helger/jcodemodel/JForLoop.java
@@ -40,6 +40,11 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.optimize.ExpressionContainer;
+import com.helger.jcodemodel.optimize.Loop;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -50,7 +55,7 @@ import javax.annotation.Nullable;
 /**
  * For statement
  */
-public class JForLoop implements IJStatement
+public class JForLoop implements IJStatement, Loop
 {
   private final List <Object> _inits = new ArrayList <Object> ();
   private IJExpression _test;
@@ -112,6 +117,51 @@ public class JForLoop implements IJStatement
     return Collections.unmodifiableList (_updates);
   }
 
+  public ExpressionContainer statementsExecutedOnce ()
+  {
+    return new ExpressionContainer ()
+    {
+      public boolean forAllSubExpressions (ExpressionCallback callback)
+      {
+        for (Object init : _inits)
+        {
+          if (init instanceof IJExpression &&
+              !((IJExpression) init).forAllSubExpressions (callback))
+            return false;
+        }
+        return true;
+      }
+    };
+  }
+
+  public ExpressionContainer statementsExecutedOnEachIteration ()
+  {
+    return new ExpressionContainer ()
+    {
+      public boolean forAllSubExpressions (ExpressionCallback callback)
+      {
+        for (IJExpression update : _updates)
+        {
+          if (!update.forAllSubExpressions (callback))
+            return false;
+        }
+        return AbstractJExpressionImpl.visitWithSubExpressions (callback,
+            new ExpressionAccessor ()
+        {
+          public void set (IJExpression newExpression)
+          {
+            _test = newExpression;
+          }
+
+          public IJExpression get ()
+          {
+            return _test;
+          }
+        });
+      }
+    };
+  }
+
   @Nonnull
   public JBlock body ()
   {
diff --git a/src/main/java/com/helger/jcodemodel/JInvocation.java b/src/main/java/com/helger/jcodemodel/JInvocation.java
index e5730c09..06758c0a 100644
--- a/src/main/java/com/helger/jcodemodel/JInvocation.java
+++ b/src/main/java/com/helger/jcodemodel/JInvocation.java
@@ -40,6 +40,9 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+import com.helger.jcodemodel.optimize.ExpressionContainer;
 import com.helger.jcodemodel.util.HashCodeGenerator;
 
 import java.util.ArrayList;
@@ -50,6 +53,7 @@ import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import static com.helger.jcodemodel.util.EqualsUtils.isEqual;
+import static com.helger.jcodemodel.util.StringUtils.upper;
 
 /**
  * {@link JMethod} invocation
@@ -62,7 +66,7 @@ public class JInvocation extends AbstractJExpressionImpl implements IJStatement,
    * Object expression upon which this method will be invoked, or null if this
    * is a constructor invocation
    */
-  private final IJGenerable _object;
+  private IJGenerable _object;
 
   /**
    * Name of the method to be invoked. Either this field is set, or
@@ -455,4 +459,76 @@ public class JInvocation extends AbstractJExpressionImpl implements IJStatement,
     }
     return hashCodeGenerator.getHashCode ();
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    if (_type != null)
+      return _type;
+    if (_method != null)
+      return _method.type ();
+    return null;
+  }
+
+  @Override
+  String derivedName ()
+  {
+    String name;
+    if (_object instanceof IJExpression)
+    {
+      name = ((IJExpression) _object).expressionName () +
+          upper (methodName ());
+    } else
+    {
+      name = methodName ();
+    }
+    for (IJExpression arg : _args)
+    {
+      name += upper (arg.expressionName ());
+    }
+    return name;
+  }
+
+  @Override
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (_object instanceof IJExpression)
+    {
+      if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+      {
+        public void set (IJExpression newExpression)
+        {
+          _object = newExpression;
+        }
+
+        public IJExpression get ()
+        {
+          return (IJExpression) _object;
+        }
+      }))
+        return false;
+    }
+    for (int i = 0; i < _args.size (); i++)
+    {
+      final int finalI = i;
+      if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+      {
+        public void set (IJExpression newExpression)
+        {
+          _args.set (finalI, newExpression);
+        }
+
+        public IJExpression get ()
+        {
+          return _args.get (finalI);
+        }
+      }))
+        return false;
+    }
+    if (_type instanceof ExpressionContainer)
+    {
+      return ((ExpressionContainer) _type).forAllSubExpressions (callback);
+    }
+    return true;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JOpBinary.java b/src/main/java/com/helger/jcodemodel/JOpBinary.java
index 75b60e40..dc2bfe79 100644
--- a/src/main/java/com/helger/jcodemodel/JOpBinary.java
+++ b/src/main/java/com/helger/jcodemodel/JOpBinary.java
@@ -40,16 +40,47 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionAccessor;
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+
 import javax.annotation.Nonnull;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import static com.helger.jcodemodel.util.EqualsUtils.isEqual;
 import static com.helger.jcodemodel.util.HashCodeGenerator.getHashCode;
 
 public class JOpBinary extends AbstractJExpressionImpl
 {
-  private final IJExpression _left;
+
+  private static AbstractJType moreGeneral(AbstractJType left,
+                                           AbstractJType right)
+  {
+    boolean leftIsDouble = left.name ().equals ("double");
+    if (leftIsDouble || right.name ().equals ("double"))
+      return leftIsDouble ? left : right;
+    boolean leftIsFloat = left.name ().equals ("float");
+    if (leftIsFloat || right.name ().equals ("float"))
+      return leftIsFloat ? left : right;
+    boolean leftIsLong = left.name ().equals ("long");
+    if (leftIsLong || right.name ().equals ("long"))
+      return leftIsLong ? left : right;
+    return left.owner ().INT;
+  }
+
+  private static Map<String, String> opNames =
+      new HashMap<String, String> () {{
+        put ("instanceof", "Instanceof");
+        put ("&", "BinaryAnd");
+        put ("|", "BinaryOr");
+        put ("+", "Plus");
+        put ("-", "Minus");
+        //TODO
+      }};
+  private IJExpression _left;
   private final String _op;
-  private final IJGenerable _right;
+  private IJGenerable _right;
 
   protected JOpBinary (@Nonnull final IJExpression left, @Nonnull final String op, @Nonnull final IJGenerable right)
   {
@@ -99,4 +130,84 @@ public class JOpBinary extends AbstractJExpressionImpl
   {
     return getHashCode (this, _left, _op, _right);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    AbstractJType leftExpressionType = _left.expressionType ();
+    if (_op.equals ("instanceof"))
+      return leftExpressionType.owner ().BOOLEAN;
+
+    AbstractJType rightExpressionType =
+        ((IJExpression) _right).expressionType ();
+    if (_op.equals ("+"))
+    {
+      boolean leftIsString =
+          leftExpressionType.fullName ().equals ("java.lang.String");
+      boolean rightIsString =
+          rightExpressionType.fullName ().equals ("java.lang.String");
+      if (leftIsString || rightIsString)
+      {
+        return leftIsString ? leftExpressionType : rightExpressionType;
+      }
+    }
+    if ("+-*/%^".indexOf (_op.charAt (0)) >= 0)
+    {
+      return moreGeneral (leftExpressionType, rightExpressionType);
+    }
+    if (_op.equals ("|") || _op.equals ("&"))
+    {
+      if (leftExpressionType.fullName ().equals ("boolean") &&
+          rightExpressionType.fullName ().equals ("boolean"))
+        return leftExpressionType;
+      return moreGeneral (leftExpressionType, rightExpressionType);
+    }
+    if (_op.startsWith (">>") || _op.equals ("<<"))
+    {
+      return leftExpressionType;
+    }
+    return leftExpressionType.owner ().BOOLEAN;
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return _left.expressionName () + opNames.get (_op) +
+        (_right instanceof IJExpression ?
+            ((IJExpression) _right).expressionName () :
+            ((AbstractJType) _right).fullName ());
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (!visitWithSubExpressions (callback, new ExpressionAccessor ()
+    {
+      public void set (IJExpression newExpression)
+      {
+        _left = newExpression;
+      }
+
+      public IJExpression get ()
+      {
+        return _left;
+      }
+    }))
+      return false;
+    if (_right instanceof IJExpression)
+    {
+      return visitWithSubExpressions (callback, new ExpressionAccessor ()
+      {
+        public void set (IJExpression newExpression)
+        {
+          _right = newExpression;
+        }
+
+        public IJExpression get ()
+        {
+          return (IJExpression) _right;
+        }
+      });
+    }
+    return true;
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JOpUnary.java b/src/main/java/com/helger/jcodemodel/JOpUnary.java
index 06c1fea2..322d9836 100644
--- a/src/main/java/com/helger/jcodemodel/JOpUnary.java
+++ b/src/main/java/com/helger/jcodemodel/JOpUnary.java
@@ -42,6 +42,9 @@ package com.helger.jcodemodel;
 
 import javax.annotation.Nonnull;
 
+import java.util.HashMap;
+import java.util.Map;
+
 import static com.helger.jcodemodel.util.EqualsUtils.isEqual;
 import static com.helger.jcodemodel.util.HashCodeGenerator.getHashCode;
 
diff --git a/src/main/java/com/helger/jcodemodel/JOpUnaryTight.java b/src/main/java/com/helger/jcodemodel/JOpUnaryTight.java
index 96dd3888..8593121e 100644
--- a/src/main/java/com/helger/jcodemodel/JOpUnaryTight.java
+++ b/src/main/java/com/helger/jcodemodel/JOpUnaryTight.java
@@ -40,6 +40,8 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+
 import javax.annotation.Nonnull;
 
 public class JOpUnaryTight extends JOpUnary
@@ -62,4 +64,25 @@ public class JOpUnaryTight extends JOpUnary
     else
       f.generable (expr ()).print (op ());
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    return expr ().expressionType ();
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return (opFirst () ? "pre" : "post") +
+        (op ().equals ("++") ? "Incremented" : "Decremented") +
+        expr ().expressionName ();
+  }
+
+  public boolean forAllSubExpressions (ExpressionCallback callback)
+  {
+    if (!expr ().forAllSubExpressions (callback))
+      return false;
+    return callback.visitAssignmentTarget ((IJAssignmentTarget) expr ());
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JPrimitiveType.java b/src/main/java/com/helger/jcodemodel/JPrimitiveType.java
index 1de9b406..28d36f60 100644
--- a/src/main/java/com/helger/jcodemodel/JPrimitiveType.java
+++ b/src/main/java/com/helger/jcodemodel/JPrimitiveType.java
@@ -48,6 +48,17 @@ import javax.annotation.Nonnull;
  */
 public class JPrimitiveType extends AbstractJType
 {
+  private static final JCodeModel CODE_MODEL = new JCodeModel ();
+  public static final JPrimitiveType VOID = CODE_MODEL.VOID;
+  public static final JPrimitiveType BOOLEAN = CODE_MODEL.BOOLEAN;
+  public static final JPrimitiveType BYTE = CODE_MODEL.BYTE;
+  public static final JPrimitiveType SHORT = CODE_MODEL.SHORT;
+  public static final JPrimitiveType CHAR = CODE_MODEL.CHAR;
+  public static final JPrimitiveType INT = CODE_MODEL.INT;
+  public static final JPrimitiveType FLOAT = CODE_MODEL.FLOAT;
+  public static final JPrimitiveType LONG = CODE_MODEL.LONG;
+  public static final JPrimitiveType DOUBLE = CODE_MODEL.DOUBLE;
+
   private final JCodeModel _owner;
   private final String _typeName;
   /**
diff --git a/src/main/java/com/helger/jcodemodel/JTryBlock.java b/src/main/java/com/helger/jcodemodel/JTryBlock.java
index 39f61d34..cf340ed4 100644
--- a/src/main/java/com/helger/jcodemodel/JTryBlock.java
+++ b/src/main/java/com/helger/jcodemodel/JTryBlock.java
@@ -40,6 +40,9 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.BranchingStatement;
+import com.helger.jcodemodel.optimize.BranchingStatementVisitor;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -49,7 +52,7 @@ import javax.annotation.Nonnull;
 /**
  * Try statement with Catch and/or Finally clause
  */
-public class JTryBlock implements IJStatement
+public class JTryBlock implements IJStatement, BranchingStatement
 {
   private final JBlock _body = new JBlock ();
   private final List <JCatchBlock> _catches = new ArrayList <JCatchBlock> ();
@@ -95,4 +98,21 @@ public class JTryBlock implements IJStatement
       f.print ("finally").generable (_finally);
     f.newline ();
   }
+
+  public void apply (BranchingStatementVisitor visitor)
+  {
+    visitor.visit (_body);
+    if (!catches ().isEmpty ())
+    {
+      ArrayList<JBlock> catchBlocks =
+          new ArrayList<JBlock> (catches ().size ());
+      for (JCatchBlock aCatch : _catches)
+      {
+        catchBlocks.add (aCatch.body ());
+      }
+      visitor.visit (catchBlocks);
+    }
+    if (_finally != null)
+      visitor.visit (_finally);
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/JVar.java b/src/main/java/com/helger/jcodemodel/JVar.java
index de92843c..3f49cb1d 100644
--- a/src/main/java/com/helger/jcodemodel/JVar.java
+++ b/src/main/java/com/helger/jcodemodel/JVar.java
@@ -40,6 +40,8 @@
  */
 package com.helger.jcodemodel;
 
+import com.helger.jcodemodel.optimize.ExpressionCallback;
+
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -92,7 +94,7 @@ public class JVar extends AbstractJExpressionAssignmentTargetImpl implements IJD
    * @param init
    *        Value to initialize this variable to
    */
-  protected JVar (@Nonnull final JMods mods,
+  public JVar (@Nonnull final JMods mods,
                   @Nonnull final AbstractJType type,
                   @Nonnull final String name,
                   @Nullable final IJExpression init)
@@ -260,4 +262,16 @@ public class JVar extends AbstractJExpressionAssignmentTargetImpl implements IJD
   {
     return getHashCode (this, _name);
   }
+
+  @Override
+  AbstractJType derivedType ()
+  {
+    return _type;
+  }
+
+  @Override
+  String derivedName ()
+  {
+    return name ();
+  }
 }
diff --git a/src/main/java/com/helger/jcodemodel/optimize/BlockNode.java b/src/main/java/com/helger/jcodemodel/optimize/BlockNode.java
new file mode 100644
index 00000000..08f6d62e
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/BlockNode.java
@@ -0,0 +1,67 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.JBlock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+final class BlockNode implements Comparable<BlockNode>
+{
+
+  static BlockNode root(JBlock block)
+  {
+    return new BlockNode (block, null, 0);
+  }
+
+  final JBlock block;
+  private final BlockNode parent;
+  private final int index;
+  private List<BlockNode> children;
+
+  private BlockNode (JBlock block, BlockNode parent, int index)
+  {
+    this.block = block;
+    this.parent = parent;
+    this.index = index;
+  }
+
+  private BlockNode (BlockNode parent, JBlock block)
+  {
+    this.block = block;
+    this.parent = parent;
+    if (parent.children == null)
+      parent.children = new ArrayList<BlockNode> (5);
+    parent.children.add (this);
+    index = parent.children.size ();
+  }
+
+  BlockNode child (JBlock block)
+  {
+    return new BlockNode (this, block);
+  }
+
+  public int compareTo (BlockNode o)
+  {
+    if (this == o)
+      return 0;
+    if (this.isChildOf (o))
+      return 1;
+    if (o.isChildOf (this))
+      return -1;
+    if (this.parent == o.parent)
+      return this.index - o.index;
+    return this.parent.compareTo (o.parent);
+  }
+
+  private boolean isChildOf (BlockNode o)
+  {
+    BlockNode parent = this.parent;
+    while (parent != null)
+    {
+      if (parent == o)
+        return true;
+      parent = parent.parent;
+    }
+    return false;
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/BranchingStatement.java b/src/main/java/com/helger/jcodemodel/optimize/BranchingStatement.java
new file mode 100644
index 00000000..1ad481e1
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/BranchingStatement.java
@@ -0,0 +1,8 @@
+package com.helger.jcodemodel.optimize;
+
+//TODO remove this API: if-else, try-catch and switch are too different between
+// each other to have a common API
+public interface BranchingStatement
+{
+  void apply (BranchingStatementVisitor visitor);
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/BranchingStatementVisitor.java b/src/main/java/com/helger/jcodemodel/optimize/BranchingStatementVisitor.java
new file mode 100644
index 00000000..0e78775c
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/BranchingStatementVisitor.java
@@ -0,0 +1,14 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.JBlock;
+
+import java.util.List;
+
+public interface BranchingStatementVisitor
+{
+  void visit (ExpressionContainer conditionalExpression);
+
+  void visit (JBlock block);
+
+  void visit (List<JBlock> branches);
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/CSE.java b/src/main/java/com/helger/jcodemodel/optimize/CSE.java
new file mode 100644
index 00000000..09bebb5d
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/CSE.java
@@ -0,0 +1,454 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.*;
+
+import java.util.*;
+
+/**
+ * Common Subexpression Elimination for Java <i>source</i> code.
+ *
+ * <p>This algorithm is targeted to reduce repetitive occurrences of
+ * <ul>
+ *   <li>field accesses
+ *   <li>array element reads
+ *   <li>method calls
+ * </ul>
+ * within {@link JBlock}, for example a method body. The idea is that Java
+ * source code compiler, and even JIT bytecode compiler, sometimes are not
+ * allowed to optimize these parts, because they should assume the worst case -
+ * object fields might be updated concurrently, methods might have side effects.
+ * This optimizer have opposite premises (if some fields or array elements
+ * accessed within the optimized block are indeed concurrently updated, and
+ * non-void returning methods indeed have side effects, they should be excluded
+ * {@code expressionFilter} parameter of {@link #optimize(JBlock,
+ * ExpressionFilter)} method).
+ *
+ * <p>I know theory of compiler optimizations a bit, classic PRE (partial
+ * redundancy elimination) algorithm, but decided that it would be simplier
+ * to implement custom utility for the needs, even that to adapt the code model
+ * for existing PRE implementations: I found only a few, most noteworthy one
+ * is from https://github.com/Sable/soot project, and they all seems not ready
+ * for reuse. Needless to say that I didn't want to implement the full PRE
+ * algorithm myself.
+ *
+ * <p>Algorithm is scope-based, unlike PRE which is control-flow based (account
+ * branching and unconditional jumps).
+ *
+ * <p>Algorithm could produce code that doesn't compile (because it doesn't
+ * track taken variable names, and even couldn't do that, because there could be
+ * higher-level scopes, about which the algorithm is not aware), but it
+ * shouldn't turn compiling and correct code into compiling, but invalid code,
+ * it's premises met (single threading and absence of side effects).
+ *
+ * @author Roman Leventov <leventov@ya.ru>
+ * @see #optimize(JBlock)
+ * @see #optimize(JBlock, ExpressionFilter)
+ */
+public final class CSE
+{
+  private static final ExpressionFilter DEFAULT_FILTER = new ExpressionFilter ()
+  {
+    public boolean test (IJExpression expression)
+    {
+      return (expression instanceof JFieldRef &&
+          !(((JFieldRef) expression).object () instanceof AbstractJType)) ||
+          expression instanceof JArrayCompRef ||
+          (expression instanceof JInvocation &&
+              !"void".equals (expression.expressionType ().fullName ()));
+    }
+  };
+
+  public static void optimize(JBlock block)
+  {
+    optimize (block, DEFAULT_FILTER);
+  }
+
+  public static void optimize(JBlock block, ExpressionFilter filter)
+  {
+    CSE cse = new CSE (filter, new ArrayList<ExpressionState> (), block);
+    cse.extractSubExpressions (cse.outContext);
+    List<ExpressionState> sortedSubExpressions =
+        sortSubExpressions (cse.commonSubExpressions);
+    Map<String, Integer> nameCounts = new HashMap<String, Integer> ();
+    for (ExpressionState state : sortedSubExpressions)
+    {
+      ExpressionState definitionBase = state.definitionBase ();
+      JBlock definitionBlock = definitionBase.definitionBlock.block;
+      IJExpression expr = state.expression;
+      String basicExprName = expr.expressionName ();
+      String exprName = basicExprName;
+      Integer nameCount = nameCounts.get (exprName);
+      if (nameCount != null)
+      {
+        nameCount += 1;
+        exprName += nameCount;
+      }
+      else
+      {
+        nameCount = 1;
+      }
+      final JVar var = new JVar (JMods.forVar (JMod.FINAL),
+          expr.expressionType (), exprName, expr);
+      if (expr instanceof JFieldRef)
+      {
+        ((JFieldRef) expr).explicitThis (true);
+      }
+      boolean anyUpdated = state.forAllSites (new ExpressionCallback ()
+      {
+        public boolean visitAssignmentTarget (
+            IJAssignmentTarget assignmentTarget)
+        {
+          // do nothing
+          return true;
+        }
+
+        public boolean visitExpression (IJExpression expr,
+                                        ExpressionAccessor accessor)
+        {
+          if (accessor.get ().equals (expr))
+          {
+            accessor.set (var);
+            return true;
+          }
+          return false;
+        }
+      });
+      if (anyUpdated)
+      {
+        nameCounts.put (basicExprName, nameCount);
+        definitionBlock.insertBefore (var, definitionBase.definitionBefore);
+      }
+    }
+  }
+
+  private static List<ExpressionState> sortSubExpressions (
+      Collection<ExpressionState> commonSubExpressions)
+  {
+    Map<ExpressionState, Integer> roots =
+        new HashMap<ExpressionState, Integer> ();
+    for (ExpressionState subExpression : commonSubExpressions)
+    {
+      ExpressionState root = subExpression.root ();
+      if (roots.containsKey (root))
+        continue;
+      class SubExpressionCounter implements ExpressionCallback
+      {
+        int count = 0;
+
+        public boolean visitAssignmentTarget (
+            IJAssignmentTarget assignmentTarget)
+        {
+          count++;
+          return true;
+        }
+
+        public boolean visitExpression (IJExpression expr,
+                                        ExpressionAccessor accessor)
+        {
+          count++;
+          return true;
+        }
+      }
+      SubExpressionCounter counter = new SubExpressionCounter ();
+      root.expression.forAllSubExpressions (counter);
+      roots.put (root, counter.count);
+    }
+    List<Map.Entry<ExpressionState, Integer>> rootsAsList =
+        new ArrayList<Map.Entry<ExpressionState, Integer>> (roots.entrySet ());
+    Collections.sort (rootsAsList,
+        new Comparator<Map.Entry<ExpressionState, Integer>> ()
+    {
+      public int compare (Map.Entry<ExpressionState, Integer> o1,
+                          Map.Entry<ExpressionState, Integer> o2)
+      {
+        int cmp = o1.getValue () - o2.getValue ();
+        if (cmp != 0)
+          return cmp;
+        BlockNode block1 = o1.getKey ().definitionBlock;
+        BlockNode block2 = o2.getKey ().definitionBlock;
+        cmp = block1.compareTo (block2);
+        if (cmp != 0)
+          return cmp;
+        List<Object> statements = block1.block.getContents ();
+        Object def1Before = o1.getKey ().definitionBefore;
+        Object def2Before = o2.getKey ().definitionBefore;
+        if (def1Before == def2Before)
+          return 0;
+        for (Object statement : statements)
+        {
+          if (statement == def1Before)
+            return -1;
+          if (statement == def2Before)
+            return 1;
+        }
+        return 0;
+      }
+    });
+    List<ExpressionState> sortedSubExpressions =
+        new ArrayList<ExpressionState> (rootsAsList.size ());
+    for (Map.Entry<ExpressionState, Integer> e : rootsAsList)
+    {
+      sortedSubExpressions.add (e.getKey ());
+    }
+    return sortedSubExpressions;
+  }
+
+  private final ExpressionFilter filter;
+  private final Collection<ExpressionState> commonSubExpressions;
+  final BlockNode block;
+  private Context outContext = new Context ();
+  private Context currentContext = new Context ();
+  private Set<IJAssignmentTarget> modified =
+      new HashSet<IJAssignmentTarget> ();
+
+  CSE (
+      ExpressionFilter filter,
+      Collection<ExpressionState> commonSubExpressions, JBlock block)
+  {
+    this.filter = filter;
+    this.commonSubExpressions = commonSubExpressions;
+    this.block = BlockNode.root (block);
+    optimize ();
+  }
+
+  CSE (CSE parent, JBlock block)
+  {
+    this.filter = parent.filter;
+    this.commonSubExpressions = parent.commonSubExpressions;
+    this.block = parent.block.child (block);
+    optimize ();
+  }
+
+  private void optimize ()
+  {
+    for (final Object blockElement : block.block.getContents ())
+    {
+      if (blockElement instanceof ExpressionContainer)
+      {
+        final ExpressionContainer exprContainer =
+            (ExpressionContainer) blockElement;
+        processExpressionContainer (exprContainer, block, blockElement);
+      }
+      else if (blockElement instanceof BranchingStatement)
+      {
+        processConditionalStatement ((BranchingStatement) blockElement);
+      }
+      else if (blockElement instanceof Loop)
+      {
+        processLoop ((Loop) blockElement);
+      }
+      else if (blockElement instanceof JBlock)
+      {
+        applySubContext (new CSE (this, (JBlock) blockElement),
+            blockElement, true);
+      }
+    }
+    extractSubExpressions (currentContext);
+    currentContext.clear ();
+  }
+
+  private void processLoop (Loop loop)
+  {
+    processExpressionContainer (loop.statementsExecutedOnce (), block, loop);
+
+    // this run to gather modified
+    final CSE loopCSE = new CSE (this, loop.body ());
+    loopCSE.processExpressionContainer (
+        loop.statementsExecutedOnEachIteration (), block, loop);
+
+    loopCSE.outContext = new Context ();
+    loopCSE.currentContext = new Context ();
+    // this run to gather outContext with respect to full modified
+    loopCSE.optimize ();
+    loopCSE.processExpressionContainer (
+        loop.statementsExecutedOnEachIteration (), block, loop);
+
+    Context loopOutContext = loopCSE.outContext;
+    commonSubExpressions.addAll (loopOutContext.values ());
+    applySubContext (loopCSE, loop, false);
+  }
+
+  private void processConditionalStatement (
+      final BranchingStatement branchingStatement)
+  {
+    branchingStatement.apply (new BranchingStatementVisitor ()
+    {
+      public void visit (ExpressionContainer conditionalExpression)
+      {
+        processExpressionContainer (conditionalExpression,
+            block, branchingStatement);
+      }
+
+      public void visit (JBlock subBlock)
+      {
+        applySubContext (new CSE (CSE.this, subBlock),
+            branchingStatement, true);
+      }
+
+      public void visit (List<JBlock> branches)
+      {
+        if (branches.size () == 1)
+        {
+          visit (branches.get (0));
+          return;
+        }
+        List<CSE> branchCSEs = new ArrayList<CSE> ();
+        for (JBlock branch : branches)
+        {
+          branchCSEs.add (new CSE (CSE.this, branch));
+        }
+        List<Context> branchContexts =
+            new ArrayList<Context> (branches.size ());
+        for (CSE branchCSE : branchCSEs)
+        {
+          branchContexts.add (branchCSE.outContext);
+        }
+        Context firstBranchContext = branchContexts.get (0);
+        firstBranchExpressionLoop:
+        for (Iterator<ExpressionState> iterator =
+                 firstBranchContext.values ().iterator ();
+             iterator.hasNext (); )
+        {
+          ExpressionState state = iterator.next ();
+          for (int i = 1; i < branchContexts.size (); i++)
+          {
+            Context branchContext = branchContexts.get (i);
+            if (!branchContext.containsKey (state.expression))
+              continue firstBranchExpressionLoop;
+          }
+          // expression is present in all branches
+          iterator.remove ();
+          applyState (branchingStatement, state, true);
+          for (int i = 1; i < branchContexts.size (); i++)
+          {
+            applyState (branchingStatement,
+                branchContexts.get (i).remove (state.expression), true);
+          }
+        }
+        for (Context branchContext : branchContexts)
+        {
+          extractSubExpressions (branchContext);
+        }
+        for (CSE branchCSE : branchCSEs)
+        {
+          applySubModifications (branchCSE);
+        }
+      }
+    });
+  }
+
+  private void applySubContext (CSE subCSE, Object blockElement,
+                                boolean temporary)
+  {
+    for (ExpressionState state : subCSE.outContext.values ())
+    {
+      applyState (blockElement, state, !temporary);
+    }
+    applySubModifications (subCSE);
+  }
+
+  private void applySubModifications (CSE subCSE)
+  {
+    for (IJAssignmentTarget modified : subCSE.modified)
+    {
+      invalidate (modified);
+    }
+  }
+
+  private void applyState (Object blockElement, ExpressionState state,
+                           boolean mustBeDefinedHere)
+  {
+    if (modified (state.expression, modified))
+    {
+      currentContext.add (state, block, blockElement, mustBeDefinedHere);
+    }
+    else
+    {
+      outContext.add (state, block, blockElement, mustBeDefinedHere);
+    }
+  }
+
+  private void processExpressionContainer (ExpressionContainer exprContainer,
+                                           final BlockNode block,
+                                           final Object currentStatement)
+  {
+    exprContainer.forAllSubExpressions (new ExpressionCallback ()
+    {
+      public boolean visitAssignmentTarget (IJAssignmentTarget assignmentTarget)
+      {
+        invalidate (assignmentTarget);
+        return true;
+      }
+
+      public boolean visitExpression (IJExpression expr,
+                                      ExpressionAccessor accessor)
+      {
+        if (filter.test (expr))
+        {
+          if (modified (expr, modified))
+          {
+            currentContext.add (expr, block, currentStatement, accessor);
+          }
+          else
+          {
+            outContext.add (expr, block, currentStatement, accessor);
+          }
+        }
+        return true;
+      }
+    });
+  }
+
+  private void invalidate (IJAssignmentTarget assignmentTarget)
+  {
+    modified.add (assignmentTarget);
+    Set<IJAssignmentTarget> assignmentTargetAsSingletonSet =
+        Collections.singleton (assignmentTarget);
+    for (Iterator<ExpressionState> iterator =
+             currentContext.values ().iterator ();
+         iterator.hasNext (); )
+    {
+      ExpressionState state = iterator.next ();
+      if (modified (state.expression, assignmentTargetAsSingletonSet))
+      {
+        iterator.remove ();
+        if (state.size () > 1)
+          commonSubExpressions.add (state);
+      }
+    }
+  }
+
+  static boolean modified (IJExpression expr,
+                           final Set<IJAssignmentTarget> modified)
+  {
+    if (expr instanceof IJAssignmentTarget && modified.contains (expr))
+      return true;
+    return !expr.forAllSubExpressions (
+        new ExpressionCallback ()
+        {
+
+          public boolean visitAssignmentTarget (
+              IJAssignmentTarget assignmentTarget)
+          {
+            // do nothing
+            return true;
+          }
+
+          public boolean visitExpression (IJExpression expr,
+                                          ExpressionAccessor accessor)
+          {
+            return !(expr instanceof IJAssignmentTarget &&
+                modified.contains (expr));
+          }
+        });
+  }
+
+  private void extractSubExpressions(Context context)
+  {
+    for (ExpressionState state : context.values ())
+    {
+      if (state.size () > 1)
+        commonSubExpressions.add (state);
+    }
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/Context.java b/src/main/java/com/helger/jcodemodel/optimize/Context.java
new file mode 100644
index 00000000..41fa20ca
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/Context.java
@@ -0,0 +1,50 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.IJExpression;
+
+import java.util.HashMap;
+
+final class Context extends HashMap<IJExpression, ExpressionState>
+{
+
+  void add (IJExpression expression,
+            BlockNode definitionBlock, Object definitionBefore,
+            ExpressionAccessor... accessors)
+  {
+    ExpressionState state = get (expression);
+    if (state == null)
+    {
+      state = new ExpressionState (expression,
+          definitionBlock, definitionBefore, false);
+      put (expression, state);
+    }
+    state.addSite (accessors);
+  }
+
+  void add(ExpressionState state,
+           BlockNode definitionBlock, Object definitionBefore,
+           boolean mustBeDefinedHere)
+  {
+    IJExpression expression = state.expression;
+    ExpressionState s = get (expression);
+    if (s == null)
+    {
+      s = new ExpressionState (expression,
+          definitionBlock, definitionBefore, mustBeDefinedHere);
+      put (expression, s);
+    }
+    s.link (state);
+  }
+
+  public boolean addIfPresent (IJExpression expression,
+                               ExpressionAccessor... accessors)
+  {
+    ExpressionState state = get (expression);
+    if (state != null)
+    {
+      state.addSite (accessors);
+      return true;
+    }
+    return false;
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/ExpressionAccessor.java b/src/main/java/com/helger/jcodemodel/optimize/ExpressionAccessor.java
new file mode 100644
index 00000000..a9db3cff
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/ExpressionAccessor.java
@@ -0,0 +1,9 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.IJExpression;
+
+public interface ExpressionAccessor
+{
+  void set (IJExpression newExpression);
+  IJExpression get ();
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/ExpressionCallback.java b/src/main/java/com/helger/jcodemodel/optimize/ExpressionCallback.java
new file mode 100644
index 00000000..2e9a854b
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/ExpressionCallback.java
@@ -0,0 +1,11 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.IJAssignmentTarget;
+import com.helger.jcodemodel.IJExpression;
+
+public interface ExpressionCallback
+{
+  boolean visitAssignmentTarget (IJAssignmentTarget assignmentTarget);
+
+  boolean visitExpression (IJExpression expr, ExpressionAccessor accessor);
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/ExpressionContainer.java b/src/main/java/com/helger/jcodemodel/optimize/ExpressionContainer.java
new file mode 100644
index 00000000..4b41c568
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/ExpressionContainer.java
@@ -0,0 +1,6 @@
+package com.helger.jcodemodel.optimize;
+
+public interface ExpressionContainer
+{
+  boolean forAllSubExpressions (ExpressionCallback callback);
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/ExpressionFilter.java b/src/main/java/com/helger/jcodemodel/optimize/ExpressionFilter.java
new file mode 100644
index 00000000..1f1554ff
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/ExpressionFilter.java
@@ -0,0 +1,8 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.IJExpression;
+
+public interface ExpressionFilter
+{
+  boolean test (IJExpression expression);
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/ExpressionState.java b/src/main/java/com/helger/jcodemodel/optimize/ExpressionState.java
new file mode 100644
index 00000000..aa19759c
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/ExpressionState.java
@@ -0,0 +1,99 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.IJExpression;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+class ExpressionState
+{
+  final IJExpression expression;
+  final BlockNode definitionBlock;
+  final Object definitionBefore;
+  final boolean mustBeDefinedHere;
+  Collection<ExpressionAccessor> sites;
+  ExpressionState parent;
+  List<ExpressionState> children;
+
+  ExpressionState (IJExpression expression,
+                   BlockNode definitionBlock, Object definitionBefore,
+                   boolean mustBeDefinedHere)
+  {
+    this.expression = expression;
+    this.definitionBlock = definitionBlock;
+    this.definitionBefore = definitionBefore;
+    this.mustBeDefinedHere = mustBeDefinedHere;
+  }
+
+  void addSite (ExpressionAccessor... accessors)
+  {
+    if (sites == null)
+      sites = new ArrayList<ExpressionAccessor> (5);
+    Collections.addAll (sites, accessors);
+  }
+
+  int size ()
+  {
+    int size = sites != null ? sites.size () : 0;
+    if (children != null)
+    {
+      for (ExpressionState child : children)
+      {
+        size += child.size ();
+      }
+    }
+    return size;
+  }
+
+  ExpressionState definitionBase()
+  {
+    if (!mustBeDefinedHere && sites == null && children.size () == 1)
+      return children.get (0).definitionBase ();
+    return this;
+  }
+
+  ExpressionState root ()
+  {
+    if (parent == null)
+      return this;
+    return parent.root ();
+  }
+
+  private void addChild (ExpressionState state)
+  {
+    if (children == null)
+      children = new ArrayList<ExpressionState> (5);
+    children.add (state);
+    state.parent = this;
+  }
+
+  void link (ExpressionState state)
+  {
+    if (!expression.equals (state.expression))
+      throw new IllegalArgumentException ();
+    root ().addChild (state.root ());
+  }
+
+  boolean forAllSites (ExpressionCallback action)
+  {
+    if (sites != null)
+    {
+      for (ExpressionAccessor site : sites)
+      {
+        if (!action.visitExpression (expression, site))
+          return false;
+      }
+    }
+    if (children != null)
+    {
+      for (ExpressionState child : children)
+      {
+        if (!child.forAllSites (action))
+          return false;
+      }
+    }
+    return true;
+  }
+}
diff --git a/src/main/java/com/helger/jcodemodel/optimize/Loop.java b/src/main/java/com/helger/jcodemodel/optimize/Loop.java
new file mode 100644
index 00000000..73b1fe02
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/optimize/Loop.java
@@ -0,0 +1,12 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.JBlock;
+
+public interface Loop
+{
+  ExpressionContainer statementsExecutedOnce ();
+
+  ExpressionContainer statementsExecutedOnEachIteration ();
+
+  JBlock body ();
+}
diff --git a/src/main/java/com/helger/jcodemodel/util/StringUtils.java b/src/main/java/com/helger/jcodemodel/util/StringUtils.java
new file mode 100644
index 00000000..31db3fa8
--- /dev/null
+++ b/src/main/java/com/helger/jcodemodel/util/StringUtils.java
@@ -0,0 +1,17 @@
+package com.helger.jcodemodel.util;
+
+public final class StringUtils
+{
+  private StringUtils ()
+  {}
+
+  public static String lower (String cap)
+  {
+    return Character.toLowerCase (cap.charAt (0)) + cap.substring (1);
+  }
+
+  public static String upper (String low)
+  {
+    return Character.toUpperCase (low.charAt (0)) + low.substring (1);
+  }
+}
diff --git a/src/test/java/com/helger/jcodemodel/optimize/CSETest.java b/src/test/java/com/helger/jcodemodel/optimize/CSETest.java
new file mode 100644
index 00000000..04cd4366
--- /dev/null
+++ b/src/test/java/com/helger/jcodemodel/optimize/CSETest.java
@@ -0,0 +1,238 @@
+package com.helger.jcodemodel.optimize;
+
+import com.helger.jcodemodel.*;
+import com.helger.jcodemodel.tests.util.CodeModelTestsUtils;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.HashSet;
+
+import static com.helger.jcodemodel.JExpr._new;
+import static com.helger.jcodemodel.JExpr.lit;
+import static com.helger.jcodemodel.JExpr.ref;
+
+public class CSETest
+{
+
+  /**
+   * Run tests one by one and verify they do something sensible.
+   */
+
+  private static void println(JCodeModel cm, JBlock b, IJExpression expression)
+  {
+    b.invoke (cm.ref (System.class).staticRef ("out"), "println")
+        .arg (expression).hintType (cm.VOID);
+  }
+
+  @Test
+  public void testFieldRefObjectInvalidation ()
+      throws JClassAlreadyExistsException, IOException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestFieldRefObjectInvalidation");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    AbstractJExpressionImpl aLength = ref (a, "length").hintType (cm.INT);
+
+    println (cm, b, aLength);
+    println (cm, b, aLength);
+
+    b.assign (a, JExpr.newArray (cm.INT, 21));
+    println (cm, b, aLength);
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testArrayIndexingInvalidation ()
+      throws JClassAlreadyExistsException, IOException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestMethodCallArgumentInvalidation");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    JVar i = b.decl ("i", lit (42));
+
+    println (cm, b, a.component (i));
+    println (cm, b, a.component (i));
+
+    b.assign (i, lit (21));
+    println (cm, b, a.component (i));
+    println (cm, b, a.component (i));
+
+    b.assign (a, JExpr.newArray (cm.INT, 21));
+    println (cm, b, a.component (i));
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testMethodCallInvalidation ()
+      throws JClassAlreadyExistsException, IOException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestMethodCallArgumentInvalidation");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar map = b.decl ("map", _new (cm._ref (HashSet.class)));
+    JVar i = b.decl ("i", lit (42));
+
+    println (cm, b, map.invoke ("contains").arg (i).hintType (cm.BOOLEAN));
+    println (cm, b, map.invoke ("contains").arg (i).hintType (cm.BOOLEAN));
+
+    b.assign (i, lit (21));
+    println (cm, b, map.invoke ("contains").arg (i).hintType (cm.BOOLEAN));
+    println (cm, b, map.invoke ("contains").arg (i).hintType (cm.BOOLEAN));
+
+    b.assign (map, _new (cm._ref (HashSet.class)));
+    println (cm, b, map.invoke ("contains").arg (i).hintType (cm.BOOLEAN));
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testNestedSubExpressions() throws JClassAlreadyExistsException, IOException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestNestedSubExpressions");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    b.invoke (cm.ref (System.class).staticRef ("out"), "println")
+        .arg (
+            ref ("arrayField").hintType (cm.LONG.array ())
+            .component (ref ("indexField").hintType (cm.INT)))
+        .hintType (cm.VOID);
+    b.invoke (cm.ref (System.class).staticRef ("out"), "println")
+        .arg (
+            ref ("arrayField").hintType (cm.LONG.array ())
+                .component (ref ("indexField").hintType (cm.INT)))
+        .hintType (cm.VOID);
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testSubBlockDefinitionPull() throws JClassAlreadyExistsException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestSubBlockDefinitionPull");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    AbstractJExpressionImpl aLength = ref (a, "length").hintType (cm.INT);
+
+    JBlock subBlock = b.block ();
+    // without dummy definition jCodeModel won't create a sub block
+    subBlock.decl ("i", lit (1));
+    println (cm, subBlock, aLength);
+    println (cm, b, aLength);
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testInsideSubBlockInvalidation() throws JClassAlreadyExistsException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestInsideSubBlockInvalidation");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    AbstractJExpressionImpl aLength = ref (a, "length").hintType (cm.INT);
+
+    println (cm, b, aLength);
+
+    JBlock subBlock = b.block ();
+    // without dummy definition jCodeModel won't create a sub block
+    subBlock.decl ("i", lit (1));
+    subBlock.assign (a, JExpr.newArray (cm.INT, 21));
+    println (cm, subBlock, aLength);
+    println (cm, subBlock, aLength);
+
+    println (cm, b, aLength);
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testIfBranchesPull() throws JClassAlreadyExistsException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestIfBranchesPull");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    AbstractJExpressionImpl aLength = ref (a, "length").hintType (cm.INT);
+
+    JConditional cond = b._if (cls.staticInvoke ("test"));
+    println (cm, cond._then (), aLength);
+    println (cm, cond._else (), aLength);
+
+    b.assign (a, JExpr.newArray (cm.INT, 21));
+
+    cond = b._if (cls.staticInvoke ("test"));
+    println (cm, cond._then (), aLength);
+    cond._else ().decl ("i", lit (1));
+
+    cond = b._if (cls.staticInvoke ("test"));
+    JConditional cond2 = cond._then ()._if (cls.staticInvoke ("test"));
+    println (cm, cond2._then (), aLength);
+    println (cm, cond2._else (), aLength);
+
+    JConditional cond3 = cond._else ()._if (cls.staticInvoke ("test"));
+    println (cm, cond3._then (), aLength);
+    println (cm, cond3._else (), aLength);
+
+    b.assign (a, JExpr.newArray (cm.INT, 42));
+
+    cond = b._if (cls.staticInvoke ("test"));
+    cond2 = cond._then ()._if (cls.staticInvoke ("test"));
+    println (cm, cond2._then (), aLength);
+    println (cm, cond2._else (), aLength);
+
+    cond3 = cond._else ()._if (cls.staticInvoke ("test"));
+    println (cm, cond3._then (), aLength);
+    cond3._else ().decl ("i", lit (1));
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+
+  @Test
+  public void testForLoop() throws JClassAlreadyExistsException
+  {
+    final JCodeModel cm = new JCodeModel ();
+    final JDefinedClass cls = cm._class ("TestForLoop");
+    final JMethod m = cls.method (JMod.PUBLIC, cm.VOID, "foo");
+    JBlock b = m.body ();
+
+    JVar a = b.decl ("a", JExpr.newArray (cm.INT, 42));
+    JVar j = b.decl ("j", lit (42));
+
+    JForLoop _for = b._for ();
+    JVar i = _for.init (cm.INT, "i", lit (0));
+    _for.test (i.lt (lit (10)));
+    _for.update (i.incr ());
+    JBlock forBody = _for.body ();
+    println (cm, forBody, a.component (i));
+    println (cm, forBody, a.component (j));
+
+    CSE.optimize (b);
+    System.out.println (CodeModelTestsUtils.declare (cls));
+  }
+}
