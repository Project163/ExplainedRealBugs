diff --git a/src/main/java/com/helger/jcodemodel/JCodeModel.java b/src/main/java/com/helger/jcodemodel/JCodeModel.java
index ebcbbef6..c4f3608d 100644
--- a/src/main/java/com/helger/jcodemodel/JCodeModel.java
+++ b/src/main/java/com/helger/jcodemodel/JCodeModel.java
@@ -536,7 +536,7 @@ public final class JCodeModel
     {
       return ref (Class.forName (sFullyQualifiedClassName));
     }
-    catch (final ClassNotFoundException e1)
+    catch (final ClassNotFoundException e)
     {
       // fall through
     }
@@ -581,7 +581,7 @@ public final class JCodeModel
     }
     catch (final IllegalArgumentException e)
     {
-      // NOt a primitive type
+      // Not a primitive type
     }
 
     // existing class
@@ -591,12 +591,12 @@ public final class JCodeModel
   @NotThreadSafe
   private final class TypeNameParser
   {
-    private final String _s;
-    private int _idx;
+    private final String m_sTypeName;
+    private int m_nIdx;
 
     public TypeNameParser (@Nonnull final String s)
     {
-      _s = s;
+      m_sTypeName = s;
     }
 
     /**
@@ -608,36 +608,37 @@ public final class JCodeModel
     @Nonnull
     AbstractJClass parseTypeName ()
     {
-      final int start = _idx;
+      final int start = m_nIdx;
 
-      if (_s.charAt (_idx) == '?')
+      if (m_sTypeName.charAt (m_nIdx) == '?')
       {
         // wildcard
-        _idx++;
+        m_nIdx++;
         _skipWs ();
-        final String head = _s.substring (_idx);
+        final String head = m_sTypeName.substring (m_nIdx);
         if (head.startsWith ("extends"))
         {
-          _idx += 7;
+          m_nIdx += 7;
           _skipWs ();
           return parseTypeName ().wildcard ();
         }
         if (head.startsWith ("super"))
           throw new UnsupportedOperationException ("? super T not implemented");
         // not supported
-        throw new IllegalArgumentException ("only extends/super can follow ?, but found " + _s.substring (_idx));
+        throw new IllegalArgumentException ("only extends/super can follow ?, but found " +
+                                            m_sTypeName.substring (m_nIdx));
       }
 
-      while (_idx < _s.length ())
+      while (m_nIdx < m_sTypeName.length ())
       {
-        final char ch = _s.charAt (_idx);
+        final char ch = m_sTypeName.charAt (m_nIdx);
         if (Character.isJavaIdentifierStart (ch) || Character.isJavaIdentifierPart (ch) || ch == '.')
-          _idx++;
+          m_nIdx++;
         else
           break;
       }
 
-      final AbstractJClass clazz = ref (_s.substring (start, _idx));
+      final AbstractJClass clazz = ref (m_sTypeName.substring (start, m_nIdx));
 
       return _parseSuffix (clazz);
     }
@@ -649,22 +650,22 @@ public final class JCodeModel
     @Nonnull
     private AbstractJClass _parseSuffix (@Nonnull final AbstractJClass clazz)
     {
-      if (_idx == _s.length ())
+      if (m_nIdx == m_sTypeName.length ())
         return clazz; // hit EOL
 
-      final char ch = _s.charAt (_idx);
+      final char ch = m_sTypeName.charAt (m_nIdx);
 
       if (ch == '<')
         return _parseSuffix (_parseArguments (clazz));
 
       if (ch == '[')
       {
-        if (_s.charAt (_idx + 1) == ']')
+        if (m_sTypeName.charAt (m_nIdx + 1) == ']')
         {
-          _idx += 2;
+          m_nIdx += 2;
           return _parseSuffix (clazz.array ());
         }
-        throw new IllegalArgumentException ("Expected ']' but found " + _s.substring (_idx + 1));
+        throw new IllegalArgumentException ("Expected ']' but found " + m_sTypeName.substring (m_nIdx + 1));
       }
 
       return clazz;
@@ -675,8 +676,8 @@ public final class JCodeModel
      */
     private void _skipWs ()
     {
-      while (Character.isWhitespace (_s.charAt (_idx)) && _idx < _s.length ())
-        _idx++;
+      while (Character.isWhitespace (m_sTypeName.charAt (m_nIdx)) && m_nIdx < m_sTypeName.length ())
+        m_nIdx++;
     }
 
     /**
@@ -687,24 +688,24 @@ public final class JCodeModel
     @Nonnull
     private AbstractJClass _parseArguments (@Nonnull final AbstractJClass rawType)
     {
-      if (_s.charAt (_idx) != '<')
+      if (m_sTypeName.charAt (m_nIdx) != '<')
         throw new IllegalArgumentException ();
-      _idx++;
+      m_nIdx++;
 
       final List <AbstractJClass> args = new ArrayList <AbstractJClass> ();
 
       while (true)
       {
         args.add (parseTypeName ());
-        if (_idx == _s.length ())
-          throw new IllegalArgumentException ("Missing '>' in " + _s);
-        final char ch = _s.charAt (_idx);
+        if (m_nIdx == m_sTypeName.length ())
+          throw new IllegalArgumentException ("Missing '>' in " + m_sTypeName);
+        final char ch = m_sTypeName.charAt (m_nIdx);
         if (ch == '>')
           return rawType.narrow (args.toArray (new AbstractJClass [args.size ()]));
 
         if (ch != ',')
-          throw new IllegalArgumentException (_s);
-        _idx++;
+          throw new IllegalArgumentException (m_sTypeName);
+        m_nIdx++;
       }
     }
   }
diff --git a/src/main/java/com/helger/jcodemodel/JDirectClass.java b/src/main/java/com/helger/jcodemodel/JDirectClass.java
index 36d0c970..b463175f 100644
--- a/src/main/java/com/helger/jcodemodel/JDirectClass.java
+++ b/src/main/java/com/helger/jcodemodel/JDirectClass.java
@@ -56,18 +56,31 @@ import javax.annotation.Nullable;
  */
 public class JDirectClass extends AbstractJClassContainer <JDirectClass>
 {
+
+  private final String m_sFullName;
+
   @Deprecated
   protected JDirectClass (@Nonnull final JCodeModel aOwner, @Nonnull final String sFullName)
   {
     this (aOwner, null, EClassType.CLASS, sFullName);
   }
 
+  @Nonnull
+  private static String _getName (@Nonnull final String sFullName)
+  {
+    final int nLast = sFullName.lastIndexOf ('.');
+    if (nLast < 0)
+      return sFullName;
+    return sFullName.substring (nLast + 1);
+  }
+
   protected JDirectClass (@Nonnull final JCodeModel aOwner,
                           @Nullable final IJClassContainer <?> aOuter,
                           @Nonnull final EClassType eClassType,
                           @Nonnull final String sFullName)
   {
-    super (aOwner, aOuter, eClassType, sFullName);
+    super (aOwner, aOuter, eClassType, _getName (sFullName));
+    m_sFullName = sFullName;
   }
 
   /**
@@ -78,10 +91,10 @@ public class JDirectClass extends AbstractJClassContainer <JDirectClass>
   public String fullName ()
   {
     if (getOuter () instanceof AbstractJClassContainer <?>)
-      return ((AbstractJClassContainer <?>) getOuter ()).fullName () + '.' + name ();
+      return ((AbstractJClassContainer <?>) getOuter ()).fullName () + '.' + m_sFullName;
 
     // The fully qualified name was already provided in the ctor
-    return name ();
+    return m_sFullName;
   }
 
   @Override
@@ -95,7 +108,7 @@ public class JDirectClass extends AbstractJClassContainer <JDirectClass>
       return (JPackage) aOuter;
 
     // No package present - use name based analysis
-    final String sFullName = name ();
+    final String sFullName = fullName ();
     final int i = sFullName.lastIndexOf ('.');
     if (i >= 0)
       return owner ()._package (sFullName.substring (0, i));
diff --git a/src/main/java/com/helger/jcodemodel/JFormatter.java b/src/main/java/com/helger/jcodemodel/JFormatter.java
index 73489a91..82423e9e 100644
--- a/src/main/java/com/helger/jcodemodel/JFormatter.java
+++ b/src/main/java/com/helger/jcodemodel/JFormatter.java
@@ -88,8 +88,7 @@ public class JFormatter implements Closeable
 
    /**
     * Find any error types in output code. In this mode we don't actually
-    * generate anything.
-    * <p>
+    * generate anything. <br/>
     * Only used by {@link JFormatter#containsErrorTypes(JDefinedClass)
     * containsErrorTypes} method
     */
@@ -106,10 +105,10 @@ public class JFormatter implements Closeable
    */
   /* package */static final char CLOSE_TYPE_ARGS = '\uFFFF';
 
-  /** all classes and ids encountered during the collection mode **/
   /**
-   * map from short type name to ReferenceList (list of JClass and ids sharing
-   * that name)
+   * all classes and ids encountered during the collection mode.<br>
+   * map from short type name to {@link Usages} (list of {@link AbstractJClass}
+   * and ids sharing that name)
    **/
   private final Map <String, Usages> m_aCollectedReferences = new HashMap <String, Usages> ();
 
@@ -391,18 +390,14 @@ public class JFormatter implements Closeable
         }
         break;
       case COLLECTING:
-        // Never import direct classes
-        if (!(aType instanceof JDirectClass))
+        final String sShortName = aType.name ();
+        Usages aUsage = m_aCollectedReferences.get (sShortName);
+        if (aUsage == null)
         {
-          final String sShortName = aType.name ();
-          Usages aUsage = m_aCollectedReferences.get (sShortName);
-          if (aUsage == null)
-          {
-            aUsage = new Usages ();
-            m_aCollectedReferences.put (sShortName, aUsage);
-          }
-          aUsage.addReferencedType (aType);
+          aUsage = new Usages ();
+          m_aCollectedReferences.put (sShortName, aUsage);
         }
+        aUsage.addReferencedType (aType);
         break;
     }
     return this;
@@ -525,46 +520,46 @@ public class JFormatter implements Closeable
   /**
    * Generates the whole source code out of the specified class.
    */
-  void write (@Nonnull final JDefinedClass c)
+  void write (@Nonnull final JDefinedClass aClassToBeWritten)
   {
-    m_aPckJavaLang = c.owner ()._package ("java.lang");
+    m_aPckJavaLang = aClassToBeWritten.owner ()._package ("java.lang");
 
     // first collect all the types and identifiers
     m_eMode = EMode.COLLECTING;
-    declaration (c);
+    declaration (aClassToBeWritten);
 
     // collate type names and identifiers to determine which types can be
     // imported
-    for (final Usages usage : m_aCollectedReferences.values ())
+    for (final Usages aUsage : m_aCollectedReferences.values ())
     {
-      if (!usage.isAmbiguousIn (c) && !usage.isVariableName ())
+      if (!aUsage.isAmbiguousIn (aClassToBeWritten) && !aUsage.isVariableName ())
       {
-        final AbstractJClass reference = usage.getSingleReferencedType ();
+        final AbstractJClass aReferencedClass = aUsage.getSingleReferencedType ();
 
-        if (_shouldBeImported (reference, c))
-          m_aImportedClasses.add (reference);
+        if (_shouldBeImported (aReferencedClass, aClassToBeWritten))
+          m_aImportedClasses.add (aReferencedClass);
         else
         {
-          _importOuterClassIfCausesNoAmbiguities (reference, c);
+          _importOuterClassIfCausesNoAmbiguities (aReferencedClass, aClassToBeWritten);
         }
       }
       else
       {
-        for (final AbstractJClass reference : usage.getReferencedTypes ())
+        for (final AbstractJClass reference : aUsage.getReferencedTypes ())
         {
-          _importOuterClassIfCausesNoAmbiguities (reference, c);
+          _importOuterClassIfCausesNoAmbiguities (reference, aClassToBeWritten);
         }
       }
     }
 
     // the class itself that we will be generating is always accessible
-    m_aImportedClasses.add (c);
+    m_aImportedClasses.add (aClassToBeWritten);
 
     // then print the declaration
     m_eMode = EMode.PRINTING;
 
-    assert c.parentContainer ().isPackage () : "this method is only for a pacakge-level class";
-    final JPackage pkg = (JPackage) c.parentContainer ();
+    assert aClassToBeWritten.parentContainer ().isPackage () : "this method is only for a pacakge-level class";
+    final JPackage pkg = (JPackage) aClassToBeWritten.parentContainer ();
     if (!pkg.isUnnamed ())
     {
       newline ().declaration (pkg);
@@ -580,7 +575,7 @@ public class JFormatter implements Closeable
       // suppress import statements for primitive types, built-in types,
       // types in the root package, and types in
       // the same package as the current type
-      if (!_isImplicitlyImported (clazz, c))
+      if (!_isImplicitlyImported (clazz, aClassToBeWritten))
       {
         if (clazz instanceof JNarrowedClass)
         {
@@ -595,7 +590,7 @@ public class JFormatter implements Closeable
     if (bAnyImport)
       newline ();
 
-    declaration (c);
+    declaration (aClassToBeWritten);
   }
 
   /**
@@ -604,23 +599,27 @@ public class JFormatter implements Closeable
    *
    * @param aReference
    *        {@link AbstractJClass} referenced class
-   * @param clazz
+   * @param aGeneratedClass
    *        {@link AbstractJClass} currently generated class
    * @return true if an import statement can be used to shorten references to
    *         referenced class
    */
-  private boolean _shouldBeImported (@Nonnull final AbstractJClass aReference, @Nonnull final JDefinedClass clazz)
+  private boolean _shouldBeImported (@Nonnull final AbstractJClass aReference,
+                                     @Nonnull final JDefinedClass aGeneratedClass)
   {
     AbstractJClass aRealReference = aReference;
     if (aRealReference instanceof JAnonymousClass)
     {
+      // get the super class of the anonymous class
       aRealReference = ((JAnonymousClass) aRealReference)._extends ();
     }
     if (aRealReference instanceof JNarrowedClass)
     {
+      // Remove the generic arguments
       aRealReference = aRealReference.erasure ();
     }
 
+    // Is it an inner class?
     final AbstractJClass aOuter = aRealReference.outer ();
     if (aOuter != null)
     {
@@ -629,7 +628,7 @@ public class JFormatter implements Closeable
       // In such case no information is lost when we refer to inner class
       // without mentioning
       // it's enclosing class
-      if (aRealReference.name ().contains (aOuter.name ()) && _shouldBeImported (aOuter, clazz))
+      if (aRealReference.name ().contains (aOuter.name ()) && _shouldBeImported (aOuter, aGeneratedClass))
         return true;
 
       // Do not import inner classes in all other cases to aid
@@ -654,10 +653,12 @@ public class JFormatter implements Closeable
     AbstractJClass aRealReference = aReference;
     if (aRealReference instanceof JAnonymousClass)
     {
+      // Get the super class of the anonymous class
       aRealReference = ((JAnonymousClass) aRealReference)._extends ();
     }
     if (aRealReference instanceof JNarrowedClass)
     {
+      // Remove generic type arguments
       aRealReference = aRealReference.erasure ();
     }
 
@@ -669,7 +670,10 @@ public class JFormatter implements Closeable
     }
 
     if (aPackage.isUnnamed ())
+    {
+      // Root package - no need to import something
       return true;
+    }
 
     if (aPackage == m_aPckJavaLang)
     {
diff --git a/src/test/java/com/helger/jcodemodel/JDirectClassTest.java b/src/test/java/com/helger/jcodemodel/JDirectClassTest.java
index 71bbf971..101d8cb9 100644
--- a/src/test/java/com/helger/jcodemodel/JDirectClassTest.java
+++ b/src/test/java/com/helger/jcodemodel/JDirectClassTest.java
@@ -1,6 +1,7 @@
 package com.helger.jcodemodel;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
 
@@ -45,12 +46,16 @@ public final class JDirectClassTest
   {
     final JCodeModel cm = new JCodeModel ();
 
-    final JDirectClass aDirectClass = cm.directClass ("com.test.GenericFragmentArguments<S,P>");
-    assertEquals ("com.test", aDirectClass._package ().name ());
-    assertEquals ("com.test.GenericFragmentArguments<S,P>", aDirectClass.name ());
-    assertEquals ("com.test.GenericFragmentArguments<S,P>", aDirectClass.fullName ());
+    final AbstractJClass aNarrowedClass = (AbstractJClass) cm.parseType ("com.test.GenericFragmentArguments<S,P>");
+    assertTrue (aNarrowedClass instanceof JNarrowedClass);
+    assertTrue (aNarrowedClass.erasure () instanceof JDirectClass);
+    assertEquals ("com.test", aNarrowedClass._package ().name ());
+    assertEquals ("GenericFragmentArguments<S,P>", aNarrowedClass.name ());
+    assertEquals ("GenericFragmentArguments", aNarrowedClass.erasure ().name ());
+    assertEquals ("com.test.GenericFragmentArguments<S,P>", aNarrowedClass.fullName ());
+    assertEquals ("com.test.GenericFragmentArguments", aNarrowedClass.erasure ().fullName ());
 
-    cm._class ("UsingClass").method (JMod.PUBLIC, cm.VOID, "test").body ().add (JExpr._new (aDirectClass));
+    cm._class ("UsingClass").method (JMod.PUBLIC, cm.VOID, "test").body ().add (JExpr._new (aNarrowedClass));
 
     CodeModelTestsHelper.parseCodeModel (cm);
   }
