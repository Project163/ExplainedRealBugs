<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 21:16:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[POOL-263] GenericObjectPool close and returnObject is not synchronized</title>
                <link>https://issues.apache.org/jira/browse/POOL-263</link>
                <project id="12310488" key="POOL">Commons Pool</project>
                    <description>&lt;p&gt;the javadoc on GenericObjectPool#close() says:&lt;br/&gt;
&quot;Closes the pool. Once the pool is closed, borrowObject() will fail with IllegalStateException, but returnObject(Object) and invalidateObject(Object) will continue to work, with returned objects destroyed on return.&lt;br/&gt;
Destroys idle instances in the pool by invoking clear().&quot;&lt;br/&gt;
Thread1: pool.close()&lt;br/&gt;
Thread2: pool.returnObject()&lt;br/&gt;
since close and returnObject is not synchronized, there is a small chance that an returned object is not destoryed after the pool is closed&lt;/p&gt;</description>
                <environment>&lt;p&gt;ALL&lt;/p&gt;</environment>
        <key id="12708668">POOL-263</key>
            <summary>GenericObjectPool close and returnObject is not synchronized</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="satiini">yangxuesong</reporter>
                        <labels>
                    </labels>
                <created>Wed, 16 Apr 2014 04:01:12 +0000</created>
                <updated>Wed, 31 Dec 2014 16:18:34 +0000</updated>
                            <resolved>Wed, 9 Jul 2014 21:30:50 +0000</resolved>
                                    <version>2.2</version>
                                    <fixVersion>2.3</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13974945" author="psteitz" created="Sat, 19 Apr 2014 19:50:27 +0000"  >&lt;p&gt;The statement &quot;once the pool is closed&quot; means once the close method completes.  At that time, subsequent returns will result in objects being destroyed.  If a return happens while close is executing it is possible for an instance to return between the time close begins and the (volatile) closed property is set.  In that case, the returning instance is likely to be destroyed by the clear() call at the end of close().  It does not look possible to me for an instance to sneak in after clear() has begun because closed is set before clear is invoked and clear&apos;s polling would pick up the returning instance.  If someone can produce a test case indicating that it is actually possible to orphan instances this way, we can look at options for ensuring clear() on close is really effective; otherwise I am inclined to close this as invalid.&lt;/p&gt;</comment>
                            <comment id="13978119" author="satiini" created="Wed, 23 Apr 2014 12:17:13 +0000"  >&lt;p&gt;Thread1: will execute GenericObjectPool line 610( idleObjects.addLast(p); )&lt;br/&gt;
Thread2: will execute GenericObjectPool line 696 ( if (isClosed()) { )&lt;br/&gt;
now, thread2 start to execute to line 718(the end of close method)&lt;br/&gt;
then, thread1 execute again( idleObjects.addLast(p); ). I think the returned object p will not be destroyed since clear() method has been executed.&lt;/p&gt;</comment>
                            <comment id="13979139" author="psteitz" created="Thu, 24 Apr 2014 00:41:56 +0000"  >&lt;p&gt;Thanks, yangxuesong, for looking carefully at the code. &lt;/p&gt;

&lt;p&gt;The scenario you describe is made more unlikely than it may look from just the GOP code because as soon as Thread 1 starts executing idleObjects.addLast(p) it is going to acquire the lock that clear() subsequently needs, so clear() can&apos;t execute until it is finished.  Look at the addLast and poll methods of LinkedBlockingDeque.  It is theoretically possible however that the steps in the middle above happen between the time that idleObjects.addLast is invoked and when it acquires the lock.&lt;/p&gt;

&lt;p&gt;A test case illustrating that this can actually happen would be most appreciated.  Also, any suggestions on how to ensure that it can&apos;t happen without adding material overhead to either of the methods involved.&lt;/p&gt;</comment>
                            <comment id="13979187" author="satiini" created="Thu, 24 Apr 2014 01:43:44 +0000"  >&lt;p&gt;&quot;It is theoretically possible however that the steps in the middle above happen between the time that idleObjects.addLast is invoked and when it acquires the lock.&quot;&lt;br/&gt;
from the above line, I think you are agree with &quot;there is a very small chance of orphan instance&quot; (Am I right?)&lt;/p&gt;

&lt;p&gt;&quot;A test case illustrating that this can actually happen would be most appreciated. Also, any suggestions on how to ensure that it can&apos;t happen without adding material overhead to either of the methods involved&quot;&lt;br/&gt;
the test case is not easy to produce, since I can NOT control the execution order of each thread. What I do is theoretically analyze.&lt;br/&gt;
Besides, if we want to ensure that can&apos;t happen, I think an material overhead is unavoidable. such as synchronize returnObject method with the closeLock object which is used in close method.&lt;/p&gt;

&lt;p&gt;Thanks for your quick response!&lt;/p&gt;</comment>
                            <comment id="14056716" author="markt" created="Wed, 9 Jul 2014 20:30:06 +0000"  >&lt;p&gt;Adding synchronize to return object is not the way to solve this. That would add a significant performance overhead.&lt;/p&gt;

&lt;p&gt;The root cause of the problem is that in a number of places isClosed() is tested and, if false, is assumed to remain false for the remainder of the code block associated with the call. Since the value of isClosed() can change it any time, this assumption is false. The way to address this is to confirm that the assumption is still true at the end of the code block and if not, take any necessary corrective action - which is almost certainly calling clear(). The overhead of doing this is minimal - just some additional calls to isClosed.&lt;/p&gt;

&lt;p&gt;I&apos;ll take a look at a patch to address this shortly. I also want to try creating a test case but there isn&apos;t going to be a way to reliably trigger this issue.&lt;/p&gt;</comment>
                            <comment id="14056776" author="markt" created="Wed, 9 Jul 2014 21:30:50 +0000"  >&lt;p&gt;This issue is fixed but a reliable test case isn&apos;t possible without polluting the GOP and GKOP code which I would rather not do.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>386991</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 19 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1unzb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>387254</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>