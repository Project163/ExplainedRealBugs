diff --git a/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java b/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
index 8ff353fb..30e729c1 100644
--- a/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
+++ b/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
@@ -1152,12 +1152,21 @@ public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements Keyed
                                 }
                             } catch(InterruptedException e) {
                                 synchronized (this) {
-                                    // Make sure allocate hasn't already assigned an object
-                                    // in a different thread or permitted a new object to be created
+                                    // Need to handle the all three possibilities
                                     if (latch.getPair() == null && !latch.mayCreate()) {
+                                        // Case 1: latch still in allocation queue
+                                        // Remove latch from the allocation queue
                                         _allocationQueue.remove(latch);
+                                    } else if (latch.getPair() == null && latch.mayCreate()) {
+                                        // Case 2: latch has been given permission to create
+                                        //         a new object
+                                        latch.getPool().decrementInternalProcessingCount();
+                                        allocate();
                                     } else {
-                                        break;
+                                        // Case 3: An object has been allocated
+                                        latch.getPool().decrementInternalProcessingCount();
+                                        latch.getPool().incrementActiveCount();
+                                        returnObject(latch.getkey(), latch.getPair().getValue());
                                     }
                                 }
                                 Thread.currentThread().interrupt();
diff --git a/src/java/org/apache/commons/pool/impl/GenericObjectPool.java b/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
index 4f35889f..24b6971e 100644
--- a/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
+++ b/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
@@ -1118,13 +1118,21 @@ public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
                                 }
                             } catch(InterruptedException e) {
                                 synchronized(this) {
-                                    // Make sure allocate hasn't already assigned an object
-                                    // in a different thread or permitted a new object to be created
+                                    // Need to handle the all three possibilities
                                     if (latch.getPair() == null && !latch.mayCreate()) {
+                                        // Case 1: latch still in allocation queue
                                         // Remove latch from the allocation queue
                                         _allocationQueue.remove(latch);
+                                    } else if (latch.getPair() == null && latch.mayCreate()) {
+                                        // Case 2: latch has been given permission to create
+                                        //         a new object
+                                        _numInternalProcessing--;
+                                        allocate();
                                     } else {
-                                        break;
+                                        // Case 3: An object has been allocated
+                                        _numInternalProcessing--;
+                                        _numActive++;
+                                        returnObject(latch.getPair().getValue());
                                     }
                                 }
                                 Thread.currentThread().interrupt();
