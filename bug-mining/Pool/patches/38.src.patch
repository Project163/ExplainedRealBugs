diff --git a/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java b/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
index d43f9642..dd21735b 100644
--- a/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
+++ b/src/java/org/apache/commons/pool/impl/GenericKeyedObjectPool.java
@@ -1127,17 +1127,22 @@ public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements Keyed
                         case WHEN_EXHAUSTED_BLOCK:
                             try {
                                 synchronized (latch) {
-                                    if (maxWait <= 0) {
-                                        latch.wait();
-                                    } else {
-                                        // this code may be executed again after a notify then continue cycle
-                                        // so, need to calculate the amount of time to wait
-                                        final long elapsed = (System.currentTimeMillis() - starttime);
-                                        final long waitTime = maxWait - elapsed;
-                                        if (waitTime > 0)
-                                        {
-                                            latch.wait(waitTime);
+                                    // Before we wait, make sure another thread didn't allocate us an object
+                                    if (latch.getPair() == null) {
+                                        if (maxWait <= 0) {
+                                            latch.wait();
+                                        } else {
+                                            // this code may be executed again after a notify then continue cycle
+                                            // so, need to calculate the amount of time to wait
+                                            final long elapsed = (System.currentTimeMillis() - starttime);
+                                            final long waitTime = maxWait - elapsed;
+                                            if (waitTime > 0)
+                                            {
+                                                latch.wait(waitTime);
+                                            }
                                         }
+                                    } else {
+                                        break;
                                     }
                                 }
                             } catch(InterruptedException e) {
diff --git a/src/java/org/apache/commons/pool/impl/GenericObjectPool.java b/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
index bb45fc55..5416c648 100644
--- a/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
+++ b/src/java/org/apache/commons/pool/impl/GenericObjectPool.java
@@ -1095,17 +1095,22 @@ public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
                         case WHEN_EXHAUSTED_BLOCK:
                             try {
                                 synchronized (latch) {
-                                    if(maxWait <= 0) {
-                                        latch.wait();
-                                    } else {
-                                        // this code may be executed again after a notify then continue cycle
-                                        // so, need to calculate the amount of time to wait
-                                        final long elapsed = (System.currentTimeMillis() - starttime);
-                                        final long waitTime = maxWait - elapsed;
-                                        if (waitTime > 0)
-                                        {
-                                            latch.wait(waitTime);
+                                    // Before we wait, make sure another thread didn't allocate us an object
+                                    if (latch.getPair() == null) {
+                                        if(maxWait <= 0) {
+                                            latch.wait();
+                                        } else {
+                                            // this code may be executed again after a notify then continue cycle
+                                            // so, need to calculate the amount of time to wait
+                                            final long elapsed = (System.currentTimeMillis() - starttime);
+                                            final long waitTime = maxWait - elapsed;
+                                            if (waitTime > 0)
+                                            {
+                                                latch.wait(waitTime);
+                                            }
                                         }
+                                    } else {
+                                        break;
                                     }
                                 }
                             } catch(InterruptedException e) {
diff --git a/xdocs/changes.xml b/xdocs/changes.xml
index 23161d46..98f525d9 100644
--- a/xdocs/changes.xml
+++ b/xdocs/changes.xml
@@ -23,6 +23,10 @@
   <body>
 
   <release version="1.5.2" date="TBD">
+    <action dev="markt" type="fix" issue="POOL-147" due-to="Giambattista Bloisi">
+      Fix case where a thread could end up waiting indefinitely even if objects
+      were available.
+    </action>
   </release>
   <release version="1.5.1" date="2009-06-16" description=
 "This is a patch release containing a fix for POOL-144, a regression introduced
