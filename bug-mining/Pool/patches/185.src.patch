diff --git a/src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java b/src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
index 2ac96297..15451597 100644
--- a/src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
+++ b/src/main/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
@@ -144,10 +144,10 @@ public class GenericKeyedObjectPool<K, T, E extends Exception> extends BaseGener
         }
 
         /**
-         * Gets the count of the number of objects created for the current
-         * key.
+         * Gets the number of instances created - number destroyed.
+         * Should always be less than or equal to maxTotalPerKey.
          *
-         * @return The number of objects created for this key
+         * @return The net instance addition count for this deque
          */
         public AtomicInteger getCreateCount() {
             return createCount;
@@ -295,6 +295,7 @@ public class GenericKeyedObjectPool<K, T, E extends Exception> extends BaseGener
 
     /**
      * Add an object to the set of idle objects for a given key.
+     * If the object is null this is a no-op.
      *
      * @param key The key to associate with the idle object
      * @param p The wrapped object to add.
@@ -601,6 +602,10 @@ public class GenericKeyedObjectPool<K, T, E extends Exception> extends BaseGener
      * @param reuseCapacity whether or not to reuse freed capacity
      */
     public void clear(final K key, final boolean reuseCapacity) {
+        // Return immediately if there is no pool under this key.
+        if (poolMap.get(key) == null) {
+            return;
+        }
         final ObjectDeque<T> objectDeque = register(key);
         int freedCapacity = 0;
         try {
@@ -1504,8 +1509,7 @@ public class GenericKeyedObjectPool<K, T, E extends Exception> extends BaseGener
             }
 
             final int maxIdle = getMaxIdlePerKey();
-            final LinkedBlockingDeque<PooledObject<T>> idleObjects =
-                    objectDeque.getIdleObjects();
+            final LinkedBlockingDeque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();
 
             if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
                 try {
@@ -1549,43 +1553,47 @@ public class GenericKeyedObjectPool<K, T, E extends Exception> extends BaseGener
      */
     private void reuseCapacity() {
         final int maxTotalPerKeySave = getMaxTotalPerKey();
+        int maxQueueLength = 0;
+        LinkedBlockingDeque<PooledObject<T>> mostLoadedPool = null;
+        K mostLoadedKey = null;
 
         // Find the most loaded pool that could take a new instance
-        int maxQueueLength = 0;
-        LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
-        K loadedKey = null;
-        for (final Entry<K, GenericKeyedObjectPool.ObjectDeque<T>> entry : poolMap.entrySet()) {
+        for (final Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
             final K k = entry.getKey();
-            final ObjectDeque<T> deque = entry.getValue();
-            final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
+            final LinkedBlockingDeque<PooledObject<T>> pool = entry.getValue().getIdleObjects();
             final int queueLength = pool.getTakeQueueLength();
             if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
                 maxQueueLength = queueLength;
-                mostLoaded = pool;
-                loadedKey = k;
+                mostLoadedPool = pool;
+                mostLoadedKey = k;
             }
         }
 
-        // Attempt to add an instance to the most loaded pool
-        if (mostLoaded != null) {
-            register(loadedKey);
+        // Attempt to add an instance to the most loaded pool.
+        if (mostLoadedPool != null) {
+            register(mostLoadedKey);
             try {
-                addIdleObject(loadedKey, create(loadedKey));
+                // If there is no capacity to add, create will return null
+                // and addIdleObject will no-op.
+                addIdleObject(mostLoadedKey, create(mostLoadedKey));
             } catch (final Exception e) {
                 swallowException(e);
             } finally {
-                deregister(loadedKey);
+                deregister(mostLoadedKey);
             }
         }
     }
 
     /**
      * Call {@link #reuseCapacity()} repeatedly.
+     * <p>
+     * Always activates {@link #reuseCapacity()} at least once.
      *
      * @param newCapacity number of new instances to attempt to create.
      */
     private void reuseCapacity(final int newCapacity) {
-        for (int i = 0; i < newCapacity; i++) {
+        final int bound = newCapacity < 1 ? 1 : newCapacity;
+        for (int i = 0; i < bound; i++) {
             reuseCapacity();
         }
     }
diff --git a/src/test/java/org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java b/src/test/java/org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java
index 9358b64f..89ae5abf 100644
--- a/src/test/java/org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java
+++ b/src/test/java/org/apache/commons/pool2/impl/TestGenericKeyedObjectPool.java
@@ -1186,18 +1186,14 @@ public class TestGenericKeyedObjectPool extends TestKeyedObjectPool {
 
     /**
      * POOL-391 Adapted from code in the JIRA ticket.
-     *
-     * @throws Exception May occur in some failure modes
      */
     @Test
-    @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)
-    public void testClearUnblocksWaiters() {
+    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
+    public void testClearUnblocksWaiters() throws Exception {
         final GenericKeyedObjectPoolConfig<Integer> config = new GenericKeyedObjectPoolConfig<>();
         config.setMaxTotalPerKey(1);
-        config.setMinIdlePerKey(0);
-        config.setMaxIdlePerKey(-1);
-        config.setMaxTotal(-1);
-        config.setMaxWait(Duration.ofMillis(5));
+        config.setMaxTotal(1);
+        config.setMaxWait(Duration.ofMillis(500));
         final GenericKeyedObjectPool<Integer, Integer, InterruptedException> testPool = new GenericKeyedObjectPool<>(
                 new KeyedPooledObjectFactory<Integer, Integer, InterruptedException>() {
                     @Override
@@ -1206,8 +1202,9 @@ public class TestGenericKeyedObjectPool extends TestKeyedObjectPool {
                     }
 
                     @Override
-                    public void destroyObject(final Integer key, final PooledObject<Integer> p) throws InterruptedException {
-                        Thread.sleep(500);
+                    public void destroyObject(final Integer key, final PooledObject<Integer> p)
+                            throws InterruptedException {
+                        Thread.sleep(10);
                     }
 
                     @Override
@@ -1225,30 +1222,35 @@ public class TestGenericKeyedObjectPool extends TestKeyedObjectPool {
                         return true;
                     }
                 }, config);
-        final int borrowKey = 10;
+        final Integer borrowKey = 10;
+        final int iterations = 100;
+        final ExecutorService executor = Executors.newFixedThreadPool(2);
         final Thread t = new Thread(() -> {
             try {
-                while (true) {
+                for (int i = 0; i < iterations; i++) {
                     final Integer integer = testPool.borrowObject(borrowKey);
                     testPool.returnObject(borrowKey, integer);
                     Thread.sleep(10);
                 }
+
             } catch (final Exception e) {
-                fail();
+                fail(e);
             }
         });
         final Thread t2 = new Thread(() -> {
             try {
-                while (true) {
+                for (int i = 0; i < iterations; i++) {
                     testPool.clear(borrowKey);
                     Thread.sleep(10);
                 }
             } catch (final Exception e) {
-                fail();
+                fail(e);
             }
         });
-        t.start();
-        t2.start();
+        final Future<?> f1 = executor.submit(t);
+        final Future<?> f2 = executor.submit(t2);
+        f2.get();
+        f1.get();
     }
 
     // POOL-259
