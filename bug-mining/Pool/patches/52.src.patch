diff --git a/src/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java b/src/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
index 8371424c..65058b49 100644
--- a/src/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
+++ b/src/java/org/apache/commons/pool2/impl/GenericKeyedObjectPool.java
@@ -747,12 +747,21 @@ public class GenericKeyedObjectPool<K,V> extends BaseKeyedObjectPool<K,V> implem
                                 }
                             } catch(InterruptedException e) {
                                 synchronized (this) {
-                                    // Make sure allocate hasn't already assigned an object
-                                    // in a different thread or permitted a new object to be created
+                                    // Need to handle the all three possibilities
                                     if (latch.getPair() == null && !latch.mayCreate()) {
+                                        // Case 1: latch still in allocation queue
+                                        // Remove latch from the allocation queue
                                         _allocationQueue.remove(latch);
+                                    } else if (latch.getPair() == null && latch.mayCreate()) {
+                                        // Case 2: latch has been given permission to create
+                                        //         a new object
+                                        latch.getPool().decrementInternalProcessingCount();
+                                        allocate();
                                     } else {
-                                        break;
+                                        // Case 3: An object has been allocated
+                                        latch.getPool().decrementInternalProcessingCount();
+                                        latch.getPool().incrementActiveCount();
+                                        returnObject(latch.getkey(), latch.getPair().getValue());
                                     }
                                 }
                                 Thread.currentThread().interrupt();
diff --git a/src/java/org/apache/commons/pool2/impl/GenericObjectPool.java b/src/java/org/apache/commons/pool2/impl/GenericObjectPool.java
index fff4fc6c..a294ec2b 100644
--- a/src/java/org/apache/commons/pool2/impl/GenericObjectPool.java
+++ b/src/java/org/apache/commons/pool2/impl/GenericObjectPool.java
@@ -720,13 +720,21 @@ public class GenericObjectPool<T> extends BaseObjectPool<T> implements GenericOb
                                 }
                             } catch(InterruptedException e) {
                                 synchronized(this) {
-                                    // Make sure allocate hasn't already assigned an object
-                                    // in a different thread or permitted a new object to be created
+                                    // Need to handle the all three possibilities
                                     if (latch.getPair() == null && !latch.mayCreate()) {
+                                        // Case 1: latch still in allocation queue
                                         // Remove latch from the allocation queue
                                         _allocationQueue.remove(latch);
+                                    } else if (latch.getPair() == null && latch.mayCreate()) {
+                                        // Case 2: latch has been given permission to create
+                                        //         a new object
+                                        _numInternalProcessing--;
+                                        allocate();
                                     } else {
-                                        break;
+                                        // Case 3: An object has been allocated
+                                        _numInternalProcessing--;
+                                        _numActive++;
+                                        returnObject(latch.getPair().getValue());
                                     }
                                 }
                                 Thread.currentThread().interrupt();
