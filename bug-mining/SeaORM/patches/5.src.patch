diff --git a/sea-orm-macros/src/derives/model_ex.rs b/sea-orm-macros/src/derives/model_ex.rs
index 1ee2d4c1..b0e3f524 100644
--- a/sea-orm-macros/src/derives/model_ex.rs
+++ b/sea-orm-macros/src/derives/model_ex.rs
@@ -7,7 +7,7 @@ use proc_macro2::{Ident, Span, TokenStream};
 use quote::{format_ident, quote};
 use std::collections::{BTreeMap, HashMap};
 use syn::{
-    Attribute, Data, Expr, Fields, ItemStruct, Lit, LitStr, Meta, Type, parse_quote,
+    Attribute, Data, Expr, Fields, ItemStruct, Lit, Meta, Type, parse_quote,
     punctuated::Punctuated, token::Comma,
 };
 
@@ -86,7 +86,6 @@ pub fn expand_derive_model_ex(
     data: Data,
     attrs: Vec<Attribute>,
 ) -> syn::Result<TokenStream> {
-    let mut table_name = None;
     let mut compact = false;
     let mut model_fields: Vec<Ident> = Vec::new();
     let mut compound_fields: Vec<Ident> = Vec::new();
@@ -99,10 +98,11 @@ pub fn expand_derive_model_ex(
         .filter(|attr| attr.path().is_ident("sea_orm"))
         .try_for_each(|attr| {
             attr.parse_nested_meta(|meta| {
-                if meta.path.is_ident("table_name") {
-                    table_name = Some(meta.value()?.parse::<LitStr>()?);
-                } else if meta.path.is_ident("compact_model") {
+                if meta.path.is_ident("compact_model") {
                     compact = true;
+                } else {
+                    // Reads the value expression to advance the parse stream.
+                    let _: Option<Expr> = meta.value().and_then(|v| v.parse()).ok();
                 }
                 Ok(())
             })
@@ -262,7 +262,7 @@ pub fn expand_derive_model_ex(
             }
             if *seen.get(field_type).unwrap() == 1 {
                 // prevent impl trait for same entity twice
-                ts.extend(expand_impl_related_trait(attrs, field_type, &table_name)?);
+                ts.extend(expand_impl_related_trait(attrs, field_type)?);
             }
         }
 
@@ -474,46 +474,36 @@ fn related_entity_enum_variant(
     (first, second)
 }
 
-fn expand_impl_related_trait(
-    attr: &compound_attr::SeaOrm,
-    ty: &str,
-    table_name: &Option<LitStr>,
-) -> syn::Result<TokenStream> {
+fn expand_impl_related_trait(attr: &compound_attr::SeaOrm, ty: &str) -> syn::Result<TokenStream> {
     if attr.has_one.is_some() || attr.has_many.is_some() || attr.belongs_to.is_some() {
         let (related_entity, relation_enum) = get_related(attr, ty);
         let related_entity: TokenStream = related_entity.parse().unwrap();
 
-        if let Some(via) = &attr.via {
-            let via = via.value();
+        if let Some(via_lit) = &attr.via {
+            let via = via_lit.value();
             let mut junction = via.as_str();
-            let via_related = table_name
-                .as_ref()
-                .map(|v| v.value().to_upper_camel_case())
-                .unwrap_or_default();
-            let mut via_related = via_related.as_str();
+            let mut via_related = "";
             if let Some((prefix, suffix)) = via.split_once("::") {
                 junction = prefix;
                 via_related = suffix;
             }
-            if via_related.is_empty() {
-                return Err(syn::Error::new_spanned(
-                    attr.via.as_ref().unwrap(),
-                    "Please provide via in `my_entity::RelationVariant`",
-                ));
-            }
-            let junction = Ident::new(junction, Span::call_site());
-            let relation_def = quote!(Relation::#relation_enum.def());
-            let via_relation_def: TokenStream =
-                format!("Relation::{via_related}.def()").parse().unwrap();
+            let junction = Ident::new(junction, via_lit.span());
+            let relation_def = quote!(super::#junction::Relation::#relation_enum.def());
+            let via_relation_def: TokenStream = if !via_related.is_empty() {
+                let via_related = Ident::new(via_related, via_lit.span());
+                quote!(super::#junction::Relation::#via_related.def().rev())
+            } else {
+                quote!(<super::#junction::Entity as Related<Entity>>::to().rev())
+            };
 
             Ok(quote! {
                 #[doc = " Generated by sea-orm-macros"]
                 impl Related<#related_entity> for Entity {
                     fn to() -> RelationDef {
-                        super::#junction::#relation_def
+                        #relation_def
                     }
                     fn via() -> Option<RelationDef> {
-                        Some(super::#junction::#via_relation_def.rev())
+                        Some(#via_relation_def)
                     }
                 }
             })
diff --git a/src/tests_cfg/cake_filling.rs b/src/tests_cfg/cake_filling.rs
index fae03f4f..98186532 100644
--- a/src/tests_cfg/cake_filling.rs
+++ b/src/tests_cfg/cake_filling.rs
@@ -1,70 +1,45 @@
 use crate as sea_orm;
-use crate::entity::prelude::*;
+use sea_orm::entity::prelude::*;
 
-#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
-pub struct Entity;
-
-impl EntityName for Entity {
-    fn table_name(&self) -> &'static str {
-        "cake_filling"
-    }
-}
-
-#[derive(Clone, Debug, PartialEq, Eq, DeriveModel, DeriveActiveModel)]
+#[sea_orm::compact_model]
+#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
+#[sea_orm(table_name = "cake_filling")]
 pub struct Model {
+    #[sea_orm(primary_key, auto_increment = false)]
     pub cake_id: i32,
+    #[sea_orm(primary_key, auto_increment = false)]
     pub filling_id: i32,
 }
 
-#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
-pub enum Column {
-    CakeId,
-    FillingId,
-}
-
-#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
-pub enum PrimaryKey {
-    CakeId,
-    FillingId,
-}
-
-impl PrimaryKeyTrait for PrimaryKey {
-    type ValueType = (i32, i32);
-
-    fn auto_increment() -> bool {
-        false
-    }
-}
-
-#[derive(Copy, Clone, Debug, EnumIter)]
+#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
 pub enum Relation {
+    #[sea_orm(
+        belongs_to = "super::cake::Entity",
+        from = "Column::CakeId",
+        to = "super::cake::Column::Id",
+        on_update = "Cascade",
+        on_delete = "Cascade",
+    )]
     Cake,
+    #[sea_orm(
+        belongs_to = "super::filling::Entity",
+        from = "Column::FillingId",
+        to = "super::filling::Column::Id",
+        on_update = "Cascade",
+        on_delete = "Cascade",
+    )]
     Filling,
 }
 
-impl ColumnTrait for Column {
-    type EntityName = Entity;
-
-    fn def(&self) -> ColumnDef {
-        match self {
-            Self::CakeId => ColumnType::Integer.def(),
-            Self::FillingId => ColumnType::Integer.def(),
-        }
+impl Related<super::cake::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::Cake.def()
     }
 }
 
-impl RelationTrait for Relation {
-    fn def(&self) -> RelationDef {
-        match self {
-            Self::Cake => Entity::belongs_to(super::cake::Entity)
-                .from(Column::CakeId)
-                .to(super::cake::Column::Id)
-                .into(),
-            Self::Filling => Entity::belongs_to(super::filling::Entity)
-                .from(Column::FillingId)
-                .to(super::filling::Column::Id)
-                .into(),
-        }
+impl Related<super::filling::Entity> for Entity {
+    fn to() -> RelationDef {
+        Relation::Filling.def()
     }
 }
 
