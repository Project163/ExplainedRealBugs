diff --git a/src/main/java/com/jcabi/aether/Aether.java b/src/main/java/com/jcabi/aether/Aether.java
index 390b2e2..78476ef 100644
--- a/src/main/java/com/jcabi/aether/Aether.java
+++ b/src/main/java/com/jcabi/aether/Aether.java
@@ -39,7 +39,6 @@ import java.util.List;
 import javax.validation.constraints.NotNull;
 import lombok.EqualsAndHashCode;
 import lombok.ToString;
-import org.apache.maven.project.DependencyResolutionException;
 import org.apache.maven.project.MavenProject;
 import org.apache.maven.repository.internal.MavenRepositorySystemSession;
 import org.sonatype.aether.RepositorySystem;
@@ -53,6 +52,8 @@ import org.sonatype.aether.repository.LocalRepository;
 import org.sonatype.aether.repository.RemoteRepository;
 import org.sonatype.aether.resolution.ArtifactResult;
 import org.sonatype.aether.resolution.DependencyRequest;
+import org.sonatype.aether.resolution.DependencyResolutionException;
+import org.sonatype.aether.resolution.DependencyResult;
 import org.sonatype.aether.util.filter.DependencyFilterUtils;
 
 /**
@@ -177,9 +178,6 @@ public final class Aether {
      * @todo #51 This catch of NPE is a temporary measure. I don't know why
      *  Aether throws NPE in case of non-resolvable artifact. This is the best
      *  I can do at the moment in order to protect clients of the class.
-     * @todo #4 First parameter of DependencyResolutionException should be
-     *  a DependencyResolutionResult, an implementation of this interface has
-     *  to be created and passed to the exception.
      */
     @SuppressWarnings("PMD.AvoidCatchingGenericException")
     private List<Artifact> fetch(final RepositorySystemSession session,
@@ -198,8 +196,7 @@ public final class Aether {
         // @checkstyle IllegalCatch (1 line)
         } catch (Exception ex) {
             throw new DependencyResolutionException(
-                null,
-                "dependency problem",
+                new DependencyResult(dreq),
                 new IllegalArgumentException(
                     Logger.format(
                         "failed to load '%s' from %[list]s into %s",
diff --git a/src/main/java/com/jcabi/aether/Classpath.java b/src/main/java/com/jcabi/aether/Classpath.java
index 5afe225..e893e35 100644
--- a/src/main/java/com/jcabi/aether/Classpath.java
+++ b/src/main/java/com/jcabi/aether/Classpath.java
@@ -43,18 +43,13 @@ import java.util.concurrent.TimeUnit;
 import javax.validation.constraints.NotNull;
 import lombok.EqualsAndHashCode;
 import org.apache.commons.lang3.StringUtils;
-import org.apache.maven.artifact.DefaultArtifact;
 import org.apache.maven.artifact.DependencyResolutionRequiredException;
-import org.apache.maven.artifact.handler.DefaultArtifactHandler;
-import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
-import org.apache.maven.execution.MavenSession;
 import org.apache.maven.model.Dependency;
 import org.apache.maven.project.MavenProject;
-import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
-import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
-import org.apache.maven.shared.dependency.graph.DependencyNode;
-import org.codehaus.plexus.PlexusContainer;
-import org.codehaus.plexus.component.repository.exception.ComponentLookupException;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.resolution.DependencyResolutionException;
+import org.sonatype.aether.util.artifact.DefaultArtifact;
+import org.sonatype.aether.util.artifact.JavaScopes;
 
 /**
  * A classpath of a Maven Project.
@@ -79,7 +74,7 @@ import org.codehaus.plexus.component.repository.exception.ComponentLookupExcepti
  * @see Aether
  * @checkstyle ClassDataAbstractionCoupling (500 lines)
  */
-@EqualsAndHashCode(callSuper = false, of = { "project", "container", "scopes" })
+@EqualsAndHashCode(callSuper = false, of = { "project", "aether", "scopes" })
 @Loggable(
     value = Loggable.DEBUG,
     limit = 1, unit = TimeUnit.MINUTES,
@@ -87,75 +82,43 @@ import org.codehaus.plexus.component.repository.exception.ComponentLookupExcepti
 )
 public final class Classpath extends AbstractSet<File> implements Set<File> {
 
-    /**
-     * Maven test scope.
-     */
-    public static final String TEST_SCOPE = "test";
-
-    /**
-     * Maven runtime scope.
-     */
-    public static final String RUNTIME_SCOPE = "runtime";
-
-    /**
-     * Maven system scope.
-     */
-    public static final String SYSTEM_SCOPE = "system";
-
-    /**
-     * Maven compile scope.
-     */
-    public static final String COMPILE_SCOPE = "compile";
-
-    /**
-     * Maven provided scope.
-     */
-    public static final String PROVIDED_SCOPE = "provided";
     /**
      * Maven Project.
      */
     private final transient MavenProject project;
 
     /**
-     * Artifact scopes to include.
+     * Aether to work with.
      */
-    private final transient Set<String> scopes;
+    private final transient Aether aether;
 
     /**
-     * Plexus container.
-     */
-    private final transient PlexusContainer container;
-
-    /**
-     * The current repository/network configuration of Maven.
+     * Artifact scopes to include.
      */
-    private final transient MavenSession session;
+    private final transient Set<String> scopes;
 
     /**
      * Public ctor.
-     * @param cntnr Plexus container.
-     * @param sess Maven session.
+     * @param prj The Maven project
+     * @param repo Local repository location (directory path)
      * @param scp The scope to use, e.g. "runtime" or "compile"
      */
-    public Classpath(@NotNull final PlexusContainer cntnr,
-        @NotNull final MavenSession sess,
-        @NotNull final String scp) {
-        this(cntnr, sess, Arrays.asList(scp));
+    public Classpath(@NotNull final MavenProject prj,
+        @NotNull final File repo, @NotNull final String scp) {
+        this(prj, repo, Arrays.asList(scp));
     }
 
     /**
      * Public ctor.
-     * @param cntnr Plexus container.
-     * @param sess Maven session.
+     * @param prj The Maven project
+     * @param repo Local repository location (directory path)
      * @param scps All scopes to include
      */
-    public Classpath(@NotNull final PlexusContainer cntnr,
-        @NotNull final MavenSession sess,
-        @NotNull final Collection<String> scps) {
+    public Classpath(@NotNull final MavenProject prj,
+        @NotNull final File repo, @NotNull final Collection<String> scps) {
         super();
-        this.project = sess.getCurrentProject();
-        this.container = cntnr;
-        this.session = sess;
+        this.project = prj;
+        this.aether = new Aether(prj, repo);
         this.scopes = new HashSet<String>(scps);
     }
 
@@ -172,7 +135,11 @@ public final class Classpath extends AbstractSet<File> implements Set<File> {
      */
     @Override
     public Iterator<File> iterator() {
-        return this.fetch().iterator();
+        try {
+            return this.fetch().iterator();
+        } catch (DependencyResolutionException ex) {
+            throw new IllegalStateException(ex);
+        }
     }
 
     /**
@@ -180,42 +147,79 @@ public final class Classpath extends AbstractSet<File> implements Set<File> {
      */
     @Override
     public int size() {
-        return this.fetch().size();
+        try {
+            return this.fetch().size();
+        } catch (DependencyResolutionException ex) {
+            throw new IllegalStateException(ex);
+        }
     }
 
     /**
      * Fetch all files found (JAR, ZIP, directories, etc).
      * @return Set of files
+     * @throws DependencyResolutionException If can't resolve
      */
     @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
-    private Set<File> fetch() {
+    private Set<File> fetch() throws DependencyResolutionException {
         final Set<File> files = new LinkedHashSet<File>(0);
         for (String path : this.elements()) {
             files.add(new File(path));
         }
+        for (Artifact artifact : this.artifacts()) {
+            files.add(artifact.getFile());
+        }
+        return files;
+    }
+
+    /**
+     * Get Maven Project elements.
+     * @return Collection of them
+     */
+    private Collection<String> elements() {
+        final Collection<String> elements = new LinkedList<String>();
         try {
-            final DependencyGraphBuilder builder =
-                (DependencyGraphBuilder) this.container.lookup(
-                    DependencyGraphBuilder.class.getCanonicalName()
-                );
-            final DependencyNode node = builder.buildDependencyGraph(
-                this.project,
-                new ArtifactFilter() {
-                    @Override
-                    public boolean include(
-                        final org.apache.maven.artifact.Artifact artifact) {
-                        return Classpath.this.scopes
-                            .contains(artifact.getScope());
-                    }
+            if (this.scopes.contains(JavaScopes.TEST)) {
+                elements.addAll(this.project.getTestClasspathElements());
+            }
+            if (this.scopes.contains(JavaScopes.RUNTIME)) {
+                elements.addAll(this.project.getRuntimeClasspathElements());
+            }
+            if (this.scopes.contains(JavaScopes.SYSTEM)) {
+                elements.addAll(this.project.getSystemClasspathElements());
+            }
+            if (this.scopes.contains(JavaScopes.COMPILE)
+                || this.scopes.contains(JavaScopes.PROVIDED)) {
+                elements.addAll(this.project.getCompileClasspathElements());
+            }
+        } catch (DependencyResolutionRequiredException ex) {
+            throw new IllegalStateException("Failed to read classpath", ex);
+        }
+        return elements;
+    }
+
+    /**
+     * Set of unique artifacts, which should be available in classpath.
+     *
+     * <p>This method gets a full list of artifacts of the project,
+     * including their transitive dependencies.
+     *
+     * @return The set of artifacts
+     * @throws DependencyResolutionException If can't resolve some of them
+     */
+    private Set<Artifact> artifacts() throws DependencyResolutionException {
+        final Set<Artifact> artifacts = new LinkedHashSet<Artifact>(0);
+        for (RootArtifact root : this.roots()) {
+            for (Artifact child : root.children()) {
+                if (Classpath.contains(child, artifacts)) {
+                    continue;
                 }
-            );
-            files.addAll(this.dependencies(node, this.scopes));
-        } catch (DependencyGraphBuilderException ex) {
-            throw new IllegalStateException(ex);
-        } catch (ComponentLookupException ex) {
-            throw new IllegalStateException(ex);
+                if (root.excluded(child)) {
+                    continue;
+                }
+                artifacts.add(child);
+            }
         }
-        return files;
+        return artifacts;
     }
 
     /**
@@ -245,71 +249,37 @@ public final class Classpath extends AbstractSet<File> implements Set<File> {
      */
     private RootArtifact root(final Dependency dep) {
         return new RootArtifact(
+            this.aether,
             new DefaultArtifact(
                 dep.getGroupId(),
                 dep.getArtifactId(),
-                dep.getVersion(),
-                dep.getScope(),
-                dep.getType(),
                 dep.getClassifier(),
-                new DefaultArtifactHandler()
+                dep.getType(),
+                dep.getVersion()
             ),
             dep.getExclusions()
         );
     }
 
     /**
-     * Get Maven Project elements.
-     * @return Collection of them
+     * Artifact exists in collection?
+     * @param artifact The artifact
+     * @param artifacts Collection of them
+     * @return TRUE if it is already there
      */
-    private Collection<String> elements() {
-        final Collection<String> elements = new LinkedList<String>();
-        try {
-            if (this.scopes.contains(TEST_SCOPE)) {
-                elements.addAll(this.project.getTestClasspathElements());
-            }
-            if (this.scopes.contains(RUNTIME_SCOPE)) {
-                elements.addAll(this.project.getRuntimeClasspathElements());
+    private static boolean contains(final Artifact artifact,
+        final Collection<Artifact> artifacts) {
+        boolean contains = false;
+        for (Artifact exists : artifacts) {
+            if (artifact.getArtifactId().equals(exists.getArtifactId())
+                && artifact.getGroupId().equals(exists.getGroupId())
+                && artifact.getClassifier().equals(exists.getClassifier())) {
+                contains = true;
+                break;
             }
-            if (this.scopes.contains(SYSTEM_SCOPE)) {
-                elements.addAll(this.project.getSystemClasspathElements());
-            }
-            if (this.scopes.contains(COMPILE_SCOPE)
-                || this.scopes.contains(PROVIDED_SCOPE)) {
-                elements.addAll(this.project.getCompileClasspathElements());
-            }
-        } catch (DependencyResolutionRequiredException ex) {
-            throw new IllegalStateException("Failed to read classpath", ex);
         }
-        return elements;
+        return contains;
     }
 
-    /**
-     * Retrieve dependencies for from given node and scope.
-     * @param node Node to traverse.
-     * @param scps Scopes to use.
-     * @return Collection of dependency files.
-     */
-    private Collection<File> dependencies(final DependencyNode node,
-        final Collection<String> scps) {
-        final org.apache.maven.artifact.Artifact artifact = node.getArtifact();
-        final Collection<File> files = new LinkedList<File>();
-        if ((artifact.getScope() == null)
-            || scps.contains(artifact.getScope())) {
-            if (artifact.getScope() == null) {
-                files.add(artifact.getFile());
-            } else {
-                files.add(
-                    this.session.getLocalRepository().find(artifact).getFile()
-                );
-            }
-            for (DependencyNode child : node.getChildren()) {
-                if (child.getArtifact().compareTo(node.getArtifact()) != 0) {
-                    files.addAll(this.dependencies(child, scps));
-                }
-            }
-        }
-        return files;
-    }
 }
 
diff --git a/src/main/java/com/jcabi/aether/MavenClasspath.java b/src/main/java/com/jcabi/aether/MavenClasspath.java
new file mode 100644
index 0000000..010ac50
--- /dev/null
+++ b/src/main/java/com/jcabi/aether/MavenClasspath.java
@@ -0,0 +1,299 @@
+/**
+ * Copyright (c) 2012-2013, JCabi.com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 1) Redistributions of source code must retain the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer. 2) Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution. 3) Neither the name of the jcabi.com nor
+ * the names of its contributors may be used to endorse or promote
+ * products derived from this software without specific prior written
+ * permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.jcabi.aether;
+
+import com.jcabi.aspects.Loggable;
+import java.io.File;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import javax.validation.constraints.NotNull;
+import lombok.EqualsAndHashCode;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.maven.artifact.DefaultArtifact;
+import org.apache.maven.artifact.DependencyResolutionRequiredException;
+import org.apache.maven.artifact.handler.DefaultArtifactHandler;
+import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
+import org.apache.maven.execution.MavenSession;
+import org.apache.maven.model.Dependency;
+import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
+import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
+import org.apache.maven.shared.dependency.graph.DependencyNode;
+
+/**
+ * A classpath of a Maven Project.
+ *
+ * @author Krzysztof Krason (Krzysztof.Krason@gmail.com)
+ * @version $Id$
+ * @checkstyle ClassDataAbstractionCoupling (500 lines)
+ */
+@EqualsAndHashCode(callSuper = false, of = { "builder", "scopes" })
+@Loggable(
+    value = Loggable.DEBUG,
+    limit = 1, unit = TimeUnit.MINUTES,
+    trim = false
+)
+public final class MavenClasspath extends AbstractSet<File> implements
+    Set<File> {
+
+    /**
+     * Maven test scope.
+     */
+    public static final String TEST_SCOPE = "test";
+
+    /**
+     * Maven runtime scope.
+     */
+    public static final String RUNTIME_SCOPE = "runtime";
+
+    /**
+     * Maven system scope.
+     */
+    public static final String SYSTEM_SCOPE = "system";
+
+    /**
+     * Maven compile scope.
+     */
+    public static final String COMPILE_SCOPE = "compile";
+
+    /**
+     * Maven provided scope.
+     */
+    public static final String PROVIDED_SCOPE = "provided";
+
+    /**
+     * Artifact scopes to include.
+     */
+    private final transient Set<String> scopes;
+
+    /**
+     * Dependency graph builder.
+     */
+    private final transient DependencyGraphBuilder builder;
+
+    /**
+     * The current repository/network configuration of Maven.
+     */
+    private final transient MavenSession session;
+
+    /**
+     * Public ctor.
+     * @param bldr Dependency graph builder.
+     * @param sess Maven session.
+     * @param scp The scope to use, e.g. "runtime" or "compile"
+     */
+    public MavenClasspath(@NotNull final DependencyGraphBuilder bldr,
+        @NotNull final MavenSession sess,
+        @NotNull final String scp) {
+        this(bldr, sess, Arrays.asList(scp));
+    }
+
+    /**
+     * Public ctor.
+     * @param bldr Dependency graph builder.
+     * @param sess Maven session.
+     * @param scps All scopes to include
+     */
+    public MavenClasspath(@NotNull final DependencyGraphBuilder bldr,
+        @NotNull final MavenSession sess,
+        @NotNull final Collection<String> scps) {
+        super();
+        this.builder = bldr;
+        this.session = sess;
+        this.scopes = new HashSet<String>(scps);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return StringUtils.join(this.roots(), "\n");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<File> iterator() {
+        return this.fetch().iterator();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int size() {
+        return this.fetch().size();
+    }
+
+    /**
+     * Fetch all files found (JAR, ZIP, directories, etc).
+     * @return Set of files
+     */
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+    private Set<File> fetch() {
+        final Set<File> files = new LinkedHashSet<File>(0);
+        for (String path : this.elements()) {
+            files.add(new File(path));
+        }
+        try {
+            final DependencyNode node = this.builder.buildDependencyGraph(
+                this.session.getCurrentProject(),
+                new ArtifactFilter() {
+                    @Override
+                    public boolean include(
+                        final org.apache.maven.artifact.Artifact artifact) {
+                        return MavenClasspath.this.scopes
+                            .contains(artifact.getScope());
+                    }
+                }
+            );
+            files.addAll(this.dependencies(node, this.scopes));
+        } catch (DependencyGraphBuilderException ex) {
+            throw new IllegalStateException(ex);
+        }
+        return files;
+    }
+
+    /**
+     * Convert dependencies to root artifacts.
+     *
+     * <p>The method is getting a list of artifacts from Maven Project, without
+     * their transitive dependencies (that's why they are called "root"
+     * artifacts).
+     *
+     * @return The set of root artifacts
+     */
+    private Set<MavenRootArtifact> roots() {
+        final Set<MavenRootArtifact> roots =
+            new LinkedHashSet<MavenRootArtifact>(0);
+        for (Dependency dep
+            : this.session.getCurrentProject().getDependencies()) {
+            if (!this.scopes.contains(dep.getScope())) {
+                continue;
+            }
+            roots.add(this.root(dep));
+        }
+        return roots;
+    }
+
+    /**
+     * Convert dependency to root artifact.
+     * @param dep Dependency
+     * @return Root artifact
+     */
+    private MavenRootArtifact root(final Dependency dep) {
+        return new MavenRootArtifact(
+            new DefaultArtifact(
+                dep.getGroupId(),
+                dep.getArtifactId(),
+                dep.getVersion(),
+                dep.getScope(),
+                dep.getType(),
+                dep.getClassifier(),
+                new DefaultArtifactHandler()
+            ),
+            dep.getExclusions()
+        );
+    }
+
+    /**
+     * Get Maven Project elements.
+     * @return Collection of them
+     */
+    private Collection<String> elements() {
+        final Collection<String> elements = new LinkedList<String>();
+        try {
+            if (this.scopes.contains(TEST_SCOPE)) {
+                elements.addAll(
+                    this.session.getCurrentProject().getTestClasspathElements()
+                );
+            }
+            if (this.scopes.contains(RUNTIME_SCOPE)) {
+                elements.addAll(
+                    this.session.getCurrentProject()
+                        .getRuntimeClasspathElements()
+                );
+            }
+            if (this.scopes.contains(SYSTEM_SCOPE)) {
+                elements.addAll(
+                    this.session.getCurrentProject()
+                        .getSystemClasspathElements()
+                );
+            }
+            if (this.scopes.contains(COMPILE_SCOPE)
+                || this.scopes.contains(PROVIDED_SCOPE)) {
+                elements.addAll(
+                    this.session.getCurrentProject()
+                        .getCompileClasspathElements()
+                );
+            }
+        } catch (DependencyResolutionRequiredException ex) {
+            throw new IllegalStateException("Failed to read classpath", ex);
+        }
+        return elements;
+    }
+
+    /**
+     * Retrieve dependencies for from given node and scope.
+     * @param node Node to traverse.
+     * @param scps Scopes to use.
+     * @return Collection of dependency files.
+     */
+    private Collection<File> dependencies(final DependencyNode node,
+        final Collection<String> scps) {
+        final org.apache.maven.artifact.Artifact artifact = node.getArtifact();
+        final Collection<File> files = new LinkedList<File>();
+        if ((artifact.getScope() == null)
+            || scps.contains(artifact.getScope())) {
+            if (artifact.getScope() == null) {
+                files.add(artifact.getFile());
+            } else {
+                files.add(
+                    this.session.getLocalRepository().find(artifact).getFile()
+                );
+            }
+            for (DependencyNode child : node.getChildren()) {
+                if (child.getArtifact().compareTo(node.getArtifact()) != 0) {
+                    files.addAll(this.dependencies(child, scps));
+                }
+            }
+        }
+        return files;
+    }
+}
+
diff --git a/src/main/java/com/jcabi/aether/MavenRootArtifact.java b/src/main/java/com/jcabi/aether/MavenRootArtifact.java
new file mode 100644
index 0000000..4f506ba
--- /dev/null
+++ b/src/main/java/com/jcabi/aether/MavenRootArtifact.java
@@ -0,0 +1,140 @@
+/**
+ * Copyright (c) 2012-2013, JCabi.com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 1) Redistributions of source code must retain the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer. 2) Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution. 3) Neither the name of the jcabi.com nor
+ * the names of its contributors may be used to endorse or promote
+ * products derived from this software without specific prior written
+ * permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.jcabi.aether;
+
+import com.jcabi.aspects.Cacheable;
+import com.jcabi.log.Logger;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import javax.validation.constraints.NotNull;
+import lombok.EqualsAndHashCode;
+import org.apache.maven.artifact.Artifact;
+import org.apache.maven.model.Exclusion;
+
+/**
+ * One root artifact found in the project.
+ *
+ * @author Yegor Bugayenko (yegor@tpc2.com)
+ * @version $Id$
+ * @since 0.7.16
+ */
+@EqualsAndHashCode(of = { "art", "exclusions" })
+final class MavenRootArtifact {
+
+    /**
+     * The artifact.
+     */
+    @NotNull
+    private final transient Artifact art;
+
+    /**
+     * Exclusions.
+     */
+    @NotNull
+    private final transient Collection<Exclusion> exclusions;
+
+    /**
+     * Ctor.
+     * @param artifact The artifact
+     * @param excl Exclusions
+     */
+    protected MavenRootArtifact(@NotNull final Artifact artifact,
+        @NotNull final List<Exclusion> excl) {
+        this.art = artifact;
+        this.exclusions = excl;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder text = new StringBuilder();
+        text.append(
+            Logger.format(
+                "%s:%s:%s:",
+                this.art.getGroupId(),
+                this.art.getArtifactId(),
+                this.art.getVersion(),
+                this.exclusions.size()
+            )
+        );
+        for (Artifact child : this.children()) {
+            text.append("\n  ").append(child);
+            if (this.excluded(child)) {
+                text.append(" (excluded)");
+            }
+        }
+        return text.toString();
+    }
+
+    /**
+     * Get artifact.
+     * @return The artifact
+     */
+    public Artifact artifact() {
+        return this.art;
+    }
+
+    /**
+     * Get all dependencies of this root artifact.
+     * @return The list of artifacts
+     * @todo #4 Retrieve list of children of given artifact from repository that
+     *  will not depend on sonatype aether or eclipse aether.
+     *  Test ClasspathTest.hasToStringWithBrokenDependency and
+     *  RootArtifactTest.gracefullyResolvesBrokenRootArtifact and
+     *  RootArtifactTest.resolvesRootArtifact should pass when
+     *  the method is updated to work in new eclipse aether.
+     */
+    @Cacheable(forever = true)
+    @SuppressWarnings("unchecked")
+    public Collection<Artifact> children() {
+        return Collections.emptyList();
+    }
+
+    /**
+     * Is this one should be excluded?
+     * @param artifact The artifact to check
+     * @return TRUE if it should be excluded
+     */
+    public boolean excluded(@NotNull final Artifact artifact) {
+        boolean excluded = false;
+        for (Exclusion exclusion : this.exclusions) {
+            if (exclusion.getArtifactId().equals(artifact.getArtifactId())
+                && exclusion.getGroupId().equals(artifact.getGroupId())) {
+                excluded = true;
+                break;
+            }
+        }
+        return excluded;
+    }
+
+}
diff --git a/src/main/java/com/jcabi/aether/RootArtifact.java b/src/main/java/com/jcabi/aether/RootArtifact.java
index 8fd6242..6e7d43f 100644
--- a/src/main/java/com/jcabi/aether/RootArtifact.java
+++ b/src/main/java/com/jcabi/aether/RootArtifact.java
@@ -32,12 +32,12 @@ package com.jcabi.aether;
 import com.jcabi.aspects.Cacheable;
 import com.jcabi.log.Logger;
 import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
 import javax.validation.constraints.NotNull;
 import lombok.EqualsAndHashCode;
-import org.apache.maven.artifact.Artifact;
 import org.apache.maven.model.Exclusion;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.resolution.DependencyResolutionException;
+import org.sonatype.aether.util.artifact.JavaScopes;
 
 /**
  * One root artifact found in the project.
@@ -46,9 +46,15 @@ import org.apache.maven.model.Exclusion;
  * @version $Id$
  * @since 0.7.16
  */
-@EqualsAndHashCode(of = { "art", "exclusions" })
+@EqualsAndHashCode(of = { "aether", "art", "exclusions" })
 final class RootArtifact {
 
+    /**
+     * The aether for finding children.
+     */
+    @NotNull
+    private final transient Aether aether;
+
     /**
      * The artifact.
      */
@@ -63,11 +69,14 @@ final class RootArtifact {
 
     /**
      * Ctor.
+     * @param aeth Aether for finding children
      * @param artifact The artifact
      * @param excl Exclusions
      */
-    protected RootArtifact(@NotNull final Artifact artifact,
-        @NotNull final List<Exclusion> excl) {
+    protected RootArtifact(@NotNull final Aether aeth,
+        @NotNull final Artifact artifact,
+        @NotNull final Collection<Exclusion> excl) {
+        this.aether = aeth;
         this.art = artifact;
         this.exclusions = excl;
     }
@@ -87,11 +96,15 @@ final class RootArtifact {
                 this.exclusions.size()
             )
         );
-        for (Artifact child : this.children()) {
-            text.append("\n  ").append(child);
-            if (this.excluded(child)) {
-                text.append(" (excluded)");
+        try {
+            for (Artifact child : this.children()) {
+                text.append("\n  ").append(child);
+                if (this.excluded(child)) {
+                    text.append(" (excluded)");
+                }
             }
+        } catch (DependencyResolutionException ex) {
+            text.append(' ').append(ex);
         }
         return text.toString();
     }
@@ -107,17 +120,12 @@ final class RootArtifact {
     /**
      * Get all dependencies of this root artifact.
      * @return The list of artifacts
-     * @todo #4 Retrieve list of children of given artifact from repository that
-     *  will not depend on sonatype aether or eclipse aether.
-     *  Test ClasspathTest.hasToStringWithBrokenDependency and
-     *  RootArtifactTest.gracefullyResolvesBrokenRootArtifact and
-     *  RootArtifactTest.resolvesRootArtifact should pass when
-     *  the method is updated to work in new eclipse aether.
+     * @throws DependencyResolutionException If fails to resolve
      */
     @Cacheable(forever = true)
-    @SuppressWarnings("unchecked")
-    public Collection<Artifact> children() {
-        return Collections.emptyList();
+    public Collection<Artifact> children()
+        throws DependencyResolutionException {
+        return this.aether.resolve(this.art, JavaScopes.COMPILE);
     }
 
     /**
diff --git a/src/test/java/com/jcabi/aether/AetherTest.java b/src/test/java/com/jcabi/aether/AetherTest.java
index 800fa6d..7081dea 100644
--- a/src/test/java/com/jcabi/aether/AetherTest.java
+++ b/src/test/java/com/jcabi/aether/AetherTest.java
@@ -42,7 +42,6 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import org.apache.maven.project.DependencyResolutionException;
 import org.apache.maven.project.MavenProject;
 import org.hamcrest.CustomMatcher;
 import org.hamcrest.Matcher;
@@ -56,6 +55,7 @@ import org.mockito.Mockito;
 import org.sonatype.aether.artifact.Artifact;
 import org.sonatype.aether.repository.Authentication;
 import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.resolution.DependencyResolutionException;
 import org.sonatype.aether.util.artifact.DefaultArtifact;
 import org.sonatype.aether.util.artifact.JavaScopes;
 
diff --git a/src/test/java/com/jcabi/aether/ClasspathTest.java b/src/test/java/com/jcabi/aether/ClasspathTest.java
index 3a27cd5..a7acac9 100644
--- a/src/test/java/com/jcabi/aether/ClasspathTest.java
+++ b/src/test/java/com/jcabi/aether/ClasspathTest.java
@@ -31,23 +31,17 @@ package com.jcabi.aether;
 
 import java.io.File;
 import java.util.Arrays;
-import org.apache.maven.artifact.Artifact;
-import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
-import org.apache.maven.execution.MavenSession;
+import java.util.List;
 import org.apache.maven.model.Dependency;
 import org.apache.maven.project.MavenProject;
-import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
-import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
-import org.apache.maven.shared.dependency.graph.DependencyNode;
-import org.codehaus.plexus.PlexusContainer;
-import org.codehaus.plexus.component.repository.exception.ComponentLookupException;
 import org.hamcrest.MatcherAssert;
 import org.hamcrest.Matchers;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.Mockito;
+import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.util.artifact.JavaScopes;
 
 /**
  * Test case for {@link Classpath}.
@@ -75,14 +69,11 @@ public final class ClasspathTest {
         dep.setGroupId(group);
         dep.setArtifactId(group);
         dep.setVersion("4.10");
-        dep.setScope("test");
-        final String jar = "junit-4.10.jar";
-        final PlexusContainer container = this.container(jar);
-        final MavenSession session = Mockito.mock(MavenSession.class);
-        final MavenProject project = this.project(dep);
-        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        dep.setScope(JavaScopes.TEST);
         MatcherAssert.assertThat(
-            new Classpath(container, session, Classpath.TEST_SCOPE),
+            new Classpath(
+                this.project(dep), this.temp.newFolder(), JavaScopes.TEST
+            ),
             Matchers.<File>hasItems(
                 Matchers.hasToString(
                     Matchers.endsWith(
@@ -92,66 +83,25 @@ public final class ClasspathTest {
                         )
                     )
                 ),
-                Matchers.hasToString(Matchers.endsWith(jar))
+                Matchers.hasToString(Matchers.endsWith("junit-4.10.jar")),
+                Matchers.hasToString(Matchers.endsWith("hamcrest-core-1.1.jar"))
             )
         );
     }
 
-    /**
-     * Build PlexusContainer with single dependency node.
-     * @param location Location of node jar.
-     * @return Container.
-     */
-    private PlexusContainer container(final String location) {
-        final PlexusContainer container = Mockito.mock(PlexusContainer.class);
-        final DependencyGraphBuilder builder = Mockito
-            .mock(DependencyGraphBuilder.class);
-        try {
-            Mockito.when(
-                container.lookup(
-                    DependencyGraphBuilder.class.getCanonicalName()
-                )
-            )
-                .thenReturn(builder);
-        } catch (ComponentLookupException ex) {
-            throw new IllegalStateException(ex);
-        }
-        final DependencyNode node = Mockito.mock(DependencyNode.class);
-        try {
-            Mockito.when(
-                builder.buildDependencyGraph(
-                    Mockito.any(MavenProject.class),
-                    Mockito.any(ArtifactFilter.class)
-                )
-            )
-                .thenReturn(node);
-        } catch (DependencyGraphBuilderException ex) {
-            throw new IllegalStateException(ex);
-        }
-        final Artifact artifact = Mockito.mock(Artifact.class);
-        Mockito.when(artifact.getFile()).thenReturn(new File(location));
-        Mockito.when(node.getArtifact()).thenReturn(artifact);
-        return container;
-    }
-
     /**
      * Classpath can return a string when a dependency is broken.
      * @throws Exception If there is some problem inside
      */
     @Test
-    @Ignore
     public void hasToStringWithBrokenDependency() throws Exception {
         final Dependency dep = new Dependency();
         dep.setGroupId("junit-broken");
         dep.setArtifactId("junit-absent");
         dep.setVersion("1.0");
-        dep.setScope(Classpath.TEST_SCOPE);
-        final PlexusContainer container = Mockito.mock(PlexusContainer.class);
-        final MavenSession session = Mockito.mock(MavenSession.class);
-        final MavenProject project = this.project(dep);
-        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        dep.setScope(JavaScopes.TEST);
         final Classpath classpath = new Classpath(
-            container, session, Classpath.TEST_SCOPE
+            this.project(dep), this.temp.newFolder(), JavaScopes.TEST
         );
         MatcherAssert.assertThat(
             classpath.toString(),
@@ -171,13 +121,9 @@ public final class ClasspathTest {
         dep.setGroupId("org.apache.commons");
         dep.setArtifactId("commons-lang3-absent");
         dep.setVersion("3.0");
-        dep.setScope(Classpath.COMPILE_SCOPE);
-        final PlexusContainer container = Mockito.mock(PlexusContainer.class);
-        final MavenSession session = Mockito.mock(MavenSession.class);
-        final MavenProject project = this.project(dep);
-        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        dep.setScope(JavaScopes.COMPILE);
         final Classpath classpath = new Classpath(
-            container, session, Classpath.TEST_SCOPE
+            this.project(dep), this.temp.newFolder(), JavaScopes.TEST
         );
         MatcherAssert.assertThat(classpath, Matchers.equalTo(classpath));
         MatcherAssert.assertThat(
@@ -197,6 +143,14 @@ public final class ClasspathTest {
         Mockito.doReturn(Arrays.asList("/some/path/as/directory"))
             .when(project).getTestClasspathElements();
         Mockito.doReturn(Arrays.asList(dep)).when(project).getDependencies();
+        final List<RemoteRepository> repos = Arrays.asList(
+            new RemoteRepository(
+                "maven-central",
+                "default",
+                "http://repo1.maven.org/maven2/"
+            )
+        );
+        Mockito.doReturn(repos).when(project).getRemoteProjectRepositories();
         return project;
     }
 
diff --git a/src/test/java/com/jcabi/aether/MavenClasspathTest.java b/src/test/java/com/jcabi/aether/MavenClasspathTest.java
new file mode 100644
index 0000000..bd44d22
--- /dev/null
+++ b/src/test/java/com/jcabi/aether/MavenClasspathTest.java
@@ -0,0 +1,192 @@
+/**
+ * Copyright (c) 2012-2013, JCabi.com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 1) Redistributions of source code must retain the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer. 2) Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution. 3) Neither the name of the jcabi.com nor
+ * the names of its contributors may be used to endorse or promote
+ * products derived from this software without specific prior written
+ * permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.jcabi.aether;
+
+import java.io.File;
+import java.util.Arrays;
+import org.apache.maven.artifact.Artifact;
+import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
+import org.apache.maven.execution.MavenSession;
+import org.apache.maven.model.Dependency;
+import org.apache.maven.project.MavenProject;
+import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
+import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
+import org.apache.maven.shared.dependency.graph.DependencyNode;
+import org.hamcrest.MatcherAssert;
+import org.hamcrest.Matchers;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.mockito.Mockito;
+
+/**
+ * Test case for {@link com.jcabi.aether.MavenClasspath}.
+ * @author Krzysztof Krason (Krzysztof.Krason@gmail.com)
+ * @version $Id$
+ */
+@SuppressWarnings("unchecked")
+public final class MavenClasspathTest {
+
+    /**
+     * Temp dir.
+     * @checkstyle VisibilityModifier (3 lines)
+     */
+    @Rule
+    public final transient TemporaryFolder temp = new TemporaryFolder();
+
+    /**
+     * Classpath can build a classpath.
+     * @throws Exception If there is some problem inside
+     */
+    @Test
+    public void buildsClasspath() throws Exception {
+        final Dependency dep = new Dependency();
+        final String group = "junit";
+        dep.setGroupId(group);
+        dep.setArtifactId(group);
+        dep.setVersion("4.10");
+        dep.setScope("test");
+        final String jar = "junit-4.10.jar";
+        final DependencyGraphBuilder builder = this.builder(jar);
+        final MavenSession session = Mockito.mock(MavenSession.class);
+        final MavenProject project = this.project(dep);
+        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        MatcherAssert.assertThat(
+            new MavenClasspath(builder, session, MavenClasspath.TEST_SCOPE),
+            Matchers.<File>hasItems(
+                Matchers.hasToString(
+                    Matchers.endsWith(
+                        String.format(
+                            "%sas%<sdirectory",
+                            System.getProperty("file.separator")
+                        )
+                    )
+                ),
+                Matchers.hasToString(Matchers.endsWith(jar))
+            )
+        );
+    }
+
+    /**
+     * Build DependencyGraphBuilder with single dependency node.
+     * @param location Location of node jar.
+     * @return Container.
+     */
+    private DependencyGraphBuilder builder(final String location) {
+        final DependencyGraphBuilder builder = Mockito
+            .mock(DependencyGraphBuilder.class);
+        final DependencyNode node = Mockito.mock(DependencyNode.class);
+        try {
+            Mockito.when(
+                builder.buildDependencyGraph(
+                    Mockito.any(MavenProject.class),
+                    Mockito.any(ArtifactFilter.class)
+                )
+            )
+                .thenReturn(node);
+        } catch (DependencyGraphBuilderException ex) {
+            throw new IllegalStateException(ex);
+        }
+        final Artifact artifact = Mockito.mock(Artifact.class);
+        Mockito.when(artifact.getFile()).thenReturn(new File(location));
+        Mockito.when(node.getArtifact()).thenReturn(artifact);
+        return builder;
+    }
+
+    /**
+     * Classpath can return a string when a dependency is broken.
+     * @throws Exception If there is some problem inside
+     */
+    @Test
+    @Ignore
+    public void hasToStringWithBrokenDependency() throws Exception {
+        final Dependency dep = new Dependency();
+        dep.setGroupId("junit-broken");
+        dep.setArtifactId("junit-absent");
+        dep.setVersion("1.0");
+        dep.setScope(MavenClasspath.TEST_SCOPE);
+        final DependencyGraphBuilder builder =
+            Mockito.mock(DependencyGraphBuilder.class);
+        final MavenSession session = Mockito.mock(MavenSession.class);
+        final MavenProject project = this.project(dep);
+        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        final MavenClasspath classpath = new MavenClasspath(
+            builder, session, MavenClasspath.TEST_SCOPE
+        );
+        MatcherAssert.assertThat(
+            classpath.toString(),
+            Matchers.containsString(
+                "failed to load 'junit-broken:junit-absent:jar:1.0 (compile)'"
+            )
+        );
+    }
+
+    /**
+     * Classpath can be compared to another classpath.
+     * @throws Exception If there is some problem inside
+     */
+    @Test
+    public void comparesToAnotherClasspath() throws Exception {
+        final Dependency dep = new Dependency();
+        dep.setGroupId("org.apache.commons");
+        dep.setArtifactId("commons-lang3-absent");
+        dep.setVersion("3.0");
+        dep.setScope(MavenClasspath.COMPILE_SCOPE);
+        final DependencyGraphBuilder builder =
+            Mockito.mock(DependencyGraphBuilder.class);
+        final MavenSession session = Mockito.mock(MavenSession.class);
+        final MavenProject project = this.project(dep);
+        Mockito.when(session.getCurrentProject()).thenReturn(project);
+        final MavenClasspath classpath = new MavenClasspath(
+            builder, session, MavenClasspath.TEST_SCOPE
+        );
+        MatcherAssert.assertThat(classpath, Matchers.equalTo(classpath));
+        MatcherAssert.assertThat(
+            classpath.canEqual(classpath),
+            Matchers.is(true)
+        );
+    }
+
+    /**
+     * Creates project with this dependency.
+     * @param dep Dependency to add to the project
+     * @return Maven project mocked
+     * @throws Exception If there is some problem inside
+     */
+    private MavenProject project(final Dependency dep) throws Exception {
+        final MavenProject project = Mockito.mock(MavenProject.class);
+        Mockito.doReturn(Arrays.asList("/some/path/as/directory"))
+            .when(project).getTestClasspathElements();
+        Mockito.doReturn(Arrays.asList(dep)).when(project).getDependencies();
+        return project;
+    }
+
+}
diff --git a/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java b/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java
new file mode 100644
index 0000000..4bc2837
--- /dev/null
+++ b/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java
@@ -0,0 +1,108 @@
+/**
+ * Copyright (c) 2012-2013, JCabi.com
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met: 1) Redistributions of source code must retain the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer. 2) Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution. 3) Neither the name of the jcabi.com nor
+ * the names of its contributors may be used to endorse or promote
+ * products derived from this software without specific prior written
+ * permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.jcabi.aether;
+
+import java.util.ArrayList;
+import org.apache.maven.artifact.Artifact;
+import org.apache.maven.artifact.DefaultArtifact;
+import org.apache.maven.artifact.handler.DefaultArtifactHandler;
+import org.apache.maven.model.Exclusion;
+import org.hamcrest.MatcherAssert;
+import org.hamcrest.Matchers;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+/**
+ * Test case for {@link com.jcabi.aether.MavenRootArtifact}.
+ * @author Krzysztof Krason (Krzysztof.Krason@gmail.com)
+ * @version $Id$
+ */
+public final class MavenRootArtifactTest {
+
+    /**
+     * Temp dir.
+     * @checkstyle VisibilityModifier (3 lines)
+     */
+    @Rule
+    public final transient TemporaryFolder temp = new TemporaryFolder();
+
+    /**
+     * MavenRootArtifact can resolve a root artifact.
+     * @throws Exception If there is some problem inside
+     */
+    @Test
+    @Ignore
+    @SuppressWarnings("unchecked")
+    public void resolvesMavenRootArtifact() throws Exception {
+        final MavenRootArtifact root = new MavenRootArtifact(
+            // @checkstyle MultipleStringLiterals (1 line)
+            new DefaultArtifact(
+                // @checkstyle MultipleStringLiteralsCheck (1 line)
+                "junit", "junit", "4.10", "", "jar", "",
+                new DefaultArtifactHandler()
+            ),
+            new ArrayList<Exclusion>()
+        );
+        MatcherAssert.assertThat(
+            root,
+            Matchers.hasToString(Matchers.containsString("junit:junit:4.10"))
+        );
+        MatcherAssert.assertThat(
+            root.children(),
+            Matchers.<Artifact>hasItems(
+                Matchers.hasToString("junit:junit:jar:4.10")
+            )
+        );
+    }
+
+    /**
+     * MavenRootArtifact can gracefully resolve a root artifact.
+     * @throws Exception If there is some problem inside
+     */
+    @Test
+    @Ignore
+    public void gracefullyResolvesBrokenMavenRootArtifact() throws Exception {
+        final MavenRootArtifact root = new MavenRootArtifact(
+            new DefaultArtifact(
+                "junit-broken", "junit-absent", "1.0", "", "", "",
+                new DefaultArtifactHandler()
+            ),
+            new ArrayList<Exclusion>()
+        );
+        MatcherAssert.assertThat(
+            root,
+            Matchers.hasToString(
+                Matchers.containsString("failed to load 'junit-broken:")
+            )
+        );
+    }
+}
diff --git a/src/test/java/com/jcabi/aether/RootArtifactTest.java b/src/test/java/com/jcabi/aether/RootArtifactTest.java
index fca3a6e..7bfa26c 100644
--- a/src/test/java/com/jcabi/aether/RootArtifactTest.java
+++ b/src/test/java/com/jcabi/aether/RootArtifactTest.java
@@ -29,17 +29,21 @@
  */
 package com.jcabi.aether;
 
+import java.io.File;
 import java.util.ArrayList;
-import org.apache.maven.artifact.Artifact;
-import org.apache.maven.artifact.DefaultArtifact;
-import org.apache.maven.artifact.handler.DefaultArtifactHandler;
+import java.util.Arrays;
+import java.util.List;
 import org.apache.maven.model.Exclusion;
+import org.apache.maven.project.MavenProject;
 import org.hamcrest.MatcherAssert;
 import org.hamcrest.Matchers;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.mockito.Mockito;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.util.artifact.DefaultArtifact;
 
 /**
  * Test case for {@link RootArtifact}.
@@ -60,16 +64,12 @@ public final class RootArtifactTest {
      * @throws Exception If there is some problem inside
      */
     @Test
-    @Ignore
     @SuppressWarnings("unchecked")
     public void resolvesRootArtifact() throws Exception {
         final RootArtifact root = new RootArtifact(
+            this.aether(),
             // @checkstyle MultipleStringLiterals (1 line)
-            new DefaultArtifact(
-                // @checkstyle MultipleStringLiteralsCheck (1 line)
-                "junit", "junit", "4.10", "", "jar", "",
-                new DefaultArtifactHandler()
-            ),
+            new DefaultArtifact("junit", "junit", "", "jar", "4.10"),
             new ArrayList<Exclusion>()
         );
         MatcherAssert.assertThat(
@@ -79,7 +79,8 @@ public final class RootArtifactTest {
         MatcherAssert.assertThat(
             root.children(),
             Matchers.<Artifact>hasItems(
-                Matchers.hasToString("junit:junit:jar:4.10")
+                Matchers.hasToString("junit:junit:jar:4.10"),
+                Matchers.hasToString("org.hamcrest:hamcrest-core:jar:1.1")
             )
         );
     }
@@ -89,13 +90,10 @@ public final class RootArtifactTest {
      * @throws Exception If there is some problem inside
      */
     @Test
-    @Ignore
     public void gracefullyResolvesBrokenRootArtifact() throws Exception {
         final RootArtifact root = new RootArtifact(
-            new DefaultArtifact(
-                "junit-broken", "junit-absent", "1.0", "", "", "",
-                new DefaultArtifactHandler()
-            ),
+            this.aether(),
+            new DefaultArtifact("junit-broken", "junit-absent", "", "", "1.0"),
             new ArrayList<Exclusion>()
         );
         MatcherAssert.assertThat(
@@ -105,4 +103,24 @@ public final class RootArtifactTest {
             )
         );
     }
+
+    /**
+     * Build aether.
+     * @return The aether
+     * @throws Exception If fails
+     */
+    private Aether aether() throws Exception {
+        final File local = this.temp.newFolder();
+        final MavenProject project = Mockito.mock(MavenProject.class);
+        final List<RemoteRepository> repos = Arrays.asList(
+            new RemoteRepository(
+                "maven-central",
+                "default",
+                "http://repo1.maven.org/maven2/"
+            )
+        );
+        Mockito.doReturn(repos).when(project).getRemoteProjectRepositories();
+        return new Aether(project, local);
+    }
+
 }
