diff --git a/src/main/java/com/jcabi/aether/MavenClasspath.java b/src/main/java/com/jcabi/aether/MavenClasspath.java
index b56fce2..39cce0b 100644
--- a/src/main/java/com/jcabi/aether/MavenClasspath.java
+++ b/src/main/java/com/jcabi/aether/MavenClasspath.java
@@ -43,6 +43,7 @@ import java.util.concurrent.TimeUnit;
 import javax.validation.constraints.NotNull;
 import lombok.EqualsAndHashCode;
 import org.apache.commons.lang3.StringUtils;
+import org.apache.maven.artifact.Artifact;
 import org.apache.maven.artifact.DefaultArtifact;
 import org.apache.maven.artifact.DependencyResolutionRequiredException;
 import org.apache.maven.artifact.handler.DefaultArtifactHandler;
@@ -170,24 +171,32 @@ public final class MavenClasspath extends AbstractSet<File> {
             files.add(new File(path));
         }
         try {
-            final DependencyNode node = this.builder.buildDependencyGraph(
-                this.session.getCurrentProject(),
-                new ArtifactFilter() {
-                    @Override
-                    public boolean include(
-                        final org.apache.maven.artifact.Artifact artifact) {
-                        return MavenClasspath.this.scopes
-                            .contains(artifact.getScope());
-                    }
-                }
-            );
-            files.addAll(this.dependencies(node, this.scopes));
+            files.addAll(this.dependencies(this.graph(), this.scopes));
         } catch (final DependencyGraphBuilderException ex) {
             throw new IllegalStateException(ex);
         }
         return files;
     }
 
+    /**
+     * Build dependency graph.
+     * @return Root of dependency graph.
+     * @throws DependencyGraphBuilderException In case of error.
+     */
+    private DependencyNode graph() throws DependencyGraphBuilderException {
+        return this.builder.buildDependencyGraph(
+            this.session.getCurrentProject(),
+            new ArtifactFilter() {
+                @Override
+                public boolean include(
+                    final Artifact artifact) {
+                    return MavenClasspath.this.scopes
+                        .contains(artifact.getScope());
+                }
+            }
+        );
+    }
+
     /**
      * Convert dependencies to root artifacts.
      *
@@ -216,18 +225,28 @@ public final class MavenClasspath extends AbstractSet<File> {
      * @return Root artifact
      */
     private MavenRootArtifact root(final Dependency dep) {
-        return new MavenRootArtifact(
-            new DefaultArtifact(
-                dep.getGroupId(),
-                dep.getArtifactId(),
-                dep.getVersion(),
-                dep.getScope(),
-                dep.getType(),
-                dep.getClassifier(),
-                new DefaultArtifactHandler()
-            ),
-            dep.getExclusions()
+        final DefaultArtifact artifact = new DefaultArtifact(
+            dep.getGroupId(),
+            dep.getArtifactId(),
+            dep.getVersion(),
+            dep.getScope(),
+            dep.getType(),
+            dep.getClassifier(),
+            new DefaultArtifactHandler()
         );
+        try {
+            final Collection<Artifact> children = new LinkedList<Artifact>();
+            for (final DependencyNode child : this.graph().getChildren()) {
+                children.add(child.getArtifact());
+            }
+            return new MavenRootArtifact(
+                artifact,
+                dep.getExclusions(),
+                children
+            );
+        } catch (final DependencyGraphBuilderException ex) {
+            throw new IllegalStateException(ex);
+        }
     }
 
     /**
@@ -275,7 +294,7 @@ public final class MavenClasspath extends AbstractSet<File> {
      */
     private Collection<File> dependencies(final DependencyNode node,
         final Collection<String> scps) {
-        final org.apache.maven.artifact.Artifact artifact = node.getArtifact();
+        final Artifact artifact = node.getArtifact();
         final Collection<File> files = new LinkedList<File>();
         if ((artifact.getScope() == null)
             || scps.contains(artifact.getScope())) {
diff --git a/src/main/java/com/jcabi/aether/MavenRootArtifact.java b/src/main/java/com/jcabi/aether/MavenRootArtifact.java
index e640b9d..e70a31c 100644
--- a/src/main/java/com/jcabi/aether/MavenRootArtifact.java
+++ b/src/main/java/com/jcabi/aether/MavenRootArtifact.java
@@ -32,7 +32,6 @@ package com.jcabi.aether;
 import com.jcabi.aspects.Cacheable;
 import com.jcabi.log.Logger;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import javax.validation.constraints.NotNull;
 import lombok.EqualsAndHashCode;
@@ -61,15 +60,24 @@ final class MavenRootArtifact {
     @NotNull
     private final transient Collection<Exclusion> exclusions;
 
+    /**
+     * This artifact child artifacts.
+     */
+    @NotNull
+    private final transient Collection<Artifact> chldrn;
+
     /**
      * Ctor.
      * @param artifact The artifact
      * @param excl Exclusions
+     * @param chld Child artifacts
      */
     protected MavenRootArtifact(@NotNull final Artifact artifact,
-        @NotNull final List<Exclusion> excl) {
+        @NotNull final List<Exclusion> excl,
+        @NotNull final Collection<Artifact> chld) {
         this.art = artifact;
         this.exclusions = excl;
+        this.chldrn = chld;
     }
 
     /**
@@ -80,7 +88,7 @@ final class MavenRootArtifact {
         final StringBuilder text = new StringBuilder();
         text.append(
             Logger.format(
-                "%s:%s:%s:",
+                "%s:%s:%s:%d",
                 this.art.getGroupId(),
                 this.art.getArtifactId(),
                 this.art.getVersion(),
@@ -107,17 +115,11 @@ final class MavenRootArtifact {
     /**
      * Get all dependencies of this root artifact.
      * @return The list of artifacts
-     * @todo #4 Retrieve list of children of given artifact from repository that
-     *  will not depend on sonatype aether or eclipse aether.
-     *  Test ClasspathTest.hasToStringWithBrokenDependency and
-     *  RootArtifactTest.gracefullyResolvesBrokenRootArtifact and
-     *  RootArtifactTest.resolvesRootArtifact should pass when
-     *  the method is updated to work in new eclipse aether.
      */
     @Cacheable(forever = true)
     @SuppressWarnings("unchecked")
     public Collection<Artifact> children() {
-        return Collections.emptyList();
+        return this.chldrn;
     }
 
     /**
diff --git a/src/test/java/com/jcabi/aether/MavenClasspathTest.java b/src/test/java/com/jcabi/aether/MavenClasspathTest.java
index 64d7e07..66e2627 100644
--- a/src/test/java/com/jcabi/aether/MavenClasspathTest.java
+++ b/src/test/java/com/jcabi/aether/MavenClasspathTest.java
@@ -98,6 +98,7 @@ public final class MavenClasspathTest {
     /**
      * Classpath can return a string when a dependency is broken.
      * @throws Exception If there is some problem inside
+     * @todo #28 Add handling of broken dependencies in toString.
      */
     @Test
     @Ignore
diff --git a/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java b/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java
index dced08d..f1a7d56 100644
--- a/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java
+++ b/src/test/java/com/jcabi/aether/MavenRootArtifactTest.java
@@ -30,13 +30,13 @@
 package com.jcabi.aether;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import org.apache.maven.artifact.Artifact;
 import org.apache.maven.artifact.DefaultArtifact;
 import org.apache.maven.artifact.handler.DefaultArtifactHandler;
 import org.apache.maven.model.Exclusion;
 import org.hamcrest.MatcherAssert;
 import org.hamcrest.Matchers;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -60,17 +60,17 @@ public final class MavenRootArtifactTest {
      * @throws Exception If there is some problem inside
      */
     @Test
-    @Ignore
     @SuppressWarnings("unchecked")
     public void resolvesMavenRootArtifact() throws Exception {
+        final DefaultArtifact artifact = new DefaultArtifact(
+            // @checkstyle MultipleStringLiteralsCheck (1 line)
+            "junit", "junit", "4.10", "", "jar", "",
+            new DefaultArtifactHandler()
+        );
         final MavenRootArtifact root = new MavenRootArtifact(
-            // @checkstyle MultipleStringLiterals (1 line)
-            new DefaultArtifact(
-                // @checkstyle MultipleStringLiteralsCheck (1 line)
-                "junit", "junit", "4.10", "", "jar", "",
-                new DefaultArtifactHandler()
-            ),
-            new ArrayList<Exclusion>(0)
+            artifact,
+            new ArrayList<Exclusion>(0),
+            Collections.<Artifact>singleton(artifact)
         );
         MatcherAssert.assertThat(
             root,
@@ -79,7 +79,7 @@ public final class MavenRootArtifactTest {
         MatcherAssert.assertThat(
             root.children(),
             Matchers.<Artifact>hasItems(
-                Matchers.hasToString("junit:junit:jar:4.10")
+                Matchers.hasToString("junit:junit:jar:4.10:")
             )
         );
     }
@@ -89,19 +89,19 @@ public final class MavenRootArtifactTest {
      * @throws Exception If there is some problem inside
      */
     @Test
-    @Ignore
     public void gracefullyResolvesBrokenMavenRootArtifact() throws Exception {
         final MavenRootArtifact root = new MavenRootArtifact(
             new DefaultArtifact(
                 "junit-broken", "junit-absent", "1.0", "", "", "",
                 new DefaultArtifactHandler()
             ),
-            new ArrayList<Exclusion>(0)
+            new ArrayList<Exclusion>(0),
+            new ArrayList<Artifact>(0)
         );
         MatcherAssert.assertThat(
             root,
             Matchers.hasToString(
-                Matchers.containsString("failed to load 'junit-broken:")
+                Matchers.containsString("junit-broken:junit-absent:1.0:0")
             )
         );
     }
