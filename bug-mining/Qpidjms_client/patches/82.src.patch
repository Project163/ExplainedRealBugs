diff --git a/client/src/main/java/org/apache/qpid/client/BasicMessageProducer.java b/client/src/main/java/org/apache/qpid/client/BasicMessageProducer.java
index d531c9eef..79647e8de 100644
--- a/client/src/main/java/org/apache/qpid/client/BasicMessageProducer.java
+++ b/client/src/main/java/org/apache/qpid/client/BasicMessageProducer.java
@@ -522,7 +522,7 @@ public class BasicMessageProducer extends Closeable implements org.apache.qpid.j
 
 
         AbstractJMSMessage message = convertToNativeMessage(origMessage);
-        message.getJmsContentHeaderProperties().setBytes(CustomJMSXProperty.JMSX_QPID_JMSDESTINATIONURL.
+        message.getJmsHeaders().setBytes(CustomJMSXProperty.JMSX_QPID_JMSDESTINATIONURL.
                                                          getShortStringName(), destination.toByteEncoding());
         // AMQP version change: Hardwire the version to 0-8 (major=8, minor=0)
         // TODO: Connect this to the session version obtained from ProtocolInitiation for this session.
@@ -539,7 +539,7 @@ public class BasicMessageProducer extends Closeable implements org.apache.qpid.j
 
         message.prepareForSending();
         ByteBuffer payload = message.getData();
-        BasicContentHeaderProperties contentHeaderProperties = message.getJmsContentHeaderProperties();
+        BasicContentHeaderProperties contentHeaderProperties = message.getContentHeaderProperties();
 
         if (!_disableTimestamps)
         {
diff --git a/client/src/main/java/org/apache/qpid/client/message/AbstractBytesMessage.java b/client/src/main/java/org/apache/qpid/client/message/AbstractBytesMessage.java
index 5fb8de369..805bdc618 100644
--- a/client/src/main/java/org/apache/qpid/client/message/AbstractBytesMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/AbstractBytesMessage.java
@@ -55,7 +55,7 @@ public abstract class AbstractBytesMessage extends AbstractJMSMessage
     AbstractBytesMessage(ByteBuffer data)
     {
         super(data); // this instanties a content header
-        getJmsContentHeaderProperties().setContentType(getMimeTypeAsShortString());
+        getContentHeaderProperties().setContentType(getMimeTypeAsShortString());
 
         if (_data == null)
         {
@@ -74,7 +74,7 @@ public abstract class AbstractBytesMessage extends AbstractJMSMessage
     {
         // TODO: this casting is ugly. Need to review whole ContentHeaderBody idea
         super(messageNbr, (BasicContentHeaderProperties) contentHeader.properties, data);
-        getJmsContentHeaderProperties().setContentType(getMimeTypeAsShortString());
+        getContentHeaderProperties().setContentType(getMimeTypeAsShortString());
     }
 
     public void clearBodyImpl() throws JMSException
diff --git a/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java b/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
index 4a0d3283b..da8d38808 100644
--- a/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
@@ -32,10 +32,7 @@ import org.apache.qpid.framing.BasicContentHeaderProperties;
 import org.apache.qpid.framing.FieldTable;
 import org.apache.qpid.framing.AMQShortString;
 
-import javax.jms.Destination;
-import javax.jms.JMSException;
-import javax.jms.MessageNotReadableException;
-import javax.jms.MessageNotWriteableException;
+import javax.jms.*;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.Map;
@@ -43,6 +40,7 @@ import java.util.Map;
 public abstract class AbstractJMSMessage extends AMQMessage implements org.apache.qpid.jms.Message
 {
     private static final Map _destinationCache = Collections.synchronizedMap(new ReferenceMap());
+                                                                  
 
     protected boolean _redelivered;
 
@@ -51,6 +49,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
     protected boolean _readableMessage = false;
     protected boolean _changedData;
     private Destination _destination;
+    private JMSHeaderAdapter _headerAdapter;
     private BasicMessageConsumer _consumer;
 
     protected AbstractJMSMessage(ByteBuffer data)
@@ -64,6 +63,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
         _readableProperties = false;
         _readableMessage = (data != null);
         _changedData = (data == null);
+        _headerAdapter = new JMSHeaderAdapter(((BasicContentHeaderProperties)_contentHeaderProperties).getHeaders());
     }
 
     protected AbstractJMSMessage(long deliveryTag, BasicContentHeaderProperties contentHeader, ByteBuffer data) throws AMQException
@@ -76,61 +76,63 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
         }
 
         _readableMessage = data != null;
+
     }
 
     protected AbstractJMSMessage(BasicContentHeaderProperties contentHeader, long deliveryTag)
     {
         super(contentHeader, deliveryTag);
         _readableProperties = (_contentHeaderProperties != null);
+        _headerAdapter = new JMSHeaderAdapter(((BasicContentHeaderProperties)_contentHeaderProperties).getHeaders());
     }
 
     public String getJMSMessageID() throws JMSException
     {
-        if (getJmsContentHeaderProperties().getMessageId() == null)
+        if (getContentHeaderProperties().getMessageId() == null)
         {
-            getJmsContentHeaderProperties().setMessageId("ID:" + _deliveryTag);
+            getContentHeaderProperties().setMessageId("ID:" + _deliveryTag);
         }
-        return getJmsContentHeaderProperties().getMessageId();
+        return getContentHeaderProperties().getMessageId();
     }
 
     public void setJMSMessageID(String messageId) throws JMSException
     {
-        getJmsContentHeaderProperties().setMessageId(messageId);
+        getContentHeaderProperties().setMessageId(messageId);
     }
 
     public long getJMSTimestamp() throws JMSException
     {
-        return new Long(getJmsContentHeaderProperties().getTimestamp()).longValue();
+        return getContentHeaderProperties().getTimestamp();
     }
 
     public void setJMSTimestamp(long timestamp) throws JMSException
     {
-        getJmsContentHeaderProperties().setTimestamp(timestamp);
+        getContentHeaderProperties().setTimestamp(timestamp);
     }
 
     public byte[] getJMSCorrelationIDAsBytes() throws JMSException
     {
-        return getJmsContentHeaderProperties().getCorrelationId().getBytes();
+        return getContentHeaderProperties().getCorrelationId().getBytes();
     }
 
     public void setJMSCorrelationIDAsBytes(byte[] bytes) throws JMSException
     {
-        getJmsContentHeaderProperties().setCorrelationId(new String(bytes));
+        getContentHeaderProperties().setCorrelationId(new String(bytes));
     }
 
     public void setJMSCorrelationID(String correlationId) throws JMSException
     {
-        getJmsContentHeaderProperties().setCorrelationId(correlationId);
+        getContentHeaderProperties().setCorrelationId(correlationId);
     }
 
     public String getJMSCorrelationID() throws JMSException
     {
-        return getJmsContentHeaderProperties().getCorrelationId();
+        return getContentHeaderProperties().getCorrelationId();
     }
 
     public Destination getJMSReplyTo() throws JMSException
     {
-        String replyToEncoding = getJmsContentHeaderProperties().getReplyTo();
+        String replyToEncoding = getContentHeaderProperties().getReplyTo();
         if (replyToEncoding == null)
         {
             return null;
@@ -165,13 +167,13 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
         if (!(destination instanceof AMQDestination))
         {
             throw new IllegalArgumentException("ReplyTo destination may only be an AMQDestination - passed argument was type " +
-                                               destination.getClass());
+                    destination.getClass());
         }
         final AMQDestination amqd = (AMQDestination) destination;
 
         final AMQShortString encodedDestination = amqd.getEncodedName();
         _destinationCache.put(encodedDestination, destination);
-        getJmsContentHeaderProperties().setReplyTo(encodedDestination);
+        getContentHeaderProperties().setReplyTo(encodedDestination);
     }
 
     public Destination getJMSDestination() throws JMSException
@@ -186,12 +188,17 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
 
     public int getJMSDeliveryMode() throws JMSException
     {
-        return getJmsContentHeaderProperties().getDeliveryMode();
+        return getContentHeaderProperties().getDeliveryMode();
     }
 
     public void setJMSDeliveryMode(int i) throws JMSException
     {
-        getJmsContentHeaderProperties().setDeliveryMode((byte) i);
+        getContentHeaderProperties().setDeliveryMode((byte) i);
+    }
+
+    public BasicContentHeaderProperties getContentHeaderProperties()
+    {
+        return (BasicContentHeaderProperties) _contentHeaderProperties;
     }
 
     public boolean getJMSRedelivered() throws JMSException
@@ -206,37 +213,37 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
 
     public String getJMSType() throws JMSException
     {
-        return getJmsContentHeaderProperties().getType();
+        return getContentHeaderProperties().getType();
     }
 
     public void setJMSType(String string) throws JMSException
     {
-        getJmsContentHeaderProperties().setType(string);
+        getContentHeaderProperties().setType(string);
     }
 
     public long getJMSExpiration() throws JMSException
     {
-        return new Long(getJmsContentHeaderProperties().getExpiration()).longValue();
+        return getContentHeaderProperties().getExpiration();
     }
 
     public void setJMSExpiration(long l) throws JMSException
     {
-        getJmsContentHeaderProperties().setExpiration(l);
+        getContentHeaderProperties().setExpiration(l);
     }
 
     public int getJMSPriority() throws JMSException
     {
-        return getJmsContentHeaderProperties().getPriority();
+        return getContentHeaderProperties().getPriority();
     }
 
     public void setJMSPriority(int i) throws JMSException
     {
-        getJmsContentHeaderProperties().setPriority((byte) i);
+        getContentHeaderProperties().setPriority((byte) i);
     }
 
     public void clearProperties() throws JMSException
     {
-        getJmsContentHeaderProperties().clear();
+        getJmsHeaders().clear();
 
         _readableProperties = false;
     }
@@ -251,21 +258,21 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
     public boolean propertyExists(AMQShortString propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().propertyExists(propertyName);
+        return getJmsHeaders().propertyExists(propertyName);
     }
 
 
     public boolean propertyExists(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().propertyExists(propertyName);
+        return getJmsHeaders().propertyExists(propertyName);
     }
 
     public boolean getBooleanProperty(AMQShortString propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
 
-        return getJmsContentHeaderProperties().getBoolean(propertyName);
+        return getJmsHeaders().getBoolean(propertyName);
     }
 
 
@@ -273,143 +280,143 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
     {
         checkPropertyName(propertyName);
 
-        return getJmsContentHeaderProperties().getBoolean(propertyName);
+        return getJmsHeaders().getBoolean(propertyName);
     }
 
     public byte getByteProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getByte(propertyName);
+        return getJmsHeaders().getByte(propertyName);
     }
 
     public short getShortProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getShort(propertyName);
+        return getJmsHeaders().getShort(propertyName);
     }
 
     public int getIntProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getInteger(propertyName);
+        return getJmsHeaders().getInteger(propertyName);
     }
 
     public long getLongProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getLong(propertyName);
+        return getJmsHeaders().getLong(propertyName);
     }
 
     public float getFloatProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getFloat(propertyName);
+        return getJmsHeaders().getFloat(propertyName);
     }
 
     public double getDoubleProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getDouble(propertyName);
+        return getJmsHeaders().getDouble(propertyName);
     }
 
     public String getStringProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getString(propertyName);
+        return getJmsHeaders().getString(propertyName);
     }
 
     public Object getObjectProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getObject(propertyName);
+        return getJmsHeaders().getObject(propertyName);
     }
 
     public Enumeration getPropertyNames() throws JMSException
     {
-        return getJmsContentHeaderProperties().getPropertyNames();
+        return getJmsHeaders().getPropertyNames();
     }
 
     public void setBooleanProperty(AMQShortString propertyName, boolean b) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setBoolean(propertyName, b);
+        getJmsHeaders().setBoolean(propertyName, b);
     }
 
     public void setBooleanProperty(String propertyName, boolean b) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setBoolean(propertyName, b);
+        getJmsHeaders().setBoolean(propertyName, b);
     }
 
     public void setByteProperty(String propertyName, byte b) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setByte(propertyName, new Byte(b));
+        getJmsHeaders().setByte(propertyName, new Byte(b));
     }
 
     public void setShortProperty(String propertyName, short i) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setShort(propertyName, new Short(i));
+        getJmsHeaders().setShort(propertyName, new Short(i));
     }
 
     public void setIntProperty(String propertyName, int i) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setInteger(propertyName, new Integer(i));
+        getJmsHeaders().setInteger(propertyName, new Integer(i));
     }
 
     public void setLongProperty(String propertyName, long l) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setLong(propertyName, new Long(l));
+        getJmsHeaders().setLong(propertyName, new Long(l));
     }
 
     public void setFloatProperty(String propertyName, float f) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setFloat(propertyName, new Float(f));
+        getJmsHeaders().setFloat(propertyName, new Float(f));
     }
 
     public void setDoubleProperty(String propertyName, double v) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setDouble(propertyName, new Double(v));
+        getJmsHeaders().setDouble(propertyName, new Double(v));
     }
 
     public void setStringProperty(String propertyName, String value) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setString(propertyName, value);
+        getJmsHeaders().setString(propertyName, value);
     }
 
     public void setObjectProperty(String propertyName, Object object) throws JMSException
     {
         checkWritableProperties();
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().setObject(propertyName, object);
+        getJmsHeaders().setObject(propertyName, object);
     }
 
     protected void removeProperty(AMQShortString propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().remove(propertyName);
+        getJmsHeaders().remove(propertyName);
     }
 
 
     protected void removeProperty(String propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        getJmsContentHeaderProperties().remove(propertyName);
+        getJmsHeaders().remove(propertyName);
     }
 
     public void acknowledgeThis() throws JMSException
@@ -431,7 +438,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
 
     public void acknowledge() throws JMSException
     {
-        if(_session != null)
+        if (_session != null)
         {
             _session.acknowledge();
         }
@@ -471,13 +478,13 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
             buf.append("\nJMS reply to: ").append(String.valueOf(getJMSReplyTo()));
             buf.append("\nAMQ message number: ").append(_deliveryTag);
             buf.append("\nProperties:");
-            if (getJmsContentHeaderProperties().isEmpty())
+            if (getJmsHeaders().isEmpty())
             {
                 buf.append("<NONE>");
             }
             else
             {
-                buf.append('\n').append(getJmsContentHeaderProperties().getHeaders());
+                buf.append('\n').append(getJmsHeaders().getHeaders());
             }
             return buf.toString();
         }
@@ -490,7 +497,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
 
     public void setUnderlyingMessagePropertiesMap(FieldTable messageProperties)
     {
-        getJmsContentHeaderProperties().setHeaders(messageProperties);
+        getContentHeaderProperties().setHeaders(messageProperties);
     }
 
     private void checkPropertyName(CharSequence propertyName)
@@ -499,15 +506,15 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
         {
             throw new IllegalArgumentException("Property name must not be null");
         }
-        else if (propertyName.length()==0)
+        else if (propertyName.length() == 0)
         {
             throw new IllegalArgumentException("Property name must not be the empty string");
         }
     }
 
-    public BasicContentHeaderProperties getJmsContentHeaderProperties()
+    public JMSHeaderAdapter getJmsHeaders()
     {
-        return (BasicContentHeaderProperties) _contentHeaderProperties;
+        return _headerAdapter;
     }
 
     public ByteBuffer getData()
@@ -576,7 +583,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements org.apach
     public byte[] getBytesProperty(AMQShortString propertyName) throws JMSException
     {
         checkPropertyName(propertyName);
-        return getJmsContentHeaderProperties().getBytes(propertyName);
+        return getJmsHeaders().getBytes(propertyName);
 
     }
 }
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSHeaderAdapter.java b/client/src/main/java/org/apache/qpid/client/message/JMSHeaderAdapter.java
new file mode 100644
index 000000000..35f8c54d9
--- /dev/null
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSHeaderAdapter.java
@@ -0,0 +1,514 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.apache.qpid.client.message;
+
+import org.apache.qpid.framing.FieldTable;
+import org.apache.qpid.framing.AMQShortString;
+import org.apache.qpid.AMQPInvalidClassException;
+import org.apache.mina.common.ByteBuffer;
+
+import javax.jms.JMSException;
+import javax.jms.MessageFormatException;
+import java.util.Enumeration;
+
+
+public final class JMSHeaderAdapter
+{
+    FieldTable _headers;
+
+    public JMSHeaderAdapter(FieldTable headers)
+    {
+        _headers = headers;
+    }
+
+
+    public FieldTable getHeaders()
+    {
+        return _headers;
+    }
+
+    public boolean getBoolean(String string) throws JMSException
+    {
+        Boolean b = getHeaders().getBoolean(string);
+
+        if (b == null)
+        {
+            if (getHeaders().containsKey(string))
+            {
+                Object str = getHeaders().getObject(string);
+
+                if (str == null || !(str instanceof String))
+                {
+                    throw new MessageFormatException("getBoolean can't use " + string + " item.");
+                }
+                else
+                {
+                    return Boolean.valueOf((String) str);
+                }
+            }
+            else
+            {
+                b = Boolean.valueOf(null);
+            }
+        }
+
+        return b;
+    }
+
+    public boolean getBoolean(AMQShortString string) throws JMSException
+    {
+        Boolean b = getHeaders().getBoolean(string);
+
+        if (b == null)
+        {
+            if (getHeaders().containsKey(string))
+            {
+                Object str = getHeaders().getObject(string);
+
+                if (str == null || !(str instanceof String))
+                {
+                    throw new MessageFormatException("getBoolean can't use " + string + " item.");
+                }
+                else
+                {
+                    return Boolean.valueOf((String) str);
+                }
+            }
+            else
+            {
+                b = Boolean.valueOf(null);
+            }
+        }
+
+        return b;
+    }
+
+    public char getCharacter(String string) throws JMSException
+    {
+        Character c = getHeaders().getCharacter(string);
+
+        if (c == null)
+        {
+            if (getHeaders().isNullStringValue(string))
+            {
+                throw new NullPointerException("Cannot convert null char");
+            }
+            else
+            {
+                throw new MessageFormatException("getChar can't use " + string + " item.");
+            }
+        }
+        else
+        {
+            return (char) c;
+        }
+    }
+
+    public byte[] getBytes(String string) throws JMSException
+    {
+        return getBytes(new AMQShortString(string));
+    }
+
+    public byte[] getBytes(AMQShortString string) throws JMSException
+    {
+        byte[] bs = getHeaders().getBytes(string);
+
+        if (bs == null)
+        {
+            throw new MessageFormatException("getBytes can't use " + string + " item.");
+        }
+        else
+        {
+            return bs;
+        }
+    }
+
+    public byte getByte(String string) throws JMSException
+    {
+        Byte b = getHeaders().getByte(string);
+        if (b == null)
+        {
+            if (getHeaders().containsKey(string))
+            {
+                Object str = getHeaders().getObject(string);
+
+                if (str == null || !(str instanceof String))
+                {
+                    throw new MessageFormatException("getByte can't use " + string + " item.");
+                }
+                else
+                {
+                    return Byte.valueOf((String) str);
+                }
+            }
+            else
+            {
+                b = Byte.valueOf(null);
+            }
+        }
+
+        return b;
+    }
+
+    public short getShort(String string) throws JMSException
+    {
+        Short s = getHeaders().getShort(string);
+
+        if (s == null)
+        {
+            s = Short.valueOf(getByte(string));
+        }
+
+        return s;
+    }
+
+    public int getInteger(String string) throws JMSException
+    {
+        Integer i = getHeaders().getInteger(string);
+
+        if (i == null)
+        {
+            i = Integer.valueOf(getShort(string));
+        }
+
+        return i;
+    }
+
+    public long getLong(String string) throws JMSException
+    {
+        Long l = getHeaders().getLong(string);
+
+        if (l == null)
+        {
+            l = Long.valueOf(getInteger(string));
+        }
+
+        return l;
+    }
+
+    public float getFloat(String string) throws JMSException
+    {
+        Float f = getHeaders().getFloat(string);
+
+        if (f == null)
+        {
+            if (getHeaders().containsKey(string))
+            {
+                Object str = getHeaders().getObject(string);
+
+                if (str == null || !(str instanceof String))
+                {
+                    throw new MessageFormatException("getFloat can't use " + string + " item.");
+                }
+                else
+                {
+                    return Float.valueOf((String) str);
+                }
+            }
+            else
+            {
+                f = Float.valueOf(null);
+            }
+
+        }
+
+        return f;
+    }
+
+    public double getDouble(String string) throws JMSException
+    {
+        Double d = getHeaders().getDouble(string);
+
+        if (d == null)
+        {
+            d = Double.valueOf(getFloat(string));
+        }
+
+        return d;
+    }
+
+    public String getString(String string) throws JMSException
+    {
+        String s = getHeaders().getString(string);
+
+        if (s == null)
+        {
+            if (getHeaders().containsKey(string))
+            {
+                Object o = getHeaders().getObject(string);
+                if (o instanceof byte[])
+                {
+                    throw new MessageFormatException("getObject couldn't find " + string + " item.");
+                }
+                else
+                {
+                    if (o == null)
+                    {
+                        return null;
+                    }
+                    else
+                    {
+                        s = String.valueOf(o);
+                    }
+                }
+            }
+        }
+
+        return s;
+    }
+
+    public Object getObject(String string) throws JMSException
+    {
+        return getHeaders().getObject(string);
+    }
+
+    public void setBoolean(AMQShortString string, boolean b) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setBoolean(string, b);
+    }
+
+    public void setBoolean(String string, boolean b) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setBoolean(string, b);
+    }
+
+    public void setChar(String string, char c) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setChar(string, c);
+    }
+
+    public Object setBytes(AMQShortString string, byte[] bytes)
+    {
+        return getHeaders().setBytes(string, bytes);
+    }
+
+    public Object setBytes(String string, byte[] bytes)
+    {
+        return getHeaders().setBytes(string, bytes);
+    }
+
+    public Object setBytes(String string, byte[] bytes, int start, int length)
+    {
+        return getHeaders().setBytes(string, bytes, start, length);
+    }
+
+    public void setByte(String string, byte b) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setByte(string, b);
+    }
+
+    public void setShort(String string, short i) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setShort(string, i);
+    }
+
+    public void setInteger(String string, int i) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setInteger(string, i);
+    }
+
+    public void setLong(String string, long l) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setLong(string, l);
+    }
+
+    public void setFloat(String string, float v) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setFloat(string, v);
+    }
+
+    public void setDouble(String string, double v) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setDouble(string, v);
+    }
+
+    public void setString(String string, String string1) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setString(string, string1);
+    }
+
+    public void setString(AMQShortString string, String string1) throws JMSException
+    {
+        checkPropertyName(string);
+        getHeaders().setString(string, string1);
+    }
+
+    public void setObject(String string, Object object) throws JMSException
+    {
+        checkPropertyName(string);
+        try
+        {
+            getHeaders().setObject(string, object);
+        }
+        catch (AMQPInvalidClassException aice)
+        {
+            throw new MessageFormatException("Only primatives are allowed object is:" + object.getClass());
+        }
+    }
+
+    public boolean itemExists(String string) throws JMSException
+    {
+        return getHeaders().containsKey(string);
+    }
+
+    public Enumeration getPropertyNames()
+    {
+        return getHeaders().getPropertyNames();
+    }
+
+    public void clear()
+    {
+        getHeaders().clear();
+    }
+
+    public boolean propertyExists(AMQShortString propertyName)
+    {
+        return getHeaders().propertyExists(propertyName);
+    }
+
+    public boolean propertyExists(String propertyName)
+    {
+        return getHeaders().propertyExists(propertyName);
+    }
+
+    public Object put(Object key, Object value)
+    {
+        return getHeaders().setObject(key.toString(), value);
+    }
+
+    public Object remove(AMQShortString propertyName)
+    {
+        return getHeaders().remove(propertyName);
+    }
+
+    public Object remove(String propertyName)
+    {
+        return getHeaders().remove(propertyName);
+    }
+
+    public boolean isEmpty()
+    {
+        return getHeaders().isEmpty();
+    }
+
+    public void writeToBuffer(ByteBuffer data)
+    {
+        getHeaders().writeToBuffer(data);
+    }
+
+    public Enumeration getMapNames()
+    {
+        return getPropertyNames();
+    }
+
+    protected static void checkPropertyName(CharSequence propertyName)
+    {
+        if (propertyName == null)
+        {
+            throw new IllegalArgumentException("Property name must not be null");
+        }
+        else if (propertyName.length() == 0)
+        {
+            throw new IllegalArgumentException("Property name must not be the empty string");
+        }
+
+        checkIdentiferFormat(propertyName);
+    }
+
+    protected static void checkIdentiferFormat(CharSequence propertyName)
+    {
+//        JMS requirements 3.5.1 Property Names
+//        Identifiers:
+//        - An identifier is an unlimited-length character sequence that must begin
+//          with a Java identifier start character; all following characters must be Java
+//          identifier part characters. An identifier start character is any character for
+//          which the method Character.isJavaIdentifierStart returns true. This includes
+//          '_' and '$'. An identifier part character is any character for which the
+//          method Character.isJavaIdentifierPart returns true.
+//        - Identifiers cannot be the names NULL, TRUE, or FALSE.
+//         Identifiers cannot be NOT, AND, OR, BETWEEN, LIKE, IN, IS, or
+//          ESCAPE.
+//         Identifiers are either header field references or property references. The
+//          type of a property value in a message selector corresponds to the type
+//          used to set the property. If a property that does not exist in a message is
+//          referenced, its value is NULL. The semantics of evaluating NULL values
+//          in a selector are described in Section 3.8.1.2, Null Values.
+//         The conversions that apply to the get methods for properties do not
+//          apply when a property is used in a message selector expression. For
+//          example, suppose you set a property as a string value, as in the
+//          following:
+//              myMessage.setStringProperty("NumberOfOrders", "2");
+//          The following expression in a message selector would evaluate to false,
+//          because a string cannot be used in an arithmetic expression:
+//          "NumberOfOrders > 1"
+//         Identifiers are case sensitive.
+//         Message header field references are restricted to JMSDeliveryMode,
+//          JMSPriority, JMSMessageID, JMSTimestamp, JMSCorrelationID, and
+//          JMSType. JMSMessageID, JMSCorrelationID, and JMSType values may be
+//          null and if so are treated as a NULL value.
+
+        if (Boolean.getBoolean("strict-jms"))
+        {
+            // JMS start character
+            if (!(Character.isJavaIdentifierStart(propertyName.charAt(0))))
+            {
+                throw new IllegalArgumentException("Identifier '" + propertyName + "' does not start with a valid JMS identifier start character");
+            }
+
+            // JMS part character
+            int length = propertyName.length();
+            for (int c = 1; c < length; c++)
+            {
+                if (!(Character.isJavaIdentifierPart(propertyName.charAt(c))))
+                {
+                    throw new IllegalArgumentException("Identifier '" + propertyName + "' contains an invalid JMS identifier character");
+                }
+            }
+
+            // JMS invalid names
+            if ((propertyName.equals("NULL")
+                    || propertyName.equals("TRUE")
+                    || propertyName.equals("FALSE")
+                    || propertyName.equals("NOT")
+                    || propertyName.equals("AND")
+                    || propertyName.equals("OR")
+                    || propertyName.equals("BETWEEN")
+                    || propertyName.equals("LIKE")
+                    || propertyName.equals("IN")
+                    || propertyName.equals("IS")
+                    || propertyName.equals("ESCAPE")))
+            {
+                throw new IllegalArgumentException("Identifier '" + propertyName + "' is not allowed in JMS");
+            }
+        }
+
+    }
+}
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
index ae29cef90..10ed53092 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
@@ -56,7 +56,7 @@ public class JMSObjectMessage extends AbstractJMSMessage implements ObjectMessag
             _data = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE);
             _data.setAutoExpand(true);
         }
-        getJmsContentHeaderProperties().setContentType(MIME_TYPE_SHORT_STRING);
+        getContentHeaderProperties().setContentType(MIME_TYPE_SHORT_STRING);
     }
 
     /**
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
index f386346dd..6c2c9a99d 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
@@ -52,8 +52,8 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
     JMSTextMessage(ByteBuffer data, String encoding) throws JMSException
     {
         super(data); // this instantiates a content header
-        getJmsContentHeaderProperties().setContentType(MIME_TYPE_SHORT_STRING);
-        getJmsContentHeaderProperties().setEncoding(encoding);
+        getContentHeaderProperties().setContentType(MIME_TYPE_SHORT_STRING);
+        getContentHeaderProperties().setEncoding(encoding);
     }
 
     JMSTextMessage(long deliveryTag, BasicContentHeaderProperties contentHeader, ByteBuffer data)
@@ -113,7 +113,7 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
                 _data.limit(text.length()) ;
                 //_data.sweep();
                 _data.setAutoExpand(true);
-                final String encoding = getJmsContentHeaderProperties().getEncoding();
+                final String encoding = getContentHeaderProperties().getEncoding();
                 if (encoding == null)
                 {
                     _data.put(text.getBytes());
@@ -152,11 +152,11 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
             {
                 return null;
             }
-            if (getJmsContentHeaderProperties().getEncoding() != null)
+            if (getContentHeaderProperties().getEncoding() != null)
             {
                 try
                 {
-                    _decodedValue = _data.getString(Charset.forName(getJmsContentHeaderProperties().getEncoding()).newDecoder());
+                    _decodedValue = _data.getString(Charset.forName(getContentHeaderProperties().getEncoding()).newDecoder());
                 }
                 catch (CharacterCodingException e)
                 {
