diff --git a/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java b/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
index 5d0a30f94..a07a87b85 100644
--- a/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/AbstractJMSMessage.java
@@ -28,8 +28,9 @@ import org.apache.qpid.client.AMQQueue;
 import org.apache.qpid.client.AMQTopic;
 import org.apache.qpid.client.JmsNotImplementedException;
 import org.apache.qpid.framing.BasicContentHeaderProperties;
-import org.apache.qpid.framing.FieldTable;
 import org.apache.qpid.framing.FieldTableKeyEnumeration;
+import org.apache.qpid.framing.FieldTable;
+import org.apache.qpid.framing.PropertyFieldTable;
 
 import javax.jms.Destination;
 import javax.jms.JMSException;
@@ -42,16 +43,19 @@ public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms
 {
     private static final Map _destinationCache = Collections.synchronizedMap(new ReferenceMap());
 
-//    protected Map _messageProperties;
 
-    public static final char BOOLEAN_PROPERTY_PREFIX = 'B';
-    public static final char BYTE_PROPERTY_PREFIX = 'b';
-    public static final char SHORT_PROPERTY_PREFIX = 's';
-    public static final char INT_PROPERTY_PREFIX = 'i';
-    public static final char LONG_PROPERTY_PREFIX = 'l';
-    public static final char FLOAT_PROPERTY_PREFIX = 'f';
-    public static final char DOUBLE_PROPERTY_PREFIX = 'd';
-    public static final char STRING_PROPERTY_PREFIX = 'S';
+    //todo Remove these and Change _headers to use a subclass of PropertyFieldTable that limits
+    // the properties that can be added... or suitably handles the values that cannot be added to the
+    // AMQP header field table.
+    public static final char BOOLEAN_PROPERTY_PREFIX = PropertyFieldTable.BOOLEAN_PROPERTY_PREFIX;
+    public static final char BYTE_PROPERTY_PREFIX = PropertyFieldTable.BYTE_PROPERTY_PREFIX;
+    public static final char SHORT_PROPERTY_PREFIX = PropertyFieldTable.SHORT_PROPERTY_PREFIX;
+    public static final char INT_PROPERTY_PREFIX = PropertyFieldTable.INT_PROPERTY_PREFIX;
+    public static final char LONG_PROPERTY_PREFIX = PropertyFieldTable.LONG_PROPERTY_PREFIX;
+    public static final char FLOAT_PROPERTY_PREFIX = PropertyFieldTable.FLOAT_PROPERTY_PREFIX;
+    public static final char DOUBLE_PROPERTY_PREFIX = PropertyFieldTable.DOUBLE_PROPERTY_PREFIX;
+    public static final char STRING_PROPERTY_PREFIX = PropertyFieldTable.STRING_PROPERTY_PREFIX ;
+
 
     protected boolean _redelivered;
 
@@ -253,8 +257,18 @@ public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms
         }
         else
         {
-            // TODO: fix this
-            return getJmsContentHeaderProperties().getHeaders().containsKey(STRING_PROPERTY_PREFIX + propertyName);
+            Iterator keys = getJmsContentHeaderProperties().getHeaders().keySet().iterator();
+
+            while (keys.hasNext())
+            {
+                String key = (String) keys.next();
+
+                if (key.endsWith(propertyName))
+                {
+                    return true;
+                }
+            }
+            return false;
         }
     }
 
@@ -489,9 +503,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms
     public void setStringProperty(String propertyName, String value) throws JMSException
     {
         checkPropertyName(propertyName);
-        createPropertyMapIfRequired();
-        propertyName = STRING_PROPERTY_PREFIX + propertyName;
-        getJmsContentHeaderProperties().getHeaders().put(propertyName, value);
+        getJmsContentHeaderProperties().getHeaders().put(STRING_PROPERTY_PREFIX + propertyName, value);
     }
 
     private void createPropertyMapIfRequired()
@@ -504,7 +516,8 @@ public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms
 
     public void setObjectProperty(String string, Object object) throws JMSException
     {
-        //To change body of implemented methods use File | Settings | File Templates.
+        //todo this should be changed to something else.. the Header doesn't support objects.
+        throw new RuntimeException("Not Implemented");
     }
 
     public void acknowledge() throws JMSException
@@ -625,10 +638,7 @@ public abstract class AbstractJMSMessage extends AMQMessage implements javax.jms
             throw new IllegalArgumentException("Property name must not be the empty string");
         }
 
-        if (getJmsContentHeaderProperties().getHeaders() == null)
-        {
-            getJmsContentHeaderProperties().setHeaders(new FieldTable());
-        }
+        createPropertyMapIfRequired();
     }
 
     public FieldTable populateHeadersFromMessageProperties()
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessage.java
index df593cbd7..6921b0a4e 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessage.java
@@ -51,8 +51,9 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
 
     /**
      * Construct a bytes message with existing data.
+     *
      * @param data the data that comprises this message. If data is null, you get a 1024 byte buffer that is
-     * set to auto expand
+     *             set to auto expand
      */
     JMSBytesMessage(ByteBuffer data)
     {
@@ -67,12 +68,12 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
         _readable = (data != null);
     }
 
-    JMSBytesMessage(long messageNbr, ByteBuffer data, ContentHeaderBody contentHeader)
+    JMSBytesMessage(long messageNbr, ContentHeaderBody contentHeader, ByteBuffer data)
             throws AMQException
     {
         // TODO: this casting is ugly. Need to review whole ContentHeaderBody idea
         super(messageNbr, (BasicContentHeaderProperties) contentHeader.properties, data);
-        getJmsContentHeaderProperties().setContentType(MIME_TYPE);        
+        getJmsContentHeaderProperties().setContentType(MIME_TYPE);
         _readable = true;
     }
 
@@ -99,6 +100,7 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
      * We reset the stream before and after reading the data. This means that toString() will always output
      * the entire message and also that the caller can then immediately start reading as if toString() had
      * never been called.
+     *
      * @return
      * @throws IOException
      */
@@ -147,6 +149,7 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
 
     /**
      * Check that there is at least a certain number of bytes available to read
+     *
      * @param len the number of bytes
      * @throws MessageEOFException if there are less than len bytes available to read
      */
@@ -203,6 +206,7 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
 
     /**
      * Note that this method reads a unicode character as two bytes from the stream
+     *
      * @return the character read from the stream
      * @throws JMSException
      */
@@ -304,7 +308,7 @@ public class JMSBytesMessage extends AbstractJMSMessage implements javax.jms.Byt
     public void writeBoolean(boolean b) throws JMSException
     {
         checkWritable();
-        _data.put(b?(byte)1:(byte)0);
+        _data.put(b ? (byte) 1 : (byte) 0);
     }
 
     public void writeByte(byte b) throws JMSException
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessageFactory.java b/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessageFactory.java
index 6baf5326e..78f392a83 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessageFactory.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSBytesMessageFactory.java
@@ -30,7 +30,7 @@ public class JMSBytesMessageFactory extends AbstractJMSMessageFactory
 {
     protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException
     {
-        return new JMSBytesMessage(deliveryTag, data, contentHeader);
+        return new JMSBytesMessage(deliveryTag, contentHeader, data);
     }
 
     public AbstractJMSMessage createMessage() throws JMSException
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSMapMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSMapMessage.java
new file mode 100644
index 000000000..2001573ef
--- /dev/null
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSMapMessage.java
@@ -0,0 +1,291 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.    
+ *
+ * 
+ */
+package org.apache.qpid.client.message;
+
+import org.apache.mina.common.ByteBuffer;
+import org.apache.qpid.framing.BasicContentHeaderProperties;
+import org.apache.qpid.framing.PropertyFieldTable;
+import org.apache.qpid.AMQException;
+
+import javax.jms.JMSException;
+import javax.jms.MessageFormatException;
+import java.util.Enumeration;
+
+public class JMSMapMessage extends JMSTextMessage implements javax.jms.MapMessage
+{
+
+    public static final String MIME_TYPE = "jms/map-message";
+
+    private PropertyFieldTable _map;
+
+    JMSMapMessage() throws JMSException
+    {
+        this(null, null);
+    }
+
+    JMSMapMessage(ByteBuffer data, String encoding) throws JMSException
+    {
+        super(data); // this instantiates a content header
+        getJmsContentHeaderProperties().setContentType(MIME_TYPE);
+        getJmsContentHeaderProperties().setEncoding(encoding);
+        _map = new PropertyFieldTable();
+    }
+
+
+    JMSMapMessage(long deliveryTag, BasicContentHeaderProperties contentHeader, ByteBuffer data)
+            throws AMQException
+    {
+        super(deliveryTag, contentHeader, data);
+        contentHeader.setContentType(MIME_TYPE);
+
+        try
+        {
+            _map = new PropertyFieldTable(getText());
+        }
+        catch (JMSException e)
+        {
+            throw new AMQException(e.getMessage(), e);
+        }
+    }
+
+    // AbstractJMSMessage Interface
+
+    public void clearBody() throws JMSException
+    {
+        if (_data != null)
+        {
+            _data.release();
+        }
+        _data = null;
+    }
+
+    public String toBodyString() throws JMSException
+    {
+        return _map.toString();
+    }
+
+    public String getMimeType()
+    {
+        return MIME_TYPE;
+    }
+
+    // MapMessage  Interface
+
+    public boolean getBoolean(String string) throws JMSException
+    {
+        Boolean b = _map.getBoolean(string);
+
+        if (b == null)
+        {
+            b = Boolean.valueOf(_map.getString(string));
+        }
+
+        return b;
+    }
+
+    public byte getByte(String string) throws JMSException
+    {
+        Byte b = _map.getByte(string);
+        if (b == null)
+        {
+            b = Byte.valueOf(_map.getString(string));
+        }
+        return b;
+    }
+
+    public short getShort(String string) throws JMSException
+    {
+        Short s = _map.getShort(string);
+
+        if (s == null)
+        {
+            s = Short.valueOf(getByte(string));
+        }
+
+        return s;
+    }
+
+    public char getChar(String string) throws JMSException
+    {
+        return _map.getCharacter(string);
+    }
+
+    public int getInt(String string) throws JMSException
+    {
+        Integer i = _map.getInteger(string);
+
+        if (i == null)
+        {
+            i = Integer.valueOf(getShort(string));
+        }
+
+        return i;
+    }
+
+    public long getLong(String string) throws JMSException
+    {
+        Long l = _map.getLong(string);
+
+        if (l == null)
+        {
+            l = Long.valueOf(getInt(string));
+        }
+
+        return l;
+    }
+
+    public float getFloat(String string) throws JMSException
+    {
+        Float f = _map.getFloat(string);
+
+        if (f == null)
+        {
+            f = Float.valueOf(_map.getString(string));
+        }
+
+        return f;
+    }
+
+    public double getDouble(String string) throws JMSException
+    {
+        Double d = _map.getDouble(string);
+
+        if (d == null)
+        {
+            d = Double.valueOf(getFloat(string));
+        }
+
+        return d;
+    }
+
+    public String getString(String string) throws JMSException
+    {
+        String s = _map.getString(string);
+
+        if (s == null)
+        {
+            Object o = _map.getObject(string);
+            s = o.toString();
+        }
+
+        return s;
+    }
+
+    public byte[] getBytes(String string) throws JMSException
+    {
+        return _map.getBytes(string);
+    }
+
+    public Object getObject(String string) throws JMSException
+    {
+        return _map.getObject(string);
+    }
+
+    public Enumeration getMapNames() throws JMSException
+    {
+        return _map.getPropertyNames();
+    }
+
+    public void setBoolean(String string, boolean b) throws JMSException
+    {
+        _map.setBoolean(string, b);
+    }
+
+    public void setByte(String string, byte b) throws JMSException
+    {
+        _map.setByte(string, b);
+    }
+
+    public void setShort(String string, short i) throws JMSException
+    {
+        _map.setShort(string, i);
+    }
+
+    public void setChar(String string, char c) throws JMSException
+    {
+        _map.setChar(string, c);
+    }
+
+    public void setInt(String string, int i) throws JMSException
+    {
+        _map.setInteger(string, i);
+    }
+
+    public void setLong(String string, long l) throws JMSException
+    {
+        _map.setLong(string, l);
+    }
+
+    public void setFloat(String string, float v) throws JMSException
+    {
+
+        _map.setFloat(string, v);
+    }
+
+    public void setDouble(String string, double v) throws JMSException
+    {
+
+        _map.setDouble(string, v);
+    }
+
+    public void setString(String string, String string1) throws JMSException
+    {
+        _map.setString(string, string1);
+    }
+
+    public void setBytes(String string, byte[] bytes) throws JMSException
+    {
+        this.setBytes(string, bytes, 0, bytes.length);
+    }
+
+    public void setBytes(String string, byte[] bytes, int i, int i1) throws JMSException
+    {
+        _map.setBytes(string, bytes, i, i1);
+    }
+
+    public void setObject(String string, Object object) throws JMSException
+    {
+        _map.setObject(string, object);
+    }
+
+    public boolean itemExists(String string) throws JMSException
+    {
+        return _map.itemExists(string);
+    }
+
+    public ByteBuffer getData()
+    {
+
+        try
+        {
+            setText(toString());
+            return super.getData();
+        }
+        catch (JMSException e)
+        {
+            // should never occur according to setText
+            //fixme -- what to do if it does occur.
+        }
+
+        return ByteBuffer.allocate(0);
+    }
+
+}
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSMapMessageFactory.java b/client/src/main/java/org/apache/qpid/client/message/JMSMapMessageFactory.java
new file mode 100644
index 000000000..8d17f2bbf
--- /dev/null
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSMapMessageFactory.java
@@ -0,0 +1,41 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.    
+ *
+ * 
+ */
+package org.apache.qpid.client.message;
+
+import org.apache.mina.common.ByteBuffer;
+import org.apache.qpid.framing.ContentHeaderBody;
+import org.apache.qpid.framing.BasicContentHeaderProperties;
+import org.apache.qpid.AMQException;
+
+import javax.jms.JMSException;
+
+public class JMSMapMessageFactory extends AbstractJMSMessageFactory
+{
+    public AbstractJMSMessage createMessage() throws JMSException
+    {
+        return new JMSMapMessage();
+    }
+
+    protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException
+    {
+        return new JMSMapMessage(deliveryTag, (BasicContentHeaderProperties) contentHeader.properties, data);
+    }
+}
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
index 3c0d9b99c..34dd7e9ec 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessage.java
@@ -39,6 +39,7 @@ public class JMSObjectMessage extends AbstractJMSMessage implements ObjectMessag
     private final boolean _readonly;
 
     private static final int DEFAULT_BUFFER_SIZE = 1024;
+
     /**
      * Creates empty, writable message for use by producers
      */
@@ -62,7 +63,7 @@ public class JMSObjectMessage extends AbstractJMSMessage implements ObjectMessag
     /**
      * Creates read only message for delivery to consumers
      */
-    JMSObjectMessage(long messageNbr, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException
+    JMSObjectMessage(long messageNbr, ContentHeaderBody contentHeader, ByteBuffer data) throws AMQException
     {
         super(messageNbr, (BasicContentHeaderProperties) contentHeader.properties, data);
         _readonly = data != null;
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessageFactory.java b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessageFactory.java
index 9d4a11650..b2228a680 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessageFactory.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSObjectMessageFactory.java
@@ -30,7 +30,7 @@ public class JMSObjectMessageFactory extends AbstractJMSMessageFactory
 {
     protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException
     {
-        return new JMSObjectMessage(deliveryTag, data, contentHeader);
+        return new JMSObjectMessage(deliveryTag, contentHeader, data);
     }
 
     public AbstractJMSMessage createMessage() throws JMSException
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
index 4983f6b62..2624c2010 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessage.java
@@ -47,7 +47,7 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
         getJmsContentHeaderProperties().setEncoding(encoding);
     }
 
-    JMSTextMessage(long deliveryTag, ByteBuffer data, BasicContentHeaderProperties contentHeader)
+    JMSTextMessage(long deliveryTag, BasicContentHeaderProperties contentHeader, ByteBuffer data)
             throws AMQException
     {
         super(deliveryTag, contentHeader, data);
@@ -62,7 +62,7 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
 
     JMSTextMessage(String text) throws JMSException
     {
-        super((ByteBuffer)null);
+        super((ByteBuffer) null);
         setText(text);
     }
 
@@ -113,7 +113,8 @@ public class JMSTextMessage extends AbstractJMSMessage implements javax.jms.Text
         catch (UnsupportedEncodingException e)
         {
             // should never occur
-            throw new JMSException("Unable to decode string data");
+            JMSException jmse = new JMSException("Unable to decode string data");
+            jmse.setLinkedException(e);
         }
     }
 
diff --git a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessageFactory.java b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessageFactory.java
index d554794fd..e7ddde279 100644
--- a/client/src/main/java/org/apache/qpid/client/message/JMSTextMessageFactory.java
+++ b/client/src/main/java/org/apache/qpid/client/message/JMSTextMessageFactory.java
@@ -37,6 +37,6 @@ public class JMSTextMessageFactory extends AbstractJMSMessageFactory
 
     protected AbstractJMSMessage createMessage(long deliveryTag, ByteBuffer data, ContentHeaderBody contentHeader) throws AMQException
     {
-        return new JMSTextMessage(deliveryTag, data, (BasicContentHeaderProperties)contentHeader.properties);
+        return new JMSTextMessage(deliveryTag, (BasicContentHeaderProperties) contentHeader.properties, data);
     }
 }
diff --git a/client/src/main/java/org/apache/qpid/client/message/MessageFactoryRegistry.java b/client/src/main/java/org/apache/qpid/client/message/MessageFactoryRegistry.java
index e6709adb0..31c9c2ed9 100644
--- a/client/src/main/java/org/apache/qpid/client/message/MessageFactoryRegistry.java
+++ b/client/src/main/java/org/apache/qpid/client/message/MessageFactoryRegistry.java
@@ -98,6 +98,7 @@ public class MessageFactoryRegistry
     public static MessageFactoryRegistry newDefaultRegistry()
     {
         MessageFactoryRegistry mf = new MessageFactoryRegistry();
+        mf.registerFactory(JMSMapMessage.MIME_TYPE, new JMSMapMessageFactory());
         mf.registerFactory("text/plain", new JMSTextMessageFactory());
         mf.registerFactory("text/xml", new JMSTextMessageFactory());
         mf.registerFactory("application/octet-stream", new JMSBytesMessageFactory());
diff --git a/client/src/test/java/org/apache/qpid/client/message/TestMessageHelper.java b/client/src/test/java/org/apache/qpid/client/message/TestMessageHelper.java
index a35c833f9..c34dbf14f 100644
--- a/client/src/test/java/org/apache/qpid/client/message/TestMessageHelper.java
+++ b/client/src/test/java/org/apache/qpid/client/message/TestMessageHelper.java
@@ -34,4 +34,8 @@ public class TestMessageHelper
         return new JMSBytesMessage();
     }
 
+    public static JMSMapMessage newJMSMapMessage() throws JMSException
+    {
+        return new JMSMapMessage();
+    }
 }
diff --git a/client/src/test/java/org/apache/qpid/test/unit/basic/BytesMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/basic/BytesMessageTest.java
index bf97c1918..4d37c5d2a 100644
--- a/client/src/test/java/org/apache/qpid/test/unit/basic/BytesMessageTest.java
+++ b/client/src/test/java/org/apache/qpid/test/unit/basic/BytesMessageTest.java
@@ -35,6 +35,7 @@ import java.util.List;
 import javax.jms.*;
 
 import junit.framework.TestCase;
+import junit.framework.Assert;
 
 public class BytesMessageTest extends TestCase implements MessageListener
 {
@@ -95,6 +96,17 @@ public class BytesMessageTest extends TestCase implements MessageListener
         for (int i = 0; i < count; i++)
         {
             BytesMessage msg = _session.createBytesMessage();
+
+            try
+            {
+                msg.readFloat();
+                Assert.fail("Message should not be readable");
+            }
+            catch (MessageNotReadableException mnwe)
+            {
+                //normal execution
+            }
+
             byte[] data = ("Message " + i).getBytes();
             msg.writeBytes(data);
             messages.add(data);
@@ -122,6 +134,16 @@ public class BytesMessageTest extends TestCase implements MessageListener
             byte[] data = new byte[buffer.remaining()];
             buffer.get(data);
             actual.add(data);
+
+            try
+            {
+                m.writeBoolean(true);
+                Assert.fail("Message should not be writeable");
+            }
+            catch (MessageNotWriteableException mnwe)
+            {
+                //normal execution
+            }
         }
 
         assertEqual(messages.iterator(), actual.iterator());
diff --git a/client/src/test/java/org/apache/qpid/test/unit/basic/FieldTableMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/basic/FieldTableMessageTest.java
index b96994212..67b7f4956 100644
--- a/client/src/test/java/org/apache/qpid/test/unit/basic/FieldTableMessageTest.java
+++ b/client/src/test/java/org/apache/qpid/test/unit/basic/FieldTableMessageTest.java
@@ -24,8 +24,6 @@ import org.apache.qpid.client.AMQConnection;
 import org.apache.qpid.client.AMQDestination;
 import org.apache.qpid.client.AMQQueue;
 import org.apache.qpid.client.AMQSession;
-import org.apache.qpid.client.vmbroker.AMQVMBrokerCreationException;
-import org.apache.qpid.client.transport.TransportConnection;
 import org.apache.qpid.client.message.JMSBytesMessage;
 import org.apache.qpid.framing.AMQFrameDecodingException;
 import org.apache.qpid.framing.FieldTable;
diff --git a/client/src/test/java/org/apache/qpid/test/unit/basic/MapMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/basic/MapMessageTest.java
new file mode 100644
index 000000000..7ec5d056e
--- /dev/null
+++ b/client/src/test/java/org/apache/qpid/test/unit/basic/MapMessageTest.java
@@ -0,0 +1,219 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.apache.qpid.test.unit.basic;
+
+import org.apache.qpid.client.AMQConnection;
+import org.apache.qpid.client.AMQDestination;
+import org.apache.qpid.client.AMQQueue;
+import org.apache.qpid.client.AMQSession;
+import org.apache.qpid.client.vmbroker.AMQVMBrokerCreationException;
+import org.apache.qpid.client.transport.TransportConnection;
+import org.apache.qpid.client.message.JMSTextMessage;
+import org.apache.qpid.client.message.JMSMapMessage;
+import org.apache.qpid.test.VMBrokerSetup;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import javax.jms.*;
+
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class MapMessageTest extends TestCase implements MessageListener
+{
+    private AMQConnection _connection;
+    private Destination _destination;
+    private AMQSession _session;
+    private final List<JMSMapMessage> received = new ArrayList<JMSMapMessage>();
+    private final List<String> messages = new ArrayList<String>();
+    private int _count = 100;
+    public String _connectionString = "vm://:1";
+
+    protected void setUp() throws Exception
+    {
+        super.setUp();
+        try
+        {
+            TransportConnection.createVMBroker(1);
+            init(new AMQConnection(_connectionString, "guest", "guest", randomize("Client"), "/test_path"));
+        }
+        catch (Exception e)
+        {
+            fail("Unable to initialilse connection: " + e);
+        }
+    }
+
+    protected void tearDown() throws Exception
+    {
+        super.tearDown();
+    }
+
+    private void init(AMQConnection connection) throws Exception
+    {
+        Destination destination = new AMQQueue(randomize("MapMessageTest"), true);
+        init(connection, destination);
+    }
+
+    private void init(AMQConnection connection, Destination destination) throws Exception
+    {
+        _connection = connection;
+        _destination = destination;
+        _session = (AMQSession) connection.createSession(false, AMQSession.AUTO_ACKNOWLEDGE);
+
+        //set up a slow consumer
+        _session.createConsumer(destination).setMessageListener(this);
+        connection.start();
+    }
+
+    public void test() throws Exception
+    {
+        int count = _count;
+        send(count);
+        waitFor(count);
+        check();
+        System.out.println("Completed without failure");
+        _connection.close();
+    }
+
+    void send(int count) throws JMSException
+    {
+        //create a publisher
+        MessageProducer producer = _session.createProducer(_destination);
+        for (int i = 0; i < count; i++)
+        {
+            String text = "Message " + i;
+            messages.add(text);
+            MapMessage message = _session.createMapMessage();
+
+            message.setBoolean("odd", i / 2 == 0);
+            message.setInt("messageNumber", i);
+            message.setString("message", text);
+
+            producer.send(message);
+        }
+    }
+
+    void waitFor(int count) throws InterruptedException
+    {
+        synchronized(received)
+        {
+            while (received.size() < count)
+            {
+                received.wait();
+            }
+        }
+    }
+
+    void check() throws JMSException
+    {
+        List<String> actual = new ArrayList<String>();
+        int count = 0;
+        for (JMSMapMessage m : received)
+        {
+            actual.add(m.getString("message"));
+            assertEqual(m.getInt("messageNumber"), count);
+            assertEqual(m.getBoolean("odd"), count / 2 == 0);
+
+//            try
+//            {
+//                m.setInt("testint", 3);
+//                Assert.fail("Message should not be writeable");
+//            }
+//            catch (MessageNotWriteableException mnwe)
+//            {
+//                //normal execution
+//            }
+
+
+            count++;
+        }
+
+        assertEqual(messages.iterator(), actual.iterator());
+    }
+
+    private static void assertEqual(Iterator expected, Iterator actual)
+    {
+        List<String> errors = new ArrayList<String>();
+        while (expected.hasNext() && actual.hasNext())
+        {
+            try
+            {
+                assertEqual(expected.next(), actual.next());
+            }
+            catch (Exception e)
+            {
+                errors.add(e.getMessage());
+            }
+        }
+        while (expected.hasNext())
+        {
+            errors.add("Expected " + expected.next() + " but no more actual values.");
+        }
+        while (actual.hasNext())
+        {
+            errors.add("Found " + actual.next() + " but no more expected values.");
+        }
+        if (!errors.isEmpty())
+        {
+            throw new RuntimeException(errors.toString());
+        }
+    }
+
+    private static void assertEqual(Object expected, Object actual)
+    {
+        if (!expected.equals(actual))
+        {
+            throw new RuntimeException("Expected '" + expected + "' found '" + actual + "'");
+        }
+    }
+
+    public void onMessage(Message message)
+    {
+        synchronized(received)
+        {
+            received.add((JMSMapMessage) message);
+            received.notify();
+        }
+    }
+
+    private static String randomize(String in)
+    {
+        return in + System.currentTimeMillis();
+    }
+
+    public static void main(String[] argv) throws Exception
+    {
+        MapMessageTest test = new MapMessageTest();
+        test._connectionString = argv.length == 0 ? "vm://:1" : argv[0];
+        test.setUp();
+        if (argv.length > 1)
+        {
+            test._count = Integer.parseInt(argv[1]);
+        }
+        test.test();
+    }
+
+    public static junit.framework.Test suite()
+    {
+        return new VMBrokerSetup(new junit.framework.TestSuite(MapMessageTest.class));
+    }
+}
diff --git a/client/src/test/java/org/apache/qpid/test/unit/basic/ObjectMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/basic/ObjectMessageTest.java
index c09369b4b..71f8e1253 100644
--- a/client/src/test/java/org/apache/qpid/test/unit/basic/ObjectMessageTest.java
+++ b/client/src/test/java/org/apache/qpid/test/unit/basic/ObjectMessageTest.java
@@ -32,12 +32,14 @@ import javax.jms.JMSException;
 import javax.jms.Message;
 import javax.jms.MessageListener;
 import javax.jms.MessageProducer;
+import javax.jms.MessageNotWriteableException;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import junit.framework.TestCase;
+import junit.framework.Assert;
 
 public class ObjectMessageTest extends TestCase implements MessageListener
 {
@@ -53,7 +55,7 @@ public class ObjectMessageTest extends TestCase implements MessageListener
     {
         super.setUp();
         try
-        {      
+        {
             init(new AMQConnection(_connectionString, "guest", "guest", randomize("Client"), "/test_path"));
         }
         catch (Exception e)
@@ -122,6 +124,17 @@ public class ObjectMessageTest extends TestCase implements MessageListener
         for (JMSObjectMessage m : received)
         {
             actual.add(m.getObject());
+
+            try
+            {
+                m.setObject("Test text");
+                Assert.fail("Message should not be writeable");
+            }
+            catch (MessageNotWriteableException mnwe)
+            {
+                //normal execution
+            }
+
         }
 
         assertEqual(messages.iterator(), actual.iterator());
diff --git a/client/src/test/java/org/apache/qpid/test/unit/basic/TextMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/basic/TextMessageTest.java
index 11f511449..10e918c4e 100644
--- a/client/src/test/java/org/apache/qpid/test/unit/basic/TextMessageTest.java
+++ b/client/src/test/java/org/apache/qpid/test/unit/basic/TextMessageTest.java
@@ -35,6 +35,7 @@ import java.util.List;
 import javax.jms.*;
 
 import junit.framework.TestCase;
+import junit.framework.Assert;
 
 public class TextMessageTest extends TestCase implements MessageListener
 {
@@ -120,6 +121,17 @@ public class TextMessageTest extends TestCase implements MessageListener
         for (JMSTextMessage m : received)
         {
             actual.add(m.getText());
+            
+            try
+            {
+                m.setText("Test text");
+                Assert.fail("Message should not be writeable");
+            }
+            catch (MessageNotWriteableException mnwe)
+            {
+                //normal execution
+            }
+
         }
 
         assertEqual(messages.iterator(), actual.iterator());
diff --git a/client/src/test/java/org/apache/qpid/test/unit/client/message/MapMessageTest.java b/client/src/test/java/org/apache/qpid/test/unit/client/message/MapMessageTest.java
new file mode 100644
index 000000000..f55f2428c
--- /dev/null
+++ b/client/src/test/java/org/apache/qpid/test/unit/client/message/MapMessageTest.java
@@ -0,0 +1,357 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.    
+ *
+ * 
+ */
+package org.apache.qpid.test.unit.client.message;
+
+import junit.framework.TestCase;
+import junit.framework.Assert;
+import org.apache.qpid.framing.PropertyFieldTable;
+import org.apache.qpid.client.message.JMSMapMessage;
+import org.apache.qpid.client.message.TestMessageHelper;
+
+import javax.jms.JMSException;
+import javax.jms.MessageFormatException;
+
+
+public class MapMessageTest extends TestCase
+{
+
+    //Test Lookups
+
+    public void testBooleanLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+
+            mm.setBoolean("value", true);
+            Assert.assertEquals(true, mm.getBoolean("value"));
+            Assert.assertEquals("true", mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testByteLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setByte("value", Byte.MAX_VALUE);
+
+            Assert.assertEquals(Byte.MAX_VALUE, mm.getByte("value"));
+            Assert.assertEquals((short) Byte.MAX_VALUE, mm.getShort("value"));
+            Assert.assertEquals(Byte.MAX_VALUE, mm.getInt("value"));
+            Assert.assertEquals((long) Byte.MAX_VALUE, mm.getLong("value"));
+            Assert.assertEquals("" + Byte.MAX_VALUE, mm.getString("value"));
+
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testShortLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setShort("value", Short.MAX_VALUE);
+            Assert.assertEquals(Short.MAX_VALUE, mm.getShort("value"));
+            Assert.assertEquals((int) Short.MAX_VALUE, mm.getInt("value"));
+            Assert.assertEquals((long) Short.MAX_VALUE, mm.getLong("value"));
+            Assert.assertEquals("" + Short.MAX_VALUE, mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+
+    public void testCharLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+
+            mm.setChar("value", 'c');
+            Assert.assertEquals('c', mm.getChar("value"));
+            Assert.assertEquals("c", mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testDoubleLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setDouble("value", Double.MAX_VALUE);
+            Assert.assertEquals(Double.MAX_VALUE, mm.getDouble("value"));
+            Assert.assertEquals("" + Double.MAX_VALUE, mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testFloatLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setFloat("value", Float.MAX_VALUE);
+            Assert.assertEquals(Float.MAX_VALUE, mm.getFloat("value"));
+            Assert.assertEquals((double) Float.MAX_VALUE, mm.getDouble("value"));
+            Assert.assertEquals("" + Float.MAX_VALUE, mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testIntLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setInt("value", Integer.MAX_VALUE);
+            Assert.assertEquals(Integer.MAX_VALUE, mm.getInt("value"));
+            Assert.assertEquals((long) Integer.MAX_VALUE, mm.getLong("value"));
+            Assert.assertEquals("" + Integer.MAX_VALUE, mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testLongLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.setLong("value", Long.MAX_VALUE);
+            Assert.assertEquals(Long.MAX_VALUE, mm.getLong("value"));
+            Assert.assertEquals("" + Long.MAX_VALUE, mm.getString("value"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testBytesLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            byte[] bytes = {99, 98, 97, 96, 95};
+            mm.setBytes("bytes", bytes);
+            assertBytesEqual(bytes, mm.getBytes("bytes"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    // Failed Lookups
+
+    public void testFailedBooleanLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            Assert.assertEquals(false, mm.getBoolean("int"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received." + e);
+        }
+    }
+
+    public void testFailedByteLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getByte("random");
+            Assert.fail("NumberFormatException should be received.");
+        }
+        catch (NumberFormatException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+
+    }
+
+    public void testFailedBytesLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            Assert.assertEquals(null, mm.getBytes("random"));
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedCharLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getChar("random");
+            Assert.fail("NullPointerException should be received.");
+        }
+        catch (NullPointerException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedDoubleLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getDouble("random");
+            Assert.fail("NullPointerException should be received.");
+        }
+        catch (NullPointerException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedFloatLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getFloat("random");
+            Assert.fail("NullPointerException should be received.");
+        }
+        catch (NullPointerException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedIntLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getInt("random");
+            Assert.fail("NumberFormatException should be received.");
+        }
+        catch (NumberFormatException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedLongLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getLong("random");
+            Assert.fail("NumberFormatException should be received.");
+        }
+        catch (NumberFormatException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+    public void testFailedShortLookup()
+    {
+        try
+        {
+            JMSMapMessage mm = TestMessageHelper.newJMSMapMessage();
+            mm.getShort("random");
+            Assert.fail("NumberFormatException should be received.");
+        }
+        catch (NumberFormatException e)
+        {
+            //normal execution
+        }
+        catch (JMSException e)
+        {
+            Assert.fail("JMSException received:" + e);
+        }
+    }
+
+
+    private void assertBytesEqual(byte[] expected, byte[] actual)
+    {
+        Assert.assertEquals(expected.length, actual.length);
+
+        for (int index = 0; index < expected.length; index++)
+        {
+            Assert.assertEquals(expected[index], actual[index]);
+        }
+    }
+
+    public static junit.framework.Test suite()
+    {
+        return new junit.framework.TestSuite(MapMessageTest.class);
+    }
+
+
+}
