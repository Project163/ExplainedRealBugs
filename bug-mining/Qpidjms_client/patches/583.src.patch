diff --git a/client/src/main/java/org/apache/qpid/client/AMQSession.java b/client/src/main/java/org/apache/qpid/client/AMQSession.java
index e27730cd4..a84c093d8 100644
--- a/client/src/main/java/org/apache/qpid/client/AMQSession.java
+++ b/client/src/main/java/org/apache/qpid/client/AMQSession.java
@@ -2324,6 +2324,15 @@ public abstract class AMQSession<C extends BasicMessageConsumer, P extends Basic
             _failedOverDirty = true;
         }
 
+        // Also reset the delivery tag tracker, to insure we dont
+        // return the first <total number of msgs received on session>
+        // messages sent by the brokers following the first rollback
+        // after failover
+        _highestDeliveryTag.set(-1);
+
+        _unacknowledgedMessageTags.clear();
+        _prefetchedMessageTags.clear();
+
         _rollbackMark.set(-1);
         resubscribeProducers();
         resubscribeConsumers();
@@ -2431,15 +2440,8 @@ public abstract class AMQSession<C extends BasicMessageConsumer, P extends Basic
     void stop() throws QpidException
     {
         // Stop the server delivering messages to this session.
-        if (!(isClosed() || isClosing()))
-        {
-            suspendChannel(true);
-        }
-
-        if (_dispatcher != null)
-        {
-            _dispatcher.setConnectionStopped(true);
-        }
+        suspendChannelIfNotClosing();
+        stopExistingDispatcher();
     }
 
     private void checkNotTransacted() throws JMSException
@@ -3686,5 +3688,31 @@ public abstract class AMQSession<C extends BasicMessageConsumer, P extends Basic
     {
         return _messageEncryptionHelper;
     }
+
+    protected void drainDispatchQueueWithDispatcher()
+    {
+        if (!_queue.isEmpty())
+        {
+            setUsingDispatcherForCleanup(true);
+            drainDispatchQueue();
+            setUsingDispatcherForCleanup(false);
+        }
+    }
+
+    protected void stopExistingDispatcher()
+    {
+        if (_dispatcher != null)
+        {
+            _dispatcher.setConnectionStopped(true);
+        }
+    }
+
+    protected void suspendChannelIfNotClosing() throws QpidException
+    {
+        if (!(isClosed() || isClosing()))
+        {
+            suspendChannel(true);
+        }
+    }
 }
 
diff --git a/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java b/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
index 0e13ad168..92f4951bf 100644
--- a/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
+++ b/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
@@ -1278,17 +1278,11 @@ public class AMQSession_0_10 extends AMQSession<BasicMessageConsumer_0_10, Basic
     @Override
     void resubscribe() throws QpidException
     {
-        // Also reset the delivery tag tracker, to insure we dont
-        // return the first <total number of msgs received on session>
-        // messages sent by the brokers following the first rollback
-        // after failover
-        getHighestDeliveryTag().set(-1);
         // Clear txRangeSet/unacknowledgedMessageTags so we don't complete commands corresponding to
         //messages that came from the old broker.
         _txRangeSet.clear();
         _txSize = 0;
-        getUnacknowledgedMessageTags().clear();
-        getPrefetchedMessageTags().clear();
+
         super.resubscribe();
         getQpidSession().sync();
     }
@@ -1296,10 +1290,10 @@ public class AMQSession_0_10 extends AMQSession<BasicMessageConsumer_0_10, Basic
     @Override
     void stop() throws QpidException
     {
-        super.stop();
-        setUsingDispatcherForCleanup(true);
-        drainDispatchQueue();
-        setUsingDispatcherForCleanup(false);
+        // Stop the server delivering messages to this session.
+        suspendChannelIfNotClosing();
+        drainDispatchQueueWithDispatcher();
+        stopExistingDispatcher();
 
         for (BasicMessageConsumer consumer : getConsumers())
         {
diff --git a/client/src/main/java/org/apache/qpid/client/AMQSession_0_8.java b/client/src/main/java/org/apache/qpid/client/AMQSession_0_8.java
index c1d62489e..e62ac8f95 100644
--- a/client/src/main/java/org/apache/qpid/client/AMQSession_0_8.java
+++ b/client/src/main/java/org/apache/qpid/client/AMQSession_0_8.java
@@ -179,6 +179,16 @@ public class AMQSession_0_8 extends AMQSession<BasicMessageConsumer_0_8, BasicMe
         getUnacknowledgedMessageTags().remove(deliveryTag);
     }
 
+    @Override
+    void resubscribe() throws QpidException
+    {
+        // drain dispatch queue
+        drainDispatchQueueWithDispatcher();
+
+        getDeliveredMessageTags().clear();
+        super.resubscribe();
+    }
+
     public void sendQueueBind(final String queueName, final String routingKey, final Map<String,Object> arguments,
                               final String exchangeName, final AMQDestination destination,
                               final boolean nowait) throws QpidException, FailoverException
diff --git a/client/src/test/java/org/apache/qpid/client/AMQSession_0_10Test.java b/client/src/test/java/org/apache/qpid/client/AMQSession_0_10Test.java
index 2284ab4d3..d7ddde518 100644
--- a/client/src/test/java/org/apache/qpid/client/AMQSession_0_10Test.java
+++ b/client/src/test/java/org/apache/qpid/client/AMQSession_0_10Test.java
@@ -18,7 +18,14 @@
  */
 package org.apache.qpid.client;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
 
 import javax.jms.JMSException;
@@ -28,10 +35,12 @@ import javax.jms.MessageProducer;
 import javax.jms.StreamMessage;
 
 import org.apache.qpid.client.message.AMQPEncodedListMessage;
+import org.apache.qpid.client.message.UnprocessedMessage;
 import org.apache.qpid.test.utils.QpidTestCase;
 import org.apache.qpid.transport.*;
 import org.apache.qpid.transport.Connection.SessionFactory;
 import org.apache.qpid.transport.Connection.State;
+import org.apache.qpid.url.AMQBindingURL;
 
 /**
  * Tests AMQSession_0_10 methods.
@@ -456,6 +465,91 @@ public class AMQSession_0_10Test extends QpidTestCase
         assertNotNull("QueueQuery command was not sent", command);
     }
 
+    public void testResubscribe() throws Exception
+    {
+        AMQSession_0_10 session = createAMQSession_0_10(AMQSession_0_10.AUTO_ACKNOWLEDGE);
+
+        AMQQueue queue1 = new AMQQueue(new AMQBindingURL("direct://amq.direct//test1?routingkey='test1'&durable='true'"));
+        session.createProducer(queue1);
+        BasicMessageConsumer_0_10 consumer1 = (BasicMessageConsumer_0_10)session.createConsumer(queue1);
+
+        AMQQueue queue2 = new AMQQueue(new AMQBindingURL("direct://amq.direct//test2?routingkey='test2'"));
+        session.createProducer(queue2);
+        BasicMessageConsumer_0_10 consumer2 = (BasicMessageConsumer_0_10)session.createConsumer(queue2);
+
+        UnprocessedMessage[] messages = new UnprocessedMessage[4];
+        for (int i =0; i< messages.length;i++ )
+        {
+            int consumerTag = i % 2 == 0 ? consumer1.getConsumerTag() : consumer2.getConsumerTag();
+            int deliveryTag = i + 1;
+            messages[i]= createMockMessage(deliveryTag, consumerTag);
+            session.messageReceived(messages[i]);
+            if (deliveryTag % 2 == 0)
+            {
+                session.addUnacknowledgedMessage(deliveryTag);
+            }
+        }
+
+        assertEquals("Unexpected highest delivery tag", 4, session.getHighestDeliveryTag().get());
+        assertFalse("Unexpected unacknowledged message tags", session.getUnacknowledgedMessageTags().isEmpty());
+        assertEquals("Unexpected consumers", new HashSet<>(Arrays.asList(consumer1, consumer2)), new HashSet<>(session.getConsumers()));
+
+        // verify test messages were not dispatched
+        for (UnprocessedMessage message: messages )
+        {
+            verify(message, never()).dispatch(session);
+        }
+
+        session.resubscribe();
+
+        assertEquals("Unexpected highest delivery tag", -1, session.getHighestDeliveryTag().get());
+        assertTrue("Unexpected unacknowledged message tags", session.getUnacknowledgedMessageTags().isEmpty());
+        assertTrue("Unexpected pre-fetched message tags", session.getPrefetchedMessageTags().isEmpty());
+        assertEquals("Unexpected consumers", new HashSet<>(Arrays.asList(consumer1, consumer2)), new HashSet<>(session.getConsumers()));
+    }
+
+    public void testFailoverPrep() throws Exception
+    {
+        AMQSession_0_10 session = createAMQSession_0_10(AMQSession_0_10.AUTO_ACKNOWLEDGE);
+
+        UnprocessedMessage[] messages = new UnprocessedMessage[4];
+        for (int i =0; i< messages.length;i++ )
+        {
+            int consumerTag = i % 2;
+            int deliveryTag = i + 1;
+            messages[i]= createMockMessage(deliveryTag, consumerTag);
+            session.messageReceived(messages[i]);
+            if (deliveryTag % 2 == 0)
+            {
+                session.addUnacknowledgedMessage(deliveryTag);
+            }
+        }
+
+        // verify test messages were not dispatched
+        for (UnprocessedMessage message: messages )
+        {
+            verify(message, never()).dispatch(session);
+        }
+
+        session.failoverPrep();
+
+        // verify dispatcher queue is drained
+        for (UnprocessedMessage message: messages )
+        {
+            verify(message).dispatch(session);
+        }
+    }
+
+    private UnprocessedMessage createMockMessage(long deliveryTag, int consumerTag)
+    {
+        UnprocessedMessage message = mock(UnprocessedMessage.class);
+        when(message.getConsumerTag()).thenReturn(consumerTag);
+        when(message.getDeliveryTag()).thenReturn(deliveryTag);
+        return message;
+    }
+
+
+
     private AMQAnyDestination createDestination()
     {
         AMQAnyDestination destination = null;
diff --git a/client/src/test/java/org/apache/qpid/client/AMQSession_0_8Test.java b/client/src/test/java/org/apache/qpid/client/AMQSession_0_8Test.java
index 92abfab09..4a94a04d4 100644
--- a/client/src/test/java/org/apache/qpid/client/AMQSession_0_8Test.java
+++ b/client/src/test/java/org/apache/qpid/client/AMQSession_0_8Test.java
@@ -20,9 +20,25 @@
  */
 package org.apache.qpid.client;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+
 import org.apache.qpid.QpidException;
+import org.apache.qpid.client.message.UnprocessedMessage;
 import org.apache.qpid.client.transport.TestNetworkConnection;
+import org.apache.qpid.configuration.ClientProperties;
+import org.apache.qpid.framing.AMQBody;
 import org.apache.qpid.framing.AMQShortString;
+import org.apache.qpid.framing.BasicConsumeOkBody;
+import org.apache.qpid.framing.ChannelFlowOkBody;
+import org.apache.qpid.framing.ExchangeDeclareOkBody;
 import org.apache.qpid.framing.QueueDeclareOkBody;
 import org.apache.qpid.test.utils.QpidTestCase;
 import org.apache.qpid.transport.network.NetworkConnection;
@@ -43,21 +59,8 @@ public class AMQSession_0_8Test extends QpidTestCase
     {
         final String testQueueName = "tmp_127_0_0_1_1_1";
 
-        _connection.setConnectionListener(new ConnectionListenerSupport()
-        {
-            @Override
-            public void bytesSent(long count)
-            {
-                try
-                {
-                    _connection.getProtocolHandler().methodBodyReceived(1, new QueueDeclareOkBody(AMQShortString.valueOf(testQueueName), 0, 0));
-                }
-                catch (QpidException e)
-                {
-                    throw new RuntimeException(e);
-                }
-            }
-        });
+        _connection.setConnectionListener(new MockReceiveConnectionListener(_connection, 1,
+                new QueueDeclareOkBody(AMQShortString.valueOf(testQueueName), 0, 0)));
 
         AMQSession_0_8 session = new AMQSession_0_8(_connection, 1, true, 0, 1, 1);
 
@@ -70,4 +73,137 @@ public class AMQSession_0_8Test extends QpidTestCase
 
         assertEquals("Unexpected queue name", testQueueName, queue.getAMQQueueName());
     }
+
+    public void testResubscribe() throws Exception
+    {
+        // to verify producer resubscribe set qpid.declare_exchanges=true
+        setTestSystemProperty(ClientProperties.QPID_DECLARE_EXCHANGES_PROP_NAME, "true");
+        setTestSystemProperty(ClientProperties.QPID_DECLARE_QUEUES_PROP_NAME, "false");
+        setTestSystemProperty(ClientProperties.QPID_BIND_QUEUES_PROP_NAME, "false");
+
+        AMQSession_0_8 session = new AMQSession_0_8(_connection, 1, true, 0, 1, 1);
+
+        AMQQueue queue1 = new AMQQueue(new AMQBindingURL("direct://amq.direct//test1?routingkey='test1'"));
+
+        // expecting exchange declare Ok
+        MockReceiveConnectionListener listener = new MockReceiveConnectionListener(_connection, 1, new ExchangeDeclareOkBody());
+        _connection.setConnectionListener(listener);
+        session.createProducer(queue1);
+        assertTrue("Not all expected commands have been sent on producer1 creation", listener.responsesEmpty());
+
+        // expecting exchange declare Ok, Channel flow Ok, Consume Ok
+        listener = new MockReceiveConnectionListener(_connection, 1,
+                new ExchangeDeclareOkBody(), new ChannelFlowOkBody(false), new BasicConsumeOkBody(AMQShortString.valueOf("1")));
+        _connection.setConnectionListener(listener );
+        BasicMessageConsumer_0_8 consumer1 = (BasicMessageConsumer_0_8)session.createConsumer(queue1);
+        assertTrue("Not all expected commands have been sent on consumer1 creation", listener.responsesEmpty());
+
+        // expecting exchange declare Ok
+        listener = new MockReceiveConnectionListener(_connection, 1, new ExchangeDeclareOkBody());
+        _connection.setConnectionListener(listener);
+        AMQQueue queue2 = new AMQQueue(new AMQBindingURL("direct://amq.direct//test2?routingkey='test2'"));
+        session.createProducer(queue2);
+        assertTrue("Not all expected commands have been sent on producer2 creation", listener.responsesEmpty());
+
+
+        // expecting exchange declare Ok, Consume Ok
+        listener = new MockReceiveConnectionListener(_connection, 1,
+                new ExchangeDeclareOkBody(), new BasicConsumeOkBody(AMQShortString.valueOf("2")));
+        _connection.setConnectionListener(listener);
+
+        BasicMessageConsumer_0_8 consumer2 = (BasicMessageConsumer_0_8)session.createConsumer(queue2);
+        assertTrue("Not all expected commands have been sent on consumer2 creation", listener.responsesEmpty());
+
+        UnprocessedMessage[] messages = new UnprocessedMessage[4];
+        for (int i =0; i< messages.length;i++ )
+        {
+            int consumerTag = i % 2 == 0 ? consumer1.getConsumerTag() : consumer2.getConsumerTag();
+            int deliveryTag = i + 1;
+            messages[i]= createMockMessage(deliveryTag, consumerTag);
+            session.messageReceived(messages[i]);
+            if (deliveryTag % 2 == 0)
+            {
+                session.addDeliveredMessage(deliveryTag);
+            }
+            else
+            {
+                session.addUnacknowledgedMessage(deliveryTag);
+            }
+        }
+
+        assertEquals("Unexpected highest delivery tag", messages.length, session.getHighestDeliveryTag().get());
+        assertFalse("Unexpected delivered message tags", session.getDeliveredMessageTags().isEmpty());
+        assertFalse("Unexpected unacknowledged message tags", session.getUnacknowledgedMessageTags().isEmpty());
+        assertEquals("Unexpected consumers", new HashSet<>(Arrays.asList(consumer1, consumer2)), new HashSet<>(session.getConsumers()));
+
+        // verify messages were not dispatched
+        for (UnprocessedMessage message: messages )
+        {
+            verify(message, never()).dispatch(session);
+        }
+
+        listener = new MockReceiveConnectionListener(_connection, 1,
+                new ExchangeDeclareOkBody(), // first producer resubscribe
+                new ExchangeDeclareOkBody(), // second producer resubscribe
+                new ExchangeDeclareOkBody(), new BasicConsumeOkBody(AMQShortString.valueOf("1")),  // first consumer resubscribe
+                new ExchangeDeclareOkBody(), new BasicConsumeOkBody(AMQShortString.valueOf("2"))); // second consumer resubscribe
+        _connection.setConnectionListener(listener);
+
+        session.resubscribe();
+
+        assertTrue("Not all expected commands have been sent on session resubscribe", listener.responsesEmpty());
+
+        assertEquals("Unexpected highest delivery tag", -1, session.getHighestDeliveryTag().get());
+        assertTrue("Unexpected unacknowledged message tags", session.getUnacknowledgedMessageTags().isEmpty());
+        assertTrue("Unexpected delivered message tags", session.getDeliveredMessageTags().isEmpty());
+        assertTrue("Unexpected pre-fetched message tags", session.getPrefetchedMessageTags().isEmpty());
+        assertEquals("Unexpected consumers", new HashSet<>(Arrays.asList(consumer1, consumer2)), new HashSet<>(session.getConsumers()));
+
+        // verify dispatcher queue is drained
+        for (UnprocessedMessage message: messages )
+        {
+            verify(message).dispatch(session);
+        }
+    }
+
+    private UnprocessedMessage createMockMessage(long deliveryTag, int consumerTag)
+    {
+        UnprocessedMessage message = mock(UnprocessedMessage.class);
+        when(message.getConsumerTag()).thenReturn(consumerTag);
+        when(message.getDeliveryTag()).thenReturn(deliveryTag);
+        return message;
+    }
+
+    static class MockReceiveConnectionListener extends ConnectionListenerSupport
+    {
+        private final AMQConnection _connection;
+        private final List<AMQBody> _responses;
+        private final int _channelId;
+
+        MockReceiveConnectionListener(AMQConnection connection, int channelId, AMQBody... response)
+        {
+            _connection = connection;
+            _responses = new ArrayList<>(Arrays.asList(response));
+            _channelId = channelId;
+        }
+
+        @Override
+        public void bytesSent(long count)
+        {
+            try
+            {
+                AMQBody response = _responses.remove(0);
+                _connection.getProtocolHandler().methodBodyReceived(_channelId, response);
+            }
+            catch (QpidException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+
+        public boolean responsesEmpty()
+        {
+            return _responses.isEmpty();
+        }
+    }
 }
