diff --git a/client/src/main/java/org/apache/qpid/client/AMQConnection.java b/client/src/main/java/org/apache/qpid/client/AMQConnection.java
index 3b916360f..8ebb0b89e 100644
--- a/client/src/main/java/org/apache/qpid/client/AMQConnection.java
+++ b/client/src/main/java/org/apache/qpid/client/AMQConnection.java
@@ -682,8 +682,8 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
 
     public boolean attemptReconnection()
     {
-        BrokerDetails broker = null;
-        while (_failoverPolicy.failoverAllowed() && (broker = _failoverPolicy.getNextBrokerDetails()) != null)
+        BrokerDetails broker;
+        while (!isClosed() && !isClosing() && _failoverPolicy.failoverAllowed() && (broker = _failoverPolicy.getNextBrokerDetails()) != null)
         {
             if (attemptConnection(broker))
             {
@@ -725,7 +725,6 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
 
     public ProtocolVersion makeBrokerConnection(BrokerDetails brokerDetail) throws IOException, QpidException
     {
-        resetClosedFlag();
         return _delegate.makeBrokerConnection(brokerDetail);
     }
 
@@ -1414,6 +1413,23 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
             _logger.debug("exceptionReceived done by:" + Thread.currentThread().getName(), cause);
         }
 
+        final JMSException je = convertToJMSException(cause);
+
+        try
+        {
+            if (hardError(cause))
+            {
+                closeSessions(cause);
+            }
+        }
+        finally
+        {
+            deliverJMSExceptionToExceptionListenerOrLog(je, cause);
+        }
+    }
+
+    private JMSException convertToJMSException(Throwable cause)
+    {
         final JMSException je;
         if (cause instanceof JMSException)
         {
@@ -1456,52 +1472,23 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
                                                                            + cause), cause);
             }
         }
+        return je;
+    }
 
-        boolean closer = false;
-
-        // in the case of an IOException, MINA has closed the protocol session so we set _closed to true
-        // so that any generic client code that tries to close the connection will not mess up this error
-        // handling sequence
-        if (cause instanceof IOException || cause instanceof AMQDisconnectedException)
-        {
-            // If we have an IOE/AMQDisconnect there is no connection to close on.
-            setClosing(false);
-            closer = !setClosed();
-
-            _protocolHandler.getProtocolSession().notifyError(je);
-        }
+    public void closed(Throwable cause)
+    {
+        _logger.debug("Closing closed connection {} ", this.toString());
 
+        final JMSException je = convertToJMSException(cause);
         try
         {
-            // decide if we are going to close the session
-            if (hardError(cause))
-            {
-                closer = (!setClosed()) || closer;
-                {
-                    _logger.info("Closing AMQConnection due to :" + cause);
-                }
-            }
-            else
-            {
-                _logger.info("Not a hard-error connection not closing: " + cause);
-            }
-
+            _protocolHandler.getProtocolSession().notifyError(je);
+            boolean performClose = !setClosed();
 
             // if we are closing the connection, close sessions first
-            if (closer)
+            if (performClose)
             {
-                // get the failover mutex before trying to close
-                synchronized (getFailoverMutex())
-                {
-                    try
-                    {
-                        closeAllSessions(cause, -1);
-                    }
-                    catch (JMSException e)
-                    {
-                        _logger.error("Error closing all sessions: " + e, e);
-                    }
-                }
+                closeSessions(cause);
             }
         }
         finally
@@ -1510,6 +1497,22 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
         }
     }
 
+    private void closeSessions(Throwable cause)
+    {
+        // get the failover mutex before trying to close
+        synchronized (getFailoverMutex())
+        {
+            try
+            {
+                closeAllSessions(cause, -1);
+            }
+            catch (JMSException e)
+            {
+                _logger.error("Error closing all sessions: " + e, e);
+            }
+        }
+    }
+
     private void deliverJMSExceptionToExceptionListenerOrLog(final JMSException je, final Throwable cause)
     {
         final ExceptionListener exceptionListener = getExceptionListenerNoCheck();
@@ -1810,12 +1813,6 @@ public class AMQConnection extends Closeable implements CommonConnection, Refere
         return _validateQueueOnSend;
     }
 
-    @Override
-    protected boolean setClosed()
-    {
-        return super.setClosed();
-    }
-
     public int getMessageCompressionThresholdSize()
     {
         return _messageCompressionThresholdSize;
diff --git a/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java b/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
index 92f4951bf..f065b9c56 100644
--- a/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
+++ b/client/src/main/java/org/apache/qpid/client/AMQSession_0_10.java
@@ -1075,8 +1075,12 @@ public class AMQSession_0_10 extends AMQSession<BasicMessageConsumer_0_10, Basic
             {
                 _logger.warn("Error closing session", e);
             }
+            getAMQConnection().exceptionReceived(_currentException);
+        }
+        else
+        {
+            getAMQConnection().closed(_currentException);
         }
-        getAMQConnection().exceptionReceived(_currentException);
     }
 
     public AMQMessageDelegateFactory getMessageDelegateFactory()
diff --git a/client/src/main/java/org/apache/qpid/client/BasicMessageConsumer_0_10.java b/client/src/main/java/org/apache/qpid/client/BasicMessageConsumer_0_10.java
index b7103f0af..43bbe66c9 100644
--- a/client/src/main/java/org/apache/qpid/client/BasicMessageConsumer_0_10.java
+++ b/client/src/main/java/org/apache/qpid/client/BasicMessageConsumer_0_10.java
@@ -154,8 +154,8 @@ public class BasicMessageConsumer_0_10 extends BasicMessageConsumer<UnprocessedM
         }
         catch (QpidException e)
         {
-            _logger.error("Receivecd an Exception when receiving message",e);
-            getSession().getAMQConnection().exceptionReceived(e);
+            _logger.error("Received an Exception when receiving message", e);
+            getSession().getAMQConnection().closed(e);
         }
     }
 
diff --git a/client/src/main/java/org/apache/qpid/client/Closeable.java b/client/src/main/java/org/apache/qpid/client/Closeable.java
index 2a3eb40a0..19549ebfa 100644
--- a/client/src/main/java/org/apache/qpid/client/Closeable.java
+++ b/client/src/main/java/org/apache/qpid/client/Closeable.java
@@ -83,11 +83,6 @@ public abstract class Closeable
         return _closing.get();
     }
 
-    public void resetClosedFlag()
-    {
-        _closed.set(false);
-    }
-
     protected boolean setClosed()
     {
         return _closed.getAndSet(true);
diff --git a/client/src/main/java/org/apache/qpid/client/failover/FailoverHandler.java b/client/src/main/java/org/apache/qpid/client/failover/FailoverHandler.java
index c9566db68..7331540c8 100644
--- a/client/src/main/java/org/apache/qpid/client/failover/FailoverHandler.java
+++ b/client/src/main/java/org/apache/qpid/client/failover/FailoverHandler.java
@@ -22,6 +22,7 @@ package org.apache.qpid.client.failover;
 
 import java.util.concurrent.CountDownLatch;
 
+import org.apache.qpid.client.AMQConnection;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -115,10 +116,12 @@ public class FailoverHandler implements Runnable
         // has completed before retrying the operation.
         _amqProtocolHandler.notifyFailoverStarting();
 
+        final AMQConnection connection = _amqProtocolHandler.getConnection();
+
         // Since failover impacts several structures we protect them all with a single mutex. These structures
         // are also in child objects of the connection. This allows us to manipulate them without affecting
         // client code which runs in a separate thread.
-        synchronized (_amqProtocolHandler.getConnection().getFailoverMutex())
+        synchronized (connection.getFailoverMutex())
         {
             //Clear the exception now that we have the failover mutex there can be no one else waiting for a frame so
             // we can clear the exception.
@@ -135,7 +138,7 @@ public class FailoverHandler implements Runnable
             _amqProtocolHandler.setStateManager(new AMQStateManager());
 
 
-            if (!_amqProtocolHandler.getConnection().firePreFailover(_host != null))
+            if (!connection.firePreFailover(_host != null))
             {
                 _logger.info("Failover process veto-ed by client");
 
@@ -144,15 +147,19 @@ public class FailoverHandler implements Runnable
 
                 //todo: ritchiem these exceptions are useless... Would be better to attempt to propogate exception that
                 // prompted the failover event.
+
+                AMQDisconnectedException cause;
                 if (_host != null)
                 {
-                    _amqProtocolHandler.getConnection().exceptionReceived(new AMQDisconnectedException("Redirect was vetoed by client", null));
+                    cause = new AMQDisconnectedException("Redirect was vetoed by client", null);
                 }
                 else
                 {
-                    _amqProtocolHandler.getConnection().exceptionReceived(new AMQDisconnectedException("Failover was vetoed by client", null));
+                    cause = new AMQDisconnectedException("Failover was vetoed by client", null);
                 }
 
+                connection.closed(cause);
+
                 _amqProtocolHandler.getFailoverLatch().countDown();
                 _amqProtocolHandler.setFailoverLatch(null);
 
@@ -168,21 +175,19 @@ public class FailoverHandler implements Runnable
             // if _host has value then we are performing a redirect.
             if (_host != null)
             {
-                failoverSucceeded = _amqProtocolHandler.getConnection().attemptReconnection(_host, _port, true);
+                failoverSucceeded = connection.attemptReconnection(_host, _port, true);
             }
             else
             {
-                failoverSucceeded = _amqProtocolHandler.getConnection().attemptReconnection();
+                failoverSucceeded = connection.attemptReconnection();
             }
 
             if (!failoverSucceeded)
             {
                 //Restore Existing State Manager
                 _amqProtocolHandler.setStateManager(existingStateManager);
-
-                _amqProtocolHandler.getConnection().exceptionReceived(
-                        new AMQDisconnectedException("Server closed connection and no failover " +
-                                "was successful", null));
+                connection.closed(new AMQDisconnectedException("Server closed connection and no failover " +
+                        "was successful", null));
             }
             else
             {
@@ -209,17 +214,17 @@ public class FailoverHandler implements Runnable
                 _amqProtocolHandler.setStateManager(existingStateManager);
                 try
                 {
-                    if (_amqProtocolHandler.getConnection().firePreResubscribe())
+                    if (connection.firePreResubscribe())
                     {
                         _logger.info("Resubscribing on new connection");
-                        _amqProtocolHandler.getConnection().resubscribeSessions();
+                        connection.resubscribeSessions();
                     }
                     else
                     {
                         _logger.info("Client vetoed automatic resubscription");
                     }
 
-                    _amqProtocolHandler.getConnection().fireFailoverComplete();
+                    connection.fireFailoverComplete();
                     _amqProtocolHandler.setFailoverState(FailoverState.NOT_STARTED);
                     _logger.info("Connection failover completed successfully");
                 }
diff --git a/client/src/main/java/org/apache/qpid/client/protocol/AMQProtocolHandler.java b/client/src/main/java/org/apache/qpid/client/protocol/AMQProtocolHandler.java
index ba7158a02..e6f1c6e91 100644
--- a/client/src/main/java/org/apache/qpid/client/protocol/AMQProtocolHandler.java
+++ b/client/src/main/java/org/apache/qpid/client/protocol/AMQProtocolHandler.java
@@ -234,7 +234,7 @@ public class AMQProtocolHandler implements ExceptionHandlingByteBufferReceiver,
 
             if (failoverNotAllowed)
             {
-                _connection.exceptionReceived(new AMQDisconnectedException(
+                _connection.closed(new AMQDisconnectedException(
                         "Server closed connection and reconnection not permitted.", _stateManager.getLastException()));
             }
             else if(failedWithoutConnecting)
@@ -244,7 +244,7 @@ public class AMQProtocolHandler implements ExceptionHandlingByteBufferReceiver,
                     initialConnectionException = _stateManager.getLastException();
                 }
                 String message = initialConnectionException == null ? "" : initialConnectionException.getMessage();
-                _connection.exceptionReceived(new AMQDisconnectedException(
+                _connection.exceptionReceived(new QpidException(
                         "Connection could not be established: " + message, initialConnectionException));
             }
         }
@@ -341,9 +341,9 @@ public class AMQProtocolHandler implements ExceptionHandlingByteBufferReceiver,
 
             // we notify the state manager of the error in case we have any clients waiting on a state
             // change. Those "waiters" will be interrupted and can handle the exception
-            QpidException amqe = new QpidException("Protocol handler error: " + cause, cause);
+            AMQDisconnectedException amqe = new AMQDisconnectedException("Failover could not re-establish connectivity: " + cause, cause);
             propagateExceptionToAllWaiters(amqe);
-            _connection.exceptionReceived(cause);
+            _connection.closed(amqe);
         }
         else
         {
@@ -697,7 +697,7 @@ public class AMQProtocolHandler implements ExceptionHandlingByteBufferReceiver,
      */
     public void closeConnection(long timeout) throws QpidException
     {
-        if (!getStateManager().getCurrentState().equals(AMQState.CONNECTION_CLOSED))
+        if (getStateManager().getCurrentState().equals(AMQState.CONNECTION_OPEN))
         {
             // Connection is already closed then don't do a syncWrite
             try
diff --git a/client/src/test/java/org/apache/qpid/client/AMQConnectionUnitTest.java b/client/src/test/java/org/apache/qpid/client/AMQConnectionUnitTest.java
index d309251b4..04e813ff2 100644
--- a/client/src/test/java/org/apache/qpid/client/AMQConnectionUnitTest.java
+++ b/client/src/test/java/org/apache/qpid/client/AMQConnectionUnitTest.java
@@ -20,14 +20,19 @@
  */
 package org.apache.qpid.client;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
 import java.util.concurrent.atomic.AtomicReference;
 
 import javax.jms.ExceptionListener;
 import javax.jms.JMSException;
 
+import org.apache.qpid.AMQDisconnectedException;
 import org.apache.qpid.AMQInvalidArgumentException;
 import org.apache.qpid.configuration.ClientProperties;
 import org.apache.qpid.jms.ConnectionURL;
+import org.apache.qpid.jms.Session;
 import org.apache.qpid.test.utils.QpidTestCase;
 
 public class AMQConnectionUnitTest extends QpidTestCase
@@ -93,7 +98,7 @@ public class AMQConnectionUnitTest extends QpidTestCase
         assertNotNull("Expected JMSException but got null", exception);
         assertEquals("JMSException error code is incorrect", Integer.toString(expectedException.getErrorCode().getCode()), exception.getErrorCode());
         assertNotNull("Expected not null message for JMSException", exception.getMessage());
-        assertTrue("JMSException error message is incorrect",  exception.getMessage().contains(expectedException.getMessage()));
+        assertTrue("JMSException error message is incorrect", exception.getMessage().contains(expectedException.getMessage()));
         assertEquals("JMSException linked exception is incorrect", expectedException, exception.getLinkedException());
     }
 
@@ -103,7 +108,7 @@ public class AMQConnectionUnitTest extends QpidTestCase
     public void testDefaultStreamMessageEncoding() throws Exception
     {
         MockAMQConnection connection = new MockAMQConnection(_url);
-        assertTrue("Legacy Stream message encoding should be the default",connection.isUseLegacyStreamMessageFormat());
+        assertTrue("Legacy Stream message encoding should be the default", connection.isUseLegacyStreamMessageFormat());
     }
 
     /**
@@ -112,7 +117,33 @@ public class AMQConnectionUnitTest extends QpidTestCase
     public void testStreamMessageEncodingProperty() throws Exception
     {
         MockAMQConnection connection = new MockAMQConnection(_url + "&use_legacy_stream_msg_format='false'");
-        assertFalse("Stream message encoding should be amqp/list",connection.isUseLegacyStreamMessageFormat());
+        assertFalse("Stream message encoding should be amqp/list", connection.isUseLegacyStreamMessageFormat());
     }
 
+    public void testClosed() throws Exception
+    {
+        final AtomicReference<Exception> exceptionCatcher = new AtomicReference<>();
+        MockAMQConnection connection = new MockAMQConnection(_url);
+
+        AMQSession session = mock(AMQSession.class);
+        connection.registerSession(1, session);
+        connection.setExceptionListener(new ExceptionListener()
+        {
+
+            @Override
+            public void onException(JMSException jmsException)
+            {
+                exceptionCatcher.set(jmsException);
+            }
+        });
+
+        AMQDisconnectedException exception = new AMQDisconnectedException("test", new Exception("chained"));
+        connection.closed(exception);
+        assertTrue("Connection shall be marked as closed", connection.isClosed());
+
+        Exception caughtException =  exceptionCatcher.get();
+        assertTrue("Unexpected exception was sent into exception listener", caughtException instanceof JMSException);
+        assertEquals("Unexpected exception cause was set in exception sent to exception listener", exception, caughtException.getCause());
+        verify(session).closed(exception);
+    }
 }
