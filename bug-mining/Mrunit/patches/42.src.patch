diff --git a/src/main/java/org/apache/hadoop/mrunit/TestDriver.java b/src/main/java/org/apache/hadoop/mrunit/TestDriver.java
index 2820940..06e837a 100644
--- a/src/main/java/org/apache/hadoop/mrunit/TestDriver.java
+++ b/src/main/java/org/apache/hadoop/mrunit/TestDriver.java
@@ -22,14 +22,9 @@ import static org.apache.hadoop.mrunit.internal.util.ArgumentChecker.returnNonNu
 import java.io.File;
 import java.io.IOException;
 import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.TreeMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
+import com.google.common.collect.Lists;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configuration;
@@ -74,7 +69,8 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
   private File tmpDistCacheDir;
   protected CounterWrapper counterWrapper;
   protected MockMultipleOutputs mos;
-  protected Map<String, List<Pair<? extends Comparable, ? extends Comparable>>> expectedMultipleOutputs;
+  protected Map<String, List<Pair<?, ?>>> expectedMultipleOutputs;
+  protected Map<String, List<Pair<?, ?>>> expectedPathOutputs;
   private boolean hasRun = false;
 
 
@@ -82,7 +78,8 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
     expectedOutputs = new ArrayList<Pair<K2, V2>>();
     expectedEnumCounters = new ArrayList<Pair<Enum<?>, Long>>();
     expectedStringCounters = new ArrayList<Pair<Pair<String, String>, Long>>();
-    expectedMultipleOutputs = new HashMap<String, List<Pair<? extends Comparable, ? extends Comparable>>>();
+    expectedMultipleOutputs = new HashMap<String, List<Pair<?, ? >>>();
+	expectedPathOutputs = new HashMap<String, List<Pair<?, ?>>>();
   }
 
   /**
@@ -861,78 +858,136 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
   /**
    * Check Multiple Outputs.
    */
+
+  protected void validateOutputList(String name, Errors errors,
+      Map<String, List<Pair<?, ?>>> actuals,
+      Map<String, List<Pair<?, ?>>> expects) {
+
+    List<String> removeList = new ArrayList<String>();
+
+    for (String key : expects.keySet()) {
+      removeList.add(key);
+      List<Pair<?, ?>> expectedValues = expects.get(key);
+      List<Pair<?, ?>> actualValues = actuals.get(key);
+
+      if (actualValues == null) {
+        errors.record("Missing expected outputs for %s '%s'", name, key);
+        actualValues = new ArrayList();
+      }
+
+      int expectedSize = expectedValues.size();
+      int actualSize = actualValues.size();
+      int i = 0;
+
+      while (expectedSize > i || actualSize > i) {
+        if (expectedSize > i && actualSize > i) {
+          Pair<?, ?> expected = expectedValues.get(i);
+          Pair<?, ?> actual = actualValues.get(i);
+
+          if (!expected.equals(actual)) {
+            errors.record(
+                "Expected output %s for %s '%s' at position %d, but found %s",
+                expected.toString(), name, key, i, actual.toString());
+          }
+        } else if (expectedSize > i) {
+          Pair<?, ?> expected = expectedValues.get(i);
+          errors.record(
+              "Missing expected output %s for %s '%s' at position %d.",
+              expected.toString(), name, key, i);
+        } else {
+          Pair<?, ?> actual = actualValues.get(i);
+          errors.record(
+              "Received unexpected output %s for %s '%s' at position %d.",
+              actual.toString(), name, key, i);
+        }
+        i++;
+      }
+    }
+
+    for (String processedOutput : removeList) {
+      actuals.remove(processedOutput);
+    }
+
+    // The rest of values in actuals, if any
+    for (String key : actuals.keySet()) {
+      List<Pair<?, ?>> actualValues = actuals.get(key);
+      for (Pair pair : actualValues) {
+        errors.record("Received unexpected output %s for unexpected %s '%s'",
+            pair.toString(), name, key);
+      }
+    }
+  }
+
   protected void validate(final MockMultipleOutputs mos) {
     final Errors errors = new Errors(LOG);
 
-    if (mos!=null && !mos.isEmpty() && expectedMultipleOutputs.isEmpty()) {
-        errors.record("Expected no multiple outputs; got %d named multipleOutputs.", mos.getMultipleOutputsCount());
+    if (mos != null && !mos.isNamedOutputsEmpty()
+        && expectedMultipleOutputs.isEmpty()) {
+      errors.record(
+          "Expected no multiple outputs; got %d named MultipleOutputs.",
+          mos.getMultipleOutputsCount());
     }
 
-    Map<String, List<Pair<? extends Comparable, ? extends Comparable>>> actuals = buildActualMultipleOutputs(mos);
-    Map<String, List<Pair<? extends Comparable, ? extends Comparable>>> expects = buildExpectedMultipleOutputs();
+    Map<String, List<Pair<?, ?>>> actuals = buildActualMultipleOutputs(mos);
+    Map<String, List<Pair<?, ?>>> expects = buildExpectedMultipleOutputs();
 
+    validateOutputList("namedOutput", errors, actuals, expects);
 
-    for (String namedOutput : expectedMultipleOutputs.keySet()) {
-        List<Pair<? extends Comparable, ? extends Comparable>> expectedValues = expects.remove(namedOutput);
-        List<Pair<? extends Comparable, ? extends Comparable>> actualValues = actuals.remove(namedOutput);
-        if (actualValues == null) {
-            errors.record("Missing expected outputs for namedOutput '%s'", namedOutput);
-            actualValues = new ArrayList();
-        }
+    actuals.clear();
+    expects.clear();
 
-        int expectedSize = expectedValues.size();
-        int actualSize = actualValues.size();
-        int i = 0;
+    if (mos != null && !mos.isPathOutputsEmpty()
+        && expectedPathOutputs.isEmpty()) {
+      errors.record("Expected no pathOutputs; got %d pathOutputs.",
+          mos.getPathOutputsCount());
+    }
 
-        while (expectedSize > i || actualSize > i) {
-            if (expectedSize > i && actualSize > i) {
-                Pair<? extends Comparable, ? extends Comparable> expected = expectedValues.get(i);
-                Pair<? extends Comparable, ? extends Comparable> actual = actualValues.get(i);
+    actuals = buildActualPathOutputs(mos);
+    expects = buildExpectedPathOutputs();
 
-                if (!expected.equals(actual)) {
-                    errors.record("Expected output %s for namedOutput '%s' at position %d, but found $s",
-                            expected.toString(), namedOutput, i, actual.toString());
-                }
-            } else if (expectedSize >i) {
-                Pair<? extends Comparable, ? extends Comparable> expected = expectedValues.get(i);
-                errors.record("Missing expected output %s for namedOutput '%s' at position %d.",
-                        expected.toString(), namedOutput, i);
-            } else {
-                Pair<? extends Comparable, ? extends Comparable> actual = actualValues.get(i);
-                errors.record("Received unexpected output %s for namedOutput '%s' at position %d.",
-                        actual.toString(), namedOutput, i);
-            }
-            i++;
-        }
+    validateOutputList("PathOutput", errors, actuals, expects);
+
+    errors.assertNone();
+  }
+
+  private Map<String, List<Pair<?, ?>>> buildActualMultipleOutputs(
+      MockMultipleOutputs mos) {
+    HashMap<String, List<Pair<?, ?>>> actuals = new HashMap<String, List<Pair<?, ?>>>();
+    if (mos != null) {
+      List<String> multipleOutputsNames = mos.getMultipleOutputsNames();
+      for (String name : multipleOutputsNames) {
+        actuals.put(name, mos.getMultipleOutputs(name));
+      }
     }
+    return actuals;
+  }
 
-    //The rest of values in mos, if any
-    for (String namedOutput : actuals.keySet()) {
-        List<Pair<? extends Comparable, ? extends Comparable>> actualValues = actuals.remove(namedOutput);
-        for (Pair pair : actualValues) {
-            errors.record("Received unexpected output %s for unexpected namedOutput '%s'", pair.toString(), namedOutput);
-        }
+  private Map<String, List<Pair<?, ?>>> buildExpectedMultipleOutputs() {
+    HashMap<String, List<Pair<?, ?>>> result = new HashMap<String, List<Pair<?, ?>>>();
+    for (String name : expectedMultipleOutputs.keySet()) {
+      result.put(name, expectedMultipleOutputs.get(name));
     }
-    errors.assertNone();
+    return result;
   }
 
-  private Map<String, List<Pair<? extends Comparable, ? extends Comparable>>> buildActualMultipleOutputs(MockMultipleOutputs mos) {
-      HashMap<String, List<Pair<? extends Comparable, ? extends Comparable>>> actuals = new HashMap<String, List<Pair<? extends Comparable, ? extends Comparable>>>();
-      if (mos != null) {
-        List<String> multipleOutputsNames = mos.getMultipleOutputsNames();
-        for (String name : multipleOutputsNames) {
-          actuals.put(name, mos.getMultipleOutputs(name));
-        }
+  private Map<String, List<Pair<?, ?>>> buildActualPathOutputs(
+      MockMultipleOutputs mos) {
+    HashMap<String, List<Pair<?, ?>>> actuals = new HashMap<String, List<Pair<?, ?>>>();
+    if (mos != null) {
+      List<String> outputPaths = mos.getOutputPaths();
+      for (String path : outputPaths) {
+        actuals.put(path, mos.getPathOutputs(path));
       }
-      return actuals;
+    }
+    return actuals;
   }
 
-  private Map<String, List<Pair<? extends Comparable, ? extends Comparable>>> buildExpectedMultipleOutputs() {
-      HashMap<String, List<Pair<? extends Comparable, ? extends Comparable>>> result = new HashMap<String, List<Pair<? extends Comparable, ? extends Comparable>>>();
-        for (String name : expectedMultipleOutputs.keySet()) {
-          result.put(name, expectedMultipleOutputs.get(name));
-        }
-      return result;
+  private Map<String, List<Pair<?, ?>>> buildExpectedPathOutputs() {
+    HashMap<String, List<Pair<?, ?>>> result = new HashMap<String, List<Pair<?, ?>>>();
+    for (String name : expectedPathOutputs.keySet()) {
+      result.put(name, expectedPathOutputs.get(name));
+    }
+    return result;
   }
 
   /**
@@ -1032,7 +1087,7 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
    * @param namedOutput
    * @param outputRecord
    */
-  public <K extends Comparable, V extends Comparable> void addMultiOutput(String namedOutput, final Pair<K, V> outputRecord) {
+  public <K, V> void addMultiOutput(String namedOutput, final Pair<K, V> outputRecord) {
     addMultiOutput(namedOutput, outputRecord.getFirst(), outputRecord.getSecond());
   }
 
@@ -1043,10 +1098,10 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
    * @param key
    * @param val
    */
-  public <K extends Comparable, V extends Comparable> void addMultiOutput(final String namedOutput, final K key, final V val) {
-    List<Pair<? extends Comparable, ? extends Comparable>> outputs = expectedMultipleOutputs.get(namedOutput);
+  public <K, V> void addMultiOutput(final String namedOutput, final K key, final V val) {
+    List<Pair<?, ?>> outputs = expectedMultipleOutputs.get(namedOutput);
     if (outputs == null) {
-      outputs = new ArrayList<Pair<? extends Comparable, ? extends Comparable>>();
+      outputs = new ArrayList<Pair<?, ?>>();
       expectedMultipleOutputs.put(namedOutput, outputs);
     }
     outputs.add(new Pair<K, V>(key, val));
@@ -1072,8 +1127,23 @@ public abstract class TestDriver<K1, V1, K2, V2, T extends TestDriver<K1, V1, K2
    * @param outputRecord
    * @return
    */
-  public <K extends Comparable, V extends Comparable> T withMultiOutput(String namedOutput, final Pair<K, V> outputRecord) {
+  public <K, V> T withMultiOutput(String namedOutput,
+      final Pair<K, V> outputRecord) {
     addMultiOutput(namedOutput, outputRecord);
     return thisAsTestDriver();
   }
+
+  public <K, V> T withPathOutput(final K key, final V value, final String path) {
+    return withPathOutput(new Pair<K, V>(key, value), path);
+  }
+
+  public <K, V> T withPathOutput(final Pair<K, V> outputRecord, String path) {
+    List<Pair<?, ?>> list = expectedPathOutputs.get(path);
+    if (list == null) {
+      list = new ArrayList<Pair<?, ?>>();
+      expectedPathOutputs.put(path, list);
+    }
+    list.add(outputRecord);
+    return thisAsTestDriver();
+  }
 }
diff --git a/src/main/java/org/apache/hadoop/mrunit/internal/output/MockMultipleOutputs.java b/src/main/java/org/apache/hadoop/mrunit/internal/output/MockMultipleOutputs.java
index 4960051..e683d03 100644
--- a/src/main/java/org/apache/hadoop/mrunit/internal/output/MockMultipleOutputs.java
+++ b/src/main/java/org/apache/hadoop/mrunit/internal/output/MockMultipleOutputs.java
@@ -23,81 +23,91 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.apache.hadoop.mapreduce.RecordWriter;
-import org.apache.hadoop.mapreduce.TaskAttemptContext;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.mapreduce.TaskInputOutputContext;
 import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;
 import org.apache.hadoop.mrunit.types.Pair;
 
 /**
  * MockMultipleOutput will mock the MultipleOutput.class.
- *
- * @param <KEYOUT>
- * @param <VALUEOUT>
+ * 
+ * @param <K>
+ * @param <V>
  */
 public class MockMultipleOutputs<K, V> extends MultipleOutputs<K, V> {
-
-  private Map<String, MockRecordWriter> recordWriterMap = new HashMap<String, MockRecordWriter>();
+  private Configuration configuration;
+  private Map<String, MockOutputCollector> namedOutputCollectorMap;
+  private Map<String, MockOutputCollector> pathCollectorMap;
 
   public MockMultipleOutputs(TaskInputOutputContext context) {
     super(context);
+    configuration = new Configuration(context.getConfiguration());
+    namedOutputCollectorMap = new HashMap<String, MockOutputCollector>();
+    pathCollectorMap = new HashMap<String, MockOutputCollector>();
   }
 
-  public boolean isEmpty() {
-    return recordWriterMap.isEmpty();
+  public boolean isNamedOutputsEmpty() {
+    return namedOutputCollectorMap.isEmpty();
   }
 
   public int getMultipleOutputsCount() {
-    return recordWriterMap.size();
+    return namedOutputCollectorMap.size();
+  }
+
+  public boolean isPathOutputsEmpty() {
+    return pathCollectorMap.isEmpty();
+  }
+
+  public int getPathOutputsCount() {
+    return pathCollectorMap.size();
   }
 
   @Override
-  public <K, V> void write(String namedOutput, K key, V value) throws IOException, InterruptedException {
+  public <K, V> void write(String namedOutput, K key, V value)
+      throws IOException, InterruptedException {
     this.write(namedOutput, key, value, namedOutput);
   }
 
   @Override
-  public <K, V> void write(String namedOutput, K key, V value, String baseOutputPath) throws IOException, InterruptedException {
-    MockRecordWriter writer = recordWriterMap.get(namedOutput);
-    if (writer == null) {
-      writer = new MockRecordWriter<K, V>();
-      recordWriterMap.put(namedOutput, writer);
+  public <K, V> void write(String namedOutput, K key, V value,
+      String baseOutputPath) throws IOException, InterruptedException {
+    MockOutputCollector collector = namedOutputCollectorMap.get(namedOutput);
+    if (collector == null) {
+      collector = new MockOutputCollector<K, V>(configuration);
+      namedOutputCollectorMap.put(namedOutput, collector);
     }
-    writer.write(key, value);
+    collector.collect(key, value);
   }
 
   @Override
-  public void write(K key, V value, String baseOutputPath) throws IOException, InterruptedException {
-    //TODO: Understand basedOutputPath
-    throw new UnsupportedOperationException("Not supported yet.");
+  public void write(K key, V value, String baseOutputPath) throws IOException,
+      InterruptedException {
+    MockOutputCollector collector = pathCollectorMap.get(baseOutputPath);
+    if (collector == null) {
+      collector = new MockOutputCollector(configuration);
+      pathCollectorMap.put(baseOutputPath, collector);
+    }
+    collector.collect(key, value);
   }
 
   public <K, V> List<Pair<K, V>> getMultipleOutputs(String outputName) {
-    return recordWriterMap.get(outputName).getOutputs();
+    return namedOutputCollectorMap.get(outputName).getOutputs();
   }
 
   public List<String> getMultipleOutputsNames() {
     final List<String> names = new ArrayList<String>();
-    names.addAll(recordWriterMap.keySet());
+    names.addAll(namedOutputCollectorMap.keySet());
     return names;
   }
 
-  class MockRecordWriter<K, V> extends RecordWriter<K, V> {
-
-    private List<Pair<K, V>> record = new ArrayList<Pair<K, V>>();
-
-    @Override
-    public void write(K key, V value) throws IOException, InterruptedException {
-      record.add(new Pair(key, value));
-    }
-
-    @Override
-    public void close(TaskAttemptContext context) throws IOException, InterruptedException {
-    }
+  public <K, V> List<Pair<K, V>> getPathOutputs(String outputName) {
+    return pathCollectorMap.get(outputName).getOutputs();
+  }
 
-    public List<Pair<K, V>> getOutputs() {
-      return record;
-    }
+  public List<String> getOutputPaths() {
+    final List<String> names = new ArrayList<String>();
+    names.addAll(pathCollectorMap.keySet());
+    return names;
   }
 
 }
diff --git a/src/test/java/org/apache/hadoop/mrunit/mapreduce/TestMultipleOutput.java b/src/test/java/org/apache/hadoop/mrunit/mapreduce/TestMultipleOutput.java
index b90239d..8abb73e 100644
--- a/src/test/java/org/apache/hadoop/mrunit/mapreduce/TestMultipleOutput.java
+++ b/src/test/java/org/apache/hadoop/mrunit/mapreduce/TestMultipleOutput.java
@@ -71,6 +71,24 @@ public class TestMultipleOutput {
             .runTest();
   }
 
+  @Test
+  public void TestMapDriverWithPathOutput() throws IOException {
+    mapDriver = MapDriver.newMapDriver(new PathOutputMapper("path1", "path2"));
+    mapDriver.withInput(new LongWritable(0), new Text("first"))
+        .withInput(new LongWritable(0), new Text("second"))
+        .withInput(new LongWritable(0), new Text("third"))
+        .withOutput(new Text("first"), new IntWritable(1))
+        .withOutput(new Text("second"), new IntWritable(1))
+        .withOutput(new Text("third"), new IntWritable(1))
+        .withPathOutput(new Text("first"), new IntWritable(1), "path1")
+        .withPathOutput(new Text("second"), new IntWritable(1), "path1")
+        .withPathOutput(new Text("third"), new IntWritable(1), "path1")
+        .withPathOutput(new Text("first"), new IntWritable(1), "path2")
+        .withPathOutput(new Text("second"), new IntWritable(1), "path2")
+        .withPathOutput(new Text("third"), new IntWritable(1), "path2")
+        .runTest();
+  }
+
   @Test
   public void TestMapDriverNullKey() throws IOException {
     mapDriver = MapDriver.newMapDriver(new NullKeyMap());
@@ -130,11 +148,62 @@ public class TestMultipleOutput {
             .runTest();
   }
 
+  @Test
+  public void TestReduceDriverWithPathOutput() throws IOException {
+    reduceDriver = ReduceDriver.newReduceDriver(new PathOutputReducer("path"));
+    List<IntWritable> inputs = new ArrayList<IntWritable>();
+    inputs.add(new IntWritable(1));
+    inputs.add(new IntWritable(2));
+    reduceDriver.withInput(new Text("abc"), inputs)
+        .withOutput(new Text("hello"), new IntWritable(1))
+        .withPathOutput(new Text("key"), new IntWritable(2), "path").runTest();
+  }
+
+  @Test
+  public void TestObjectReuese() throws IOException {
+    mapDriver = MapDriver.newMapDriver(new ValueReuseMapper());
+    mapDriver.withInput(new LongWritable(0), new Text("first"))
+        .withInput(new LongWritable(1), new Text("second"))
+        .withInput(new LongWritable(2), new Text("third"))
+        .withMultiOutput("test", new Text("first"), new IntWritable(2))
+        .withMultiOutput("test", new Text("second"), new IntWritable(3))
+        .withMultiOutput("test", new Text("third"), new IntWritable(4))
+        .runTest();
+  }
+
+  public class ValueReuseMapper extends MyMap {
+    @Override
+    public void map(LongWritable key, Text value, Context context)
+        throws IOException, InterruptedException {
+      word.set(value);
+      number.set(number.get() + 1);
+      mos.write("test", word, number);
+    }
+  }
+
+  public class PathOutputMapper extends MyMap {
+    private List<String> paths = new ArrayList<String>();
+
+    public PathOutputMapper(String... paths) {
+      for (String path : paths) {
+        this.paths.add(path);
+      }
+    }
+
+    @Override
+    public void map(LongWritable key, Text value, Context context)
+        throws IOException, InterruptedException {
+      for (String path : paths) {
+        mos.write(value, number, path);
+      }
+      context.write(value, number);
+    }
+  }
   public class MyMap extends Mapper<LongWritable, Text, Text, IntWritable> {
 
-    private final IntWritable one = new IntWritable(1);
-    private Text word = new Text();
-    private MultipleOutputs<Text, IntWritable> mos = null;
+    protected final IntWritable number = new IntWritable(1);
+    protected Text word = new Text();
+    protected MultipleOutputs<Text, IntWritable> mos = null;
 
     @Override
     public void setup(Context context) throws IOException, InterruptedException {
@@ -150,6 +219,7 @@ public class TestMultipleOutput {
       super.cleanup(context);
     }
 
+	@Override
     public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
       String line = value.toString();
       //The first word before a "dash" used to create a named output
@@ -166,7 +236,7 @@ public class TestMultipleOutput {
       } else {
         while (tokenizer.hasMoreTokens()) {
           word.set(tokenizer.nextToken());
-          context.write(word, one);
+          context.write(word, number);
         }
       }
     }
@@ -194,7 +264,7 @@ public class TestMultipleOutput {
 
   public class MyReduce extends Reducer<Text, IntWritable, Text, IntWritable> {
 
-    private MultipleOutputs<Text, IntWritable> mos = null;
+    protected MultipleOutputs<Text, IntWritable> mos = null;
 
     @Override
     public void setup(Context context) throws IOException, InterruptedException {
@@ -217,4 +287,22 @@ public class TestMultipleOutput {
     }
   }
 
+  public class PathOutputReducer extends MyReduce {
+    private List<String> paths = new ArrayList<String>();
+
+    public PathOutputReducer(String... paths) {
+      for (String path : paths) {
+        this.paths.add(path);
+      }
+    }
+
+    @Override
+    protected void reduce(Text key, Iterable<IntWritable> values,
+        Context context) throws IOException, InterruptedException {
+      for (String path : paths) {
+        mos.write(new Text("key"), new IntWritable(2), path);
+      }
+      context.write(new Text("hello"), new IntWritable(1));
+    }
+  }
 }
