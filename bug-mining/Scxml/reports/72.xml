<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 21:31:53 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SCXML-112] Wrong behavior if event is triggered from EventDispatcher</title>
                <link>https://issues.apache.org/jira/browse/SCXML-112</link>
                <project id="12310492" key="SCXML">Commons SCXML</project>
                    <description>&lt;p&gt;Method SCMLExecutor#triggerEvents is synchronized which is too naive way to ensure that events are processed in order they arrive.&lt;/p&gt;

&lt;p&gt;Since the callback to EventDispatcher is made by thread that holds lock on SCMLExecutor triggering event from the dispatcher allows this thread to re-enter the event handling.&lt;/p&gt;

&lt;p&gt;Note: This has nothing to do with multi-threading since there is only one thread.&lt;/p&gt;

&lt;p&gt;Simple queue might e sufficient but in multi-threaded application would make the first thread to enter #triggerEvents process events from other threads queued while the method is running.&lt;/p&gt;

&lt;p&gt;Another approach might be to call EventDispatcher in separate thread,but it has it&apos;s drawbacks too:&lt;br/&gt;
a) changes single-threaded application into-multithreaded which might break assumtions made by unaware user&lt;br/&gt;
b) might start too many threads&lt;br/&gt;
c) Java does not guarantee that threads waiting for lock will get it in same order as they arrive =&amp;gt; might result in non-deterministic behavior of SCXML interpretation&lt;/p&gt;

&lt;p&gt;Possible solutions would be:&lt;/p&gt;

&lt;p&gt;1) add queue and allow the &quot;first&quot; thread server all events - might be just fine since multi-threaded applications might create dedicate thread just for SCXML imterpretation&lt;br/&gt;
2) add queue and block threads after they queue event - so they &quot;wait&quot; until execute their event become first in queue&lt;br/&gt;
3) factor out the queue event queue management and allow for &quot;pluggable&quot; strategy&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12430665">SCXML-112</key>
            <summary>Wrong behavior if event is triggered from EventDispatcher</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ate">Ate Douma</assignee>
                                    <reporter username="alesd">Ales Dolecek</reporter>
                        <labels>
                    </labels>
                <created>Thu, 16 Jul 2009 13:12:25 +0000</created>
                <updated>Thu, 3 Apr 2014 09:17:43 +0000</updated>
                            <resolved>Thu, 3 Apr 2014 09:17:43 +0000</resolved>
                                                    <fixVersion>2.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="12731933" author="alesd" created="Thu, 16 Jul 2009 13:25:37 +0000"  >&lt;p&gt;Interpreting test1.xml with JEXL will end &quot;in good-end&quot;. Interpreting test2.xml will end in &quot;disconnected&quot; while &quot;visiting&quot; the &quot;wrong-end&quot; state. In both cases the SCXMLexecutor should use attached Dispatcher which simply triggers any event back to executor.&lt;/p&gt;

&lt;p&gt;INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /initial&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /initial&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; transition (event = start, cond = null, from = /initial, to = /disconnected)&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /disconnected&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /disconnected&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; transition (event = event, cond = null, from = /disconnected, to = /good-end)&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /good-end&lt;/p&gt;

&lt;p&gt;INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /initial&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /initial&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; transition (event = start, cond = null, from = /initial, to = /disconnected)&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /initial&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; transition (event = event, cond = null, from = /initial, to = /wrong-end)&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /wrong-end&lt;br/&gt;
INFO  &lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleSCXMLListener&amp;#93;&lt;/span&gt; /disconnected&lt;/p&gt;</comment>
                            <comment id="12731934" author="alesd" created="Thu, 16 Jul 2009 13:27:47 +0000"  >&lt;p&gt;Oh and probably the easiest solution:&lt;/p&gt;

&lt;p&gt;4) throw IllegalStateException if the EventDispatcher tries to re-enter the loop (although it will not help with the non-deterministic behavior)&lt;/p&gt;

&lt;p&gt;BTW: Same probably holds for triggering events from &amp;lt;invoke&amp;gt; or listeners&lt;/p&gt;</comment>
                            <comment id="12732372" author="rahul@apache.org" created="Fri, 17 Jul 2009 06:42:44 +0000"  >&lt;p&gt;The current behavior is very much so by design. As you&apos;ve well articulated in your comments, there are trade-offs and in the end the drawbacks of always spawning a thread for the EventDispatcher / Invoker / SCXMLListener outweigh any benefits (especially when users can still choose to do some processing asynchronously per application needs). In many container environments, a very large number of SCXML instances are live in the same JVM (furthermore, any &amp;lt;onentry&amp;gt;, &amp;lt;onexit&amp;gt; or &amp;lt;transition&amp;gt; may have multiple &amp;lt;send&amp;gt;s for example) so we have to take a resource-conservative approach.&lt;/p&gt;

&lt;p&gt;In fact, executable content (which includes &amp;lt;send&amp;gt;) is supposed to take negligible amount of time (tending to zero) in state chart theory. So, in general, the EventDispatcher shouldn&apos;t do anything that takes noticeable amount of time. However, a pragmatic view suggests that sometimes a bit of processing is helpful in executable content, and when that happens doing it asynchronously is always possible as application choice.&lt;/p&gt;

&lt;p&gt;Furthermore, using the EventDispatcher, Invokers or SCXMLListeners to immediately trigger events to the originating/host state machine is generally an anti-pattern (they may ofcourse do so to report the result of some processing). The recommended way for adding immediate events to the queue is through use of &amp;lt;send&amp;gt; with no target and type &quot;SCXML&quot;. These entities should also use something like the AsyncTrigger when needed (though now that I&apos;m pointing to it, I can spot a couple of improvements):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/commons/proper/scxml/trunk/src/main/java/org/apache/commons/scxml/invoke/AsyncTrigger.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/repos/asf/commons/proper/scxml/trunk/src/main/java/org/apache/commons/scxml/invoke/AsyncTrigger.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So your attached Dispatcher would do something similar. I did try to understand the rest of your test cases (but test1.xml and test2.xml seem very similar &amp;#8211; except one has &amp;lt;send&amp;gt; attribute &quot;targettype&quot; and the other just has &quot;type&quot;). It&apos;d be great if you could please attach complete JUnit tests so its easy to run these without guesswork. There are many helper methods in SCXMLTestHelper class which make the JUnit tests quite brief (and therefore, hopefully quick to author).&lt;/p&gt;

&lt;p&gt;In terms of action items, perhaps it may make sense to add something like the AsyncTrigger as a public class in the v1.0 timeframe. It may also make sense to improve the documentation by adding, say a section to the user guide on the website about triggering events back on the originating executor.&lt;/p&gt;</comment>
                            <comment id="12732403" author="alesd" created="Fri, 17 Jul 2009 07:54:28 +0000"  >&lt;p&gt;Sorry - the difference between the files SHOULD be the type - not name of the attribute - but it&apos;s name but it&apos;s value. (I have edited the file in-place and made 2 versions just for the report - apparently wrong). When &quot;scxml&quot; is used the SCXMLExecutor handles the event by itself and everything works fine. When &quot;non-scxml&quot; is used the SCXMLExecutor calls EventDispatcher which calls back #triggerEvent. It is single thread and the call takes &quot;neglible amount of time&quot;.&lt;/p&gt;

&lt;p&gt;The point was to show that executor itself does not use #triggerEvents internally.&lt;/p&gt;

&lt;p&gt;I have no problem with the issue as I&apos;m using ScheduledThreadPoolExecutor (introduced in J5) which converts #send invocations into asyncronous calls and also provides queue.&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;I&apos;m in telephony world, which is fast, async and event based by it&apos;s nature and is also &quot;behind&quot; SCXML. The dispatcher calls CTI and the results come back asynchronously and very fast. I came acros the issue in test unit which fake the CTI loop and fire expected events directly from dispatcher.&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;Maybe the triggering of events should be separated from it&apos;s execution. The SCXMLExecutor might expose methods to check if there are external events in queue and that make single macro-step. User would then call triggerEvent(...) and &quot;while (pendingEvents()) &lt;/p&gt;
{ step(); }
&lt;p&gt;&quot;. The step might have variants that would block waiting for events (possibly with timeout).&lt;/p&gt;

&lt;p&gt;AsyncTrigger does not solve the problem of non-derministic behavior. If you trigger multiple AsyncTriggers you have no guarantee that they will be processed in the order you fired them - which might be problem and violate SCXML specification. External queue won&apos;t help since events of type &quot;scxml&quot; would not use it and would skip events in the queue.&lt;/p&gt;

&lt;p&gt;As result there is currently no way how to achive the deterministic behavior of SCXML in multithreaded environment. And no way to correctly trigger events from &amp;lt;send&amp;gt; or &amp;lt;invoke&amp;gt; in single-threaded environment. Both of these are however needed to conform to SCXML as using send/invoke with wrong type MUST result in firing error event.&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;The idea I&apos;m trying to express, rather clumsily, is that the the SCXMLExecutor should be designed as thread safe, or at least with thread safety &quot;in-mind&quot;, since the events MAY come from different &quot;sources&quot; and MAY do so while the state machine is in transition.&lt;/p&gt;

&lt;p&gt;The SCXML is multi-threaded and async by nature/design and at least SCXMLExecutor should be as well.&lt;/p&gt;</comment>
                            <comment id="12732628" author="rahul@apache.org" created="Fri, 17 Jul 2009 17:49:44 +0000"  >&lt;p&gt;OK, great, with that clarification for the test SCXML documents, the tests and comments make sense. What I didn&apos;t get around to mentioning in my last comment was that we&apos;ve always said that users should set up an external event queue as a feeder to the SCXMLExecutor instances (using an appropriate implementation that makes sense for their application domain).&lt;/p&gt;

&lt;p&gt;Towards that end, I agree that having something along the lines of option (3) mentioned in your initial post to this issue i.e. factor out the queue event queue management and allow for &quot;pluggable&quot; strategy, seems like a reasonable addition at this time. We would want to be able to allow for any number of queueing solutions/implementations. For example, using ScheduledThreadPoolExecutor as you mention may be one basis. Note that SCXML trunk is JDK 1.4 based, though we can definitely add such a solution in the J6 branch. So I think this is open to code proposals, any proposal via patch(es) welcome.&lt;/p&gt;</comment>
                            <comment id="12732874" author="alesd" created="Sat, 18 Jul 2009 10:14:12 +0000"  >&lt;p&gt;I&apos;m afraid that I can&apos;t externalize the queue.&lt;/p&gt;

&lt;p&gt;I&apos;m sorry to say that, but the code seems &quot;scattered&quot;. There are many interlinked classes/interfaces which overlap eg.&lt;/p&gt;

&lt;p&gt;Status and SCInstance&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;both hold state information&lt;br/&gt;
SCXMLExecutor and SCInstance reference each other in 1:1 relation&lt;/li&gt;
	&lt;li&gt;seems useless to have them separated&lt;/li&gt;
	&lt;li&gt;might give sense if executor was intended as &quot;driver&quot;, but then this is purpose of the SCXMLSemantics&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Also came across other issues while digging into the code:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the events are not processed one at time but in chunks - submitting multiple events via #triggerEvents behave differently than repeated invocation of #triggerEvent&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Factoring out the queue would mean radical changes in code and, what is worse, also to contracts of the public APIs.&lt;/p&gt;

&lt;p&gt;It might be possible to keep contract of SCXMLExecutor eg. by adding:&lt;/p&gt;

&lt;p&gt;#microStep() and #macroStep() methods and let&lt;/p&gt;

&lt;p&gt;a) triggerEvents&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;lock external queue, enqueue all queued events and then call, get it&apos;s size, unlock it and call #macroStep &quot;size&quot; times so that it process all currently queued external events plus the ones added by the invocation&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;b) all methods invoked by SCXMLExecutor that might generate internal events must have access to the internalQueue =&amp;gt;&#160;pass along SCInstance (if the queue would be there)&lt;/p&gt;

&lt;p&gt;c) all methods that take TriggerEvent[] should be rewriten so theat they take just TriggerEvent&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;or ensure that they are invoked with array of lenght == 1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;The API deserve major revision/rethink&lt;/p&gt;</comment>
                            <comment id="12732923" author="rahul@apache.org" created="Sat, 18 Jul 2009 19:02:11 +0000"  >&lt;p&gt;I&apos;m afraid externalizing the queue is best for the 0.x line.&lt;/p&gt;

&lt;p&gt;Your feedback is appreciated. Some comments:&lt;/p&gt;

&lt;p&gt;This involves years of code evolution, but to summarize quickly (not in any order):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;SCXMLExecutor is the primary API for clients&lt;/li&gt;
	&lt;li&gt;SCInstance is the backing store for internal state&lt;/li&gt;
	&lt;li&gt;Status exposes the state clients most want to know about&lt;/li&gt;
	&lt;li&gt;SCXMLSemantics is the crux of the SCXML algorithm (extension point for users to have different algorithm if and when it makes sense)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Much of that separation is useful IMO.&lt;/p&gt;

&lt;p&gt;The #triggerEvents() behavior is different from a series of triggerEvent() calls, but that was intentional when it was done (multiple active regions).&lt;/p&gt;

&lt;p&gt;With many of the changes in the spec, its certainly on the cards to create a version of the SCXMLExecutor for the next major line of development that internalizes the external events queue that feeds the main loop for processing events (there&apos;d be a inner loop for internal events) and makes other tweaks to the algorithm as needed. But the idea won&apos;t be to drastically change any API / contracts.&lt;/p&gt;</comment>
                            <comment id="12732940" author="alesd" created="Sat, 18 Jul 2009 22:44:28 +0000"  >&lt;p&gt;No, no - that is fine. I understand that the project has it&apos;s history and that it is hard to keep up with changing &quot;standard&quot;. I&apos;m just not up to made the changes and actually externalize the queue since I&apos;m just starting to dig into commons-scxml internals and my attempt to &quot;fix&quot; this issue grew fast out of my time and skills. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12732948" author="rahul@apache.org" created="Sun, 19 Jul 2009 00:08:32 +0000"  >&lt;p&gt;Got it. In any case, getting the external queue set up as part of the executor has been on my todo list &amp;#8211; it will be added to the J6 branch in SVN at some point. I just don&apos;t have an ETA for it (likely its going to be a few weeks, not days). Ofcourse, if someone proposes a patch to this issue, it could be faster.&lt;/p&gt;</comment>
                            <comment id="13824198" author="woon_san" created="Fri, 15 Nov 2013 22:44:25 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I&apos;ve just met this issue while looking into the internal Send action behavior.&lt;br/&gt;
IIUC, then I think there are two improvement ideas here:&lt;br/&gt;
1 - to queue the events and execute event in order&lt;br/&gt;
2 - hopefully to have a new EventDispatcher implementation (maybe using ScheduledThreadPoolExecutor for instance)&lt;/p&gt;

&lt;p&gt;IMO, the first one is more important because it guarantees the execution order. The second one is still possible if a custom one is provided for their domain.&lt;br/&gt;
To simply fix the first one, I think we can improve SimpleDispatcher to inject an event queue instance (e.g, EventQueue interface) or create a default implementation (e.g, SimpleEventQueue) and SimpleDispatcher#send() can simply push the event into the event queue instance first and try to poll/execute all the remaining events afterward.&lt;br/&gt;
Then I think the SimpleDispatcher will perform more correctly even though it is still a trivial and simple implementation (as intended).&lt;/p&gt;

&lt;p&gt;The second improvement idea (another EventDispatcher implementation) can be another JIRA issue.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;Regards,&lt;/p&gt;

&lt;p&gt;Woonsan&lt;/p&gt;</comment>
                            <comment id="13958656" author="adouma" created="Thu, 3 Apr 2014 09:17:43 +0000"  >&lt;p&gt;With &lt;a href=&quot;https://issues.apache.org/jira/browse/SCXML-196&quot; title=&quot;Redefine SCXMLSemantics to align with the Algorithm for SCXML Interpretation as described in the SCXML specification&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SCXML-196&quot;&gt;&lt;del&gt;SCXML-196&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/SCXML-197&quot; title=&quot;Better separation of concern between SCXMLExecutor and SCInstance and introducing a new SCXMLExecutionContext&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SCXML-197&quot;&gt;&lt;del&gt;SCXML-197&lt;/del&gt;&lt;/a&gt; the event handling has been completely refactored and for the larger part all the above issues have either be resolved or handled differently.&lt;br/&gt;
I&apos;m closing this now as it probably is better to review the new implementation first and start from there if other/extra functionality is needed.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12413684" name="Dispatcher.java" size="806" author="alesd" created="Thu, 16 Jul 2009 13:25:37 +0000"/>
                            <attachment id="12413682" name="test1.xml" size="578" author="alesd" created="Thu, 16 Jul 2009 13:25:37 +0000"/>
                            <attachment id="12413683" name="test2.xml" size="572" author="alesd" created="Thu, 16 Jul 2009 13:25:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>172768</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 33 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1a54v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>267298</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>