diff --git a/code/AssetLib/Obj/ObjFileData.h b/code/AssetLib/Obj/ObjFileData.h
index 0d4367835..02cec4dba 100644
--- a/code/AssetLib/Obj/ObjFileData.h
+++ b/code/AssetLib/Obj/ObjFileData.h
@@ -165,21 +165,23 @@ struct Material {
     //! Ambient color
     aiColor3D ambient;
     //! Diffuse color
-    aiColor3D diffuse;
+    aiColor3D diffuse = aiColor3D(0.6f, 0.6f, 0.6f);
     //! Specular color
     aiColor3D specular;
     //! Emissive color
     aiColor3D emissive;
     //! Alpha value
-    ai_real alpha;
+    ai_real alpha = ai_real(1.0);
     //! Shineness factor
-    ai_real shineness;
+    ai_real shineness = ai_real(0.0);
     //! Illumination model
-    int illumination_model;
+    int illumination_model = 1;
     //! Index of refraction
-    ai_real ior;
+    ai_real ior = ai_real(1.0);
     //! Transparency color
-    aiColor3D transparent;
+    aiColor3D transparent = aiColor3D(1.0f, 1.0f, 1.0f);
+    //! Ambient occlusion
+    Maybe<ai_real> ambient_occlusion;
 
     //! PBR Roughness
     Maybe<ai_real> roughness;
@@ -187,31 +189,33 @@ struct Material {
     Maybe<ai_real> metallic;
     //! PBR Metallic
     Maybe<aiColor3D> sheen;
+    //! PBR Sheen: an additional grazing component, primarily intended for cloth.
+    Maybe<ai_real> sheen_grazing;
+    //! PBR Sheen Tint: amount to tint sheen towards base color.
+    Maybe<ai_real> sheen_tint;
+    //! PBR Clearcoat
+    Maybe<ai_real> clearcoat;
     //! PBR Clearcoat Thickness
     Maybe<ai_real> clearcoat_thickness;
     //! PBR Clearcoat Rougness
     Maybe<ai_real> clearcoat_roughness;
+    //! PBR clearcoatGloss: controls clearcoat glossiness (0 = a “satin” appearance, 1 = a “gloss” appearance).
+    Maybe<ai_real> clearcoat_gloss;
     //! PBR Anisotropy
-    ai_real anisotropy;
-
-    //! bump map multipler (normal map scalar)(-bm)
-    ai_real bump_multiplier;
+    ai_real anisotropy = ai_real(0.0);
+    //! PBR Anisotropy Rotation
+    Maybe<ai_real> anisotropy_rotation;
+    //! PBR Subsurface Scattering
+    Maybe<ai_real> subsurface_scattering;
+    //! PBR Specular Tint: a concession for artistic control that tints incident specular towards the base color.
+    Maybe<ai_real> specular_tint;
+    // See: https://disneyanimation.com/publications/physically-based-shading-at-disney/
+
+    //! bump map multiplier (normal map scalar)(-bm)
+    ai_real bump_multiplier = ai_real(1.0);
 
     //! Constructor
-    Material() :
-            diffuse(0.6f, 0.6f, 0.6f),
-            alpha(ai_real(1.0)),
-            shineness(ai_real(0.0)),
-            illumination_model(1),
-            ior(ai_real(1.0)),
-            transparent(1.0f, 1.0, 1.0),
-            roughness(),
-            metallic(),
-            sheen(),
-            clearcoat_thickness(),
-            clearcoat_roughness(),
-            anisotropy(ai_real(0.0)),
-            bump_multiplier(ai_real(1.0)) {
+    Material() {
         std::fill_n(clamp, static_cast<unsigned int>(TextureTypeCount), false);
     }
 
diff --git a/code/AssetLib/Obj/ObjFileMtlImporter.cpp b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
index 02ccfcb93..5f34e5363 100644
--- a/code/AssetLib/Obj/ObjFileMtlImporter.cpp
+++ b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
@@ -235,24 +235,64 @@ void ObjFileMtlImporter::load() {
                             ++m_DataIt;
                             if (m_pModel->mCurrentMaterial != nullptr)
                                 getFloatValue(m_pModel->mCurrentMaterial->clearcoat_roughness);
-                        } else {
+                        } else if (*m_DataIt == 't') {
+                            ++m_DataIt;
                             if (m_pModel->mCurrentMaterial != nullptr)
                                 getFloatValue(m_pModel->mCurrentMaterial->clearcoat_thickness);
+                        } else {
+                            if (m_pModel->mCurrentMaterial != nullptr)
+                                getFloatValue(m_pModel->mCurrentMaterial->clearcoat);
                         }
                         break;
                     }
                     m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                 }
                 break;
+            
+            case 'm': // Texture or metallic
+            {
+                // Save start of token (after 'm')
+                auto tokenStart = m_DataIt;  // points to 'm'
+                auto tokenEnd = getNextToken(m_DataIt, m_DataItEnd); // move iterator to end of token
+
+                std::string keyword(tokenStart, tokenEnd);
+                m_DataIt = tokenEnd; // advance iterator
+
+                if (keyword.compare(0, 3, "map") == 0) {
+                    // starts with "map", treat as texture map
+                    m_DataIt = tokenStart;
+                    getTexture();
+                } else if (keyword == "metallic" || keyword == "metal" || keyword == "metalness") {
+                    // parse metallic float value instead of texture
+                    getFloatIfMaterialValid(&ObjFile::Material::metallic);
+                }
+
+                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
+            } break;
 
-            case 'm': // Texture
             case 'b': // quick'n'dirty - for 'bump' sections
-            case 'r': // quick'n'dirty - for 'refl' sections
             {
                 getTexture();
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
+            case 'r': // refl (map) or roughness (float)
+            {
+                auto tokenStart = m_DataIt;  // points to 'r'
+                auto tokenEnd = getNextToken(m_DataIt, m_DataItEnd);
+                std::string keyword(tokenStart, tokenEnd);
+                m_DataIt = tokenEnd;
+
+                if (keyword == "roughness" || keyword == "rough") {
+                    getFloatIfMaterialValid(&ObjFile::Material::roughness);
+                } else if (keyword == "refl" || keyword == "reflection") {
+                    m_DataIt = tokenStart;
+                    getTexture();
+                }
+
+                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
+            } break;
+
             case 'i': // Illumination model
             {
                 m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
@@ -261,11 +301,60 @@ void ObjFileMtlImporter::load() {
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
-            case 'a': // Anisotropy
-            {
-                ++m_DataIt;
-                if (m_pModel->mCurrentMaterial != nullptr)
-                    getFloatValue(m_pModel->mCurrentMaterial->anisotropy);
+            case 'a': {
+                auto tokenStart = m_DataIt;
+                auto tokenEnd = getNextToken(m_DataIt, m_DataItEnd);
+                std::string keyword(tokenStart, tokenEnd);
+                m_DataIt = tokenEnd;
+
+                if (keyword == "aniso" || keyword == "anisotropy") {
+                    getFloatIfMaterialValid(&ObjFile::Material::anisotropy);
+                } else if (keyword == "ao") {
+                    getFloatIfMaterialValid(&ObjFile::Material::ambient_occlusion);
+                } else if (keyword == "anisor" || ai_stdStrToLower(keyword) == "anisotropicrotation") {
+                    getFloatIfMaterialValid(&ObjFile::Material::anisotropy_rotation);
+                } else {
+                    ASSIMP_LOG_WARN("Unhandled keyword: ", keyword );
+                }
+
+                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
+            } break;
+
+            case 's': {
+                auto tokenStart = m_DataIt;
+                auto tokenEnd = getNextToken(m_DataIt, m_DataItEnd);
+                std::string keyword(tokenStart, tokenEnd);
+                m_DataIt = tokenEnd;
+
+                if (keyword == "subsurface" || keyword == "scattering") {
+                    getFloatIfMaterialValid(&ObjFile::Material::subsurface_scattering);
+                } else if (ai_stdStrToLower(keyword) == "speculartint") {
+                    getFloatIfMaterialValid(&ObjFile::Material::specular_tint);
+                } else if (keyword == "sheen") {
+                    getFloatIfMaterialValid(&ObjFile::Material::sheen_grazing);
+                } else if (ai_stdStrToLower(keyword) == "sheentint") {
+                    getFloatIfMaterialValid(&ObjFile::Material::sheen_tint);
+                } else {
+                    ASSIMP_LOG_WARN("Unhandled keyword: ", keyword );
+                }
+
+                m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
+            } break;
+
+            case 'c': {
+                auto tokenStart = m_DataIt;
+                auto tokenEnd = getNextToken(m_DataIt, m_DataItEnd);
+                std::string keyword(tokenStart, tokenEnd);
+                m_DataIt = tokenEnd;
+
+                if (ai_stdStrToLower(keyword) == "clearcoat") {
+                    getFloatIfMaterialValid(&ObjFile::Material::clearcoat);
+                } else if (ai_stdStrToLower(keyword) == "clearcoatgloss") {
+                    getFloatIfMaterialValid(&ObjFile::Material::clearcoat_gloss);
+                } else {
+                    ASSIMP_LOG_WARN("Unhandled keyword: ", keyword );
+                }
+
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
@@ -332,6 +421,23 @@ void ObjFileMtlImporter::getFloatValue(Maybe<ai_real> &value) {
         value = Maybe<ai_real>();
 }
 
+// -------------------------------------------------------------------
+//  Writes a loaded single float value if material not null
+void ObjFileMtlImporter::getFloatIfMaterialValid(ai_real ObjFile::Material::*member) {
+    if (m_pModel != nullptr && m_pModel->mCurrentMaterial != nullptr) {
+        // This will call getFloatValue(ai_real&)
+        getFloatValue(m_pModel->mCurrentMaterial->*member);
+    }
+}
+
+// -------------------------------------------------------------------
+void ObjFileMtlImporter::getFloatIfMaterialValid(Maybe<ai_real> ObjFile::Material::*member) {
+    // It can directly access `m_pModel` because it's part of the class
+    if (m_pModel != nullptr && m_pModel->mCurrentMaterial != nullptr) {
+        getFloatValue(m_pModel->mCurrentMaterial->*member);
+    }
+}
+
 // -------------------------------------------------------------------
 //  Creates a material from loaded data.
 void ObjFileMtlImporter::createMaterial() {
diff --git a/code/AssetLib/Obj/ObjFileMtlImporter.h b/code/AssetLib/Obj/ObjFileMtlImporter.h
index f187b6e58..8a28dc48f 100644
--- a/code/AssetLib/Obj/ObjFileMtlImporter.h
+++ b/code/AssetLib/Obj/ObjFileMtlImporter.h
@@ -87,6 +87,8 @@ private:
     /// Gets a float value from data.
     void getFloatValue(ai_real &value);
     void getFloatValue(Maybe<ai_real> &value);
+    void getFloatIfMaterialValid(ai_real ObjFile::Material::*member);
+    void getFloatIfMaterialValid(Maybe<ai_real> ObjFile::Material::*member);
     /// Creates a new material from loaded data.
     void createMaterial();
     /// Get texture name from loaded data.
diff --git a/code/AssetLib/Obj/ObjFileParser.cpp b/code/AssetLib/Obj/ObjFileParser.cpp
index f1f0b4017..3a0a77650 100644
--- a/code/AssetLib/Obj/ObjFileParser.cpp
+++ b/code/AssetLib/Obj/ObjFileParser.cpp
@@ -121,6 +121,13 @@ void ObjFileParser::parseFile(IOStreamBuffer<char> &streamBuffer) {
         m_DataItEnd = buffer.end();
         mEnd = &buffer[buffer.size() - 1] + 1;
 
+        if (processed == 0 && std::distance(m_DataIt, m_DataItEnd) >= 3 &&
+            static_cast<unsigned char>(*m_DataIt) == 0xEF &&
+            static_cast<unsigned char>(*(m_DataIt + 1)) == 0xBB &&
+            static_cast<unsigned char>(*(m_DataIt + 2)) == 0xBF) {
+            m_DataIt += 3; // skip BOM
+        }
+
         // Handle progress reporting
         const size_t filePos(streamBuffer.getFilePos());
         if (lastFilePos < filePos) {
