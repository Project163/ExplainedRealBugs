diff --git a/code/IFCLoader.cpp b/code/IFCLoader.cpp
index 3ae88a74e..b6e6e0289 100644
--- a/code/IFCLoader.cpp
+++ b/code/IFCLoader.cpp
@@ -46,6 +46,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef ASSIMP_BUILD_NO_IFC_IMPORTER
 
 #include <iterator>
+#include <limits>
 #include <boost/tuple/tuple.hpp>
 
 #ifndef ASSIMP_BUILD_NO_COMPRESSED_IFC
@@ -560,7 +561,7 @@ void ProcessProductRepresentation(const IfcProduct& el, aiNode* nd, std::vector<
 	}
 
 	// extract Color from metadata, if present
-	unsigned int matid = ProcessMaterials( el.GetID(), UINT32_MAX, conv, false);
+	unsigned int matid = ProcessMaterials( el.GetID(), std::numeric_limits<uint32_t>::max(), conv, false);
 	std::vector<unsigned int> meshes;
 
 	// we want only one representation type, so bring them in a suitable order (i.e try those
diff --git a/code/IFCMaterial.cpp b/code/IFCMaterial.cpp
index 030603837..5b9bab00d 100644
--- a/code/IFCMaterial.cpp
+++ b/code/IFCMaterial.cpp
@@ -46,6 +46,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifndef ASSIMP_BUILD_NO_IFC_IMPORTER
 #include "IFCUtil.h"
+#include <limits>
 
 namespace Assimp {
 	namespace IFC {
@@ -167,12 +168,12 @@ unsigned int ProcessMaterials(uint64_t id, unsigned int prevMatId, ConversionDat
 	}
 
 	// no local material defined. If there's global one, use that instead
-	if( prevMatId != UINT32_MAX )
+	if( prevMatId != std::numeric_limits<uint32_t>::max() )
 		return prevMatId;
 
 	// we're still here - create an default material if required, or simply fail otherwise
 	if( !forceDefaultMat )
-		return UINT32_MAX;
+		return std::numeric_limits<uint32_t>::max();
 
 	aiString name;
 	name.Set("<IFCDefault>");
