diff --git a/code/glTF2/glTF2Asset.h b/code/glTF2/glTF2Asset.h
index 831a763cd..d13ebfd66 100644
--- a/code/glTF2/glTF2Asset.h
+++ b/code/glTF2/glTF2Asset.h
@@ -1034,6 +1034,12 @@ namespace glTF2
 			bool KHR_texture_transform;
         } extensionsUsed;
 
+        //! Keeps info about the required extensions
+        struct RequiredExtensions
+        {
+            bool KHR_draco_mesh_compression;
+        } extensionsRequired;
+
         AssetMetadata asset;
 
 
@@ -1076,6 +1082,7 @@ namespace glTF2
             , textures      (*this, "textures")
         {
             memset(&extensionsUsed, 0, sizeof(extensionsUsed));
+            memset(&extensionsRequired, 0, sizeof(extensionsRequired));
         }
 
         //! Main function
@@ -1094,6 +1101,7 @@ namespace glTF2
         void ReadBinaryHeader(IOStream& stream, std::vector<char>& sceneData);
 
         void ReadExtensionsUsed(Document& doc);
+        void ReadExtensionsRequired(Document& doc);
 
         IOStream* OpenFile(std::string path, const char* mode, bool absolute = false);
     };
diff --git a/code/glTF2/glTF2Asset.inl b/code/glTF2/glTF2Asset.inl
index 4259022e9..32bca88ce 100644
--- a/code/glTF2/glTF2Asset.inl
+++ b/code/glTF2/glTF2Asset.inl
@@ -1432,6 +1432,12 @@ inline void Asset::Load(const std::string& pFile, bool isBinary)
     // Load the metadata
     asset.Read(doc);
     ReadExtensionsUsed(doc);
+    ReadExtensionsRequired(doc);
+
+    // Currently Draco is not supported
+    if (extensionsRequired.KHR_draco_mesh_compression) {
+        throw DeadlyImportError("GLTF: Draco mesh compression not currently supported.");
+    }
 
     // Prepare the dictionaries
     for (size_t i = 0; i < mDicts.size(); ++i) {
@@ -1478,6 +1484,28 @@ inline void Asset::SetAsBinary()
     }
 }
 
+// As required extensions are only a concept in glTF 2.0, this is here
+// instead of glTFCommon.h
+#define CHECK_REQUIRED_EXT(EXT) \
+	if (exts.find(#EXT) != exts.end()) extensionsRequired.EXT = true;
+
+inline void Asset::ReadExtensionsRequired(Document& doc)
+{
+    Value* extsRequired = FindArray(doc, "extensionsRequired");
+    if (!extsRequired) return;
+
+    std::gltf_unordered_map<std::string, bool> exts;
+
+    for (unsigned int i = 0; i < extsRequired->Size(); ++i) {
+        if ((*extsRequired)[i].IsString()) {
+            exts[(*extsRequired)[i].GetString()] = true;
+        }
+    }
+
+    CHECK_REQUIRED_EXT(KHR_draco_mesh_compression);
+
+    #undef CHECK_REQUIRED_EXT
+}
 
 inline void Asset::ReadExtensionsUsed(Document& doc)
 {
