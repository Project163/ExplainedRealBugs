diff --git a/code/AssetLib/Collada/ColladaParser.cpp b/code/AssetLib/Collada/ColladaParser.cpp
index 46d832380..59a012325 100644
--- a/code/AssetLib/Collada/ColladaParser.cpp
+++ b/code/AssetLib/Collada/ColladaParser.cpp
@@ -335,7 +335,7 @@ void ColladaParser::ReadAssetInfo(XmlNode &node) {
         const std::string &currentName = currentNode.name();
         if (currentName == "unit") {
             mUnitSize = 1.f;
-            XmlParser::getFloatAttribute(currentNode, "meter", mUnitSize);
+            XmlParser::getRealAttribute(currentNode, "meter", mUnitSize);
         } else if (currentName == "up_axis") {
             std::string v;
             if (!XmlParser::getValueAsString(currentNode, v)) {
@@ -957,33 +957,33 @@ void ColladaParser::ReadLight(XmlNode &node, Collada::Light &pLight) {
             content = fast_atoreal_move<ai_real>(content, (ai_real &)pLight.mColor.b);
             SkipSpacesAndLineEnd(&content);
         } else if (currentName == "constant_attenuation") {
-            XmlParser::getFloatAttribute(currentNode, "constant_attenuation", pLight.mAttConstant);
+            XmlParser::getRealAttribute(currentNode, "constant_attenuation", pLight.mAttConstant);
         } else if (currentName == "linear_attenuation") {
-            XmlParser::getFloatAttribute(currentNode, "linear_attenuation", pLight.mAttLinear);
+            XmlParser::getRealAttribute(currentNode, "linear_attenuation", pLight.mAttLinear);
         } else if (currentName == "quadratic_attenuation") {
-            XmlParser::getFloatAttribute(currentNode, "quadratic_attenuation", pLight.mAttQuadratic);
+            XmlParser::getRealAttribute(currentNode, "quadratic_attenuation", pLight.mAttQuadratic);
         } else if (currentName == "falloff_angle") {
-            XmlParser::getFloatAttribute(currentNode, "falloff_angle", pLight.mFalloffAngle);
+            XmlParser::getRealAttribute(currentNode, "falloff_angle", pLight.mFalloffAngle);
         } else if (currentName == "falloff_exponent") {
-            XmlParser::getFloatAttribute(currentNode, "falloff_exponent", pLight.mFalloffExponent);
+            XmlParser::getRealAttribute(currentNode, "falloff_exponent", pLight.mFalloffExponent);
         }
         // FCOLLADA extensions
         // -------------------------------------------------------
         else if (currentName == "outer_cone") {
-            XmlParser::getFloatAttribute(currentNode, "outer_cone", pLight.mOuterAngle);
+            XmlParser::getRealAttribute(currentNode, "outer_cone", pLight.mOuterAngle);
         } else if (currentName == "penumbra_angle") { // ... and this one is even deprecated
-            XmlParser::getFloatAttribute(currentNode, "penumbra_angle", pLight.mPenumbraAngle);
+            XmlParser::getRealAttribute(currentNode, "penumbra_angle", pLight.mPenumbraAngle);
         } else if (currentName == "intensity") {
-            XmlParser::getFloatAttribute(currentNode, "intensity", pLight.mIntensity);
+            XmlParser::getRealAttribute(currentNode, "intensity", pLight.mIntensity);
         } else if (currentName == "falloff") {
-            XmlParser::getFloatAttribute(currentNode, "falloff", pLight.mOuterAngle);
+            XmlParser::getRealAttribute(currentNode, "falloff", pLight.mOuterAngle);
         } else if (currentName == "hotspot_beam") {
-            XmlParser::getFloatAttribute(currentNode, "hotspot_beam", pLight.mFalloffAngle);
+            XmlParser::getRealAttribute(currentNode, "hotspot_beam", pLight.mFalloffAngle);
         }
         // OpenCOLLADA extensions
         // -------------------------------------------------------
         else if (currentName == "decay_falloff") {
-            XmlParser::getFloatAttribute(currentNode, "decay_falloff", pLight.mOuterAngle);
+            XmlParser::getRealAttribute(currentNode, "decay_falloff", pLight.mOuterAngle);
         }
     }
 }
@@ -1162,15 +1162,15 @@ void ColladaParser::ReadSamplerProperties(XmlNode &node, Sampler &out) {
         } else if (currentName == "mirrorV") {
             XmlParser::getBoolAttribute(currentNode, currentName.c_str(), out.mMirrorV);
         } else if (currentName == "repeatU") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mTransform.mScaling.x);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mTransform.mScaling.x);
         } else if (currentName == "repeatV") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mTransform.mScaling.y);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mTransform.mScaling.y);
         } else if (currentName == "offsetU") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mTransform.mTranslation.x);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mTransform.mTranslation.x);
         } else if (currentName == "offsetV") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mTransform.mTranslation.y);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mTransform.mTranslation.y);
         } else if (currentName == "rotateUV") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mTransform.mRotation);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mTransform.mRotation);
         } else if (currentName == "blend_mode") {
             std::string v;
             XmlParser::getValueAsString(currentNode, v);
@@ -1190,14 +1190,14 @@ void ColladaParser::ReadSamplerProperties(XmlNode &node, Sampler &out) {
         // OKINO extensions
         // -------------------------------------------------------
         else if (currentName == "weighting") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mWeighting);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mWeighting);
         } else if (currentName == "mix_with_previous_layer") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mMixWithPrevious);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mMixWithPrevious);
         }
         // MAX3D extensions
         // -------------------------------------------------------
         else if (currentName == "amount") {
-            XmlParser::getFloatAttribute(currentNode, currentName.c_str(), out.mWeighting);
+            XmlParser::getRealAttribute(currentNode, currentName.c_str(), out.mWeighting);
         }
     }
 }
diff --git a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
index 1c20527fb..4df0d0d1d 100644
--- a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
+++ b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
@@ -1309,7 +1309,7 @@ void HL1MDLLoader::read_global_info() {
 */
 void HL1MDLLoader::extract_anim_value(
         const AnimValue_HL1 *panimvalue,
-        int frame, float bone_scale, float &value) {
+        int frame, float bone_scale, ai_real &value) {
     int k = frame;
 
     // find span of values that includes the frame we want
diff --git a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.h b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.h
index 86e96fc45..74bff7362 100644
--- a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.h
+++ b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.h
@@ -132,7 +132,7 @@ private:
     * \param[in,out] value The decompressed anim value at \p frame.
     */
     void extract_anim_value(const AnimValue_HL1 *panimvalue,
-            int frame, float bone_scale, float &value);
+            int frame, float bone_scale, ai_real &value);
 
     /**
      *  \brief Given the number of blend animations, determine the number of blend controllers.
diff --git a/code/Pbrt/PbrtExporter.cpp b/code/Pbrt/PbrtExporter.cpp
index 168a30db5..b793c37f9 100644
--- a/code/Pbrt/PbrtExporter.cpp
+++ b/code/Pbrt/PbrtExporter.cpp
@@ -761,7 +761,7 @@ void PbrtExporter::WriteLights() {
             case aiLightSource_AREA: {
                 aiVector3D left = light->mDirection ^ light->mUp;
                 // rectangle. center at position, direction is normal vector
-                float dLeft = light->mSize.x / 2, dUp = light->mSize.y / 2;
+                ai_real dLeft = light->mSize.x / 2, dUp = light->mSize.y / 2;
                 aiVector3D vertices[4] = {
                      light->mPosition - dLeft * left - dUp * light->mUp,
                      light->mPosition + dLeft * left - dUp * light->mUp,
diff --git a/include/assimp/XmlParser.h b/include/assimp/XmlParser.h
index e6114a914..4d212232a 100644
--- a/include/assimp/XmlParser.h
+++ b/include/assimp/XmlParser.h
@@ -178,6 +178,26 @@ public:
         return true;
     }
 
+#ifdef ASSIMP_DOUBLE_PRECISION
+    static inline bool getRealAttribute( XmlNode &xmlNode, const char *name, ai_real &val ) {
+        pugi::xml_attribute attr = xmlNode.attribute(name);
+        if (attr.empty()) {
+            return false;
+        }
+        val = attr.as_double();
+        return true;
+    }
+#else
+    static inline bool getRealAttribute(XmlNode &xmlNode, const char *name, ai_real &val ) {
+        pugi::xml_attribute attr = xmlNode.attribute(name);
+        if (attr.empty()) {
+            return false;
+        }
+        val = attr.as_float();
+        return true;
+    }
+#endif
+
     static inline bool getFloatAttribute(XmlNode &xmlNode, const char *name, float &val ) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
