diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
new file mode 100644
index 00000000..546b80ad
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -0,0 +1,27 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Replaces the header with the the value of its target. If the target is null,
+ * the header is removed.
+ *
+ * <p/>
+ * ex.
+ *
+ * <pre>
+ * @GET("/")
+ * void foo(@Header("Auth-Token") String token, ..);
+ * </pre>
+ *
+ * @author Adrian Cole (adrianc@netflix.com)
+ */
+@Retention(RUNTIME) @Target(PARAMETER)
+public @interface Header {
+  String value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/HeaderPair.java b/retrofit/src/main/java/retrofit/http/HeaderPair.java
index 10a6ae31..a42fcc80 100644
--- a/retrofit/src/main/java/retrofit/http/HeaderPair.java
+++ b/retrofit/src/main/java/retrofit/http/HeaderPair.java
@@ -1,4 +1,4 @@
-// Copyright 2012 Square, Inc.
+// Copyright 2013 Square, Inc.
 package retrofit.http;
 
 /** Represents an HTTP header name/value pair. */
diff --git a/retrofit/src/main/java/retrofit/http/Headers.java b/retrofit/src/main/java/retrofit/http/Headers.java
new file mode 100644
index 00000000..0b887248
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Headers.java
@@ -0,0 +1,34 @@
+// Copyright 2013 Square, Inc.
+package retrofit.http;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Adds headers literally supplied in the {@code value}.
+ *
+ * <p/>
+ * ex.
+ *
+ * <pre>
+ * @Headers("Cache-Control: max-age=640000")
+ * @GET("/")
+ * ...
+ *
+ * @Headers({
+ *   "X-Foo: Bar",
+ *   "X-Ping: Pong"
+ * })
+ * @GET("/")
+ * ...
+ * </pre>
+ *
+ * @author Adrian Cole (adrianc@netflix.com)
+ */
+@Target(METHOD) @Retention(RUNTIME)
+public @interface Headers {
+  String[] value();
+}
diff --git a/retrofit/src/main/java/retrofit/http/RequestBuilder.java b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
index 485be705..53d2cf2d 100644
--- a/retrofit/src/main/java/retrofit/http/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/http/RequestBuilder.java
@@ -4,6 +4,7 @@ package retrofit.http;
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
@@ -64,7 +65,7 @@ final class RequestBuilder {
     int singleEntityArgumentIndex = methodInfo.singleEntityArgumentIndex;
     for (int i = 0; i < pathNamedParams.length; i++) {
       Object arg = args[i];
-      if (arg == null) continue;
+      if (arg == null || pathNamedParams[i] == null) continue;
       if (i != singleEntityArgumentIndex) {
         params.add(new Parameter(pathNamedParams[i], arg, arg.getClass()));
       }
@@ -150,6 +151,30 @@ final class RequestBuilder {
       }
     }
 
+    List<HeaderPair> headers = new ArrayList<HeaderPair>();
+    if (this.headers != null) {
+      headers.addAll(this.headers);
+    }
+    if (methodInfo.headers != null) {
+      headers.addAll(methodInfo.headers);
+    }
+    List<String> headersToRemove = new ArrayList<String>();
+    if (methodInfo.headerParams != null) {
+      for (int i = 0; i < methodInfo.headerParams.length; i++) {
+        String name = methodInfo.headerParams[i];
+        if (name == null) continue;
+        Object arg = args[i];
+        if (arg != null) {
+          headers.add(new HeaderPair(name, arg.toString()));
+        } else {
+          headersToRemove.add(name);
+        }
+      }
+    }
+    for (Iterator<HeaderPair> header = headers.iterator(); header.hasNext();) {
+      if (headersToRemove.contains(header.next().getName()))
+        header.remove();
+    }
     return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);
   }
 
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index 9252b0ce..82cddb46 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -50,8 +50,8 @@ public class RestAdapter {
   private volatile boolean debug;
 
   private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, HeaderPairs headers, Converter converter, Profiler profiler, Log log,
-      boolean debug) {
+      Executor callbackExecutor, HeaderPairs headers, Converter converter, Profiler profiler,
+      Log log, boolean debug) {
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
diff --git a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
index e7ac42b5..e6b2acc7 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/http/RestMethodInfo.java
@@ -6,7 +6,9 @@ import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -27,6 +29,8 @@ final class RestMethodInfo {
   String path;
   Set<String> pathParams;
   QueryParam[] pathQueryParams;
+  List<HeaderPair> headers;
+  String[] headerParams;
   String[] namedParams;
   int singleEntityArgumentIndex = NO_SINGLE_ENTITY;
   boolean isMultipart = false;
@@ -46,8 +50,8 @@ final class RestMethodInfo {
   }
 
   /**
-   * Loads {@link #restMethod}, {@link #path}, {@link #pathParams}, {@link #pathQueryParams}, and
-   * {@link #isMultipart}.
+   * Loads {@link #restMethod}, {@link #path}, {@link #pathParams}, {@link #pathQueryParams},
+   * {@link headers}, and {@link #isMultipart}.
    */
   private void parseMethodAnnotations() {
     for (Annotation methodAnnotation : method.getAnnotations()) {
@@ -73,6 +77,12 @@ final class RestMethodInfo {
         }
         pathParams = parsePathParameters(path);
         restMethod = methodInfo;
+      } else if (annotationType == Headers.class) {
+        String[] headersToParse = ((Headers) methodAnnotation).value();
+        if (headersToParse.length == 0) {
+          throw new IllegalStateException("Headers annotation was empty.");
+        }
+        headers = parseHeaders(headersToParse);
       } else if (annotationType == QueryParams.class) {
         if (pathQueryParams != null) {
           throw new IllegalStateException(
@@ -112,6 +122,17 @@ final class RestMethodInfo {
     }
   }
 
+  private List<HeaderPair> parseHeaders(String[] headersToParse) {
+    List<HeaderPair> headers = new ArrayList<HeaderPair>();
+    for (String headerToParse: headersToParse) {
+      int colon = headerToParse.indexOf(':');
+      headers.add(new HeaderPair(headerToParse.substring(0, colon),
+                                 headerToParse.substring(colon + 2)));
+
+    }
+    return headers;
+  }
+
   /** Loads {@link #type}. Returns true if the method is synchronous. */
   private boolean parseResponseType() {
     // Synchronous methods have a non-void return type.
@@ -168,8 +189,8 @@ final class RestMethodInfo {
   }
 
   /**
-   * Loads {@link #namedParams}, {@link #singleEntityArgumentIndex}. Must be called after
-   * {@link #parseMethodAnnotations()}}.
+   * Loads {@link #namedParams}, {@link headerParams}, {@link #singleEntityArgumentIndex},
+   * Must be called after {@link #parseMethodAnnotations()}}.
    */
   private void parseParameters() {
     Class<?>[] parameterTypes = method.getParameterTypes();
@@ -180,6 +201,7 @@ final class RestMethodInfo {
     }
 
     String[] namedParams = new String[count];
+    String[] headerParams = new String[count];
     for (int i = 0; i < count; i++) {
       Class<?> parameterType = parameterTypes[i];
       Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
@@ -199,6 +221,13 @@ final class RestMethodInfo {
             throw new IllegalStateException(
                 "Non-path params can only be used in multipart request.");
           }
+        } else if (annotationType == Header.class) {
+          String header = ((Header) parameterAnnotation).value();
+          headerParams[i] = header;
+          if (parameterType != String.class) {
+            throw new IllegalStateException(
+                "Expected @Header parameter type to be String: " + header);
+          }
         } else if (annotationType == SingleEntity.class) {
           if (isMultipart) {
             throw new IllegalStateException("SingleEntity cannot be used with multipart request.");
@@ -228,6 +257,7 @@ final class RestMethodInfo {
           "Non-body HTTP method cannot contain @SingleEntity or @TypedOutput.");
     }
     this.namedParams = namedParams;
+    this.headerParams = headerParams;
   }
 
   /**
diff --git a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
index c15f66ef..27823a2b 100644
--- a/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/http/RequestBuilderTest.java
@@ -10,7 +10,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import org.junit.Test;
 import retrofit.http.client.Request;
@@ -248,6 +247,66 @@ public class RequestBuilderTest {
     assertThat(request.getBody()).isNull();
   }
 
+  @Test public void methodHeader() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addMethodHeader("kit", "kat") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()) //
+        .containsExactly(new HeaderPair("ping", "pong"), new HeaderPair("kit", "kat"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void headerParam() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addHeaderParam("kit", "kat") //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()) //
+        .containsExactly(new HeaderPair("ping", "pong"), new HeaderPair("kit", "kat"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void nullHeaderParamRemovesHeader() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addHeaderParam("ping", null) //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()).isEmpty();
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
+  @Test public void nullHeaderParamRemovesMethodHeader() throws Exception {
+    Request request = new Helper() //
+        .setMethod("GET") //
+        .setUrl("http://example.com") //
+        .setPath("/foo/bar/") //
+        .addHeader("ping", "pong") //
+        .addMethodHeader("kit", "kat") //
+        .addHeaderParam("kit", null) //
+        .build();
+    assertThat(request.getMethod()).isEqualTo("GET");
+    assertThat(request.getHeaders()) //
+        .containsExactly(new HeaderPair("ping", "pong"));
+    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.getBody()).isNull();
+  }
+
   @Test public void noDuplicateSlashes() throws Exception {
     Request request = new Helper() //
         .setMethod("GET") //
@@ -274,9 +333,11 @@ public class RequestBuilderTest {
     private String path;
     private Set<String> pathParams;
     private final List<QueryParam> queryParams = new ArrayList<QueryParam>();
+    private final List<String> headerParams = new ArrayList<String>();
     private final List<String> namedParams = new ArrayList<String>();
     private final List<Object> args = new ArrayList<Object>();
     private final List<HeaderPair> headers = new ArrayList<HeaderPair>();
+    private final List<HeaderPair> methodHeaders = new ArrayList<HeaderPair>();
     private int singleEntityArgumentIndex = NO_SINGLE_ENTITY;
     private String url;
 
@@ -318,6 +379,15 @@ public class RequestBuilderTest {
       return this;
     }
 
+    Helper addHeaderParam(String name, Object value) {
+      if (name == null) {
+        throw new IllegalArgumentException("Name can not be null.");
+      }
+      headerParams.add(name);
+      args.add(value);
+      return this;
+    }
+
     Helper addSingleEntityParam(Object value) {
       if (singleEntityArgumentIndex != NO_SINGLE_ENTITY) {
         throw new IllegalStateException("Single entity param already added.");
@@ -334,6 +404,11 @@ public class RequestBuilderTest {
       return this;
     }
 
+    Helper addMethodHeader(String name, String value) {
+      methodHeaders.add(new HeaderPair(name, value));
+      return this;
+    }
+
     Helper setMultipart() {
       isMultipart = true;
       return this;
@@ -370,6 +445,8 @@ public class RequestBuilderTest {
       methodInfo.path = path;
       methodInfo.pathParams = pathParams;
       methodInfo.pathQueryParams = queryParams.toArray(new QueryParam[queryParams.size()]);
+      methodInfo.headers = methodHeaders;
+      methodInfo.headerParams = headerParams.toArray(new String[headerParams.size()]);
       methodInfo.namedParams = namedParams.toArray(new String[namedParams.size()]);
       methodInfo.singleEntityArgumentIndex = singleEntityArgumentIndex;
       methodInfo.isMultipart = isMultipart;
diff --git a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
index 80255d25..f0517002 100644
--- a/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestMethodInfoTest.java
@@ -6,6 +6,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -775,6 +776,68 @@ public class RestMethodInfoTest {
     methodInfo.init();
   }
 
+  @Test(expected = IllegalStateException.class)
+  public void headersFailWhenEmptyOnMethod() {
+    class Example {
+      @GET("/") @Headers({}) Response a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+  }
+
+  @Test public void twoMethodHeaders() {
+
+    class Example {
+      @GET("/") @Headers({
+        "X-Foo: Bar",
+        "X-Ping: Pong"
+      }) Response a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+
+    assertThat(methodInfo.headers).isEqualTo(
+        Arrays.asList(new HeaderPair("X-Foo", "Bar"), new HeaderPair("X-Ping", "Pong")));
+  }
+
+  @Test public void twoHeaderParams() {
+    class Example {
+      @GET("/")
+      Response a(@Header("a") String a, @Header("b") String b) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+
+    assertThat(Arrays.asList(methodInfo.headerParams))
+      .isEqualTo(Arrays.asList("a", "b"));
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void headerParamMustBeString() {
+    class Example {
+      @GET("/")
+      Response a(@Header("a") TypedOutput a, @Header("b") int b) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    methodInfo.init();
+  }
+
   private static class Response {
   }
 
