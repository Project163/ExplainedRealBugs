diff --git a/retrofit/src/main/java/retrofit/http/Converter.java b/retrofit/src/main/java/retrofit/http/Converter.java
index 638e2eb5..0a829525 100644
--- a/retrofit/src/main/java/retrofit/http/Converter.java
+++ b/retrofit/src/main/java/retrofit/http/Converter.java
@@ -17,8 +17,10 @@ public interface Converter {
    * @param body HTTP response body.
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
-   * @throws ConversionException If conversion was unable to complete. This will trigger a call to
-   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}.
+   * @throws ConversionException if conversion was unable to complete. This will trigger a call to
+   * {@link Callback#failure(RetrofitError)} or throw a {@link retrofit.http.RetrofitError}. The
+   * exception message should report all necessary information about its cause as the response body
+   * will be set to {@code null}.
    */
   Object fromBody(TypedInput body, Type type) throws ConversionException;
 
diff --git a/retrofit/src/main/java/retrofit/http/RestAdapter.java b/retrofit/src/main/java/retrofit/http/RestAdapter.java
index e77f4121..1e209138 100644
--- a/retrofit/src/main/java/retrofit/http/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/http/RestAdapter.java
@@ -195,13 +195,19 @@ public class RestAdapter {
         }
 
         Type type = methodDetails.type;
+
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
+          // Caller requested the raw Response object directly.
           if (type.equals(Response.class)) {
+            // Read the entire stream and replace with one backed by a byte[]
+            response = Utils.readBodyToBytesIfNecessary(response);
+
             if (methodDetails.isSynchronous) {
               return response;
             }
             return new ResponseWrapper(response, response);
           }
+
           TypedInput body = response.getBody();
           if (body == null) {
             return new ResponseWrapper(response, null);
@@ -213,9 +219,14 @@ public class RestAdapter {
             }
             return new ResponseWrapper(response, convert);
           } catch (ConversionException e) {
+            // The response body was partially read by the converter. Replace it with null.
+            response = Utils.replaceResponseBody(response, null);
+
             throw RetrofitError.conversionError(url, response, converter, type, e);
           }
         }
+
+        response = Utils.readBodyToBytesIfNecessary(response);
         throw RetrofitError.httpError(url, response, converter, type);
       } catch (RetrofitError e) {
         throw e; // Pass through our own errors.
@@ -248,8 +259,8 @@ public class RestAdapter {
       bodySize = bodyBytes.length;
       String bodyMime = body.mimeType();
       String bodyString = new String(bodyBytes, Utils.parseCharset(bodyMime));
-      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
-        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
         log.log(bodyString.substring(i, end));
       }
 
@@ -278,23 +289,26 @@ public class RestAdapter {
         log.log("");
       }
 
-      byte[] bodyBytes = Utils.streamToBytes(body.in());
+      if (!(body instanceof TypedByteArray)) {
+        // Read the entire response body to we can log it and replace the original response
+        response = Utils.readBodyToBytesIfNecessary(response);
+        body = response.getBody();
+      }
+
+      byte[] bodyBytes = ((TypedByteArray) body).getBytes();
       bodySize = bodyBytes.length;
       String bodyMime = body.mimeType();
       String bodyCharset = Utils.parseCharset(bodyMime);
       String bodyString = new String(bodyBytes, bodyCharset);
-      for (int i = 0; i < bodyString.length(); i += LOG_CHUNK_SIZE) {
-        int end = Math.min(bodyString.length(), i + LOG_CHUNK_SIZE);
+      for (int i = 0, len = bodyString.length(); i < len; i += LOG_CHUNK_SIZE) {
+        int end = Math.min(len, i + LOG_CHUNK_SIZE);
         log.log(bodyString.substring(i, end));
       }
-
-      body = new TypedByteArray(bodyMime, bodyBytes);
     }
 
-    log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
+    log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
 
-    // Since we consumed the original response, return a new, identical one from its bytes.
-    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
+    return response;
   }
 
   private static Profiler.RequestInformation getRequestInfo(String serverUrl,
diff --git a/retrofit/src/main/java/retrofit/http/Utils.java b/retrofit/src/main/java/retrofit/http/Utils.java
index e606f18f..12dddb5e 100644
--- a/retrofit/src/main/java/retrofit/http/Utils.java
+++ b/retrofit/src/main/java/retrofit/http/Utils.java
@@ -8,6 +8,9 @@ import java.io.InputStream;
 import java.util.concurrent.Executor;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import retrofit.http.client.Response;
+import retrofit.http.mime.TypedByteArray;
+import retrofit.http.mime.TypedInput;
 
 import static java.util.regex.Pattern.CASE_INSENSITIVE;
 
@@ -33,6 +36,27 @@ public final class Utils {
     return baos.toByteArray();
   }
 
+  /**
+   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
+   * byte[] rather than an input stream.
+   */
+  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
+    TypedInput body = response.getBody();
+    if (body == null || body instanceof TypedByteArray) {
+      return response;
+    }
+
+    String bodyMime = body.mimeType();
+    byte[] bodyBytes = Utils.streamToBytes(body.in());
+    body = new TypedByteArray(bodyMime, bodyBytes);
+
+    return replaceResponseBody(response, body);
+  }
+
+  static Response replaceResponseBody(Response response, TypedInput body) {
+    return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
+  }
+
   public static String parseCharset(String mimeType) {
     Matcher match = CHARSET.matcher(mimeType);
     if (match.find()) {
@@ -50,4 +74,4 @@ public final class Utils {
   private Utils() {
     // No instances.
   }
-}
\ No newline at end of file
+}
diff --git a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
index 683055a1..de15b6bd 100644
--- a/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/http/RestAdapterTest.java
@@ -111,7 +111,7 @@ public class RestAdapterTest {
     } catch (RetrofitError e) {
       assertThat(e.getResponse().getStatus()).isEqualTo(200);
       assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isEqualTo(new TypedString("{"));
+      assertThat(e.getResponse().getBody()).isNull();
     }
   }
 
