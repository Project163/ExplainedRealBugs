diff --git a/fs/operations/multithread.go b/fs/operations/multithread.go
index 1e8f5ec82..1f615d4b2 100644
--- a/fs/operations/multithread.go
+++ b/fs/operations/multithread.go
@@ -165,7 +165,6 @@ func multiThreadCopy(ctx context.Context, f fs.Fs, remote string, src fs.Object,
 	if err != nil {
 		return nil, errors.Wrap(err, "multpart copy: failed to open destination")
 	}
-	defer fs.CheckClose(mc.wc, &err)
 
 	fs.Debugf(src, "Starting multi-thread copy with %d parts of size %v", mc.streams, fs.SizeSuffix(mc.partSize))
 	for stream := 0; stream < mc.streams; stream++ {
@@ -175,9 +174,13 @@ func multiThreadCopy(ctx context.Context, f fs.Fs, remote string, src fs.Object,
 		})
 	}
 	err = g.Wait()
+	closeErr := mc.wc.Close()
 	if err != nil {
 		return nil, err
 	}
+	if closeErr != nil {
+		return nil, errors.Wrap(closeErr, "multi-thread copy: failed to close object after copy")
+	}
 
 	obj, err := f.NewObject(ctx, remote)
 	if err != nil {
diff --git a/fs/operations/multithread_test.go b/fs/operations/multithread_test.go
index 9e125a702..86ca3c1b6 100644
--- a/fs/operations/multithread_test.go
+++ b/fs/operations/multithread_test.go
@@ -138,7 +138,7 @@ func TestMultithreadCopy(t *testing.T) {
 			assert.Equal(t, src.Size(), dst.Size())
 			assert.Equal(t, "file1", dst.Remote())
 
-			fstest.CheckListingWithPrecision(t, r.Fremote, []fstest.Item{file1}, nil, fs.ModTimeNotSupported)
+			fstest.CheckItems(t, r.Flocal, file1)
 			require.NoError(t, dst.Remove(context.Background()))
 		})
 	}
