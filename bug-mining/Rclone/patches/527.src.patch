diff --git a/lib/rest/rest.go b/lib/rest/rest.go
index 76eda84ff..2f473026a 100644
--- a/lib/rest/rest.go
+++ b/lib/rest/rest.go
@@ -166,30 +166,6 @@ func DecodeXML(resp *http.Response, result interface{}) (err error) {
 	return decoder.Decode(result)
 }
 
-// ClientWithHeaderReset makes a new http client which resets the
-// headers passed in on redirect
-//
-// FIXME This is now unecessary with go1.8
-func ClientWithHeaderReset(c *http.Client, headers map[string]string) *http.Client {
-	if len(headers) == 0 {
-		return c
-	}
-	clientCopy := *c
-	clientCopy.CheckRedirect = func(req *http.Request, via []*http.Request) error {
-		if len(via) >= 10 {
-			return errors.New("stopped after 10 redirects")
-		}
-		// Reset the headers in the new request
-		for k, v := range headers {
-			if v != "" {
-				req.Header.Set(k, v)
-			}
-		}
-		return nil
-	}
-	return &clientCopy
-}
-
 // ClientWithNoRedirects makes a new http client which won't follow redirects
 func ClientWithNoRedirects(c *http.Client) *http.Client {
 	clientCopy := *c
diff --git a/lib/rest/rest_header_reset.go b/lib/rest/rest_header_reset.go
new file mode 100644
index 000000000..599473f40
--- /dev/null
+++ b/lib/rest/rest_header_reset.go
@@ -0,0 +1,15 @@
+//+build go1.8
+
+package rest
+
+import (
+	"net/http"
+)
+
+// ClientWithHeaderReset makes a new http client which resets the
+// headers passed in on redirect
+//
+// This is now unecessary with go1.8 so becomes a no-op
+func ClientWithHeaderReset(c *http.Client, headers map[string]string) *http.Client {
+	return c
+}
diff --git a/lib/rest/rest_header_reset_go17.go b/lib/rest/rest_header_reset_go17.go
new file mode 100644
index 000000000..7b3109b57
--- /dev/null
+++ b/lib/rest/rest_header_reset_go17.go
@@ -0,0 +1,33 @@
+//+build !go1.8
+
+package rest
+
+import (
+	"net/http"
+
+	"github.com/pkg/errors"
+)
+
+// ClientWithHeaderReset makes a new http client which resets the
+// headers passed in on redirect
+//
+// This is only needed for go < go1.8
+func ClientWithHeaderReset(c *http.Client, headers map[string]string) *http.Client {
+	if len(headers) == 0 {
+		return c
+	}
+	clientCopy := *c
+	clientCopy.CheckRedirect = func(req *http.Request, via []*http.Request) error {
+		if len(via) >= 10 {
+			return errors.New("stopped after 10 redirects")
+		}
+		// Reset the headers in the new request
+		for k, v := range headers {
+			if v != "" {
+				req.Header.Set(k, v)
+			}
+		}
+		return nil
+	}
+	return &clientCopy
+}
