diff --git a/Gopkg.lock b/Gopkg.lock
index b3cdeefd1..851cad592 100644
--- a/Gopkg.lock
+++ b/Gopkg.lock
@@ -331,7 +331,7 @@
   branch = "master"
   name = "github.com/t3rm1n4l/go-mega"
   packages = ["."]
-  revision = "3ba49835f4db01d6329782cbdc7a0a8bb3a26c5f"
+  revision = "57978a63bd3f91fa7e188b751a7e7e6dd4e33813"
 
 [[projects]]
   branch = "master"
diff --git a/vendor/github.com/t3rm1n4l/go-mega/.travis.yml b/vendor/github.com/t3rm1n4l/go-mega/.travis.yml
index 96561bbd5..dda4077ae 100644
--- a/vendor/github.com/t3rm1n4l/go-mega/.travis.yml
+++ b/vendor/github.com/t3rm1n4l/go-mega/.travis.yml
@@ -4,7 +4,6 @@ osx_image: xcode7.3
 os:
 - linux
 go:
-- 1.6.4
 - 1.7.6
 - 1.8.7
 - 1.9.5
diff --git a/vendor/github.com/t3rm1n4l/go-mega/mega.go b/vendor/github.com/t3rm1n4l/go-mega/mega.go
index b2e9d57b9..81f992eae 100644
--- a/vendor/github.com/t3rm1n4l/go-mega/mega.go
+++ b/vendor/github.com/t3rm1n4l/go-mega/mega.go
@@ -112,6 +112,10 @@ type Mega struct {
 	debugf func(format string, v ...interface{})
 	// serialize the API requests
 	apiMu sync.Mutex
+	// mutex to protext waitEvents
+	waitEventsMu sync.Mutex
+	// Outstanding channels to close to indicate events all received
+	waitEvents []chan struct{}
 }
 
 // Filesystem node types
@@ -489,9 +493,61 @@ func (m *Mega) Login(email string, passwd string) error {
 		return err
 	}
 
+	waitEvent := m.WaitEventsStart()
+
 	err = m.getFileSystem()
+	if err != nil {
+		return err
+	}
 
-	return err
+	// Wait until the all the pending events have been received
+	m.WaitEvents(waitEvent, 5*time.Second)
+
+	return nil
+}
+
+// WaitEventsStart - call this before you do the action which might
+// generate events then use the returned channel as a parameter to
+// WaitEvents to wait for the event(s) to be received.
+func (m *Mega) WaitEventsStart() <-chan struct{} {
+	ch := make(chan struct{})
+	m.waitEventsMu.Lock()
+	m.waitEvents = append(m.waitEvents, ch)
+	m.waitEventsMu.Unlock()
+	return ch
+}
+
+// WaitEvents waits for all outstanding events to be received for a
+// maximum of duration.  eventChan should be a channel as returned
+// from WaitEventStart.
+//
+// If the timeout elapsed then it returns true otherwise false.
+func (m *Mega) WaitEvents(eventChan <-chan struct{}, duration time.Duration) (timedout bool) {
+	m.debugf("Waiting for events to be finished for %v", duration)
+	timer := time.NewTimer(duration)
+	select {
+	case <-eventChan:
+		m.debugf("Events received")
+		timedout = false
+	case <-timer.C:
+		m.debugf("Timeout waiting for events")
+		timedout = true
+	}
+	timer.Stop()
+	return timedout
+}
+
+// waitEventsFire - fire the wait event
+func (m *Mega) waitEventsFire() {
+	m.waitEventsMu.Lock()
+	if len(m.waitEvents) > 0 {
+		m.debugf("Signalling events received")
+		for _, ch := range m.waitEvents {
+			close(ch)
+		}
+		m.waitEvents = nil
+	}
+	m.waitEventsMu.Unlock()
 }
 
 // Get user information
@@ -1616,6 +1672,7 @@ func (m *Mega) pollEvents() {
 		// if wait URL is set, then fetch it and continue - we
 		// don't expect anything else if we have a wait URL.
 		if events.W != "" {
+			m.waitEventsFire()
 			if len(events.E) > 0 {
 				m.logf("pollEvents: Unexpected event with w set: %s", buf)
 			}
diff --git a/vendor/github.com/t3rm1n4l/go-mega/mega_test.go b/vendor/github.com/t3rm1n4l/go-mega/mega_test.go
index 285b95fef..30a55563f 100644
--- a/vendor/github.com/t3rm1n4l/go-mega/mega_test.go
+++ b/vendor/github.com/t3rm1n4l/go-mega/mega_test.go
@@ -7,6 +7,7 @@ import (
 	"io/ioutil"
 	"os"
 	"path"
+	"sync"
 	"testing"
 	"time"
 )
@@ -360,3 +361,43 @@ func TestExportLink(t *testing.T) {
 		return err
 	})
 }
+
+func TestWaitEvents(t *testing.T) {
+	m := &Mega{}
+	m.SetLogger(t.Logf)
+	m.SetDebugger(t.Logf)
+	var wg sync.WaitGroup
+	// in the background fire the event timer after 100mS
+	wg.Add(1)
+	go func() {
+		time.Sleep(100 * time.Millisecond)
+		m.waitEventsFire()
+		wg.Done()
+	}()
+	wait := func(d time.Duration, pb *bool) {
+		e := m.WaitEventsStart()
+		*pb = m.WaitEvents(e, d)
+		wg.Done()
+	}
+	// wait for each event in a separate goroutine
+	var b1, b2, b3 bool
+	wg.Add(3)
+	go wait(10*time.Second, &b1)
+	go wait(2*time.Second, &b2)
+	go wait(1*time.Millisecond, &b3)
+	wg.Wait()
+	if b1 != false {
+		t.Errorf("Unexpected timeout for b1")
+	}
+	if b2 != false {
+		t.Errorf("Unexpected timeout for b2")
+	}
+	if b3 != true {
+		t.Errorf("Unexpected event for b3")
+	}
+	if m.waitEvents != nil {
+		t.Errorf("Expecting waitEvents to be empty")
+	}
+	// Check nothing happens if we fire the event with no listeners
+	m.waitEventsFire()
+}
