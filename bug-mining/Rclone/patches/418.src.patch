diff --git a/fs/filter/filter.go b/fs/filter/filter.go
index 78a6b4058..9a9f79994 100644
--- a/fs/filter/filter.go
+++ b/fs/filter/filter.go
@@ -92,12 +92,10 @@ type Opt struct {
 	MaxSize        fs.SizeSuffix
 }
 
-const unusedAge = fs.Duration((1 << 63) - 1)
-
 // DefaultOpt is the default config for the filter
 var DefaultOpt = Opt{
-	MinAge:  unusedAge,
-	MaxAge:  unusedAge,
+	MinAge:  fs.DurationOff,
+	MaxAge:  fs.DurationOff,
 	MinSize: fs.SizeSuffix(-1),
 	MaxSize: fs.SizeSuffix(-1),
 }
@@ -126,11 +124,11 @@ func NewFilter(opt *Opt) (f *Filter, err error) {
 	}
 
 	// Filter flags
-	if f.Opt.MinAge != unusedAge {
+	if f.Opt.MinAge.IsSet() {
 		f.ModTimeTo = time.Now().Add(-time.Duration(f.Opt.MinAge))
 		fs.Debugf(nil, "--min-age %v to %v", f.Opt.MinAge, f.ModTimeTo)
 	}
-	if f.Opt.MaxAge != unusedAge {
+	if f.Opt.MaxAge.IsSet() {
 		f.ModTimeFrom = time.Now().Add(-time.Duration(f.Opt.MaxAge))
 		if !f.ModTimeTo.IsZero() && f.ModTimeFrom.Before(f.ModTimeTo) {
 			log.Fatal("filter: --min-age can't be larger than --max-age")
diff --git a/fs/parseduration.go b/fs/parseduration.go
index 679cb0921..4df6fb6d9 100644
--- a/fs/parseduration.go
+++ b/fs/parseduration.go
@@ -9,11 +9,22 @@ import (
 // Duration is a time.Duration with some more parsing options
 type Duration time.Duration
 
+// DurationOff is the default value for flags which can be turned off
+const DurationOff = Duration((1 << 63) - 1)
+
 // Turn Duration into a string
 func (d Duration) String() string {
+	if d == DurationOff {
+		return "off"
+	}
 	return time.Duration(d).String()
 }
 
+// IsSet returns if the duration is != DurationOff
+func (d Duration) IsSet() bool {
+	return d != DurationOff
+}
+
 // We use time conventions
 var ageSuffixes = []struct {
 	Suffix     string
@@ -36,6 +47,10 @@ var ageSuffixes = []struct {
 func ParseDuration(age string) (time.Duration, error) {
 	var period float64
 
+	if age == "off" {
+		return time.Duration(DurationOff), nil
+	}
+
 	for _, ageSuffix := range ageSuffixes {
 		if strings.HasSuffix(age, ageSuffix.Suffix) {
 			numberString := age[:len(age)-len(ageSuffix.Suffix)]
@@ -64,5 +79,5 @@ func (d *Duration) Set(s string) error {
 
 // Type of the value
 func (d Duration) Type() string {
-	return "time.Duration"
+	return "duration"
 }
diff --git a/fs/parseduration_test.go b/fs/parseduration_test.go
index 7c9d7240b..fa32b0c67 100644
--- a/fs/parseduration_test.go
+++ b/fs/parseduration_test.go
@@ -15,23 +15,24 @@ var _ pflag.Value = (*Duration)(nil)
 func TestParseDuration(t *testing.T) {
 	for _, test := range []struct {
 		in   string
-		want float64
+		want time.Duration
 		err  bool
 	}{
 		{"0", 0, false},
 		{"", 0, true},
-		{"1ms", float64(time.Millisecond), false},
-		{"1s", float64(time.Second), false},
-		{"1m", float64(time.Minute), false},
-		{"1h", float64(time.Hour), false},
-		{"1d", float64(time.Hour) * 24, false},
-		{"1w", float64(time.Hour) * 24 * 7, false},
-		{"1M", float64(time.Hour) * 24 * 30, false},
-		{"1y", float64(time.Hour) * 24 * 365, false},
-		{"1.5y", float64(time.Hour) * 24 * 365 * 1.5, false},
-		{"-1s", -float64(time.Second), false},
-		{"1.s", float64(time.Second), false},
+		{"1ms", time.Millisecond, false},
+		{"1s", time.Second, false},
+		{"1m", time.Minute, false},
+		{"1h", time.Hour, false},
+		{"1d", time.Hour * 24, false},
+		{"1w", time.Hour * 24 * 7, false},
+		{"1M", time.Hour * 24 * 30, false},
+		{"1y", time.Hour * 24 * 365, false},
+		{"1.5y", time.Hour * 24 * 365 * 3 / 2, false},
+		{"-1s", -time.Second, false},
+		{"1.s", time.Second, false},
 		{"1x", 0, true},
+		{"off", time.Duration(DurationOff), false},
 	} {
 		duration, err := ParseDuration(test.in)
 		if test.err {
@@ -39,6 +40,21 @@ func TestParseDuration(t *testing.T) {
 		} else {
 			require.NoError(t, err)
 		}
-		assert.Equal(t, test.want, float64(duration))
+		assert.Equal(t, test.want, duration)
+	}
+}
+
+func TestDurationString(t *testing.T) {
+	for _, test := range []struct {
+		in   time.Duration
+		want string
+	}{
+		// {time.Duration(0), "0s"}, doesn't work on go1.6
+		{time.Second, "1s"},
+		{time.Minute, "1m0s"},
+		{time.Duration(DurationOff), "off"},
+	} {
+		got := Duration(test.in).String()
+		assert.Equal(t, test.want, got)
 	}
 }
