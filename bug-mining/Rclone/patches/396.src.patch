diff --git a/cmd/cmd.go b/cmd/cmd.go
index 481cc93ee..b9c564035 100644
--- a/cmd/cmd.go
+++ b/cmd/cmd.go
@@ -179,8 +179,6 @@ func newFsSrc(remote string) (fs.Fs, string) {
 			fs.CountError(err)
 			log.Fatalf("Failed to limit to single file %q: %v", remote, err)
 		}
-		// Set --no-traverse as only one file
-		fs.Config.NoTraverse = true
 	}
 	return f, fileName
 }
diff --git a/cmd/copy/copy.go b/cmd/copy/copy.go
index a1c59c4f1..5b928668f 100644
--- a/cmd/copy/copy.go
+++ b/cmd/copy/copy.go
@@ -49,9 +49,6 @@ If you are familiar with ` + "`rsync`" + `, rclone always works as if you had
 written a trailing / - meaning "copy the contents of this directory".
 This applies to all commands and whether you are talking about the
 source or destination.
-
-See the ` + "`--no-traverse`" + ` option for controlling whether rclone lists
-the destination directory or not.
 `,
 	Run: func(command *cobra.Command, args []string) {
 		cmd.CheckArgs(2, 2, command, args)
diff --git a/docs/content/docs.md b/docs/content/docs.md
index c979fe2e6..e945224b9 100644
--- a/docs/content/docs.md
+++ b/docs/content/docs.md
@@ -118,7 +118,7 @@ The file `test.jpg` will be placed inside `/tmp/download`.
 
 This is equivalent to specifying
 
-    rclone copy --no-traverse --files-from /tmp/files remote: /tmp/download
+    rclone copy --files-from /tmp/files remote: /tmp/download
 
 Where `/tmp/files` contains the single line
 
@@ -691,8 +691,8 @@ If the destination does not support server-side copy or move, rclone
 will fall back to the default behaviour and log an error level message
 to the console.
 
-Note that `--track-renames` is incompatible with `--no-traverse` and
-that it uses extra memory to keep track of all the rename candidates.
+Note that `--track-renames` uses extra memory to keep track of all
+the rename candidates.
 
 Note also that `--track-renames` is incompatible with
 `--delete-before` and will select `--delete-after` instead of
@@ -957,26 +957,6 @@ This option defaults to `false`.
 
 **This should be used only for testing.**
 
-### --no-traverse ###
-
-The `--no-traverse` flag controls whether the destination file system
-is traversed when using the `copy` or `move` commands.
-`--no-traverse` is not compatible with `sync` and will be ignored if
-you supply it with `sync`.
-
-If you are only copying a small number of files and/or have a large
-number of files on the destination then `--no-traverse` will stop
-rclone listing the destination and save time.
-
-However, if you are copying a large number of files, especially if you
-are doing a copy where lots of the files haven't changed and won't
-need copying then you shouldn't use `--no-traverse`.
-
-It can also be used to reduce the memory usage of rclone when copying
-- `rclone --no-traverse copy src dst` won't load either the source or
-destination listings into memory so will use the minimum amount of
-memory.
-
 Filtering
 ---------
 
diff --git a/fs/config.go b/fs/config.go
index 330110e05..48aff8651 100644
--- a/fs/config.go
+++ b/fs/config.go
@@ -48,7 +48,6 @@ type ConfigInfo struct {
 	MaxDepth              int
 	IgnoreSize            bool
 	IgnoreChecksum        bool
-	NoTraverse            bool
 	NoUpdateModTime       bool
 	DataRateUnit          string
 	BackupDir             string
diff --git a/fs/config/configflags/configflags.go b/fs/config/configflags/configflags.go
index 4f6e6993b..6ddddf497 100644
--- a/fs/config/configflags/configflags.go
+++ b/fs/config/configflags/configflags.go
@@ -26,6 +26,7 @@ var (
 	deleteAfter     bool
 	bindAddr        string
 	disableFeatures string
+	noTraverse      bool
 )
 
 // AddFlags adds the non filing system specific flags to the command
@@ -59,7 +60,7 @@ func AddFlags(flagSet *pflag.FlagSet) {
 	flags.IntVarP(flagSet, &fs.Config.MaxDepth, "max-depth", "", fs.Config.MaxDepth, "If set limits the recursion depth to this.")
 	flags.BoolVarP(flagSet, &fs.Config.IgnoreSize, "ignore-size", "", false, "Ignore size when skipping use mod-time or checksum.")
 	flags.BoolVarP(flagSet, &fs.Config.IgnoreChecksum, "ignore-checksum", "", fs.Config.IgnoreChecksum, "Skip post copy check of checksums.")
-	flags.BoolVarP(flagSet, &fs.Config.NoTraverse, "no-traverse", "", fs.Config.NoTraverse, "Don't traverse destination file system on copy.")
+	flags.BoolVarP(flagSet, &noTraverse, "no-traverse", "", noTraverse, "Obsolete - does nothing.")
 	flags.BoolVarP(flagSet, &fs.Config.NoUpdateModTime, "no-update-modtime", "", fs.Config.NoUpdateModTime, "Don't update destination mod-time if files identical.")
 	flags.StringVarP(flagSet, &fs.Config.BackupDir, "backup-dir", "", fs.Config.BackupDir, "Make backups into hierarchy based in DIR.")
 	flags.StringVarP(flagSet, &fs.Config.Suffix, "suffix", "", fs.Config.Suffix, "Suffix for use with --backup-dir.")
@@ -105,13 +106,17 @@ func SetFlags() {
 		}
 	}
 
+	if noTraverse {
+		fs.Logf(nil, "--no-traverse is obsolete and no longer needed - please remove")
+	}
+
 	if dumpHeaders {
 		fs.Config.Dump |= fs.DumpHeaders
-		fs.Infof(nil, "--dump-headers is obsolete - please use --dump headers instead")
+		fs.Logf(nil, "--dump-headers is obsolete - please use --dump headers instead")
 	}
 	if dumpBodies {
 		fs.Config.Dump |= fs.DumpBodies
-		fs.Infof(nil, "--dump-bodies is obsolete - please use --dump bodies instead")
+		fs.Logf(nil, "--dump-bodies is obsolete - please use --dump bodies instead")
 	}
 
 	switch {
diff --git a/fs/sync/sync.go b/fs/sync/sync.go
index 66d84c6c6..c91f6f701 100644
--- a/fs/sync/sync.go
+++ b/fs/sync/sync.go
@@ -28,7 +28,6 @@ type syncCopyMove struct {
 	// internal state
 	ctx            context.Context        // internal context for controlling go-routines
 	cancel         func()                 // cancel the context
-	noTraverse     bool                   // if set don't trafevers the dst
 	deletersWg     sync.WaitGroup         // for delete before go routine
 	deleteFilesCh  chan fs.Object         // channel to receive deletes if delete before
 	trackRenames   bool                   // set if we should do server side renames
@@ -73,7 +72,6 @@ func newSyncCopyMove(fdst, fsrc fs.Fs, deleteMode fs.DeleteMode, DoMove bool, de
 		srcFilesChan:       make(chan fs.Object, fs.Config.Checkers+fs.Config.Transfers),
 		srcFilesResult:     make(chan error, 1),
 		dstFilesResult:     make(chan error, 1),
-		noTraverse:         fs.Config.NoTraverse,
 		toBeChecked:        make(fs.ObjectPairChan, fs.Config.Transfers),
 		toBeUploaded:       make(fs.ObjectPairChan, fs.Config.Transfers),
 		deleteFilesCh:      make(chan fs.Object, fs.Config.Checkers),
@@ -83,10 +81,6 @@ func newSyncCopyMove(fdst, fsrc fs.Fs, deleteMode fs.DeleteMode, DoMove bool, de
 		trackRenamesCh:     make(chan fs.Object, fs.Config.Checkers),
 	}
 	s.ctx, s.cancel = context.WithCancel(context.Background())
-	if s.noTraverse && s.deleteMode != fs.DeleteModeOff {
-		fs.Errorf(nil, "Ignoring --no-traverse with sync")
-		s.noTraverse = false
-	}
 	if s.trackRenames {
 		// Don't track renames for remotes without server-side move support.
 		if !operations.CanServerSideMove(fdst) {
@@ -103,10 +97,6 @@ func newSyncCopyMove(fdst, fsrc fs.Fs, deleteMode fs.DeleteMode, DoMove bool, de
 		if s.deleteMode != fs.DeleteModeOff {
 			s.deleteMode = fs.DeleteModeAfter
 		}
-		if s.noTraverse {
-			fs.Errorf(nil, "Ignoring --no-traverse with --track-renames")
-			s.noTraverse = false
-		}
 	}
 	// Make Fs for --backup-dir if required
 	if fs.Config.BackupDir != "" {
diff --git a/fs/sync/sync_test.go b/fs/sync/sync_test.go
index 354fd9453..f0d007018 100644
--- a/fs/sync/sync_test.go
+++ b/fs/sync/sync_test.go
@@ -61,41 +61,6 @@ func TestCopy(t *testing.T) {
 	fstest.CheckItems(t, r.Fremote, file1)
 }
 
-// Now with --no-traverse
-func TestCopyNoTraverse(t *testing.T) {
-	r := fstest.NewRun(t)
-	defer r.Finalise()
-
-	fs.Config.NoTraverse = true
-	defer func() { fs.Config.NoTraverse = false }()
-
-	file1 := r.WriteFile("sub dir/hello world", "hello world", t1)
-
-	err := CopyDir(r.Fremote, r.Flocal)
-	require.NoError(t, err)
-
-	fstest.CheckItems(t, r.Flocal, file1)
-	fstest.CheckItems(t, r.Fremote, file1)
-}
-
-// Now with --no-traverse
-func TestSyncNoTraverse(t *testing.T) {
-	r := fstest.NewRun(t)
-	defer r.Finalise()
-
-	fs.Config.NoTraverse = true
-	defer func() { fs.Config.NoTraverse = false }()
-
-	file1 := r.WriteFile("sub dir/hello world", "hello world", t1)
-
-	accounting.Stats.ResetCounters()
-	err := Sync(r.Fremote, r.Flocal)
-	require.NoError(t, err)
-
-	fstest.CheckItems(t, r.Flocal, file1)
-	fstest.CheckItems(t, r.Fremote, file1)
-}
-
 // Test copy with depth
 func TestCopyWithDepth(t *testing.T) {
 	r := fstest.NewRun(t)
