diff --git a/cmd/mount/dir.go b/cmd/mount/dir.go
index e5c47e5d9..29535f637 100644
--- a/cmd/mount/dir.go
+++ b/cmd/mount/dir.go
@@ -78,7 +78,7 @@ func (d *Dir) readDir() error {
 		}
 		fs.Debugf(d.path, "Re-reading directory (%v old)", age)
 	}
-	objs, dirs, err := fs.NewLister().SetLevel(1).Start(d.f, d.path).GetAll()
+	entries, err := fs.ListDirSorted(d.f, false, d.path)
 	if err == fs.ErrorDirNotFound {
 		// We treat directory not found as empty because we
 		// create directories on the fly
@@ -93,26 +93,34 @@ func (d *Dir) readDir() error {
 	oldItems := d.items
 
 	// Cache the items by name
-	d.items = make(map[string]*DirEntry, len(objs)+len(dirs))
-	for _, obj := range objs {
-		name := path.Base(obj.Remote())
-		d.items[name] = &DirEntry{
-			o:    obj,
-			node: nil,
-		}
-	}
-	for _, dir := range dirs {
-		name := path.Base(dir.Remote())
-		// Use old dir value if it exists
-		if oldItem, ok := oldItems[name]; ok {
-			if _, ok := oldItem.o.(*fs.Dir); ok {
-				d.items[name] = oldItem
-				continue
+	d.items = make(map[string]*DirEntry, len(entries))
+	for _, entry := range entries {
+		switch item := entry.(type) {
+		case fs.Object:
+			obj := item
+			name := path.Base(obj.Remote())
+			d.items[name] = &DirEntry{
+				o:    obj,
+				node: nil,
 			}
-		}
-		d.items[name] = &DirEntry{
-			o:    dir,
-			node: nil,
+		case *fs.Dir:
+			dir := item
+			name := path.Base(dir.Remote())
+			// Use old dir value if it exists
+			if oldItem, ok := oldItems[name]; ok {
+				if _, ok := oldItem.o.(*fs.Dir); ok {
+					d.items[name] = oldItem
+					continue
+				}
+			}
+			d.items[name] = &DirEntry{
+				o:    dir,
+				node: nil,
+			}
+		default:
+			err = errors.Errorf("unknown type %T", item)
+			fs.Errorf(d.path, "readDir error: %v", err)
+			return err
 		}
 	}
 	d.read = when
diff --git a/cmd/mount/mount.go b/cmd/mount/mount.go
index f68207ff9..a8496f7a8 100644
--- a/cmd/mount/mount.go
+++ b/cmd/mount/mount.go
@@ -114,6 +114,11 @@ can't use retries in the same way without making local copies of the
 uploads.  This might happen in the future, but for the moment rclone
 mount won't do that, so will be less reliable than the rclone command.
 
+### Filters ###
+
+Note that all the rclone filters can be used to select a subset of the
+files to be visible in the mount.
+
 ### Bugs ###
 
   * All the remotes should work for read, but some may not for write
diff --git a/fs/operations.go b/fs/operations.go
index 60695b85f..c3d5fdcfd 100644
--- a/fs/operations.go
+++ b/fs/operations.go
@@ -530,8 +530,6 @@ func (ds DirEntries) Less(i, j int) bool {
 	return ds[i].Remote() < ds[j].Remote()
 }
 
-// FIXME can use this in Mount
-
 // ListDirSorted reads Object and *Dir into entries for the given Fs.
 //
 // dir is the start directory, "" for root
