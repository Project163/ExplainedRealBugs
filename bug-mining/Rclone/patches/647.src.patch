diff --git a/fs/operations/multithread.go b/fs/operations/multithread.go
index 211b32102..56d7677ab 100644
--- a/fs/operations/multithread.go
+++ b/fs/operations/multithread.go
@@ -122,9 +122,9 @@ func multiThreadCopy(ctx context.Context, f fs.Fs, remote string, src fs.Object,
 		return nil, errors.New("multi-thread copy: can't copy zero sized file")
 	}
 
-	g, ctx := errgroup.WithContext(context.Background())
+	g, gCtx := errgroup.WithContext(ctx)
 	mc := &multiThreadCopyState{
-		ctx:     ctx,
+		ctx:     gCtx,
 		size:    src.Size(),
 		src:     src,
 		streams: streams,
@@ -136,7 +136,7 @@ func multiThreadCopy(ctx context.Context, f fs.Fs, remote string, src fs.Object,
 	defer fs.CheckClose(mc.acc, &err)
 
 	// create write file handle
-	mc.wc, err = openWriterAt(ctx, remote, mc.size)
+	mc.wc, err = openWriterAt(gCtx, remote, mc.size)
 	if err != nil {
 		return nil, errors.Wrap(err, "multpart copy: failed to open destination")
 	}
@@ -146,7 +146,7 @@ func multiThreadCopy(ctx context.Context, f fs.Fs, remote string, src fs.Object,
 	for stream := 0; stream < mc.streams; stream++ {
 		stream := stream
 		g.Go(func() (err error) {
-			return mc.copyStream(ctx, stream)
+			return mc.copyStream(gCtx, stream)
 		})
 	}
 	err = g.Wait()
diff --git a/fs/operations/operations.go b/fs/operations/operations.go
index 1fc63561b..107a8b2b8 100644
--- a/fs/operations/operations.go
+++ b/fs/operations/operations.go
@@ -1818,18 +1818,18 @@ func DirMove(ctx context.Context, f fs.Fs, srcRemote, dstRemote string) (err err
 		newPath string
 	}
 	renames := make(chan rename, fs.Config.Transfers)
-	g, ctx := errgroup.WithContext(context.Background())
+	g, gCtx := errgroup.WithContext(context.Background())
 	for i := 0; i < fs.Config.Transfers; i++ {
 		g.Go(func() error {
 			for job := range renames {
-				dstOverwritten, _ := f.NewObject(ctx, job.newPath)
-				_, err := Move(ctx, f, dstOverwritten, job.newPath, job.o)
+				dstOverwritten, _ := f.NewObject(gCtx, job.newPath)
+				_, err := Move(gCtx, f, dstOverwritten, job.newPath, job.o)
 				if err != nil {
 					return err
 				}
 				select {
-				case <-ctx.Done():
-					return ctx.Err()
+				case <-gCtx.Done():
+					return gCtx.Err()
 				default:
 				}
 
