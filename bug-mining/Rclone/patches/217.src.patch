diff --git a/docs/content/crypt.md b/docs/content/crypt.md
index a2dc5a481..1901d3bd2 100644
--- a/docs/content/crypt.md
+++ b/docs/content/crypt.md
@@ -99,8 +99,8 @@ Remote config
 [secret]
 remote = remote:path
 filename_encryption = standard
-password = CfDxopZIXFG0Oo-ac7dPLWWOHkNJbw
-password2 = HYUpfuzHJL8qnX9fOaIYijq0xnVLwyVzp3y4SF3TwYqAU6HLysk
+password = *** ENCRYPTED ***
+password2 = *** ENCRYPTED ***
 --------------------
 y) Yes this is OK
 e) Edit this remote
diff --git a/fs/config.go b/fs/config.go
index 36feb96de..5d9610813 100644
--- a/fs/config.go
+++ b/fs/config.go
@@ -752,8 +752,21 @@ func ChooseNumber(what string, min, max int) int {
 func ShowRemote(name string) {
 	fmt.Printf("--------------------\n")
 	fmt.Printf("[%s]\n", name)
+	fs := MustFindByName(name)
 	for _, key := range ConfigFile.GetKeyList(name) {
-		fmt.Printf("%s = %s\n", key, ConfigFile.MustValue(name, key))
+		isPassword := false
+		for _, option := range fs.Options {
+			if option.Name == key && option.IsPassword {
+				isPassword = true
+				break
+			}
+		}
+		value := ConfigFile.MustValue(name, key)
+		if isPassword && value != "" {
+			fmt.Printf("%s = *** ENCRYPTED ***\n", key)
+		} else {
+			fmt.Printf("%s = %s\n", key, value)
+		}
 	}
 	fmt.Printf("--------------------\n")
 }
@@ -775,17 +788,20 @@ func OkRemote(name string) bool {
 	return false
 }
 
+// MustFindByName finds the RegInfo for the remote name passed in or
+// exits with a fatal error.
+func MustFindByName(name string) *RegInfo {
+	fsType := ConfigFile.MustValue(name, "type")
+	if fsType == "" {
+		log.Fatalf("Couldn't find type of fs for %q", name)
+	}
+	return MustFind(fsType)
+}
+
 // RemoteConfig runs the config helper for the remote if needed
 func RemoteConfig(name string) {
 	fmt.Printf("Remote config\n")
-	fsName := ConfigFile.MustValue(name, "type")
-	if fsName == "" {
-		log.Fatalf("Couldn't find type of fs for %q", name)
-	}
-	f, err := Find(fsName)
-	if err != nil {
-		log.Fatalf("Didn't find filing system: %v", err)
-	}
+	f := MustFindByName(name)
 	if f.Config != nil {
 		f.Config(name)
 	}
@@ -864,10 +880,7 @@ func fsOption() *Option {
 func NewRemote(name string) {
 	newType := ChooseOption(fsOption())
 	ConfigFile.SetValue(name, "type", newType)
-	fs, err := Find(newType)
-	if err != nil {
-		log.Fatalf("Failed to find fs: %v", err)
-	}
+	fs := MustFind(newType)
 	for _, option := range fs.Options {
 		ConfigFile.SetValue(name, option.Name, ChooseOption(&option))
 	}
@@ -924,10 +937,7 @@ func EditConfig() {
 		switch i := Command(what); i {
 		case 'e':
 			name := ChooseRemote()
-			fs, err := Find(ConfigFile.MustValue(name, "type"))
-			if err != nil {
-				log.Fatalf("Failed to find fs: %v", err)
-			}
+			fs := MustFindByName(name)
 			EditRemote(fs, name)
 		case 'n':
 		nameLoop:
@@ -1010,11 +1020,7 @@ func Authorize(args []string) {
 		log.Fatalf("Invalid number of arguments: %d", len(args))
 	}
 	newType := args[0]
-	fs, err := Find(newType)
-	if err != nil {
-		log.Fatalf("Failed to find fs: %v", err)
-	}
-
+	fs := MustFind(newType)
 	if fs.Config == nil {
 		log.Fatalf("Can't authorize fs %q", newType)
 	}
diff --git a/fs/fs.go b/fs/fs.go
index 2b5fa055d..48840b90c 100644
--- a/fs/fs.go
+++ b/fs/fs.go
@@ -394,6 +394,19 @@ func Find(name string) (*RegInfo, error) {
 	return nil, errors.Errorf("didn't find filing system for %q", name)
 }
 
+// MustFind looks for an Info object for the type name passed in
+//
+// Services are looked up in the config file
+//
+// Exits with a fatal error if not found
+func MustFind(name string) *RegInfo {
+	fs, err := Find(name)
+	if err != nil {
+		log.Fatalf("Failed to find remote: %v", err)
+	}
+	return fs
+}
+
 // Pattern to match an rclone url
 var matcher = regexp.MustCompile(`^([\w_ -]+):(.*)$`)
 
