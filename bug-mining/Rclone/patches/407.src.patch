diff --git a/vfs/write.go b/vfs/write.go
index d212cfcda..99777a88f 100644
--- a/vfs/write.go
+++ b/vfs/write.go
@@ -231,9 +231,9 @@ func (fh *WriteFileHandle) Flush() error {
 	// If Write hasn't been called then ignore the Flush - Release
 	// will pick it up
 	if !fh.writeCalled {
-		fs.Debugf(fh.remote, "WriteFileHandle.Flush ignoring flush on unwritten handle")
-		return nil
-
+		fs.Debugf(fh.remote, "WriteFileHandle.Flush unwritten handle, writing 0 bytes to avoid race conditions")
+		_, err := fh.writeAt([]byte{}, fh.offset)
+		return err
 	}
 	err := fh.close()
 	if err != nil {
diff --git a/vfs/write_test.go b/vfs/write_test.go
index 883fe15b1..6acc1ecce 100644
--- a/vfs/write_test.go
+++ b/vfs/write_test.go
@@ -168,12 +168,15 @@ func TestWriteFileHandleWriteAt(t *testing.T) {
 func TestWriteFileHandleFlush(t *testing.T) {
 	r := fstest.NewRun(t)
 	defer r.Finalise()
-	_, fh := writeHandleCreate(t, r)
+	vfs, fh := writeHandleCreate(t, r)
 
-	// Check Flush does nothing if write not called
+	// Check Flush already creates file for unwritten handles, without closing it
 	err := fh.Flush()
 	assert.NoError(t, err)
 	assert.False(t, fh.closed)
+	root, err := vfs.Root()
+	assert.NoError(t, err)
+	checkListing(t, root, []string{"file1,0,false"})
 
 	// Write some data
 	n, err := fh.Write([]byte("hello"))
@@ -189,6 +192,11 @@ func TestWriteFileHandleFlush(t *testing.T) {
 	err = fh.Flush()
 	assert.NoError(t, err)
 	assert.True(t, fh.closed)
+
+	// Check file was written properly
+	root, err = vfs.Root()
+	assert.NoError(t, err)
+	checkListing(t, root, []string{"file1,5,false"})
 }
 
 func TestWriteFileHandleRelease(t *testing.T) {
