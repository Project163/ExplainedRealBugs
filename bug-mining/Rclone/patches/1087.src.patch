diff --git a/cmd/serve/dlna/dlna.go b/cmd/serve/dlna/dlna.go
index 0c9d2fbca..fc802226c 100644
--- a/cmd/serve/dlna/dlna.go
+++ b/cmd/serve/dlna/dlna.go
@@ -186,7 +186,7 @@ func (s *server) rootDescHandler(w http.ResponseWriter, r *http.Request) {
 // Handle a service control HTTP request.
 func (s *server) serviceControlHandler(w http.ResponseWriter, r *http.Request) {
 	soapActionString := r.Header.Get("SOAPACTION")
-	soapAction, err := parseActionHTTPHeader(soapActionString)
+	soapAction, err := upnp.ParseActionHTTPHeader(soapActionString)
 	if err != nil {
 		serveError(s, w, "Could not parse SOAPACTION header", err)
 		return
diff --git a/cmd/serve/dlna/dlna_test.go b/cmd/serve/dlna/dlna_test.go
index acc1d0ffe..8327ee054 100644
--- a/cmd/serve/dlna/dlna_test.go
+++ b/cmd/serve/dlna/dlna_test.go
@@ -119,6 +119,8 @@ func TestContentDirectoryBrowseMetadata(t *testing.T) {
 	assert.Equal(t, http.StatusOK, resp.StatusCode)
 	body, err := ioutil.ReadAll(resp.Body)
 	require.NoError(t, err)
+	// should contain an appropriate URN
+	require.Contains(t, string(body), "urn:schemas-upnp-org:service:ContentDirectory:1")
 	// expect a <container> element
 	require.Contains(t, string(body), html.EscapeString("<container "))
 	require.NotContains(t, string(body), html.EscapeString("<item "))
diff --git a/cmd/serve/dlna/dlna_util.go b/cmd/serve/dlna/dlna_util.go
index cde43d693..ad961e067 100644
--- a/cmd/serve/dlna/dlna_util.go
+++ b/cmd/serve/dlna/dlna_util.go
@@ -3,7 +3,6 @@ package dlna
 import (
 	"crypto/md5"
 	"encoding/xml"
-	"errors"
 	"fmt"
 	"io"
 	"log"
@@ -12,9 +11,6 @@ import (
 	"net/http/httptest"
 	"net/http/httputil"
 	"os"
-	"regexp"
-	"strconv"
-	"strings"
 
 	"github.com/anacrolix/dms/soap"
 	"github.com/anacrolix/dms/upnp"
@@ -89,36 +85,6 @@ func marshalSOAPResponse(sa upnp.SoapAction, args map[string]string) []byte {
 		sa.Action, sa.ServiceURN.String(), mustMarshalXML(soapArgs)))
 }
 
-var serviceURNRegexp = regexp.MustCompile(`:service:(\w+):(\d+)$`)
-
-func parseServiceType(s string) (ret upnp.ServiceURN, err error) {
-	matches := serviceURNRegexp.FindStringSubmatch(s)
-	if matches == nil {
-		err = errors.New(s)
-		return
-	}
-	if len(matches) != 3 {
-		log.Panicf("Invalid serviceURNRegexp ?")
-	}
-	ret.Type = matches[1]
-	ret.Version, err = strconv.ParseUint(matches[2], 0, 0)
-	return
-}
-
-func parseActionHTTPHeader(s string) (ret upnp.SoapAction, err error) {
-	if s[0] != '"' || s[len(s)-1] != '"' {
-		return
-	}
-	s = s[1 : len(s)-1]
-	hashIndex := strings.LastIndex(s, "#")
-	if hashIndex == -1 {
-		return
-	}
-	ret.Action = s[hashIndex+1:]
-	ret.ServiceURN, err = parseServiceType(s[:hashIndex])
-	return
-}
-
 type loggingResponseWriter struct {
 	http.ResponseWriter
 	request   *http.Request
