diff --git a/vfs/dir.go b/vfs/dir.go
index c45033d0e..2087dc638 100644
--- a/vfs/dir.go
+++ b/vfs/dir.go
@@ -325,10 +325,15 @@ func (d *Dir) renameTree(dirPath string) {
 		d.entry = fs.NewDirCopy(context.TODO(), d.entry).SetRemote(dirPath)
 	}
 
-	// Do the same to any child directories
+	// Do the same to any child directories and files
 	for leaf, node := range d.items {
-		if dir, ok := node.(*Dir); ok {
-			dir.renameTree(path.Join(dirPath, leaf))
+		switch x := node.(type) {
+		case *Dir:
+			x.renameTree(path.Join(dirPath, leaf))
+		case *File:
+			x.renameDir(dirPath)
+		default:
+			panic("bad dir entry")
 		}
 	}
 }
diff --git a/vfs/file.go b/vfs/file.go
index 5e5c74f97..44a4ebb88 100644
--- a/vfs/file.go
+++ b/vfs/file.go
@@ -141,6 +141,13 @@ func (f *File) Node() Node {
 	return f
 }
 
+// renameDir - call when parent directory has been renamed
+func (f *File) renameDir(dPath string) {
+	f.mu.RLock()
+	f.dPath = dPath
+	f.mu.RUnlock()
+}
+
 // applyPendingRename runs a previously set rename operation if there are no
 // more remaining writers. Call without lock held.
 func (f *File) applyPendingRename() {
