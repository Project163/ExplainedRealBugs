diff --git a/cmd/mount/read.go b/cmd/mount/read.go
index a8d119b1c..4da3989f7 100644
--- a/cmd/mount/read.go
+++ b/cmd/mount/read.go
@@ -116,17 +116,23 @@ func (fh *ReadFileHandle) Flush(ctx context.Context, req *fuse.FlushRequest) err
 	fh.mu.Lock()
 	defer fh.mu.Unlock()
 	fs.Debug(fh.o, "ReadFileHandle.Flush")
-	// If Read hasn't been called then ignore the Flush - Release
-	// will pick it up
-	if !fh.readCalled {
-		fs.Debug(fh.o, "ReadFileHandle.Flush ignoring flush on unread handle")
-		return nil
 
-	}
-	err := fh.close()
-	if err != nil {
-		fs.ErrorLog(fh.o, "ReadFileHandle.Flush error: %v", err)
-		return err
+	// Ignore the Flush as there is nothing we can sensibly do and
+	// it seems quite common for Flush to be called from
+	// different threads each of which have read some data.
+	if false {
+		// If Read hasn't been called then ignore the Flush - Release
+		// will pick it up
+		if !fh.readCalled {
+			fs.Debug(fh.o, "ReadFileHandle.Flush ignoring flush on unread handle")
+			return nil
+
+		}
+		err := fh.close()
+		if err != nil {
+			fs.ErrorLog(fh.o, "ReadFileHandle.Flush error: %v", err)
+			return err
+		}
 	}
 	fs.Debug(fh.o, "ReadFileHandle.Flush OK")
 	return nil
diff --git a/cmd/mount/read_test.go b/cmd/mount/read_test.go
index ba10f64f1..885d86435 100644
--- a/cmd/mount/read_test.go
+++ b/cmd/mount/read_test.go
@@ -72,9 +72,9 @@ func TestReadFileDoubleClose(t *testing.T) {
 	assert.NoError(t, err)
 	assert.Equal(t, 1, n)
 
-	// close the dup - should produce an error
+	// close the dup - should not produce an error
 	err = syscall.Close(fd2)
-	assert.Error(t, err, "input/output error")
+	assert.NoError(t, err, "input/output error")
 
 	run.rm(t, "testdoubleclose")
 }
