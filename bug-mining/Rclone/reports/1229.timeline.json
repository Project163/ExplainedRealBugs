[{"id":10453445980,"node_id":"MEE_lADOAQ-n5M5x1vV-zwAAAAJvEu1c","url":"https://api.github.com/repos/rclone/rclone/issues/events/10453445980","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"mentioned","commit_id":null,"commit_url":null,"created_at":"2023-09-23T15:42:19Z","performed_via_github_app":null},{"id":10453445981,"node_id":"SE_lADOAQ-n5M5x1vV-zwAAAAJvEu1d","url":"https://api.github.com/repos/rclone/rclone/issues/events/10453445981","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2023-09-23T15:42:19Z","performed_via_github_app":null},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732432644","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1732432644","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1732432644,"node_id":"IC_kwDOAQ-n5M5nQtME","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-23T23:32:56Z","updated_at":"2023-12-10T06:40:41Z","body":"Thank you for the benchmarks and feedback! You are right -- `bisync` is currently much slower than `copy` or `sync`. This is for a few reasons, most of which I think are solvable. My multi-step plan to address this includes:\r\n\r\n- [x] Apply filters correctly during deletes (fixed in `v1.64.0` https://github.com/rclone/rclone/pull/6971/commits/26ff813ff3bcf1755631f840e6b4464083a8d80d )\r\n- [x] Build and compare initial listings concurrently using March \r\nThis should help a lot. Currently, bisync builds a full listing for Path1, then a full listing for Path2, then compares them -- and each of those tasks must finish before the next one can start. That's silly, as we could easily be doing most of these tasks concurrently, using the same March infrastructure that `check` and `sync` use. This would also solve another important issue I talked about [here](https://forum.rclone.org/t/bisync-bugs-and-feature-requests/37636#:~:text=4.%20Listings%20should%20alternate%20between%20paths%20to%20minimize%20errors).\r\n- [x] Merge copies and deletes\r\nCurrently bisync makes its changes in a 4-step process:\r\n\r\n1. `copy` 2 to 1\r\n2. `copy` 1 to 2\r\n3.  `delete` 2 to 1\r\n4.  `delete` 1 to 2\r\n\r\nI believe we can condense this to just 2 steps:\r\n\r\n1. `sync` 2 to 1\r\n2. `sync` 1 to 2\r\n\r\nBoth syncs would be filtered for only the individual files that need to be copied or deleted in that direction. I already have a local proof-of-concept for this that works beautifully, so I think it should be coming relatively soon. Incidentally, this change also paves the way for [allowing bisync to support `--track-renames`](https://github.com/rclone/rclone/issues/5690) (which is supported only for `sync`, not `copy`.)\r\n\r\n- [x] Eliminate the second listing\r\nThis is probably the one that will make the most difference in terms of speed. Currently, if there are changes to sync, bisync lists each directory twice: once before the sync and once after. The second one causes [quite a lot of problems](https://github.com/rclone/rclone/issues/5676), in addition to making each run much slower. I am currently working on a way to eliminate it by getting the underlying sync operation to [report back a list of what it changed](https://github.com/rclone/rclone/issues/7282). This project is pretty far along, and the results are very encouraging so far! \r\n\r\nWhen all of the above are done, `bisync` will probably still be slightly slower than `sync` (because bisync has to do an extra listing, and 2 syncs instead of 1), but the difference should be much less dramatic than it is today. \r\n\r\nFor `bisync` to ever truly be as fast as `sync`, it would have to (at minimum) merge the two sync operations together (or at least do them concurrently), and also merge the initial listing into the sync operation (similar to how checkers and transfers currently work during a `sync` -- note how the transfers are able to start working before all the checkers have completed!) These particular optimizations are not currently planned, but I do think they might be possible someday. \r\n\r\nIn the meantime, one thing you might consider to speed up your runs slightly is `--check-sync=false`. `--check-sync` has some [issues](https://github.com/rclone/rclone/issues/7270) anyway at the moment, so in my opinion, you might be better off disabling it and replacing it with an occasional [check](https://rclone.org/bisync/#concurrent-modifications), until this is more properly fixed in a future release. Disabling it will make the run slightly faster, because it will skip the step of re-loading both listings into memory at the end and comparing them.\r\n\r\nThank you also for the kind words of encouragement! ðŸ˜ƒ ","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732432644/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":10454200658,"node_id":"LE_lADOAQ-n5M5x1vV-zwAAAAJvHnFS","url":"https://api.github.com/repos/rclone/rclone/issues/events/10454200658","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2023-09-23T23:33:44Z","label":{"name":"enhancement","color":"84b6eb"},"performed_via_github_app":null},{"id":10454200660,"node_id":"LE_lADOAQ-n5M5x1vV-zwAAAAJvHnFU","url":"https://api.github.com/repos/rclone/rclone/issues/events/10454200660","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2023-09-23T23:33:44Z","label":{"name":"concurrency","color":"9090e4"},"performed_via_github_app":null},{"id":10454200661,"node_id":"LE_lADOAQ-n5M5x1vV-zwAAAAJvHnFV","url":"https://api.github.com/repos/rclone/rclone/issues/events/10454200661","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2023-09-23T23:33:44Z","label":{"name":"bisync","color":"1D76DB"},"performed_via_github_app":null},{"id":10454201099,"node_id":"AE_lADOAQ-n5M5x1vV-zwAAAAJvHnML","url":"https://api.github.com/repos/rclone/rclone/issues/events/10454201099","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"assigned","commit_id":null,"commit_url":null,"created_at":"2023-09-23T23:34:09Z","assignee":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"performed_via_github_app":null},{"id":10454201889,"node_id":"MIE_lADOAQ-n5M5x1vV-zwAAAAJvHnYh","url":"https://api.github.com/repos/rclone/rclone/issues/events/10454201889","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"milestoned","commit_id":null,"commit_url":null,"created_at":"2023-09-23T23:34:59Z","milestone":{"title":"Soon"},"performed_via_github_app":null},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732584536","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1732584536","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1732584536,"node_id":"IC_kwDOAQ-n5M5nRSRY","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-24T14:23:12Z","updated_at":"2023-09-24T14:34:51Z","body":"This is awesome and sounds very promising! Thank you for the detailed response it was very useful as I'm sure for others stumbling across this.\r\n\r\nIn particular, implementing March and the secondary listing to bisync sounds very promising and can see the vast improvement of comparing the files in real-time over a delayed listing and further prevent this locking/corruption issue when there are changes made during sync. Also, as I understand this is one of the major issues left to bring bisync out of experimental?\r\n\r\nCan't wait to have this working! For now, I will also try with `--check-sync=false` as ultimately I plan on running this at regular intervals anyways.\r\n\r\nWould these changes also help with the following situation (perhaps this is not the best place to ask this or maybe a new issue or forum?):\r\n\r\nI have a systemd service that runs bisync on a timer/repeat. If I shutdown my computer and bisync is running it would require a full resync as pressing Ctrl+C would do when running in terminal (as far as I can tell - or at least seems to be this way from my tests?). I haven't had any luck using `--resilient` in this case either. This means for most of the longer running (and occasionally shorter) bisyncs will fail requiring a --resync every reboot (or at least I'd have to assume this). This is also difficult as you couldn't automate this as I would need to know whether to resync as push or pull of the remote. Would be fantastic if bisync can recover from a failed or rather cancelled sync without requiring a resync. Would any of these upcoming changes fix this too? Or maybe my setup is wrong? \r\n\r\nGood luck with it all and thank you again ðŸ™","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732584536/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732881448","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1732881448","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1732881448,"node_id":"IC_kwDOAQ-n5M5nSawo","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-25T04:18:28Z","updated_at":"2023-09-25T04:18:28Z","body":"> I have a systemd service that runs bisync on a timer/repeat. If I shutdown my computer and bisync is running it would require a full resync as pressing Ctrl+C would do when running in terminal\r\n\r\nAn interrupted run is tough for `bisync` to recover from cleanly, because of its bi-directional nature. When `sync` is interrupted, it can be safely retried because the source is still intact, even if the dest was left in a messy state. But with `bisync`, _both_ sides could be left in a messy state, if interrupted. Before `v1.63.0`, I would have said clean recovery is impossible, due to the possibility (on certain backends) of leaving a partially-written file on one path, which would then get erroneously copied to the other path on the next run. But now that we have [\"atomic downloads\"](https://github.com/rclone/rclone/pull/6913), I think this is worth another look. \r\n\r\nOne challenge would be bisync's logic surrounding [lock files](https://rclone.org/bisync/#lock-file) and the saving of the \"new\" state for use by the next run. Currently bisync finalizes these only after a successful sync operation. Doing this after every individual transfer probably wouldn't be practical -- it would add too much overhead and too many writes to disk. The cleaner solution is probably the \"retry from last successful snapshot on error\" idea that I mentioned [here](https://github.com/rclone/rclone/issues/5692#issuecomment-1689973729). Essentially what this would mean is: if the most recent listing is untrusted (because, in this case, it was interrupted), and `--resilient` is specified, we would look instead to the one before that, and diff the current state against the last \"trusted\" state. This would effectively make it possible to recover from these kinds of errors by \"retrying\" on the next run.\r\n\r\nWe would also need some way of distinguishing between lock files left by aborted runs vs. ones that are still running. Perhaps lock files should be considered \"expired\" after X number of minutes (configurable with a setting)? (And, thinking ahead: perhaps they should also get \"renewed\" every X-1 minutes by runs that are still running.)\r\n\r\nIn the meantime, my recommendation is: try to wait to shut down your computer until you know the bisync run has completed. (FWIW: I have mine scripted to send me a push notification when it starts, and another with the exit code when it finishes.)","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1732881448/reactions","total_count":2,"+1":2,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1735345785","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1735345785","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1735345785,"node_id":"IC_kwDOAQ-n5M5nb0Z5","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-26T11:27:38Z","updated_at":"2023-09-26T11:45:17Z","body":"Great news! I've taken a look at how lock files work and in my opinion the best option would be to check the PID alongside a regex similar to `*.rclone.*.PATH1.*.PATH2` in the case the PID is reused for another application (rclone included). This would save any 'hackery' solution and get straight to the source. \r\n\r\nWith regards to Sessions, I believe this is the best way and I do not see a reason you couldn't have a partial session where every 30s-1m the session data is updated so in a recovery situation rather than going back to the last complete session you can continue from the last complete session + partial session. However, this might be overkill.\r\n\r\nI have many bisync's running so it would be too hard to handle manually or with push notification as an aid.. So my current approach is going to have to be to catch any shutdown requests. Then, I would regularly (every 5s or so) watch the systemd process to be in the off state, stop the process so it does not run again and repeat for each rclone service. Only when all of them have been stopped then I would continue shutdown/restart/sleep etc... Perhaps, a push notification to let me know if one requires a re-sync (power cut for example) so there is no ambiguity. ","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1735345785/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1736313223","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1736313223","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1736313223,"node_id":"IC_kwDOAQ-n5M5nfgmH","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-26T21:16:17Z","updated_at":"2023-09-26T21:16:17Z","body":"> in my opinion the best option would be to check the PID alongside a regex similar to `*.rclone.*.PATH1.*.PATH2` in the case the PID is reused for another application (rclone included). This would save any 'hackery' solution and get straight to the source.\r\n\r\nThis would work well if you're running bisync on only one machine. However, one of our long-term goals is to make bisync more portable by allowing any remote path to be used as the `--workdir` (currently it is limited to local paths). One of the benefits of storing lock files on a non-local remote is that you could then easily [use bisync to keep several devices in sync with a cloud storage provider](https://github.com/rclone/rclone/issues/5689#issuecomment-1685612894), without the risk of [syncing the same path simultaneously from different locations](https://rclone.org/faq/#using-rclone-from-multiple-locations-at-the-same-time). The PID is less useful in this scenario, because each machine would not know the PIDs from the other machines. (They also would not be unique, but that could possibly be solved by adding some kind of machine/location identifier.)\r\n\r\n> I do not see a reason you couldn't have a partial session where every 30s-1m the session data is updated so in a recovery situation rather than going back to the last complete session you can continue from the last complete session + partial session. However, this might be overkill.\r\n\r\nThis is an interesting idea -- sort of analogous to an \"autosave\" feature. 30s-1m could be reasonable with a local `--workdir`, but may not be for other backends -- particularly ones that charge per API call. It would also slow down the run. But perhaps the option should exist as a setting, and then each user can decide what's right for them. I'm not sure that this method would have much advantage over the \"retry from last successful\" method... the one scenario I can think of where it would make a difference is:\r\n\r\n1. File changes on one side\r\n2. File is synced successfully during a run that later aborts\r\n3. Same file changes AGAIN before the next run\r\n4. File is synced again on next run\r\n\r\nAbsent step 3, the results should be identical with either method. (With the \"retry...\" method, bisync should say \"I see that the file has changed on both sides since the last successful run, but since the file currently matches on both sides, I can skip this and move on.\")\r\n\r\n> I have many bisync's running so it would be too hard to handle manually or with push notification as an aid.. So my current approach is going to have to be to catch any shutdown requests...\r\n\r\nI wonder if what you ultimately want here is something more like #966 (a way to tell all your running bisync processes to gracefully wrap-up early, when you want to shut down.) (See also: #1522)","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1736313223/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1737323325","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1737323325","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1737323325,"node_id":"IC_kwDOAQ-n5M5njXM9","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-27T12:43:22Z","updated_at":"2023-09-29T15:10:16Z","body":"I only found rclone 2 weeks ago and with the general complexity of this topic do forgive my ignorance that my come from the below.\r\n\r\n## Workdir\r\n\r\nWhat are the benifits of a remote --workdir? The only example I can think of is to make syncing the **same** two **remotes** in stateless application easier? If the only requirement is to lock a sync it seems like a lot of work with greater potential for error if multiple PCs with different listings use the same remote workdir.\r\n\r\nIn terms of locking a sync this could be handled either globally or at a file level. Where there are no api charges file level seems to be the better option so that multiple syncs can run at the same time. \r\n\r\nFlags could be: `--lock-remote 'global' | 'file'` && `--global-lock-name '.rclone-lock' (default)` && `--lock-remote-timeout 60s (default)`\r\n\r\nThere are likely other ways to handle this however this would seem to be the simplest.\r\n\r\n## Conflict Resolution \r\n\r\nAfter, looking into how rclone handles conflict resolution, I would say a small change is needed in that the newest file should not be renamed rather kept as the master and any conflicts are made using .conflict1, .conflict2 and so on over _PATH1, _PATH2 so it is more inline with the typical two-way sync. Naming the files ..path1 & ..path2 limits the number of conflict and can lead to further issues when multiple PCs are used at the same time. Should I open another issue for this?\r\n\r\n## Race Conditions\r\n\r\nAs bisync is stateful rather than stateless the only race condition I could think of is the same path being written at the same time? I have two machines running bisync at the same time (give or take) with the same sync command e.g. `rclone bisync ~/Documents remote@documents:` and fail to see how this would cause any problems (other than the above) especially once the listing/operation process is changed so that \"Listings should alternate between paths to minimize errors\". At this stage, I have an archive so am okay with the odd corruption here and there however it would seem unlikely that I would ever see such a thing? Especially, as I typically would never change the same file on both machines prior to a sync.\r\n\r\n## Initial Resync\r\n\r\nPlease see comment on #5681 \r\n\r\n## Sessions\r\n\r\nWith regards to session, my view is if the workdir is local then this should happen regularly at reasonable and predefined interval and perhaps disabled by default when remote e.g. `--session-interval 0 (disabled & default with remote --workdir) | 15s (default with local --workdir)`. In this case I'd probably even lower default for local to 10-20s.\r\n\r\n## Graceful Shutdown\r\n\r\nThe issue with something like a graceful shutdown for rclone is most applications are only given a moments notice between SIGTERM and a SIGKILL which is unlikely enough time to let current transaction complete. There are certain ways with systemd to allow longer running processes but I've found these solution to be hit and miss. Currently, I would prefer my computers to be fully up-to-date on shutdown so when switching between machines I know I will always have the latest copy so I've implemented the method described in my previous comment which seemingly works well for my use case. If/once bisync can handle a SIGKILL event and recovery without a resync then the approach of graceful handling on SIGTERM would likely work well for most use cases. \r\n\r\nEDITS: Was running out of time and last response was rushed so have had a tidy up to make it read better.. ","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1737323325/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-29T14:59:03Z","updated_at":"2023-09-29T14:59:03Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/rclone/rclone/issues/5681","repository_url":"https://api.github.com/repos/rclone/rclone","labels_url":"https://api.github.com/repos/rclone/rclone/issues/5681/labels{/name}","comments_url":"https://api.github.com/repos/rclone/rclone/issues/5681/comments","events_url":"https://api.github.com/repos/rclone/rclone/issues/5681/events","html_url":"https://github.com/rclone/rclone/issues/5681","id":1021237704,"node_id":"I_kwDOAQ-n5M483tnI","number":5681,"title":"bisync: optimize --resync","user":{"login":"ivandeex","id":9028053,"node_id":"MDQ6VXNlcjkwMjgwNTM=","avatar_url":"https://avatars.githubusercontent.com/u/9028053?v=4","gravatar_id":"","url":"https://api.github.com/users/ivandeex","html_url":"https://github.com/ivandeex","followers_url":"https://api.github.com/users/ivandeex/followers","following_url":"https://api.github.com/users/ivandeex/following{/other_user}","gists_url":"https://api.github.com/users/ivandeex/gists{/gist_id}","starred_url":"https://api.github.com/users/ivandeex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivandeex/subscriptions","organizations_url":"https://api.github.com/users/ivandeex/orgs","repos_url":"https://api.github.com/users/ivandeex/repos","events_url":"https://api.github.com/users/ivandeex/events{/privacy}","received_events_url":"https://api.github.com/users/ivandeex/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":86399007,"node_id":"MDU6TGFiZWw4NjM5OTAwNw==","url":"https://api.github.com/repos/rclone/rclone/labels/enhancement","name":"enhancement","color":"84b6eb","default":true,"description":null},{"id":173668299,"node_id":"MDU6TGFiZWwxNzM2NjgyOTk=","url":"https://api.github.com/repos/rclone/rclone/labels/doc%20fix","name":"doc fix","color":"f0b040","default":false,"description":""},{"id":709439722,"node_id":"MDU6TGFiZWw3MDk0Mzk3MjI=","url":"https://api.github.com/repos/rclone/rclone/labels/thinking","name":"thinking","color":"e9d6d5","default":false,"description":""},{"id":2433162118,"node_id":"MDU6TGFiZWwyNDMzMTYyMTE4","url":"https://api.github.com/repos/rclone/rclone/labels/breaking%20change","name":"breaking change","color":"b60205","default":false,"description":""},{"id":3427818774,"node_id":"LA_kwDOAQ-n5M7MUF0W","url":"https://api.github.com/repos/rclone/rclone/labels/bisync","name":"bisync","color":"1D76DB","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"ivandeex","id":9028053,"node_id":"MDQ6VXNlcjkwMjgwNTM=","avatar_url":"https://avatars.githubusercontent.com/u/9028053?v=4","gravatar_id":"","url":"https://api.github.com/users/ivandeex","html_url":"https://github.com/ivandeex","followers_url":"https://api.github.com/users/ivandeex/followers","following_url":"https://api.github.com/users/ivandeex/following{/other_user}","gists_url":"https://api.github.com/users/ivandeex/gists{/gist_id}","starred_url":"https://api.github.com/users/ivandeex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivandeex/subscriptions","organizations_url":"https://api.github.com/users/ivandeex/orgs","repos_url":"https://api.github.com/users/ivandeex/repos","events_url":"https://api.github.com/users/ivandeex/events{/privacy}","received_events_url":"https://api.github.com/users/ivandeex/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"ivandeex","id":9028053,"node_id":"MDQ6VXNlcjkwMjgwNTM=","avatar_url":"https://avatars.githubusercontent.com/u/9028053?v=4","gravatar_id":"","url":"https://api.github.com/users/ivandeex","html_url":"https://github.com/ivandeex","followers_url":"https://api.github.com/users/ivandeex/followers","following_url":"https://api.github.com/users/ivandeex/following{/other_user}","gists_url":"https://api.github.com/users/ivandeex/gists{/gist_id}","starred_url":"https://api.github.com/users/ivandeex/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivandeex/subscriptions","organizations_url":"https://api.github.com/users/ivandeex/orgs","repos_url":"https://api.github.com/users/ivandeex/repos","events_url":"https://api.github.com/users/ivandeex/events{/privacy}","received_events_url":"https://api.github.com/users/ivandeex/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":{"url":"https://api.github.com/repos/rclone/rclone/milestones/18","html_url":"https://github.com/rclone/rclone/milestone/18","labels_url":"https://api.github.com/repos/rclone/rclone/milestones/18/labels","id":1832726,"node_id":"MDk6TWlsZXN0b25lMTgzMjcyNg==","number":18,"title":"Known Problem","description":"This milestone contains issues which are known problems which are proving difficult to fix, or are awaiting an external fix or we haven't got round to yet.","creator":{"login":"ncw","id":536803,"node_id":"MDQ6VXNlcjUzNjgwMw==","avatar_url":"https://avatars.githubusercontent.com/u/536803?v=4","gravatar_id":"","url":"https://api.github.com/users/ncw","html_url":"https://github.com/ncw","followers_url":"https://api.github.com/users/ncw/followers","following_url":"https://api.github.com/users/ncw/following{/other_user}","gists_url":"https://api.github.com/users/ncw/gists{/gist_id}","starred_url":"https://api.github.com/users/ncw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ncw/subscriptions","organizations_url":"https://api.github.com/users/ncw/orgs","repos_url":"https://api.github.com/users/ncw/repos","events_url":"https://api.github.com/users/ncw/events{/privacy}","received_events_url":"https://api.github.com/users/ncw/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":70,"closed_issues":148,"state":"open","created_at":"2016-06-16T16:59:54Z","updated_at":"2025-08-25T17:05:37Z","due_on":null,"closed_at":null},"comments":15,"created_at":"2021-10-08T15:48:38Z","updated_at":"2024-01-20T22:17:03Z","closed_at":"2024-01-20T22:17:03Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":17803236,"node_id":"MDEwOlJlcG9zaXRvcnkxNzgwMzIzNg==","name":"rclone","full_name":"rclone/rclone","private":false,"owner":{"login":"rclone","id":24937341,"node_id":"MDEyOk9yZ2FuaXphdGlvbjI0OTM3MzQx","avatar_url":"https://avatars.githubusercontent.com/u/24937341?v=4","gravatar_id":"","url":"https://api.github.com/users/rclone","html_url":"https://github.com/rclone","followers_url":"https://api.github.com/users/rclone/followers","following_url":"https://api.github.com/users/rclone/following{/other_user}","gists_url":"https://api.github.com/users/rclone/gists{/gist_id}","starred_url":"https://api.github.com/users/rclone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rclone/subscriptions","organizations_url":"https://api.github.com/users/rclone/orgs","repos_url":"https://api.github.com/users/rclone/repos","events_url":"https://api.github.com/users/rclone/events{/privacy}","received_events_url":"https://api.github.com/users/rclone/received_events","type":"Organization","user_view_type":"public","site_admin":false},"html_url":"https://github.com/rclone/rclone","description":"\"rsync for cloud storage\" - Google Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Wasabi, Google Cloud Storage, Azure Blob, Azure Files, Yandex Files","fork":false,"url":"https://api.github.com/repos/rclone/rclone","forks_url":"https://api.github.com/repos/rclone/rclone/forks","keys_url":"https://api.github.com/repos/rclone/rclone/keys{/key_id}","collaborators_url":"https://api.github.com/repos/rclone/rclone/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/rclone/rclone/teams","hooks_url":"https://api.github.com/repos/rclone/rclone/hooks","issue_events_url":"https://api.github.com/repos/rclone/rclone/issues/events{/number}","events_url":"https://api.github.com/repos/rclone/rclone/events","assignees_url":"https://api.github.com/repos/rclone/rclone/assignees{/user}","branches_url":"https://api.github.com/repos/rclone/rclone/branches{/branch}","tags_url":"https://api.github.com/repos/rclone/rclone/tags","blobs_url":"https://api.github.com/repos/rclone/rclone/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/rclone/rclone/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/rclone/rclone/git/refs{/sha}","trees_url":"https://api.github.com/repos/rclone/rclone/git/trees{/sha}","statuses_url":"https://api.github.com/repos/rclone/rclone/statuses/{sha}","languages_url":"https://api.github.com/repos/rclone/rclone/languages","stargazers_url":"https://api.github.com/repos/rclone/rclone/stargazers","contributors_url":"https://api.github.com/repos/rclone/rclone/contributors","subscribers_url":"https://api.github.com/repos/rclone/rclone/subscribers","subscription_url":"https://api.github.com/repos/rclone/rclone/subscription","commits_url":"https://api.github.com/repos/rclone/rclone/commits{/sha}","git_commits_url":"https://api.github.com/repos/rclone/rclone/git/commits{/sha}","comments_url":"https://api.github.com/repos/rclone/rclone/comments{/number}","issue_comment_url":"https://api.github.com/repos/rclone/rclone/issues/comments{/number}","contents_url":"https://api.github.com/repos/rclone/rclone/contents/{+path}","compare_url":"https://api.github.com/repos/rclone/rclone/compare/{base}...{head}","merges_url":"https://api.github.com/repos/rclone/rclone/merges","archive_url":"https://api.github.com/repos/rclone/rclone/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/rclone/rclone/downloads","issues_url":"https://api.github.com/repos/rclone/rclone/issues{/number}","pulls_url":"https://api.github.com/repos/rclone/rclone/pulls{/number}","milestones_url":"https://api.github.com/repos/rclone/rclone/milestones{/number}","notifications_url":"https://api.github.com/repos/rclone/rclone/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/rclone/rclone/labels{/name}","releases_url":"https://api.github.com/repos/rclone/rclone/releases{/id}","deployments_url":"https://api.github.com/repos/rclone/rclone/deployments","created_at":"2014-03-16T16:19:57Z","updated_at":"2025-11-09T20:38:02Z","pushed_at":"2025-11-08T21:33:38Z","git_url":"git://github.com/rclone/rclone.git","ssh_url":"git@github.com:rclone/rclone.git","clone_url":"https://github.com/rclone/rclone.git","svn_url":"https://github.com/rclone/rclone","homepage":"https://rclone.org","size":217990,"stargazers_count":53422,"watchers_count":53422,"language":"Go","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":4767,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1169,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["azure-blob","azure-blob-storage","azure-files","backblaze-b2","cloud-storage","dropbox","encryption","ftp","fuse-filesystem","go","golang","google-cloud-storage","google-drive","onedrive","openstack-swift","rclone","s3","sftp","sync","webdav"],"visibility":"public","forks":4767,"open_issues":1169,"watchers":53422,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"## Synposis\r\n\r\nClearly explain in documentation whether `--resync` is asymmetrical.\r\n(@cjnaz could you comment?)\r\n\r\nInvestigate whether `--resync` can be re-implemented by the equivalent of:\r\n\r\n```\r\nrclone copy --update Path1 Path2\r\nrclone copy --update Path2 Path1\r\n```\r\n\r\n## Prior discussions\r\n\r\n## optimize --resync\r\n\r\n### https://github.com/cjnaz/rclonesync-V2/issues/66 (eric-void) -> (cjnaz)\r\n\r\n> looking at the code there is a lot of work to copy Path2 files not in Path1, and then do an \"rclone sync\" from Path1 to Path2. Why don't you just do and \"rclone copy\" from Path1 to Path2, and then an \"rclone copy\" from Path2 to Path1?\r\n> This is much simpler, there is no need to read 2 times LSL files and to loop for missing Path2 files, and the result should be the same. Am i missing something?\r\n\r\nThe first-sync optimization is deferred for now since its not broke and should be rarely run.\r\n\r\n### https://github.com/rclone/rclone/pull/5164#discussion_r688913159 (ncw)\r\n\r\nSo `--resync` is asymetrical?\r\n\r\nPerhaps it would be better implemented by the equivalent of\r\n\r\n```\r\nrclone copy --update Path1 Path2\r\nrclone copy --update Path2 Path1\r\n```\r\n\r\n## How to use GitHub\r\n\r\n* Please use the ðŸ‘ [reaction](https://blog.github.com/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) to show that you are affected by the same issue.\r\n* Please don't comment if you have no relevant information to add. It's just extra noise for everyone subscribed to this issue.\r\n* Subscribe to receive notifications on status change and new comments.\r\n","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/5681/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rclone/rclone/issues/5681/timeline","performed_via_github_app":null,"state_reason":"completed"}},"event":"cross-referenced"},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741611077","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1741611077","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1741611077,"node_id":"IC_kwDOAQ-n5M5nzuBF","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-30T00:58:19Z","updated_at":"2023-09-30T00:58:19Z","body":"Thank you so much for this detailed feedback! It is really helping me gain insight into bisync use cases that are different from my own, which is quite valuable ðŸ™‚ (As an aside, I wonder if it might be helpful to start a \"bisync user feedback\" group in the forum or something -- it would be really helpful to be able to easily survey a group from time to time on these kinds of design questions.)\r\n\r\nA few responses to your comments:\r\n> What are the benifits of a remote --workdir? The only example I can think of is to make syncing the same two remotes in stateless application easier? If the only requirement is to lock a sync it seems like a lot of work with greater potential for error if multiple PCs with different listings use the same remote workdir.\r\n\r\nIn a word: portability. This question sort of implies that at least one of the bisync paths is a `local` remote, and while I agree that's probably the most common use case for bisync, it's not technically a requirement. For example, bisync could just as easily be used to sync a `drive` remote with a `dropbox` remote. In this kind of scenario, it makes a little less sense to require that bisync must always be run from the same machine. Perhaps I'm traveling with my laptop and away from my main desktop machine -- if the listing files are in the cloud, I can seamlessly pick up on one machine where I left off on another. It also just strikes me as more \"rclonic\" -- in general, rclone is designed to be as stateless as possible, and avoid relying on sidecars, resource forks, or local databases. Bisync is currently one of the only rclone commands that does so (out of necessity, as bidirectional sync can never be completely stateless). So, in my (subjective) opinion, allowing a non-local `--workdir` brings us a little bit closer to rclone's platform-agnostic core principles, and the (unreachable) goal of having full feature parity between backends.\r\n\r\nIt should also be noted that adding support for non-local `--workdir` does not mean removing any existing support for `local` -- so really nothing would change for users that wish to continue using a local `--workdir`. They can ignore this new feature and carry on like they did before.\r\n\r\n> After, looking into how rclone handles conflict resolution, I would say a small change is needed in that the newest file should not be renamed rather kept as the master\r\n\r\nOne of the [most common complaints](https://github.com/rclone/rclone/issues/5679#:~:text=The%20fact%20that,one%20side%20only.) about bisync is that it currently [refuses to operate on backends that lack modification time support](https://rclone.org/bisync/#modification-time). This is going to be solved soon by adding support for [`--checksum`](https://github.com/rclone/rclone/issues/5683) and [`--size-only`](https://github.com/rclone/rclone/issues/5684). Once this is the case, there will no longer really be a concept of \"newest\" in a file-conflict situation -- all we can say is whether a file changed on both paths (since the last run), and whether or not the current version on one path is [equal](https://github.com/rclone/rclone/pull/6971/commits/add917cfac363bd49ac718123f29f764ea5531c0) to the version on the opposite path. So, this would present a challenge to what you are proposing -- sometimes there is no \"newest\", only \"different\". I could imagine possibly implementing what you are suggesting as an optional flag for the rest of the time (when we do have modtime available on both sides), although personally I'm not sure I would use it. To me, the `..path1` / `..path2` rename is a helpful alert that something went wrong and needs my attention to resolve, so silently skipping this for one of the paths would give me a false sense of security. That said, I have no objection to implementing features I don't personally plan to use (I much prefer giving users the choice whenever possible), so if a sizable number of users want this, I'm happy to add the option. (This is a good example of something I'd love to poll the group about!)\r\n\r\nAlso worth noting: even when both paths do support modtime, \"deletes\" still never have a modtime, just by their nature. (All we can say is that a file used to be there and now is not -- we can't say _what time_ it was deleted, or whether it was deleted before or after the other path's version was last modified.)\r\n\r\n> any conflicts are made using .conflict1, .conflict2 and so on over _PATH1, _PATH2 so it is more inline with the typical two-way sync. Naming the files ..path1 & ..path2 limits the number of conflict and can lead to further issues when multiple PCs are used at the same time. Should I open another issue for this?\r\n\r\nI'm not sure if I understand what you mean about this one. How does `..path1` / `..path2` limit the number of conflicts, and how would `.conflict1` / `.conflict2` solve that? Does this question rely on the the prior suggestion (of renaming only one side) being implemented? To make sure we're on the same page about the _current_ behavior: the first conflict for file `x` results in `x..path1` (for the Path1 side) and `x..path2` (for the Path2 side). If the Path1 conflict were to have yet another conflict after that (and I'm not sure why that would happen, as it would mean opening `x..path1` and editing it on both sides without renaming it first -- but let's just assume it did), you would then get `x..path1..path1` and `x..path1..path2`, in addition to the pre-existing `x..path2` which would remain unchanged. You could repeat this any number of times (limited only by filename length limitations from your backend...eventually.) I'm guessing that maybe what you would prefer is for subsequent conflicts to be named `x..conflict3`, `x..conflict4`, `x..conflict5`, etc. but my question then would be: how would you tell whether `x..conflict5` came from Path1 or Path2? And how do you determine the winner when neither side can be considered \"newest\"?\r\n\r\n> As bisync is stateful rather than stateless the only race condition I could think of is the same path being written at the same time?\r\n\r\nBy \"path\" do you mean one individual file? That is certainly a concern, but I think it's also important to consider the risk at the _directory_ level. When rclone walks directories recursively, the [order can be unpredictable](https://rclone.org/docs/#limitations) due to concurrency, among other things -- there's no guarantee that `bisync A B` and `bisync A C` will both list the directories of `A` in the same order. (The tradeoff is that concurrency is what makes rclone so fast.) So given that, now imagine a use case where the sync needs to be atomic at not just the _file_ level, but also the _directory_ level. For example, something like a source code repository, where _all_ files in the tree must be from version 1 or else _all_ files in the tree must be from version 2. You can't end up with one subdirectory from version 1 and another from version 2 in the same repo -- the application won't work. This is the kind of problem we could miss if we only worry about conflicts between individual files and consider each file an island. So, while you're right that the chance of writing any individual file at the exact same time from two locations is fairly small, the chance of doing the same thing to a _directory_ is much larger -- the race condition window could be even hours or days-long, if the files are particularly large. A directory-level conflict could occur without any of its containing files having a file-level conflict. Most concurrent applications solve this problem with a mutex or other kind of locking mechanism, and that is why bisync uses \"lock files\", although the implementation is imperfect at the moment because the mutual exclusion enforcement doesn't extend to other machines (nor does it detect tree overlaps even within the same machine.) To give credit where credit's due, though, the original designer of bisync (not me, to be clear) realized this problem and made sure to include this warning in [the docs](https://rclone.org/bisync/#lock-file):\r\n>>\"**Note** that while concurrent bisync runs are allowed, be _very cautious_ that there is no overlap in the trees being synched between concurrent runs, lest there be replicated files, deleted files and general mayhem.\"\r\n\r\nAnother common scenario where mutual exclusion matters at the directory-level is a \"project folder\" like the kind often created by media editing applications (Pro Tools, Adobe Premiere / Illustrator, Apple Logic Pro, etc.) These apps expect all the source media files to be from the same project version (for example, video editors often throw errors if the video file they find at a particular path doesn't match the length of the clip in the timeline.) This kind of data corruption is not something we can catch by looking solely for conflicts between individual files.\r\n\r\n> With regards to session, my view is if the workdir is local then this should happen regularly at reasonable and predefined interval and perhaps disabled by default when remote\r\n\r\nI think we may be using the word \"sessions\" to mean different things (I'm using it as defined [here](https://github.com/rclone/rclone/issues/5678)), but setting that aside, I think we generally agree on the substance -- it would be ideal for bisync to be more prepared for the possibility of an unexpected interruption, and it should require `--resync` as little as possible. I think where we might differ slightly is our preference when faced with the inevitable tradeoff between convenience and safety. While I'm no fan of being asked to `--resync`, I still would rather be asked than have bisync take a \"best guess\" on my behalf and guess wrong. One of the main reasons I chose bisync (and rclone as a whole) in the first place is because of how it prioritizes safety where other sync tools prioritize convenience or resilience. I feel comfortable entrusting important files to bisync precisely because it will err on the side of stopping and asking me for help when its only alternative is to guess. I fully acknowledge that some users will prefer a different tradeoff and may be fine settling for a standard where data corruption is just \"unlikely\" -- but I can't assume that every user will be ok with that. So, I plan to maintain bisync's original philosophy of being \"(too) safe by default\", but changeable with flags for advanced users. (My recent addition of [`--resilient` mode](https://rclone.org/bisync/#resilient) is an example.)\r\n\r\nTo sum up where I think I am regarding crash recovery: I think there are definitely some meaningful improvements we can and should make, and in particular I like your idea of an \"autosave\"-like feature that is disabled by default when `--workdir` is remote (and I'd say possibly when local too -- unless careful testing finds the performance overhead to be basically negligible.) To be totally transparent, I think it will likely take me awhile to get to it, as I think bisync has several other more pressing issues, and I also don't find \"don't pull the plug while it's running\" to be an unreasonable or excessively burdensome expectation in the meantime (but again, that's not to say we shouldn't try to improve it -- we should.) You are also of course welcome to submit a Pull Request at any time, if you would like to. You might also consider checking out some [bisync alternatives](https://rclone.org/bisync/#references) (such as [syncrclone](https://github.com/Jwink3101/syncrclone)) that make some different choices with regard to some of these tradeoffs.\r\n\r\n> I've implemented the method described in my previous comment which seemingly works well for my use case.\r\n\r\nGlad to hear that! I'd also be interested to know a little more about your use case (only if you're inclined to share) and why it requires so many different bisync processes to be running simultaneously. For example -- could it not be solved by [combining](https://rclone.org/combine/) the various paths into one tree and then bisyncing them all in one bisync run? Also, how frequently do you schedule the runs, and what's the longest they normally take? (I think this info may help me conceptualize why curing the interruptions would be more practical than preventing them.)\r\n\r\nThank you again for the thoughtful feedback! You've challenged my thinking in a good way ðŸ™‚ ","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741611077/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741776569","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1741776569","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1741776569,"node_id":"IC_kwDOAQ-n5M5n0Wa5","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-09-30T14:19:28Z","updated_at":"2023-09-30T14:30:51Z","body":"## Workdir\r\n\r\nThis is exactly the use case I was suggesting here, however I should have said stateless manner over application.\r\n\r\n> The only example I can think of is to make syncing the same two remotes in stateless application easier? \r\n\r\nI was thinking something like k8s cronjob however your example of laptop to desktop and keeping the same two remotes (e.g. remoteA: remoteB:) is just as valid. This could already be solved by using a systemd service for example and using StartPre to update local workdir from a remote, Start to run bisync, StartPost to update local workdir to a remote. Though sure adding this functionality could make life easier provided one does not do what I talk about later in this section. \r\n\r\nHowever, I should have been more clear with my question as I was only asking due to your comment:  \r\n\r\n> This would work well if you're running bisync on only one machine. However, one of our long-term goals is to make bisync more portable by allowing any remote path to be used as the --workdir (currently it is limited to local paths). One of the benefits of storing lock files on a non-local remote is that you could then easily use bisync to keep several devices in sync with a cloud storage provider, without the risk of syncing the same path simultaneously from different locations. The PID is less useful in this scenario, because each machine would not know the PIDs from the other machines. (They also would not be unique, but that could possibly be solved by adding some kind of machine/location identifier.)\r\n\r\nThe comment here made me go well hold on, why would you store the lock file in the --workdir and how would having a remote --workdir help keep multiple pc in sync. I can only see it making it worse. If I have two computers syncing `~/Documents remote:` having a remote --workdir would require a complete change to --workdir to handle unique ids and runs the risk of duplicate IDs, more requests where not needed and I'm sure other problems too. Also, a lock file is to do with the remote and not workdir. Of course, I understand you would never remove a local --workdir. When syncing multiple PCs it should be a limitation that the workdir must be local as there can be no benefit to storing it remotely and if one really wants to (for some unknown reason at least that I can think of?) it must be a different remote path ergo --workdir of any other pc.\r\n\r\n## Mod time & Conflicts\r\n\r\nBy very nature and for bisync to be fully functional requires a backend to support mod time. That's not to say that workarounds can't be put in place but simply when using bisync one should always be advised to use it with a backend that supports modtime. Checksum should really on be used to prevent re uploading/downloading a file that hasn't changed but for some reasons has different modtimes. Where a backend has a modtime (which surely is the norm anyways?), conflict resolution should work by keeping the newest file unnamed to prevent any major breakage / damage to a running application that relies on these files. Also, this is a limitation of bidirectional sync its not designed to merge files so if somebody makes a change to file from both ends they should already expect a conflict. If this is something happening regularly in their workflow they need to change the way they're working e.g. do not change a file until it has updated to the latest copy or use git or switch over to using a central database or use libreoffice in the cloud, ms365 or google docs. I also believe this should be the default however if you believe strongly against this a flag would be greatly appreciated. My view on flags and why this should be the default is that advanced users should add flags to change the industry norms of a tool not the other way round. If using a remote that does not support modtime then sure maybe you have to keep both files named conflict1/path1 and conflict2/path2 as you can't determine which is newer.\r\n\r\n## Conflict Naming\r\n\r\nI see with the current way you would just end up with ..path1..path1 ..path1..path2 so it doesn't actually limit the number of conflicts (except that the file name could be come exceptionally long). \r\n\r\n> If the Path1 conflict were to have yet another conflict after that (and I'm not sure why that would happen, as it would mean opening x..path1 and editing it on both sides without renaming it first -- but let's just assume it did), you would then get x..path1..path1 and x..path1..path2, in addition to the pre-existing x..path2 which would remain unchanged.\r\n\r\nAgreed, but just because you changed the file name back to the original doesn't mean you won't get another conflict, what if someone else has already handled the conflict.\r\n\r\n> Does this question rely on the the prior suggestion (of renaming only one side) being implemented? \r\n\r\nYes the suggestion to use conflict1, etc.. is with the fact that you would always keep the newest file. Also PATH1 and PATH2 is ultimately meaningless as by very nature if wanting to bisync a remote that means you are expecting more than one person/pc to update the remote and would also assume the use of the same tool e.g. rclone (in general). So really it would only have meaning if you also include a PC/PERSON unqiue ID too as PATH1 and PATH2 could be different in each case e.g. ..PATH1..COMPUTER1, ... Anyways, my point here is that PATH1 and PATH2 is meaningless in a bisync capacity so why use it at all? \r\n\r\n## Race Conditions\r\n\r\nYes, I was talking about a path because if there is a conflict we are now talking about multiple file(s) rather than a file. I do think using a lock on the file/path level would solve this. \r\n\r\nWith regards to directories, I feel like what you are talking about here applies to all bidirectional file sync that aren't watching the directories and therefore do not have the concept of deleted_at to handle this case.\r\n\r\n- Directory 'dir' is deleted on machine A\r\n- On machine B somebody adds a file to 'dir' called 'file'\r\n\r\nI'm not sure how rclone handles this? The two cases I can see is Machine A syncs first or Machine B\r\n\r\n- Machine B adds 'dir.file' then Machine A delete 'dir' meaning 'dir.file' is no more\r\n- Machine A delete 'dir' then Machine B add 'dir.file' \r\n\r\nThough, I thought rclone handles files rather than directories that's why there is a `--remove-empty-dir` flags which would mean even in the case listed above regardless of sync order 'dir.file' would survive and all files that were originally in 'dir' would be removed as one would expect? There not much a tool can do if lets say multiple people use bisync on a single drive where one deletes a folder and another one adds stuff to said folder. The best it can do is try to keep the new file and delete the old ones. Though, perhaps this is not the case with bisync and it would be entirely dependant on which machine syncs first. Either way, it up to users to not delete a directory which others are using otherwise they're gonna have to use there archives to restore data (fair enough no?) and why one has archives..\r\n\r\nThis also comes back to how one uses bisync. In the common case where someone is mass deleting directories, I believe it would be to keep multiple pc in sync for one user not on a shared drive used by others for this very reason. I know that if I want to delete 'dir' v1 and replace 'dir' with v2 I should : \r\n\r\n1. do on one machine \r\n2. if using another machine first wait for 'dir' to be deleted before recreating 'dir' with new files\r\n3. do not make changes to 'dir' until up to date from step 1 or 2\r\n\r\n> \"Note that while concurrent bisync runs are allowed, be very cautious that there is no overlap in the trees being synched between concurrent runs, lest there be replicated files, deleted files and general mayhem.\"\r\n\r\nThis is a limitation that as far as I am aware of applies to all bidirectional syncing and everyone is aware so I still fail to understand if there is something else in 'bisync' that warrants this statement. Like the above is kinda of obvious no? Like yes, if you try and edit stuff you've deleted on another machine then get ready for some issues when it tries to sync up. Though, I still think the file you edited would remain as rclone uses files not directories. (perhaps only when --create-empty-directories is used would this create the issue where sync order would matter). I guess I also struggle to see how concurrency changes the outcome of the sync if rclone is file based but perhaps I'm wrong about this..\r\n\r\n## Sessions (not sessions ðŸ¤£)\r\n\r\nI agree, I'm using the wrong terminology here but ultimately have nothing more to add to your points. I'm in full agreeance and also yes believe there are more pressing matters at hand. I would also expect that when local this should add virtually no overhead. \r\n\r\n\r\n## Graceful Shutdown\r\n\r\nMy setup is as such to create separation of different crypt keys, storage remotes, usage and local file path/location. Also to avoid too many files in one place as bisync in its current state simply can't handle the load. So take for example: Cold, Documents, Work, VMs, this list goes on. Each one of these may reside on different remotes and my desktop for example keeps a full local copy of all where my laptop will mount drives that do not need to be local such as Cold. To make this work for me now I've already sacrificed storing files in certain directories so a sync for my Work directory for example can be done in 10 minutes as per the first comment of this issue rather than over an hour as it was taking before. One of my directories contains over 100,000 files and this could take 12 hours to sync. I would only do this manually until the performance is increased. I simply call the below script with all the systemd services when a shutdown is called which will wait until the service is inactive and then stop it completely. These service will notify if any of the syncs require a --resync or exit 1 errors via `notify-send` so I can assume sync is working otherwise.\r\n\r\n```\r\nisActiveRunning() {\r\n\tif systemctl --user is-active --quiet $1; then echo true;\r\n\telse echo false; fi\r\n}\r\n\r\nstopService() {\r\n\twhile true;\tdo\r\n\t\tif [ \"$(isActiveRunning $1)\" == \"false\" ]; then\r\n\t\t\tsystemctl --user stop $1\r\n\t\t\techo \"$1 stopped\"\r\n\t\t\tbreak\r\n\t\tfi\r\n\t\techo \"$1 still running...\"\r\n\t\tsleep 5\r\n\tdone\r\n}\r\n\r\nstopService {serviceName}\r\n``` \r\n\r\nThanks !","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741776569/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741926456","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1741926456","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1741926456,"node_id":"IC_kwDOAQ-n5M5n07A4","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-10-01T02:11:38Z","updated_at":"2023-10-01T02:51:54Z","body":"> having a remote --workdir would require a complete change to --workdir to handle unique ids\r\n\r\nYou are right -- it would. This is work that would have to be done when implementing the feature.\r\n\r\nThe rest of your comments in this section describe why you personally do not wish to use a remote `--workdir`, which is fine -- you don't have to. There are others who do want such a feature. I think the only way it affects you is that it means we can't rely on PIDs as our locking mechanism -- but as I've explained, there would already be problems with doing so. At most, checking PIDs could offer some protection within the same machine, but it could not protect against the risk of race conditions caused by bisync runs on other machines.\r\n\r\n> Also, a lock file is to do with the remote and not workdir.\r\n\r\nI agree this is a valid point, and I think it may be worth considering a separation -- such that you can have a remote lock file and a local `--workdir`. I think that might be my ideal combination. \r\n\r\n> By very nature and for bisync to be fully functional requires a backend to support mod time. That's not to say that workarounds can't be put in place but simply when using bisync one should always be advised to use it with a backend that supports modtime.\r\n\r\nI disagree -- please read the following:\r\n\r\n- [5679 JWink3101 comment (author of bisync-alternative \"syncrclone\")](https://github.com/rclone/rclone/issues/5679#:~:text=The%20fact%20that,one%20side%20only.) \r\n- [How Bisync avoids needing modtimes to match precisely](https://rclone.org/bisync/#modification-time)\r\n- [User feedback re Bisync's lack of backend support](https://forum.rclone.org/t/bisync-should-be-considered-experimental/29879)\r\n- [\"This limitation will be lifted in a future rclone bisync release.\"](https://rclone.org/bisync/#supported-backends)\r\n\r\nI think where we do agree is that I personally would probably not ever use a backend that didn't support modtimes (and [there are many](https://rclone.org/overview/#features).) But that is just my personal preference. There are many other users who feel differently and do want to use such backends. There are even many users who go out of their way to [avoid using modtimes, even when the backend supports it](https://rclone.org/s3/#avoiding-head-requests-to-read-the-modification-time). This is popular with [S3-compatible backends](https://rclone.org/s3), for example, for performance and money reasons. Bisync should be available to them too.\r\n\r\nModtime is also imperfect -- it relies on the assumption that the underlying Fs is always updating it correctly, and that's not always true. It can be fooled (for example by using `touch`). It is not sensitive to bit rot. And even if it were perfect, \"newer\" does not always equal \"better\". There are times when a user does intentionally revert to an older version.\r\n\r\nI think the best compromise here is a `--prefer newer` flag that renames conflicts in the way you describe if modtime is available for both paths.\r\n\r\n> Also PATH1 and PATH2 is ultimately meaningless as by very nature if wanting to bisync a remote that means you are expecting more than one person/pc to update the remote and would also assume the use of the same tool e.g. rclone (in general). So really it would only have meaning if you also include a PC/PERSON unqiue ID too as PATH1 and PATH2 could be different in each case e.g. ..PATH1..COMPUTER1\r\n\r\nThis is a good point, and perhaps we should consider adding such a unique ID.\r\n\r\n> - Directory 'dir' is deleted on machine A\r\n> - On machine B somebody adds a file to 'dir' called 'file'\r\n> I'm not sure how rclone handles this?\r\n\r\nThis is explained in [the docs](https://rclone.org/bisync/#unusual-sync-checks). In short: the non-deleted path always wins (when one path is deleted and the other is new/changed). (But note that anything else in the dir, such as `dir/file2`, would still be deleted.)\r\n\r\n> I guess I also struggle to see how concurrency changes the outcome of the sync if rclone is file based but perhaps I'm wrong about this.\r\n\r\nWhen there's only one run at a time, it does not change the outcome of the sync. The problem is when there's more than one run at a time. The outcome then depends on which machine gets to that directory _first_, and _that_ is what cannot be predicted, because of concurrency (and potentially because of other things too, like differences in network speed, CPU/RAM, size of other jobs in the queue, etc). \r\n\r\n> Like the above is kinda of obvious no? Like yes, if you try and edit stuff you've deleted on another machine then get ready for some issues when it tries to sync up.\r\n\r\nIt's obvious to me, but I can't assume it will be obvious to everyone ðŸ˜„ \r\n\r\nBut if it's obvious, then surely it is also obvious why a lock file must ideally exclude additional runs on _any_ machine, not just the _same_ machine.\r\n\r\n> My setup is as such to create separation of different crypt keys, storage remotes, usage and local file path/location. Also to avoid too many files in one place as bisync in its current state simply can't handle the load.\r\n\r\nSo, it sounds to me like the reason you have so many simultaneous bisync runs is:\r\n\r\n1. You have many different remotes\r\n2. Bisync currently is slow\r\n\r\nFor 1, have you looked into the [Combine backend](https://rclone.org/combine/)? This is exactly what it's for.\r\nFor 2, I agree -- bisync is currently slow. I'm working on improving that.\r\n\r\nAm I understanding correctly that if the speed issues were solved, and you combined your remotes with the Combine backend, you would no longer need multiple simultaneous bisync runs? Or is there an additional problem that I'm overlooking?\r\n","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1741926456/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1742120292","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1742120292","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1742120292,"node_id":"IC_kwDOAQ-n5M5n1qVk","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-10-01T15:46:26Z","updated_at":"2023-10-01T15:46:26Z","body":"## Workdir\r\n\r\nI think the problem here is that there is only one use case for a remote --workdir and it requires no concept of unique ids or machines is syncing remote to remote (even if multiple remotes e.g. remoteA to remoteB, remoteC to remoteD, and so on). As soon as machine is syncing a local folder than there is 0 benefit to use a remote --workdir and instead only adds so much unneeded complexity. That is my only point and has nothing to do with PID as we've already spoken about this.\r\n\r\nTake for example you configure workdir to be able to handle multiple PCs:\r\n\r\n- I now want to use the remote workdir to sync remoteA and remoteB?\r\n    - Using a unique ID only breaks this setup unless all remote to remote are stored globally as there is no relevance to which machine synced remoteA to remoteB.\r\n- When would anyone ever be able to sync a local to remote of another PC and therefore need this information stored in a remote?\r\n- I copy my VM and run a sync it will have the same ID so I now have a broken sync and likely corruption. Or same case that one duplicates the uniqueID?\r\n- How do you correctly handle unique IDs, restorations alongside loss connectivity and failures?\r\n- Why create more requests and complex workdir with no benefit?\r\n\r\nThere is only one \"potential advantage\" to allowing multiple PCs to use a --workdir for anything other than remote to remote and that is if my computer crashes due to hard drive failure and my data is stored on another drive which didn't crash I could recover the session cache provided I knew this unique ID. Though this a weak reason as this should be solved by backing up your cache directory for the event of failure (even if that is to a remote and using rclone)\r\n\r\nAll that would need to be done is to allow workdir to be remote when both paths are also remotes which should be very fast as no changes are required to workdir. I'm only saying this for your benefit as why spend hours coding what would be a useless feature with as far as I can tell would have an absolute zero gain.  \r\n\r\n## Conflicts / ModTime\r\n\r\nI can see the lack of mod time is useful when you already have a preferred direction to reduce cost and speed up transfers. Also agree if people are happy for bi sync with no preferred direction to just have files randomly renamed files on conflicts and no mechanism to determine latest fair play, I personally wouldn't but each to their own ðŸ¤£ my point just below may also play into this regarding symmetry as bisync progresses. \r\n\r\nA flag to prefer 'newer' is more than valid and may tie into the point I just added to resync in #5681 and perhaps this needs more thought in general about conflict resolution and bisync nature as either symmetrical or asymmetrical.\r\n\r\nI also agree generally that modtime is not always perfect but in most cases it is. I also agree with the fact that a user may need access to a conflict which is why I'm very happy bisync already keeps conflicts by default. The newer flag in my case is not to prevent any other conflict file being made but to simply keep at least one of them always named the same.\r\n\r\nThe problem with then naming files with a unique ID is this is arguably only valid in a single user environment where they can still find useful info about the unique ID e.g. oh that's my laptop. But what in a multi user environment with many people syncing it still becomes rather unuseful. Which is why as far as I am aware most tools use .conflict1, .conflict2 naming. However, in a single user or small multi user environment I could see a conflict being named using some form of unqiueID could be useful.\r\n\r\n## Race Conditions\r\n\r\n> This is explained in [the docs](https://rclone.org/bisync/#unusual-sync-checks). In short: the non-deleted path always wins (when one path is deleted and the other is new/changed). (But note that anything else in the dir, such as dir/file2, would still be deleted.)\r\n\r\nExactly, what I though and what should happen. \r\n\r\n>When there's only one run at a time, it does not change the outcome of the sync. The problem is when there's more than one run at a time. The outcome then depends on which machine gets to that directory first, and that is what cannot be predicted, because of concurrency (and potentially because of other things too, like differences in network speed, CPU/RAM, size of other jobs in the queue, etc).\r\n\r\nSorry I am still confused as to why? If sync order has no effect then running concurrently should have no effect. Perhaps only if one is trying to delete an entire directory but if this is the only case then surely a check should be put in place to prevent the deletion of directory if files still remain even if the sync thinks it should delete that directory and has removed all the files.\r\n\r\n> It's obvious to me, but I can't assume it will be obvious to everyone ðŸ˜„\r\n> But if it's obvious, then surely it is also obvious why a lock file must ideally exclude additional runs on any machine, not just the same machine. \r\n\r\nI believe the first one is obvious because that is how almost all bi sync tools work and people have experience with these from the most un techy all the way through to the super techs. Though of course to someone who has never used bisync tools perhaps not.\r\n\r\nThe reason the second one is not obvious is most bisync tools do run concurrently and the explanation is rather vague and does not list the cases that would cause said problems. As far as I can tell the only need for lock files is to prevent manipulating the same path/file at the same time. Though I am still trying to determine if there are any other reasons. The reason being is without actually knowing the race conditions one can't look at fixing these and I really dislike the idea of a global lock in my case as you know I'd rather a file lock. But would that even work. Without actually knowing the race condition of concurrent sync it would be impossible to answer. Perhaps, at this stage the answer to this is unknown and of course that's okay but I think for this tool to come out of experimental this must be known. \r\n\r\n## Multiple Processes\r\n\r\nYes, combined remotes could help but that does disregard different local directories e.g. I'm not storing all my cold data on SSD for example. For ones where they are all stored on same drive perhaps this could reduce the need of multiple processes once bisync can handle vast number of files e.g. millions. So thanks for the suggestion. At this stage, I have no issue with running multiple processes. At the end of the day and regardless of how many process as I would still have to call this script to ensure a graceful shutdown until such time as this is implemented into bisync or rclone more generally. \r\n\r\nCheers !","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1742120292/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1744518386","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1744518386","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1744518386,"node_id":"IC_kwDOAQ-n5M5n-zzy","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-10-03T08:52:51Z","updated_at":"2023-10-03T08:59:29Z","body":"Firstly, I agree with you about the technical challenges surrounding unique IDs. Fully agree that either these challenges must be solved, or the feature can't be implemented. You seem to assume they can't be solved -- I am not so quick to assume that. But if you turn out to be right that they are totally unsolvable, then of course the feature will not be implemented.\r\n\r\n> As soon as machine is syncing a local folder than there is 0 benefit to use a remote --workdir and instead only adds so much unneeded complexity.\r\n\r\nEven if I accept your premise here, you are still acknowledging that remote-to-remote is a valid use case. So, if the feature is being built anyway for remote-to-remote, then the question becomes: should we disable the already developed feature for local? Or allow each user to make their own choice, in case they have some use case we haven't thought of? I lean towards the latter, even though I agree that most users (including me) would probably choose not to use it.\r\n\r\nOne possible use I can think of is if you want your listing files to be encrypted at rest, since they contain a list of all of your files in plaintext, even files from a `crypt` remote. If remote `--workdir` is supported, you could store these listing files on a `crypt` remote. Otherwise, you have no choice but to store them in plaintext on your local machine. \r\n\r\nThe bottom line is: I don't claim to know every possible use case that a user might have, and so I think it's better to make the option available, even if it might not get used much or at all (assuming the dev work is mostly happening anyway).\r\n\r\n> Also agree if people are happy for bi sync with no preferred direction to just have files randomly renamed files on conflicts and no mechanism to determine latest fair play, I personally wouldn't but each to their own ðŸ¤£ \r\n\r\nI don't agree that it's \"random\" or that there is \"no mechanism to determine latest\". The beauty of the [\"Dual Shadow Method\"](https://rclone.org/bisync/#references) is that you actually _don't_ need modtimes to determine \"latest\", usually. For example, if you only have checksums, if the checksum changed on Path1 but stayed unchanged on Path2, you can conclude that Path1 is \"latest\" and should be synced to Path2.\r\n\r\n> As far as I can tell the only need for lock files is to prevent manipulating the same path/file at the same time. Though I am still trying to determine if there are any other reasons. The reason being is without actually knowing the race conditions one can't look at fixing these and I really dislike the idea of a global lock in my case as you know I'd rather a file lock. But would that even work. Without actually knowing the race condition of concurrent sync it would be impossible to answer. Perhaps, at this stage the answer to this is unknown and of course that's okay but I think for this tool to come out of experimental this must be known.\r\n\r\nThe race condition scenarios are very much known, and I've been trying to explain them. Since you have acknowledged that you understand the problem with manipulating the same path/file at the same time, I will skip that part of the explanation and just take that as a given. So, the next question is how concurrency could cause that to happen. Well, imagine that you have two machines syncing at overlapping times, but the directory order and completion time are perfectly predictable. In this situation, there might not be a problem, because while the sync as a whole overlaps, no two directories actually overlap. We can conclude that Machine 1 will always sync any given directory before Machine 2:\r\n\r\n```\r\nMachine 1: | A | B | C | D | E | F | G | H | I | J | K | L |\r\nMachine 2:         | A | B | C | D | E | F | G | H | I | J | K | L |\r\n```\r\n(In these examples, imagine that Machine 1 is running `rclone bisync A B` and Machine 2 is running `rclone bisync A C`.)\r\n\r\nNow, imagine the same thing with an unpredictable sync order. Now, it becomes possible that Machine 2 will sync a given directory at the same time or earlier than Machine 1, as noted by the `!` symbol:\r\n\r\n```\r\nMachine 1: | I | J | E | D | F | C | L | A | K | H | B | G |\r\nMachine 2:         | D | L | G | J | A | H | I | C | B | E | K | F |\r\n                     !   !   !       !   !           !\r\n```\r\n\r\nBut with a mutual exclusion lock, the random directory order isn't a problem, since it can never overlap:\r\n```\r\nMachine 1: | I | J | E | D | F | C | L | A | K | H | B | G |\r\nMachine 2:                                                 | D | L | G | J | A | H | I | C | B | E | K | F |\r\n```\r\n\r\nHopefully that clarifies the problem.\r\n\r\nAdditionally, [here is a simple little example](https://go.dev/play/p/S98GjeaGBX0) illustrating how order can be unpredictable due to concurrency in Go. Click \"Run\" multiple times, and observe how the worker numbers are printed in a different order each time, even though the code has not changed.\r\n\r\n> Yes, combined remotes could help but that does disregard different local directories e.g. I'm not storing all my cold data on SSD for example.\r\n\r\nI'm not sure if I'm understanding what the type of drive has to do with this. The [combine backend](https://rclone.org/combine/) is perfectly capable of combining SSD and HDD paths into one virtual tree for rclone's purposes. (They would still remain on their original drives -- rclone would just see them as part of the same tree. Similar to symlinks.) But in any case, I am glad you found a solution that works for you.","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1744518386/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1745193248","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1745193248","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1745193248,"node_id":"IC_kwDOAQ-n5M5oBYkg","user":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-10-03T15:16:43Z","updated_at":"2023-10-03T15:28:43Z","body":"## Workdir\r\n\r\n> You seem to assume they can't be solved -- I am not so quick to assume that. But if you turn out to be right that they are totally unsolvable, then of course the feature will not be implemented.\r\n\r\nJust to clarify I'm not saying they can't be solved I'm saying that there is no advantage and a lot of complication in doing so, that is local to remote not remote to remote and could cause real damage to ones data. I agree remote to remote is a fantastic idea.\r\n\r\n> Even if I accept your premise here, you are still acknowledging that remote-to-remote is a valid use case. So, if the feature is being built anyway for remote-to-remote, then the question becomes: should we disable the already developed feature for local? \r\n\r\nRemote-to-remote requires no changes to workdir though? Rather just allowing a remote to be workdir which is why I suggested disabling local all together with a remote workdir so this feature can be added easily and with minimal risk.\r\n\r\n> Or allow each user to make their own choice, in case they have some use case we haven't thought of? I lean towards the latter, even though I agree that most users (including me) would probably choose not to use it.\r\n\r\nCall me old school but if one can't find a good reason to do something then do not do it. If somebody has a valid reason for local to remote then sure at the point perhaps it makes sense. \r\n\r\n> One possible use I can think of is if you want your listing files to be encrypted at rest, since they contain a list of all of your files in plaintext, even files from a crypt remote.\r\n\r\nOther than remote to remote (which is easy and I agree should be added) the files are already present on the machine so anyone who is already on your machine will have this data anyways. You can encrypt your HD too and anyone who has already got your password (e.g. government by risk of jail time or someone with a wrench) can further request your password to decrypt your rclone.conf file (if encrypted). \r\n\r\n## Conflicts\r\n\r\n> I don't agree that it's \"random\" or that there is \"no mechanism to determine latest\". The beauty of the \"Dual Shadow Method\" is that you actually don't need modtimes to determine \"latest\", usually. \r\n\r\nSorry if it wasn't clear I was talking about conflicts only and that in bidirectional sync you would just have randomly renamed conflict files with no chance of a winner. Which I was saying for me is enough of a reason to never use a non modtime backend for bisync. I am aware that with any relevant metric you can determine a change if you have prior state of said metric.\r\n\r\n## Race Conditions\r\n\r\nI think I am understanding you and that I am right then in saying that the only issue with concurrency is writing to the same path/file at the same time and that is it? \r\n\r\nAs far as I can tell the rest of your explanation is how unpredictable sync order may lead to this occurrence happening more often?\r\n\r\nAs sync order doesn't matter as long as its not the same path at precisely the same time everything should be fine e.g. so a lockfile on the file/path level would suffice?\r\n\r\n> Now, it becomes possible that Machine 2 will sync a given directory at the same time or earlier than Machine 1, as noted by the ! symbol:\r\n\r\nThough following on you do say Machine 2 may get there earlier and I fail to see a problem with this as sync order does not matter. Just the bit about same time I see the relevance. Perhaps, this is because listings are handled in bulk at the start, which I know you are working on changing to speed up sync and handle some other race conditions?\r\n\r\nExample 1: different paths but directory is removed in one\r\n\r\n- Machine A does -dir/file1 && -dir/ = file deleted no more files in directory so directory would be deleted too\r\n- Machine B does +dir/file2 = file added in directory\r\n\r\nThat this would never cause a concurrency problem as the same path is not written? Though perhaps if directory delete is at same time file is added? Though that would depend on backend maybe e.g. one that allows deletion of non empty directory? For S3 for example the file should always survive in this case?\r\n\r\nExample 2: file changed at same time\r\n\r\n- Machine A does ~dir/file1 = file changed\r\n- Machine B does ~dir/file1 = file changed\r\n\r\nConflict file not written if both paths are written at the same time; only one survives. But if not written at the same time (but syncs are still run concurrently) you would end up with a conflict.\r\n\r\nExample 3: file deleted and changed at same time\r\n\r\n- Machine A does -dir/file1 = file deleted\r\n- Machine B does ~dir/file1 = file changed\r\n\r\nUnknown if same time either the file is deleted or changed depending on which is committed last. But if not written at the same time (but syncs are still run concurrently) you would end up with the modified file.\r\n\r\nExample 4: If the changed path/files have no overlap at all there will never be any problems running concurrently?\r\n\r\nSorry, I promise last of my questions on race conditions / concurrency. \r\n\r\nI do appreciate your time and do hope the ideas in this thread are challenging and at least some what helpful. Thank you ðŸ™","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1745193248/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"crocinsocks","id":88002608,"node_id":"MDQ6VXNlcjg4MDAyNjA4","avatar_url":"https://avatars.githubusercontent.com/u/88002608?v=4","gravatar_id":"","url":"https://api.github.com/users/crocinsocks","html_url":"https://github.com/crocinsocks","followers_url":"https://api.github.com/users/crocinsocks/followers","following_url":"https://api.github.com/users/crocinsocks/following{/other_user}","gists_url":"https://api.github.com/users/crocinsocks/gists{/gist_id}","starred_url":"https://api.github.com/users/crocinsocks/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/crocinsocks/subscriptions","organizations_url":"https://api.github.com/users/crocinsocks/orgs","repos_url":"https://api.github.com/users/crocinsocks/repos","events_url":"https://api.github.com/users/crocinsocks/events{/privacy}","received_events_url":"https://api.github.com/users/crocinsocks/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1746444947","html_url":"https://github.com/rclone/rclone/issues/7332#issuecomment-1746444947","issue_url":"https://api.github.com/repos/rclone/rclone/issues/7332","id":1746444947,"node_id":"IC_kwDOAQ-n5M5oGKKT","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-10-04T09:02:11Z","updated_at":"2023-10-04T09:02:11Z","body":"> Just to clarify I'm not saying they can't be solved I'm saying that there is no advantage and a lot of complication in doing so\r\n\r\nI hear you, and I don't have much more to add on this topic. I think we agree on the \"a lot of complication\" part, disagree on the \"no advantage\" part. \r\n\r\n> Remote-to-remote requires no changes to workdir though?\r\n\r\nIt would still require changes, as currently all of this logic uses the `os` module. It actually would be _harder_ to not change local too, because it would require having two totally separate code paths for remote vs. local (vs. just one for remote, which could just happen to be a remote of type `local`.) So the question is really: should we _go out of our way to disable_ access to a feature that's already built? (Although you are right that it's not quite that simple, since enabling it also adds some complexity.) \r\n\r\n> Other than remote to remote (which is easy and I agree should be added) the files are already present on the machine so anyone who is already on your machine will have this data anyways.\r\n\r\nIt could be `local` wrapped by `crypt`, meaning the local files are encrypted and only readable by rclone. No, this will never be resistant to a \"$5 wrench attack\", but I still think it's better than nothing -- in addition to obtaining your files, someone would have to obtain your crypt password / config and understand how to use rclone to decrypt it. Not impossible, but it would take a lot more effort. \r\n\r\n> Sorry if it wasn't clear I was talking about conflicts only and that in bidirectional sync you would just have randomly renamed conflict files with no chance of a winner. Which I was saying for me is enough of a reason to never use a non modtime backend for bisync.\r\n\r\nBut that's what you already have now with bisync, whether your backend supports modtime or not. As I mentioned earlier, I see it as a feature--not a bug--that bisync refuses to engage in \"guessing\" about winners and losers.\r\n\r\n> I think I am understanding you and that I am right then in saying that the only issue with concurrency is writing to the same path/file at the same time and that is it?\r\n\r\nIn general that is correct, but there are some important caveats to understand:\r\n\r\n- Currently bisync builds its entire list at the beginning, and does all its \"checking\" before transfers start. It then filters the transfers for only those files that it determines need to be synced. Those files get re-checked the moment before they are transferred, while the other files never get re-checked. There can therefore sometimes be a fairly large window between when bisync gets information and acts on that information, and thus more chance of bisync finding something unexpected by the time it gets there (ex. trying to delete a file that's already gone)\r\n- As we've discussed, bisync currently saves the state only once at the very end -- not after each transfer.\r\n- If you use `--check-sync=true` (which is the default), the entire sync will fail and require `--resync` if the two sides don't match exactly at the end of the sync. This could easily be triggered by a change from another machine. (Even your Example 4 where the trees overlap but the changed paths do not.)\r\n- \"The same time\" could be quite a long window, in some scenarios (ex. huge file that takes hours to transfer)\r\n- How you define \"path\" here matters (see below)\r\n\r\n> As sync order doesn't matter as long as its not the same path at precisely the same time everything should be fine e.g. so a lockfile on the file/path level would suffice?\r\n\r\nWell, how do you define \"path\"? Is a \"path\" still a \"path\" if it has \"sub-paths\"? Isn't your root directory still a \"path\"? This is where it starts to make a big difference whether atomicity is important to any of your directories. If we care only about individual files, your chances of a collision are much smaller (but still not zero). On the other hand, if we care about directory-level atomicity, then basically any amount of overlap is a potential hazard. After all, who's to say at what specific hierarchy-level the atomicity should start to matter? Isn't it possible that some users bisync a root path that they consider to be atomic? All to say: a file-level lock file would work if you only care about files with no concern for directory atomicity. If you do care at all about directory atomicity, the only viable lock file is one at the level of your bisync root path. \r\n\r\n> Though following on you do say Machine 2 may get there earlier and I fail to see a problem with this as sync order does not matter.\r\n\r\nSync order does matter. Your Example 3 is a good example (file deleted and changed at same time). If Machine A gets there first, the file is deleted by A and then re-added by B, causing it to propagate back to A on the next run. But if B gets there first, the file is updated by B and then deleted by A, causing the delete to propagate back to B on the next run. One way the file survives everywhere, the other way it gets deleted everywhere. Only difference is which machine gets there first. \r\n\r\nI think that is the best that I can explain it... if it still doesn't make sense, perhaps it would be helpful to test it (not with any files you care about ðŸ˜… )","author_association":"CONTRIBUTOR","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/comments/1746444947/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":10877458751,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKIWNk_","url":"https://api.github.com/repos/rclone/rclone/issues/events/10877458751","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"89e8ba2c630f931e4e6816847858ff43ded29777","commit_url":"https://api.github.com/repos/nielash/rclone/commits/89e8ba2c630f931e4e6816847858ff43ded29777","created_at":"2023-11-06T19:13:07Z","performed_via_github_app":null},{"id":10894093137,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKJVqtR","url":"https://api.github.com/repos/rclone/rclone/issues/events/10894093137","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"d406c297cd5072abed333af3bb67a2c2a4831a22","commit_url":"https://api.github.com/repos/nielash/rclone/commits/d406c297cd5072abed333af3bb67a2c2a4831a22","created_at":"2023-11-08T00:47:50Z","performed_via_github_app":null},{"id":10894581472,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKJXh7g","url":"https://api.github.com/repos/rclone/rclone/issues/events/10894581472","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"08a44c7d69358031e129d91fe101a731d2bb6cc0","commit_url":"https://api.github.com/repos/nielash/rclone/commits/08a44c7d69358031e129d91fe101a731d2bb6cc0","created_at":"2023-11-08T02:04:58Z","performed_via_github_app":null},{"actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2023-11-08T05:05:26Z","updated_at":"2023-11-08T05:05:26Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/rclone/rclone/issues/7410","repository_url":"https://api.github.com/repos/rclone/rclone","labels_url":"https://api.github.com/repos/rclone/rclone/issues/7410/labels{/name}","comments_url":"https://api.github.com/repos/rclone/rclone/issues/7410/comments","events_url":"https://api.github.com/repos/rclone/rclone/issues/7410/events","html_url":"https://github.com/rclone/rclone/pull/7410","id":1982750140,"node_id":"PR_kwDOAQ-n5M5e4Z_J","number":7410,"title":"bisync: logger, march, and several big bug fixes","user":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":86399005,"node_id":"MDU6TGFiZWw4NjM5OTAwNQ==","url":"https://api.github.com/repos/rclone/rclone/labels/bug","name":"bug","color":"fc2929","default":true,"description":null},{"id":86399007,"node_id":"MDU6TGFiZWw4NjM5OTAwNw==","url":"https://api.github.com/repos/rclone/rclone/labels/enhancement","name":"enhancement","color":"84b6eb","default":true,"description":null},{"id":2510652221,"node_id":"MDU6TGFiZWwyNTEwNjUyMjIx","url":"https://api.github.com/repos/rclone/rclone/labels/encoding","name":"encoding","color":"b3baf2","default":false,"description":""},{"id":2523110692,"node_id":"MDU6TGFiZWwyNTIzMTEwNjky","url":"https://api.github.com/repos/rclone/rclone/labels/refactoring","name":"refactoring","color":"5319e7","default":false,"description":""},{"id":2533004918,"node_id":"MDU6TGFiZWwyNTMzMDA0OTE4","url":"https://api.github.com/repos/rclone/rclone/labels/change%20detection","name":"change detection","color":"54d3cf","default":false,"description":""},{"id":2547621549,"node_id":"MDU6TGFiZWwyNTQ3NjIxNTQ5","url":"https://api.github.com/repos/rclone/rclone/labels/concurrency","name":"concurrency","color":"9090e4","default":false,"description":""},{"id":3427818774,"node_id":"LA_kwDOAQ-n5M7MUF0W","url":"https://api.github.com/repos/rclone/rclone/labels/bisync","name":"bisync","color":"1D76DB","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":14,"created_at":"2023-11-08T05:05:25Z","updated_at":"2024-01-20T19:50:09Z","closed_at":"2024-01-20T19:50:09Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"draft":false,"repository":{"id":17803236,"node_id":"MDEwOlJlcG9zaXRvcnkxNzgwMzIzNg==","name":"rclone","full_name":"rclone/rclone","private":false,"owner":{"login":"rclone","id":24937341,"node_id":"MDEyOk9yZ2FuaXphdGlvbjI0OTM3MzQx","avatar_url":"https://avatars.githubusercontent.com/u/24937341?v=4","gravatar_id":"","url":"https://api.github.com/users/rclone","html_url":"https://github.com/rclone","followers_url":"https://api.github.com/users/rclone/followers","following_url":"https://api.github.com/users/rclone/following{/other_user}","gists_url":"https://api.github.com/users/rclone/gists{/gist_id}","starred_url":"https://api.github.com/users/rclone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rclone/subscriptions","organizations_url":"https://api.github.com/users/rclone/orgs","repos_url":"https://api.github.com/users/rclone/repos","events_url":"https://api.github.com/users/rclone/events{/privacy}","received_events_url":"https://api.github.com/users/rclone/received_events","type":"Organization","user_view_type":"public","site_admin":false},"html_url":"https://github.com/rclone/rclone","description":"\"rsync for cloud storage\" - Google Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Wasabi, Google Cloud Storage, Azure Blob, Azure Files, Yandex Files","fork":false,"url":"https://api.github.com/repos/rclone/rclone","forks_url":"https://api.github.com/repos/rclone/rclone/forks","keys_url":"https://api.github.com/repos/rclone/rclone/keys{/key_id}","collaborators_url":"https://api.github.com/repos/rclone/rclone/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/rclone/rclone/teams","hooks_url":"https://api.github.com/repos/rclone/rclone/hooks","issue_events_url":"https://api.github.com/repos/rclone/rclone/issues/events{/number}","events_url":"https://api.github.com/repos/rclone/rclone/events","assignees_url":"https://api.github.com/repos/rclone/rclone/assignees{/user}","branches_url":"https://api.github.com/repos/rclone/rclone/branches{/branch}","tags_url":"https://api.github.com/repos/rclone/rclone/tags","blobs_url":"https://api.github.com/repos/rclone/rclone/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/rclone/rclone/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/rclone/rclone/git/refs{/sha}","trees_url":"https://api.github.com/repos/rclone/rclone/git/trees{/sha}","statuses_url":"https://api.github.com/repos/rclone/rclone/statuses/{sha}","languages_url":"https://api.github.com/repos/rclone/rclone/languages","stargazers_url":"https://api.github.com/repos/rclone/rclone/stargazers","contributors_url":"https://api.github.com/repos/rclone/rclone/contributors","subscribers_url":"https://api.github.com/repos/rclone/rclone/subscribers","subscription_url":"https://api.github.com/repos/rclone/rclone/subscription","commits_url":"https://api.github.com/repos/rclone/rclone/commits{/sha}","git_commits_url":"https://api.github.com/repos/rclone/rclone/git/commits{/sha}","comments_url":"https://api.github.com/repos/rclone/rclone/comments{/number}","issue_comment_url":"https://api.github.com/repos/rclone/rclone/issues/comments{/number}","contents_url":"https://api.github.com/repos/rclone/rclone/contents/{+path}","compare_url":"https://api.github.com/repos/rclone/rclone/compare/{base}...{head}","merges_url":"https://api.github.com/repos/rclone/rclone/merges","archive_url":"https://api.github.com/repos/rclone/rclone/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/rclone/rclone/downloads","issues_url":"https://api.github.com/repos/rclone/rclone/issues{/number}","pulls_url":"https://api.github.com/repos/rclone/rclone/pulls{/number}","milestones_url":"https://api.github.com/repos/rclone/rclone/milestones{/number}","notifications_url":"https://api.github.com/repos/rclone/rclone/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/rclone/rclone/labels{/name}","releases_url":"https://api.github.com/repos/rclone/rclone/releases{/id}","deployments_url":"https://api.github.com/repos/rclone/rclone/deployments","created_at":"2014-03-16T16:19:57Z","updated_at":"2025-11-09T20:38:02Z","pushed_at":"2025-11-08T21:33:38Z","git_url":"git://github.com/rclone/rclone.git","ssh_url":"git@github.com:rclone/rclone.git","clone_url":"https://github.com/rclone/rclone.git","svn_url":"https://github.com/rclone/rclone","homepage":"https://rclone.org","size":217990,"stargazers_count":53422,"watchers_count":53422,"language":"Go","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":4767,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1169,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["azure-blob","azure-blob-storage","azure-files","backblaze-b2","cloud-storage","dropbox","encryption","ftp","fuse-filesystem","go","golang","google-cloud-storage","google-drive","onedrive","openstack-swift","rclone","s3","sftp","sync","webdav"],"visibility":"public","forks":4767,"open_issues":1169,"watchers":53422,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"pull_request":{"url":"https://api.github.com/repos/rclone/rclone/pulls/7410","html_url":"https://github.com/rclone/rclone/pull/7410","diff_url":"https://github.com/rclone/rclone/pull/7410.diff","patch_url":"https://github.com/rclone/rclone/pull/7410.patch","merged_at":"2024-01-20T19:50:09Z"},"body":"#### What is the purpose of this change?\r\n\r\nA suite of several related fixes tackling bisync's biggest pain points.\r\n\r\nHighlights:\r\n- bisync: merge copies and deletes, support `--track-renames` and `--backup-dir` -- fixes #5690 and #5685\r\n- operations: add logger to log list of sync results -- fixes #7282\r\n- sync: report list of synced paths to file -- see #7282\r\n- bisync: generate final listing from sync results, not relisting - fixes #5676\r\n- bisync: rollback listing on sync error\r\n- bisync: generate listings concurrently with march -- fixes #7332\r\n- sync: `--fix-case` flag to rename case insensitive dest -- fixes #4854\r\n- bisync: handle unicode and case normalization consistently - fixes #7270\r\n- bisync: optimize `--resync` performance -- partially addresses #5681\r\n- bisync: add support for Google Docs - fixes #5696\r\n\r\n#### Was the change discussed in an issue or in the forum before?\r\n\r\nYes. See [this post](https://forum.rclone.org/t/bisync-bugs-and-feature-requests/37636) and the individual issues linked above.\r\n\r\n#### Checklist\r\n\r\n- [x] I have read the [contribution guidelines](https://github.com/rclone/rclone/blob/master/CONTRIBUTING.md#submitting-a-new-feature-or-bug-fix).\r\n- [x] I have added tests for all changes in this PR if appropriate.\r\n- [x] I have added documentation for the changes if appropriate.\r\n- [x] All commit messages are in [house style](https://github.com/rclone/rclone/blob/master/CONTRIBUTING.md#commit-messages).\r\n- [x] I'm done, this Pull Request is ready for review :-)\r\n","reactions":{"url":"https://api.github.com/repos/rclone/rclone/issues/7410/reactions","total_count":7,"+1":5,"-1":0,"laugh":0,"hooray":2,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rclone/rclone/issues/7410/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"id":10897864956,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKJkDj8","url":"https://api.github.com/repos/rclone/rclone/issues/events/10897864956","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"8837784f6d988aed6ebee5ec2fa51a9dfe18feae","commit_url":"https://api.github.com/repos/nielash/rclone/commits/8837784f6d988aed6ebee5ec2fa51a9dfe18feae","created_at":"2023-11-08T09:22:47Z","performed_via_github_app":null},{"id":10912025521,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKKaEux","url":"https://api.github.com/repos/rclone/rclone/issues/events/10912025521","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"81875b6e9cdeecbf73a7c3caf2928d4daa92d8b8","commit_url":"https://api.github.com/repos/nielash/rclone/commits/81875b6e9cdeecbf73a7c3caf2928d4daa92d8b8","created_at":"2023-11-09T11:30:24Z","performed_via_github_app":null},{"id":10932714084,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKLo_pk","url":"https://api.github.com/repos/rclone/rclone/issues/events/10932714084","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"3ba7d75a056a3e30f1ab49268ea295dbff28c10a","commit_url":"https://api.github.com/repos/nielash/rclone/commits/3ba7d75a056a3e30f1ab49268ea295dbff28c10a","created_at":"2023-11-11T16:09:32Z","performed_via_github_app":null},{"id":10932770329,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKLpNYZ","url":"https://api.github.com/repos/rclone/rclone/issues/events/10932770329","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"55d932656e3296dc59c3e2246d9d0831f38e8b58","commit_url":"https://api.github.com/repos/nielash/rclone/commits/55d932656e3296dc59c3e2246d9d0831f38e8b58","created_at":"2023-11-11T16:40:45Z","performed_via_github_app":null},{"id":10934921466,"node_id":"REFE_lADOAQ-n5M5x1vV-zwAAAAKLxaj6","url":"https://api.github.com/repos/rclone/rclone/issues/events/10934921466","actor":{"login":"nielash","id":31582349,"node_id":"MDQ6VXNlcjMxNTgyMzQ5","avatar_url":"https://avatars.githubusercontent.com/u/31582349?v=4","gravatar_id":"","url":"https://api.github.com/users/nielash","html_url":"https://github.com/nielash","followers_url":"https://api.github.com/users/nielash/followers","following_url":"https://api.github.com/users/nielash/following{/other_user}","gists_url":"https://api.github.com/users/nielash/gists{/gist_id}","starred_url":"https://api.github.com/users/nielash/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nielash/subscriptions","organizations_url":"https://api.github.com/users/nielash/orgs","repos_url":"https://api.github.com/users/nielash/repos","events_url":"https://api.github.com/users/nielash/events{/privacy}","received_events_url":"https://api.github.com/users/nielash/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"52dddaa47183b36d63deebb6aecec12dc4d3f8aa","commit_url":"https://api.github.com/repos/nielash/rclone/commits/52dddaa47183b36d63deebb6aecec12dc4d3f8aa","created_at":"2023-11-12T16:55:52Z","performed_via_github_app":null}]