diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 3d9c68c2142..605e8375cb8 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -207,6 +207,11 @@ Bug Fixes
 
 * SOLR-12594: MetricsHistoryHandler.getOverseerLeader fails when hostname contains hyphen. (ab)
 
+* SOLR-12615: HashQParserPlugin will no longer throw an NPE if the hash key field is a string when there are documents
+  with empty values. All documents with empty values ( string , numeric ) will be processed by worker=0
+  This would fix the NPE when using the search stream with partitionKeys. (Varun Thacker)
+
+
 Optimizations
 ----------------------
 
diff --git a/solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java b/solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java
index 8832bb72801..bd8f425f278 100644
--- a/solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java
+++ b/solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java
@@ -297,7 +297,7 @@ public class HashQParserPlugin extends QParserPlugin {
       if (doc == values.docID()) {
         ref = values.binaryValue();
       } else {
-        ref = null;
+        ref = new BytesRef(); // EMPTY_BYTES . worker=0 will always process empty values
       }
       this.fieldType.indexedToReadable(ref, charsRefBuilder);
       CharsRef charsRef = charsRefBuilder.get();
@@ -327,7 +327,7 @@ public class HashQParserPlugin extends QParserPlugin {
       if (valuesDocID == doc) {
         l = values.longValue();
       } else {
-        l = 0;
+        l = 0; //worker=0 will always process empty values
       }
       return Longs.hashCode(l);
     }
diff --git a/solr/core/src/test/org/apache/solr/search/TestHashQParserPlugin.java b/solr/core/src/test/org/apache/solr/search/TestHashQParserPlugin.java
index 3f320ce04d4..6f68906604e 100644
--- a/solr/core/src/test/org/apache/solr/search/TestHashQParserPlugin.java
+++ b/solr/core/src/test/org/apache/solr/search/TestHashQParserPlugin.java
@@ -54,6 +54,34 @@ public class TestHashQParserPlugin extends SolrTestCaseJ4 {
     }
   }
 
+  @Test
+  public void testHashPartitionWithEmptyValues() throws Exception {
+
+    assertU(adoc("id", "1", "a_s", "one", "a_i" , "1"));
+    assertU(adoc("id", "2", "a_s", "one", "a_i" , "1"));
+    assertU(adoc("id", "3"));
+    assertU(adoc("id", "4"));
+    assertU(commit());
+
+    //Test with string hash
+    ModifiableSolrParams params = new ModifiableSolrParams();
+    params.add("q", "*:*");
+    params.add("fq", "{!hash worker=0 workers=1 cost="+getCost(random())+"}");
+    params.add("partitionKeys", "a_s");
+    params.add("wt", "xml");
+    String response = h.query(req(params));
+    h.validateXPath(response, "//*[@numFound='4']");
+
+    //Test with int hash
+    params = new ModifiableSolrParams();
+    params.add("q", "*:*");
+    params.add("fq", "{!hash worker=0 workers=1 cost="+getCost(random())+"}");
+    params.add("partitionKeys", "a_i");
+    params.add("wt", "xml");
+    response = h.query(req(params));
+    h.validateXPath(response, "//*[@numFound='4']");
+  }
+
 
   @Test
   public void testHashPartition() throws Exception {
@@ -62,7 +90,7 @@ public class TestHashQParserPlugin extends SolrTestCaseJ4 {
     Random random = random();
     HashSet<String> set = new HashSet();
 
-    for(int i=0; i<50; i++) {
+    for (int i=0; i<50; i++) {
       int v = random.nextInt(1000000);
       String val = Integer.toString(v);
       if(!set.contains(val)){
