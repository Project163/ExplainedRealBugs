diff --git a/solr/core/src/java/org/apache/solr/util/TimeOut.java b/solr/core/src/java/org/apache/solr/util/TimeOut.java
index d7749c983b6..a1d682a6ed9 100644
--- a/solr/core/src/java/org/apache/solr/util/TimeOut.java
+++ b/solr/core/src/java/org/apache/solr/util/TimeOut.java
@@ -23,15 +23,29 @@ import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 import org.apache.solr.common.util.TimeSource;
 
+/** Timeout tool to ease checking time left, time elapsed, and waiting on a condition. */
 public class TimeOut {
 
+  // Internally, the time unit is nanosecond.
   private final long timeoutAt, startTime;
   private final TimeSource timeSource;
 
-  public TimeOut(long interval, TimeUnit unit, TimeSource timeSource) {
+  /**
+   * @param timeout after this maximum time, {@link #hasTimedOut()} will return true.
+   * @param unit the time unit of the timeout argument.
+   * @param timeSource the source of the time.
+   */
+  public TimeOut(long timeout, TimeUnit unit, TimeSource timeSource) {
+    // Since timeout is stored in nanoseconds, it cannot track more than Long.MAX_VALUE nanoseconds.
+    // Depending on the time unit selected in this constructor, large timeout can be truncated when
+    // converting to Long.MAX_VALUE nanoseconds.
     this.timeSource = timeSource;
     startTime = timeSource.getTimeNs();
-    this.timeoutAt = startTime + NANOSECONDS.convert(interval, unit);
+    // Consider negative interval as 0.
+    timeout = Math.max(timeout, 0L);
+    // Detect long addition overflow.
+    long timeoutAt = startTime + NANOSECONDS.convert(timeout, unit);
+    this.timeoutAt = timeoutAt < startTime ? Long.MAX_VALUE : timeoutAt;
   }
 
   public boolean hasTimedOut() {
@@ -51,7 +65,7 @@ public class TimeOut {
   }
 
   /**
-   * Wait until the given {@link Supplier} returns true or the time out expires which ever happens
+   * Wait until the given {@link Supplier} returns true or the timeout expires which ever happens
    * first
    *
    * @param messageOnTimeOut the exception message to be used in case a TimeoutException is thrown
diff --git a/solr/core/src/test/org/apache/solr/util/TimeOutTest.java b/solr/core/src/test/org/apache/solr/util/TimeOutTest.java
new file mode 100644
index 00000000000..d5dc645a315
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/util/TimeOutTest.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.util;
+
+import java.util.concurrent.TimeUnit;
+import org.apache.solr.SolrTestCase;
+import org.apache.solr.common.util.TimeSource;
+
+/** Tests {@link TimeOut}. */
+public class TimeOutTest extends SolrTestCase {
+
+  public void testConstructorOverflowProtection() {
+    TimeOut timeOut =
+        new TimeOut(Long.MAX_VALUE, TimeUnit.MILLISECONDS, new MockTimeSource(0L, 0L));
+    assertFalse(timeOut.hasTimedOut());
+    assertTrue(
+        timeOut.timeLeft(TimeUnit.MILLISECONDS) >= TimeUnit.NANOSECONDS.toMillis(Long.MAX_VALUE));
+    assertEquals(0L, timeOut.timeElapsed(TimeUnit.MILLISECONDS));
+
+    timeOut =
+        new TimeOut(Long.MAX_VALUE, TimeUnit.MILLISECONDS, new MockTimeSource(Long.MIN_VALUE, 0L));
+    assertFalse(timeOut.hasTimedOut());
+    assertTrue(
+        timeOut.timeLeft(TimeUnit.MILLISECONDS) >= TimeUnit.NANOSECONDS.toMillis(Long.MAX_VALUE));
+    assertEquals(0L, timeOut.timeElapsed(TimeUnit.MILLISECONDS));
+  }
+
+  private static class MockTimeSource extends TimeSource {
+
+    private final long timeNs;
+    private final long epochTimeNs;
+
+    MockTimeSource(long timeNs, long epochTimeNs) {
+      this.timeNs = timeNs;
+      this.epochTimeNs = epochTimeNs;
+    }
+
+    @Override
+    public long getTimeNs() {
+      return timeNs;
+    }
+
+    @Override
+    public long getEpochTimeNs() {
+      return epochTimeNs;
+    }
+
+    @Override
+    public long[] getTimeAndEpochNs() {
+      return new long[] {timeNs, epochTimeNs};
+    }
+
+    @Override
+    public void sleep(long ms) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long convertDelay(TimeUnit fromUnit, long value, TimeUnit toUnit) {
+      return fromUnit.convert(value, toUnit);
+    }
+  }
+}
