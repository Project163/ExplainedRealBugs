diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index e21132d502b..5cba5cbf3ef 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -228,6 +228,8 @@ Bug Fixes
   weren't using nested docs.  In-place updates were not affected (worked).
   Reminder: if you don't need nested docs then remove both _root_ and _nest_path_ !  (David Smiley)
 
+* SOLR-13566: REINDEXCOLLECTION does not work with (basic) authentication. (Colvin Cowie, ab)
+
 ==================  8.1.1 ==================
 
 Consult the LUCENE_CHANGES.txt file for additional, low level, changes in this release.
diff --git a/solr/core/src/test/org/apache/solr/security/BasicAuthIntegrationTest.java b/solr/core/src/test/org/apache/solr/security/BasicAuthIntegrationTest.java
index abbc05561b8..26d7d33af83 100644
--- a/solr/core/src/test/org/apache/solr/security/BasicAuthIntegrationTest.java
+++ b/solr/core/src/test/org/apache/solr/security/BasicAuthIntegrationTest.java
@@ -296,15 +296,22 @@ public class BasicAuthIntegrationTest extends SolrCloudAuthTestCase {
       assertAuthMetricsMinimums(23, 11, 9, 1, 2, 0);
       assertPkiAuthMetricsMinimums(14, 14, 0, 0, 0, 0);
 
+      // Reindex collection depends on streaming request that needs to authenticate against new collection
+      CollectionAdminRequest.ReindexCollection reindexReq = CollectionAdminRequest.reindexCollection(COLLECTION);
+      reindexReq.setBasicAuthCredentials("harry", "HarryIsUberCool");
+      cluster.getSolrClient().request(reindexReq, COLLECTION);
+      assertAuthMetricsMinimums(24, 12, 9, 1, 2, 0);
+      assertPkiAuthMetricsMinimums(15, 15, 0, 0, 0, 0);
+
       // Validate forwardCredentials
       assertEquals(1, executeQuery(params("q", "id:5"), "harry", "HarryIsUberCool").getResults().getNumFound());
-      assertAuthMetricsMinimums(24, 12, 9, 1, 2, 0);
-      assertPkiAuthMetricsMinimums(18, 18, 0, 0, 0, 0);
+      assertAuthMetricsMinimums(25, 13, 9, 1, 2, 0);
+      assertPkiAuthMetricsMinimums(19, 19, 0, 0, 0, 0);
       executeCommand(baseUrl + authcPrefix, cl, "{set-property : { forwardCredentials: true}}", "harry", "HarryIsUberCool");
       verifySecurityStatus(cl, baseUrl + authcPrefix, "authentication/forwardCredentials", "true", 20, "harry", "HarryIsUberCool");
       assertEquals(1, executeQuery(params("q", "id:5"), "harry", "HarryIsUberCool").getResults().getNumFound());
-      assertAuthMetricsMinimums(31, 19, 9, 1, 2, 0);
-      assertPkiAuthMetricsMinimums(18, 18, 0, 0, 0, 0);
+      assertAuthMetricsMinimums(32, 20, 9, 1, 2, 0);
+      assertPkiAuthMetricsMinimums(19, 19, 0, 0, 0, 0);
       
       executeCommand(baseUrl + authcPrefix, cl, "{set-property : { blockUnknown: false}}", "harry", "HarryIsUberCool");
     } finally {
diff --git a/solr/solr-ref-guide/src/stream-decorator-reference.adoc b/solr/solr-ref-guide/src/stream-decorator-reference.adoc
index ae3ad3f43ba..b1d4b66032c 100644
--- a/solr/solr-ref-guide/src/stream-decorator-reference.adoc
+++ b/solr/solr-ref-guide/src/stream-decorator-reference.adoc
@@ -514,7 +514,7 @@ The `/stream` handler supports a small set commands for listing and controlling
 http://localhost:8983/collection/stream?action=list
 ----
 
-This command will provide a listing of the current daemon's running on the specific node along with there current state.
+This command will provide a listing of the current daemons running on the specific node along with their current state.
 
 [source,text]
 ----
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.java
index 59eab4107d1..f681ff22755 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.java
@@ -17,6 +17,7 @@
 package org.apache.solr.client.solrj.io.stream;
 
 import java.io.IOException;
+import java.lang.Thread.State;
 import java.lang.invoke.MethodHandles;
 import java.util.ArrayList;
 import java.util.Date;
@@ -25,12 +26,15 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.solr.client.solrj.io.Tuple;
 import org.apache.solr.client.solrj.io.comp.StreamComparator;
 import org.apache.solr.client.solrj.io.stream.expr.Explanation;
 import org.apache.solr.client.solrj.io.stream.expr.Explanation.ExpressionType;
+import org.apache.solr.common.util.ExecutorUtil;
+import org.apache.solr.common.util.SolrjNamedThreadFactory;
 import org.apache.solr.client.solrj.io.stream.expr.Expressible;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExplanation;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
@@ -202,7 +206,13 @@ public class DaemonStream extends TupleStream implements Expressible {
     }
     this.closed = false;
     this.streamRunner = new StreamRunner(runInterval, id);
-    this.streamRunner.start();
+    ExecutorService service = ExecutorUtil.newMDCAwareSingleThreadExecutor(new SolrjNamedThreadFactory("DaemonStream-" + id));
+    try {
+      service.submit(this.streamRunner);
+    }
+    finally {
+      service.shutdown();
+    }
   }
 
   public Tuple read() throws IOException {
@@ -267,13 +277,15 @@ public class DaemonStream extends TupleStream implements Expressible {
     this.stopTime = stopTime;
   }
 
-  private class StreamRunner extends Thread {
+  private class StreamRunner implements Runnable {
 
     private long sleepMillis = 1000;
     private long runInterval;
     private long lastRun;
     private String id;
 
+    // a reference to the Thread that is executing the stream to track its state
+    private volatile Thread executingThread;
     private boolean shutdown;
 
     public StreamRunner(long runInterval, String id) {
@@ -289,7 +301,29 @@ public class DaemonStream extends TupleStream implements Expressible {
       return shutdown;
     }
 
+    public State getState() {
+      if (executingThread == null) {
+        if (shutdown) {
+          return Thread.State.TERMINATED;
+        } else {
+          return Thread.State.NEW;
+        }
+      } else {
+        return executingThread.getState();
+      }
+    }
+
     public void run() {
+      executingThread = Thread.currentThread();
+      try {
+        stream();
+      } finally {
+        setShutdown(true);
+        executingThread = null;
+      }
+    }
+
+    private void stream() {
       int errors = 0;
       setStartTime(new Date().getTime());
       OUTER:
