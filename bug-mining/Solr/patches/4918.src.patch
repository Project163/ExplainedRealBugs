diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 3a2f206f70d..090c6a8a5e8 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -145,6 +145,8 @@ Optimizations
 
 * SOLR-16328: intern() strings in DocCollection to reduce memory footprint (noble)
 
+* SOLR-16445: Leader message should only be sent when there is more than one (NRT+Tlog) replica (Hitesh Khamesra, noble via Ishan Chattopadhyaya)
+
 Bug Fixes
 ---------------------
 * SOLR-13219: Fix NPE in FieldLengthFeature with non-stored/missing fields (Nick Veenhof, Tomasz Elendt)
diff --git a/solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java b/solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java
index f33d20b0f94..668126b68c8 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java
@@ -124,8 +124,7 @@ final class ShardLeaderElectionContext extends ShardLeaderElectionContextBase {
               .getClusterState()
               .getCollection(collection)
               .getSlice(shardId)
-              .getReplicas()
-              .size()
+              .getNumLeaderReplicas()
           > 1) {
         // Clear the leader in clusterstate. We only need to worry about this if there is actually
         // more than one replica.
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java b/solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java
index 0b05b9bdf69..308d37faeca 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java
@@ -104,21 +104,27 @@ public class Replica extends ZkNodeProps implements MapWriter {
      * support NRT (soft commits) and RTG. Any {@link Type#NRT} replica can become a leader. A shard
      * leader will forward updates to all active {@link Type#NRT} and {@link Type#TLOG} replicas.
      */
-    NRT,
+    NRT(true),
     /**
      * Writes to transaction log, but not to index, uses replication. Any {@link Type#TLOG} replica
      * can become leader (by first applying all local transaction log elements). If a replica is of
      * type {@link Type#TLOG} but is also the leader, it will behave as a {@link Type#NRT}. A shard
      * leader will forward updates to all active {@link Type#NRT} and {@link Type#TLOG} replicas.
      */
-    TLOG,
+    TLOG(true),
     /**
      * Doesn’t index or writes to transaction log. Just replicates from {@link Type#NRT} or {@link
      * Type#TLOG} replicas. {@link Type#PULL} replicas can’t become shard leaders (i.e., if there
      * are only pull replicas in the collection at some point, updates will fail same as if there is
      * no leaders, queries continue to work), so they don’t even participate in elections.
      */
-    PULL;
+    PULL(false);
+
+    public final boolean leaderEligible;
+
+    Type(boolean b) {
+      this.leaderEligible = b;
+    }
 
     public static Type get(String name) {
       return name == null ? Type.NRT : Type.valueOf(name.toUpperCase(Locale.ROOT));
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/Slice.java b/solr/solrj/src/java/org/apache/solr/common/cloud/Slice.java
index 3eed8d0fa4d..5414942b480 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/Slice.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/Slice.java
@@ -136,6 +136,7 @@ public class Slice extends ZkNodeProps implements Iterable<Replica> {
   private final State state;
   private final String parent;
   private final Map<String, RoutingRule> routingRules;
+  private final int numLeaderReplicas;
 
   /**
    * @param name The name of the slice
@@ -185,6 +186,8 @@ public class Slice extends ZkNodeProps implements Iterable<Replica> {
                 collection, name, (Map<String, Object>) propMap.get(SliceStateProps.REPLICAS));
     propMap.put(SliceStateProps.REPLICAS, this.replicas);
 
+    this.numLeaderReplicas =
+        (int) this.replicas.values().stream().filter(r -> r.type.leaderEligible).count();
     Map<String, Object> rules = (Map<String, Object>) propMap.get("routingRules");
     if (rules != null) {
       this.routingRules = new HashMap<>();
@@ -275,6 +278,10 @@ public class Slice extends ZkNodeProps implements Iterable<Replica> {
     return leader;
   }
 
+  public int getNumLeaderReplicas() {
+    return numLeaderReplicas;
+  }
+
   public Replica getReplica(String replicaName) {
     return replicas.get(replicaName);
   }
