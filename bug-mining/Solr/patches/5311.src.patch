diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 6ce45b4dfd0..f209a8e43e1 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -216,7 +216,7 @@ New Features
 
 Improvements
 ---------------------
-(No changes)
+* SOLR-17860: DocBasedVersionConstraintsProcessorFactory now supports PULL replicas. (Houston Putman)
 
 Optimizations
 ---------------------
diff --git a/solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java
index 1088d3280de..c7fbcc88892 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java
@@ -170,15 +170,20 @@ public class DocBasedVersionConstraintsProcessorFactory extends UpdateRequestPro
 
   @Override
   public void inform(SolrCore core) {
-
-    if (core.getUpdateHandler().getUpdateLog() == null) {
-      throw new SolrException(SERVER_ERROR, "updateLog must be enabled.");
-    }
-
     if (core.getLatestSchema().getUniqueKeyField() == null) {
       throw new SolrException(SERVER_ERROR, "schema must have uniqueKey defined.");
     }
 
+    // We can only be sure that no-update-log is safe if the core is a SolrCloud replica and is not
+    // leader eligible, because those cores will all have the "isNotLeader()" return true, and the
+    // URP logic will be ignored. Otherwise, we need to ensure an update log exists.
+    if (core.getCoreDescriptor().getCloudDescriptor() == null
+        || core.getCoreDescriptor().getCloudDescriptor().getReplicaType().leaderEligible) {
+      if (core.getUpdateHandler().getUpdateLog() == null) {
+        throw new SolrException(SERVER_ERROR, "updateLog must be enabled.");
+      }
+    }
+
     useFieldCache = true;
     for (String versionField : versionFields) {
       SchemaField userVersionField = core.getLatestSchema().getField(versionField);
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestDistribDocBasedVersion.java b/solr/core/src/test/org/apache/solr/cloud/TestDistribDocBasedVersion.java
index a0fc4b2b988..2efdb51ccde 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestDistribDocBasedVersion.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestDistribDocBasedVersion.java
@@ -21,10 +21,12 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.request.CollectionAdminRequest;
 import org.apache.solr.client.solrj.request.UpdateRequest;
 import org.apache.solr.client.solrj.response.QueryResponse;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.util.StrUtils;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -108,6 +110,26 @@ public class TestDistribDocBasedVersion extends AbstractFullDistribZkTestBase {
     }
   }
 
+  @Test
+  public void testPullReplica() throws Exception {
+    try {
+      CollectionAdminRequest.addReplicaToShard(DEFAULT_COLLECTION, "shard1")
+          .setType(Replica.Type.PULL)
+          .process(cloudClient);
+    } finally {
+      List<Replica> pullReplicas =
+          cloudClient
+              .getClusterStateProvider()
+              .getCollection(DEFAULT_COLLECTION)
+              .getSlice("shard1")
+              .getReplicas(r -> r.getType().equals(Replica.Type.PULL));
+      for (Replica replica : pullReplicas) {
+        CollectionAdminRequest.deleteReplica(DEFAULT_COLLECTION, "shard1", replica.getName())
+            .process(cloudClient);
+      }
+    }
+  }
+
   private void doTestHardFail() throws Exception {
     log.info("### STARTING doTestHardFail");
 
