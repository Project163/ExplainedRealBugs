diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 343bd5b09ad..2415906b680 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -103,6 +103,8 @@ Bug Fixes
 
 * SOLR-11503: Collections created with legacyCloud=true cannot be opened if legacyCloud=false (Erick Erickson)
 
+* SOLR-11619: V2 requests that needed to be forwarded to other nodes would get an NPE. (David Smiley)
+
 Optimizations
 ----------------------
 * SOLR-11285: Refactor autoscaling framework to avoid direct references to Zookeeper and Solr
diff --git a/solr/core/src/java/org/apache/solr/api/V2HttpCall.java b/solr/core/src/java/org/apache/solr/api/V2HttpCall.java
index d712289f1a8..8716e1af856 100644
--- a/solr/core/src/java/org/apache/solr/api/V2HttpCall.java
+++ b/solr/core/src/java/org/apache/solr/api/V2HttpCall.java
@@ -59,6 +59,7 @@ import static org.apache.solr.common.params.CommonParams.WT;
 import static org.apache.solr.servlet.SolrDispatchFilter.Action.ADMIN;
 import static org.apache.solr.servlet.SolrDispatchFilter.Action.PROCESS;
 import static org.apache.solr.common.util.PathTrie.getPathSegments;
+import static org.apache.solr.servlet.SolrDispatchFilter.Action.REMOTEQUERY;
 
 // class that handle the '/v2' path
 public class V2HttpCall extends HttpSolrCall {
@@ -122,9 +123,11 @@ public class V2HttpCall extends HttpSolrCall {
           core = getCoreByCollection(collection.getName(), isPreferLeader);
           if (core == null) {
             //this collection exists , but this node does not have a replica for that collection
-            //todo find a better way to compute remote
-            extractRemotePath(collectionName, origCorename, 0);
-            return;
+            extractRemotePath(collectionName, origCorename);
+            if (action == REMOTEQUERY) {
+              this.path = path = path.substring(prefix.length() + origCorename.length() + 2);
+              return;
+            }
           }
         }
       } else if ("cores".equals(prefix)) {
@@ -159,7 +162,7 @@ public class V2HttpCall extends HttpSolrCall {
       log.error("Error in init()", rte);
       throw rte;
     } finally {
-      if (api == null) action = PROCESS;
+      if (action == null && api == null) action = PROCESS;
       if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);
     }
   }
diff --git a/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java b/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
index 38b118722aa..ca9b69d6db8 100644
--- a/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
@@ -396,7 +396,7 @@ public class SolrConfigHandler extends RequestHandlerBase implements SolrCoreAwa
               RequestParams.ParamSet old = params.getParams(key);
               if (op.name.equals(UPDATE)) {
                 if (old == null) {
-                  op.addError(formatString("unknown paramset {} cannot update ", key));
+                  op.addError(formatString("unknown paramset {0} cannot update ", key));
                   continue;
                 }
                 params = params.setParams(key, old.update(val));
diff --git a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
index 39c60e9dbca..5022817d898 100644
--- a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
+++ b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
@@ -114,12 +114,12 @@ import static org.apache.solr.common.cloud.ZkStateReader.COLLECTION_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.CORE_NAME_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.NODE_NAME_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
+import static org.apache.solr.common.params.CollectionAdminParams.SYSTEM_COLL;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.RELOAD;
 import static org.apache.solr.common.params.CommonParams.NAME;
 import static org.apache.solr.common.params.CoreAdminParams.ACTION;
-import static org.apache.solr.common.params.CollectionAdminParams.SYSTEM_COLL;
 import static org.apache.solr.servlet.SolrDispatchFilter.Action.ADMIN;
 import static org.apache.solr.servlet.SolrDispatchFilter.Action.FORWARD;
 import static org.apache.solr.servlet.SolrDispatchFilter.Action.PASSTHROUGH;
@@ -285,8 +285,13 @@ public class HttpSolrCall {
           }
         } else {
           // if we couldn't find it locally, look on other nodes
-          extractRemotePath(collectionName, origCorename, idx);
-          if (action != null) return;
+          if (idx > 0) {
+            extractRemotePath(collectionName, origCorename);
+            if (action == REMOTEQUERY) {
+              path = path.substring(idx);
+              return;
+            }
+          }
           //core is not available locally or remotely
           autoCreateSystemColl(collectionName);
           if (action != null) return;
@@ -422,29 +427,26 @@ public class HttpSolrCall {
     }
   }
 
-  protected void extractRemotePath(String collectionName, String origCorename, int idx) throws UnsupportedEncodingException, KeeperException, InterruptedException {
-    if (core == null && idx > 0) {
-      coreUrl = getRemotCoreUrl(collectionName, origCorename);
-      // don't proxy for internal update requests
-      invalidStates = checkStateVersionsAreValid(queryParams.get(CloudSolrClient.STATE_VERSION));
-      if (coreUrl != null
-          && queryParams
-          .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {
-        path = path.substring(idx);
-        if (invalidStates != null) {
-          //it does not make sense to send the request to a remote node
-          throw new SolrException(SolrException.ErrorCode.INVALID_STATE, new String(Utils.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));
-        }
-        action = REMOTEQUERY;
-      } else {
-        if (!retry) {
-          // we couldn't find a core to work with, try reloading aliases
-          // TODO: it would be nice if admin ui elements skipped this...
-          ZkStateReader reader = cores.getZkController()
-              .getZkStateReader();
-          reader.updateAliases();
-          action = RETRY;
-        }
+  protected void extractRemotePath(String collectionName, String origCorename) throws UnsupportedEncodingException, KeeperException, InterruptedException {
+    assert core == null;
+    coreUrl = getRemotCoreUrl(collectionName, origCorename);
+    // don't proxy for internal update requests
+    invalidStates = checkStateVersionsAreValid(queryParams.get(CloudSolrClient.STATE_VERSION));
+    if (coreUrl != null
+        && queryParams.get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {
+      if (invalidStates != null) {
+        //it does not make sense to send the request to a remote node
+        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, new String(Utils.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));
+      }
+      action = REMOTEQUERY;
+    } else {
+      if (!retry) {
+        // we couldn't find a core to work with, try reloading aliases
+        // TODO: it would be nice if admin ui elements skipped this...
+        ZkStateReader reader = cores.getZkController()
+            .getZkStateReader();
+        reader.updateAliases();
+        action = RETRY;
       }
     }
   }
