diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index db129f4041c..01c697bcd46 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -417,6 +417,9 @@ Bug Fixes
 * SOLR-14758: Fix NPE in QueryComponent.mergeIds when using timeAllowed and sorting
   (Bram Van Dam, Uwe Schindler)
 
+* SOLR-15579: Allow for many values in a SQL IN clause; previously using more than 19 would result in
+  the IN clause being ignored, now users are only limited by the `maxBooleanClauses` configured for a collection (Timothy Potter)
+
 Other Changes
 ---------------------
 * SOLR-15566: Clarify ref guide documentation about SQL queries with `SELECT *` requiring a `LIMIT` clause (Timothy Potter)
diff --git a/solr/core/src/java/org/apache/solr/handler/sql/CalciteSolrDriver.java b/solr/core/src/java/org/apache/solr/handler/sql/CalciteSolrDriver.java
index 664cb8af698..d734d5146b4 100644
--- a/solr/core/src/java/org/apache/solr/handler/sql/CalciteSolrDriver.java
+++ b/solr/core/src/java/org/apache/solr/handler/sql/CalciteSolrDriver.java
@@ -18,7 +18,10 @@ package org.apache.solr.handler.sql;
 
 import org.apache.calcite.jdbc.CalciteConnection;
 import org.apache.calcite.jdbc.Driver;
+import org.apache.calcite.runtime.Hook;
 import org.apache.calcite.schema.SchemaPlus;
+import org.apache.calcite.sql2rel.SqlToRelConverter;
+import org.apache.calcite.util.Holder;
 import org.apache.solr.client.solrj.io.SolrClientCache;
 
 import java.sql.Connection;
@@ -46,6 +49,10 @@ public class CalciteSolrDriver extends Driver {
     INSTANCE.register();
   }
 
+  static void subQueryThreshold(Holder<SqlToRelConverter.Config> configHolder) {
+    configHolder.accept(config -> config.withInSubQueryThreshold(Integer.MAX_VALUE));
+  }
+
   @Override
   protected String getConnectStringPrefix() {
     return CONNECT_STRING_PREFIX;
@@ -57,8 +64,13 @@ public class CalciteSolrDriver extends Driver {
       return null;
     }
 
+    // Configure SqlToRelConverter to allow more values for an 'IN' clause,
+    // otherwise, Calcite will transform the query into a join with a static table of literals
+    Hook.SQL2REL_CONVERTER_CONFIG_BUILDER.addThread(CalciteSolrDriver::subQueryThreshold);
+
     Connection connection = super.connect(url, info);
     CalciteConnection calciteConnection = (CalciteConnection) connection;
+
     final SchemaPlus rootSchema = calciteConnection.getRootSchema();
 
     String schemaName = info.getProperty("zk");
diff --git a/solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java b/solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java
index f5cabb7a2ca..f33bdbade02 100644
--- a/solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java
+++ b/solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java
@@ -22,6 +22,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptCost;
@@ -31,11 +32,17 @@ import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
-import org.apache.calcite.rex.*;
+import org.apache.calcite.rex.RexBuilder;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexInputRef;
+import org.apache.calcite.rex.RexLiteral;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.Pair;
 import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -79,7 +86,7 @@ class SolrFilter extends Filter implements SolrRel {
       Translator translator = new Translator(SolrRules.solrFieldNames(getRowType()), builder);
       String query = translator.translateMatch(condition);
       implementor.addQuery(query);
-      implementor.setNegativeQuery(translator.negativeQuery);
+      implementor.setNegativeQuery(query.startsWith("-"));
     }
   }
 
@@ -87,7 +94,6 @@ class SolrFilter extends Filter implements SolrRel {
 
     protected final List<String> fieldNames;
     private final RexBuilder builder;
-    public boolean negativeQuery = true;
 
     Translator(List<String> fieldNames, RexBuilder builder) {
       this.fieldNames = fieldNames;
@@ -102,37 +108,15 @@ class SolrFilter extends Filter implements SolrRel {
       final SqlKind kind = condition.getKind();
 
       if (condition.isA(SqlKind.SEARCH)) {
-
-        return translateMatch(RexUtil.expandSearch(builder, null, condition));
-      }
-
-      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {
+        return translateSearch(condition);
+      } else if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {
         return translateComparison(condition);
       } else if (condition.isA(SqlKind.AND)) {
-        // see if this is a translated range query of greater than or equals and less than or equal on same field
-        // if so, then collapse into a single range criteria, e.g. field:[gte TO lte] instead of two ranges AND'd together
-        RexCall call = (RexCall) condition;
-        List<RexNode> operands = call.getOperands();
-        String query = null;
-        if (operands.size() == 2) {
-          RexNode lhs = operands.get(0);
-          RexNode rhs = operands.get(1);
-          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {
-            query = translateBetween(lhs, rhs);
-          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {
-            // just swap the nodes
-            query = translateBetween(rhs, lhs);
-          }
-        }
-        query = query != null ? query : "(" + translateAnd(condition) + ")";
-        if (log.isDebugEnabled()) {
-          log.debug("translated query match={}", query);
-        }
-        return query;
+        return translateAndOrBetween(condition);
       } else if (condition.isA(SqlKind.OR)) {
         return "(" + translateOr(condition) + ")";
       } else if (kind == SqlKind.LIKE) {
-        return translateLike(condition, false);
+        return translateLike(condition);
       } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {
         return translateIsNullOrIsNotNull(condition);
       } else {
@@ -140,6 +124,29 @@ class SolrFilter extends Filter implements SolrRel {
       }
     }
 
+    protected String translateAndOrBetween(RexNode condition) {
+      // see if this is a translated range query of greater than or equals and less than or equal on same field
+      // if so, then collapse into a single range criteria, e.g. field:[gte TO lte] instead of two ranges AND'd together
+      RexCall call = (RexCall) condition;
+      List<RexNode> operands = call.getOperands();
+      String query = null;
+      if (operands.size() == 2) {
+        RexNode lhs = operands.get(0);
+        RexNode rhs = operands.get(1);
+        if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {
+          query = translateBetween(lhs, rhs);
+        } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {
+          // just swap the nodes
+          query = translateBetween(rhs, lhs);
+        }
+      }
+      query = (query != null ? query : translateAnd(condition));
+      if (log.isDebugEnabled()) {
+        log.debug("translated query match={}", query);
+      }
+      return "(" + query + ")";
+    }
+
     protected String translateBetween(RexNode gteNode, RexNode lteNode) {
       Pair<String, RexLiteral> gte = getFieldValuePair(gteNode);
       Pair<String, RexLiteral> lte = getFieldValuePair(lteNode);
@@ -147,7 +154,6 @@ class SolrFilter extends Filter implements SolrRel {
       String query = null;
       if (fieldName.equals(lte.getKey()) && compareRexLiteral(gte.right, lte.right) < 0) {
         query = fieldName + ":[" + toSolrLiteral(gte.getValue()) + " TO " + toSolrLiteral(lte.getValue()) + "]";
-        this.negativeQuery = false; // so we don't get *:* AND range
       }
 
       return query;
@@ -172,7 +178,6 @@ class SolrFilter extends Filter implements SolrRel {
       if (left instanceof RexInputRef) {
         String name = fieldNames.get(((RexInputRef) left).getIndex());
         SqlKind kind = node.getKind();
-        this.negativeQuery = false;
         return kind == SqlKind.IS_NOT_NULL ? "+" + name + ":*" : "(*:* -" + name + ":*)";
       }
 
@@ -182,7 +187,11 @@ class SolrFilter extends Filter implements SolrRel {
     protected String translateOr(RexNode condition) {
       List<String> ors = new ArrayList<>();
       for (RexNode node : RelOptUtil.disjunctions(condition)) {
-        ors.add(translateMatch(node));
+        String orQuery = translateMatch(node);
+        if (orQuery.startsWith("-")) {
+          orQuery = "(*:* "+orQuery+")";
+        }
+        ors.add(orQuery);
       }
       return String.join(" OR ", ors);
     }
@@ -197,7 +206,11 @@ class SolrFilter extends Filter implements SolrRel {
 
 
       for (RexNode node : ands) {
-        andStrings.add(translateMatch(node));
+        String andQuery = translateMatch(node);
+        if (andQuery.startsWith("-")) {
+          andQuery = "(*:* "+andQuery+")";
+        }
+        andStrings.add(andQuery);
       }
 
       String andString = String.join(" AND ", andStrings);
@@ -213,7 +226,7 @@ class SolrFilter extends Filter implements SolrRel {
       }
     }
 
-    protected String translateLike(RexNode like, boolean isNegativeQuery) {
+    protected String translateLike(RexNode like) {
       Pair<String, RexLiteral> pair = getFieldValuePair(like);
       String terms = pair.getValue().toString().trim();
       terms = terms.replace("'", "").replace('%', '*').replace('_', '?');
@@ -224,7 +237,6 @@ class SolrFilter extends Filter implements SolrRel {
         wrappedQuotes = true;
       }
 
-      this.negativeQuery = isNegativeQuery;
       String query = pair.getKey() + ":" + terms;
       return wrappedQuotes ? "{!complexphrase}" + query : query;
     }
@@ -233,7 +245,7 @@ class SolrFilter extends Filter implements SolrRel {
       final SqlKind kind = node.getKind();
       if (kind == SqlKind.NOT) {
         RexNode negated = ((RexCall) node).getOperands().get(0);
-        return "-" + (negated.getKind() == SqlKind.LIKE ? translateLike(negated, true) : translateComparison(negated));
+        return "-" + (negated.getKind() == SqlKind.LIKE ? translateLike(negated) : translateMatch(negated));
       }
 
       Pair<String, RexLiteral> binaryTranslated = getFieldValuePair(node);
@@ -241,24 +253,19 @@ class SolrFilter extends Filter implements SolrRel {
       RexLiteral value = binaryTranslated.getValue();
       switch (kind) {
         case EQUALS:
-          this.negativeQuery = false;
           return toEqualsClause(key, value, node);
         case NOT_EQUALS:
-          return "-(" + toEqualsClause(key, value, node) + ")";
+          return "-" + toEqualsClause(key, value, node);
         case LESS_THAN:
-          this.negativeQuery = false;
           return "(" + key + ": [ * TO " + toSolrLiteral(value) + " })";
         case LESS_THAN_OR_EQUAL:
-          this.negativeQuery = false;
           return "(" + key + ": [ * TO " + toSolrLiteral(value) + " ])";
         case GREATER_THAN:
-          this.negativeQuery = false;
           return "(" + key + ": { " + toSolrLiteral(value) + " TO * ])";
         case GREATER_THAN_OR_EQUAL:
-          this.negativeQuery = false;
           return "(" + key + ": [ " + toSolrLiteral(value) + " TO * ])";
         case LIKE:
-          return translateLike(node, false);
+          return translateLike(node);
         case IS_NOT_NULL:
         case IS_NULL:
           return translateIsNullOrIsNotNull(node);
@@ -356,12 +363,12 @@ class SolrFilter extends Filter implements SolrRel {
       }
 
       if (left.getKind() == SqlKind.CAST && right.getKind() == SqlKind.CAST) {
-        return translateBinary2(((RexCall)left).operands.get(0), ((RexCall)right).operands.get(0));
+        return translateBinary2(((RexCall) left).operands.get(0), ((RexCall) right).operands.get(0));
       }
 
       // for WHERE clause like: pdatex >= '2021-07-13T15:12:10.037Z'
       if (left.getKind() == SqlKind.INPUT_REF && right.getKind() == SqlKind.CAST) {
-        final RexCall cast = ((RexCall)right);
+        final RexCall cast = ((RexCall) right);
         if (cast.operands.size() == 1 && cast.operands.get(0).getKind() == SqlKind.LITERAL) {
           return translateBinary2(left, cast.operands.get(0));
         }
@@ -401,6 +408,58 @@ class SolrFilter extends Filter implements SolrRel {
           return null;
       }
     }
+
+    /**
+     * A search node can be an IN or NOT IN clause or a BETWEEN
+     */
+    protected String translateSearch(RexNode condition) {
+      final String fieldName = getSolrFieldName(condition);
+
+      RexCall expanded = (RexCall) RexUtil.expandSearch(builder, null, condition);
+      final RexNode peekAt0 = !expanded.operands.isEmpty() ? expanded.operands.get(0) : null;
+      if (expanded.op.kind == SqlKind.AND) {
+        // See if NOT IN was translated into a big AND not
+        if (peekAt0 instanceof RexCall) {
+          RexCall op0 = (RexCall) peekAt0;
+          if (op0.op.kind == SqlKind.NOT_EQUALS) {
+            return "*:* -" + fieldName + ":" + toOrSetOnSameField(expanded);
+          }
+        }
+      } else if (expanded.op.kind == SqlKind.OR) {
+        if (peekAt0 instanceof RexCall) {
+          RexCall op0 = (RexCall) peekAt0;
+          if (op0.op.kind == SqlKind.EQUALS) {
+            return fieldName + ":" + toOrSetOnSameField(expanded);
+          }
+        }
+      }
+
+      if (expanded.getKind() != SqlKind.SEARCH) {
+        // passing a search back to translateMatch would lead to infinite recursion ...
+        return translateMatch(expanded);
+      }
+
+      // don't know how to handle this search!
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unsupported search filter: " + condition);
+    }
+
+    protected String toOrSetOnSameField(RexCall search) {
+      String orClause = search.operands.stream().map(n -> {
+        RexCall next = (RexCall) n;
+        RexLiteral lit = (RexLiteral) next.getOperands().get(1);
+        return "\"" + toSolrLiteral(lit) + "\"";
+      }).collect(Collectors.joining(" OR "));
+      return "(" + orClause + ")";
+    }
+
+    protected String getSolrFieldName(RexNode node) {
+      RexCall call = (RexCall) node;
+      final RexNode left = call.getOperands().get(0);
+      if (left instanceof RexInputRef) {
+        return fieldNames.get(((RexInputRef) left).getIndex());
+      }
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Expected Solr field name for " + call.getKind() + " but found " + left);
+    }
   }
 
   private static class HavingTranslator extends Translator {
diff --git a/solr/core/src/java/org/apache/solr/handler/sql/SolrSchema.java b/solr/core/src/java/org/apache/solr/handler/sql/SolrSchema.java
index 14f310245bb..36f12228fe5 100644
--- a/solr/core/src/java/org/apache/solr/handler/sql/SolrSchema.java
+++ b/solr/core/src/java/org/apache/solr/handler/sql/SolrSchema.java
@@ -138,8 +138,10 @@ class SolrSchema extends AbstractSchema implements Closeable {
     }
   }
 
-  private boolean isStoredOrDocValues(final EnumSet<FieldFlag> flags) {
-    return flags != null && (flags.contains(FieldFlag.STORED) || flags.contains(FieldFlag.DOC_VALUES));
+  private boolean isStoredIndexedOrDocValues(final EnumSet<FieldFlag> flags) {
+    // if a field is not stored but indexed, then we should still include it in the table schema so that users
+    // can filter on it, they just won't be able to return it as a field
+    return flags != null && (flags.contains(FieldFlag.DOC_VALUES) || flags.contains(FieldFlag.STORED) || flags.contains(FieldFlag.INDEXED));
   }
 
   private EnumSet<FieldFlag> getFieldFlags(final LukeResponse.FieldInfo luceneFieldInfo) {
@@ -172,13 +174,12 @@ class SolrSchema extends AbstractSchema implements Closeable {
     Map<String, LukeResponse.FieldInfo> fieldsInUseMap = getFieldInfo(collection);
 
     LukeResponse schema = getSchema(collection);
-    // Only want fields that are stored or have docValues enabled
     Map<String, LukeResponse.FieldInfo> storedFields = schema.getFieldInfo().entrySet().stream()
-            .filter(e -> isStoredOrDocValues(getFieldFlags(e.getValue())))
             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
     // merge the actual fields in use returned by Luke with the declared fields in the schema that are empty
     Map<String, LukeResponse.FieldInfo> combinedFields = Stream.of(fieldsInUseMap, storedFields)
             .flatMap(map -> map.entrySet().stream())
+            .filter(e -> isStoredIndexedOrDocValues(getFieldFlags(e.getValue()))) // Only want fields that are stored, indexed, or have docValues enabled
             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (v1, v2) -> v1, TreeMap::new));
 
     Map<String, Class<?>> javaClassForTypeMap = new HashMap<>(); // local cache for custom field types we've already resolved
diff --git a/solr/core/src/test/org/apache/solr/handler/TestSQLHandler.java b/solr/core/src/test/org/apache/solr/handler/TestSQLHandler.java
index db5f2a2f6f4..b0ec1f427ea 100644
--- a/solr/core/src/test/org/apache/solr/handler/TestSQLHandler.java
+++ b/solr/core/src/test/org/apache/solr/handler/TestSQLHandler.java
@@ -18,13 +18,16 @@ package org.apache.solr.handler;
 
 import java.io.IOException;
 import java.time.Instant;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.stream.Collectors;
 
+import org.apache.commons.lang3.StringUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.LuceneTestCase.Slow;
 import org.apache.solr.SolrTestCaseJ4;
@@ -2035,7 +2038,6 @@ public class TestSQLHandler extends SolrCloudTestCase {
     assertEquals("world-2", tuples.get(0).getString("a_s"));
     assertEquals("world-4", tuples.get(1).getString("a_s"));
     assertEquals("world-6", tuples.get(2).getString("a_s"));
-
     tuples = expectResults("SELECT a_s FROM $ALIAS WHERE a_s NOT LIKE 'hello%' AND b_s IS NOT NULL AND c_s IS NULL AND a_i NOT BETWEEN 2 AND 4 AND d_s IN ('a','b','c') ORDER BY id ASC LIMIT 10", 1);
     assertEquals("world-8", tuples.get(0).getString("a_s"));
   }
@@ -2398,4 +2400,96 @@ public class TestSQLHandler extends SolrCloudTestCase {
   private void expectAggCount(String mvField, int expCount) throws Exception {
     expectResults("SELECT COUNT(*), " + mvField + " FROM $ALIAS GROUP BY " + mvField, expCount);
   }
+
+  @Test
+  public void testManyInValues() throws Exception {
+    int maxSize = 1000;
+    int width = 4;
+    List<String> bigList = new ArrayList<>(maxSize);
+    for (int i=0; i < maxSize; i++) {
+      bigList.add(StringUtils.leftPad(String.valueOf(i), width, "0"));
+    }
+
+    UpdateRequest update = new UpdateRequest();
+    final int maxDocs = 10;
+    for (int i = 0; i < maxDocs; i++) {
+      SolrInputDocument doc = new SolrInputDocument("id", String.valueOf(i));
+      doc.setField("stringxmv", bigList);
+      update.add(doc);
+    }
+    update.add("id", String.valueOf(maxDocs)); // no stringxmv
+
+    SolrInputDocument doc = new SolrInputDocument("id", String.valueOf(maxDocs+1));
+    doc.setField("stringxmv", Arrays.asList("a", "b", "c"));
+    update.add(doc);
+
+    doc = new SolrInputDocument("id", String.valueOf(maxDocs+2));
+    doc.setField("stringxmv", Arrays.asList("d", "e", "f"));
+    update.add(doc);
+
+    update.commit(cluster.getSolrClient(), COLLECTIONORALIAS);
+
+    int numIn = 200;
+    List<String> bigInList = new ArrayList<>(bigList);
+    Collections.shuffle(bigInList, random());
+    bigInList = bigInList.subList(0, numIn).stream().map(s -> "'"+s+"'").collect(Collectors.toList());
+    String inClause = String.join(",", bigInList);
+    String sql = "SELECT id FROM $ALIAS WHERE stringxmv IN ("+inClause+") ORDER BY id ASC";
+    expectResults(sql, maxDocs);
+    sql = "SELECT * FROM $ALIAS WHERE stringxmv IN ("+inClause+") ORDER BY id ASC LIMIT "+maxDocs;
+    expectResults(sql, maxDocs);
+    sql = "SELECT id FROM $ALIAS WHERE stringxmv NOT IN ("+inClause+") ORDER BY id ASC";
+    expectResults(sql, 3);
+    sql = "SELECT id FROM $ALIAS WHERE stringxmv IS NOT NULL AND stringxmv NOT IN ("+inClause+") ORDER BY id ASC";
+    expectResults(sql, 2);
+    sql = "SELECT * FROM $ALIAS WHERE stringxmv IN ('a','d') ORDER BY id ASC LIMIT 10";
+    expectResults(sql, 2);
+  }
+
+  @Test
+  public void testNotAndOrLogic() throws Exception {
+    new UpdateRequest()
+        .add("id", "1", "a_s", "hello-1", "b_s", "foo", "c_s", "bar", "d_s", "x")
+        .add("id", "2", "a_s", "world-2", "b_s", "foo", "a_i", "2", "d_s", "a")
+        .add("id", "3", "a_s", "hello-3", "b_s", "foo", "c_s", "bar", "d_s", "x")
+        .add("id", "4", "a_s", "world-4", "b_s", "foo", "a_i", "3", "d_s", "b")
+        .commit(cluster.getSolrClient(), COLLECTIONORALIAS);
+
+    // single NOT clause
+    expectResults("SELECT id FROM $ALIAS WHERE a_s <> 'hello-1' ORDER BY id ASC LIMIT 10", 3);
+    expectResults("SELECT id FROM $ALIAS WHERE b_s NOT LIKE 'foo' ORDER BY id ASC LIMIT 10", 0);
+    expectResults("SELECT id FROM $ALIAS WHERE d_s NOT IN ('x','y') ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE a_i IS NULL ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE c_s IS NOT NULL ORDER BY id ASC LIMIT 10", 2);
+
+    expectResults("SELECT * FROM $ALIAS WHERE a_s='hello-1' AND d_s='x' ORDER BY id ASC LIMIT 10", 1);
+    expectResults("SELECT id FROM $ALIAS WHERE a_s='hello-1' AND d_s='x'", 1);
+
+    expectResults("SELECT * FROM $ALIAS WHERE a_s <> 'hello-1' AND d_s <> 'x' ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE a_s <> 'hello-1' AND d_s <> 'x'", 2);
+
+    expectResults("SELECT * FROM $ALIAS WHERE d_s <> 'x' ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE d_s <> 'x'", 2);
+
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s <> 'x' ORDER BY id ASC LIMIT 10", 0);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s <> 'x'", 0);
+
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT IN ('x') ORDER BY id ASC LIMIT 10", 0);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT IN ('x')", 0);
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT IN ('a') ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT IN ('a')", 2);
+
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT LIKE 'x' ORDER BY id ASC LIMIT 10", 0);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT LIKE 'x'", 0);
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT LIKE 'b' ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s NOT LIKE 'b'", 2);
+    expectResults("SELECT * FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s LIKE 'x' ORDER BY id ASC LIMIT 10", 2);
+    expectResults("SELECT id FROM $ALIAS WHERE (a_s = 'hello-1' OR a_s = 'hello-3') AND d_s LIKE 'x'", 2);
+
+    expectResults("SELECT * FROM $ALIAS WHERE a_s <> 'hello-1' AND b_s='foo' AND d_s IS NOT NULL AND a_i IS NULL AND c_s IN ('bar') ORDER BY id ASC LIMIT 10", 1);
+    expectResults("SELECT id FROM $ALIAS WHERE a_s <> 'hello-1' AND b_s='foo' AND d_s IS NOT NULL AND a_i IS NULL AND c_s IN ('bar')", 1);
+
+    // just a bunch of OR's that end up matching all docs
+    expectResults("SELECT id FROM $ALIAS WHERE a_s <> 'hello-1' OR a_i <> 2 OR d_s <> 'x' ORDER BY id ASC LIMIT 10", 4);
+  }
 }
diff --git a/solr/solr-ref-guide/src/parallel-sql-interface.adoc b/solr/solr-ref-guide/src/parallel-sql-interface.adoc
index c888ca9e6e3..b542df63cb0 100644
--- a/solr/solr-ref-guide/src/parallel-sql-interface.adoc
+++ b/solr/solr-ref-guide/src/parallel-sql-interface.adoc
@@ -321,6 +321,7 @@ The parallel SQL interface supports and pushes down most common SQL operators, s
 * IN, LIKE, BETWEEN support the NOT keyword to find rows where the condition is not true, such as `fielda NOT LIKE 'day%'`
 * String literals must be wrapped in single-quotes; double-quotes indicate database objects and not a string literal.
 * A simplistic LIKE can be used with an asterisk wildcard, such as `field = 'sam*'`; this is Solr specific and not part of the SQL standard.
+* The maximum number of values for an `IN` clause is limited by the `maxBooleanClauses` configured for your collection.
 * When performing ANDed range queries over a multi-valued field, Apache Calcite short-circuits to zero results if the ANDed predicates appear to be disjoint sets.
 For example, +++b_is <= 2 AND b_is >= 5+++ appears to Calcite to be disjoint sets, which they are from a single-valued field perspective.
 However, this may not be the case with multi-valued fields, as Solr might match documents.
@@ -368,6 +369,7 @@ Unlimited queries do not.
 Unlimited queries require the fields to be stored as a DocValues field.
 * Limited queries allow any indexed field in the `ORDER BY` list.
 Unlimited queries require the fields to be stored as a DocValues field.
+* If a field is indexed but not stored or has docValues, you can filter on the field but you cannot return it in results.
 
 === SELECT DISTINCT Queries
 
