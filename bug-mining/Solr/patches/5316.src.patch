diff --git a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 5d76a4886c2..5498d9202a8 100644
--- a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -326,7 +326,7 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
 
     try {
       try {
-        super.search(query, collector);
+        search(query, collector);
       } finally {
         // The complete() method can use the collectors, so this needs to be surrounded by the same
         // catch logic that limit collecting
@@ -782,24 +782,25 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
     return qr;
   }
 
-  /*@Override
-  TBD . This is overridden to exit the query when limits are reached
-  protected void search(List<LeafReaderContext> leaves, Weight weight, Collector collector)
-      throws IOException {
+  @Override
+  public void search(Query query, Collector collector) throws IOException {
     QueryLimits queryLimits = QueryLimits.getCurrentLimits();
-    if (EnvUtils.getPropertyAsBool(EXITABLE_READER_PROPERTY, Boolean.FALSE)
-        || !queryLimits.isLimitsEnabled()) {
+    if (!queryLimits.isLimitsEnabled()) {
       // no timeout.  Pass through to super class
-      super.search(leaves, weight, collector);
+      super.search(query, collector);
     } else {
       // Timeout enabled!  This impl is maybe a hack.  Use Lucene's IndexSearcher timeout.
       // But only some queries have it so don't use on "this" (SolrIndexSearcher), not to mention
       //   that timedOut() might race with concurrent queries (dubious design).
       // So we need to make a new IndexSearcher instead of using "this".
-      new IndexSearcher(reader) { // cheap, actually!
+      // Make sure to reuse the existing executor.
+      new IndexSearcher(
+          reader, core.getCoreContainer().getIndexSearcherExecutor()) { // cheap, actually!
         void searchWithTimeout() throws IOException {
           setTimeout(queryLimits); // Lucene's method name is less than ideal here...
-          super.search(leaves, weight, collector); // FYI protected access
+          // XXX Deprecated in Lucene 10, we should probably use search(Query, CollectorManager)
+          // instead
+          super.search(query, collector);
           if (timedOut()) {
             throw new QueryLimitsExceededException(
                 "Limits exceeded! (search): " + queryLimits.limitStatusMessage());
@@ -807,7 +808,7 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
         }
       }.searchWithTimeout();
     }
-  }*/
+  }
 
   /**
    * Retrieve the {@link Document} instance corresponding to the document id.
diff --git a/solr/core/src/test/org/apache/solr/search/TestQueryLimits.java b/solr/core/src/test/org/apache/solr/search/TestQueryLimits.java
index 01d7447c181..decc52da7a7 100644
--- a/solr/core/src/test/org/apache/solr/search/TestQueryLimits.java
+++ b/solr/core/src/test/org/apache/solr/search/TestQueryLimits.java
@@ -67,6 +67,7 @@ public class TestQueryLimits extends SolrCloudTestCase {
           "SearchHandler.handleRequestBody",
           "QueryComponent",
           "QueryComponent.process",
+          "TimeLimitingBulkScorer.score",
           "FacetComponent.process:2"
         };
     for (String matchingExpr : matchingExprTests) {
diff --git a/solr/test-framework/src/java/org/apache/solr/search/CallerSpecificQueryLimit.java b/solr/test-framework/src/java/org/apache/solr/search/CallerSpecificQueryLimit.java
index a979e1eff7d..0deed2273e9 100644
--- a/solr/test-framework/src/java/org/apache/solr/search/CallerSpecificQueryLimit.java
+++ b/solr/test-framework/src/java/org/apache/solr/search/CallerSpecificQueryLimit.java
@@ -21,11 +21,11 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;
 import org.slf4j.Logger;
@@ -53,10 +53,10 @@ public class CallerSpecificQueryLimit implements QueryLimit {
   // className -> set of method names
   private final Map<String, Set<String>> interestingCallers = new HashMap<>();
   // expr -> initial count
-  private final Map<String, Integer> maxCounts = new HashMap<>();
+  private final Map<String, Integer> maxCounts = new ConcurrentHashMap<>();
   // expr -> current count
-  private final Map<String, AtomicInteger> callCounts = new HashMap<>();
-  private Set<String> trippedBy = new LinkedHashSet<>();
+  private final Map<String, AtomicInteger> callCounts = new ConcurrentHashMap<>();
+  private Set<String> trippedBy = ConcurrentHashMap.newKeySet();
 
   /**
    * Signal a timeout in places that match the calling classes (and methods).
