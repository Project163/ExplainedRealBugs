diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 655f23d1d38..4216fd755d0 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -78,6 +78,8 @@ Bug Fixes
 
 * SOLR-16293: Luke request fails for document with a binary field (Kevin Risden)
 
+* SOLR-16477: Collection RENAME api creates broken alias (Alex Deparvu via Kevin Risden)
+
 Build
 ---------------------
 * Upgrade forbiddenapis to 3.4 (Uwe Schindler)
diff --git a/solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest.java b/solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest.java
index 0c1ed2ee46a..fbfe0778f69 100644
--- a/solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest.java
@@ -1045,7 +1045,7 @@ public class CollectionsAPISolrJTest extends SolrCloudTestCase {
     if (followAliases) {
       assertEquals(
           aliases.getCollectionAliasListMap().toString(),
-          collectionName2,
+          collectionName1,
           aliases.resolveSimpleAlias("foo"));
     }
     assertEquals(
@@ -1054,7 +1054,7 @@ public class CollectionsAPISolrJTest extends SolrCloudTestCase {
         aliases.resolveSimpleAlias("simpleAlias"));
     assertEquals(
         aliases.getCollectionAliasListMap().toString(),
-        collectionName2,
+        collectionName1,
         aliases.resolveSimpleAlias(collectionName1));
     // we renamed col1 -> col2 so the compound alias contains only "col2,col2" which is reduced to
     // col2
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/Aliases.java b/solr/solrj/src/java/org/apache/solr/common/cloud/Aliases.java
index dc80635c4c7..c29cdb6f5d8 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/Aliases.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/Aliases.java
@@ -66,7 +66,7 @@ public class Aliases {
    * Construct aliases directly with this information -- caller should not retain. Any deeply nested
    * collections are assumed to already be unmodifiable.
    */
-  private Aliases(
+  Aliases(
       Map<String, List<String>> collectionAliases,
       Map<String, Map<String, String>> collectionAliasProperties,
       int zNodeVersion) {
@@ -319,7 +319,7 @@ public class Aliases {
    */
   public Aliases cloneWithCollectionAlias(String alias, String collections) {
     if (alias == null) {
-      throw new NullPointerException("Alias name cannot be null");
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Alias name cannot be null");
     }
     Map<String, Map<String, String>> newColProperties;
     Map<String, List<String>> newColAliases =
@@ -364,7 +364,7 @@ public class Aliases {
    */
   public Aliases cloneWithRename(String before, String after) throws SolrException {
     if (before == null) {
-      throw new NullPointerException("'before' and 'after' cannot be null");
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "'before' cannot be null");
     }
     if (after == null) {
       return cloneWithCollectionAlias(before, after);
@@ -411,7 +411,7 @@ public class Aliases {
       }
     }
     if (level1 == null) { // create an alias that points to the collection
-      newColAliases.put(before, Collections.singletonList(after));
+      newColAliases.put(after, Collections.singletonList(before));
     }
     return new Aliases(newColAliases, newColProperties, zNodeVersion);
   }
diff --git a/solr/solrj/src/test/org/apache/solr/common/cloud/AliasesTest.java b/solr/solrj/src/test/org/apache/solr/common/cloud/AliasesTest.java
new file mode 100755
index 00000000000..1002eaf08a4
--- /dev/null
+++ b/solr/solrj/src/test/org/apache/solr/common/cloud/AliasesTest.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.common.cloud;
+
+import java.util.List;
+import java.util.Map;
+import org.apache.solr.SolrTestCase;
+import org.apache.solr.common.SolrException;
+
+/** Unit test for {@link Aliases} */
+public class AliasesTest extends SolrTestCase {
+
+  public void testCloneWithRenameNullBefore() {
+    Aliases aliases = Aliases.EMPTY;
+    SolrException e =
+        assertThrows(SolrException.class, () -> aliases.cloneWithRename(null, "alias1"));
+    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());
+  }
+
+  public void testCloneWithRenameEmptyBefore() {
+    Aliases aliases = Aliases.EMPTY;
+    SolrException e =
+        assertThrows(SolrException.class, () -> aliases.cloneWithRename("", "alias1"));
+    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());
+  }
+
+  public void testCloneWithRenameEmptyAfter() {
+    Aliases aliases = Aliases.EMPTY;
+    SolrException e =
+        assertThrows(SolrException.class, () -> aliases.cloneWithRename("alias0", ""));
+    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());
+  }
+
+  public void testCloneWithRenameBeforeEqAfter() {
+    Aliases aliases = Aliases.EMPTY;
+    Aliases same = aliases.cloneWithRename("same", "same");
+    assertEquals(same, aliases);
+  }
+
+  public void testCloneWithRenameNewAlias() {
+    Map<String, List<String>> collectionAliases = Map.of();
+    Map<String, Map<String, String>> collectionAliasProperties = Map.of();
+    Aliases aliases = new Aliases(collectionAliases, collectionAliasProperties, -1);
+    Aliases renamed = aliases.cloneWithRename("col0", "alias0");
+    Map<String, String> expected = Map.of("alias0", "col0");
+    assertEquals(expected, renamed.getCollectionAliasMap());
+  }
+
+  public void testCloneWithRename() {
+    Map<String, List<String>> collectionAliases =
+        Map.of("alias0", List.of("col0"), "alias5", List.of("col5", "col0", "col7"));
+    Map<String, Map<String, String>> collectionAliasProperties = Map.of("col0", Map.of("p0", "v0"));
+    Aliases aliases = new Aliases(collectionAliases, collectionAliasProperties, -1);
+    Aliases renamed = aliases.cloneWithRename("col0", "alias1");
+    Map<String, String> expected =
+        Map.of("alias0", "alias1", "alias1", "col0", "alias5", "col5,alias1,col7");
+    assertEquals(expected, renamed.getCollectionAliasMap());
+    assertEquals(Map.of(), renamed.getCollectionAliasProperties("col0"));
+    assertEquals(Map.of("p0", "v0"), renamed.getCollectionAliasProperties("alias1"));
+  }
+
+  public void testCloneWithCollectionAliasNullAlias() {
+    Aliases aliases = Aliases.EMPTY;
+    SolrException e =
+        assertThrows(SolrException.class, () -> aliases.cloneWithCollectionAlias(null, "col"));
+    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());
+  }
+
+  public void testCloneWithCollectionAlias() {
+    Map<String, List<String>> collectionAliases =
+        Map.of("alias0", List.of("col0"), "alias5", List.of("col5", "col0", "col7"));
+    Map<String, Map<String, String>> collectionAliasProperties =
+        Map.of("alias0", Map.of("p0", "v0"));
+    Aliases aliases = new Aliases(collectionAliases, collectionAliasProperties, -1);
+    Aliases cloned = aliases.cloneWithCollectionAlias("alias7", "col9");
+
+    Map<String, String> expected =
+        Map.of("alias0", "col0", "alias5", "col5,col0,col7", "alias7", "col9");
+    assertEquals(expected, cloned.getCollectionAliasMap());
+    assertEquals(Map.of("p0", "v0"), cloned.getCollectionAliasProperties("alias0"));
+    assertEquals(Map.of(), cloned.getCollectionAliasProperties("alias7"));
+  }
+
+  public void testCloneWithCollectionAliasRemoval() {
+    Map<String, List<String>> collectionAliases =
+        Map.of("alias0", List.of("col0"), "alias5", List.of("col5", "col0", "col7"));
+    Map<String, Map<String, String>> collectionAliasProperties =
+        Map.of("alias0", Map.of("p0", "v0"));
+    Aliases aliases = new Aliases(collectionAliases, collectionAliasProperties, -1);
+    Aliases cloned = aliases.cloneWithCollectionAlias("alias0", null);
+
+    Map<String, String> expected = Map.of("alias5", "col5,col0,col7");
+    assertEquals(expected, cloned.getCollectionAliasMap());
+    assertEquals(Map.of(), cloned.getCollectionAliasProperties("alias0"));
+  }
+}
