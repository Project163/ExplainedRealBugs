diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory.java
index 9407d1dd354..1bd4334976a 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory.java
@@ -849,43 +849,43 @@ public class ExpressionFactory {
   public static interface ConstantFunction {
     AnalyticsValueStream apply(String t) throws SolrException;
   }
+  static class VariableFunctionInfo {
+    public String[] params;
+    public String returnSignature;
+  }
+  static class WeightedMeanVariableFunction {
+    public static final String name = "wmean";
+    public static final String params = "a,b";
+    public static final String function = DivideFunction.name+"("+SumFunction.name+"("+MultFunction.name+"(a,b)),"+SumFunction.name+"("+FilterFunction.name+"(b,"+ExistsFunction.name+"(a))))";
+  }
+  static class SumOfSquaresVariableFunction {
+    public static final String name = "sumofsquares";
+    public static final String params = "a";
+    public static final String function = SumFunction.name+"("+PowerFunction.name+"(a,2))";
+  }
+  static class SquareRootVariableFunction {
+    public static final String name = "sqrt";
+    public static final String params = "a";
+    public static final String function = PowerFunction.name+"(a,0.5)";
+  }
+  static class VarianceVariableFunction {
+    public static final String name = "variance";
+    public static final String params = "a";
+    public static final String function = SubtractFunction.name+"("+MeanFunction.name+"("+PowerFunction.name+"(a,2)),"+PowerFunction.name+"("+MeanFunction.name+"(a),2))";
+  }
+  static class SandardDeviationVariableFunction {
+    public static final String name = "stddev";
+    public static final String params = "a";
+    public static final String function = SquareRootVariableFunction.name+"("+VarianceVariableFunction.name+"(a))";
+  }
+  static class CSVVariableFunction {
+    public static final String name = "csv";
+    public static final String params = "a"+ExpressionFactory.variableLengthParamSuffix;
+    public static final String function = SeparatedConcatFunction.name+"(',',a)";
+  }
+  static class CSVOutputVariableFunction {
+    public static final String name = "csv_output";
+    public static final String params = "a"+ExpressionFactory.variableLengthParamSuffix;
+    public static final String function = "concat_sep(',',a"+ExpressionFactory.variableForEachSep+FillMissingFunction.name+"("+SeparatedConcatFunction.name+"(';',"+ExpressionFactory.variableForEachParam+"),''))";
+  }
 }
-class VariableFunctionInfo {
-  public String[] params;
-  public String returnSignature;
-}
-class WeightedMeanVariableFunction {
-  public static final String name = "wmean";
-  public static final String params = "a,b";
-  public static final String function = DivideFunction.name+"("+SumFunction.name+"("+MultFunction.name+"(a,b)),"+SumFunction.name+"("+FilterFunction.name+"(b,"+ExistsFunction.name+"(a))))";
-}
-class SumOfSquaresVariableFunction {
-  public static final String name = "sumofsquares";
-  public static final String params = "a";
-  public static final String function = SumFunction.name+"("+PowerFunction.name+"(a,2))";
-}
-class SquareRootVariableFunction {
-  public static final String name = "sqrt";
-  public static final String params = "a";
-  public static final String function = PowerFunction.name+"(a,0.5)";
-}
-class VarianceVariableFunction {
-  public static final String name = "variance";
-  public static final String params = "a";
-  public static final String function = SubtractFunction.name+"("+MeanFunction.name+"("+PowerFunction.name+"(a,2)),"+PowerFunction.name+"("+MeanFunction.name+"(a),2))";
-}
-class SandardDeviationVariableFunction {
-  public static final String name = "stddev";
-  public static final String params = "a";
-  public static final String function = SquareRootVariableFunction.name+"("+VarianceVariableFunction.name+"(a))";
-}
-class CSVVariableFunction {
-  public static final String name = "csv";
-  public static final String params = "a"+ExpressionFactory.variableLengthParamSuffix;
-  public static final String function = SeparatedConcatFunction.name+"(',',a)";
-}
-class CSVOutputVariableFunction {
-  public static final String name = "csv_output";
-  public static final String params = "a"+ExpressionFactory.variableLengthParamSuffix;
-  public static final String function = "concat_sep(',',a"+ExpressionFactory.variableForEachSep+FillMissingFunction.name+"("+SeparatedConcatFunction.name+"(';',"+ExpressionFactory.variableForEachParam+"),''))";
-}
\ No newline at end of file
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/facet/PivotFacet.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/facet/PivotFacet.java
index d06bba80459..d6ff05e19aa 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/facet/PivotFacet.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/facet/PivotFacet.java
@@ -72,43 +72,44 @@ public class PivotFacet extends AnalyticsFacet implements StreamingFacet {
   public Iterable<Map<String,Object>> createResponse() {
     return pivotHead.createResponse();
   }
-}
-/**
- * Typed Pivot class that stores the overall Pivot data and head of the Pivot node chain.
- *
- * This class exists so that the {@link PivotFacet} class doesn't have to be typed ( {@code <T>} ).
- */
-class PivotHead<T> implements StreamingFacet {
-  private final PivotNode<T> topPivot;
-  private final Map<String, T> pivotValues;
-
-  public PivotHead(PivotNode<T> topPivot) {
-    this.topPivot = topPivot;
-    this.pivotValues = new HashMap<>();
-  }
-
-  public void setReductionCollectionManager(ReductionCollectionManager collectionManager) {
-    topPivot.setReductionCollectionManager(collectionManager);
-  }
-
-  public void setExpressionCalculator(ExpressionCalculator expressionCalculator) {
-    topPivot.setExpressionCalculator(expressionCalculator);
-  }
 
-  @Override
-  public void addFacetValueCollectionTargets() {
-    topPivot.addFacetValueCollectionTargets(pivotValues);
-  }
-
-  public void importShardData(DataInput input) throws IOException {
-    topPivot.importPivot(input, pivotValues);
-  }
-
-  public void exportShardData(DataOutput output) throws IOException {
-    topPivot.exportPivot(output, pivotValues);
-  }
-
-  public Iterable<Map<String,Object>> createResponse() {
-    return topPivot.getPivotedResponse(pivotValues);
+  /**
+   * Typed Pivot class that stores the overall Pivot data and head of the Pivot node chain.
+   *
+   * This class exists so that the {@link PivotFacet} class doesn't have to be typed ( {@code <T>} ).
+   */
+  private static class PivotHead<T> implements StreamingFacet {
+    private final PivotNode<T> topPivot;
+    private final Map<String, T> pivotValues;
+
+    public PivotHead(PivotNode<T> topPivot) {
+      this.topPivot = topPivot;
+      this.pivotValues = new HashMap<>();
+    }
+
+    public void setReductionCollectionManager(ReductionCollectionManager collectionManager) {
+      topPivot.setReductionCollectionManager(collectionManager);
+    }
+
+    public void setExpressionCalculator(ExpressionCalculator expressionCalculator) {
+      topPivot.setExpressionCalculator(expressionCalculator);
+    }
+
+    @Override
+    public void addFacetValueCollectionTargets() {
+      topPivot.addFacetValueCollectionTargets(pivotValues);
+    }
+
+    public void importShardData(DataInput input) throws IOException {
+      topPivot.importPivot(input, pivotValues);
+    }
+
+    public void exportShardData(DataOutput output) throws IOException {
+      topPivot.exportPivot(output, pivotValues);
+    }
+
+    public Iterable<Map<String,Object>> createResponse() {
+      return topPivot.getPivotedResponse(pivotValues);
+    }
   }
-}
\ No newline at end of file
+}
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ComparisonFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ComparisonFunction.java
index 1ecc930c44c..4b7497d1b1d 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ComparisonFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ComparisonFunction.java
@@ -17,7 +17,6 @@
 package org.apache.solr.analytics.function.mapping;
 
 import org.apache.solr.analytics.ExpressionFactory.CreatorFunction;
-import org.apache.solr.analytics.function.mapping.ComparisonFunction.CompResultFunction;
 import org.apache.solr.analytics.util.function.BooleanConsumer;
 import org.apache.solr.analytics.value.AnalyticsValue;
 import org.apache.solr.analytics.value.AnalyticsValueStream;
@@ -141,178 +140,183 @@ public class ComparisonFunction {
   private static CompResultFunction reverse(CompResultFunction original) {
     return val -> original.apply(val*-1);
   }
-}
-/**
- * A comparison function for two {@link DoubleValue}s.
- */
-class CompareDoubleValueFunction extends AbstractBooleanValue {
-  private final DoubleValue exprA;
-  private final DoubleValue exprB;
-  private final CompResultFunction comp;
-  private final String name;
-  private final String funcStr;
-  private final ExpressionType funcType;
 
-  public CompareDoubleValueFunction(String name, DoubleValue exprA, DoubleValue exprB, CompResultFunction comp) {
-    this.name = name;
-    this.exprA = exprA;
-    this.exprB = exprB;
-    this.comp = comp;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
-  }
+  /**
+   * A comparison function for two {@link DoubleValue}s.
+   */
+  static class CompareDoubleValueFunction extends AbstractBooleanValue {
+    private final DoubleValue exprA;
+    private final DoubleValue exprB;
+    private final CompResultFunction comp;
+    private final String name;
+    private final String funcStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
-  @Override
-  public boolean getBoolean() {
-    double valueA = exprA.getDouble();
-    double valueB = exprB.getDouble();
-    exists = exprA.exists() && exprB.exists();
-    return exists ? comp.apply(Double.compare(valueA,valueB)) : false;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public CompareDoubleValueFunction(String name, DoubleValue exprA, DoubleValue exprB, CompResultFunction comp) {
+      this.name = name;
+      this.exprA = exprA;
+      this.exprB = exprB;
+      this.comp = comp;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A comparison function for a {@link DoubleValue} and a {@link DoubleValueStream}.
- */
-class CompareDoubleStreamFunction extends AbstractBooleanValueStream {
-  private final DoubleValue baseExpr;
-  private final DoubleValueStream compExpr;
-  private final CompResultFunction comp;
-  private final String name;
-  private final String funcStr;
-  private final ExpressionType funcType;
+    private boolean exists = false;
+    @Override
+    public boolean getBoolean() {
+      double valueA = exprA.getDouble();
+      double valueB = exprB.getDouble();
+      exists = exprA.exists() && exprB.exists();
+      return exists ? comp.apply(Double.compare(valueA,valueB)) : false;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public CompareDoubleStreamFunction(String name, DoubleValue baseExpr, DoubleValueStream compExpr, CompResultFunction comp) throws SolrException {
-    this.name = name;
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.comp = comp;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    double baseValue = baseExpr.getDouble();
-    if (baseExpr.exists()) {
-      compExpr.streamDoubles(compValue -> cons.accept(comp.apply(Double.compare(baseValue,compValue))));
+  /**
+   * A comparison function for a {@link DoubleValue} and a {@link DoubleValueStream}.
+   */
+  static class CompareDoubleStreamFunction extends AbstractBooleanValueStream {
+    private final DoubleValue baseExpr;
+    private final DoubleValueStream compExpr;
+    private final CompResultFunction comp;
+    private final String name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public CompareDoubleStreamFunction(String name, DoubleValue baseExpr, DoubleValueStream compExpr, CompResultFunction comp) throws SolrException {
+      this.name = name;
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.comp = comp;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A comparison function for two {@link DateValue}s.
- */
-class CompareDateValueFunction extends AbstractBooleanValue {
-  private final DateValue exprA;
-  private final DateValue exprB;
-  private final CompResultFunction comp;
-  private final String name;
-  private final String funcStr;
-  private final ExpressionType funcType;
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      double baseValue = baseExpr.getDouble();
+      if (baseExpr.exists()) {
+        compExpr.streamDoubles(compValue -> cons.accept(comp.apply(Double.compare(baseValue,compValue))));
+      }
+    }
 
-  public CompareDateValueFunction(String name, DateValue exprA, DateValue exprB, CompResultFunction comp) {
-    this.name = name;
-    this.exprA = exprA;
-    this.exprB = exprB;
-    this.comp = comp;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  private boolean exists = false;
-  @Override
-  public boolean getBoolean() {
-    long valueA = exprA.getLong();
-    long valueB = exprB.getLong();
-    exists = exprA.exists() && exprB.exists();
-    return exists ? comp.apply(Long.compare(valueA,valueB)) : false;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+  /**
+   * A comparison function for two {@link DateValue}s.
+   */
+  static class CompareDateValueFunction extends AbstractBooleanValue {
+    private final DateValue exprA;
+    private final DateValue exprB;
+    private final CompResultFunction comp;
+    private final String name;
+    private final String funcStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A comparison function for a {@link DateValue} and a {@link DateValueStream}.
- */
-class CompareDateStreamFunction extends AbstractBooleanValueStream {
-  private final DateValue baseExpr;
-  private final DateValueStream compExpr;
-  private final CompResultFunction comp;
-  private final String name;
-  private final String funcStr;
-  private final ExpressionType funcType;
+    public CompareDateValueFunction(String name, DateValue exprA, DateValue exprB, CompResultFunction comp) {
+      this.name = name;
+      this.exprA = exprA;
+      this.exprB = exprB;
+      this.comp = comp;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
+    }
 
-  public CompareDateStreamFunction(String name, DateValue baseExpr, DateValueStream compExpr, CompResultFunction comp) throws SolrException {
-    this.name = name;
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.comp = comp;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
-  }
+    private boolean exists = false;
+    @Override
+    public boolean getBoolean() {
+      long valueA = exprA.getLong();
+      long valueB = exprB.getLong();
+      exists = exprA.exists() && exprB.exists();
+      return exists ? comp.apply(Long.compare(valueA,valueB)) : false;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    long baseValue = baseExpr.getLong();
-    if (baseExpr.exists()) {
-      compExpr.streamLongs(compValue -> cons.accept(comp.apply(Long.compare(baseValue,compValue))));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  /**
+   * A comparison function for a {@link DateValue} and a {@link DateValueStream}.
+   */
+  static class CompareDateStreamFunction extends AbstractBooleanValueStream {
+    private final DateValue baseExpr;
+    private final DateValueStream compExpr;
+    private final CompResultFunction comp;
+    private final String name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public CompareDateStreamFunction(String name, DateValue baseExpr, DateValueStream compExpr, CompResultFunction comp) throws SolrException {
+      this.name = name;
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.comp = comp;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
+    }
+
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      long baseValue = baseExpr.getLong();
+      if (baseExpr.exists()) {
+        compExpr.streamLongs(compValue -> cons.accept(comp.apply(Long.compare(baseValue,compValue))));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateMathFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateMathFunction.java
index 8a5756144ab..93fee3e3e91 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateMathFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateMathFunction.java
@@ -62,97 +62,100 @@ public class DateMathFunction {
       throw new SolrException(ErrorCode.BAD_REQUEST,"The "+name+" function requires a date as the first parameter.");
     }
   });
-}
-/**
- * DateMath function that supports {@link DateValue}s.
- */
-class DateMathValueFunction extends AbstractDateValue {
-  private final DateValue dateParam;
-  private final String mathParam;
-  DateMathParser parser = new DateMathParser();
-  public static final String name = DateMathFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateMathValueFunction(DateValue dateParam, ConstantStringValue mathParam) throws SolrException {
-    this.dateParam = dateParam;
-    this.mathParam = "NOW" + mathParam.getString();
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,dateParam,mathParam);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,dateParam);
-  }
+  /**
+   * DateMath function that supports {@link DateValue}s.
+   */
+  static class DateMathValueFunction extends AbstractDateValue {
+    private final DateValue dateParam;
+    private final String mathParam;
+    DateMathParser parser = new DateMathParser();
+    public static final String name = DateMathFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
+    public DateMathValueFunction(DateValue dateParam, ConstantStringValue mathParam) throws SolrException {
+      this.dateParam = dateParam;
+      this.mathParam = "NOW" + mathParam.getString();
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,dateParam,mathParam);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,dateParam);
+    }
 
-  @Override
-  public long getLong() {
-    Date date = getDate();
-    return (exists) ? date.getTime() : 0;
-  }
-  @Override
-  public Date getDate() {
-    Date date = dateParam.getDate();
-    if (dateParam.exists()) {
-      exists = true;
-      return DateMathParser.parseMath(date,mathParam);
-    } else {
-      exists = false;
-      return null;
+    private boolean exists = false;
+
+    @Override
+    public long getLong() {
+      Date date = getDate();
+      return (exists) ? date.getTime() : 0;
+    }
+    @Override
+    public Date getDate() {
+      Date date = dateParam.getDate();
+      if (dateParam.exists()) {
+        exists = true;
+        return DateMathParser.parseMath(date,mathParam);
+      } else {
+        exists = false;
+        return null;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-/**
- * DateMath function that supports {@link DateValueStream}s.
- */
-class DateMathStreamFunction extends AbstractDateValueStream {
-  private final DateValueStream dateParam;
-  private final String mathParam;
-  public static final String name = DateMathFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateMathStreamFunction(DateValueStream dateParam, ConstantStringValue mathParam) throws SolrException {
-    this.dateParam = dateParam;
-    this.mathParam = "NOW" + mathParam.getString();
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,dateParam,mathParam);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,dateParam);
-  }
+  /**
+   * DateMath function that supports {@link DateValueStream}s.
+   */
+  static class DateMathStreamFunction extends AbstractDateValueStream {
+    private final DateValueStream dateParam;
+    private final String mathParam;
+    public static final String name = DateMathFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    streamDates(value -> cons.accept(value.getTime()));
-  }
-  @Override
-  public void streamDates(Consumer<Date> cons) {
-    dateParam.streamDates(value -> cons.accept(DateMathParser.parseMath(value, mathParam)));
-  }
+    public DateMathStreamFunction(DateValueStream dateParam, ConstantStringValue mathParam) throws SolrException {
+      this.dateParam = dateParam;
+      this.mathParam = "NOW" + mathParam.getString();
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,dateParam,mathParam);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,dateParam);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      streamDates(value -> cons.accept(value.getTime()));
+    }
+    @Override
+    public void streamDates(Consumer<Date> cons) {
+      dateParam.streamDates(value -> cons.accept(DateMathParser.parseMath(value, mathParam)));
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateParseFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateParseFunction.java
index 83c0ba7256d..9462e438552 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateParseFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DateParseFunction.java
@@ -61,146 +61,151 @@ public class DateParseFunction {
           "Incorrect parameter: "+params[0].getExpressionStr());
     }
   });
-}
-class LongToDateParseFunction extends AbstractDateValue {
-  private final LongValue param;
-  public static final String name = DateParseFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongToDateParseFunction(LongValue param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
 
-  @Override
-  public long getLong() {
-    return param.getLong();
-  }
-  @Override
-  public boolean exists() {
-    return param.exists();
-  }
+  static class LongToDateParseFunction extends AbstractDateValue {
+    private final LongValue param;
+    public static final String name = DateParseFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamToDateParseFunction extends AbstractDateValueStream {
-  private final LongValueStream param;
-  public static final String name = DateParseFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamToDateParseFunction(LongValueStream param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+    public LongToDateParseFunction(LongValue param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    param.streamLongs(cons);
-  }
+    @Override
+    public long getLong() {
+      return param.getLong();
+    }
+    @Override
+    public boolean exists() {
+      return param.exists();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringToDateParseFunction extends AbstractDateValue {
-  private final StringValue param;
-  public static final String name = DateParseFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringToDateParseFunction(StringValue param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  private boolean exists = false;
-  @Override
-  public long getLong() {
-    long value = 0;
-    try {
-      String paramStr = param.getString();
-      exists = param.exists();
-      if (exists) {
-        value = Instant.parse(paramStr).toEpochMilli();
-      }
-    } catch (DateTimeParseException e) {
-      exists = false;
+  static class LongStreamToDateParseFunction extends AbstractDateValueStream {
+    private final LongValueStream param;
+    public static final String name = DateParseFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongStreamToDateParseFunction(LongValueStream param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamToDateParseFunction extends AbstractDateValueStream {
-  private final StringValueStream param;
-  public static final String name = DateParseFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamToDateParseFunction(StringValueStream param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      param.streamLongs(cons);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    param.streamStrings(value -> {
+  static class StringToDateParseFunction extends AbstractDateValue {
+    private final StringValue param;
+    public static final String name = DateParseFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringToDateParseFunction(StringValue param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
+    @Override
+    public long getLong() {
+      long value = 0;
       try {
-        cons.accept(Instant.parse(value).toEpochMilli());
-      } catch (DateTimeParseException e) {}
-    });
-  }
+        String paramStr = param.getString();
+        exists = param.exists();
+        if (exists) {
+          value = Instant.parse(paramStr).toEpochMilli();
+        }
+      } catch (DateTimeParseException e) {
+        exists = false;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  static class StringStreamToDateParseFunction extends AbstractDateValueStream {
+    private final StringValueStream param;
+    public static final String name = DateParseFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamToDateParseFunction(StringValueStream param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      param.streamStrings(value -> {
+        try {
+          cons.accept(Instant.parse(value).toEpochMilli());
+        } catch (DateTimeParseException e) {}
+      });
+    }
+
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 }
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DecimalNumericConversionFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DecimalNumericConversionFunction.java
index c8881ee7b22..0247da83b56 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DecimalNumericConversionFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/DecimalNumericConversionFunction.java
@@ -20,8 +20,6 @@ import java.util.function.IntConsumer;
 import java.util.function.LongConsumer;
 
 import org.apache.solr.analytics.ExpressionFactory.CreatorFunction;
-import org.apache.solr.analytics.function.mapping.DecimalNumericConversionFunction.ConvertDoubleFunction;
-import org.apache.solr.analytics.function.mapping.DecimalNumericConversionFunction.ConvertFloatFunction;
 import org.apache.solr.analytics.value.AnalyticsValueStream;
 import org.apache.solr.analytics.value.DoubleValue;
 import org.apache.solr.analytics.value.DoubleValueStream;
@@ -116,156 +114,161 @@ public class DecimalNumericConversionFunction {
   public static interface ConvertDoubleFunction {
     public long convert(double value);
   }
-}
-/**
- * A function to convert a {@link FloatValue} to a {@link IntValue}.
- */
-class ConvertFloatValueFunction extends AbstractIntValue {
-  private final String name;
-  private final FloatValue param;
-  private final ConvertFloatFunction conv;
-  private final String funcStr;
-  private final ExpressionType funcType;
 
-  public ConvertFloatValueFunction(String name, FloatValue param, ConvertFloatFunction conv) {
-    this.name = name;
-    this.param = param;
-    this.conv = conv;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
-  }
+  /**
+   * A function to convert a {@link FloatValue} to a {@link IntValue}.
+   */
+  static class ConvertFloatValueFunction extends AbstractIntValue {
+    private final String name;
+    private final FloatValue param;
+    private final ConvertFloatFunction conv;
+    private final String funcStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public int getInt() {
-    return conv.convert(param.getFloat());
-  }
-  @Override
-  public boolean exists() {
-    return param.exists();
-  }
+    public ConvertFloatValueFunction(String name, FloatValue param, ConvertFloatFunction conv) {
+      this.name = name;
+      this.param = param;
+      this.conv = conv;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A function to convert a {@link FloatValueStream} to a {@link IntValueStream}.
- */
-class ConvertFloatStreamFunction extends AbstractIntValueStream {
-  private final String name;
-  private final FloatValueStream param;
-  private final ConvertFloatFunction conv;
-  private final String funcStr;
-  private final ExpressionType funcType;
+    @Override
+    public int getInt() {
+      return conv.convert(param.getFloat());
+    }
+    @Override
+    public boolean exists() {
+      return param.exists();
+    }
 
-  public ConvertFloatStreamFunction(String name, FloatValueStream param, ConvertFloatFunction conv) {
-    this.name = name;
-    this.param = param;
-    this.conv = conv;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    param.streamFloats( value -> cons.accept(conv.convert(value)));
-  }
+  /**
+   * A function to convert a {@link FloatValueStream} to a {@link IntValueStream}.
+   */
+  static class ConvertFloatStreamFunction extends AbstractIntValueStream {
+    private final String name;
+    private final FloatValueStream param;
+    private final ConvertFloatFunction conv;
+    private final String funcStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A function to convert a {@link DoubleValue} to a {@link LongValue}.
- */
-class ConvertDoubleValueFunction extends AbstractLongValue {
-  private final String name;
-  private final DoubleValue param;
-  private final ConvertDoubleFunction conv;
-  private final String funcStr;
-  private final ExpressionType funcType;
+    public ConvertFloatStreamFunction(String name, FloatValueStream param, ConvertFloatFunction conv) {
+      this.name = name;
+      this.param = param;
+      this.conv = conv;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
+    }
 
-  public ConvertDoubleValueFunction(String name, DoubleValue param, ConvertDoubleFunction conv) {
-    this.name = name;
-    this.param = param;
-    this.conv = conv;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
-  }
+    @Override
+    public void streamInts(IntConsumer cons) {
+      param.streamFloats( value -> cons.accept(conv.convert(value)));
+    }
 
-  @Override
-  public long getLong() {
-    return conv.convert(param.getDouble());
-  }
-  @Override
-  public boolean exists() {
-    return param.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A function to convert a {@link DoubleValueStream} to a {@link LongValueStream}.
- */
-class ConvertDoubleStreamFunction extends AbstractLongValueStream {
-  private final String name;
-  private final DoubleValueStream param;
-  private final ConvertDoubleFunction conv;
-  private final String funcStr;
-  private final ExpressionType funcType;
+  /**
+   * A function to convert a {@link DoubleValue} to a {@link LongValue}.
+   */
+  static class ConvertDoubleValueFunction extends AbstractLongValue {
+    private final String name;
+    private final DoubleValue param;
+    private final ConvertDoubleFunction conv;
+    private final String funcStr;
+    private final ExpressionType funcType;
 
-  public ConvertDoubleStreamFunction(String name, DoubleValueStream param, ConvertDoubleFunction conv) {
-    this.name = name;
-    this.param = param;
-    this.conv = conv;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
-  }
+    public ConvertDoubleValueFunction(String name, DoubleValue param, ConvertDoubleFunction conv) {
+      this.name = name;
+      this.param = param;
+      this.conv = conv;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    param.streamDoubles( value -> cons.accept(conv.convert(value)));
-  }
+    @Override
+    public long getLong() {
+      return conv.convert(param.getDouble());
+    }
+    @Override
+    public boolean exists() {
+      return param.exists();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  /**
+   * A function to convert a {@link DoubleValueStream} to a {@link LongValueStream}.
+   */
+  static class ConvertDoubleStreamFunction extends AbstractLongValueStream {
+    private final String name;
+    private final DoubleValueStream param;
+    private final ConvertDoubleFunction conv;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public ConvertDoubleStreamFunction(String name, DoubleValueStream param, ConvertDoubleFunction conv) {
+      this.name = name;
+      this.param = param;
+      this.conv = conv;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,param);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      param.streamDoubles( value -> cons.accept(conv.convert(value)));
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/EqualFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/EqualFunction.java
index 18a8bce206d..9d1bbf20da4 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/EqualFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/EqualFunction.java
@@ -73,166 +73,171 @@ public class EqualFunction {
     }
     throw new SolrException(ErrorCode.BAD_REQUEST,"The "+name+" function requires that at least 1 parameter be single-valued.");
   });
-}
-/**
- * An equal function for two {@link BooleanValue}s.
- */
-class BooleanValueEqualFunction extends AbstractBooleanValue {
-  private final BooleanValue exprA;
-  private final BooleanValue exprB;
-  public static final String name = EqualFunction.name;
-  private final String funcStr;
-  private final ExpressionType funcType;
-
-  public BooleanValueEqualFunction(BooleanValue exprA, BooleanValue exprB) {
-    this.exprA = exprA;
-    this.exprB = exprB;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
-  }
 
-  private boolean exists = false;
-  @Override
-  public boolean getBoolean() {
-    boolean valueA = exprA.getBoolean();
-    boolean valueB = exprB.getBoolean();
-    exists = exprA.exists() && exprB.exists();
-    return exists ? valueA == valueB : false;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+  /**
+   * An equal function for two {@link BooleanValue}s.
+   */
+  static class BooleanValueEqualFunction extends AbstractBooleanValue {
+    private final BooleanValue exprA;
+    private final BooleanValue exprB;
+    public static final String name = EqualFunction.name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public BooleanValueEqualFunction(BooleanValue exprA, BooleanValue exprB) {
+      this.exprA = exprA;
+      this.exprB = exprB;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * An equal function for a {@link BooleanValue} and a {@link BooleanValueStream}.
- */
-class BooleanStreamEqualFunction extends AbstractBooleanValueStream {
-  private final BooleanValue baseExpr;
-  private final BooleanValueStream compExpr;
-  public static final String name = EqualFunction.name;
-  private final String funcStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamEqualFunction(BooleanValue baseExpr, BooleanValueStream compExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
-  }
+    private boolean exists = false;
+    @Override
+    public boolean getBoolean() {
+      boolean valueA = exprA.getBoolean();
+      boolean valueB = exprB.getBoolean();
+      exists = exprA.exists() && exprB.exists();
+      return exists ? valueA == valueB : false;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean baseValue = baseExpr.getBoolean();
-    if (baseExpr.exists()) {
-      compExpr.streamBooleans(compValue -> cons.accept(baseValue == compValue));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A catch-all equal function for two {@link AnalyticsValue}s.
- */
-class ValueEqualFunction extends AbstractBooleanValue {
-  private final AnalyticsValue exprA;
-  private final AnalyticsValue exprB;
-  public static final String name = EqualFunction.name;
-  private final String funcStr;
-  private final ExpressionType funcType;
-
-  public ValueEqualFunction(AnalyticsValue exprA, AnalyticsValue exprB) {
-    this.exprA = exprA;
-    this.exprB = exprB;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
-  }
+  /**
+   * An equal function for a {@link BooleanValue} and a {@link BooleanValueStream}.
+   */
+  static class BooleanStreamEqualFunction extends AbstractBooleanValueStream {
+    private final BooleanValue baseExpr;
+    private final BooleanValueStream compExpr;
+    public static final String name = EqualFunction.name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public BooleanStreamEqualFunction(BooleanValue baseExpr, BooleanValueStream compExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
+    }
 
-  private boolean exists = false;
-  @Override
-  public boolean getBoolean() {
-    Object valueA = exprA.getObject();
-    Object valueB = exprB.getObject();
-    exists = exprA.exists() && exprB.exists();
-    return exists ? valueA.equals(valueB) : false;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean baseValue = baseExpr.getBoolean();
+      if (baseExpr.exists()) {
+        compExpr.streamBooleans(compValue -> cons.accept(baseValue == compValue));
+      }
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * A catch-all equal function for an {@link AnalyticsValue} and an {@link AnalyticsValueStream}.
- */
-class StreamEqualFunction extends AbstractBooleanValueStream {
-  private final AnalyticsValue baseExpr;
-  private final AnalyticsValueStream compExpr;
-  public static final String name = EqualFunction.name;
-  private final String funcStr;
-  private final ExpressionType funcType;
-
-  public StreamEqualFunction(AnalyticsValue baseExpr, AnalyticsValueStream compExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    Object baseValue = baseExpr.getObject();
-    if (baseExpr.exists()) {
-      compExpr.streamObjects(compValue -> cons.accept(baseValue.equals(compValue)));
+  /**
+   * A catch-all equal function for two {@link AnalyticsValue}s.
+   */
+  static class ValueEqualFunction extends AbstractBooleanValue {
+    private final AnalyticsValue exprA;
+    private final AnalyticsValue exprB;
+    public static final String name = EqualFunction.name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public ValueEqualFunction(AnalyticsValue exprA, AnalyticsValue exprB) {
+      this.exprA = exprA;
+      this.exprB = exprB;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,exprA,exprB);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,exprA,exprB);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return funcStr;
+    private boolean exists = false;
+    @Override
+    public boolean getBoolean() {
+      Object valueA = exprA.getObject();
+      Object valueB = exprB.getObject();
+      exists = exprA.exists() && exprB.exists();
+      return exists ? valueA.equals(valueB) : false;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  /**
+   * A catch-all equal function for an {@link AnalyticsValue} and an {@link AnalyticsValueStream}.
+   */
+  static class StreamEqualFunction extends AbstractBooleanValueStream {
+    private final AnalyticsValue baseExpr;
+    private final AnalyticsValueStream compExpr;
+    public static final String name = EqualFunction.name;
+    private final String funcStr;
+    private final ExpressionType funcType;
+
+    public StreamEqualFunction(AnalyticsValue baseExpr, AnalyticsValueStream compExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.funcStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(funcStr,baseExpr,compExpr);
+    }
+
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      Object baseValue = baseExpr.getObject();
+      if (baseExpr.exists()) {
+        compExpr.streamObjects(compValue -> cons.accept(baseValue.equals(compValue)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return funcStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 }
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ExistsFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ExistsFunction.java
index 0e289175148..44f571db742 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ExistsFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ExistsFunction.java
@@ -42,82 +42,85 @@ public class ExistsFunction {
     }
     return new ValueStreamExistsFunction(param);
   });
-}
-/**
- * Exists function that supports {@link AnalyticsValueStream}s.
- */
-class ValueStreamExistsFunction extends AbstractBooleanValue {
-  private final AnalyticsValueStream param;
-  public static final String name = ExistsFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public ValueStreamExistsFunction(AnalyticsValueStream param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  /**
+   * Exists function that supports {@link AnalyticsValueStream}s.
+   */
+  static class ValueStreamExistsFunction extends AbstractBooleanValue {
+    private final AnalyticsValueStream param;
+    public static final String name = ExistsFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists;
-  @Override
-  public boolean getBoolean() {
-    exists = false;
-    param.streamObjects(val -> exists = true);
-    return exists;
-  }
-  @Override
-  public boolean exists() {
-    return true;
-  }
+    public ValueStreamExistsFunction(AnalyticsValueStream param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-/**
- * Exists function that supports {@link AnalyticsValue}s.
- */
-class ValueExistsFunction extends AbstractBooleanValue {
-  private final AnalyticsValue param;
-  public static final String name = ExistsFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    private boolean exists;
+    @Override
+    public boolean getBoolean() {
+      exists = false;
+      param.streamObjects(val -> exists = true);
+      return exists;
+    }
+    @Override
+    public boolean exists() {
+      return true;
+    }
 
-  public ValueExistsFunction(AnalyticsValue param) throws SolrException {
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public boolean getBoolean() {
-    param.getObject();
-    return param.exists();
-  }
-  @Override
-  public boolean exists() {
-    return true;
-  }
+  /**
+   * Exists function that supports {@link AnalyticsValue}s.
+   */
+  static class ValueExistsFunction extends AbstractBooleanValue {
+    private final AnalyticsValue param;
+    public static final String name = ExistsFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    public ValueExistsFunction(AnalyticsValue param) throws SolrException {
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    @Override
+    public boolean getBoolean() {
+      param.getObject();
+      return param.exists();
+    }
+    @Override
+    public boolean exists() {
+      return true;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 }
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FillMissingFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FillMissingFunction.java
index 7bc38fd3fa6..592fc1a825b 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FillMissingFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FillMissingFunction.java
@@ -128,716 +128,733 @@ public class FillMissingFunction {
     }
     return new StreamFillMissingFunction(baseExpr,fillExpr);
   });
-}
-class StreamFillMissingFunction extends AbstractAnalyticsValueStream implements Consumer<Object> {
-  private final AnalyticsValueStream baseExpr;
-  private final AnalyticsValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StreamFillMissingFunction(AnalyticsValueStream baseExpr, AnalyticsValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
 
-  boolean exists = false;
-  Consumer<Object> cons;
+  static class StreamFillMissingFunction extends AbstractAnalyticsValueStream implements Consumer<Object> {
+    private final AnalyticsValueStream baseExpr;
+    private final AnalyticsValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamObjects(Consumer<Object> cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamObjects(this);
-    if (!exists) {
-      fillExpr.streamObjects(cons);
+    public StreamFillMissingFunction(AnalyticsValueStream baseExpr, AnalyticsValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
     }
-  }
-  @Override
-  public void accept(Object value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class ValueFillMissingFunction extends AbstractAnalyticsValue {
-  private final AnalyticsValue baseExpr;
-  private final AnalyticsValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public ValueFillMissingFunction(AnalyticsValue baseExpr, AnalyticsValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+    boolean exists = false;
+    Consumer<Object> cons;
 
-  boolean exists = false;
+    @Override
+    public void streamObjects(Consumer<Object> cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamObjects(this);
+      if (!exists) {
+        fillExpr.streamObjects(cons);
+      }
+    }
+    @Override
+    public void accept(Object value) {
+      exists = true;
+      cons.accept(value);
+    }
 
-  @Override
-  public Object getObject() {
-    Object value = baseExpr.getObject();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getObject();
-      exists = fillExpr.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamFillMissingFunction extends AbstractBooleanValueStream implements BooleanConsumer {
-  private final BooleanValueStream baseExpr;
-  private final BooleanValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamFillMissingFunction(BooleanValueStream baseExpr, BooleanValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+  static class ValueFillMissingFunction extends AbstractAnalyticsValue {
+    private final AnalyticsValue baseExpr;
+    private final AnalyticsValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public ValueFillMissingFunction(AnalyticsValue baseExpr, AnalyticsValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
 
-  boolean exists = false;
-  BooleanConsumer cons;
+    boolean exists = false;
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamBooleans(this);
-    if (!exists) {
-      fillExpr.streamBooleans(cons);
+    @Override
+    public Object getObject() {
+      Object value = baseExpr.getObject();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getObject();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
-  @Override
-  public void accept(boolean value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanFillMissingFunction extends AbstractBooleanValue {
-  private final BooleanValue baseExpr;
-  private final BooleanValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanFillMissingFunction(BooleanValue baseExpr, BooleanValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class BooleanStreamFillMissingFunction extends AbstractBooleanValueStream implements BooleanConsumer {
+    private final BooleanValueStream baseExpr;
+    private final BooleanValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = baseExpr.getBoolean();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getBoolean();
-      exists = fillExpr.exists();
+    public BooleanStreamFillMissingFunction(BooleanValueStream baseExpr, BooleanValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamFillMissingFunction extends AbstractIntValueStream implements IntConsumer {
-  private final IntValueStream baseExpr;
-  private final IntValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntStreamFillMissingFunction(IntValueStream baseExpr, IntValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+    boolean exists = false;
+    BooleanConsumer cons;
 
-  boolean exists = false;
-  IntConsumer cons;
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamBooleans(this);
+      if (!exists) {
+        fillExpr.streamBooleans(cons);
+      }
+    }
+    @Override
+    public void accept(boolean value) {
+      exists = true;
+      cons.accept(value);
+    }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamInts(this);
-    if (!exists) {
-      fillExpr.streamInts(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-  }
-  @Override
-  public void accept(int value) {
-    exists = true;
-    cons.accept(value);
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntFillMissingFunction extends AbstractIntValue {
-  private final IntValue baseExpr;
-  private final IntValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntFillMissingFunction(IntValue baseExpr, IntValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+  static class BooleanFillMissingFunction extends AbstractBooleanValue {
+    private final BooleanValue baseExpr;
+    private final BooleanValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanFillMissingFunction(BooleanValue baseExpr, BooleanValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
 
-  boolean exists = false;
+    boolean exists = false;
 
-  @Override
-  public int getInt() {
-    int value = baseExpr.getInt();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getInt();
-      exists = fillExpr.exists();
+    @Override
+    public boolean getBoolean() {
+      boolean value = baseExpr.getBoolean();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getBoolean();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamFillMissingFunction extends AbstractLongValueStream implements LongConsumer {
-  private final LongValueStream baseExpr;
-  private final LongValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamFillMissingFunction(LongValueStream baseExpr, LongValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
-  LongConsumer cons;
+  static class IntStreamFillMissingFunction extends AbstractIntValueStream implements IntConsumer {
+    private final IntValueStream baseExpr;
+    private final IntValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamLongs(this);
-    if (!exists) {
-      fillExpr.streamLongs(cons);
+    public IntStreamFillMissingFunction(IntValueStream baseExpr, IntValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
     }
-  }
-  @Override
-  public void accept(long value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongFillMissingFunction extends AbstractLongValue {
-  private final LongValue baseExpr;
-  private final LongValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongFillMissingFunction(LongValue baseExpr, LongValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+    boolean exists = false;
+    IntConsumer cons;
 
-  boolean exists = false;
+    @Override
+    public void streamInts(IntConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamInts(this);
+      if (!exists) {
+        fillExpr.streamInts(cons);
+      }
+    }
+    @Override
+    public void accept(int value) {
+      exists = true;
+      cons.accept(value);
+    }
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getLong();
-      exists = fillExpr.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamFillMissingFunction extends AbstractFloatValueStream implements FloatConsumer {
-  private final FloatValueStream baseExpr;
-  private final FloatValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatStreamFillMissingFunction(FloatValueStream baseExpr, FloatValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+  static class IntFillMissingFunction extends AbstractIntValue {
+    private final IntValue baseExpr;
+    private final IntValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntFillMissingFunction(IntValue baseExpr, IntValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
 
-  boolean exists = false;
-  FloatConsumer cons;
+    boolean exists = false;
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamFloats(this);
-    if (!exists) {
-      fillExpr.streamFloats(cons);
+    @Override
+    public int getInt() {
+      int value = baseExpr.getInt();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getInt();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
-  @Override
-  public void accept(float value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatFillMissingFunction extends AbstractFloatValue {
-  private final FloatValue baseExpr;
-  private final FloatValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatFillMissingFunction(FloatValue baseExpr, FloatValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class LongStreamFillMissingFunction extends AbstractLongValueStream implements LongConsumer {
+    private final LongValueStream baseExpr;
+    private final LongValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public float getFloat() {
-    float value = baseExpr.getFloat();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getFloat();
-      exists = fillExpr.exists();
+    public LongStreamFillMissingFunction(LongValueStream baseExpr, LongValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamFillMissingFunction extends AbstractDoubleValueStream implements DoubleConsumer {
-  private final DoubleValueStream baseExpr;
-  private final DoubleValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleStreamFillMissingFunction(DoubleValueStream baseExpr, DoubleValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+    boolean exists = false;
+    LongConsumer cons;
 
-  boolean exists = false;
-  DoubleConsumer cons;
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamLongs(this);
+      if (!exists) {
+        fillExpr.streamLongs(cons);
+      }
+    }
+    @Override
+    public void accept(long value) {
+      exists = true;
+      cons.accept(value);
+    }
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamDoubles(this);
-    if (!exists) {
-      fillExpr.streamDoubles(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-  }
-  @Override
-  public void accept(double value) {
-    exists = true;
-    cons.accept(value);
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleFillMissingFunction extends AbstractDoubleValue {
-  private final DoubleValue baseExpr;
-  private final DoubleValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleFillMissingFunction(DoubleValue baseExpr, DoubleValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+  static class LongFillMissingFunction extends AbstractLongValue {
+    private final LongValue baseExpr;
+    private final LongValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongFillMissingFunction(LongValue baseExpr, LongValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
 
-  boolean exists = false;
+    boolean exists = false;
 
-  @Override
-  public double getDouble() {
-    double value = baseExpr.getDouble();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getDouble();
-      exists = fillExpr.exists();
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getLong();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamFillMissingFunction extends AbstractDateValueStream implements LongConsumer {
-  private final DateValueStream baseExpr;
-  private final DateValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateStreamFillMissingFunction(DateValueStream baseExpr, DateValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
-  LongConsumer cons;
+  static class FloatStreamFillMissingFunction extends AbstractFloatValueStream implements FloatConsumer {
+    private final FloatValueStream baseExpr;
+    private final FloatValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamLongs(this);
-    if (!exists) {
-      fillExpr.streamLongs(cons);
+    public FloatStreamFillMissingFunction(FloatValueStream baseExpr, FloatValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
     }
-  }
-  @Override
-  public void accept(long value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateFillMissingFunction extends AbstractDateValue {
-  private final DateValue baseExpr;
-  private final DateValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateFillMissingFunction(DateValue baseExpr, DateValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+    boolean exists = false;
+    FloatConsumer cons;
 
-  boolean exists = false;
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamFloats(this);
+      if (!exists) {
+        fillExpr.streamFloats(cons);
+      }
+    }
+    @Override
+    public void accept(float value) {
+      exists = true;
+      cons.accept(value);
+    }
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getLong();
-      exists = fillExpr.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamFillMissingFunction extends AbstractStringValueStream implements Consumer<String> {
-  private final StringValueStream baseExpr;
-  private final StringValueStream fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamFillMissingFunction(StringValueStream baseExpr, StringValueStream fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
-  }
+  static class FloatFillMissingFunction extends AbstractFloatValue {
+    private final FloatValue baseExpr;
+    private final FloatValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  boolean exists = false;
-  Consumer<String> cons;
+    public FloatFillMissingFunction(FloatValue baseExpr, FloatValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    exists = false;
-    this.cons = cons;
-    baseExpr.streamStrings(this);
-    if (!exists) {
-      fillExpr.streamStrings(cons);
+    boolean exists = false;
+
+    @Override
+    public float getFloat() {
+      float value = baseExpr.getFloat();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getFloat();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
-  @Override
-  public void accept(String value) {
-    exists = true;
-    cons.accept(value);
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringFillMissingFunction extends AbstractStringValue {
-  private final StringValue baseExpr;
-  private final StringValue fillExpr;
-  public static final String name = FillMissingFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringFillMissingFunction(StringValue baseExpr, StringValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+
+  static class DoubleStreamFillMissingFunction extends AbstractDoubleValueStream implements DoubleConsumer {
+    private final DoubleValueStream baseExpr;
+    private final DoubleValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamFillMissingFunction(DoubleValueStream baseExpr, DoubleValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+    DoubleConsumer cons;
+
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamDoubles(this);
+      if (!exists) {
+        fillExpr.streamDoubles(cons);
+      }
+    }
+    @Override
+    public void accept(double value) {
+      exists = true;
+      cons.accept(value);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class DoubleFillMissingFunction extends AbstractDoubleValue {
+    private final DoubleValue baseExpr;
+    private final DoubleValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getString() {
-    String value = baseExpr.getString();
-    exists = true;
-    if (!baseExpr.exists()) {
-      value = fillExpr.getString();
-      exists = fillExpr.exists();
+    public DoubleFillMissingFunction(DoubleValue baseExpr, DoubleValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public double getDouble() {
+      double value = baseExpr.getDouble();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getDouble();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
   }
-  @Override
-  public boolean exists() {
-    return exists;
+
+  static class DateStreamFillMissingFunction extends AbstractDateValueStream implements LongConsumer {
+    private final DateValueStream baseExpr;
+    private final DateValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamFillMissingFunction(DateValueStream baseExpr, DateValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+    LongConsumer cons;
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamLongs(this);
+      if (!exists) {
+        fillExpr.streamLongs(cons);
+      }
+    }
+    @Override
+    public void accept(long value) {
+      exists = true;
+      cons.accept(value);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
+  static class DateFillMissingFunction extends AbstractDateValue {
+    private final DateValue baseExpr;
+    private final DateValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateFillMissingFunction(DateValue baseExpr, DateValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getLong();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class StringStreamFillMissingFunction extends AbstractStringValueStream implements Consumer<String> {
+    private final StringValueStream baseExpr;
+    private final StringValueStream fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamFillMissingFunction(StringValueStream baseExpr, StringValueStream fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+    Consumer<String> cons;
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      exists = false;
+      this.cons = cons;
+      baseExpr.streamStrings(this);
+      if (!exists) {
+        fillExpr.streamStrings(cons);
+      }
+    }
+    @Override
+    public void accept(String value) {
+      exists = true;
+      cons.accept(value);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  static class StringFillMissingFunction extends AbstractStringValue {
+    private final StringValue baseExpr;
+    private final StringValue fillExpr;
+    public static final String name = FillMissingFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringFillMissingFunction(StringValue baseExpr, StringValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public String getString() {
+      String value = baseExpr.getString();
+      exists = true;
+      if (!baseExpr.exists()) {
+        value = fillExpr.getString();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java
index 6dac746bf7a..f266e796cce 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/FilterFunction.java
@@ -128,596 +128,613 @@ public class FilterFunction {
     }
     return new StreamFilterFunction(baseExpr,filterExpr);
   });
-}
-class StreamFilterFunction extends AbstractAnalyticsValueStream {
-  private final AnalyticsValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StreamFilterFunction(AnalyticsValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
 
-  @Override
-  public void streamObjects(Consumer<Object> cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamObjects(cons);
+  static class StreamFilterFunction extends AbstractAnalyticsValueStream {
+    private final AnalyticsValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StreamFilterFunction(AnalyticsValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class ValueFilterFunction extends AbstractAnalyticsValue {
-  private final AnalyticsValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public ValueFilterFunction(AnalyticsValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    @Override
+    public void streamObjects(Consumer<Object> cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamObjects(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class ValueFilterFunction extends AbstractAnalyticsValue {
+    private final AnalyticsValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public Object getObject() {
-    Object value = baseExpr.getObject();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public ValueFilterFunction(AnalyticsValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamFilterFunction extends AbstractBooleanValueStream {
-  private final BooleanValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamFilterFunction(BooleanValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    boolean exists = false;
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamBooleans(cons);
+    @Override
+    public Object getObject() {
+      Object value = baseExpr.getObject();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanFilterFunction extends AbstractBooleanValue {
-  private final BooleanValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanFilterFunction(BooleanValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class BooleanStreamFilterFunction extends AbstractBooleanValueStream {
+    private final BooleanValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = baseExpr.getBoolean();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public BooleanStreamFilterFunction(BooleanValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamFilterFunction extends AbstractIntValueStream {
-  private final IntValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntStreamFilterFunction(IntValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamBooleans(cons);
+      }
+    }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamInts(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntFilterFunction extends AbstractIntValue {
-  private final IntValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntFilterFunction(IntValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+  static class BooleanFilterFunction extends AbstractBooleanValue {
+    private final BooleanValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  boolean exists = false;
+    public BooleanFilterFunction(BooleanValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public int getInt() {
-    int value = baseExpr.getInt();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamFilterFunction extends AbstractLongValueStream {
-  private final LongValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamFilterFunction(LongValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    @Override
+    public boolean getBoolean() {
+      boolean value = baseExpr.getBoolean();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamLongs(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongFilterFunction extends AbstractLongValue {
-  private final LongValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongFilterFunction(LongValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+  static class IntStreamFilterFunction extends AbstractIntValueStream {
+    private final IntValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  boolean exists = false;
+    public IntStreamFilterFunction(IntValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public void streamInts(IntConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamInts(cons);
+      }
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamFilterFunction extends AbstractFloatValueStream {
-  private final FloatValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatStreamFilterFunction(FloatValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamFloats(cons);
+  static class IntFilterFunction extends AbstractIntValue {
+    private final IntValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntFilterFunction(IntValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatFilterFunction extends AbstractFloatValue {
-  private final FloatValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    boolean exists = false;
 
-  boolean exists = false;
+    @Override
+    public int getInt() {
+      int value = baseExpr.getInt();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public float getFloat() {
-    float value = baseExpr.getFloat();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamFilterFunction extends AbstractDoubleValueStream {
-  private final DoubleValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleStreamFilterFunction(DoubleValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+  static class LongStreamFilterFunction extends AbstractLongValueStream {
+    private final LongValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamDoubles(cons);
+    public LongStreamFilterFunction(LongValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleFilterFunction extends AbstractDoubleValue {
-  private final DoubleValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleFilterFunction(DoubleValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamLongs(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class LongFilterFunction extends AbstractLongValue {
+    private final LongValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public double getDouble() {
-    double value = baseExpr.getDouble();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public LongFilterFunction(LongValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamFilterFunction extends AbstractDateValueStream {
-  private final DateValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateStreamFilterFunction(DateValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    boolean exists = false;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamLongs(cons);
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateFilterFunction extends AbstractDateValue {
-  private final DateValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateFilterFunction(DateValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class FloatStreamFilterFunction extends AbstractFloatValueStream {
+    private final FloatValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public FloatStreamFilterFunction(FloatValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamFilterFunction extends AbstractStringValueStream {
-  private final StringValueStream baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamFilterFunction(StringValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
-  }
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamFloats(cons);
+      }
+    }
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    if (filterExpr.getBoolean() && filterExpr.exists()) {
-      baseExpr.streamStrings(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  static class FloatFilterFunction extends AbstractFloatValue {
+    private final FloatValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatFilterFunction(FloatValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public float getFloat() {
+      float value = baseExpr.getFloat();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringFilterFunction extends AbstractStringValue {
-  private final StringValue baseExpr;
-  private final BooleanValue filterExpr;
-  public static final String name = FilterFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringFilterFunction(StringValue baseExpr, BooleanValue filterExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.filterExpr = filterExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+
+  static class DoubleStreamFilterFunction extends AbstractDoubleValueStream {
+    private final DoubleValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamFilterFunction(DoubleValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamDoubles(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class DoubleFilterFunction extends AbstractDoubleValue {
+    private final DoubleValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getString() {
-    String value = baseExpr.getString();
-    exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
-    return value;
+    public DoubleFilterFunction(DoubleValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public double getDouble() {
+      double value = baseExpr.getDouble();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public boolean exists() {
-    return exists;
+
+  static class DateStreamFilterFunction extends AbstractDateValueStream {
+    private final DateValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamFilterFunction(DateValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamLongs(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
+  static class DateFilterFunction extends AbstractDateValue {
+    private final DateValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateFilterFunction(DateValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class StringStreamFilterFunction extends AbstractStringValueStream {
+    private final StringValueStream baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamFilterFunction(StringValueStream baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      if (filterExpr.getBoolean() && filterExpr.exists()) {
+        baseExpr.streamStrings(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  static class StringFilterFunction extends AbstractStringValue {
+    private final StringValue baseExpr;
+    private final BooleanValue filterExpr;
+    public static final String name = FilterFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringFilterFunction(StringValue baseExpr, BooleanValue filterExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.filterExpr = filterExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,filterExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,filterExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public String getString() {
+      String value = baseExpr.getString();
+      exists = baseExpr.exists() && filterExpr.getBoolean() && filterExpr.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/IfFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/IfFunction.java
index ff28b905987..a506e46cefd 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/IfFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/IfFunction.java
@@ -172,722 +172,738 @@ public class IfFunction extends AbstractAnalyticsValueStream {
   public ExpressionType getExpressionType() {
     return funcType;
   }
-}
-class ValueIfFunction extends AbstractAnalyticsValue {
-  private final BooleanValue ifExpr;
-  private final AnalyticsValue thenExpr;
-  private final AnalyticsValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public ValueIfFunction(BooleanValue ifExpr, AnalyticsValue thenExpr, AnalyticsValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
-
-  private boolean exists = false;
 
-  @Override
-  public Object getObject() {
-    exists = false;
-    Object value = null;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getObject();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getObject();
-        exists = elseExpr.exists();
-      }
+  static class ValueIfFunction extends AbstractAnalyticsValue {
+    private final BooleanValue ifExpr;
+    private final AnalyticsValue thenExpr;
+    private final AnalyticsValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public ValueIfFunction(BooleanValue ifExpr, AnalyticsValue thenExpr, AnalyticsValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamIfFunction extends AbstractBooleanValueStream {
-  private final BooleanValue ifExpr;
-  private final BooleanValueStream thenExpr;
-  private final BooleanValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    private boolean exists = false;
 
-  public BooleanStreamIfFunction(BooleanValue ifExpr, BooleanValueStream thenExpr, BooleanValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
-
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamBooleans(cons);
-      }
-      else {
-        elseExpr.streamBooleans(cons);
-      }
+    @Override
+    public Object getObject() {
+      exists = false;
+      Object value = null;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getObject();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getObject();
+          exists = elseExpr.exists();
+        }
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  static class BooleanStreamIfFunction extends AbstractBooleanValueStream {
+    private final BooleanValue ifExpr;
+    private final BooleanValueStream thenExpr;
+    private final BooleanValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanStreamIfFunction(BooleanValue ifExpr, BooleanValueStream thenExpr, BooleanValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
+
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamBooleans(cons);
+        }
+        else {
+          elseExpr.streamBooleans(cons);
+        }
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class BooleanIfFunction extends AbstractBooleanValue {
-  private final BooleanValue ifExpr;
-  private final BooleanValue thenExpr;
-  private final BooleanValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public BooleanIfFunction(BooleanValue ifExpr, BooleanValue thenExpr, BooleanValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class BooleanIfFunction extends AbstractBooleanValue {
+    private final BooleanValue ifExpr;
+    private final BooleanValue thenExpr;
+    private final BooleanValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanIfFunction(BooleanValue ifExpr, BooleanValue thenExpr, BooleanValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public boolean getBoolean() {
-    exists = false;
-    boolean value = false;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getBoolean();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getBoolean();
-        exists = elseExpr.exists();
+    @Override
+    public boolean getBoolean() {
+      exists = false;
+      boolean value = false;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getBoolean();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getBoolean();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class IntStreamIfFunction extends AbstractIntValueStream {
-  private final BooleanValue ifExpr;
-  private final IntValueStream thenExpr;
-  private final IntValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public IntStreamIfFunction(BooleanValue ifExpr, IntValueStream thenExpr, IntValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class IntStreamIfFunction extends AbstractIntValueStream {
+    private final BooleanValue ifExpr;
+    private final IntValueStream thenExpr;
+    private final IntValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntStreamIfFunction(BooleanValue ifExpr, IntValueStream thenExpr, IntValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamInts(cons);
-      }
-      else {
-        elseExpr.streamInts(cons);
+    @Override
+    public void streamInts(IntConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamInts(cons);
+        }
+        else {
+          elseExpr.streamInts(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class IntIfFunction extends AbstractIntValue {
-  private final BooleanValue ifExpr;
-  private final IntValue thenExpr;
-  private final IntValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public IntIfFunction(BooleanValue ifExpr, IntValue thenExpr, IntValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class IntIfFunction extends AbstractIntValue {
+    private final BooleanValue ifExpr;
+    private final IntValue thenExpr;
+    private final IntValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntIfFunction(BooleanValue ifExpr, IntValue thenExpr, IntValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public int getInt() {
-    exists = false;
-    int value = 0;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getInt();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getInt();
-        exists = elseExpr.exists();
+    @Override
+    public int getInt() {
+      exists = false;
+      int value = 0;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getInt();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getInt();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class LongStreamIfFunction extends AbstractLongValueStream {
-  private final BooleanValue ifExpr;
-  private final LongValueStream thenExpr;
-  private final LongValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public LongStreamIfFunction(BooleanValue ifExpr, LongValueStream thenExpr, LongValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class LongStreamIfFunction extends AbstractLongValueStream {
+    private final BooleanValue ifExpr;
+    private final LongValueStream thenExpr;
+    private final LongValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongStreamIfFunction(BooleanValue ifExpr, LongValueStream thenExpr, LongValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamLongs(cons);
-      }
-      else {
-        elseExpr.streamLongs(cons);
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamLongs(cons);
+        }
+        else {
+          elseExpr.streamLongs(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class LongIfFunction extends AbstractLongValue {
-  private final BooleanValue ifExpr;
-  private final LongValue thenExpr;
-  private final LongValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public LongIfFunction(BooleanValue ifExpr, LongValue thenExpr, LongValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class LongIfFunction extends AbstractLongValue {
+    private final BooleanValue ifExpr;
+    private final LongValue thenExpr;
+    private final LongValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongIfFunction(BooleanValue ifExpr, LongValue thenExpr, LongValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public long getLong() {
-    exists = false;
-    long value = 0;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getLong();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getLong();
-        exists = elseExpr.exists();
+    @Override
+    public long getLong() {
+      exists = false;
+      long value = 0;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getLong();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getLong();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class FloatStreamIfFunction extends AbstractFloatValueStream {
-  private final BooleanValue ifExpr;
-  private final FloatValueStream thenExpr;
-  private final FloatValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public FloatStreamIfFunction(BooleanValue ifExpr, FloatValueStream thenExpr, FloatValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class FloatStreamIfFunction extends AbstractFloatValueStream {
+    private final BooleanValue ifExpr;
+    private final FloatValueStream thenExpr;
+    private final FloatValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatStreamIfFunction(BooleanValue ifExpr, FloatValueStream thenExpr, FloatValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamFloats(cons);
-      }
-      else {
-        elseExpr.streamFloats(cons);
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamFloats(cons);
+        }
+        else {
+          elseExpr.streamFloats(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class FloatIfFunction extends AbstractFloatValue {
-  private final BooleanValue ifExpr;
-  private final FloatValue thenExpr;
-  private final FloatValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public FloatIfFunction(BooleanValue ifExpr, FloatValue thenExpr, FloatValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class FloatIfFunction extends AbstractFloatValue {
+    private final BooleanValue ifExpr;
+    private final FloatValue thenExpr;
+    private final FloatValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatIfFunction(BooleanValue ifExpr, FloatValue thenExpr, FloatValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public float getFloat() {
-    exists = false;
-    float value = 0;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getFloat();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getFloat();
-        exists = elseExpr.exists();
+    @Override
+    public float getFloat() {
+      exists = false;
+      float value = 0;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getFloat();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getFloat();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DoubleStreamIfFunction extends AbstractDoubleValueStream {
-  private final BooleanValue ifExpr;
-  private final DoubleValueStream thenExpr;
-  private final DoubleValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DoubleStreamIfFunction(BooleanValue ifExpr, DoubleValueStream thenExpr, DoubleValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class DoubleStreamIfFunction extends AbstractDoubleValueStream {
+    private final BooleanValue ifExpr;
+    private final DoubleValueStream thenExpr;
+    private final DoubleValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamIfFunction(BooleanValue ifExpr, DoubleValueStream thenExpr, DoubleValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamDoubles(cons);
-      }
-      else {
-        elseExpr.streamDoubles(cons);
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamDoubles(cons);
+        }
+        else {
+          elseExpr.streamDoubles(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DoubleIfFunction extends AbstractDoubleValue {
-  private final BooleanValue ifExpr;
-  private final DoubleValue thenExpr;
-  private final DoubleValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DoubleIfFunction(BooleanValue ifExpr, DoubleValue thenExpr, DoubleValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class DoubleIfFunction extends AbstractDoubleValue {
+    private final BooleanValue ifExpr;
+    private final DoubleValue thenExpr;
+    private final DoubleValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleIfFunction(BooleanValue ifExpr, DoubleValue thenExpr, DoubleValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public double getDouble() {
-    exists = false;
-    double value = 0;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getDouble();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getDouble();
-        exists = elseExpr.exists();
+    @Override
+    public double getDouble() {
+      exists = false;
+      double value = 0;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getDouble();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getDouble();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DateStreamIfFunction extends AbstractDateValueStream {
-  private final BooleanValue ifExpr;
-  private final DateValueStream thenExpr;
-  private final DateValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateStreamIfFunction(BooleanValue ifExpr, DateValueStream thenExpr, DateValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class DateStreamIfFunction extends AbstractDateValueStream {
+    private final BooleanValue ifExpr;
+    private final DateValueStream thenExpr;
+    private final DateValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamIfFunction(BooleanValue ifExpr, DateValueStream thenExpr, DateValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamLongs(cons);
-      }
-      else {
-        elseExpr.streamLongs(cons);
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamLongs(cons);
+        }
+        else {
+          elseExpr.streamLongs(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DateIfFunction extends AbstractDateValue {
-  private final BooleanValue ifExpr;
-  private final DateValue thenExpr;
-  private final DateValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateIfFunction(BooleanValue ifExpr, DateValue thenExpr, DateValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class DateIfFunction extends AbstractDateValue {
+    private final BooleanValue ifExpr;
+    private final DateValue thenExpr;
+    private final DateValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateIfFunction(BooleanValue ifExpr, DateValue thenExpr, DateValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public long getLong() {
-    exists = false;
-    long value = 0;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getLong();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getLong();
-        exists = elseExpr.exists();
+    @Override
+    public long getLong() {
+      exists = false;
+      long value = 0;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getLong();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getLong();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringStreamIfFunction extends AbstractStringValueStream {
-  private final BooleanValue ifExpr;
-  private final StringValueStream thenExpr;
-  private final StringValueStream elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public StringStreamIfFunction(BooleanValue ifExpr, StringValueStream thenExpr, StringValueStream elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class StringStreamIfFunction extends AbstractStringValueStream {
+    private final BooleanValue ifExpr;
+    private final StringValueStream thenExpr;
+    private final StringValueStream elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        thenExpr.streamStrings(cons);
-      }
-      else {
-        elseExpr.streamStrings(cons);
+    public StringStreamIfFunction(BooleanValue ifExpr, StringValueStream thenExpr, StringValueStream elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          thenExpr.streamStrings(cons);
+        }
+        else {
+          elseExpr.streamStrings(cons);
+        }
       }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringIfFunction extends AbstractStringValue {
-  private final BooleanValue ifExpr;
-  private final StringValue thenExpr;
-  private final StringValue elseExpr;
-  public static final String name = IfFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public StringIfFunction(BooleanValue ifExpr, StringValue thenExpr, StringValue elseExpr) throws SolrException {
-    this.ifExpr = ifExpr;
-    this.thenExpr = thenExpr;
-    this.elseExpr = elseExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
-  }
+  static class StringIfFunction extends AbstractStringValue {
+    private final BooleanValue ifExpr;
+    private final StringValue thenExpr;
+    private final StringValue elseExpr;
+    public static final String name = IfFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
+    public StringIfFunction(BooleanValue ifExpr, StringValue thenExpr, StringValue elseExpr) throws SolrException {
+      this.ifExpr = ifExpr;
+      this.thenExpr = thenExpr;
+      this.elseExpr = elseExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,ifExpr,thenExpr,elseExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,ifExpr,thenExpr,elseExpr);
+    }
 
-  @Override
-  public String getString() {
-    exists = false;
-    String value = null;
-    boolean ifValue = ifExpr.getBoolean();
-    if (ifExpr.exists()) {
-      if (ifValue) {
-        value = thenExpr.getString();
-        exists = thenExpr.exists();
-      }
-      else {
-        value = elseExpr.getString();
-        exists = elseExpr.exists();
+    private boolean exists = false;
+
+    @Override
+    public String getString() {
+      exists = false;
+      String value = null;
+      boolean ifValue = ifExpr.getBoolean();
+      if (ifExpr.exists()) {
+        if (ifValue) {
+          value = thenExpr.getString();
+          exists = thenExpr.exists();
+        }
+        else {
+          value = elseExpr.getString();
+          exists = elseExpr.exists();
+        }
       }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/LambdaFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/LambdaFunction.java
index fcaf332b899..ff72becc6b6 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/LambdaFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/LambdaFunction.java
@@ -21,18 +21,6 @@ import java.util.function.DoubleConsumer;
 import java.util.function.IntConsumer;
 import java.util.function.LongConsumer;
 
-import org.apache.solr.analytics.function.mapping.LambdaFunction.BoolInBoolOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.DoubleInDoubleOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.FloatInFloatOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.IntInIntOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.LongInLongOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.StringInStringOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoBoolInBoolOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoDoubleInDoubleOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoFloatInFloatOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoIntInIntOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoLongInLongOutLambda;
-import org.apache.solr.analytics.function.mapping.LambdaFunction.TwoStringInStringOutLambda;
 import org.apache.solr.analytics.util.function.BooleanConsumer;
 import org.apache.solr.analytics.util.function.FloatConsumer;
 import org.apache.solr.analytics.value.AnalyticsValueStream;
@@ -958,2263 +946,2313 @@ public class LambdaFunction {
   public static interface TwoDoubleInStringOutLambda { String apply(double  a, double  b); }
   @FunctionalInterface
   public static interface TwoStringInStringOutLambda { String apply(String  a, String  b); }
-}
-class BooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
-  private final BooleanValue param;
-  private final BoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public BooleanValueInBooleanValueOutFunction(String name, BoolInBoolOutLambda lambda, BooleanValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  static class BooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
+    private final BooleanValue param;
+    private final BoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanValueInBooleanValueOutFunction(String name, BoolInBoolOutLambda lambda, BooleanValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  private boolean exists = false;
+    private boolean exists = false;
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = lambda.apply(param.getBoolean());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public boolean getBoolean() {
+      boolean value = lambda.apply(param.getBoolean());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class BooleanStreamInBooleanStreamOutFunction extends AbstractBooleanValueStream {
-  private final BooleanValueStream param;
-  private final BoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public BooleanStreamInBooleanStreamOutFunction(String name, BoolInBoolOutLambda lambda, BooleanValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  static class BooleanStreamInBooleanStreamOutFunction extends AbstractBooleanValueStream {
+    private final BooleanValueStream param;
+    private final BoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    param.streamBooleans(value -> cons.accept(lambda.apply(value)));
-  }
+    public BooleanStreamInBooleanStreamOutFunction(String name, BoolInBoolOutLambda lambda, BooleanValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamInBooleanValueOutFunction extends AbstractBooleanValue implements BooleanConsumer {
-  private final BooleanValueStream param;
-  private final TwoBoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private boolean value;
-
-  @Override
-  public boolean getBoolean() {
-    exists = false;
-    param.streamBooleans(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(boolean paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      param.streamBooleans(value -> cons.accept(lambda.apply(value)));
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class TwoBooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
-  private final BooleanValue param1;
-  private final BooleanValue param2;
-  private final TwoBoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoBooleanValueInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue param1, BooleanValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class BooleanStreamInBooleanValueOutFunction extends AbstractBooleanValue implements BooleanConsumer {
+    private final BooleanValueStream param;
+    private final TwoBoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
+    public BooleanStreamInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = lambda.apply(param1.getBoolean(), param2.getBoolean());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    private boolean exists = false;
+    private boolean value;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanValueBooleanStreamInBooleanStreamOutFunction extends AbstractBooleanValueStream {
-  private final BooleanValue param1;
-  private final BooleanValueStream param2;
-  private final TwoBoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public boolean getBoolean() {
+      exists = false;
+      param.streamBooleans(this);
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+    public void accept(boolean paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
+      }
+    }
 
-  public BooleanValueBooleanStreamInBooleanStreamOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue param1, BooleanValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean value1 = param1.getBoolean();
-    if (param1.exists()) {
-      param2.streamBooleans(value2 -> cons.accept(lambda.apply(value1,value2)));
+  static class TwoBooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
+    private final BooleanValue param1;
+    private final BooleanValue param2;
+    private final TwoBoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoBooleanValueInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue param1, BooleanValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamBooleanValueInBooleanStreamOutFunction extends AbstractBooleanValueStream {
-  private final BooleanValueStream param1;
-  private final BooleanValue param2;
-  private final TwoBoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    private boolean exists = false;
 
-  public BooleanStreamBooleanValueInBooleanStreamOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValueStream param1, BooleanValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    @Override
+    public boolean getBoolean() {
+      boolean value = lambda.apply(param1.getBoolean(), param2.getBoolean());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean value2 = param2.getBoolean();
-    if (param2.exists()) {
-      param1.streamBooleans(value1 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-abstract class MultiBooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
-  protected final BooleanValue[] params;
-  protected final TwoBoolInBoolOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class BooleanValueBooleanStreamInBooleanStreamOutFunction extends AbstractBooleanValueStream {
+    private final BooleanValue param1;
+    private final BooleanValueStream param2;
+    private final TwoBoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanValueBooleanStreamInBooleanStreamOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue param1, BooleanValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public MultiBooleanValueInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
-  }
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean value1 = param1.getBoolean();
+      if (param1.exists()) {
+        param2.streamBooleans(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  protected boolean exists = false;
-  protected boolean temp;
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class MultiBooleanValueInBooleanValueOutRequireAllFunction extends MultiBooleanValueInBooleanValueOutFunction {
+  static class BooleanStreamBooleanValueInBooleanStreamOutFunction extends AbstractBooleanValueStream {
+    private final BooleanValueStream param1;
+    private final BooleanValue param2;
+    private final TwoBoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanStreamBooleanValueInBooleanStreamOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValueStream param1, BooleanValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public MultiBooleanValueInBooleanValueOutRequireAllFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
-    super(name, lambda, params);
-  }
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean value2 = param2.getBoolean();
+      if (param2.exists()) {
+        param1.streamBooleans(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = params[0].getBoolean();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getBoolean());
-      exists = params[i].exists();
+    @Override
+    public String getName() {
+      return name;
     }
-    return value;
-  }
-}
-class MultiBooleanValueInBooleanValueOutRequireOneFunction extends MultiBooleanValueInBooleanValueOutFunction {
-
-  public MultiBooleanValueInBooleanValueOutRequireOneFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public boolean getBoolean() {
-    int i = -1;
-    boolean value = false;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getBoolean();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
     }
-    while (++i < params.length) {
-      temp = params[i].getBoolean();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
-      }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
-  }
-}
-class IntValueInIntValueOutFunction extends AbstractIntValue {
-  private final IntValue param;
-  private final IntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntValueInIntValueOutFunction(String name, IntInIntOutLambda lambda, IntValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
   }
 
-  private boolean exists = false;
+  abstract static class MultiBooleanValueInBooleanValueOutFunction extends AbstractBooleanValue {
+    protected final BooleanValue[] params;
+    protected final TwoBoolInBoolOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public int getInt() {
-    int value = lambda.apply(param.getInt());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public MultiBooleanValueInBooleanValueOutFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamInIntStreamOutFunction extends AbstractIntValueStream {
-  private final IntValueStream param;
-  private final IntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    protected boolean exists = false;
+    protected boolean temp;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public IntStreamInIntStreamOutFunction(String name, IntInIntOutLambda lambda, IntValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    param.streamInts(value -> cons.accept(lambda.apply(value)));
-  }
+  static class MultiBooleanValueInBooleanValueOutRequireAllFunction extends MultiBooleanValueInBooleanValueOutFunction {
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamInIntValueOutFunction extends AbstractIntValue implements IntConsumer {
-  private final IntValueStream param;
-  private final TwoIntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntStreamInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private int value;
-
-  @Override
-  public int getInt() {
-    exists = false;
-    param.streamInts(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(int paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    public MultiBooleanValueInBooleanValueOutRequireAllFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
+      super(name, lambda, params);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public boolean getBoolean() {
+      boolean value = params[0].getBoolean();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getBoolean());
+        exists = params[i].exists();
+      }
+      return value;
+    }
   }
-}
-class TwoIntValueInIntValueOutFunction extends AbstractIntValue {
-  private final IntValue param1;
-  private final IntValue param2;
-  private final TwoIntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoIntValueInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue param1, IntValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class MultiBooleanValueInBooleanValueOutRequireOneFunction extends MultiBooleanValueInBooleanValueOutFunction {
 
-  private boolean exists = false;
+    public MultiBooleanValueInBooleanValueOutRequireOneFunction(String name, TwoBoolInBoolOutLambda lambda, BooleanValue[] params) {
+      super(name, lambda, params);
+    }
 
-  @Override
-  public int getInt() {
-    int value = lambda.apply(param1.getInt(), param2.getInt());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public boolean getBoolean() {
+      int i = -1;
+      boolean value = false;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getBoolean();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
+      }
+      while (++i < params.length) {
+        temp = params[i].getBoolean();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntValueIntStreamInIntStreamOutFunction extends AbstractIntValueStream {
-  private final IntValue param1;
-  private final IntValueStream param2;
-  private final TwoIntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class IntValueInIntValueOutFunction extends AbstractIntValue {
+    private final IntValue param;
+    private final IntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  public IntValueIntStreamInIntStreamOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue param1, IntValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    public IntValueInIntValueOutFunction(String name, IntInIntOutLambda lambda, IntValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    int value1 = param1.getInt();
-    if (param1.exists()) {
-      param2.streamInts(value2 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public int getInt() {
+      int value = lambda.apply(param.getInt());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class IntStreamIntValueInIntStreamOutFunction extends AbstractIntValueStream {
-  private final IntValueStream param1;
-  private final IntValue param2;
-  private final TwoIntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public IntStreamIntValueInIntStreamOutFunction(String name, TwoIntInIntOutLambda lambda, IntValueStream param1, IntValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class IntStreamInIntStreamOutFunction extends AbstractIntValueStream {
+    private final IntValueStream param;
+    private final IntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    int value2 = param2.getInt();
-    if (param2.exists()) {
-      param1.streamInts(value1 -> cons.accept(lambda.apply(value1,value2)));
+    public IntStreamInIntStreamOutFunction(String name, IntInIntOutLambda lambda, IntValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-abstract class MultiIntValueInIntValueOutFunction extends AbstractIntValue {
-  protected final IntValue[] params;
-  protected final TwoIntInIntOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public void streamInts(IntConsumer cons) {
+      param.streamInts(value -> cons.accept(lambda.apply(value)));
+    }
 
-  public MultiIntValueInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  protected boolean exists = false;
-  protected int temp;
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+  static class IntStreamInIntValueOutFunction extends AbstractIntValue implements IntConsumer {
+    private final IntValueStream param;
+    private final TwoIntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class MultiIntValueInIntValueOutRequireAllFunction extends MultiIntValueInIntValueOutFunction {
+    public IntStreamInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  public MultiIntValueInIntValueOutRequireAllFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
-    super(name, lambda, params);
-  }
+    private boolean exists = false;
+    private int value;
 
-  @Override
-  public int getInt() {
-    int value = params[0].getInt();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getInt());
-      exists = params[i].exists();
+    @Override
+    public int getInt() {
+      exists = false;
+      param.streamInts(this);
+      return value;
     }
-    return value;
-  }
-}
-class MultiIntValueInIntValueOutRequireOneFunction extends MultiIntValueInIntValueOutFunction {
-
-  public MultiIntValueInIntValueOutRequireOneFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public int getInt() {
-    int i = -1;
-    int value = 0;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getInt();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    while (++i < params.length) {
-      temp = params[i].getInt();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+    public void accept(int paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
       }
     }
-    return value;
-  }
-}
-class LongValueInLongValueOutFunction extends AbstractLongValue {
-  private final LongValue param;
-  private final LongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongValueInLongValueOutFunction(String name, LongInLongOutLambda lambda, LongValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-
-  @Override
-  public long getLong() {
-    long value = lambda.apply(param.getLong());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class LongStreamInLongStreamOutFunction extends AbstractLongValueStream {
-  private final LongValueStream param;
-  private final LongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public LongStreamInLongStreamOutFunction(String name, LongInLongOutLambda lambda, LongValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  static class TwoIntValueInIntValueOutFunction extends AbstractIntValue {
+    private final IntValue param1;
+    private final IntValue param2;
+    private final TwoIntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoIntValueInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue param1, IntValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    param.streamLongs(value -> cons.accept(lambda.apply(value)));
-  }
+    private boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamInLongValueOutFunction extends AbstractLongValue implements LongConsumer {
-  private final LongValueStream param;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private long value;
-
-  @Override
-  public long getLong() {
-    exists = false;
-    param.streamLongs(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(long paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    @Override
+    public int getInt() {
+      int value = lambda.apply(param1.getInt(), param2.getInt());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class TwoLongValueInLongValueOutFunction extends AbstractLongValue {
-  private final LongValue param1;
-  private final LongValue param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoLongValueInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue param1, LongValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class IntValueIntStreamInIntStreamOutFunction extends AbstractIntValueStream {
+    private final IntValue param1;
+    private final IntValueStream param2;
+    private final TwoIntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntValueIntStreamInIntStreamOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue param1, IntValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  private boolean exists = false;
+    @Override
+    public void streamInts(IntConsumer cons) {
+      int value1 = param1.getInt();
+      if (param1.exists()) {
+        param2.streamInts(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public long getLong() {
-    long value = lambda.apply(param1.getLong(), param2.getLong());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongValueLongStreamInLongStreamOutFunction extends AbstractLongValueStream {
-  private final LongValue param1;
-  private final LongValueStream param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class IntStreamIntValueInIntStreamOutFunction extends AbstractIntValueStream {
+    private final IntValueStream param1;
+    private final IntValue param2;
+    private final TwoIntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntStreamIntValueInIntStreamOutFunction(String name, TwoIntInIntOutLambda lambda, IntValueStream param1, IntValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public LongValueLongStreamInLongStreamOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue param1, LongValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    @Override
+    public void streamInts(IntConsumer cons) {
+      int value2 = param2.getInt();
+      if (param2.exists()) {
+        param1.streamInts(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long value1 = param1.getLong();
-    if (param1.exists()) {
-      param2.streamLongs(value2 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamLongValueInLongStreamOutFunction extends AbstractLongValueStream {
-  private final LongValueStream param1;
-  private final LongValue param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  abstract static class MultiIntValueInIntValueOutFunction extends AbstractIntValue {
+    protected final IntValue[] params;
+    protected final TwoIntInIntOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  public LongStreamLongValueInLongStreamOutFunction(String name, TwoLongInLongOutLambda lambda, LongValueStream param1, LongValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    public MultiIntValueInIntValueOutFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long value2 = param2.getLong();
-    if (param2.exists()) {
-      param1.streamLongs(value1 -> cons.accept(lambda.apply(value1,value2)));
+    protected boolean exists = false;
+    protected int temp;
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-abstract class MultiLongValueInLongValueOutFunction extends AbstractLongValue {
-  protected final LongValue[] params;
-  protected final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public MultiLongValueInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
-  }
+  static class MultiIntValueInIntValueOutRequireAllFunction extends MultiIntValueInIntValueOutFunction {
 
-  protected boolean exists = false;
-  protected long temp;
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public MultiIntValueInIntValueOutRequireAllFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
+      super(name, lambda, params);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public int getInt() {
+      int value = params[0].getInt();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getInt());
+        exists = params[i].exists();
+      }
+      return value;
+    }
   }
-}
-class MultiLongValueInLongValueOutRequireAllFunction extends MultiLongValueInLongValueOutFunction {
 
-  public MultiLongValueInLongValueOutRequireAllFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
-    super(name, lambda, params);
-  }
+  static class MultiIntValueInIntValueOutRequireOneFunction extends MultiIntValueInIntValueOutFunction {
 
-  @Override
-  public long getLong() {
-    long value = params[0].getLong();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getLong());
-      exists = params[i].exists();
+    public MultiIntValueInIntValueOutRequireOneFunction(String name, TwoIntInIntOutLambda lambda, IntValue[] params) {
+      super(name, lambda, params);
     }
-    return value;
-  }
-}
-class MultiLongValueInLongValueOutRequireOneFunction extends MultiLongValueInLongValueOutFunction {
-
-  public MultiLongValueInLongValueOutRequireOneFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public long getLong() {
-    int i = -1;
-    long value = 0;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getLong();
-      exists = params[i].exists();
-      if (exists) {
-        break;
+
+    @Override
+    public int getInt() {
+      int i = -1;
+      int value = 0;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getInt();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
       }
-    }
-    while (++i < params.length) {
-      temp = params[i].getLong();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+      while (++i < params.length) {
+        temp = params[i].getInt();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
       }
+      return value;
     }
-    return value;
   }
-}
-class FloatValueInFloatValueOutFunction extends AbstractFloatValue {
-  private final FloatValue param;
-  private final FloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public FloatValueInFloatValueOutFunction(String name, FloatInFloatOutLambda lambda, FloatValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  static class LongValueInLongValueOutFunction extends AbstractLongValue {
+    private final LongValue param;
+    private final LongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
+    public LongValueInLongValueOutFunction(String name, LongInLongOutLambda lambda, LongValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public float getFloat() {
-    float value = lambda.apply(param.getFloat());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    private boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamInFloatStreamOutFunction extends AbstractFloatValueStream {
-  private final FloatValueStream param;
-  private final FloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public long getLong() {
+      long value = lambda.apply(param.getLong());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public FloatStreamInFloatStreamOutFunction(String name, FloatInFloatOutLambda lambda, FloatValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    param.streamFloats(value -> cons.accept(lambda.apply(value)));
-  }
+  static class LongStreamInLongStreamOutFunction extends AbstractLongValueStream {
+    private final LongValueStream param;
+    private final LongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamInFloatValueOutFunction extends AbstractFloatValue implements FloatConsumer {
-  private final FloatValueStream param;
-  private final TwoFloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatStreamInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private float value;
-
-  @Override
-  public float getFloat() {
-    exists = false;
-    param.streamFloats(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(float paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    public LongStreamInLongStreamOutFunction(String name, LongInLongOutLambda lambda, LongValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class TwoFloatValueInFloatValueOutFunction extends AbstractFloatValue {
-  private final FloatValue param1;
-  private final FloatValue param2;
-  private final TwoFloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      param.streamLongs(value -> cons.accept(lambda.apply(value)));
+    }
 
-  public TwoFloatValueInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue param1, FloatValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  private boolean exists = false;
+  static class LongStreamInLongValueOutFunction extends AbstractLongValue implements LongConsumer {
+    private final LongValueStream param;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public float getFloat() {
-    float value = lambda.apply(param1.getFloat(), param2.getFloat());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public LongStreamInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatValueFloatStreamInFloatStreamOutFunction extends AbstractFloatValueStream {
-  private final FloatValue param1;
-  private final FloatValueStream param2;
-  private final TwoFloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    private boolean exists = false;
+    private long value;
 
-  public FloatValueFloatStreamInFloatStreamOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue param1, FloatValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    @Override
+    public long getLong() {
+      exists = false;
+      param.streamLongs(this);
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+    public void accept(long paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
+      }
+    }
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    float value1 = param1.getFloat();
-    if (param1.exists()) {
-      param2.streamFloats(value2 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamFloatValueInFloatStreamOutFunction extends AbstractFloatValueStream {
-  private final FloatValueStream param1;
-  private final FloatValue param2;
-  private final TwoFloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class TwoLongValueInLongValueOutFunction extends AbstractLongValue {
+    private final LongValue param1;
+    private final LongValue param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoLongValueInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue param1, LongValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public FloatStreamFloatValueInFloatStreamOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValueStream param1, FloatValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    private boolean exists = false;
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    float value2 = param2.getFloat();
-    if (param2.exists()) {
-      param1.streamFloats(value1 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public long getLong() {
+      long value = lambda.apply(param1.getLong(), param2.getLong());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-abstract class MultiFloatValueInFloatValueOutFunction extends AbstractFloatValue {
-  protected final FloatValue[] params;
-  protected final TwoFloatInFloatOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public MultiFloatValueInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
-  }
+  static class LongValueLongStreamInLongStreamOutFunction extends AbstractLongValueStream {
+    private final LongValue param1;
+    private final LongValueStream param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongValueLongStreamInLongStreamOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue param1, LongValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  protected boolean exists = false;
-  protected float temp;
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long value1 = param1.getLong();
+      if (param1.exists()) {
+        param2.streamLongs(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class MultiFloatValueInFloatValueOutRequireAllFunction extends MultiFloatValueInFloatValueOutFunction {
 
-  public MultiFloatValueInFloatValueOutRequireAllFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
-    super(name, lambda, params);
+  static class LongStreamLongValueInLongStreamOutFunction extends AbstractLongValueStream {
+    private final LongValueStream param1;
+    private final LongValue param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongStreamLongValueInLongStreamOutFunction(String name, TwoLongInLongOutLambda lambda, LongValueStream param1, LongValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long value2 = param2.getLong();
+      if (param2.exists()) {
+        param1.streamLongs(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public float getFloat() {
-    float value = params[0].getFloat();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getFloat());
-      exists = params[i].exists();
+  abstract static class MultiLongValueInLongValueOutFunction extends AbstractLongValue {
+    protected final LongValue[] params;
+    protected final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public MultiLongValueInLongValueOutFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
+
+    protected boolean exists = false;
+    protected long temp;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
   }
-}
-class MultiFloatValueInFloatValueOutRequireOneFunction extends MultiFloatValueInFloatValueOutFunction {
-
-  public MultiFloatValueInFloatValueOutRequireOneFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public float getFloat() {
-    int i = -1;
-    float value = 0;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getFloat();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+
+  static class MultiLongValueInLongValueOutRequireAllFunction extends MultiLongValueInLongValueOutFunction {
+
+    public MultiLongValueInLongValueOutRequireAllFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
+      super(name, lambda, params);
     }
-    while (++i < params.length) {
-      temp = params[i].getFloat();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+
+    @Override
+    public long getLong() {
+      long value = params[0].getLong();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getLong());
+        exists = params[i].exists();
       }
+      return value;
     }
-    return value;
   }
-}
-class DoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
-  private final DoubleValue param;
-  private final DoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DoubleValueInDoubleValueOutFunction(String name, DoubleInDoubleOutLambda lambda, DoubleValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+  static class MultiLongValueInLongValueOutRequireOneFunction extends MultiLongValueInLongValueOutFunction {
 
-  private boolean exists = false;
+    public MultiLongValueInLongValueOutRequireOneFunction(String name, TwoLongInLongOutLambda lambda, LongValue[] params) {
+      super(name, lambda, params);
+    }
 
-  @Override
-  public double getDouble() {
-    double value = lambda.apply(param.getDouble());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public long getLong() {
+      int i = -1;
+      long value = 0;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getLong();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
+      }
+      while (++i < params.length) {
+        temp = params[i].getLong();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamInDoubleStreamOutFunction extends AbstractDoubleValueStream {
-  private final DoubleValueStream param;
-  private final DoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class FloatValueInFloatValueOutFunction extends AbstractFloatValue {
+    private final FloatValue param;
+    private final FloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  public DoubleStreamInDoubleStreamOutFunction(String name, DoubleInDoubleOutLambda lambda, DoubleValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
+    public FloatValueInFloatValueOutFunction(String name, FloatInFloatOutLambda lambda, FloatValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    param.streamDoubles(value -> cons.accept(lambda.apply(value)));
-  }
+    private boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamInDoubleValueOutFunction extends AbstractDoubleValue implements DoubleConsumer {
-  private final DoubleValueStream param;
-  private final TwoDoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleStreamInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private double value;
-
-  @Override
-  public double getDouble() {
-    exists = false;
-    param.streamDoubles(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(double paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    @Override
+    public float getFloat() {
+      float value = lambda.apply(param.getFloat());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class TwoDoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
-  private final DoubleValue param1;
-  private final DoubleValue param2;
-  private final TwoDoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoDoubleValueInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue param1, DoubleValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class FloatStreamInFloatStreamOutFunction extends AbstractFloatValueStream {
+    private final FloatValueStream param;
+    private final FloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  private boolean exists = false;
+    public FloatStreamInFloatStreamOutFunction(String name, FloatInFloatOutLambda lambda, FloatValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  @Override
-  public double getDouble() {
-    double value = lambda.apply(param1.getDouble(), param2.getDouble());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      param.streamFloats(value -> cons.accept(lambda.apply(value)));
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DoubleValueDoubleStreamInDoubleStreamOutFunction extends AbstractDoubleValueStream {
-  private final DoubleValue param1;
-  private final DoubleValueStream param2;
-  private final TwoDoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DoubleValueDoubleStreamInDoubleStreamOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue param1, DoubleValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class FloatStreamInFloatValueOutFunction extends AbstractFloatValue implements FloatConsumer {
+    private final FloatValueStream param;
+    private final TwoFloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    double value1 = param1.getDouble();
-    if (param1.exists()) {
-      param2.streamDoubles(value2 -> cons.accept(lambda.apply(value1,value2)));
+    public FloatStreamInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamDoubleValueInDoubleStreamOutFunction extends AbstractDoubleValueStream {
-  private final DoubleValueStream param1;
-  private final DoubleValue param2;
-  private final TwoDoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    private boolean exists = false;
+    private float value;
 
-  public DoubleStreamDoubleValueInDoubleStreamOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValueStream param1, DoubleValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    @Override
+    public float getFloat() {
+      exists = false;
+      param.streamFloats(this);
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+    public void accept(float paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
+      }
+    }
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    double value2 = param2.getDouble();
-    if (param2.exists()) {
-      param1.streamDoubles(value1 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-abstract class MultiDoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
-  protected final DoubleValue[] params;
-  protected final TwoDoubleInDoubleOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class TwoFloatValueInFloatValueOutFunction extends AbstractFloatValue {
+    private final FloatValue param1;
+    private final FloatValue param2;
+    private final TwoFloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoFloatValueInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue param1, FloatValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public MultiDoubleValueInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
-  }
+    private boolean exists = false;
 
-  protected boolean exists = false;
-  protected double temp;
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    @Override
+    public float getFloat() {
+      float value = lambda.apply(param1.getFloat(), param2.getFloat());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class MultiDoubleValueInDoubleValueOutRequireAllFunction extends MultiDoubleValueInDoubleValueOutFunction {
 
-  public MultiDoubleValueInDoubleValueOutRequireAllFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
-    super(name, lambda, params);
-  }
+  static class FloatValueFloatStreamInFloatStreamOutFunction extends AbstractFloatValueStream {
+    private final FloatValue param1;
+    private final FloatValueStream param2;
+    private final TwoFloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatValueFloatStreamInFloatStreamOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue param1, FloatValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      float value1 = param1.getFloat();
+      if (param1.exists()) {
+        param2.streamFloats(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public double getDouble() {
-    double value = params[0].getDouble();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getDouble());
-      exists = params[i].exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
   }
-}
-class MultiDoubleValueInDoubleValueOutRequireOneFunction extends MultiDoubleValueInDoubleValueOutFunction {
-
-  public MultiDoubleValueInDoubleValueOutRequireOneFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public double getDouble() {
-    int i = -1;
-    double value = 0;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getDouble();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+
+  static class FloatStreamFloatValueInFloatStreamOutFunction extends AbstractFloatValueStream {
+    private final FloatValueStream param1;
+    private final FloatValue param2;
+    private final TwoFloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatStreamFloatValueInFloatStreamOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValueStream param1, FloatValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
     }
-    while (++i < params.length) {
-      temp = params[i].getDouble();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      float value2 = param2.getFloat();
+      if (param2.exists()) {
+        param1.streamFloats(value1 -> cons.accept(lambda.apply(value1,value2)));
       }
     }
-    return value;
-  }
-}
-class DateValueInDateValueOutFunction extends AbstractDateValue {
-  private final DateValue param;
-  private final LongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateValueInDateValueOutFunction(String name, LongInLongOutLambda lambda, DateValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  private boolean exists = false;
+  abstract static class MultiFloatValueInFloatValueOutFunction extends AbstractFloatValue {
+    protected final FloatValue[] params;
+    protected final TwoFloatInFloatOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public long getLong() {
-    long value = lambda.apply(param.getLong());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    public MultiFloatValueInFloatValueOutFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamInDateStreamOutFunction extends AbstractDateValueStream {
-  private final DateValueStream param;
-  private final LongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    protected boolean exists = false;
+    protected float temp;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public DateStreamInDateStreamOutFunction(String name, LongInLongOutLambda lambda, DateValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    param.streamLongs(value -> cons.accept(lambda.apply(value)));
-  }
+  static class MultiFloatValueInFloatValueOutRequireAllFunction extends MultiFloatValueInFloatValueOutFunction {
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamInDateValueOutFunction extends AbstractDateValue implements LongConsumer {
-  private final DateValueStream param;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateStreamInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private long value;
-
-  @Override
-  public long getLong() {
-    exists = false;
-    param.streamLongs(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(long paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    public MultiFloatValueInFloatValueOutRequireAllFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
+      super(name, lambda, params);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public float getFloat() {
+      float value = params[0].getFloat();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getFloat());
+        exists = params[i].exists();
+      }
+      return value;
+    }
   }
-}
-class TwoDateValueInDateValueOutFunction extends AbstractDateValue {
-  private final DateValue param1;
-  private final DateValue param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoDateValueInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue param1, DateValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class MultiFloatValueInFloatValueOutRequireOneFunction extends MultiFloatValueInFloatValueOutFunction {
 
-  private boolean exists = false;
+    public MultiFloatValueInFloatValueOutRequireOneFunction(String name, TwoFloatInFloatOutLambda lambda, FloatValue[] params) {
+      super(name, lambda, params);
+    }
 
-  @Override
-  public long getLong() {
-    long value = lambda.apply(param1.getLong(), param2.getLong());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public float getFloat() {
+      int i = -1;
+      float value = 0;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getFloat();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
+      }
+      while (++i < params.length) {
+        temp = params[i].getFloat();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateValueDateStreamInDateStreamOutFunction extends AbstractDateValueStream {
-  private final DateValue param1;
-  private final DateValueStream param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class DoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
+    private final DoubleValue param;
+    private final DoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  public DateValueDateStreamInDateStreamOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue param1, DateValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+    public DoubleValueInDoubleValueOutFunction(String name, DoubleInDoubleOutLambda lambda, DoubleValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long value1 = param1.getLong();
-    if (param1.exists()) {
-      param2.streamLongs(value2 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public double getDouble() {
+      double value = lambda.apply(param.getDouble());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class DateStreamDateValueInDateStreamOutFunction extends AbstractDateValueStream {
-  private final DateValueStream param1;
-  private final DateValue param2;
-  private final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public DateStreamDateValueInDateStreamOutFunction(String name, TwoLongInLongOutLambda lambda, DateValueStream param1, DateValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class DoubleStreamInDoubleStreamOutFunction extends AbstractDoubleValueStream {
+    private final DoubleValueStream param;
+    private final DoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long value2 = param2.getLong();
-    if (param2.exists()) {
-      param1.streamLongs(value1 -> cons.accept(lambda.apply(value1,value2)));
+    public DoubleStreamInDoubleStreamOutFunction(String name, DoubleInDoubleOutLambda lambda, DoubleValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-abstract class MultiDateValueInDateValueOutFunction extends AbstractDateValue {
-  protected final DateValue[] params;
-  protected final TwoLongInLongOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      param.streamDoubles(value -> cons.accept(lambda.apply(value)));
+    }
 
-  public MultiDateValueInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  protected boolean exists = false;
-  protected long temp;
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+  static class DoubleStreamInDoubleValueOutFunction extends AbstractDoubleValue implements DoubleConsumer {
+    private final DoubleValueStream param;
+    private final TwoDoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class MultiDateValueInDateValueOutRequireAllFunction extends MultiDateValueInDateValueOutFunction {
+    public DoubleStreamInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  public MultiDateValueInDateValueOutRequireAllFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
-    super(name, lambda, params);
-  }
+    private boolean exists = false;
+    private double value;
 
-  @Override
-  public long getLong() {
-    long value = params[0].getLong();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      value = lambda.apply(value, params[i].getLong());
-      exists = params[i].exists();
+    @Override
+    public double getDouble() {
+      exists = false;
+      param.streamDoubles(this);
+      return value;
     }
-    return value;
-  }
-}
-class MultiDateValueInDateValueOutRequireOneFunction extends MultiDateValueInDateValueOutFunction {
-
-  public MultiDateValueInDateValueOutRequireOneFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public long getLong() {
-    int i = -1;
-    long value = 0;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getLong();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    while (++i < params.length) {
-      temp = params[i].getLong();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+    public void accept(double paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
       }
     }
-    return value;
-  }
-}
-class StringValueInStringValueOutFunction extends AbstractStringValue {
-  private final StringValue param;
-  private final StringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public StringValueInStringValueOutFunction(String name, StringInStringOutLambda lambda, StringValue param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  private boolean exists = false;
+  static class TwoDoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
+    private final DoubleValue param1;
+    private final DoubleValue param2;
+    private final TwoDoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoDoubleValueInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue param1, DoubleValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  @Override
-  public String getString() {
-    String value = lambda.apply(param.getString());
-    exists = param.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    private boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamInStringStreamOutFunction extends AbstractStringValueStream {
-  private final StringValueStream param;
-  private final StringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+    @Override
+    public double getDouble() {
+      double value = lambda.apply(param1.getDouble(), param2.getDouble());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  public StringStreamInStringStreamOutFunction(String name, StringInStringOutLambda lambda, StringValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    param.streamStrings(value -> cons.accept(lambda.apply(value)));
-  }
+  static class DoubleValueDoubleStreamInDoubleStreamOutFunction extends AbstractDoubleValueStream {
+    private final DoubleValue param1;
+    private final DoubleValueStream param2;
+    private final TwoDoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleValueDoubleStreamInDoubleStreamOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue param1, DoubleValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamInStringValueOutFunction extends AbstractStringValue implements Consumer<String> {
-  private final StringValueStream param;
-  private final TwoStringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValueStream param) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param = param;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
-  }
-
-  private boolean exists = false;
-  private String value;
-
-  @Override
-  public String getString() {
-    exists = false;
-    param.streamStrings(this);
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-  public void accept(String paramValue) {
-    if (!exists) {
-      exists = true;
-      value = paramValue;
-    } else {
-      value = lambda.apply(value, paramValue);
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      double value1 = param1.getDouble();
+      if (param1.exists()) {
+        param2.streamDoubles(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class TwoStringValueInStringValueOutFunction extends AbstractStringValue {
-  private final StringValue param1;
-  private final StringValue param2;
-  private final TwoStringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
 
-  public TwoStringValueInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue param1, StringValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
-  }
+  static class DoubleStreamDoubleValueInDoubleStreamOutFunction extends AbstractDoubleValueStream {
+    private final DoubleValueStream param1;
+    private final DoubleValue param2;
+    private final TwoDoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamDoubleValueInDoubleStreamOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValueStream param1, DoubleValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  private boolean exists = false;
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      double value2 = param2.getDouble();
+      if (param2.exists()) {
+        param1.streamDoubles(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
 
-  @Override
-  public String getString() {
-    String value = lambda.apply(param1.getString(), param2.getString());
-    exists = param1.exists() && param2.exists();
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
+  abstract static class MultiDoubleValueInDoubleValueOutFunction extends AbstractDoubleValue {
+    protected final DoubleValue[] params;
+    protected final TwoDoubleInDoubleOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public MultiDoubleValueInDoubleValueOutFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
+
+    protected boolean exists = false;
+    protected double temp;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class MultiDoubleValueInDoubleValueOutRequireAllFunction extends MultiDoubleValueInDoubleValueOutFunction {
+
+    public MultiDoubleValueInDoubleValueOutRequireAllFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
+      super(name, lambda, params);
+    }
+
+    @Override
+    public double getDouble() {
+      double value = params[0].getDouble();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getDouble());
+        exists = params[i].exists();
+      }
+      return value;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  static class MultiDoubleValueInDoubleValueOutRequireOneFunction extends MultiDoubleValueInDoubleValueOutFunction {
+
+    public MultiDoubleValueInDoubleValueOutRequireOneFunction(String name, TwoDoubleInDoubleOutLambda lambda, DoubleValue[] params) {
+      super(name, lambda, params);
+    }
+
+    @Override
+    public double getDouble() {
+      int i = -1;
+      double value = 0;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getDouble();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
+      }
+      while (++i < params.length) {
+        temp = params[i].getDouble();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
+    }
   }
-}
-class StringValueStringStreamInStringStreamOutFunction extends AbstractStringValueStream {
-  private final StringValue param1;
-  private final StringValueStream param2;
-  private final TwoStringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class DateValueInDateValueOutFunction extends AbstractDateValue {
+    private final DateValue param;
+    private final LongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateValueInDateValueOutFunction(String name, LongInLongOutLambda lambda, DateValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
 
-  public StringValueStringStreamInStringStreamOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue param1, StringValueStream param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    private boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = lambda.apply(param.getLong());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
+  static class DateStreamInDateStreamOutFunction extends AbstractDateValueStream {
+    private final DateValueStream param;
+    private final LongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamInDateStreamOutFunction(String name, LongInLongOutLambda lambda, DateValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      param.streamLongs(value -> cons.accept(lambda.apply(value)));
+    }
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    String value1 = param1.getString();
-    if (param1.exists()) {
-      param2.streamStrings(value2 -> cons.accept(lambda.apply(value1,value2)));
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
+  static class DateStreamInDateValueOutFunction extends AbstractDateValue implements LongConsumer {
+    private final DateValueStream param;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
+    private long value;
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public long getLong() {
+      exists = false;
+      param.streamLongs(this);
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+    public void accept(long paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+  static class TwoDateValueInDateValueOutFunction extends AbstractDateValue {
+    private final DateValue param1;
+    private final DateValue param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoDateValueInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue param1, DateValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    private boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = lambda.apply(param1.getLong(), param2.getLong());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  static class DateValueDateStreamInDateStreamOutFunction extends AbstractDateValueStream {
+    private final DateValue param1;
+    private final DateValueStream param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateValueDateStreamInDateStreamOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue param1, DateValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long value1 = param1.getLong();
+      if (param1.exists()) {
+        param2.streamLongs(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringStreamStringValueInStringStreamOutFunction extends AbstractStringValueStream {
-  private final StringValueStream param1;
-  private final StringValue param2;
-  private final TwoStringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class DateStreamDateValueInDateStreamOutFunction extends AbstractDateValueStream {
+    private final DateValueStream param1;
+    private final DateValue param2;
+    private final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamDateValueInDateStreamOutFunction(String name, TwoLongInLongOutLambda lambda, DateValueStream param1, DateValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
 
-  public StringStreamStringValueInStringStreamOutFunction(String name, TwoStringInStringOutLambda lambda, StringValueStream param1, StringValue param2) {
-    this.name = name;
-    this.lambda = lambda;
-    this.param1 = param1;
-    this.param2 = param2;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long value2 = param2.getLong();
+      if (param2.exists()) {
+        param1.streamLongs(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    String value2 = param2.getString();
-    if (param2.exists()) {
-      param1.streamStrings(value1 -> cons.accept(lambda.apply(value1,value2)));
+  abstract static class MultiDateValueInDateValueOutFunction extends AbstractDateValue {
+    protected final DateValue[] params;
+    protected final TwoLongInLongOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public MultiDateValueInDateValueOutFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
+
+    protected boolean exists = false;
+    protected long temp;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
+  static class MultiDateValueInDateValueOutRequireAllFunction extends LambdaFunction.MultiDateValueInDateValueOutFunction {
+
+    public MultiDateValueInDateValueOutRequireAllFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
+      super(name, lambda, params);
+    }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public long getLong() {
+      long value = params[0].getLong();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        value = lambda.apply(value, params[i].getLong());
+        exists = params[i].exists();
+      }
+      return value;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+  static class MultiDateValueInDateValueOutRequireOneFunction extends LambdaFunction.MultiDateValueInDateValueOutFunction {
+
+    public MultiDateValueInDateValueOutRequireOneFunction(String name, TwoLongInLongOutLambda lambda, DateValue[] params) {
+      super(name, lambda, params);
+    }
+
+    @Override
+    public long getLong() {
+      int i = -1;
+      long value = 0;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getLong();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
+      }
+      while (++i < params.length) {
+        temp = params[i].getLong();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  static class StringValueInStringValueOutFunction extends AbstractStringValue {
+    private final StringValue param;
+    private final StringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringValueInStringValueOutFunction(String name, StringInStringOutLambda lambda, StringValue param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
+
+    @Override
+    public String getString() {
+      String value = lambda.apply(param.getString());
+      exists = param.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-abstract class MultiStringValueInStringValueOutFunction extends AbstractStringValue {
-  protected final StringValue[] params;
-  protected final TwoStringInStringOutLambda lambda;
-  private final String name;
-  private final String exprStr;
-  private final ExpressionType funcType;
+  static class StringStreamInStringStreamOutFunction extends AbstractStringValueStream {
+    private final StringValueStream param;
+    private final StringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamInStringStreamOutFunction(String name, StringInStringOutLambda lambda, StringValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      param.streamStrings(value -> cons.accept(lambda.apply(value)));
+    }
 
-  public MultiStringValueInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
-    this.name = name;
-    this.lambda = lambda;
-    this.params = params;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
+  static class StringStreamInStringValueOutFunction extends AbstractStringValue implements Consumer<String> {
+    private final StringValueStream param;
+    private final TwoStringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValueStream param) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param = param;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param);
+    }
+
+    private boolean exists = false;
+    private String value;
+
+    @Override
+    public String getString() {
+      exists = false;
+      param.streamStrings(this);
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+    public void accept(String paramValue) {
+      if (!exists) {
+        exists = true;
+        value = paramValue;
+      } else {
+        value = lambda.apply(value, paramValue);
+      }
+    }
 
-  protected boolean exists = false;
-  protected String temp = null;
-  @Override
-  public boolean exists() {
-    return exists;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
+  static class TwoStringValueInStringValueOutFunction extends AbstractStringValue {
+    private final StringValue param1;
+    private final StringValue param2;
+    private final TwoStringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public TwoStringValueInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue param1, StringValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    private boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public String getString() {
+      String value = lambda.apply(param1.getString(), param2.getString());
+      exists = param1.exists() && param2.exists();
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+  static class StringValueStringStreamInStringStreamOutFunction extends AbstractStringValueStream {
+    private final StringValue param1;
+    private final StringValueStream param2;
+    private final TwoStringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringValueStringStreamInStringStreamOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue param1, StringValueStream param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      String value1 = param1.getString();
+      if (param1.exists()) {
+        param2.streamStrings(value2 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+  static class StringStreamStringValueInStringStreamOutFunction extends AbstractStringValueStream {
+    private final StringValueStream param1;
+    private final StringValue param2;
+    private final TwoStringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamStringValueInStringStreamOutFunction(String name, TwoStringInStringOutLambda lambda, StringValueStream param1, StringValue param2) {
+      this.name = name;
+      this.lambda = lambda;
+      this.param1 = param1;
+      this.param2 = param2;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param1,param2);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,param1,param2);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      String value2 = param2.getString();
+      if (param2.exists()) {
+        param1.streamStrings(value1 -> cons.accept(lambda.apply(value1,value2)));
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class MultiStringValueInStringValueOutRequireAllFunction extends MultiStringValueInStringValueOutFunction {
 
-  public MultiStringValueInStringValueOutRequireAllFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
-    super(name, lambda, params);
+  abstract static class MultiStringValueInStringValueOutFunction extends AbstractStringValue {
+    protected final StringValue[] params;
+    protected final TwoStringInStringOutLambda lambda;
+    private final String name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public MultiStringValueInStringValueOutFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
+      this.name = name;
+      this.lambda = lambda;
+      this.params = params;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,params);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,params);
+    }
+
+    protected boolean exists = false;
+    protected String temp = null;
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getString() {
-    String value = params[0].getString();
-    exists = params[0].exists();
-    for (int i = 1; i < params.length && exists; ++i) {
-      temp = params[i].getString();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
-      } else {
-        exists = false;
-        value = null;
+  static class MultiStringValueInStringValueOutRequireAllFunction extends MultiStringValueInStringValueOutFunction {
+
+    public MultiStringValueInStringValueOutRequireAllFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
+      super(name, lambda, params);
+    }
+
+    @Override
+    public String getString() {
+      String value = params[0].getString();
+      exists = params[0].exists();
+      for (int i = 1; i < params.length && exists; ++i) {
+        temp = params[i].getString();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        } else {
+          exists = false;
+          value = null;
+        }
       }
+      return value;
     }
-    return value;
   }
-}
-class MultiStringValueInStringValueOutRequireOneFunction extends MultiStringValueInStringValueOutFunction {
-
-  public MultiStringValueInStringValueOutRequireOneFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
-    super(name, lambda, params);
-  }
-
-  @Override
-  public String getString() {
-    int i = -1;
-    String value = null;
-    exists = false;
-    while (++i < params.length) {
-      value = params[i].getString();
-      exists = params[i].exists();
-      if (exists) {
-        break;
-      }
+
+  static class MultiStringValueInStringValueOutRequireOneFunction extends MultiStringValueInStringValueOutFunction {
+
+    public MultiStringValueInStringValueOutRequireOneFunction(String name, TwoStringInStringOutLambda lambda, StringValue[] params) {
+      super(name, lambda, params);
     }
-    while (++i < params.length) {
-      temp = params[i].getString();
-      if (params[i].exists()) {
-        value = lambda.apply(value, temp);
+
+    @Override
+    public String getString() {
+      int i = -1;
+      String value = null;
+      exists = false;
+      while (++i < params.length) {
+        value = params[i].getString();
+        exists = params[i].exists();
+        if (exists) {
+          break;
+        }
       }
+      while (++i < params.length) {
+        temp = params[i].getString();
+        if (params[i].exists()) {
+          value = lambda.apply(value, temp);
+        }
+      }
+      return value;
     }
-    return value;
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/RemoveFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/RemoveFunction.java
index 76605d67531..bda118097d0 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/RemoveFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/RemoveFunction.java
@@ -131,667 +131,684 @@ public class RemoveFunction {
     }
     return new StreamRemoveFunction(baseExpr,removeExpr);
   });
-}
-class StreamRemoveFunction extends AbstractAnalyticsValueStream {
-  private final AnalyticsValueStream baseExpr;
-  private final AnalyticsValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StreamRemoveFunction(AnalyticsValueStream baseExpr, AnalyticsValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
 
-  @Override
-  public void streamObjects(Consumer<Object> cons) {
-    Object removeValue = removeExpr.getObject();
-    if (removeExpr.exists()) {
-      baseExpr.streamObjects(value -> {
-        if (!removeValue.equals(value)) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamObjects(cons);
+  static class StreamRemoveFunction extends AbstractAnalyticsValueStream {
+    private final AnalyticsValueStream baseExpr;
+    private final AnalyticsValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StreamRemoveFunction(AnalyticsValueStream baseExpr, AnalyticsValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
+    @Override
+    public void streamObjects(Consumer<Object> cons) {
+      Object removeValue = removeExpr.getObject();
+      if (removeExpr.exists()) {
+        baseExpr.streamObjects(value -> {
+          if (!removeValue.equals(value)) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamObjects(cons);
+      }
+    }
 
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
+    @Override
+    public String getName() {
+      return name;
+    }
 
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class ValueRemoveFunction extends AbstractAnalyticsValue {
-  private final AnalyticsValue baseExpr;
-  private final AnalyticsValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public ValueRemoveFunction(AnalyticsValue baseExpr, AnalyticsValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class ValueRemoveFunction extends AbstractAnalyticsValue {
+    private final AnalyticsValue baseExpr;
+    private final AnalyticsValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public Object getObject() {
-    Object value = baseExpr.getObject();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value.equals(removeExpr.getObject()) ? (removeExpr.exists() ? false : true) : true;
+    public ValueRemoveFunction(AnalyticsValue baseExpr, AnalyticsValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-    return value;
-  }
 
-  @Override
-  public boolean exists() {
-    return exists;
-  }
+    boolean exists = false;
 
-  @Override
-  public String getName() {
-    return name;
-  }
+    @Override
+    public Object getObject() {
+      Object value = baseExpr.getObject();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value.equals(removeExpr.getObject()) ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
 
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
 
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamRemoveFunction extends AbstractBooleanValueStream {
-  private final BooleanValueStream baseExpr;
-  private final BooleanValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamRemoveFunction(BooleanValueStream baseExpr, BooleanValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    @Override
+    public String getName() {
+      return name;
+    }
 
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean removeValue = removeExpr.getBoolean();
-    if (removeExpr.exists()) {
-      baseExpr.streamBooleans(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamBooleans(cons);
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
+  static class BooleanStreamRemoveFunction extends AbstractBooleanValueStream {
+    private final BooleanValueStream baseExpr;
+    private final BooleanValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanRemoveFunction extends AbstractBooleanValue {
-  private final BooleanValue baseExpr;
-  private final BooleanValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanRemoveFunction(BooleanValue baseExpr, BooleanValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    public BooleanStreamRemoveFunction(BooleanValueStream baseExpr, BooleanValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
 
-  boolean exists = false;
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean removeValue = removeExpr.getBoolean();
+      if (removeExpr.exists()) {
+        baseExpr.streamBooleans(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamBooleans(cons);
+      }
+    }
 
-  @Override
-  public boolean getBoolean() {
-    boolean value = baseExpr.getBoolean();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getBoolean() ? (removeExpr.exists() ? false : true) : true;
+    @Override
+    public String getName() {
+      return name;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamRemoveFunction extends AbstractIntValueStream {
-  private final IntValueStream baseExpr;
-  private final IntValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntStreamRemoveFunction(IntValueStream baseExpr, IntValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
 
-  @Override
-  public void streamInts(IntConsumer cons) {
-    int removeValue = removeExpr.getInt();
-    if (removeExpr.exists()) {
-      baseExpr.streamInts(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamInts(cons);
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntRemoveFunction extends AbstractIntValue {
-  private final IntValue baseExpr;
-  private final IntValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntRemoveFunction(IntValue baseExpr, IntValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+  static class BooleanRemoveFunction extends AbstractBooleanValue {
+    private final BooleanValue baseExpr;
+    private final BooleanValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanRemoveFunction(BooleanValue baseExpr, BooleanValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
 
-  boolean exists = false;
+    boolean exists = false;
 
-  @Override
-  public int getInt() {
-    int value = baseExpr.getInt();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getInt() ? (removeExpr.exists() ? false : true) : true;
+    @Override
+    public boolean getBoolean() {
+      boolean value = baseExpr.getBoolean();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getBoolean() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamRemoveFunction extends AbstractLongValueStream {
-  private final LongValueStream baseExpr;
-  private final LongValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamRemoveFunction(LongValueStream baseExpr, LongValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long removeValue = removeExpr.getLong();
-    if (removeExpr.exists()) {
-      baseExpr.streamLongs(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamLongs(cons);
+  static class IntStreamRemoveFunction extends AbstractIntValueStream {
+    private final IntValueStream baseExpr;
+    private final IntValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntStreamRemoveFunction(IntValueStream baseExpr, IntValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongRemoveFunction extends AbstractLongValue {
-  private final LongValue baseExpr;
-  private final LongValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongRemoveFunction(LongValue baseExpr, LongValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public void streamInts(IntConsumer cons) {
+      int removeValue = removeExpr.getInt();
+      if (removeExpr.exists()) {
+        baseExpr.streamInts(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamInts(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class IntRemoveFunction extends AbstractIntValue {
+    private final IntValue baseExpr;
+    private final IntValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getLong() ? (removeExpr.exists() ? false : true) : true;
+    public IntRemoveFunction(IntValue baseExpr, IntValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamRemoveFunction extends AbstractFloatValueStream {
-  private final FloatValueStream baseExpr;
-  private final FloatValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatStreamRemoveFunction(FloatValueStream baseExpr, FloatValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    boolean exists = false;
 
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    float removeValue = removeExpr.getFloat();
-    if (removeExpr.exists()) {
-      baseExpr.streamFloats(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamFloats(cons);
+    @Override
+    public int getInt() {
+      int value = baseExpr.getInt();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getInt() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatRemoveFunction extends AbstractFloatValue {
-  private final FloatValue baseExpr;
-  private final FloatValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatRemoveFunction(FloatValue baseExpr, FloatValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class LongStreamRemoveFunction extends AbstractLongValueStream {
+    private final LongValueStream baseExpr;
+    private final LongValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public float getFloat() {
-    float value = baseExpr.getFloat();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getFloat() ? (removeExpr.exists() ? false : true) : true;
+    public LongStreamRemoveFunction(LongValueStream baseExpr, LongValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamRemoveFunction extends AbstractDoubleValueStream {
-  private final DoubleValueStream baseExpr;
-  private final DoubleValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleStreamRemoveFunction(DoubleValueStream baseExpr, DoubleValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long removeValue = removeExpr.getLong();
+      if (removeExpr.exists()) {
+        baseExpr.streamLongs(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamLongs(cons);
+      }
+    }
 
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    double removeValue = removeExpr.getDouble();
-    if (removeExpr.exists()) {
-      baseExpr.streamDoubles(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamDoubles(cons);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleRemoveFunction extends AbstractDoubleValue {
-  private final DoubleValue baseExpr;
-  private final DoubleValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleRemoveFunction(DoubleValue baseExpr, DoubleValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+  static class LongRemoveFunction extends AbstractLongValue {
+    private final LongValue baseExpr;
+    private final LongValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongRemoveFunction(LongValue baseExpr, LongValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
 
-  boolean exists = false;
+    boolean exists = false;
 
-  @Override
-  public double getDouble() {
-    double value = baseExpr.getDouble();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getDouble() ? (removeExpr.exists() ? false : true) : true;
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getLong() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamRemoveFunction extends AbstractDateValueStream {
-  private final DateValueStream baseExpr;
-  private final DateValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateStreamRemoveFunction(DateValueStream baseExpr, DateValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long removeValue = removeExpr.getLong();
-    if (removeExpr.exists()) {
-      baseExpr.streamLongs(value -> {
-        if (removeValue != value) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamLongs(cons);
+  static class FloatStreamRemoveFunction extends AbstractFloatValueStream {
+    private final FloatValueStream baseExpr;
+    private final FloatValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatStreamRemoveFunction(FloatValueStream baseExpr, FloatValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateRemoveFunction extends AbstractDateValue {
-  private final DateValue baseExpr;
-  private final DateValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateRemoveFunction(DateValue baseExpr, DateValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      float removeValue = removeExpr.getFloat();
+      if (removeExpr.exists()) {
+        baseExpr.streamFloats(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamFloats(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class FloatRemoveFunction extends AbstractFloatValue {
+    private final FloatValue baseExpr;
+    private final FloatValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value==removeExpr.getLong() ? (removeExpr.exists() ? false : true) : true;
+    public FloatRemoveFunction(FloatValue baseExpr, FloatValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamRemoveFunction extends AbstractStringValueStream {
-  private final StringValueStream baseExpr;
-  private final StringValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamRemoveFunction(StringValueStream baseExpr, StringValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
-  }
+    boolean exists = false;
 
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    String removeValue = removeExpr.getString();
-    if (removeExpr.exists()) {
-      baseExpr.streamStrings(value -> {
-        if (!removeValue.equals(value)) cons.accept(value);
-      });
-    } else {
-      baseExpr.streamStrings(cons);
+    @Override
+    public float getFloat() {
+      float value = baseExpr.getFloat();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getFloat() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
-class StringRemoveFunction extends AbstractStringValue {
-  private final StringValue baseExpr;
-  private final StringValue removeExpr;
-  public static final String name = RemoveFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringRemoveFunction(StringValue baseExpr, StringValue removeExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.removeExpr = removeExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+
+  static class DoubleStreamRemoveFunction extends AbstractDoubleValueStream {
+    private final DoubleValueStream baseExpr;
+    private final DoubleValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamRemoveFunction(DoubleValueStream baseExpr, DoubleValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      double removeValue = removeExpr.getDouble();
+      if (removeExpr.exists()) {
+        baseExpr.streamDoubles(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamDoubles(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  boolean exists = false;
+  static class DoubleRemoveFunction extends AbstractDoubleValue {
+    private final DoubleValue baseExpr;
+    private final DoubleValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  @Override
-  public String getString() {
-    String value = baseExpr.getString();
-    exists = false;
-    if (baseExpr.exists()) {
-      exists = value.equals(removeExpr.getString()) ? (removeExpr.exists() ? false : true) : true;
+    public DoubleRemoveFunction(DoubleValue baseExpr, DoubleValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public double getDouble() {
+      double value = baseExpr.getDouble();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getDouble() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
-    return value;
   }
-  @Override
-  public boolean exists() {
-    return exists;
+
+  static class DateStreamRemoveFunction extends AbstractDateValueStream {
+    private final DateValueStream baseExpr;
+    private final DateValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamRemoveFunction(DateValueStream baseExpr, DateValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long removeValue = removeExpr.getLong();
+      if (removeExpr.exists()) {
+        baseExpr.streamLongs(value -> {
+          if (removeValue != value) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamLongs(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
+  static class DateRemoveFunction extends AbstractDateValue {
+    private final DateValue baseExpr;
+    private final DateValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateRemoveFunction(DateValue baseExpr, DateValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value==removeExpr.getLong() ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class StringStreamRemoveFunction extends AbstractStringValueStream {
+    private final StringValueStream baseExpr;
+    private final StringValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamRemoveFunction(StringValueStream baseExpr, StringValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      String removeValue = removeExpr.getString();
+      if (removeExpr.exists()) {
+        baseExpr.streamStrings(value -> {
+          if (!removeValue.equals(value)) cons.accept(value);
+        });
+      } else {
+        baseExpr.streamStrings(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
+
+  static class StringRemoveFunction extends AbstractStringValue {
+    private final StringValue baseExpr;
+    private final StringValue removeExpr;
+    public static final String name = RemoveFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringRemoveFunction(StringValue baseExpr, StringValue removeExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.removeExpr = removeExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,removeExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,removeExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public String getString() {
+      String value = baseExpr.getString();
+      exists = false;
+      if (baseExpr.exists()) {
+        exists = value.equals(removeExpr.getString()) ? (removeExpr.exists() ? false : true) : true;
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ReplaceFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ReplaceFunction.java
index 9c4204f5bd9..d61d75fee63 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ReplaceFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/mapping/ReplaceFunction.java
@@ -136,780 +136,797 @@ public class ReplaceFunction {
     return new StreamReplaceFunction(baseExpr,compExpr,fillExpr);
 
   });
-}
-class StreamReplaceFunction extends AbstractAnalyticsValueStream {
-  private final AnalyticsValueStream baseExpr;
-  private final AnalyticsValue compExpr;
-  private final AnalyticsValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StreamReplaceFunction(AnalyticsValueStream baseExpr, AnalyticsValue compExpr, AnalyticsValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
 
-  @Override
-  public void streamObjects(Consumer<Object> cons) {
-    Object compValue = compExpr.getObject();
-    if (compExpr.exists()) {
-      final Object fillValue = fillExpr.getObject();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamObjects(value -> {
-        if (value.equals(compValue)) {
-          if (fillExists) {
-            cons.accept(fillValue);
+  static class StreamReplaceFunction extends AbstractAnalyticsValueStream {
+    private final AnalyticsValueStream baseExpr;
+    private final AnalyticsValue compExpr;
+    private final AnalyticsValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StreamReplaceFunction(AnalyticsValueStream baseExpr, AnalyticsValue compExpr, AnalyticsValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamObjects(Consumer<Object> cons) {
+      Object compValue = compExpr.getObject();
+      if (compExpr.exists()) {
+        final Object fillValue = fillExpr.getObject();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamObjects(value -> {
+          if (value.equals(compValue)) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
           }
-        } else {
-          cons.accept(value);
-        }
-      });
-    }
-    else {
-      baseExpr.streamObjects(cons);
-    }
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class ValueReplaceFunction extends AbstractAnalyticsValue {
-  private final AnalyticsValue baseExpr;
-  private final AnalyticsValue compExpr;
-  private final AnalyticsValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public ValueReplaceFunction(AnalyticsValue baseExpr, AnalyticsValue compExpr, AnalyticsValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
-
-  @Override
-  public Object getObject() {
-    Object value = baseExpr.getObject();
-    exists = baseExpr.exists();
-    Object comp = compExpr.getObject();
-    if (exists && compExpr.exists() && value.equals(comp)) {
-      value = fillExpr.getObject();
-      exists = fillExpr.exists();
-    }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanStreamReplaceFunction extends AbstractBooleanValueStream {
-  private final BooleanValueStream baseExpr;
-  private final BooleanValue compExpr;
-  private final BooleanValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanStreamReplaceFunction(BooleanValueStream baseExpr, BooleanValue compExpr, BooleanValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamBooleans(BooleanConsumer cons) {
-    boolean compValue = compExpr.getBoolean();
-    if (compExpr.exists()) {
-      final boolean fillValue = fillExpr.getBoolean();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamBooleans(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
+        });
+      }
+      else {
+        baseExpr.streamObjects(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class ValueReplaceFunction extends AbstractAnalyticsValue {
+    private final AnalyticsValue baseExpr;
+    private final AnalyticsValue compExpr;
+    private final AnalyticsValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public ValueReplaceFunction(AnalyticsValue baseExpr, AnalyticsValue compExpr, AnalyticsValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public Object getObject() {
+      Object value = baseExpr.getObject();
+      exists = baseExpr.exists();
+      Object comp = compExpr.getObject();
+      if (exists && compExpr.exists() && value.equals(comp)) {
+        value = fillExpr.getObject();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class BooleanStreamReplaceFunction extends AbstractBooleanValueStream {
+    private final BooleanValueStream baseExpr;
+    private final BooleanValue compExpr;
+    private final BooleanValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanStreamReplaceFunction(BooleanValueStream baseExpr, BooleanValue compExpr, BooleanValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamBooleans(BooleanConsumer cons) {
+      boolean compValue = compExpr.getBoolean();
+      if (compExpr.exists()) {
+        final boolean fillValue = fillExpr.getBoolean();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamBooleans(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
           }
-        } else {
-          cons.accept(value);
-        }
-      });
-    }
-    else {
-      baseExpr.streamBooleans(cons);
-    }
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class BooleanReplaceFunction extends AbstractBooleanValue {
-  private final BooleanValue baseExpr;
-  private final BooleanValue compExpr;
-  private final BooleanValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public BooleanReplaceFunction(BooleanValue baseExpr, BooleanValue compExpr, BooleanValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
-
-  @Override
-  public boolean getBoolean() {
-    boolean value = baseExpr.getBoolean();
-    exists = baseExpr.exists();
-    boolean comp = compExpr.getBoolean();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getBoolean();
-      exists = fillExpr.exists();
-    }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntStreamReplaceFunction extends AbstractIntValueStream {
-  private final IntValueStream baseExpr;
-  private final IntValue compExpr;
-  private final IntValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntStreamReplaceFunction(IntValueStream baseExpr, IntValue compExpr, IntValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamInts(IntConsumer cons) {
-    int compValue = compExpr.getInt();
-    if (compExpr.exists()) {
-      final int fillValue = fillExpr.getInt();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamInts(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
+        });
+      }
+      else {
+        baseExpr.streamBooleans(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class BooleanReplaceFunction extends AbstractBooleanValue {
+    private final BooleanValue baseExpr;
+    private final BooleanValue compExpr;
+    private final BooleanValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public BooleanReplaceFunction(BooleanValue baseExpr, BooleanValue compExpr, BooleanValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public boolean getBoolean() {
+      boolean value = baseExpr.getBoolean();
+      exists = baseExpr.exists();
+      boolean comp = compExpr.getBoolean();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getBoolean();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class IntStreamReplaceFunction extends AbstractIntValueStream {
+    private final IntValueStream baseExpr;
+    private final IntValue compExpr;
+    private final IntValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntStreamReplaceFunction(IntValueStream baseExpr, IntValue compExpr, IntValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamInts(IntConsumer cons) {
+      int compValue = compExpr.getInt();
+      if (compExpr.exists()) {
+        final int fillValue = fillExpr.getInt();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamInts(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
           }
-        } else {
-          cons.accept(value);
-        }
-      });
-    }
-    else {
-      baseExpr.streamInts(cons);
-    }
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class IntReplaceFunction extends AbstractIntValue {
-  private final IntValue baseExpr;
-  private final IntValue compExpr;
-  private final IntValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public IntReplaceFunction(IntValue baseExpr, IntValue compExpr, IntValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
-
-  @Override
-  public int getInt() {
-    int value = baseExpr.getInt();
-    exists = baseExpr.exists();
-    int comp = compExpr.getInt();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getInt();
-      exists = fillExpr.exists();
-    }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongStreamReplaceFunction extends AbstractLongValueStream {
-  private final LongValueStream baseExpr;
-  private final LongValue compExpr;
-  private final LongValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongStreamReplaceFunction(LongValueStream baseExpr, LongValue compExpr, LongValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long compValue = compExpr.getLong();
-    if (compExpr.exists()) {
-      final long fillValue = fillExpr.getLong();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamLongs(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
+        });
+      }
+      else {
+        baseExpr.streamInts(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class IntReplaceFunction extends AbstractIntValue {
+    private final IntValue baseExpr;
+    private final IntValue compExpr;
+    private final IntValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public IntReplaceFunction(IntValue baseExpr, IntValue compExpr, IntValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public int getInt() {
+      int value = baseExpr.getInt();
+      exists = baseExpr.exists();
+      int comp = compExpr.getInt();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getInt();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class LongStreamReplaceFunction extends AbstractLongValueStream {
+    private final LongValueStream baseExpr;
+    private final LongValue compExpr;
+    private final LongValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongStreamReplaceFunction(LongValueStream baseExpr, LongValue compExpr, LongValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long compValue = compExpr.getLong();
+      if (compExpr.exists()) {
+        final long fillValue = fillExpr.getLong();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamLongs(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
           }
-        } else {
-          cons.accept(value);
-        }
-      });
-    }
-    else {
-      baseExpr.streamLongs(cons);
-    }
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class LongReplaceFunction extends AbstractLongValue {
-  private final LongValue baseExpr;
-  private final LongValue compExpr;
-  private final LongValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public LongReplaceFunction(LongValue baseExpr, LongValue compExpr, LongValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
-
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = baseExpr.exists();
-    long comp = compExpr.getLong();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getLong();
-      exists = fillExpr.exists();
-    }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatStreamReplaceFunction extends AbstractFloatValueStream {
-  private final FloatValueStream baseExpr;
-  private final FloatValue compExpr;
-  private final FloatValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatStreamReplaceFunction(FloatValueStream baseExpr, FloatValue compExpr, FloatValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamFloats(FloatConsumer cons) {
-    float compValue = compExpr.getFloat();
-    if (compExpr.exists()) {
-      final float fillValue = fillExpr.getFloat();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamFloats(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
+        });
+      }
+      else {
+        baseExpr.streamLongs(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class LongReplaceFunction extends AbstractLongValue {
+    private final LongValue baseExpr;
+    private final LongValue compExpr;
+    private final LongValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public LongReplaceFunction(LongValue baseExpr, LongValue compExpr, LongValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = baseExpr.exists();
+      long comp = compExpr.getLong();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getLong();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class FloatStreamReplaceFunction extends AbstractFloatValueStream {
+    private final FloatValueStream baseExpr;
+    private final FloatValue compExpr;
+    private final FloatValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatStreamReplaceFunction(FloatValueStream baseExpr, FloatValue compExpr, FloatValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamFloats(FloatConsumer cons) {
+      float compValue = compExpr.getFloat();
+      if (compExpr.exists()) {
+        final float fillValue = fillExpr.getFloat();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamFloats(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
           }
-        } else {
-          cons.accept(value);
-        }
-      });
-    }
-    else {
-      baseExpr.streamFloats(cons);
+        });
+      }
+      else {
+        baseExpr.streamFloats(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class FloatReplaceFunction extends AbstractFloatValue {
+    private final FloatValue baseExpr;
+    private final FloatValue compExpr;
+    private final FloatValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public FloatReplaceFunction(FloatValue baseExpr, FloatValue compExpr, FloatValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public float getFloat() {
+      float value = baseExpr.getFloat();
+      exists = baseExpr.exists();
+      float comp = compExpr.getFloat();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getFloat();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class DoubleStreamReplaceFunction extends AbstractDoubleValueStream {
+    private final DoubleValueStream baseExpr;
+    private final DoubleValue compExpr;
+    private final DoubleValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleStreamReplaceFunction(DoubleValueStream baseExpr, DoubleValue compExpr, DoubleValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamDoubles(DoubleConsumer cons) {
+      double compValue = compExpr.getDouble();
+      if (compExpr.exists()) {
+        final double fillValue = fillExpr.getDouble();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamDoubles(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
+          }
+        });
+      }
+      else {
+        baseExpr.streamDoubles(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class DoubleReplaceFunction extends AbstractDoubleValue {
+    private final DoubleValue baseExpr;
+    private final DoubleValue compExpr;
+    private final DoubleValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DoubleReplaceFunction(DoubleValue baseExpr, DoubleValue compExpr, DoubleValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public double getDouble() {
+      double value = baseExpr.getDouble();
+      exists = baseExpr.exists();
+      double comp = compExpr.getDouble();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getDouble();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class DateStreamReplaceFunction extends AbstractDateValueStream {
+    private final DateValueStream baseExpr;
+    private final DateValue compExpr;
+    private final DateValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateStreamReplaceFunction(DateValueStream baseExpr, DateValue compExpr, DateValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamLongs(LongConsumer cons) {
+      long compValue = compExpr.getLong();
+      if (compExpr.exists()) {
+        final long fillValue = fillExpr.getLong();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamLongs(value -> {
+          if (value == compValue) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
+          }
+        });
+      }
+      else {
+        baseExpr.streamLongs(cons);
+      }
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class DateReplaceFunction extends AbstractDateValue {
+    private final DateValue baseExpr;
+    private final DateValue compExpr;
+    private final DateValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public DateReplaceFunction(DateValue baseExpr, DateValue compExpr, DateValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    boolean exists = false;
+
+    @Override
+    public long getLong() {
+      long value = baseExpr.getLong();
+      exists = baseExpr.exists();
+      long comp = compExpr.getLong();
+      if (exists && compExpr.exists() && value == comp) {
+        value = fillExpr.getLong();
+        exists = fillExpr.exists();
+      }
+      return value;
+    }
+    @Override
+    public boolean exists() {
+      return exists;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
+    }
+  }
+
+  static class StringStreamReplaceFunction extends AbstractStringValueStream {
+    private final StringValueStream baseExpr;
+    private final StringValue compExpr;
+    private final StringValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
+
+    public StringStreamReplaceFunction(StringValueStream baseExpr, StringValue compExpr, StringValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
+    }
+
+    @Override
+    public void streamStrings(Consumer<String> cons) {
+      String compValue = compExpr.getString();
+      if (compExpr.exists()) {
+        final String fillValue = fillExpr.getString();
+        final boolean fillExists = fillExpr.exists();
+        baseExpr.streamStrings(value -> {
+          if (value.equals(compValue)) {
+            if (fillExists) {
+              cons.accept(fillValue);
+            }
+          } else {
+            cons.accept(value);
+          }
+        });
+      }
+      else {
+        baseExpr.streamStrings(cons);
+      }
     }
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class FloatReplaceFunction extends AbstractFloatValue {
-  private final FloatValue baseExpr;
-  private final FloatValue compExpr;
-  private final FloatValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public FloatReplaceFunction(FloatValue baseExpr, FloatValue compExpr, FloatValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
 
-  @Override
-  public float getFloat() {
-    float value = baseExpr.getFloat();
-    exists = baseExpr.exists();
-    float comp = compExpr.getFloat();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getFloat();
-      exists = fillExpr.exists();
+    @Override
+    public String getName() {
+      return name;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleStreamReplaceFunction extends AbstractDoubleValueStream {
-  private final DoubleValueStream baseExpr;
-  private final DoubleValue compExpr;
-  private final DoubleValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleStreamReplaceFunction(DoubleValueStream baseExpr, DoubleValue compExpr, DoubleValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamDoubles(DoubleConsumer cons) {
-    double compValue = compExpr.getDouble();
-    if (compExpr.exists()) {
-      final double fillValue = fillExpr.getDouble();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamDoubles(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
-          }
-        } else {
-          cons.accept(value);
-        }
-      });
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
     }
-    else {
-      baseExpr.streamDoubles(cons);
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DoubleReplaceFunction extends AbstractDoubleValue {
-  private final DoubleValue baseExpr;
-  private final DoubleValue compExpr;
-  private final DoubleValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DoubleReplaceFunction(DoubleValue baseExpr, DoubleValue compExpr, DoubleValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
+  static class StringReplaceFunction extends AbstractStringValue {
+    private final StringValue baseExpr;
+    private final StringValue compExpr;
+    private final StringValue fillExpr;
+    public static final String name = ReplaceFunction.name;
+    private final String exprStr;
+    private final ExpressionType funcType;
 
-  boolean exists = false;
-
-  @Override
-  public double getDouble() {
-    double value = baseExpr.getDouble();
-    exists = baseExpr.exists();
-    double comp = compExpr.getDouble();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getDouble();
-      exists = fillExpr.exists();
+    public StringReplaceFunction(StringValue baseExpr, StringValue compExpr, StringValue fillExpr) throws SolrException {
+      this.baseExpr = baseExpr;
+      this.compExpr = compExpr;
+      this.fillExpr = fillExpr;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
+      this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateStreamReplaceFunction extends AbstractDateValueStream {
-  private final DateValueStream baseExpr;
-  private final DateValue compExpr;
-  private final DateValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateStreamReplaceFunction(DateValueStream baseExpr, DateValue compExpr, DateValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
+    boolean exists = false;
 
-  @Override
-  public void streamLongs(LongConsumer cons) {
-    long compValue = compExpr.getLong();
-    if (compExpr.exists()) {
-      final long fillValue = fillExpr.getLong();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamLongs(value -> {
-        if (value == compValue) {
-          if (fillExists) {
-            cons.accept(fillValue);
-          }
-        } else {
-          cons.accept(value);
-        }
-      });
+    @Override
+    public String getString() {
+      String value = baseExpr.getString();
+      exists = baseExpr.exists();
+      String comp = compExpr.getString();
+      if (exists && compExpr.exists() && value.equals(comp)) {
+        value = fillExpr.getString();
+        exists = fillExpr.exists();
+      }
+      return value;
     }
-    else {
-      baseExpr.streamLongs(cons);
+    @Override
+    public boolean exists() {
+      return exists;
     }
-  }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class DateReplaceFunction extends AbstractDateValue {
-  private final DateValue baseExpr;
-  private final DateValue compExpr;
-  private final DateValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public DateReplaceFunction(DateValue baseExpr, DateValue compExpr, DateValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
-
-  @Override
-  public long getLong() {
-    long value = baseExpr.getLong();
-    exists = baseExpr.exists();
-    long comp = compExpr.getLong();
-    if (exists && compExpr.exists() && value == comp) {
-      value = fillExpr.getLong();
-      exists = fillExpr.exists();
+    @Override
+    public String getName() {
+      return name;
     }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
-class StringStreamReplaceFunction extends AbstractStringValueStream {
-  private final StringValueStream baseExpr;
-  private final StringValue compExpr;
-  private final StringValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringStreamReplaceFunction(StringValueStream baseExpr, StringValue compExpr, StringValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  @Override
-  public void streamStrings(Consumer<String> cons) {
-    String compValue = compExpr.getString();
-    if (compExpr.exists()) {
-      final String fillValue = fillExpr.getString();
-      final boolean fillExists = fillExpr.exists();
-      baseExpr.streamStrings(value -> {
-        if (value.equals(compValue)) {
-          if (fillExists) {
-            cons.accept(fillValue);
-          }
-        } else {
-          cons.accept(value);
-        }
-      });
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
     }
-    else {
-      baseExpr.streamStrings(cons);
+    @Override
+    public ExpressionType getExpressionType() {
+      return funcType;
     }
   }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
 }
-class StringReplaceFunction extends AbstractStringValue {
-  private final StringValue baseExpr;
-  private final StringValue compExpr;
-  private final StringValue fillExpr;
-  public static final String name = ReplaceFunction.name;
-  private final String exprStr;
-  private final ExpressionType funcType;
-
-  public StringReplaceFunction(StringValue baseExpr, StringValue compExpr, StringValue fillExpr) throws SolrException {
-    this.baseExpr = baseExpr;
-    this.compExpr = compExpr;
-    this.fillExpr = fillExpr;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,baseExpr,compExpr,fillExpr);
-    this.funcType = AnalyticsValueStream.determineMappingPhase(exprStr,baseExpr,compExpr,fillExpr);
-  }
-
-  boolean exists = false;
 
-  @Override
-  public String getString() {
-    String value = baseExpr.getString();
-    exists = baseExpr.exists();
-    String comp = compExpr.getString();
-    if (exists && compExpr.exists() && value.equals(comp)) {
-      value = fillExpr.getString();
-      exists = fillExpr.exists();
-    }
-    return value;
-  }
-  @Override
-  public boolean exists() {
-    return exists;
-  }
-
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return funcType;
-  }
-}
\ No newline at end of file
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MaxFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MaxFunction.java
index 8d142ea3fea..af7be67e9d2 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MaxFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MaxFunction.java
@@ -73,226 +73,233 @@ public class MaxFunction {
     throw new SolrException(ErrorCode.BAD_REQUEST,"The "+name+" function requires a comparable parameter. " +
           "Incorrect parameter: "+params[0].getExpressionStr());
   });
-}
-class IntMaxFunction extends AbstractIntValue implements ReductionFunction {
-  private IntMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public IntMaxFunction(IntValueStream param) {
-    this.collector = new IntMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
 
-  @Override
-  public int getInt() {
-    return collector.exists() ? collector.max() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+  static class IntMaxFunction extends AbstractIntValue implements ReductionFunction {
+    private IntMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (IntMaxCollector)sync.apply(collector);
-  }
+    public IntMaxFunction(IntValueStream param) {
+      this.collector = new IntMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class LongMaxFunction extends AbstractLongValue implements ReductionFunction {
-  private LongMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public LongMaxFunction(LongValueStream param) {
-    this.collector = new LongMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    @Override
+    public int getInt() {
+      return collector.exists() ? collector.max() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public long getLong() {
-    return collector.exists() ? collector.max() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (IntMaxCollector)sync.apply(collector);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (LongMaxCollector)sync.apply(collector);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class FloatMaxFunction extends AbstractFloatValue implements ReductionFunction {
-  private FloatMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public FloatMaxFunction(FloatValueStream param) {
-    this.collector = new FloatMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+  static class LongMaxFunction extends AbstractLongValue implements ReductionFunction {
+    private LongMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
 
-  @Override
-  public float getFloat() {
-    return collector.exists() ? collector.max() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    public LongMaxFunction(LongValueStream param) {
+      this.collector = new LongMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (FloatMaxCollector)sync.apply(collector);
-  }
+    @Override
+    public long getLong() {
+      return collector.exists() ? collector.max() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DoubleMaxFunction extends AbstractDoubleValue implements ReductionFunction {
-  private DoubleMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public DoubleMaxFunction(DoubleValueStream param) {
-    this.collector = new DoubleMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (LongMaxCollector)sync.apply(collector);
+    }
 
-  @Override
-  public double getDouble() {
-    return collector.exists() ? collector.max() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (DoubleMaxCollector)sync.apply(collector);
-  }
+  static class FloatMaxFunction extends AbstractFloatValue implements ReductionFunction {
+    private FloatMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DateMaxFunction extends AbstractDateValue implements ReductionFunction {
-  private LongMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public DateMaxFunction(LongValueStream param) {
-    this.collector = new LongMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    public FloatMaxFunction(FloatValueStream param) {
+      this.collector = new FloatMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public long getLong() {
-    return collector.exists() ? collector.max() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    @Override
+    public float getFloat() {
+      return collector.exists() ? collector.max() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (LongMaxCollector)sync.apply(collector);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (FloatMaxCollector)sync.apply(collector);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class StringMaxFunction extends AbstractStringValue implements ReductionFunction {
-  private StringMaxCollector collector;
-  public static final String name = MaxFunction.name;
-  private final String exprStr;
-
-  public StringMaxFunction(StringValueStream param) {
-    this.collector = new StringMaxCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getString() {
-    return collector.exists() ? collector.max() : null;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+  static class DoubleMaxFunction extends AbstractDoubleValue implements ReductionFunction {
+    private DoubleMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (StringMaxCollector)sync.apply(collector);
-  }
+    public DoubleMaxFunction(DoubleValueStream param) {
+      this.collector = new DoubleMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public double getDouble() {
+      return collector.exists() ? collector.max() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (DoubleMaxCollector)sync.apply(collector);
+    }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class DateMaxFunction extends AbstractDateValue implements ReductionFunction {
+    private LongMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
+
+    public DateMaxFunction(LongValueStream param) {
+      this.collector = new LongMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public long getLong() {
+      return collector.exists() ? collector.max() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (LongMaxCollector)sync.apply(collector);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
+
+  static class StringMaxFunction extends AbstractStringValue implements ReductionFunction {
+    private StringMaxCollector collector;
+    public static final String name = MaxFunction.name;
+    private final String exprStr;
+
+    public StringMaxFunction(StringValueStream param) {
+      this.collector = new StringMaxCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public String getString() {
+      return collector.exists() ? collector.max() : null;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (StringMaxCollector)sync.apply(collector);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MedianFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MedianFunction.java
index 90d0ea56276..13c262b34e9 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MedianFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MedianFunction.java
@@ -60,141 +60,148 @@ public class MedianFunction {
     }
     throw new SolrException(ErrorCode.BAD_REQUEST,"The "+name+" function requires a date or numeric parameter.");
   });
-}
-abstract class NumericMedianFunction<T extends Comparable<T>> extends AbstractDoubleValue implements ReductionFunction {
-  protected SortedListCollector<T> collector;
-  public static final String name = MedianFunction.name;
-  private final String exprStr;
-
-  public NumericMedianFunction(DoubleValueStream param, SortedListCollector<T> collector) {
-    this.collector = collector;
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
 
-  protected abstract double collectOrd(int ord);
+  abstract static class NumericMedianFunction<T extends Comparable<T>> extends AbstractDoubleValue implements ReductionFunction {
+    protected SortedListCollector<T> collector;
+    public static final String name = MedianFunction.name;
+    private final String exprStr;
 
-  @Override
-  public double getDouble() {
-    int size = collector.size();
-    if (size == 0) {
-      return 0;
+    public NumericMedianFunction(DoubleValueStream param, SortedListCollector<T> collector) {
+      this.collector = collector;
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
     }
-    if (size % 2 == 0) {
-      return (collectOrd(size/2) + collectOrd(size/2 - 1))/2;
-    } else {
-      return collectOrd(size/2);
+
+    protected abstract double collectOrd(int ord);
+
+    @Override
+    public double getDouble() {
+      int size = collector.size();
+      if (size == 0) {
+        return 0;
+      }
+      if (size % 2 == 0) {
+        return (collectOrd(size/2) + collectOrd(size/2 - 1))/2;
+      } else {
+        return collectOrd(size/2);
+      }
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
     }
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
 
-  @SuppressWarnings("unchecked")
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedListCollector<T>)sync.apply(collector);
-    collector.calcMedian();
-  }
+    @SuppressWarnings("unchecked")
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedListCollector<T>)sync.apply(collector);
+      collector.calcMedian();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
 
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class IntMedianFunction extends NumericMedianFunction<Integer> {
-  public IntMedianFunction(IntValueStream param) {
-    super((DoubleValueStream) param, new SortedIntListCollector(param));
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  protected double collectOrd(int ord) {
-    return collector.get(ord);
-  }
-}
-class LongMedianFunction extends NumericMedianFunction<Long> {
-  public LongMedianFunction(LongValueStream param) {
-    super((DoubleValueStream) param, new SortedLongListCollector(param));
-  }
+  static class IntMedianFunction extends NumericMedianFunction<Integer> {
+    public IntMedianFunction(IntValueStream param) {
+      super((DoubleValueStream) param, new SortedIntListCollector(param));
+    }
 
-  @Override
-  protected double collectOrd(int ord) {
-    return collector.get(ord);
-  }
-}
-class FloatMedianFunction extends NumericMedianFunction<Float> {
-  public FloatMedianFunction(FloatValueStream param) {
-    super((DoubleValueStream) param, new SortedFloatListCollector(param));
+    @Override
+    protected double collectOrd(int ord) {
+      return collector.get(ord);
+    }
   }
 
-  @Override
-  protected double collectOrd(int ord) {
-    return collector.get(ord);
-  }
-}
-class DoubleMedianFunction extends NumericMedianFunction<Double> {
-  public DoubleMedianFunction(DoubleValueStream param) {
-    super(param, new SortedDoubleListCollector(param));
-  }
+  static class LongMedianFunction extends NumericMedianFunction<Long> {
+    public LongMedianFunction(LongValueStream param) {
+      super((DoubleValueStream) param, new SortedLongListCollector(param));
+    }
 
-  @Override
-  protected double collectOrd(int ord) {
-    return collector.get(ord);
-  }
-}
-class DateMedianFunction extends AbstractDateValue implements ReductionFunction {
-  private SortedLongListCollector collector;
-  public static final String name = MedianFunction.name;
-  private final String exprStr;
-
-  public DateMedianFunction(DateValueStream param) {
-    this.collector = new SortedLongListCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    @Override
+    protected double collectOrd(int ord) {
+      return collector.get(ord);
+    }
   }
 
-  @Override
-  public long getLong() {
-    int size = collector.size();
-    if (size == 0) {
-      return 0;
+  static class FloatMedianFunction extends NumericMedianFunction<Float> {
+    public FloatMedianFunction(FloatValueStream param) {
+      super((DoubleValueStream) param, new SortedFloatListCollector(param));
     }
-    if (size % 2 == 0) {
-      return (collector.get(size/2) + collector.get(size/2 - 1))/2;
-    } else {
-      return collector.get(size/2);
+
+    @Override
+    protected double collectOrd(int ord) {
+      return collector.get(ord);
     }
   }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedLongListCollector)sync.apply(collector);
-    collector.calcMedian();
-  }
+  static class DoubleMedianFunction extends NumericMedianFunction<Double> {
+    public DoubleMedianFunction(DoubleValueStream param) {
+      super(param, new SortedDoubleListCollector(param));
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+    @Override
+    protected double collectOrd(int ord) {
+      return collector.get(ord);
+    }
   }
 
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
+  static class DateMedianFunction extends AbstractDateValue implements ReductionFunction {
+    private SortedLongListCollector collector;
+    public static final String name = MedianFunction.name;
+    private final String exprStr;
+
+    public DateMedianFunction(DateValueStream param) {
+      this.collector = new SortedLongListCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public long getLong() {
+      int size = collector.size();
+      if (size == 0) {
+        return 0;
+      }
+      if (size % 2 == 0) {
+        return (collector.get(size/2) + collector.get(size/2 - 1))/2;
+      } else {
+        return collector.get(size/2);
+      }
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedLongListCollector)sync.apply(collector);
+      collector.calcMedian();
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MinFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MinFunction.java
index a7f654efaa6..6298eab0098 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MinFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/MinFunction.java
@@ -73,226 +73,233 @@ public class MinFunction {
     throw new SolrException(ErrorCode.BAD_REQUEST,"The "+name+" function requires a comparable parameter. " +
           "Incorrect parameter: "+params[0].getExpressionStr());
   });
-}
-class IntMinFunction extends AbstractIntValue implements ReductionFunction {
-  private IntMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public IntMinFunction(IntValueStream param) {
-    this.collector = new IntMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
 
-  @Override
-  public int getInt() {
-    return collector.exists() ? collector.min() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+  static class IntMinFunction extends AbstractIntValue implements ReductionFunction {
+    private IntMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (IntMinCollector)sync.apply(collector);
-  }
+    public IntMinFunction(IntValueStream param) {
+      this.collector = new IntMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class LongMinFunction extends AbstractLongValue implements ReductionFunction {
-  private LongMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public LongMinFunction(LongValueStream param) {
-    this.collector = new LongMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    @Override
+    public int getInt() {
+      return collector.exists() ? collector.min() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public long getLong() {
-    return collector.exists() ? collector.min() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (IntMinCollector)sync.apply(collector);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (LongMinCollector)sync.apply(collector);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class FloatMinFunction extends AbstractFloatValue implements ReductionFunction {
-  private FloatMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public FloatMinFunction(FloatValueStream param) {
-    this.collector = new FloatMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+  static class LongMinFunction extends AbstractLongValue implements ReductionFunction {
+    private LongMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
 
-  @Override
-  public float getFloat() {
-    return collector.exists() ? collector.min() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    public LongMinFunction(LongValueStream param) {
+      this.collector = new LongMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (FloatMinCollector)sync.apply(collector);
-  }
+    @Override
+    public long getLong() {
+      return collector.exists() ? collector.min() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DoubleMinFunction extends AbstractDoubleValue implements ReductionFunction {
-  private DoubleMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public DoubleMinFunction(DoubleValueStream param) {
-    this.collector = new DoubleMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (LongMinCollector)sync.apply(collector);
+    }
 
-  @Override
-  public double getDouble() {
-    return collector.exists() ? collector.min() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (DoubleMinCollector)sync.apply(collector);
-  }
+  static class FloatMinFunction extends AbstractFloatValue implements ReductionFunction {
+    private FloatMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DateMinFunction extends AbstractDateValue implements ReductionFunction {
-  private LongMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public DateMinFunction(LongValueStream param) {
-    this.collector = new LongMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
-  }
+    public FloatMinFunction(FloatValueStream param) {
+      this.collector = new FloatMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
 
-  @Override
-  public long getLong() {
-    return collector.exists() ? collector.min() : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+    @Override
+    public float getFloat() {
+      return collector.exists() ? collector.min() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (LongMinCollector)sync.apply(collector);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (FloatMinCollector)sync.apply(collector);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class StringMinFunction extends AbstractStringValue implements ReductionFunction {
-  private StringMinCollector collector;
-  public static final String name = MinFunction.name;
-  private final String exprStr;
-
-  public StringMinFunction(StringValueStream param) {
-    this.collector = new StringMinCollector(param);
-    this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getString() {
-    return collector.exists() ? collector.min() : null;
-  }
-  @Override
-  public boolean exists() {
-    return collector.exists();
-  }
+  static class DoubleMinFunction extends AbstractDoubleValue implements ReductionFunction {
+    private DoubleMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (StringMinCollector)sync.apply(collector);
-  }
+    public DoubleMinFunction(DoubleValueStream param) {
+      this.collector = new DoubleMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public double getDouble() {
+      return collector.exists() ? collector.min() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (DoubleMinCollector)sync.apply(collector);
+    }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class DateMinFunction extends AbstractDateValue implements ReductionFunction {
+    private LongMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
+
+    public DateMinFunction(LongValueStream param) {
+      this.collector = new LongMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public long getLong() {
+      return collector.exists() ? collector.min() : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (LongMinCollector)sync.apply(collector);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
+
+  static class StringMinFunction extends AbstractStringValue implements ReductionFunction {
+    private StringMinCollector collector;
+    public static final String name = MinFunction.name;
+    private final String exprStr;
+
+    public StringMinFunction(StringValueStream param) {
+      this.collector = new StringMinCollector(param);
+      this.exprStr = AnalyticsValueStream.createExpressionString(name,param);
+    }
+
+    @Override
+    public String getString() {
+      return collector.exists() ? collector.min() : null;
+    }
+    @Override
+    public boolean exists() {
+      return collector.exists();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (StringMinCollector)sync.apply(collector);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/OrdinalFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/OrdinalFunction.java
index e6ed5723ac6..a5aeed6bd2d 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/OrdinalFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/OrdinalFunction.java
@@ -87,274 +87,281 @@ public class OrdinalFunction {
                          ord,
                          param.getExpressionStr());
   }
-}
-class IntOrdinalFunction extends AbstractIntValue implements ReductionFunction {
-  private SortedIntListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public IntOrdinalFunction(IntValueStream param, int ordinal) {
-    this.collector = new SortedIntListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
-  }
 
-  @Override
-  public int getInt() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : 0;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+  static class IntOrdinalFunction extends AbstractIntValue implements ReductionFunction {
+    private SortedIntListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
+
+    public IntOrdinalFunction(IntValueStream param, int ordinal) {
+      this.collector = new SortedIntListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
-  }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedIntListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+    @Override
+    public int getInt() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : 0;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class LongOrdinalFunction extends AbstractLongValue implements ReductionFunction {
-  private SortedLongListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public LongOrdinalFunction(LongValueStream param, int ordinal) {
-    this.collector = new SortedLongListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedIntListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
 
-  @Override
-  public long getLong() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : 0;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
   }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedLongListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+  static class LongOrdinalFunction extends AbstractLongValue implements ReductionFunction {
+    private SortedLongListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class FloatOrdinalFunction extends AbstractFloatValue implements ReductionFunction {
-  private SortedFloatListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public FloatOrdinalFunction(FloatValueStream param, int ordinal) {
-    this.collector = new SortedFloatListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
-  }
+    public LongOrdinalFunction(LongValueStream param, int ordinal) {
+      this.collector = new SortedLongListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
+    }
 
-  @Override
-  public float getFloat() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : 0;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+    @Override
+    public long getLong() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : 0;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
-  }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedFloatListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedLongListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DoubleOrdinalFunction extends AbstractDoubleValue implements ReductionFunction {
-  private SortedDoubleListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public DoubleOrdinalFunction(DoubleValueStream param, int ordinal) {
-    this.collector = new SortedDoubleListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public double getDouble() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : 0;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+  static class FloatOrdinalFunction extends AbstractFloatValue implements ReductionFunction {
+    private SortedFloatListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
+
+    public FloatOrdinalFunction(FloatValueStream param, int ordinal) {
+      this.collector = new SortedFloatListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
-  }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedDoubleListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+    @Override
+    public float getFloat() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : 0;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DateOrdinalFunction extends AbstractDateValue implements ReductionFunction {
-  private SortedLongListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public DateOrdinalFunction(LongValueStream param, int ordinal) {
-    this.collector = new SortedLongListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedFloatListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
 
-  @Override
-  public long getLong() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : 0;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
   }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedLongListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+  static class DoubleOrdinalFunction extends AbstractDoubleValue implements ReductionFunction {
+    private SortedDoubleListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class StringOrdinalFunction extends AbstractStringValue implements ReductionFunction {
-  private SortedStringListCollector collector;
-  private int ordinal;
-  public static final String name = OrdinalFunction.name;
-  private final String exprStr;
-
-  public StringOrdinalFunction(StringValueStream param, int ordinal) {
-    this.collector = new SortedStringListCollector(param);
-    this.ordinal = ordinal;
-    this.exprStr = OrdinalFunction.createOrdinalExpressionString(param, ordinal);
-  }
+    public DoubleOrdinalFunction(DoubleValueStream param, int ordinal) {
+      this.collector = new SortedDoubleListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
+    }
 
-  @Override
-  public String getString() {
-    int size = collector.size();
-    if (ordinal > 0) {
-      return ordinal <= size ? collector.get(ordinal - 1) : null;
-    } else {
-      return (ordinal * -1) <= size ? collector.get(size + ordinal) : null;
+    @Override
+    public double getDouble() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : 0;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
     }
-  }
-  @Override
-  public boolean exists() {
-    return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
-  }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedStringListCollector)sync.apply(collector);
-    collector.calcOrdinal(ordinal);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedDoubleListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class DateOrdinalFunction extends AbstractDateValue implements ReductionFunction {
+    private SortedLongListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
+
+    public DateOrdinalFunction(LongValueStream param, int ordinal) {
+      this.collector = new SortedLongListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
+    }
+
+    @Override
+    public long getLong() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : 0;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : 0;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedLongListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
+
+  static class StringOrdinalFunction extends AbstractStringValue implements ReductionFunction {
+    private SortedStringListCollector collector;
+    private int ordinal;
+    public static final String name = OrdinalFunction.name;
+    private final String exprStr;
+
+    public StringOrdinalFunction(StringValueStream param, int ordinal) {
+      this.collector = new SortedStringListCollector(param);
+      this.ordinal = ordinal;
+      this.exprStr = createOrdinalExpressionString(param, ordinal);
+    }
+
+    @Override
+    public String getString() {
+      int size = collector.size();
+      if (ordinal > 0) {
+        return ordinal <= size ? collector.get(ordinal - 1) : null;
+      } else {
+        return (ordinal * -1) <= size ? collector.get(size + ordinal) : null;
+      }
+    }
+    @Override
+    public boolean exists() {
+      return (ordinal > 0 ? ordinal : (ordinal * -1)) <= collector.size();
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedStringListCollector)sync.apply(collector);
+      collector.calcOrdinal(ordinal);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/PercentileFunction.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/PercentileFunction.java
index a5ff6be8a64..981ee42ff8c 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/PercentileFunction.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/function/reduction/PercentileFunction.java
@@ -88,250 +88,257 @@ public class PercentileFunction {
                          perc,
                          param.getExpressionStr());
   }
-}
-class IntPercentileFunction extends AbstractIntValue implements ReductionFunction {
-  private SortedIntListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public IntPercentileFunction(IntValueStream param, double percentile) {
-    this.collector = new SortedIntListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
-  }
 
-  @Override
-  public int getInt() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
+  static class IntPercentileFunction extends AbstractIntValue implements ReductionFunction {
+    private SortedIntListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedIntListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
-  }
+    public IntPercentileFunction(IntValueStream param, double percentile) {
+      this.collector = new SortedIntListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class LongPercentileFunction extends AbstractLongValue implements ReductionFunction {
-  private SortedLongListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public LongPercentileFunction(LongValueStream param, double percentile) {
-    this.collector = new SortedLongListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
-  }
+    @Override
+    public int getInt() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
 
-  @Override
-  public long getLong() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedIntListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedLongListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class FloatPercentileFunction extends AbstractFloatValue implements ReductionFunction {
-  private SortedFloatListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public FloatPercentileFunction(FloatValueStream param, double percentile) {
-    this.collector = new SortedFloatListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
-  }
+  static class LongPercentileFunction extends AbstractLongValue implements ReductionFunction {
+    private SortedLongListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
 
-  @Override
-  public float getFloat() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
+    public LongPercentileFunction(LongValueStream param, double percentile) {
+      this.collector = new SortedLongListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedFloatListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
-  }
+    @Override
+    public long getLong() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DoublePercentileFunction extends AbstractDoubleValue implements ReductionFunction {
-  private SortedDoubleListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public DoublePercentileFunction(DoubleValueStream param, double percentile) {
-    this.collector = new SortedDoubleListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedLongListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
 
-  @Override
-  public double getDouble() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedDoubleListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
-  }
+  static class FloatPercentileFunction extends AbstractFloatValue implements ReductionFunction {
+    private SortedFloatListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class DatePercentileFunction extends AbstractDateValue implements ReductionFunction {
-  private SortedLongListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public DatePercentileFunction(LongValueStream param, double percentile) {
-    this.collector = new SortedLongListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
-  }
+    public FloatPercentileFunction(FloatValueStream param, double percentile) {
+      this.collector = new SortedFloatListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
 
-  @Override
-  public long getLong() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
+    @Override
+    public float getFloat() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedLongListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
-  }
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedFloatListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
 
-  @Override
-  public String getName() {
-    return name;
-  }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
-  }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
-  }
-}
-class StringPercentileFunction extends AbstractStringValue implements ReductionFunction {
-  private SortedStringListCollector collector;
-  private double percentile;
-  public static final String name = PercentileFunction.name;
-  private final String exprStr;
-
-  public StringPercentileFunction(StringValueStream param, double percentile) {
-    this.collector = new SortedStringListCollector(param);
-    this.percentile = percentile;
-    this.exprStr = PercentileFunction.createPercentileExpressionString(param, percentile);
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
 
-  @Override
-  public String getString() {
-    int size = collector.size();
-    return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : null;
-  }
-  @Override
-  public boolean exists() {
-    return collector.size() > 0;
-  }
+  static class DoublePercentileFunction extends AbstractDoubleValue implements ReductionFunction {
+    private SortedDoubleListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
 
-  @Override
-  public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
-    collector = (SortedStringListCollector)sync.apply(collector);
-    collector.calcPercentile(percentile);
-  }
+    public DoublePercentileFunction(DoubleValueStream param, double percentile) {
+      this.collector = new SortedDoubleListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
+
+    @Override
+    public double getDouble() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedDoubleListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
 
-  @Override
-  public String getName() {
-    return name;
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public String getExpressionStr() {
-    return exprStr;
+
+  static class DatePercentileFunction extends AbstractDateValue implements ReductionFunction {
+    private SortedLongListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
+
+    public DatePercentileFunction(LongValueStream param, double percentile) {
+      this.collector = new SortedLongListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
+
+    @Override
+    public long getLong() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : 0;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedLongListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-  @Override
-  public ExpressionType getExpressionType() {
-    return ExpressionType.REDUCTION;
+
+  static class StringPercentileFunction extends AbstractStringValue implements ReductionFunction {
+    private SortedStringListCollector collector;
+    private double percentile;
+    public static final String name = PercentileFunction.name;
+    private final String exprStr;
+
+    public StringPercentileFunction(StringValueStream param, double percentile) {
+      this.collector = new SortedStringListCollector(param);
+      this.percentile = percentile;
+      this.exprStr = createPercentileExpressionString(param, percentile);
+    }
+
+    @Override
+    public String getString() {
+      int size = collector.size();
+      return size > 0 ? collector.get((int) Math.round(percentile * size - .5)) : null;
+    }
+    @Override
+    public boolean exists() {
+      return collector.size() > 0;
+    }
+
+    @Override
+    public void synchronizeDataCollectors(UnaryOperator<ReductionDataCollector<?>> sync) {
+      collector = (SortedStringListCollector)sync.apply(collector);
+      collector.calcPercentile(percentile);
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+    @Override
+    public String getExpressionStr() {
+      return exprStr;
+    }
+    @Override
+    public ExpressionType getExpressionType() {
+      return ExpressionType.REDUCTION;
+    }
   }
-}
\ No newline at end of file
+}
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator.java
index c0ec919ca66..ed842083d15 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator.java
@@ -273,80 +273,84 @@ public abstract class FacetRangeGenerator<T extends Comparable<T>> {
     }
     return calc;
   }
-}
-class IntegerFacetRangeGenerator extends FacetRangeGenerator<Integer> {
-  public IntegerFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
 
-  @Override
-  protected Integer parseVal(String rawval) {
-    return Integer.valueOf(rawval);
-  }
-  @Override
-  public Integer parseAndAddGap(Integer value, String gap) {
-    return value.intValue() + Integer.valueOf(gap).intValue();
-  }
-}
-class LongFacetRangeGenerator extends FacetRangeGenerator<Long> {
-  public LongFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
+  static class IntegerFacetRangeGenerator extends FacetRangeGenerator<Integer> {
+    public IntegerFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
 
-  @Override
-  protected Long parseVal(String rawval) {
-    return Long.valueOf(rawval);
-  }
-  @Override
-  public Long parseAndAddGap(Long value, String gap) {
-    return value.longValue() + Long.valueOf(gap).longValue();
+    @Override
+    protected Integer parseVal(String rawval) {
+      return Integer.valueOf(rawval);
+    }
+    @Override
+    public Integer parseAndAddGap(Integer value, String gap) {
+      return value.intValue() + Integer.valueOf(gap).intValue();
+    }
   }
-}
 
-class FloatFacetRangeGenerator extends FacetRangeGenerator<Float> {
-  public FloatFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
+  static class LongFacetRangeGenerator extends FacetRangeGenerator<Long> {
+    public LongFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
 
-  @Override
-  protected Float parseVal(String rawval) {
-    return Float.valueOf(rawval);
-  }
-  @Override
-  public Float parseAndAddGap(Float value, String gap) {
-    return value.floatValue() + Float.valueOf(gap).floatValue();
+    @Override
+    protected Long parseVal(String rawval) {
+      return Long.valueOf(rawval);
+    }
+    @Override
+    public Long parseAndAddGap(Long value, String gap) {
+      return value.longValue() + Long.valueOf(gap).longValue();
+    }
   }
-}
 
-class DoubleFacetRangeGenerator extends FacetRangeGenerator<Double> {
-  public DoubleFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
+  static class FloatFacetRangeGenerator extends FacetRangeGenerator<Float> {
+    public FloatFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
 
-  @Override
-  protected Double parseVal(String rawval) {
-    return Double.valueOf(rawval);
-  }
-  @Override
-  public Double parseAndAddGap(Double value, String gap) {
-    return value.doubleValue() + Double.valueOf(gap).doubleValue();
-  }
-}
-class DateFacetRangeGenerator extends FacetRangeGenerator<Date> {
-  private final Date now;
-  public DateFacetRangeGenerator(final RangeFacet rangeFacet, final Date now) {
-    super(rangeFacet);
-    this.now = now;
+    @Override
+    protected Float parseVal(String rawval) {
+      return Float.valueOf(rawval);
+    }
+    @Override
+    public Float parseAndAddGap(Float value, String gap) {
+      return value.floatValue() + Float.valueOf(gap).floatValue();
+    }
   }
 
-  @Override
-  public String formatValue(Date val) {
-    return val.toInstant().toString();
-  }
-  @Override
-  protected Date parseVal(String rawval) {
-    return DateMathParser.parseMath(now, rawval);
-  }
-  @Override
-  protected Object parseGap(final String rawval) {
-    return rawval;
+  static class DoubleFacetRangeGenerator extends FacetRangeGenerator<Double> {
+    public DoubleFacetRangeGenerator(final RangeFacet rangeFacet) { super(rangeFacet); }
+
+    @Override
+    protected Double parseVal(String rawval) {
+      return Double.valueOf(rawval);
+    }
+    @Override
+    public Double parseAndAddGap(Double value, String gap) {
+      return value.doubleValue() + Double.valueOf(gap).doubleValue();
+    }
   }
-  @Override
-  public Date parseAndAddGap(Date value, String gap) throws java.text.ParseException {
-    final DateMathParser dmp = new DateMathParser();
-    dmp.setNow(value);
-    return dmp.parseMath(gap);
+
+  static class DateFacetRangeGenerator extends FacetRangeGenerator<Date> {
+    private final Date now;
+    public DateFacetRangeGenerator(final RangeFacet rangeFacet, final Date now) {
+      super(rangeFacet);
+      this.now = now;
+    }
+
+    @Override
+    public String formatValue(Date val) {
+      return val.toInstant().toString();
+    }
+    @Override
+    protected Date parseVal(String rawval) {
+      return DateMathParser.parseMath(now, rawval);
+    }
+    @Override
+    protected Object parseGap(final String rawval) {
+      return rawval;
+    }
+    @Override
+    public Date parseAndAddGap(Date value, String gap) throws java.text.ParseException {
+      final DateMathParser dmp = new DateMathParser();
+      dmp.setNow(value);
+      return dmp.parseMath(gap);
+    }
   }
 }
+
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/MedianCalculator.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/MedianCalculator.java
index 541cff07ca7..1cc7a36091c 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/MedianCalculator.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/MedianCalculator.java
@@ -53,7 +53,7 @@ public class MedianCalculator {
       split = split(list, begin, end);
     }
 
-    Point result = partition(list, begin, end, split);
+    OrdinalCalculator.Point result = partition(list, begin, end, split);
 
     if (place < result.low) {
       select(list, place, begin, result.low);
@@ -86,7 +86,7 @@ public class MedianCalculator {
     return list.get(recursiveSize / 2 + begin);
   }
 
-  private static <T extends Comparable<T>> Point partition(List<T> list, int begin, int end, T indexElement) {
+  private static <T extends Comparable<T>> OrdinalCalculator.Point partition(List<T> list, int begin, int end, T indexElement) {
     T temp;
     int left, right;
     for (left = begin, right = end; left < right; left++, right--) {
@@ -126,6 +126,6 @@ public class MedianCalculator {
       }
       rightMove++;
     }
-    return new Point(left, right);
+    return new OrdinalCalculator.Point(left, right);
   }
 }
diff --git a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/OrdinalCalculator.java b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/OrdinalCalculator.java
index 10975f6e0a5..5a28f4ae0e9 100644
--- a/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/OrdinalCalculator.java
+++ b/solr/contrib/analytics/src/java/org/apache/solr/analytics/util/OrdinalCalculator.java
@@ -157,14 +157,15 @@ public class OrdinalCalculator {
     }
     return new Point(left, right);
   }
-}
 
-class Point {
-  public int low;
-  public int high;
+  static class Point {
+    public int low;
+    public int high;
 
-  public Point(int low, int high) {
-    this.low = low;
-    this.high = high;
+    public Point(int low, int high) {
+      this.low = low;
+      this.high = high;
+    }
   }
 }
+
diff --git a/solr/core/src/java/org/apache/solr/handler/component/SortedDateStatsValues.java b/solr/core/src/java/org/apache/solr/handler/component/SortedDateStatsValues.java
index 9e6076f182c..2c027ba50af 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/SortedDateStatsValues.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/SortedDateStatsValues.java
@@ -29,12 +29,12 @@ import org.apache.solr.common.util.NamedList;
 
 public class SortedDateStatsValues implements StatsValues {
 
-  private final DateStatsValues dsv;
+  private final StatsValuesFactory.DateStatsValues dsv;
   private final String fieldName;
   private SortedNumericDocValues sndv;
 
 
-  public SortedDateStatsValues(DateStatsValues dsv, StatsField field) {
+  public SortedDateStatsValues(StatsValuesFactory.DateStatsValues dsv, StatsField field) {
     this.dsv = dsv;
     this.fieldName = field.getSchemaField().getName();
   }
diff --git a/solr/core/src/java/org/apache/solr/handler/component/SortedNumericStatsValues.java b/solr/core/src/java/org/apache/solr/handler/component/SortedNumericStatsValues.java
index 91b313d40e8..56b80cf53b2 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/SortedNumericStatsValues.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/SortedNumericStatsValues.java
@@ -29,13 +29,13 @@ import org.apache.solr.schema.NumberType;
 
 public class SortedNumericStatsValues implements StatsValues {
   
-  private final NumericStatsValues nsv;
+  private final StatsValuesFactory.NumericStatsValues nsv;
   private final String fieldName;
   private final NumberType numberType;
   private SortedNumericDocValues sndv;
   
   
-  public SortedNumericStatsValues(NumericStatsValues nsv, StatsField field) {
+  public SortedNumericStatsValues(StatsValuesFactory.NumericStatsValues nsv, StatsField field) {
     this.nsv = nsv;
     this.fieldName = field.getSchemaField().getName();
     this.numberType = field.getSchemaField().getType().getNumberType();
diff --git a/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java b/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
index 2cbdb73bb81..fc3dcc1f07c 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
@@ -86,781 +86,782 @@ public class StatsValuesFactory {
           "Field type " + fieldType + " is not currently supported");
     }
   }
-}
 
-/**
- * Abstract implementation of
- * {@link org.apache.solr.handler.component.StatsValues} that provides the
- * default behavior for most StatsValues implementations.
- *
- * There are very few requirements placed on what statistics concrete
- * implementations should collect, with the only required statistics being the
- * minimum and maximum values.
- */
-abstract class AbstractStatsValues<T> implements StatsValues {
-  private static final String FACETS = "facets";
-  
-  /** Tracks all data about tthe stats we need to collect */
-  final protected StatsField statsField;
-
-  /** may be null if we are collecting stats directly from a function ValueSource */
-  final protected SchemaField sf;
-  /**
-   * may be null if we are collecting stats directly from a function ValueSource
-   */
-  final protected FieldType ft;
-
-  // final booleans from StatsField to allow better inlining & JIT optimizing
-  final protected boolean computeCount;
-  final protected boolean computeMissing;
-  final protected boolean computeCalcDistinct; // needed for either countDistinct or distinctValues
-  final protected boolean computeMin;
-  final protected boolean computeMax;
-  final protected boolean computeMinOrMax;
-  final protected boolean computeCardinality; 
-
-  /** 
-   * Either a function value source to collect from, or the ValueSource associated 
-   * with a single valued field we are collecting from.  Will be null until/unless 
-   * {@link #setNextReader} is called at least once
-   */
-  private ValueSource valueSource;
-  /**
-   * Context to use when retrieving FunctionValues, will be null until/unless
-   * {@link #setNextReader} is called at least once
-   */
-  private Map vsContext;
   /**
-   * Values to collect, will be null until/unless {@link #setNextReader} is
-   * called at least once
-   */
-  protected FunctionValues values;
-  
-  protected T max;
-  protected T min;
-  protected long missing;
-  protected long count;
-  protected long countDistinct;
-  protected final Set<T> distinctValues;
-
-  /**
-   * Hash function that must be used by implementations of {@link #hash}
+   * Abstract implementation of
+   * {@link StatsValues} that provides the
+   * default behavior for most StatsValues implementations.
+   *
+   * There are very few requirements placed on what statistics concrete
+   * implementations should collect, with the only required statistics being the
+   * minimum and maximum values.
    */
-  protected final HashFunction hasher; 
-  // if null, no HLL logic can be computed; not final because of "union" optimization (see below)
-  private HLL hll; 
-
-  // facetField facetValue
-  protected Map<String,Map<String, StatsValues>> facets = new HashMap<>();
-  
-  protected AbstractStatsValues(StatsField statsField) {
-    this.statsField = statsField;
-    this.computeCount = statsField.calculateStats(Stat.count);
-    this.computeMissing = statsField.calculateStats(Stat.missing);
-    this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct) 
-      || statsField.calculateStats(Stat.distinctValues);
-    this.computeMin = statsField.calculateStats(Stat.min);
-    this.computeMax = statsField.calculateStats(Stat.max);
-    this.computeMinOrMax = computeMin || computeMax;
-    
-    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;
-
-    this.computeCardinality = statsField.calculateStats(Stat.cardinality);
-    if ( computeCardinality ) {
+  private abstract static class AbstractStatsValues<T> implements StatsValues {
+    private static final String FACETS = "facets";
+
+    /** Tracks all data about tthe stats we need to collect */
+    final protected StatsField statsField;
+
+    /** may be null if we are collecting stats directly from a function ValueSource */
+    final protected SchemaField sf;
+    /**
+     * may be null if we are collecting stats directly from a function ValueSource
+     */
+    final protected FieldType ft;
+
+    // final booleans from StatsField to allow better inlining & JIT optimizing
+    final protected boolean computeCount;
+    final protected boolean computeMissing;
+    final protected boolean computeCalcDistinct; // needed for either countDistinct or distinctValues
+    final protected boolean computeMin;
+    final protected boolean computeMax;
+    final protected boolean computeMinOrMax;
+    final protected boolean computeCardinality;
+
+    /**
+     * Either a function value source to collect from, or the ValueSource associated
+     * with a single valued field we are collecting from.  Will be null until/unless
+     * {@link #setNextReader} is called at least once
+     */
+    private ValueSource valueSource;
+    /**
+     * Context to use when retrieving FunctionValues, will be null until/unless
+     * {@link #setNextReader} is called at least once
+     */
+    private Map vsContext;
+    /**
+     * Values to collect, will be null until/unless {@link #setNextReader} is
+     * called at least once
+     */
+    protected FunctionValues values;
+
+    protected T max;
+    protected T min;
+    protected long missing;
+    protected long count;
+    protected long countDistinct;
+    protected final Set<T> distinctValues;
+
+    /**
+     * Hash function that must be used by implementations of {@link #hash}
+     */
+    protected final HashFunction hasher;
+    // if null, no HLL logic can be computed; not final because of "union" optimization (see below)
+    private HLL hll;
+
+    // facetField facetValue
+    protected Map<String,Map<String, StatsValues>> facets = new HashMap<>();
+
+    protected AbstractStatsValues(StatsField statsField) {
+      this.statsField = statsField;
+      this.computeCount = statsField.calculateStats(Stat.count);
+      this.computeMissing = statsField.calculateStats(Stat.missing);
+      this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct)
+        || statsField.calculateStats(Stat.distinctValues);
+      this.computeMin = statsField.calculateStats(Stat.min);
+      this.computeMax = statsField.calculateStats(Stat.max);
+      this.computeMinOrMax = computeMin || computeMax;
+
+      this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;
+
+      this.computeCardinality = statsField.calculateStats(Stat.cardinality);
+      if ( computeCardinality ) {
+
+        hasher = statsField.getHllOptions().getHasher();
+        hll = statsField.getHllOptions().newHLL();
+        assert null != hll : "Cardinality requires an HLL";
+      } else {
+        hll = null;
+        hasher = null;
+      }
 
-      hasher = statsField.getHllOptions().getHasher();
-      hll = statsField.getHllOptions().newHLL();
-      assert null != hll : "Cardinality requires an HLL";
-    } else {
-      hll = null;
-      hasher = null;
-    }
-
-    // alternatively, we could refactor a common base class that doesn't know/care
-    // about either SchemaField or ValueSource - but then there would be a lot of
-    // duplicate code between "NumericSchemaFieldStatsValues" and 
-    // "NumericValueSourceStatsValues" which would have diff parent classes
-    //
-    // part of the complexity here being that the StatsValues API serves two
-    // masters: collecting concrete Values from things like DocValuesStats and
-    // the distributed aggregation logic, but also collecting docIds which it
-    // then
-    // uses to go out and pull concreate values from the ValueSource
-    // (from a func, or single valued field)
-    if (null != statsField.getSchemaField()) {
-      assert null == statsField.getValueSource();
-      this.sf = statsField.getSchemaField();
-      this.ft = sf.getType();
-    } else {
-      assert null != statsField.getValueSource();
-      assert null == statsField.getSchemaField();
-      this.sf = null;
-      this.ft = null;
-    }
-  }
-  
-  @Override
-  public void accumulate(NamedList stv) {
-    if (computeCount) {
-      count += (Long) stv.get("count");
-    }
-    if (computeMissing) {
-      missing += (Long) stv.get("missing");
-    }
-    if (computeCalcDistinct) {
-      distinctValues.addAll((Collection<T>) stv.get("distinctValues"));
-      countDistinct = distinctValues.size();
-    }
-    
-    if (computeMinOrMax) {
-      updateMinMax((T) stv.get("min"), (T) stv.get("max"));
-    }
-
-    if (computeCardinality) {
-      byte[] data = (byte[]) stv.get("cardinality");
-      HLL other = HLL.fromBytes(data);
-      if (hll.getType().equals(HLLType.EMPTY)) {
-        // The HLL.union method goes out of it's way not to modify the "other" HLL.
-        // Which means in the case of merging into an "EMPTY" HLL (garunteed to happen at
-        // least once in every coordination of shard requests) it always clones all
-        // of the internal storage -- but since we're going to throw "other" away after
-        // the merge, this just means a short term doubling of RAM that we can skip.
-        hll = other;
+      // alternatively, we could refactor a common base class that doesn't know/care
+      // about either SchemaField or ValueSource - but then there would be a lot of
+      // duplicate code between "NumericSchemaFieldStatsValues" and
+      // "NumericValueSourceStatsValues" which would have diff parent classes
+      //
+      // part of the complexity here being that the StatsValues API serves two
+      // masters: collecting concrete Values from things like DocValuesStats and
+      // the distributed aggregation logic, but also collecting docIds which it
+      // then
+      // uses to go out and pull concreate values from the ValueSource
+      // (from a func, or single valued field)
+      if (null != statsField.getSchemaField()) {
+        assert null == statsField.getValueSource();
+        this.sf = statsField.getSchemaField();
+        this.ft = sf.getType();
       } else {
-        hll.union(other);
+        assert null != statsField.getValueSource();
+        assert null == statsField.getSchemaField();
+        this.sf = null;
+        this.ft = null;
       }
     }
 
-    updateTypeSpecificStats(stv);
-    
-    NamedList f = (NamedList) stv.get(FACETS);
-    if (f == null) {
-      return;
-    }
-    
-    for (int i = 0; i < f.size(); i++) {
-      String field = f.getName(i);
-      NamedList vals = (NamedList) f.getVal(i);
-      Map<String, StatsValues> addTo = facets.get(field);
-      if (addTo == null) {
-        addTo = new HashMap<>();
-        facets.put(field, addTo);
-      }
-      for (int j = 0; j < vals.size(); j++) {
-        String val = vals.getName(j);
-        StatsValues vvals = addTo.get(val);
-        if (vvals == null) {
-          vvals = StatsValuesFactory.createStatsValues(statsField);
-          addTo.put(val, vvals);
+    @Override
+    public void accumulate(NamedList stv) {
+      if (computeCount) {
+        count += (Long) stv.get("count");
+      }
+      if (computeMissing) {
+        missing += (Long) stv.get("missing");
+      }
+      if (computeCalcDistinct) {
+        distinctValues.addAll((Collection<T>) stv.get("distinctValues"));
+        countDistinct = distinctValues.size();
+      }
+
+      if (computeMinOrMax) {
+        updateMinMax((T) stv.get("min"), (T) stv.get("max"));
+      }
+
+      if (computeCardinality) {
+        byte[] data = (byte[]) stv.get("cardinality");
+        HLL other = HLL.fromBytes(data);
+        if (hll.getType().equals(HLLType.EMPTY)) {
+          // The HLL.union method goes out of it's way not to modify the "other" HLL.
+          // Which means in the case of merging into an "EMPTY" HLL (garunteed to happen at
+          // least once in every coordination of shard requests) it always clones all
+          // of the internal storage -- but since we're going to throw "other" away after
+          // the merge, this just means a short term doubling of RAM that we can skip.
+          hll = other;
+        } else {
+          hll.union(other);
         }
-        vvals.accumulate((NamedList) vals.getVal(j));
       }
-    }
-  }
-  
-  @Override
-  public void accumulate(BytesRef value, int count) {
-    if (null == ft) {
-      throw new IllegalStateException(
-          "Can't collect & convert BytesRefs on stats that do't use a a FieldType: "
-              + statsField);
-    }
-    T typedValue = (T) ft.toObject(sf, value);
-    accumulate(typedValue, count);
-  }
 
-  public void accumulate(T value, int count) { 
-    assert null != value : "Can't accumulate null";
+      updateTypeSpecificStats(stv);
 
-    if (computeCount) {
-      this.count += count;
-    }
-    if (computeCalcDistinct) {
-      distinctValues.add(value);
-      countDistinct = distinctValues.size();
-    }
-    if (computeMinOrMax) {
-      updateMinMax(value, value);
-    }
-    if (computeCardinality) {
-      if (null == hasher) {
-        assert value instanceof Number : "pre-hashed value support only works with numeric longs";
-        hll.addRaw(((Number)value).longValue());
-      } else {
-        hll.addRaw(hash(value));
+      NamedList f = (NamedList) stv.get(FACETS);
+      if (f == null) {
+        return;
       }
-    }
-    updateTypeSpecificStats(value, count);
-  }
-  
-  @Override
-  public void missing() {
-    if (computeMissing) {
-      missing++;
-    }
-  }
-  
-  @Override
-  public void addMissing(int count) {
-    missing += count;
-  }
-  
-  @Override
-  public void addFacet(String facetName, Map<String, StatsValues> facetValues) {
-    facets.put(facetName, facetValues);
-  }
-  
-  @Override
-  public NamedList<?> getStatsValues() {
-    NamedList<Object> res = new SimpleOrderedMap<>();
 
-    if (statsField.includeInResponse(Stat.min)) {
-      res.add("min", min);
+      for (int i = 0; i < f.size(); i++) {
+        String field = f.getName(i);
+        NamedList vals = (NamedList) f.getVal(i);
+        Map<String, StatsValues> addTo = facets.get(field);
+        if (addTo == null) {
+          addTo = new HashMap<>();
+          facets.put(field, addTo);
+        }
+        for (int j = 0; j < vals.size(); j++) {
+          String val = vals.getName(j);
+          StatsValues vvals = addTo.get(val);
+          if (vvals == null) {
+            vvals = createStatsValues(statsField);
+            addTo.put(val, vvals);
+          }
+          vvals.accumulate((NamedList) vals.getVal(j));
+        }
+      }
     }
-    if (statsField.includeInResponse(Stat.max)) {
-      res.add("max", max);
+
+    @Override
+    public void accumulate(BytesRef value, int count) {
+      if (null == ft) {
+        throw new IllegalStateException(
+            "Can't collect & convert BytesRefs on stats that do't use a a FieldType: "
+                + statsField);
+      }
+      T typedValue = (T) ft.toObject(sf, value);
+      accumulate(typedValue, count);
     }
-    if (statsField.includeInResponse(Stat.count)) {
-      res.add("count", count);
+
+    public void accumulate(T value, int count) {
+      assert null != value : "Can't accumulate null";
+
+      if (computeCount) {
+        this.count += count;
+      }
+      if (computeCalcDistinct) {
+        distinctValues.add(value);
+        countDistinct = distinctValues.size();
+      }
+      if (computeMinOrMax) {
+        updateMinMax(value, value);
+      }
+      if (computeCardinality) {
+        if (null == hasher) {
+          assert value instanceof Number : "pre-hashed value support only works with numeric longs";
+          hll.addRaw(((Number)value).longValue());
+        } else {
+          hll.addRaw(hash(value));
+        }
+      }
+      updateTypeSpecificStats(value, count);
     }
-    if (statsField.includeInResponse(Stat.missing)) {
-      res.add("missing", missing);
+
+    @Override
+    public void missing() {
+      if (computeMissing) {
+        missing++;
+      }
     }
-    if (statsField.includeInResponse(Stat.distinctValues)) {
-      res.add("distinctValues", distinctValues);
+
+    @Override
+    public void addMissing(int count) {
+      missing += count;
     }
-    if (statsField.includeInResponse(Stat.countDistinct)) {
-      res.add("countDistinct", countDistinct);
+
+    @Override
+    public void addFacet(String facetName, Map<String, StatsValues> facetValues) {
+      facets.put(facetName, facetValues);
     }
-    if (statsField.includeInResponse(Stat.cardinality)) {
-      if (statsField.getIsShard()) {
-        res.add("cardinality", hll.toBytes());
-      } else {
-        res.add("cardinality", hll.cardinality());
+
+    @Override
+    public NamedList<?> getStatsValues() {
+      NamedList<Object> res = new SimpleOrderedMap<>();
+
+      if (statsField.includeInResponse(Stat.min)) {
+        res.add("min", min);
       }
-    }
-    
-    addTypeSpecificStats(res);
-    
-    if (!facets.isEmpty()) {
-      
-      // add the facet stats
-      NamedList<NamedList<?>> nl = new SimpleOrderedMap<>();
-      for (Map.Entry<String,Map<String,StatsValues>> entry : facets.entrySet()) {
-        NamedList<NamedList<?>> nl2 = new SimpleOrderedMap<>();
-        nl.add(entry.getKey(), nl2);
-        for (Map.Entry<String,StatsValues> e2 : entry.getValue().entrySet()) {
-          nl2.add(e2.getKey(), e2.getValue().getStatsValues());
+      if (statsField.includeInResponse(Stat.max)) {
+        res.add("max", max);
+      }
+      if (statsField.includeInResponse(Stat.count)) {
+        res.add("count", count);
+      }
+      if (statsField.includeInResponse(Stat.missing)) {
+        res.add("missing", missing);
+      }
+      if (statsField.includeInResponse(Stat.distinctValues)) {
+        res.add("distinctValues", distinctValues);
+      }
+      if (statsField.includeInResponse(Stat.countDistinct)) {
+        res.add("countDistinct", countDistinct);
+      }
+      if (statsField.includeInResponse(Stat.cardinality)) {
+        if (statsField.getIsShard()) {
+          res.add("cardinality", hll.toBytes());
+        } else {
+          res.add("cardinality", hll.cardinality());
         }
       }
 
-      res.add(FACETS, nl);
+      addTypeSpecificStats(res);
+
+      if (!facets.isEmpty()) {
+
+        // add the facet stats
+        NamedList<NamedList<?>> nl = new SimpleOrderedMap<>();
+        for (Map.Entry<String,Map<String,StatsValues>> entry : facets.entrySet()) {
+          NamedList<NamedList<?>> nl2 = new SimpleOrderedMap<>();
+          nl.add(entry.getKey(), nl2);
+          for (Map.Entry<String,StatsValues> e2 : entry.getValue().entrySet()) {
+            nl2.add(e2.getKey(), e2.getValue().getStatsValues());
+          }
+        }
+
+        res.add(FACETS, nl);
+      }
+
+      return res;
     }
 
-    return res;
-  }
-  
-  public void setNextReader(LeafReaderContext ctx) throws IOException {
-    if (valueSource == null) {
-      // first time we've collected local values, get the right ValueSource
-      valueSource = (null == ft) 
-        ? statsField.getValueSource() 
-        : ft.getValueSource(sf, null);
-      vsContext = ValueSource.newContext(statsField.getSearcher());
-    }
-    values = valueSource.getValues(vsContext, ctx);
+    public void setNextReader(LeafReaderContext ctx) throws IOException {
+      if (valueSource == null) {
+        // first time we've collected local values, get the right ValueSource
+        valueSource = (null == ft)
+          ? statsField.getValueSource()
+          : ft.getValueSource(sf, null);
+        vsContext = ValueSource.newContext(statsField.getSearcher());
+      }
+      values = valueSource.getValues(vsContext, ctx);
+    }
+
+    /**
+     * Hash function to be used for computing cardinality.
+     *
+     * This method will not be called in cases where the user has indicated the values
+     * are already hashed.  If this method is called, then {@link #hasher} will be non-null,
+     * and should be used to generate the appropriate hash value.
+     *
+     * @see Stat#cardinality
+     * @see #hasher
+     */
+    protected abstract long hash(T value);
+
+    /**
+     * Updates the minimum and maximum statistics based on the given values
+     *
+     * @param min
+     *          Value that the current minimum should be updated against
+     * @param max
+     *          Value that the current maximum should be updated against
+     */
+    protected abstract void updateMinMax(T min, T max);
+
+    /**
+     * Updates the type specific statistics based on the given value
+     *
+     * @param value
+     *          Value the statistics should be updated against
+     * @param count
+     *          Number of times the value is being accumulated
+     */
+    protected abstract void updateTypeSpecificStats(T value, int count);
+
+    /**
+     * Updates the type specific statistics based on the values in the given list
+     *
+     * @param stv
+     *          List containing values the current statistics should be updated
+     *          against
+     */
+    protected abstract void updateTypeSpecificStats(NamedList stv);
+
+    /**
+     * Add any type specific statistics to the given NamedList
+     *
+     * @param res
+     *          NamedList to add the type specific statistics too
+     */
+    protected abstract void addTypeSpecificStats(NamedList<Object> res);
   }
-  
-  /**
-   * Hash function to be used for computing cardinality.
-   *
-   * This method will not be called in cases where the user has indicated the values 
-   * are already hashed.  If this method is called, then {@link #hasher} will be non-null, 
-   * and should be used to generate the appropriate hash value.
-   *
-   * @see Stat#cardinality
-   * @see #hasher
-   */
-  protected abstract long hash(T value);
 
   /**
-   * Updates the minimum and maximum statistics based on the given values
-   *
-   * @param min
-   *          Value that the current minimum should be updated against
-   * @param max
-   *          Value that the current maximum should be updated against
-   */
-  protected abstract void updateMinMax(T min, T max);
-  
-  /**
-   * Updates the type specific statistics based on the given value
-   *
-   * @param value
-   *          Value the statistics should be updated against
-   * @param count
-   *          Number of times the value is being accumulated
-   */
-  protected abstract void updateTypeSpecificStats(T value, int count);
-  
-  /**
-   * Updates the type specific statistics based on the values in the given list
-   *
-   * @param stv
-   *          List containing values the current statistics should be updated
-   *          against
+   * Implementation of StatsValues that supports Double values
    */
-  protected abstract void updateTypeSpecificStats(NamedList stv);
-  
-  /**
-   * Add any type specific statistics to the given NamedList
-   *
-   * @param res
-   *          NamedList to add the type specific statistics too
-   */
-  protected abstract void addTypeSpecificStats(NamedList<Object> res);
-}
+  static class NumericStatsValues extends AbstractStatsValues<Number> {
 
-/**
- * Implementation of StatsValues that supports Double values
- */
-class NumericStatsValues extends AbstractStatsValues<Number> {
-  
-  double sum;
-  double sumOfSquares;
-  
-  AVLTreeDigest tdigest;
-
-  double minD; // perf optimization, only valid if (null != this.min)
-  double maxD; // perf optimization, only valid if (null != this.max)
-  
-  final protected boolean computeSum;
-  final protected boolean computeSumOfSquares;
-  final protected boolean computePercentiles;
-
-  public NumericStatsValues(StatsField statsField) {
-    super(statsField);
-
-    this.computeSum = statsField.calculateStats(Stat.sum);
-    this.computeSumOfSquares = statsField.calculateStats(Stat.sumOfSquares);
-    
-    this.computePercentiles = statsField.calculateStats(Stat.percentiles);
-    if ( computePercentiles ) {
-      tdigest = new AVLTreeDigest(statsField.getTdigestCompression()); 
-    }
+    double sum;
+    double sumOfSquares;
 
-  }
+    AVLTreeDigest tdigest;
+
+    double minD; // perf optimization, only valid if (null != this.min)
+    double maxD; // perf optimization, only valid if (null != this.max)
+
+    final protected boolean computeSum;
+    final protected boolean computeSumOfSquares;
+    final protected boolean computePercentiles;
+
+    public NumericStatsValues(StatsField statsField) {
+      super(statsField);
+
+      this.computeSum = statsField.calculateStats(Stat.sum);
+      this.computeSumOfSquares = statsField.calculateStats(Stat.sumOfSquares);
+
+      this.computePercentiles = statsField.calculateStats(Stat.percentiles);
+      if ( computePercentiles ) {
+        tdigest = new AVLTreeDigest(statsField.getTdigestCompression());
+      }
 
-  @Override
-  public long hash(Number v) {
-    // have to use a bit of reflection to ensure good hash values since
-    // we don't have truely type specific stats
-    if (v instanceof Long) {
-      return hasher.hashLong(v.longValue()).asLong();
-    } else if (v instanceof Integer) {
-      return hasher.hashInt(v.intValue()).asLong();
-    } else if (v instanceof Double) {
-      return hasher.hashLong(Double.doubleToRawLongBits(v.doubleValue())).asLong();
-    } else if (v instanceof Float) {
-      return hasher.hashInt(Float.floatToRawIntBits(v.floatValue())).asLong();
-    } else if (v instanceof Byte) {
-      return hasher.newHasher().putByte(v.byteValue()).hash().asLong();
-    } else if (v instanceof Short) {
-      return hasher.newHasher().putShort(v.shortValue()).hash().asLong();
-    } 
-    // else...
-    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-                            "Unsupported Numeric Type ("+v.getClass()+") for hashing: " +statsField);
-  }
-  
-  @Override
-  public void accumulate(int docID) throws IOException {
-    if (values.exists(docID)) {
-      Number value = (Number) values.objectVal(docID);
-      accumulate(value, 1);
-    } else {
-      missing();
-    }
-  }
-  
-  @Override
-  public void updateTypeSpecificStats(NamedList stv) {
-    if (computeSum) {
-      sum += ((Number) stv.get("sum")).doubleValue();
-    }
-    if (computeSumOfSquares) {
-      sumOfSquares += ((Number) stv.get("sumOfSquares")).doubleValue();
     }
-    
-    if (computePercentiles) {      
-      byte[] data = (byte[]) stv.get("percentiles");
-      ByteBuffer buf = ByteBuffer.wrap(data);
-      tdigest.add(AVLTreeDigest.fromBytes(buf));
+
+    @Override
+    public long hash(Number v) {
+      // have to use a bit of reflection to ensure good hash values since
+      // we don't have truely type specific stats
+      if (v instanceof Long) {
+        return hasher.hashLong(v.longValue()).asLong();
+      } else if (v instanceof Integer) {
+        return hasher.hashInt(v.intValue()).asLong();
+      } else if (v instanceof Double) {
+        return hasher.hashLong(Double.doubleToRawLongBits(v.doubleValue())).asLong();
+      } else if (v instanceof Float) {
+        return hasher.hashInt(Float.floatToRawIntBits(v.floatValue())).asLong();
+      } else if (v instanceof Byte) {
+        return hasher.newHasher().putByte(v.byteValue()).hash().asLong();
+      } else if (v instanceof Short) {
+        return hasher.newHasher().putShort(v.shortValue()).hash().asLong();
+      }
+      // else...
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
+                              "Unsupported Numeric Type ("+v.getClass()+") for hashing: " +statsField);
     }
-  }
-  
-  @Override
-  public void updateTypeSpecificStats(Number v, int count) {
-    double value = v.doubleValue();
-    if (computeSumOfSquares) {
-      sumOfSquares += (value * value * count); // for std deviation
+
+    @Override
+    public void accumulate(int docID) throws IOException {
+      if (values.exists(docID)) {
+        Number value = (Number) values.objectVal(docID);
+        accumulate(value, 1);
+      } else {
+        missing();
+      }
     }
-    if (computeSum) {
-      sum += value * count;
+
+    @Override
+    public void updateTypeSpecificStats(NamedList stv) {
+      if (computeSum) {
+        sum += ((Number) stv.get("sum")).doubleValue();
+      }
+      if (computeSumOfSquares) {
+        sumOfSquares += ((Number) stv.get("sumOfSquares")).doubleValue();
+      }
+
+      if (computePercentiles) {
+        byte[] data = (byte[]) stv.get("percentiles");
+        ByteBuffer buf = ByteBuffer.wrap(data);
+        tdigest.add(AVLTreeDigest.fromBytes(buf));
+      }
     }
-    if (computePercentiles) {
-      tdigest.add(value, count);
+
+    @Override
+    public void updateTypeSpecificStats(Number v, int count) {
+      double value = v.doubleValue();
+      if (computeSumOfSquares) {
+        sumOfSquares += (value * value * count); // for std deviation
+      }
+      if (computeSum) {
+        sum += value * count;
+      }
+      if (computePercentiles) {
+        tdigest.add(value, count);
+      }
     }
-  }
-  
-  @Override
-  protected void updateMinMax(Number min, Number max) {
-    // we always use the double values, because that way the response Object class is 
-    // consistent regardless of whether we only have 1 value or many that we min/max
-    //
-    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat
-
-    if (computeMin) { // nested if to encourage JIT to optimize aware final var?
-      if (null != min) {
-        double minD = min.doubleValue();
-        if (null == this.min || minD < this.minD) {
-          // Double for result & cached primitive double to minimize unboxing in future comparisons
-          this.min = this.minD = minD;
+
+    @Override
+    protected void updateMinMax(Number min, Number max) {
+      // we always use the double values, because that way the response Object class is
+      // consistent regardless of whether we only have 1 value or many that we min/max
+      //
+      // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat
+
+      if (computeMin) { // nested if to encourage JIT to optimize aware final var?
+        if (null != min) {
+          double minD = min.doubleValue();
+          if (null == this.min || minD < this.minD) {
+            // Double for result & cached primitive double to minimize unboxing in future comparisons
+            this.min = this.minD = minD;
+          }
         }
       }
-    }
-    if (computeMax) { // nested if to encourage JIT to optimize aware final var?
-      if (null != max) {
-        double maxD = max.doubleValue();
-        if (null == this.max || this.maxD < maxD) {
-          // Double for result & cached primitive double to minimize unboxing in future comparisons
-          this.max = this.maxD = maxD;
+      if (computeMax) { // nested if to encourage JIT to optimize aware final var?
+        if (null != max) {
+          double maxD = max.doubleValue();
+          if (null == this.max || this.maxD < maxD) {
+            // Double for result & cached primitive double to minimize unboxing in future comparisons
+            this.max = this.maxD = maxD;
+          }
         }
       }
     }
-  }
-  
-  /**
-   * Adds sum, sumOfSquares, mean, stddev, and percentiles to the given
-   * NamedList
-   *
-   * @param res
-   *          NamedList to add the type specific statistics too
-   */
-  @Override
-  protected void addTypeSpecificStats(NamedList<Object> res) {
-    if (statsField.includeInResponse(Stat.sum)) {
-      res.add("sum", sum);
-    }
-    if (statsField.includeInResponse(Stat.sumOfSquares)) {
-      res.add("sumOfSquares", sumOfSquares);
-    }
-    if (statsField.includeInResponse(Stat.mean)) {
-      res.add("mean", sum / count);
-    }
-    if (statsField.includeInResponse(Stat.stddev)) {
-      res.add("stddev", getStandardDeviation());
-    }
-    if (statsField.includeInResponse(Stat.percentiles)) {
-      if (statsField.getIsShard()) {
-        // as of current t-digest version, smallByteSize() internally does a full conversion in 
-        // order to determine what the size is (can't be precomputed?) .. so rather then
-        // serialize to a ByteBuffer twice, allocate the max possible size buffer,
-        // serialize once, and then copy only the byte[] subset that we need, and free up the buffer
-        ByteBuffer buf = ByteBuffer.allocate(tdigest.byteSize()); // upper bound
-        tdigest.asSmallBytes(buf);
-        res.add("percentiles", Arrays.copyOf(buf.array(), buf.position()) );
-      } else {
-        NamedList<Object> percentileNameList = new NamedList<Object>();
-        for (Double percentile : statsField.getPercentilesList()) {
-          // Empty document set case
-          if (tdigest.size() == 0) {
-            percentileNameList.add(percentile.toString(), null);
-          } else {
-            Double cutoff = tdigest.quantile(percentile / 100);
-            percentileNameList.add(percentile.toString(), cutoff);
+
+    /**
+     * Adds sum, sumOfSquares, mean, stddev, and percentiles to the given
+     * NamedList
+     *
+     * @param res
+     *          NamedList to add the type specific statistics too
+     */
+    @Override
+    protected void addTypeSpecificStats(NamedList<Object> res) {
+      if (statsField.includeInResponse(Stat.sum)) {
+        res.add("sum", sum);
+      }
+      if (statsField.includeInResponse(Stat.sumOfSquares)) {
+        res.add("sumOfSquares", sumOfSquares);
+      }
+      if (statsField.includeInResponse(Stat.mean)) {
+        res.add("mean", sum / count);
+      }
+      if (statsField.includeInResponse(Stat.stddev)) {
+        res.add("stddev", getStandardDeviation());
+      }
+      if (statsField.includeInResponse(Stat.percentiles)) {
+        if (statsField.getIsShard()) {
+          // as of current t-digest version, smallByteSize() internally does a full conversion in
+          // order to determine what the size is (can't be precomputed?) .. so rather then
+          // serialize to a ByteBuffer twice, allocate the max possible size buffer,
+          // serialize once, and then copy only the byte[] subset that we need, and free up the buffer
+          ByteBuffer buf = ByteBuffer.allocate(tdigest.byteSize()); // upper bound
+          tdigest.asSmallBytes(buf);
+          res.add("percentiles", Arrays.copyOf(buf.array(), buf.position()) );
+        } else {
+          NamedList<Object> percentileNameList = new NamedList<Object>();
+          for (Double percentile : statsField.getPercentilesList()) {
+            // Empty document set case
+            if (tdigest.size() == 0) {
+              percentileNameList.add(percentile.toString(), null);
+            } else {
+              Double cutoff = tdigest.quantile(percentile / 100);
+              percentileNameList.add(percentile.toString(), cutoff);
+            }
           }
+          res.add("percentiles", percentileNameList);
         }
-        res.add("percentiles", percentileNameList);
       }
     }
+
+
+    /**
+     * Calculates the standard deviation statistic
+     *
+     * @return Standard deviation statistic
+     */
+    private double getStandardDeviation() {
+      if (count <= 1.0D) {
+        return 0.0D;
+      }
+
+      return Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (count * (count - 1.0D)));
+
+    }
   }
-  
-  
+
   /**
-   * Calculates the standard deviation statistic
-   *
-   * @return Standard deviation statistic
+   * Implementation of StatsValues that supports EnumField values
    */
-  private double getStandardDeviation() {
-    if (count <= 1.0D) {
-      return 0.0D;
+  private static class EnumStatsValues extends AbstractStatsValues<EnumFieldValue> {
+
+    public EnumStatsValues(StatsField statsField) {
+      super(statsField);
     }
-    
-    return Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (count * (count - 1.0D)));
-                     
-  }
-}
 
-/**
- * Implementation of StatsValues that supports EnumField values
- */
-class EnumStatsValues extends AbstractStatsValues<EnumFieldValue> {
-  
-  public EnumStatsValues(StatsField statsField) {
-    super(statsField);
-  }
-  
-  @Override
-  public long hash(EnumFieldValue v) {
-    return hasher.hashInt(v.toInt().intValue()).asLong();
-  }
+    @Override
+    public long hash(EnumFieldValue v) {
+      return hasher.hashInt(v.toInt().intValue()).asLong();
+    }
 
-  @Override
-  public void accumulate(int docID) throws IOException {
-    if (values.exists(docID)) {
-      Integer intValue = (Integer) values.objectVal(docID);
-      String stringValue = values.strVal(docID);
-      EnumFieldValue enumFieldValue = new EnumFieldValue(intValue, stringValue);
-      accumulate(enumFieldValue, 1);
-    } else {
-      missing();
+    @Override
+    public void accumulate(int docID) throws IOException {
+      if (values.exists(docID)) {
+        Integer intValue = (Integer) values.objectVal(docID);
+        String stringValue = values.strVal(docID);
+        EnumFieldValue enumFieldValue = new EnumFieldValue(intValue, stringValue);
+        accumulate(enumFieldValue, 1);
+      } else {
+        missing();
+      }
     }
-  }
-  
-  protected void updateMinMax(EnumFieldValue min, EnumFieldValue max) {
-    if (computeMin) { // nested if to encourage JIT to optimize aware final var?
-      if (null != min) {
-        if (null == this.min || (min.compareTo(this.min) < 0)) {
-          this.min = min;
+
+    protected void updateMinMax(EnumFieldValue min, EnumFieldValue max) {
+      if (computeMin) { // nested if to encourage JIT to optimize aware final var?
+        if (null != min) {
+          if (null == this.min || (min.compareTo(this.min) < 0)) {
+            this.min = min;
+          }
         }
       }
-    }
-    if (computeMax) { // nested if to encourage JIT to optimize aware final var?
-      if (null != max) {
-        if (null == this.max || (max.compareTo(this.max) > 0)) {
-          this.max = max;
+      if (computeMax) { // nested if to encourage JIT to optimize aware final var?
+        if (null != max) {
+          if (null == this.max || (max.compareTo(this.max) > 0)) {
+            this.max = max;
+          }
         }
       }
     }
-  }
-  
-  @Override
-  protected void updateTypeSpecificStats(NamedList stv) {
-    // No type specific stats
-  }
-  
-  @Override
-  protected void updateTypeSpecificStats(EnumFieldValue value, int count) {
-    // No type specific stats
-  }
-  
-  /**
-   * Adds no type specific statistics
-   */
-  @Override
-  protected void addTypeSpecificStats(NamedList<Object> res) {
-    // Add no statistics
-  }
-  
-}
-
-/**
- * /** Implementation of StatsValues that supports Date values
- */
-class DateStatsValues extends AbstractStatsValues<Date> {
-  
-  private double sum = 0.0;
-  double sumOfSquares = 0;
-  
-  final protected boolean computeSum;
-  final protected boolean computeSumOfSquares;
-
-  public DateStatsValues(StatsField statsField) {
-    super(statsField);
-    this.computeSum = statsField.calculateStats(Stat.sum);
-    this.computeSumOfSquares = statsField.calculateStats(Stat.sumOfSquares);
-  }
 
-  @Override
-  public long hash(Date v) {
-    return hasher.hashLong(v.getTime()).asLong();
-  }
-  
-  @Override
-  public void accumulate(int docID) throws IOException {
-    if (values.exists(docID)) {
-      accumulate((Date) values.objectVal(docID), 1);
-    } else {
-      missing();
+    @Override
+    protected void updateTypeSpecificStats(NamedList stv) {
+      // No type specific stats
     }
-  }
-  
-  @Override
-  protected void updateTypeSpecificStats(NamedList stv) {
-    if (computeSum) {
-      sum += ((Number) stv.get("sum")).doubleValue();
+
+    @Override
+    protected void updateTypeSpecificStats(EnumFieldValue value, int count) {
+      // No type specific stats
     }
-    if (computeSumOfSquares) {
-      sumOfSquares += ((Number) stv.get("sumOfSquares")).doubleValue();
+
+    /**
+     * Adds no type specific statistics
+     */
+    @Override
+    protected void addTypeSpecificStats(NamedList<Object> res) {
+      // Add no statistics
     }
+
   }
-  
-  @Override
-  public void updateTypeSpecificStats(Date v, int count) {
-    long value = v.getTime();
-    if (computeSumOfSquares) {
-      sumOfSquares += ((double)value * value * count); // for std deviation
+
+  /**
+   * /** Implementation of StatsValues that supports Date values
+   */
+  static class DateStatsValues extends AbstractStatsValues<Date> {
+
+    private double sum = 0.0;
+    double sumOfSquares = 0;
+
+    final protected boolean computeSum;
+    final protected boolean computeSumOfSquares;
+
+    public DateStatsValues(StatsField statsField) {
+      super(statsField);
+      this.computeSum = statsField.calculateStats(Stat.sum);
+      this.computeSumOfSquares = statsField.calculateStats(Stat.sumOfSquares);
     }
-    if (computeSum) {
-      sum += value * count;
+
+    @Override
+    public long hash(Date v) {
+      return hasher.hashLong(v.getTime()).asLong();
     }
-  }
-  
-  @Override
-  protected void updateMinMax(Date min, Date max) {
-    if (computeMin) { // nested if to encourage JIT to optimize aware final var?
-      if (null != min && (this.min==null || this.min.after(min))) {
-        this.min = min;
+
+    @Override
+    public void accumulate(int docID) throws IOException {
+      if (values.exists(docID)) {
+        accumulate((Date) values.objectVal(docID), 1);
+      } else {
+        missing();
       }
     }
-    if (computeMax) { // nested if to encourage JIT to optimize aware final var?
-      if (null != max && (this.max==null || this.max.before(max))) {
-        this.max = max;
+
+    @Override
+    protected void updateTypeSpecificStats(NamedList stv) {
+      if (computeSum) {
+        sum += ((Number) stv.get("sum")).doubleValue();
+      }
+      if (computeSumOfSquares) {
+        sumOfSquares += ((Number) stv.get("sumOfSquares")).doubleValue();
       }
     }
-  }
-  
-  /**
-   * Adds sum and mean statistics to the given NamedList
-   *
-   * @param res
-   *          NamedList to add the type specific statistics too
-   */
-  @Override
-  protected void addTypeSpecificStats(NamedList<Object> res) {
-    if (statsField.includeInResponse(Stat.sum)) {
-      res.add("sum", sum);
+
+    @Override
+    public void updateTypeSpecificStats(Date v, int count) {
+      long value = v.getTime();
+      if (computeSumOfSquares) {
+        sumOfSquares += ((double)value * value * count); // for std deviation
+      }
+      if (computeSum) {
+        sum += value * count;
+      }
     }
-    if (statsField.includeInResponse(Stat.mean)) {
-      res.add("mean", (count > 0) ? new Date((long)(sum / count)) : null);
+
+    @Override
+    protected void updateMinMax(Date min, Date max) {
+      if (computeMin) { // nested if to encourage JIT to optimize aware final var?
+        if (null != min && (this.min==null || this.min.after(min))) {
+          this.min = min;
+        }
+      }
+      if (computeMax) { // nested if to encourage JIT to optimize aware final var?
+        if (null != max && (this.max==null || this.max.before(max))) {
+          this.max = max;
+        }
+      }
     }
-    if (statsField.includeInResponse(Stat.sumOfSquares)) {
-      res.add("sumOfSquares", sumOfSquares);
+
+    /**
+     * Adds sum and mean statistics to the given NamedList
+     *
+     * @param res
+     *          NamedList to add the type specific statistics too
+     */
+    @Override
+    protected void addTypeSpecificStats(NamedList<Object> res) {
+      if (statsField.includeInResponse(Stat.sum)) {
+        res.add("sum", sum);
+      }
+      if (statsField.includeInResponse(Stat.mean)) {
+        res.add("mean", (count > 0) ? new Date((long)(sum / count)) : null);
+      }
+      if (statsField.includeInResponse(Stat.sumOfSquares)) {
+        res.add("sumOfSquares", sumOfSquares);
+      }
+      if (statsField.includeInResponse(Stat.stddev)) {
+        res.add("stddev", getStandardDeviation());
+      }
     }
-    if (statsField.includeInResponse(Stat.stddev)) {
-      res.add("stddev", getStandardDeviation());
+
+    /**
+     * Calculates the standard deviation. For dates, this is really the MS
+     * deviation
+     *
+     * @return Standard deviation statistic
+     */
+    private double getStandardDeviation() {
+      if (count <= 1) {
+        return 0.0D;
+      }
+      return Math.sqrt(((count * sumOfSquares) - (sum * sum))
+          / (count * (count - 1.0D)));
     }
   }
-  
+
   /**
-   * Calculates the standard deviation. For dates, this is really the MS
-   * deviation
-   *
-   * @return Standard deviation statistic
+   * Implementation of StatsValues that supports String values
    */
-  private double getStandardDeviation() {
-    if (count <= 1) {
-      return 0.0D;
+  private static class StringStatsValues extends AbstractStatsValues<String> {
+
+    public StringStatsValues(StatsField statsField) {
+      super(statsField);
     }
-    return Math.sqrt(((count * sumOfSquares) - (sum * sum))
-        / (count * (count - 1.0D)));
-  }
-}
 
-/**
- * Implementation of StatsValues that supports String values
- */
-class StringStatsValues extends AbstractStatsValues<String> {
-  
-  public StringStatsValues(StatsField statsField) {
-    super(statsField);
-  }
+    @Override
+    public long hash(String v) {
+      return hasher.hashString(v, StandardCharsets.UTF_8).asLong();
+    }
 
-  @Override
-  public long hash(String v) {
-    return hasher.hashString(v, StandardCharsets.UTF_8).asLong();
-  }
-  
-  @Override
-  public void accumulate(int docID) throws IOException {
-    if (values.exists(docID)) {
-      String value = values.strVal(docID);
-      if (value != null) {
-        accumulate(value, 1);
-      } else { 
+    @Override
+    public void accumulate(int docID) throws IOException {
+      if (values.exists(docID)) {
+        String value = values.strVal(docID);
+        if (value != null) {
+          accumulate(value, 1);
+        } else {
+          missing();
+        }
+      } else {
         missing();
       }
-    } else {
-      missing();
     }
-  }
-  
-  @Override
-  protected void updateTypeSpecificStats(NamedList stv) {
-    // No type specific stats
-  }
-  
-  @Override
-  protected void updateTypeSpecificStats(String value, int count) {
-    // No type specific stats
-  }
-  
-  @Override
-  protected void updateMinMax(String min, String max) {
-    if (computeMin) { // nested if to encourage JIT to optimize aware final var?
-      this.min = min(this.min, min);
+
+    @Override
+    protected void updateTypeSpecificStats(NamedList stv) {
+      // No type specific stats
     }
-    if (computeMax) { // nested if to encourage JIT to optimize aware final var?
-      this.max = max(this.max, max);
+
+    @Override
+    protected void updateTypeSpecificStats(String value, int count) {
+      // No type specific stats
     }
-  }
-  
-  /**
-   * Adds no type specific statistics
-   */
-  @Override
-  protected void addTypeSpecificStats(NamedList<Object> res) {
-    // Add no statistics
-  }
-  
-  /**
-   * Determines which of the given Strings is the maximum, as computed by
-   * {@link String#compareTo(String)}
-   *
-   * @param str1
-   *          String to compare against b
-   * @param str2
-   *          String compared against a
-   * @return str1 if it is considered greater by
-   *         {@link String#compareTo(String)}, str2 otherwise
-   */
-  private static String max(String str1, String str2) {
-    if (str1 == null) {
-      return str2;
-    } else if (str2 == null) {
-      return str1;
+
+    @Override
+    protected void updateMinMax(String min, String max) {
+      if (computeMin) { // nested if to encourage JIT to optimize aware final var?
+        this.min = min(this.min, min);
+      }
+      if (computeMax) { // nested if to encourage JIT to optimize aware final var?
+        this.max = max(this.max, max);
+      }
     }
-    return (str1.compareTo(str2) > 0) ? str1 : str2;
-  }
-  
-  /**
-   * Determines which of the given Strings is the minimum, as computed by
-   * {@link String#compareTo(String)}
-   *
-   * @param str1
-   *          String to compare against b
-   * @param str2
-   *          String compared against a
-   * @return str1 if it is considered less by {@link String#compareTo(String)},
-   *         str2 otherwise
-   */
-  private static String min(String str1, String str2) {
-    if (str1 == null) {
-      return str2;
-    } else if (str2 == null) {
-      return str1;
+
+    /**
+     * Adds no type specific statistics
+     */
+    @Override
+    protected void addTypeSpecificStats(NamedList<Object> res) {
+      // Add no statistics
+    }
+
+    /**
+     * Determines which of the given Strings is the maximum, as computed by
+     * {@link String#compareTo(String)}
+     *
+     * @param str1
+     *          String to compare against b
+     * @param str2
+     *          String compared against a
+     * @return str1 if it is considered greater by
+     *         {@link String#compareTo(String)}, str2 otherwise
+     */
+    private static String max(String str1, String str2) {
+      if (str1 == null) {
+        return str2;
+      } else if (str2 == null) {
+        return str1;
+      }
+      return (str1.compareTo(str2) > 0) ? str1 : str2;
+    }
+
+    /**
+     * Determines which of the given Strings is the minimum, as computed by
+     * {@link String#compareTo(String)}
+     *
+     * @param str1
+     *          String to compare against b
+     * @param str2
+     *          String compared against a
+     * @return str1 if it is considered less by {@link String#compareTo(String)},
+     *         str2 otherwise
+     */
+    private static String min(String str1, String str2) {
+      if (str1 == null) {
+        return str2;
+      } else if (str2 == null) {
+        return str1;
+      }
+      return (str1.compareTo(str2) < 0) ? str1 : str2;
     }
-    return (str1.compareTo(str2) < 0) ? str1 : str2;
   }
 }
+
diff --git a/solr/core/src/java/org/apache/solr/response/transform/DocIdAugmenterFactory.java b/solr/core/src/java/org/apache/solr/response/transform/DocIdAugmenterFactory.java
index 219ca5d83e7..7e0fed577b7 100644
--- a/solr/core/src/java/org/apache/solr/response/transform/DocIdAugmenterFactory.java
+++ b/solr/core/src/java/org/apache/solr/response/transform/DocIdAugmenterFactory.java
@@ -33,27 +33,24 @@ public class DocIdAugmenterFactory extends TransformerFactory
   public DocTransformer create(String field, SolrParams params, SolrQueryRequest req) {
     return new DocIdAugmenter( field );
   }
-}
 
-class DocIdAugmenter extends DocTransformer
-{
-  final String name;
+  private static class DocIdAugmenter extends DocTransformer {
+    final String name;
 
-  public DocIdAugmenter( String display )
-  {
-    this.name = display;
-  }
+    public DocIdAugmenter( String display ) {
+      this.name = display;
+    }
 
-  @Override
-  public String getName()
-  {
-    return name;
-  }
+    @Override
+    public String getName() {
+      return name;
+    }
 
-  @Override
-  public void transform(SolrDocument doc, int docid) {
-    assert -1 <= docid;
-    doc.setField( name, docid );
+    @Override
+    public void transform(SolrDocument doc, int docid) {
+      assert -1 <= docid;
+      doc.setField( name, docid );
+    }
   }
 }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/BoolField.java b/solr/core/src/java/org/apache/solr/schema/BoolField.java
index 5fb2d85fbc2..d9f9f0e5318 100644
--- a/solr/core/src/java/org/apache/solr/schema/BoolField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BoolField.java
@@ -215,94 +215,95 @@ public class BoolField extends PrimitiveFieldType {
     }
     return super.toNativeType(val);
   }
-}
 
-// TODO - this can be much more efficient - use FixedBitSet or Bits
-class BoolFieldSource extends ValueSource {
-  protected String field;
+  // TODO - this can be much more efficient - use FixedBitSet or Bits
+  private static class BoolFieldSource extends ValueSource {
+    protected String field;
 
-  public BoolFieldSource(String field) {
-    this.field = field;
-  }
+    public BoolFieldSource(String field) {
+      this.field = field;
+    }
 
-  @Override
-  public String description() {
-    return "bool(" + field + ')';
-  }
+    @Override
+    public String description() {
+      return "bool(" + field + ')';
+    }
 
 
-  @Override
-  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-    final SortedDocValues sindex = DocValues.getSorted(readerContext.reader(), field);
-
-    // figure out what ord maps to true
-    int nord = sindex.getValueCount();
-    // if no values in the segment, default trueOrd to something other then -1 (missing)
-    int tord = -2;
-    for (int i=0; i<nord; i++) {
-      final BytesRef br = sindex.lookupOrd(i);
-      if (br.length==1 && br.bytes[br.offset]=='T') {
-        tord = i;
-        break;
+    @Override
+    public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
+      final SortedDocValues sindex = DocValues.getSorted(readerContext.reader(), field);
+
+      // figure out what ord maps to true
+      int nord = sindex.getValueCount();
+      // if no values in the segment, default trueOrd to something other then -1 (missing)
+      int tord = -2;
+      for (int i=0; i<nord; i++) {
+        final BytesRef br = sindex.lookupOrd(i);
+        if (br.length==1 && br.bytes[br.offset]=='T') {
+          tord = i;
+          break;
+        }
       }
-    }
 
-    final int trueOrd = tord;
+      final int trueOrd = tord;
 
-    return new BoolDocValues(this) {
+      return new BoolDocValues(this) {
 
-      private int getOrdForDoc(int doc) throws IOException {
-        if (doc > sindex.docID()) {
-          sindex.advance(doc);
-        }
-        if (doc == sindex.docID()) {
-          return sindex.ordValue();
-        } else {
-          return -1;
+        private int getOrdForDoc(int doc) throws IOException {
+          if (doc > sindex.docID()) {
+            sindex.advance(doc);
+          }
+          if (doc == sindex.docID()) {
+            return sindex.ordValue();
+          } else {
+            return -1;
+          }
         }
-      }
 
-      @Override
-      public boolean boolVal(int doc) throws IOException {
-        return getOrdForDoc(doc) == trueOrd;
-      }
-
-      @Override
-      public boolean exists(int doc) throws IOException {
-        return getOrdForDoc(doc) != -1;
-      }
+        @Override
+        public boolean boolVal(int doc) throws IOException {
+          return getOrdForDoc(doc) == trueOrd;
+        }
 
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueBool mval = new MutableValueBool();
+        @Override
+        public boolean exists(int doc) throws IOException {
+          return getOrdForDoc(doc) != -1;
+        }
 
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
+        @Override
+        public ValueFiller getValueFiller() {
+          return new ValueFiller() {
+            private final MutableValueBool mval = new MutableValueBool();
+
+            @Override
+            public MutableValue getValue() {
+              return mval;
+            }
+
+            @Override
+            public void fillValue(int doc) throws IOException {
+              int ord = getOrdForDoc(doc);
+              mval.value = (ord == trueOrd);
+              mval.exists = (ord != -1);
+            }
+          };
+        }
+      };
+    }
 
-          @Override
-          public void fillValue(int doc) throws IOException {
-            int ord = getOrdForDoc(doc);
-            mval.value = (ord == trueOrd);
-            mval.exists = (ord != -1);
-          }
-        };
-      }
-    };
-  }
+    @Override
+    public boolean equals(Object o) {
+      return o.getClass() == BoolFieldSource.class && this.field.equals(((BoolFieldSource)o).field);
+    }
 
-  @Override
-  public boolean equals(Object o) {
-    return o.getClass() == BoolFieldSource.class && this.field.equals(((BoolFieldSource)o).field);
-  }
+    private static final int hcode = OrdFieldSource.class.hashCode();
 
-  private static final int hcode = OrdFieldSource.class.hashCode();
+    @Override
+    public int hashCode() {
+      return hcode + field.hashCode();
+    }
 
-  @Override
-  public int hashCode() {
-    return hcode + field.hashCode();
   }
-
 }
+
diff --git a/solr/core/src/java/org/apache/solr/schema/DatePointField.java b/solr/core/src/java/org/apache/solr/schema/DatePointField.java
index 9360aa4534b..184dde152b3 100644
--- a/solr/core/src/java/org/apache/solr/schema/DatePointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DatePointField.java
@@ -219,36 +219,37 @@ public class DatePointField extends PointField implements DateValueFieldType {
   protected StoredField getStoredField(SchemaField sf, Object value) {
     return new StoredField(sf.getName(), ((Date) this.toNativeType(value)).getTime());
   }
-}
 
-class DatePointFieldSource extends LongFieldSource {
+  private static class DatePointFieldSource extends LongFieldSource {
 
-  public DatePointFieldSource(String field) {
-    super(field);
-  }
+    public DatePointFieldSource(String field) {
+      super(field);
+    }
 
-  @Override
-  public String description() {
-    return "date(" + field + ')';
-  }
+    @Override
+    public String description() {
+      return "date(" + field + ')';
+    }
 
-  @Override
-  protected MutableValueLong newMutableValueLong() {
-    return new MutableValueDate();
-  }
+    @Override
+    protected MutableValueLong newMutableValueLong() {
+      return new MutableValueDate();
+    }
 
-  @Override
-  public Date longToObject(long val) {
-    return new Date(val);
-  }
+    @Override
+    public Date longToObject(long val) {
+      return new Date(val);
+    }
 
-  @Override
-  public String longToString(long val) {
-    return longToObject(val).toInstant().toString();
-  }
+    @Override
+    public String longToString(long val) {
+      return longToObject(val).toInstant().toString();
+    }
 
-  @Override
-  public long externalToLong(String extVal) {
-    return DateMathParser.parseMath(null, extVal).getTime();
+    @Override
+    public long externalToLong(String extVal) {
+      return DateMathParser.parseMath(null, extVal).getTime();
+    }
   }
 }
+
diff --git a/solr/core/src/java/org/apache/solr/search/FunctionQParser.java b/solr/core/src/java/org/apache/solr/search/FunctionQParser.java
index a212f050729..7743640ea3f 100644
--- a/solr/core/src/java/org/apache/solr/search/FunctionQParser.java
+++ b/solr/core/src/java/org/apache/solr/search/FunctionQParser.java
@@ -327,7 +327,7 @@ public class FunctionQParser extends QParser {
     if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {
       Number num = sp.getNumber();
       if (num instanceof Long) {
-        valueSource = new LongConstValueSource(num.longValue());
+        valueSource = new ValueSourceParser.LongConstValueSource(num.longValue());
       } else if (num instanceof Double) {
         valueSource = new DoubleConstValueSource(num.doubleValue());
       } else {
@@ -399,9 +399,9 @@ public class FunctionQParser extends QParser {
         sp.expect(")");
       } else {
         if ("true".equals(id)) {
-          valueSource = new BoolConstValueSource(true);
+          valueSource = ValueSourceParser.BoolConstValueSource.TRUE;
         } else if ("false".equals(id)) {
-          valueSource = new BoolConstValueSource(false);
+          valueSource = ValueSourceParser.BoolConstValueSource.FALSE;
         } else {
           if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {
             // Don't try to create a ValueSource for the field, just use a placeholder.
diff --git a/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java b/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
index d054bc8d886..2a4c1a2c10c 100644
--- a/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
+++ b/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
@@ -764,14 +764,14 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin {
     addParser("true", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) {
-        return new BoolConstValueSource(true);
+        return BoolConstValueSource.TRUE;
       }
     });
 
     addParser("false", new ValueSourceParser() {
       @Override
       public ValueSource parse(FunctionQParser fp) {
-        return new BoolConstValueSource(false);
+        return BoolConstValueSource.FALSE;
       }
     });
 
@@ -1184,430 +1184,427 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin {
     BytesRefBuilder indexedBytes;
   }
 
-}
-
+  static class DateValueSourceParser extends ValueSourceParser {
+    @Override
+    public void init(NamedList args) {
+    }
 
-class DateValueSourceParser extends ValueSourceParser {
-  @Override
-  public void init(NamedList args) {
-  }
+    public Date getDate(FunctionQParser fp, String arg) {
+      if (arg == null) return null;
+      // check character index 1 to be a digit.  Index 0 might be a +/-.
+      if (arg.startsWith("NOW") || (arg.length() > 1 && Character.isDigit(arg.charAt(1)))) {
+        Date now = null;//TODO pull from params?
+        return DateMathParser.parseMath(now, arg);
+      }
+      return null;
+    }
 
-  public Date getDate(FunctionQParser fp, String arg) {
-    if (arg == null) return null;
-    // check character index 1 to be a digit.  Index 0 might be a +/-.
-    if (arg.startsWith("NOW") || (arg.length() > 1 && Character.isDigit(arg.charAt(1)))) {
-      Date now = null;//TODO pull from params?
-      return DateMathParser.parseMath(now, arg);
+    public ValueSource getValueSource(FunctionQParser fp, String arg) {
+      if (arg == null) return null;
+      SchemaField f = fp.req.getSchema().getField(arg);
+      return f.getType().getValueSource(f, fp);
     }
-    return null;
-  }
 
-  public ValueSource getValueSource(FunctionQParser fp, String arg) {
-    if (arg == null) return null;
-    SchemaField f = fp.req.getSchema().getField(arg);
-    return f.getType().getValueSource(f, fp);
-  }
+    @Override
+    public ValueSource parse(FunctionQParser fp) throws SyntaxError {
+      String first = fp.parseArg();
+      String second = fp.parseArg();
+      if (first == null) first = "NOW";
 
-  @Override
-  public ValueSource parse(FunctionQParser fp) throws SyntaxError {
-    String first = fp.parseArg();
-    String second = fp.parseArg();
-    if (first == null) first = "NOW";
+      Date d1 = getDate(fp, first);
+      ValueSource v1 = d1 == null ? getValueSource(fp, first) : null;
 
-    Date d1 = getDate(fp, first);
-    ValueSource v1 = d1 == null ? getValueSource(fp, first) : null;
+      Date d2 = getDate(fp, second);
+      ValueSource v2 = d2 == null ? getValueSource(fp, second) : null;
 
-    Date d2 = getDate(fp, second);
-    ValueSource v2 = d2 == null ? getValueSource(fp, second) : null;
+      // d     constant
+      // v     field
+      // dd    constant
+      // dv    subtract field from constant
+      // vd    subtract constant from field
+      // vv    subtract fields
 
-    // d     constant
-    // v     field
-    // dd    constant
-    // dv    subtract field from constant
-    // vd    subtract constant from field
-    // vv    subtract fields
+      final long ms1 = (d1 == null) ? 0 : d1.getTime();
+      final long ms2 = (d2 == null) ? 0 : d2.getTime();
 
-    final long ms1 = (d1 == null) ? 0 : d1.getTime();
-    final long ms2 = (d2 == null) ? 0 : d2.getTime();
+      // "d,dd" handle both constant cases
 
-    // "d,dd" handle both constant cases
+      if (d1 != null && v2 == null) {
+        return new LongConstValueSource(ms1 - ms2);
+      }
 
-    if (d1 != null && v2 == null) {
-      return new LongConstValueSource(ms1 - ms2);
-    }
+      // "v" just the date field
+      if (v1 != null && v2 == null && d2 == null) {
+        return v1;
+      }
+
+
+      // "dv"
+      if (d1 != null && v2 != null)
+        return new DualFloatFunction(new LongConstValueSource(ms1), v2) {
+          @Override
+          protected String name() {
+            return "ms";
+          }
+
+          @Override
+          protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
+            return ms1 - bVals.longVal(doc);
+          }
+        };
+
+      // "vd"
+      if (v1 != null && d2 != null)
+        return new DualFloatFunction(v1, new LongConstValueSource(ms2)) {
+          @Override
+          protected String name() {
+            return "ms";
+          }
 
-    // "v" just the date field
-    if (v1 != null && v2 == null && d2 == null) {
-      return v1;
+          @Override
+          protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
+            return aVals.longVal(doc) - ms2;
+          }
+        };
+
+      // "vv"
+      if (v1 != null && v2 != null)
+        return new DualFloatFunction(v1, v2) {
+          @Override
+          protected String name() {
+            return "ms";
+          }
+
+          @Override
+          protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
+            return aVals.longVal(doc) - bVals.longVal(doc);
+          }
+        };
+
+      return null; // shouldn't happen
     }
 
+  }
+
+  // Private for now - we need to revisit how to handle typing in function queries
+  static class LongConstValueSource extends ConstNumberSource {
+    final long constant;
+    final double dv;
+    final float fv;
 
-    // "dv"
-    if (d1 != null && v2 != null)
-      return new DualFloatFunction(new LongConstValueSource(ms1), v2) {
-        @Override
-        protected String name() {
-          return "ms";
-        }
+    public LongConstValueSource(long constant) {
+      this.constant = constant;
+      this.dv = constant;
+      this.fv = constant;
+    }
+
+    @Override
+    public String description() {
+      return "const(" + constant + ")";
+    }
 
+    @Override
+    public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
+      return new LongDocValues(this) {
         @Override
-        protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
-          return ms1 - bVals.longVal(doc);
+        public float floatVal(int doc) {
+          return fv;
         }
-      };
 
-    // "vd"
-    if (v1 != null && d2 != null)
-      return new DualFloatFunction(v1, new LongConstValueSource(ms2)) {
         @Override
-        protected String name() {
-          return "ms";
+        public int intVal(int doc) {
+          return (int) constant;
         }
 
         @Override
-        protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
-          return aVals.longVal(doc) - ms2;
+        public long longVal(int doc) {
+          return constant;
         }
-      };
 
-    // "vv"
-    if (v1 != null && v2 != null)
-      return new DualFloatFunction(v1, v2) {
         @Override
-        protected String name() {
-          return "ms";
+        public double doubleVal(int doc) {
+          return dv;
         }
 
         @Override
-        protected float func(int doc, FunctionValues aVals, FunctionValues bVals) throws IOException {
-          return aVals.longVal(doc) - bVals.longVal(doc);
+        public String toString(int doc) {
+          return description();
         }
       };
+    }
 
-    return null; // shouldn't happen
-  }
+    @Override
+    public int hashCode() {
+      return (int) constant + (int) (constant >>> 32);
+    }
 
-}
+    @Override
+    public boolean equals(Object o) {
+      if (LongConstValueSource.class != o.getClass()) return false;
+      LongConstValueSource other = (LongConstValueSource) o;
+      return this.constant == other.constant;
+    }
+
+    @Override
+    public int getInt() {
+      return (int)constant;
+    }
+
+    @Override
+    public long getLong() {
+      return constant;
+    }
 
+    @Override
+    public float getFloat() {
+      return fv;
+    }
 
-// Private for now - we need to revisit how to handle typing in function queries
-class LongConstValueSource extends ConstNumberSource {
-  final long constant;
-  final double dv;
-  final float fv;
+    @Override
+    public double getDouble() {
+      return dv;
+    }
 
-  public LongConstValueSource(long constant) {
-    this.constant = constant;
-    this.dv = constant;
-    this.fv = constant;
+    @Override
+    public Number getNumber() {
+      return constant;
+    }
+
+    @Override
+    public boolean getBool() {
+      return constant != 0;
+    }
   }
 
-  @Override
-  public String description() {
-    return "const(" + constant + ")";
+  abstract static class NamedParser extends ValueSourceParser {
+    private final String name;
+    public NamedParser(String name) {
+      this.name = name;
+    }
+    public String name() {
+      return name;
+    }
   }
 
-  @Override
-  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-    return new LongDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return fv;
-      }
+  abstract static class DoubleParser extends NamedParser {
+    public DoubleParser(String name) {
+      super(name);
+    }
 
-      @Override
-      public int intVal(int doc) {
-        return (int) constant;
-      }
+    public abstract double func(int doc, FunctionValues vals) throws IOException;
 
-      @Override
-      public long longVal(int doc) {
-        return constant;
+    @Override
+    public ValueSource parse(FunctionQParser fp) throws SyntaxError {
+      return new Function(fp.parseValueSource());
+    }
+
+    class Function extends SingleFunction {
+      public Function(ValueSource source) {
+        super(source);
       }
 
       @Override
-      public double doubleVal(int doc) {
-        return dv;
+      public String name() {
+        return DoubleParser.this.name();
       }
 
       @Override
-      public String toString(int doc) {
-        return description();
+      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
+        final FunctionValues vals =  source.getValues(context, readerContext);
+        return new DoubleDocValues(this) {
+          @Override
+          public double doubleVal(int doc) throws IOException {
+            return func(doc, vals);
+          }
+          @Override
+          public String toString(int doc) throws IOException {
+            return name() + '(' + vals.toString(doc) + ')';
+          }
+        };
       }
-    };
-  }
-
-  @Override
-  public int hashCode() {
-    return (int) constant + (int) (constant >>> 32);
+    }
   }
 
-  @Override
-  public boolean equals(Object o) {
-    if (LongConstValueSource.class != o.getClass()) return false;
-    LongConstValueSource other = (LongConstValueSource) o;
-    return this.constant == other.constant;
-  }
+  abstract static class Double2Parser extends NamedParser {
+    public Double2Parser(String name) {
+      super(name);
+    }
 
-  @Override
-  public int getInt() {
-    return (int)constant;
-  }
+    public abstract double func(int doc, FunctionValues a, FunctionValues b) throws IOException;
 
-  @Override
-  public long getLong() {
-    return constant;
-  }
+    @Override
+    public ValueSource parse(FunctionQParser fp) throws SyntaxError {
+      return new Function(fp.parseValueSource(), fp.parseValueSource());
+    }
 
-  @Override
-  public float getFloat() {
-    return fv;
-  }
+    class Function extends ValueSource {
+      private final ValueSource a;
+      private final ValueSource b;
 
-  @Override
-  public double getDouble() {
-    return dv;
-  }
+     /**
+       * @param   a  the base.
+       * @param   b  the exponent.
+       */
+      public Function(ValueSource a, ValueSource b) {
+        this.a = a;
+        this.b = b;
+      }
 
-  @Override
-  public Number getNumber() {
-    return constant;
-  }
+      @Override
+      public String description() {
+        return name() + "(" + a.description() + "," + b.description() + ")";
+      }
 
-  @Override
-  public boolean getBool() {
-    return constant != 0;
-  }
-}
+      @Override
+      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
+        final FunctionValues aVals =  a.getValues(context, readerContext);
+        final FunctionValues bVals =  b.getValues(context, readerContext);
+        return new DoubleDocValues(this) {
+          @Override
+          public double doubleVal(int doc) throws IOException {
+            return func(doc, aVals, bVals);
+          }
+          @Override
+          public String toString(int doc) throws IOException {
+            return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
+          }
+        };
+      }
 
+      @Override
+      public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+      }
 
-abstract class NamedParser extends ValueSourceParser {
-  private final String name;
-  public NamedParser(String name) {
-    this.name = name;
-  }
-  public String name() {
-    return name;
-  }
-}
+      @Override
+      public int hashCode() {
+        int h = a.hashCode();
+        h ^= (h << 13) | (h >>> 20);
+        h += b.hashCode();
+        h ^= (h << 23) | (h >>> 10);
+        h += name().hashCode();
+        return h;
+      }
 
+      @Override
+      public boolean equals(Object o) {
+        if (this.getClass() != o.getClass()) return false;
+        Function other = (Function)o;
+        return this.a.equals(other.a)
+            && this.b.equals(other.b);
+      }
+    }
 
-abstract class DoubleParser extends NamedParser {
-  public DoubleParser(String name) {
-    super(name);
   }
 
-  public abstract double func(int doc, FunctionValues vals) throws IOException;
+  static class BoolConstValueSource extends ConstNumberSource {
+    public static final BoolConstValueSource TRUE = new BoolConstValueSource(true);
+    public static final BoolConstValueSource FALSE = new BoolConstValueSource(false);
 
-  @Override
-  public ValueSource parse(FunctionQParser fp) throws SyntaxError {
-    return new Function(fp.parseValueSource());
-  }
+    final boolean constant;
 
-  class Function extends SingleFunction {
-    public Function(ValueSource source) {
-      super(source);
+    private BoolConstValueSource(boolean constant) {
+      this.constant = constant;
     }
 
     @Override
-    public String name() {
-      return DoubleParser.this.name();
+    public String description() {
+      return "const(" + constant + ")";
     }
 
     @Override
     public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-      final FunctionValues vals =  source.getValues(context, readerContext);
-      return new DoubleDocValues(this) {
+      return new BoolDocValues(this) {
         @Override
-        public double doubleVal(int doc) throws IOException {
-          return func(doc, vals);
-        }
-        @Override
-        public String toString(int doc) throws IOException {
-          return name() + '(' + vals.toString(doc) + ')';
+        public boolean boolVal(int doc) {
+          return constant;
         }
       };
     }
-  }
-}
 
+    @Override
+    public int hashCode() {
+      return constant ? 0x12345678 : 0x87654321;
+    }
 
-abstract class Double2Parser extends NamedParser {
-  public Double2Parser(String name) {
-    super(name);
-  }
-
-  public abstract double func(int doc, FunctionValues a, FunctionValues b) throws IOException;
-
-  @Override
-  public ValueSource parse(FunctionQParser fp) throws SyntaxError {
-    return new Function(fp.parseValueSource(), fp.parseValueSource());
-  }
+    @Override
+    public boolean equals(Object o) {
+      if (BoolConstValueSource.class != o.getClass()) return false;
+      BoolConstValueSource other = (BoolConstValueSource) o;
+      return this.constant == other.constant;
+    }
 
-  class Function extends ValueSource {
-    private final ValueSource a;
-    private final ValueSource b;
-
-   /**
-     * @param   a  the base.
-     * @param   b  the exponent.
-     */
-    public Function(ValueSource a, ValueSource b) {
-      this.a = a;
-      this.b = b;
+    @Override
+    public int getInt() {
+      return constant ? 1 : 0;
     }
 
     @Override
-    public String description() {
-      return name() + "(" + a.description() + "," + b.description() + ")";
+    public long getLong() {
+      return constant ? 1 : 0;
     }
 
     @Override
-    public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-      final FunctionValues aVals =  a.getValues(context, readerContext);
-      final FunctionValues bVals =  b.getValues(context, readerContext);
-      return new DoubleDocValues(this) {
-        @Override
-        public double doubleVal(int doc) throws IOException {
-          return func(doc, aVals, bVals);
-        }
-        @Override
-        public String toString(int doc) throws IOException {
-          return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
-        }
-      };
+    public float getFloat() {
+      return constant ? 1 : 0;
     }
 
     @Override
-    public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    public double getDouble() {
+      return constant ? 1 : 0;
     }
 
     @Override
-    public int hashCode() {
-      int h = a.hashCode();
-      h ^= (h << 13) | (h >>> 20);
-      h += b.hashCode();
-      h ^= (h << 23) | (h >>> 10);
-      h += name().hashCode();
-      return h;
+    public Number getNumber() {
+      return constant ? 1 : 0;
     }
 
     @Override
-    public boolean equals(Object o) {
-      if (this.getClass() != o.getClass()) return false;
-      Function other = (Function)o;
-      return this.a.equals(other.a)
-          && this.b.equals(other.b);
+    public boolean getBool() {
+      return constant;
     }
   }
 
-}
+  static class TestValueSource extends ValueSource {
+    ValueSource source;
 
+    public TestValueSource(ValueSource source) {
+      this.source = source;
+    }
 
-class BoolConstValueSource extends ConstNumberSource {
-  final boolean constant;
-
-  public BoolConstValueSource(boolean constant) {
-    this.constant = constant;
-  }
-
-  @Override
-  public String description() {
-    return "const(" + constant + ")";
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-    return new BoolDocValues(this) {
-      @Override
-      public boolean boolVal(int doc) {
-        return constant;
+    @Override
+    public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
+      if (context.get(this) == null) {
+        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "testfunc: unweighted value source detected.  delegate="+source + " request=" + (requestInfo==null ? "null" : requestInfo.getReq()));
       }
-    };
-  }
-
-  @Override
-  public int hashCode() {
-    return constant ? 0x12345678 : 0x87654321;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (BoolConstValueSource.class != o.getClass()) return false;
-    BoolConstValueSource other = (BoolConstValueSource) o;
-    return this.constant == other.constant;
-  }
-
-  @Override
-  public int getInt() {
-    return constant ? 1 : 0;
-  }
-
-  @Override
-  public long getLong() {
-    return constant ? 1 : 0;
-  }
-
-  @Override
-  public float getFloat() {
-    return constant ? 1 : 0;
-  }
-
-  @Override
-  public double getDouble() {
-    return constant ? 1 : 0;
-  }
-
-  @Override
-  public Number getNumber() {
-    return constant ? 1 : 0;
-  }
-
-  @Override
-  public boolean getBool() {
-    return constant;
-  }
-}
+      return source.getValues(context, readerContext);
+    }
 
+    @Override
+    public boolean equals(Object o) {
+      return o instanceof TestValueSource && source.equals(((TestValueSource)o).source);
+    }
 
-class TestValueSource extends ValueSource {
-  ValueSource source;
-  
-  public TestValueSource(ValueSource source) {
-    this.source = source;
-  }
-  
-  @Override
-  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
-    if (context.get(this) == null) {
-      SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "testfunc: unweighted value source detected.  delegate="+source + " request=" + (requestInfo==null ? "null" : requestInfo.getReq()));
+    @Override
+    public int hashCode() {
+      return source.hashCode() + TestValueSource.class.hashCode();
     }
-    return source.getValues(context, readerContext);
-  }
 
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof TestValueSource && source.equals(((TestValueSource)o).source);
-  }
+    @Override
+    public String description() {
+      return "testfunc(" + source.description() + ')';
+    }
 
-  @Override
-  public int hashCode() {
-    return source.hashCode() + TestValueSource.class.hashCode();
-  }
+    @Override
+    public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+      context.put(this, this);
+    }
 
-  @Override
-  public String description() {
-    return "testfunc(" + source.description() + ')';
+    @Override
+    public SortField getSortField(boolean reverse) {
+      return super.getSortField(reverse);
+    }
   }
+}
 
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    context.put(this, this);
-  }
 
-  @Override
-  public SortField getSortField(boolean reverse) {
-    return super.getSortField(reverse);
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/search/facet/AggValueSource.java b/solr/core/src/java/org/apache/solr/search/facet/AggValueSource.java
index 1678c6fa097..c633dbf43b3 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/AggValueSource.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/AggValueSource.java
@@ -50,7 +50,7 @@ public abstract class AggValueSource extends ValueSource {
   }
 
   // TODO: make abstract
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     throw new UnsupportedOperationException("NOT IMPLEMENTED " + name + " " + this);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/AvgAgg.java b/solr/core/src/java/org/apache/solr/search/facet/AvgAgg.java
index 3b6cee03d56..e22192b0c61 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/AvgAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/AvgAgg.java
@@ -37,7 +37,7 @@ public class AvgAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -91,7 +91,7 @@ public class AvgAgg extends SimpleAggValueSource {
   class AvgSortedNumericAcc extends DoubleSortedNumericDVAcc {
     int[] counts;
 
-    public AvgSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public AvgSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
       this.counts = new int[numSlots];
     }
@@ -141,7 +141,7 @@ public class AvgAgg extends SimpleAggValueSource {
   class AvgSortedSetAcc extends DoubleSortedSetDVAcc {
     int[] counts;
 
-    public AvgSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public AvgSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
       this.counts = new int[numSlots];
     }
@@ -195,7 +195,7 @@ public class AvgAgg extends SimpleAggValueSource {
   class AvgUnInvertedFieldAcc extends DoubleUnInvertedFieldAcc {
     int[] counts;
 
-    public AvgUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public AvgUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
       this.counts = new int[numSlots];
     }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/CountAgg.java b/solr/core/src/java/org/apache/solr/search/facet/CountAgg.java
index 491622d2afe..527399c681c 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/CountAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/CountAgg.java
@@ -24,7 +24,7 @@ public class CountAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     return new CountSlotArrAcc(fcontext, numSlots);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/CountValsAgg.java b/solr/core/src/java/org/apache/solr/search/facet/CountValsAgg.java
index 81fa983b926..8735c0fdb23 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/CountValsAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/CountValsAgg.java
@@ -37,7 +37,7 @@ public class CountValsAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
     if (vs instanceof FieldNameValueSource) {
       String field = ((FieldNameValueSource)vs).getFieldName();
@@ -69,7 +69,7 @@ public class CountValsAgg extends SimpleAggValueSource {
 
   class CountValSlotAcc extends LongFuncSlotAcc {
 
-    public CountValSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public CountValSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots, 0);
     }
 
@@ -83,7 +83,7 @@ public class CountValsAgg extends SimpleAggValueSource {
 
   class CountSortedNumericDVAcc extends LongSortedNumericDVAcc {
 
-    public CountSortedNumericDVAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public CountSortedNumericDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -95,7 +95,7 @@ public class CountValsAgg extends SimpleAggValueSource {
 
   class CountSortedSetDVAcc extends LongSortedSetDVAcc {
 
-    public CountSortedSetDVAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public CountSortedSetDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -111,7 +111,7 @@ public class CountValsAgg extends SimpleAggValueSource {
     private int currentSlot;
     long[] result;
 
-    public CountMultiValuedAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public CountMultiValuedAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
       result = new long[numSlots];
     }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/DocValuesAcc.java b/solr/core/src/java/org/apache/solr/search/facet/DocValuesAcc.java
index bd52c42c50b..1603a50f724 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/DocValuesAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/DocValuesAcc.java
@@ -39,7 +39,7 @@ import org.apache.solr.schema.SchemaField;
 public abstract class DocValuesAcc extends SlotAcc {
   SchemaField sf;
 
-  public DocValuesAcc(FacetContext fcontext, SchemaField sf) throws IOException {
+  public DocValuesAcc(FacetRequest.FacetContext fcontext, SchemaField sf) throws IOException {
     super(fcontext);
     this.sf = sf;
   }
@@ -66,7 +66,7 @@ public abstract class DocValuesAcc extends SlotAcc {
 abstract class NumericDVAcc extends DocValuesAcc {
   NumericDocValues values;
 
-  public NumericDVAcc(FacetContext fcontext, SchemaField sf) throws IOException {
+  public NumericDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf) throws IOException {
     super(fcontext, sf);
   }
 
@@ -88,7 +88,7 @@ abstract class NumericDVAcc extends DocValuesAcc {
 abstract class SortedNumericDVAcc extends DocValuesAcc {
   SortedNumericDocValues values;
 
-  public SortedNumericDVAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public SortedNumericDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext, sf);
   }
 
@@ -108,7 +108,7 @@ abstract class LongSortedNumericDVAcc extends SortedNumericDVAcc {
   long[] result;
   long initialValue;
 
-  public LongSortedNumericDVAcc(FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
+  public LongSortedNumericDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
     super(fcontext, sf, numSlots);
     this.result = new long[numSlots];
     this.initialValue = initialValue;
@@ -143,7 +143,7 @@ abstract class DoubleSortedNumericDVAcc extends SortedNumericDVAcc {
   double[] result;
   double initialValue;
 
-  public DoubleSortedNumericDVAcc(FacetContext fcontext, SchemaField sf, int numSlots, double initialValue) throws IOException {
+  public DoubleSortedNumericDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots, double initialValue) throws IOException {
     super(fcontext, sf, numSlots);
     this.result = new double[numSlots];
     this.initialValue = initialValue;
@@ -200,7 +200,7 @@ abstract class SDVSortedNumericAcc extends DoubleSortedNumericDVAcc {
   int[] counts;
   double[] sum;
 
-  public SDVSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public SDVSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext, sf, numSlots, 0);
     this.counts = new int[numSlots];
     this.sum = new double[numSlots];
@@ -257,7 +257,7 @@ abstract class SDVSortedNumericAcc extends DoubleSortedNumericDVAcc {
 abstract class SortedDVAcc extends DocValuesAcc {
   SortedDocValues values;
 
-  public SortedDVAcc(FacetContext fcontext, SchemaField sf) throws IOException {
+  public SortedDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf) throws IOException {
     super(fcontext, sf);
   }
 
@@ -279,7 +279,7 @@ abstract class SortedDVAcc extends DocValuesAcc {
 abstract class SortedSetDVAcc extends DocValuesAcc {
   SortedSetDocValues values;
 
-  public SortedSetDVAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public SortedSetDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext, sf);
   }
 
@@ -299,7 +299,7 @@ abstract class LongSortedSetDVAcc extends SortedSetDVAcc {
   long[] result;
   long initialValue;
 
-  public LongSortedSetDVAcc(FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
+  public LongSortedSetDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
     super(fcontext, sf, numSlots);
     result = new long[numSlots];
     this.initialValue = initialValue;
@@ -333,7 +333,7 @@ abstract class DoubleSortedSetDVAcc extends SortedSetDVAcc {
   double[] result;
   double initialValue;
 
-  public DoubleSortedSetDVAcc(FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
+  public DoubleSortedSetDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots, long initialValue) throws IOException {
     super(fcontext, sf, numSlots);
     result = new double[numSlots];
     this.initialValue = initialValue;
@@ -370,7 +370,7 @@ abstract class SDVSortedSetAcc extends DoubleSortedSetDVAcc {
   int[] counts;
   double[] sum;
 
-  public SDVSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public SDVSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext, sf, numSlots, 0);
     this.counts = new int[numSlots];
     this.sum = new double[numSlots];
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
index fe418f1b385..631fefc7753 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
@@ -41,7 +41,7 @@ import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.DocSet;
 import org.apache.solr.search.facet.SlotAcc.SlotContext;
 
-import static org.apache.solr.search.facet.FacetContext.SKIP_FACET;
+import static org.apache.solr.search.facet.FacetRequest.FacetContext.SKIP_FACET;
 
 /**
  * Facet processing based on field values. (not range nor by query)
@@ -69,7 +69,7 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
 
   SpecialSlotAcc allBucketsAcc;  // this can internally refer to otherAccs and/or collectAcc. setNextReader should be called on otherAccs directly if they exist.
 
-  FacetFieldProcessor(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessor(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq);
     this.sf = sf;
     this.effectiveMincount = (int)(fcontext.isShard() ? Math.min(1 , freq.mincount) : freq.mincount);
@@ -690,7 +690,7 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
   static class MultiAcc extends SlotAcc {
     final SlotAcc[] subAccs;
 
-    MultiAcc(FacetContext fcontext, SlotAcc[] subAccs) {
+    MultiAcc(FacetRequest.FacetContext fcontext, SlotAcc[] subAccs) {
       super(fcontext);
       this.subAccs = subAccs;
     }
@@ -749,7 +749,7 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
     int otherAccsSlot;
     long count;
 
-    SpecialSlotAcc(FacetContext fcontext, SlotAcc collectAcc, int collectAccSlot, SlotAcc[] otherAccs, int otherAccsSlot) {
+    SpecialSlotAcc(FacetRequest.FacetContext fcontext, SlotAcc collectAcc, int collectAccSlot, SlotAcc[] otherAccs, int otherAccsSlot) {
       super(fcontext);
       this.collectAcc = collectAcc;
       this.collectAccSlot = collectAccSlot;
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray.java
index e5ee181b5cb..b60ec119271 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray.java
@@ -28,7 +28,7 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.facet.SlotAcc.SlotContext;
 
-import static org.apache.solr.search.facet.FacetContext.SKIP_FACET;
+import static org.apache.solr.search.facet.FacetRequest.FacetContext.SKIP_FACET;
 
 /**
  * Base class for DV/UIF accumulating counts into an array by ordinal.  It's
@@ -45,7 +45,7 @@ abstract class FacetFieldProcessorByArray extends FacetFieldProcessor {
 
   int allBucketsSlot = -1;  // slot for the primary Accs (countAcc, collectAcc)
 
-  FacetFieldProcessorByArray(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessorByArray(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq, sf);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayDV.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayDV.java
index dfd1bc18e18..1443b5e15f9 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayDV.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayDV.java
@@ -46,7 +46,7 @@ class FacetFieldProcessorByArrayDV extends FacetFieldProcessorByArray {
   SortedSetDocValues si;  // only used for term lookups (for both single and multi-valued)
   OrdinalMap ordinalMap = null; // maps per-segment ords to global ords
 
-  FacetFieldProcessorByArrayDV(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessorByArrayDV(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq, sf);
     multiValuedField = sf.multiValued() || sf.getType().multiValuedFieldCache();
   }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayUIF.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayUIF.java
index 6c90b3eca0f..4e70d40dec6 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayUIF.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArrayUIF.java
@@ -30,7 +30,7 @@ class FacetFieldProcessorByArrayUIF extends FacetFieldProcessorByArray {
   UnInvertedField uif;
   TermsEnum te;
 
-  FacetFieldProcessorByArrayUIF(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessorByArrayUIF(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq, sf);
     if (! sf.isUninvertible()) {
       throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
index 8151aec41e7..c2c0a1f1b9a 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
@@ -72,7 +72,7 @@ class FacetFieldProcessorByEnumTermsStream extends FacetFieldProcessor implement
   
   LeafReaderContext[] leaves;
 
-  FacetFieldProcessorByEnumTermsStream(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessorByEnumTermsStream(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq, sf);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV.java
index 966da872a6d..058cfd62fb6 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV.java
@@ -189,7 +189,7 @@ class FacetFieldProcessorByHashDV extends FacetFieldProcessor {
   LongCounts table;
   int allBucketsSlot = -1;
 
-  FacetFieldProcessorByHashDV(FacetContext fcontext, FacetField freq, SchemaField sf) {
+  FacetFieldProcessorByHashDV(FacetRequest.FacetContext fcontext, FacetField freq, SchemaField sf) {
     super(fcontext, freq, sf);
     if (freq.mincount == 0) {
       throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetModule.java b/solr/core/src/java/org/apache/solr/search/facet/FacetModule.java
index 847e651f98d..6eb10d7a65d 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetModule.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetModule.java
@@ -125,17 +125,17 @@ public class FacetModule extends SearchComponent {
 
     boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);
 
-    FacetContext fcontext = new FacetContext();
+    FacetRequest.FacetContext fcontext = new FacetRequest.FacetContext();
     fcontext.base = rb.getResults().docSet;
     fcontext.req = rb.req;
     fcontext.searcher = rb.req.getSearcher();
     fcontext.qcontext = QueryContext.newContext(fcontext.searcher);
     if (isShard) {
-      fcontext.flags |= FacetContext.IS_SHARD;
+      fcontext.flags |= FacetRequest.FacetContext.IS_SHARD;
       fcontext.facetInfo = facetState.facetInfo.isEmpty() ? null : (Map<String,Object>)facetState.facetInfo.get(FACET_REFINE);
       if (fcontext.facetInfo != null) {
-        fcontext.flags |= FacetContext.IS_REFINEMENT;
-        fcontext.flags |= FacetContext.SKIP_FACET; // the root bucket should have been received from all shards previously
+        fcontext.flags |= FacetRequest.FacetContext.IS_REFINEMENT;
+        fcontext.flags |= FacetRequest.FacetContext.SKIP_FACET; // the root bucket should have been received from all shards previously
       }
     }
     if (rb.isDebug()) {
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java b/solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java
index b8271f5961a..c1043f967b9 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java
@@ -47,7 +47,7 @@ import org.apache.solr.search.facet.SlotAcc.SlotContext;
 /** Base abstraction for a class that computes facets. This is fairly internal to the module. */
 public abstract class FacetProcessor<FacetRequestT extends FacetRequest>  {
   SimpleOrderedMap<Object> response;
-  FacetContext fcontext;
+  FacetRequest.FacetContext fcontext;
   FacetRequestT freq;
 
   DocSet filter;  // additional filters specified by "filter"  // TODO: do these need to be on the context to support recomputing during multi-select?
@@ -55,7 +55,7 @@ public abstract class FacetProcessor<FacetRequestT extends FacetRequest>  {
   SlotAcc[] accs;
   CountSlotAcc countAcc;
 
-  FacetProcessor(FacetContext fcontext, FacetRequestT freq) {
+  FacetProcessor(FacetRequest.FacetContext fcontext, FacetRequestT freq) {
     this.fcontext = fcontext;
     this.freq = freq;
     fcontext.processor = this;
@@ -74,7 +74,7 @@ public abstract class FacetProcessor<FacetRequestT extends FacetRequest>  {
     this.filter = fcontext.searcher.getDocSet(evalJSONFilterQueryStruct(fcontext, freq.domain.filters));
   }
   
-  private static List<Query> evalJSONFilterQueryStruct(FacetContext fcontext, List<Object> filters) throws IOException {
+  private static List<Query> evalJSONFilterQueryStruct(FacetRequest.FacetContext fcontext, List<Object> filters) throws IOException {
     List<Query> qlist = new ArrayList<>(filters.size());
     // TODO: prevent parsing filters each time!
     for (Object rawFilter : filters) {
@@ -226,7 +226,7 @@ public abstract class FacetProcessor<FacetRequestT extends FacetRequest>  {
 
     // now walk back up the context tree
     // TODO: we lose parent exclusions...
-    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {
+    for (FacetRequest.FacetContext curr = fcontext; curr != null; curr = curr.parent) {
       if (curr.filter != null) {
         qlist.add( curr.filter );
       }
@@ -462,9 +462,9 @@ public abstract class FacetProcessor<FacetRequestT extends FacetRequest>  {
       if (skip && facetInfoSub == null) continue;
 
       // make a new context for each sub-facet since they can change the domain
-      FacetContext subContext = fcontext.sub(filter, domain);
+      FacetRequest.FacetContext subContext = fcontext.sub(filter, domain);
       subContext.facetInfo = facetInfoSub;
-      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket
+      if (!skip) subContext.flags &= ~FacetRequest.FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket
 
       if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true
         FacetDebugInfo fdebug = new FacetDebugInfo();
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetQuery.java b/solr/core/src/java/org/apache/solr/search/facet/FacetQuery.java
index a6782bf7091..1d5a3307ffb 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetQuery.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetQuery.java
@@ -49,7 +49,7 @@ public class FacetQuery extends FacetRequest {
 
 
 class FacetQueryProcessor extends FacetProcessor<FacetQuery> {
-  FacetQueryProcessor(FacetContext fcontext, FacetQuery freq) {
+  FacetQueryProcessor(FacetRequest.FacetContext fcontext, FacetQuery freq) {
     super(fcontext, freq);
   }
 
@@ -61,7 +61,7 @@ class FacetQueryProcessor extends FacetProcessor<FacetQuery> {
       // FIXME - what needs to be done here?
     }
     response = new SimpleOrderedMap<>();
-    fillBucket(response, freq.q, null, (fcontext.flags & FacetContext.SKIP_FACET)!=0, fcontext.facetInfo);
+    fillBucket(response, freq.q, null, (fcontext.flags & FacetRequest.FacetContext.SKIP_FACET)!=0, fcontext.facetInfo);
   }
 
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetRange.java b/solr/core/src/java/org/apache/solr/search/facet/FacetRange.java
index a93bc079e70..b02834c5488 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetRange.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetRange.java
@@ -43,7 +43,7 @@ import org.apache.solr.search.SyntaxError;
 import org.apache.solr.search.facet.SlotAcc.SlotContext;
 import org.apache.solr.util.DateMathParser;
 
-import static org.apache.solr.search.facet.FacetContext.SKIP_FACET;
+import static org.apache.solr.search.facet.FacetRequest.FacetContext.SKIP_FACET;
 
 public class FacetRange extends FacetRequestSorted {
   static final String ACTUAL_END_JSON_KEY = "_actual_end";
@@ -123,7 +123,7 @@ class FacetRangeProcessor extends FacetProcessor<FacetRange> {
    */
   Comparable actual_end = null; // null until/unless we need it
 
-  FacetRangeProcessor(FacetContext fcontext, FacetRange freq) {
+  FacetRangeProcessor(FacetRequest.FacetContext fcontext, FacetRange freq) {
     super(fcontext, freq);
     include = freq.include;
     sf = fcontext.searcher.getSchema().getField(freq.field);
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetRequest.java b/solr/core/src/java/org/apache/solr/search/facet/FacetRequest.java
index 6860a943841..2ff3b575a56 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetRequest.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetRequest.java
@@ -437,699 +437,693 @@ public abstract class FacetRequest {
   public abstract FacetMerger createFacetMerger(Object prototype);
   
   public abstract Map<String, Object> getFacetDescription();
-}
 
+  static class FacetContext {
+    // Context info for actually executing a local facet command
+    public static final int IS_SHARD=0x01;
+    public static final int IS_REFINEMENT=0x02;
+    public static final int SKIP_FACET=0x04;  // refinement: skip calculating this immediate facet, but proceed to specific sub-facets based on facetInfo
+
+    FacetProcessor processor;
+    Map<String,Object> facetInfo; // refinement info for this node
+    QueryContext qcontext;
+    SolrQueryRequest req;  // TODO: replace with params?
+    SolrIndexSearcher searcher;
+    Query filter;  // TODO: keep track of as a DocSet or as a Query?
+    DocSet base;
+    FacetContext parent;
+    int flags;
+    FacetDebugInfo debugInfo;
+
+    public void setDebugInfo(FacetDebugInfo debugInfo) {
+      this.debugInfo = debugInfo;
+    }
 
-class FacetContext {
-  // Context info for actually executing a local facet command
-  public static final int IS_SHARD=0x01;
-  public static final int IS_REFINEMENT=0x02;
-  public static final int SKIP_FACET=0x04;  // refinement: skip calculating this immediate facet, but proceed to specific sub-facets based on facetInfo
-
-  FacetProcessor processor;
-  Map<String,Object> facetInfo; // refinement info for this node
-  QueryContext qcontext;
-  SolrQueryRequest req;  // TODO: replace with params?
-  SolrIndexSearcher searcher;
-  Query filter;  // TODO: keep track of as a DocSet or as a Query?
-  DocSet base;
-  FacetContext parent;
-  int flags;
-  FacetDebugInfo debugInfo;
-  
-  public void setDebugInfo(FacetDebugInfo debugInfo) {
-    this.debugInfo = debugInfo;
-  }
-  
-  public FacetDebugInfo getDebugInfo() {
-    return debugInfo;
-  }
-  
-  public boolean isShard() {
-    return (flags & IS_SHARD) != 0;
-  }
+    public FacetDebugInfo getDebugInfo() {
+      return debugInfo;
+    }
 
-  /**
-   * @param filter The filter for the bucket that resulted in this context/domain.  Can be null if this is the root context.
-   * @param domain The resulting set of documents for this facet.
-   */
-  public FacetContext sub(Query filter, DocSet domain) {
-    FacetContext ctx = new FacetContext();
-    ctx.parent = this;
-    ctx.base = domain;
-    ctx.filter = filter;
-
-    // carry over from parent
-    ctx.flags = flags;
-    ctx.qcontext = qcontext;
-    ctx.req = req;
-    ctx.searcher = searcher;
-
-    return ctx;
-  }
-}
+    public boolean isShard() {
+      return (flags & IS_SHARD) != 0;
+    }
 
+    /**
+     * @param filter The filter for the bucket that resulted in this context/domain.  Can be null if this is the root context.
+     * @param domain The resulting set of documents for this facet.
+     */
+    public FacetContext sub(Query filter, DocSet domain) {
+      FacetContext ctx = new FacetContext();
+      ctx.parent = this;
+      ctx.base = domain;
+      ctx.filter = filter;
+
+      // carry over from parent
+      ctx.flags = flags;
+      ctx.qcontext = qcontext;
+      ctx.req = req;
+      ctx.searcher = searcher;
+
+      return ctx;
+    }
+  }
 
-abstract class FacetParser<FacetRequestT extends FacetRequest> {
-  protected FacetRequestT facet;
-  protected FacetParser parent;
-  protected String key;
+  abstract static class FacetParser<FacetRequestT extends FacetRequest> {
+    protected FacetRequestT facet;
+    protected FacetParser parent;
+    protected String key;
 
-  public FacetParser(FacetParser parent,String key) {
-    this.parent = parent;
-    this.key = key;
-  }
+    public FacetParser(FacetParser parent, String key) {
+      this.parent = parent;
+      this.key = key;
+    }
 
-  public String getKey() {
-    return key;
-  }
+    public String getKey() {
+      return key;
+    }
 
-  public String getPathStr() {
-    if (parent == null) {
-      return "/" + key;
+    public String getPathStr() {
+      if (parent == null) {
+        return "/" + key;
+      }
+      return parent.getKey() + "/" + key;
     }
-    return parent.getKey() + "/" + key;
-  }
 
-  protected RuntimeException err(String msg) {
-    return new SolrException(SolrException.ErrorCode.BAD_REQUEST, msg + " , path="+getPathStr());
-  }
+    protected RuntimeException err(String msg) {
+      return new SolrException(SolrException.ErrorCode.BAD_REQUEST, msg + " , path="+getPathStr());
+    }
 
-  public abstract FacetRequest parse(Object o) throws SyntaxError;
+    public abstract FacetRequest parse(Object o) throws SyntaxError;
 
-  // TODO: put the FacetRequest on the parser object?
-  public void parseSubs(Object o) throws SyntaxError {
-    if (o==null) return;
-    if (o instanceof Map) {
-      Map<String,Object> m = (Map<String, Object>) o;
-      for (Map.Entry<String,Object> entry : m.entrySet()) {
-        String key = entry.getKey();
-        Object value = entry.getValue();
+    // TODO: put the FacetRequest on the parser object?
+    public void parseSubs(Object o) throws SyntaxError {
+      if (o==null) return;
+      if (o instanceof Map) {
+        Map<String,Object> m = (Map<String, Object>) o;
+        for (Map.Entry<String,Object> entry : m.entrySet()) {
+          String key = entry.getKey();
+          Object value = entry.getValue();
 
-        if ("processEmpty".equals(key)) {
-          facet.processEmpty = getBoolean(m, "processEmpty", false);
-          continue;
-        }
+          if ("processEmpty".equals(key)) {
+            facet.processEmpty = getBoolean(m, "processEmpty", false);
+            continue;
+          }
 
-        // "my_prices" : { "range" : { "field":...
-        // key="my_prices", value={"range":..
+          // "my_prices" : { "range" : { "field":...
+          // key="my_prices", value={"range":..
 
-        Object parsedValue = parseFacetOrStat(key, value);
+          Object parsedValue = parseFacetOrStat(key, value);
 
-        // TODO: have parseFacetOrStat directly add instead of return?
-        if (parsedValue instanceof FacetRequest) {
-          facet.addSubFacet(key, (FacetRequest)parsedValue);
-        } else if (parsedValue instanceof AggValueSource) {
-          facet.addStat(key, (AggValueSource)parsedValue);
-        } else {
-          throw err("Unknown facet type key=" + key + " class=" + (parsedValue == null ? "null" : parsedValue.getClass().getName()));
+          // TODO: have parseFacetOrStat directly add instead of return?
+          if (parsedValue instanceof FacetRequest) {
+            facet.addSubFacet(key, (FacetRequest)parsedValue);
+          } else if (parsedValue instanceof AggValueSource) {
+            facet.addStat(key, (AggValueSource)parsedValue);
+          } else {
+            throw err("Unknown facet type key=" + key + " class=" + (parsedValue == null ? "null" : parsedValue.getClass().getName()));
+          }
         }
+      } else {
+        // facet : my_field?
+        throw err("Expected map for facet/stat");
       }
-    } else {
-      // facet : my_field?
-      throw err("Expected map for facet/stat");
     }
-  }
 
-  public Object parseFacetOrStat(String key, Object o) throws SyntaxError {
+    public Object parseFacetOrStat(String key, Object o) throws SyntaxError {
 
-    if (o instanceof String) {
-      return parseStringFacetOrStat(key, (String)o);
-    }
+      if (o instanceof String) {
+        return parseStringFacetOrStat(key, (String)o);
+      }
+
+      if (!(o instanceof Map)) {
+        throw err("expected Map but got " + o);
+      }
+
+      // The type can be in a one element map, or inside the args as the "type" field
+      // { "query" : "foo:bar" }
+      // { "range" : { "field":... } }
+      // { "type"  : range, field : myfield, ... }
+      Map<String,Object> m = (Map<String,Object>)o;
+      String type;
+      Object args;
+
+      if (m.size() == 1) {
+        Map.Entry<String,Object> entry = m.entrySet().iterator().next();
+        type = entry.getKey();
+        args = entry.getValue();
+        // throw err("expected facet/stat type name, like {range:{... but got " + m);
+      } else {
+        // type should be inside the map as a parameter
+        Object typeObj = m.get("type");
+        if (!(typeObj instanceof String)) {
+            throw err("expected facet/stat type name, like {type:range, field:price, ...} but got " + typeObj);
+        }
+        type = (String)typeObj;
+        args = m;
+      }
 
-    if (!(o instanceof Map)) {
-      throw err("expected Map but got " + o);
+      return parseFacetOrStat(key, type, args);
     }
 
-    // The type can be in a one element map, or inside the args as the "type" field
-    // { "query" : "foo:bar" }
-    // { "range" : { "field":... } }
-    // { "type"  : range, field : myfield, ... }
-    Map<String,Object> m = (Map<String,Object>)o;
-    String type;
-    Object args;
-
-    if (m.size() == 1) {
-      Map.Entry<String,Object> entry = m.entrySet().iterator().next();
-      type = entry.getKey();
-      args = entry.getValue();
-      // throw err("expected facet/stat type name, like {range:{... but got " + m);
-    } else {
-      // type should be inside the map as a parameter
-      Object typeObj = m.get("type");
-      if (!(typeObj instanceof String)) {
-          throw err("expected facet/stat type name, like {type:range, field:price, ...} but got " + typeObj);
+    public Object parseFacetOrStat(String key, String type, Object args) throws SyntaxError {
+      // TODO: a place to register all these facet types?
+
+      switch (type) {
+        case "field":
+        case "terms":
+          return new FacetFieldParser(this, key).parse(args);
+        case "query":
+          return new FacetQueryParser(this, key).parse(args);
+        case "range":
+          return new FacetRangeParser(this, key).parse(args);
+        case "heatmap":
+          return new FacetHeatmap.Parser(this, key).parse(args);
+        case "func":
+          return parseStat(key, args);
       }
-      type = (String)typeObj;
-      args = m;
+
+      throw err("Unknown facet or stat. key=" + key + " type=" + type + " args=" + args);
     }
 
-    return parseFacetOrStat(key, type, args);
-  }
+    public Object parseStringFacetOrStat(String key, String s) throws SyntaxError {
+      // "avg(myfield)"
+      return parseStat(key, s);
+      // TODO - simple string representation of facets
+    }
 
-  public Object parseFacetOrStat(String key, String type, Object args) throws SyntaxError {
-    // TODO: a place to register all these facet types?
-
-    switch (type) {
-      case "field":
-      case "terms":
-        return new FacetFieldParser(this, key).parse(args);
-      case "query":
-        return new FacetQueryParser(this, key).parse(args);
-      case "range":
-        return new FacetRangeParser(this, key).parse(args);
-      case "heatmap":
-        return new FacetHeatmap.Parser(this, key).parse(args);
-      case "func":
-        return parseStat(key, args);
+    /** Parses simple strings like "avg(x)" in the context of optional local params (may be null) */
+    private AggValueSource parseStatWithParams(String key, SolrParams localparams, String stat) throws SyntaxError {
+      SolrQueryRequest req = getSolrRequest();
+      FunctionQParser parser = new FunctionQParser(stat, localparams, req.getParams(), req);
+      AggValueSource agg = parser.parseAgg(FunctionQParser.FLAG_DEFAULT);
+      return agg;
     }
 
-    throw err("Unknown facet or stat. key=" + key + " type=" + type + " args=" + args);
-  }
+    /** Parses simple strings like "avg(x)" or robust Maps that may contain local params */
+    private AggValueSource parseStat(String key, Object args) throws SyntaxError {
+      assert null != args;
 
-  public Object parseStringFacetOrStat(String key, String s) throws SyntaxError {
-    // "avg(myfield)"
-    return parseStat(key, s);
-    // TODO - simple string representation of facets
-  }
+      if (args instanceof CharSequence) {
+        // Both of these variants are already unpacked for us in this case, and use no local params...
+        // 1) x:{func:'min(foo)'}
+        // 2) x:'min(foo)'
+        return parseStatWithParams(key, null, args.toString());
+      }
 
-  /** Parses simple strings like "avg(x)" in the context of optional local params (may be null) */
-  private AggValueSource parseStatWithParams(String key, SolrParams localparams, String stat) throws SyntaxError {
-    SolrQueryRequest req = getSolrRequest();
-    FunctionQParser parser = new FunctionQParser(stat, localparams, req.getParams(), req);
-    AggValueSource agg = parser.parseAgg(FunctionQParser.FLAG_DEFAULT);
-    return agg;
-  }
-  
-  /** Parses simple strings like "avg(x)" or robust Maps that may contain local params */
-  private AggValueSource parseStat(String key, Object args) throws SyntaxError {
-    assert null != args;
-
-    if (args instanceof CharSequence) {
-      // Both of these variants are already unpacked for us in this case, and use no local params...
-      // 1) x:{func:'min(foo)'}
-      // 2) x:'min(foo)'
-      return parseStatWithParams(key, null, args.toString());
-    }
-    
-    if (args instanceof Map) {
-      final Map<String,Object> statMap = (Map<String,Object>)args;
-      return parseStatWithParams(key, jsonToSolrParams(statMap), statMap.get("func").toString());
-    }
-      
-    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
-                            "Stats must be specified as either a simple string, or a json Map");
-      
-  }
+      if (args instanceof Map) {
+        final Map<String,Object> statMap = (Map<String,Object>)args;
+        return parseStatWithParams(key, jsonToSolrParams(statMap), statMap.get("func").toString());
+      }
 
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                              "Stats must be specified as either a simple string, or a json Map");
 
-  private FacetRequest.Domain getDomain() {
-    if (facet.domain == null) {
-      facet.domain = new FacetRequest.Domain();
     }
-    return facet.domain;
-  }
 
-  protected void parseCommonParams(Object o) {
-    if (o instanceof Map) {
-      Map<String,Object> m = (Map<String,Object>)o;
-      List<String> excludeTags = getStringList(m, "excludeTags");
-      if (excludeTags != null) {
-        getDomain().excludeTags = excludeTags;
-      }
 
-      Object domainObj =  m.get("domain");
-      if (domainObj instanceof Map) {
-        Map<String, Object> domainMap = (Map<String, Object>)domainObj;
-        FacetRequest.Domain domain = getDomain();
+    private Domain getDomain() {
+      if (facet.domain == null) {
+        facet.domain = new Domain();
+      }
+      return facet.domain;
+    }
 
-        excludeTags = getStringList(domainMap, "excludeTags");
+    protected void parseCommonParams(Object o) {
+      if (o instanceof Map) {
+        Map<String,Object> m = (Map<String,Object>)o;
+        List<String> excludeTags = getStringList(m, "excludeTags");
         if (excludeTags != null) {
-          domain.excludeTags = excludeTags;
+          getDomain().excludeTags = excludeTags;
         }
 
-        if (domainMap.containsKey("query")) {
-          domain.explicitQueries = parseJSONQueryStruct(domainMap.get("query"));
-          if (null == domain.explicitQueries) {
-            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
-                                    "'query' domain can not be null or empty");
-          } else if (null != domain.excludeTags) {
-            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
-                                    "'query' domain can not be combined with 'excludeTags'");
+        Object domainObj =  m.get("domain");
+        if (domainObj instanceof Map) {
+          Map<String, Object> domainMap = (Map<String, Object>)domainObj;
+          Domain domain = getDomain();
+
+          excludeTags = getStringList(domainMap, "excludeTags");
+          if (excludeTags != null) {
+            domain.excludeTags = excludeTags;
           }
-        }
 
-        String blockParent = getString(domainMap, "blockParent", null);
-        String blockChildren = getString(domainMap, "blockChildren", null);
+          if (domainMap.containsKey("query")) {
+            domain.explicitQueries = parseJSONQueryStruct(domainMap.get("query"));
+            if (null == domain.explicitQueries) {
+              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                      "'query' domain can not be null or empty");
+            } else if (null != domain.excludeTags) {
+              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                      "'query' domain can not be combined with 'excludeTags'");
+            }
+          }
 
-        if (blockParent != null) {
-          domain.toParent = true;
-          domain.parents = blockParent;
-        } else if (blockChildren != null) {
-          domain.toChildren = true;
-          domain.parents = blockChildren;
-        }
-          
-        FacetRequest.Domain.JoinField.createJoinField(domain, domainMap);
-        FacetRequest.Domain.GraphField.createGraphField(domain, domainMap);
-
-        Object filterOrList = domainMap.get("filter");
-        if (filterOrList != null) {
-          assert domain.filters == null;
-          domain.filters = parseJSONQueryStruct(filterOrList);
-        }
+          String blockParent = getString(domainMap, "blockParent", null);
+          String blockChildren = getString(domainMap, "blockChildren", null);
 
-      } else if (domainObj != null) {
-        throw err("Expected Map for 'domain', received " + domainObj.getClass().getSimpleName() + "=" + domainObj);
+          if (blockParent != null) {
+            domain.toParent = true;
+            domain.parents = blockParent;
+          } else if (blockChildren != null) {
+            domain.toChildren = true;
+            domain.parents = blockChildren;
+          }
+
+          Domain.JoinField.createJoinField(domain, domainMap);
+          Domain.GraphField.createGraphField(domain, domainMap);
+
+          Object filterOrList = domainMap.get("filter");
+          if (filterOrList != null) {
+            assert domain.filters == null;
+            domain.filters = parseJSONQueryStruct(filterOrList);
+          }
+
+        } else if (domainObj != null) {
+          throw err("Expected Map for 'domain', received " + domainObj.getClass().getSimpleName() + "=" + domainObj);
+        }
       }
     }
-  }
 
-  /** returns null on null input, otherwise returns a list of the JSON query structures -- either
-   * directly from the raw (list) input, or if raw input is a not a list then it encapsulates 
-   * it in a new list.
-   */
-  private List<Object> parseJSONQueryStruct(Object raw) {
-    List<Object> result = null;
-    if (null == raw) {
+    /** returns null on null input, otherwise returns a list of the JSON query structures -- either
+     * directly from the raw (list) input, or if raw input is a not a list then it encapsulates
+     * it in a new list.
+     */
+    private List<Object> parseJSONQueryStruct(Object raw) {
+      List<Object> result = null;
+      if (null == raw) {
+        return result;
+      } else if (raw instanceof List) {
+        result = (List<Object>) raw;
+      } else {
+        result = new ArrayList<>(1);
+        result.add(raw);
+      }
       return result;
-    } else if (raw instanceof List) {
-      result = (List<Object>) raw;
-    } else {
-      result = new ArrayList<>(1);
-      result.add(raw);
     }
-    return result;
-  }
 
-  public String getField(Map<String,Object> args) {
-    Object fieldName = args.get("field"); // TODO: pull out into defined constant
-    if (fieldName == null) {
-      fieldName = args.get("f");  // short form
-    }
-    if (fieldName == null) {
-      throw err("Missing 'field'");
-    }
+    public String getField(Map<String,Object> args) {
+      Object fieldName = args.get("field"); // TODO: pull out into defined constant
+      if (fieldName == null) {
+        fieldName = args.get("f");  // short form
+      }
+      if (fieldName == null) {
+        throw err("Missing 'field'");
+      }
 
-    if (!(fieldName instanceof String)) {
-      throw err("Expected string for 'field', got" + fieldName);
-    }
+      if (!(fieldName instanceof String)) {
+        throw err("Expected string for 'field', got" + fieldName);
+      }
 
-    return (String)fieldName;
-  }
+      return (String)fieldName;
+    }
 
 
-  public Long getLongOrNull(Map<String,Object> args, String paramName, boolean required) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      if (required) {
-        throw err("Missing required parameter '" + paramName + "'");
+    public Long getLongOrNull(Map<String,Object> args, String paramName, boolean required) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        if (required) {
+          throw err("Missing required parameter '" + paramName + "'");
+        }
+        return null;
       }
-      return null;
-    }
-    if (!(o instanceof Long || o instanceof Integer || o instanceof Short || o instanceof Byte)) {
-      throw err("Expected integer type for param '"+paramName + "' but got " + o);
+      if (!(o instanceof Long || o instanceof Integer || o instanceof Short || o instanceof Byte)) {
+        throw err("Expected integer type for param '"+paramName + "' but got " + o);
+      }
+
+      return ((Number)o).longValue();
     }
 
-    return ((Number)o).longValue();
-  }
+    public long getLong(Map<String,Object> args, String paramName, long defVal) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        return defVal;
+      }
+      if (!(o instanceof Long || o instanceof Integer || o instanceof Short || o instanceof Byte)) {
+        throw err("Expected integer type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      }
 
-  public long getLong(Map<String,Object> args, String paramName, long defVal) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      return defVal;
-    }
-    if (!(o instanceof Long || o instanceof Integer || o instanceof Short || o instanceof Byte)) {
-      throw err("Expected integer type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      return ((Number)o).longValue();
     }
 
-    return ((Number)o).longValue();
-  }
-
-  public Double getDoubleOrNull(Map<String,Object> args, String paramName, boolean required) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      if (required) {
-        throw err("Missing required parameter '" + paramName + "'");
+    public Double getDoubleOrNull(Map<String,Object> args, String paramName, boolean required) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        if (required) {
+          throw err("Missing required parameter '" + paramName + "'");
+        }
+        return null;
       }
-      return null;
-    }
-    if (!(o instanceof Number)) {
-      throw err("Expected double type for param '" + paramName + "' but got " + o);
+      if (!(o instanceof Number)) {
+        throw err("Expected double type for param '" + paramName + "' but got " + o);
+      }
+
+      return ((Number)o).doubleValue();
     }
 
-    return ((Number)o).doubleValue();
-  }
+    public boolean getBoolean(Map<String,Object> args, String paramName, boolean defVal) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        return defVal;
+      }
+      // TODO: should we be more flexible and accept things like "true" (strings)?
+      // Perhaps wait until the use case comes up.
+      if (!(o instanceof Boolean)) {
+        throw err("Expected boolean type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      }
 
-  public boolean getBoolean(Map<String,Object> args, String paramName, boolean defVal) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      return defVal;
-    }
-    // TODO: should we be more flexible and accept things like "true" (strings)?
-    // Perhaps wait until the use case comes up.
-    if (!(o instanceof Boolean)) {
-      throw err("Expected boolean type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      return (Boolean)o;
     }
 
-    return (Boolean)o;
-  }
+    public Boolean getBooleanOrNull(Map<String, Object> args, String paramName) {
+      Object o = args.get(paramName);
 
-  public Boolean getBooleanOrNull(Map<String, Object> args, String paramName) {
-    Object o = args.get(paramName);
-
-    if (o != null && !(o instanceof Boolean)) {
-      throw err("Expected boolean type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      if (o != null && !(o instanceof Boolean)) {
+        throw err("Expected boolean type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      }
+      return (Boolean) o;
     }
-    return (Boolean) o;
-  }
 
 
-  public String getString(Map<String,Object> args, String paramName, String defVal) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      return defVal;
-    }
-    if (!(o instanceof String)) {
-      throw err("Expected string type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+    public String getString(Map<String,Object> args, String paramName, String defVal) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        return defVal;
+      }
+      if (!(o instanceof String)) {
+        throw err("Expected string type for param '"+paramName + "' but got " + o.getClass().getSimpleName() + " = " + o);
+      }
+
+      return (String)o;
     }
 
-    return (String)o;
-  }
+    public Object getVal(Map<String, Object> args, String paramName, boolean required) {
+      Object o = args.get(paramName);
+      if (o == null && required) {
+        throw err("Missing required parameter: '" + paramName + "'");
+      }
+      return o;
+    }
 
-  public Object getVal(Map<String, Object> args, String paramName, boolean required) {
-    Object o = args.get(paramName);
-    if (o == null && required) {
-      throw err("Missing required parameter: '" + paramName + "'");
+    public List<String> getStringList(Map<String,Object> args, String paramName) {
+      return getStringList(args, paramName, true);
     }
-    return o;
-  }
 
-  public List<String> getStringList(Map<String,Object> args, String paramName) {
-    return getStringList(args, paramName, true);
-  }
+    public List<String> getStringList(Map<String, Object> args, String paramName, boolean decode) {
+      Object o = args.get(paramName);
+      if (o == null) {
+        return null;
+      }
+      if (o instanceof List) {
+        return (List<String>)o;
+      }
+      if (o instanceof String) {
+        // TODO: SOLR-12539 handle spaces in b/w comma & value ie, should the values be trimmed before returning??
+        return StrUtils.splitSmart((String)o, ",", decode);
+      }
 
-  public List<String> getStringList(Map<String, Object> args, String paramName, boolean decode) {
-    Object o = args.get(paramName);
-    if (o == null) {
-      return null;
-    }
-    if (o instanceof List) {
-      return (List<String>)o;
+      throw err("Expected list of string or comma separated string values for '" + paramName +
+          "', received " + o.getClass().getSimpleName() + "=" + o);
     }
-    if (o instanceof String) {
-      // TODO: SOLR-12539 handle spaces in b/w comma & value ie, should the values be trimmed before returning??
-      return StrUtils.splitSmart((String)o, ",", decode);
-    }
-
-    throw err("Expected list of string or comma separated string values for '" + paramName +
-        "', received " + o.getClass().getSimpleName() + "=" + o);
-  }
 
-  public IndexSchema getSchema() {
-    return parent.getSchema();
-  }
+    public IndexSchema getSchema() {
+      return parent.getSchema();
+    }
 
-  public SolrQueryRequest getSolrRequest() {
-    return parent.getSolrRequest();
-  }
+    public SolrQueryRequest getSolrRequest() {
+      return parent.getSolrRequest();
+    }
 
-  /** 
-   * Helper that handles the possibility of map values being lists 
-   * NOTE: does *NOT* fail on map values that are sub-maps (ie: nested json objects)
-   */
-  public static SolrParams jsonToSolrParams(Map jsonObject) {
-    // HACK, but NamedList already handles the list processing for us...
-    NamedList<String> nl = new NamedList<>();
-    nl.addAll(jsonObject);
-    return SolrParams.toSolrParams(nl);
+    /**
+     * Helper that handles the possibility of map values being lists
+     * NOTE: does *NOT* fail on map values that are sub-maps (ie: nested json objects)
+     */
+    public static SolrParams jsonToSolrParams(Map jsonObject) {
+      // HACK, but NamedList already handles the list processing for us...
+      NamedList<String> nl = new NamedList<>();
+      nl.addAll(jsonObject);
+      return SolrParams.toSolrParams(nl);
+    }
   }
-}
 
+  static class FacetTopParser extends FacetParser<FacetQuery> {
+    private SolrQueryRequest req;
 
-class FacetTopParser extends FacetParser<FacetQuery> {
-  private SolrQueryRequest req;
+    public FacetTopParser(SolrQueryRequest req) {
+      super(null, "facet");
+      this.facet = new FacetQuery();
+      this.req = req;
+    }
 
-  public FacetTopParser(SolrQueryRequest req) {
-    super(null, "facet");
-    this.facet = new FacetQuery();
-    this.req = req;
-  }
+    @Override
+    public FacetQuery parse(Object args) throws SyntaxError {
+      parseSubs(args);
+      return facet;
+    }
 
-  @Override
-  public FacetQuery parse(Object args) throws SyntaxError {
-    parseSubs(args);
-    return facet;
-  }
+    @Override
+    public SolrQueryRequest getSolrRequest() {
+      return req;
+    }
 
-  @Override
-  public SolrQueryRequest getSolrRequest() {
-    return req;
+    @Override
+    public IndexSchema getSchema() {
+      return req.getSchema();
+    }
   }
 
-  @Override
-  public IndexSchema getSchema() {
-    return req.getSchema();
-  }
-}
+  static class FacetQueryParser extends FacetParser<FacetQuery> {
+    public FacetQueryParser(FacetParser parent, String key) {
+      super(parent, key);
+      facet = new FacetQuery();
+    }
 
-class FacetQueryParser extends FacetParser<FacetQuery> {
-  public FacetQueryParser(FacetParser parent, String key) {
-    super(parent, key);
-    facet = new FacetQuery();
-  }
+    @Override
+    public FacetQuery parse(Object arg) throws SyntaxError {
+      parseCommonParams(arg);
 
-  @Override
-  public FacetQuery parse(Object arg) throws SyntaxError {
-    parseCommonParams(arg);
+      String qstring = null;
+      if (arg instanceof String) {
+        // just the field name...
+        qstring = (String)arg;
 
-    String qstring = null;
-    if (arg instanceof String) {
-      // just the field name...
-      qstring = (String)arg;
+      } else if (arg instanceof Map) {
+        Map<String, Object> m = (Map<String, Object>) arg;
+        qstring = getString(m, "q", null);
+        if (qstring == null) {
+          qstring = getString(m, "query", null);
+        }
 
-    } else if (arg instanceof Map) {
-      Map<String, Object> m = (Map<String, Object>) arg;
-      qstring = getString(m, "q", null);
-      if (qstring == null) {
-        qstring = getString(m, "query", null);
+        // OK to parse subs before we have parsed our own query?
+        // as long as subs don't need to know about it.
+        parseSubs( m.get("facet") );
+      } else if (arg != null) {
+        // something lke json.facet.facet.query=2
+        throw err("Expected string/map for facet query, received " + arg.getClass().getSimpleName() + "=" + arg);
       }
 
-      // OK to parse subs before we have parsed our own query?
-      // as long as subs don't need to know about it.
-      parseSubs( m.get("facet") );
-    } else if (arg != null) {
-      // something lke json.facet.facet.query=2
-      throw err("Expected string/map for facet query, received " + arg.getClass().getSimpleName() + "=" + arg);
-    }
+      // TODO: substats that are from defaults!!!
 
-    // TODO: substats that are from defaults!!!
+      if (qstring != null) {
+        QParser parser = QParser.getParser(qstring, getSolrRequest());
+        parser.setIsFilter(true);
+        facet.q = parser.getQuery();
+      }
 
-    if (qstring != null) {
-      QParser parser = QParser.getParser(qstring, getSolrRequest());
-      parser.setIsFilter(true);
-      facet.q = parser.getQuery();
+      return facet;
     }
-
-    return facet;
   }
-}
 
 /*** not a separate type of parser for now...
-class FacetBlockParentParser extends FacetParser<FacetBlockParent> {
-  public FacetBlockParentParser(FacetParser parent, String key) {
-    super(parent, key);
-    facet = new FacetBlockParent();
-  }
-
-  @Override
-  public FacetBlockParent parse(Object arg) throws SyntaxError {
-    parseCommonParams(arg);
-
-    if (arg instanceof String) {
-      // just the field name...
-      facet.parents = (String)arg;
-
-    } else if (arg instanceof Map) {
-      Map<String, Object> m = (Map<String, Object>) arg;
-      facet.parents = getString(m, "parents", null);
-
-      parseSubs( m.get("facet") );
+static class FacetBlockParentParser extends FacetParser<FacetBlockParent> {
+ public FacetBlockParentParser(FacetParser parent, String key) {
+ super(parent, key);
+ facet = new FacetBlockParent();
+ }
+
+ @Override
+ public FacetBlockParent parse(Object arg) throws SyntaxError {
+ parseCommonParams(arg);
+
+ if (arg instanceof String) {
+ // just the field name...
+ facet.parents = (String)arg;
+
+ } else if (arg instanceof Map) {
+ Map<String, Object> m = (Map<String, Object>) arg;
+ facet.parents = getString(m, "parents", null);
+
+ parseSubs( m.get("facet") );
+ }
+
+ return facet;
+ }
+ }
+ ***/
+
+  static class FacetFieldParser extends FacetParser<FacetField> {
+    public FacetFieldParser(FacetParser parent, String key) {
+      super(parent, key);
+      facet = new FacetField();
     }
 
-    return facet;
-  }
-}
-***/
-
-
-class FacetFieldParser extends FacetParser<FacetField> {
-  public FacetFieldParser(FacetParser parent, String key) {
-    super(parent, key);
-    facet = new FacetField();
-  }
+    public FacetField parse(Object arg) throws SyntaxError {
+      parseCommonParams(arg);
+      if (arg instanceof String) {
+        // just the field name...
+        facet.field = (String)arg;
+
+      } else if (arg instanceof Map) {
+        Map<String, Object> m = (Map<String, Object>) arg;
+        facet.field = getField(m);
+        facet.offset = getLong(m, "offset", facet.offset);
+        facet.limit = getLong(m, "limit", facet.limit);
+        facet.overrequest = (int) getLong(m, "overrequest", facet.overrequest);
+        facet.overrefine = (int) getLong(m, "overrefine", facet.overrefine);
+        if (facet.limit == 0) facet.offset = 0;  // normalize.  an offset with a limit of non-zero isn't useful.
+        facet.mincount = getLong(m, "mincount", facet.mincount);
+        facet.missing = getBoolean(m, "missing", facet.missing);
+        facet.numBuckets = getBoolean(m, "numBuckets", facet.numBuckets);
+        facet.prefix = getString(m, "prefix", facet.prefix);
+        facet.allBuckets = getBoolean(m, "allBuckets", facet.allBuckets);
+        facet.method = FacetField.FacetMethod.fromString(getString(m, "method", null));
+        facet.cacheDf = (int)getLong(m, "cacheDf", facet.cacheDf);
+
+        // TODO: pull up to higher level?
+        facet.refine = RefineMethod.fromObj(m.get("refine"));
+
+        facet.perSeg = getBooleanOrNull(m, "perSeg");
+
+        // facet.sort may depend on a facet stat...
+        // should we be parsing / validating this here, or in the execution environment?
+        Object o = m.get("facet");
+        parseSubs(o);
+
+        facet.sort = parseAndValidateSort(facet, m, SORT);
+        facet.prelim_sort = parseAndValidateSort(facet, m, "prelim_sort");
+      } else if (arg != null) {
+        // something like json.facet.facet.field=2
+        throw err("Expected string/map for facet field, received " + arg.getClass().getSimpleName() + "=" + arg);
+      }
 
-  public FacetField parse(Object arg) throws SyntaxError {
-    parseCommonParams(arg);
-    if (arg instanceof String) {
-      // just the field name...
-      facet.field = (String)arg;
-      
-    } else if (arg instanceof Map) {
-      Map<String, Object> m = (Map<String, Object>) arg;
-      facet.field = getField(m);
-      facet.offset = getLong(m, "offset", facet.offset);
-      facet.limit = getLong(m, "limit", facet.limit);
-      facet.overrequest = (int) getLong(m, "overrequest", facet.overrequest);
-      facet.overrefine = (int) getLong(m, "overrefine", facet.overrefine);
-      if (facet.limit == 0) facet.offset = 0;  // normalize.  an offset with a limit of non-zero isn't useful.
-      facet.mincount = getLong(m, "mincount", facet.mincount);
-      facet.missing = getBoolean(m, "missing", facet.missing);
-      facet.numBuckets = getBoolean(m, "numBuckets", facet.numBuckets);
-      facet.prefix = getString(m, "prefix", facet.prefix);
-      facet.allBuckets = getBoolean(m, "allBuckets", facet.allBuckets);
-      facet.method = FacetField.FacetMethod.fromString(getString(m, "method", null));
-      facet.cacheDf = (int)getLong(m, "cacheDf", facet.cacheDf);
-
-      // TODO: pull up to higher level?
-      facet.refine = FacetField.RefineMethod.fromObj(m.get("refine"));
-
-      facet.perSeg = getBooleanOrNull(m, "perSeg");
-
-      // facet.sort may depend on a facet stat...
-      // should we be parsing / validating this here, or in the execution environment?
-      Object o = m.get("facet");
-      parseSubs(o);
-
-      facet.sort = parseAndValidateSort(facet, m, SORT);
-      facet.prelim_sort = parseAndValidateSort(facet, m, "prelim_sort");
-    } else if (arg != null) {
-      // something like json.facet.facet.field=2
-      throw err("Expected string/map for facet field, received " + arg.getClass().getSimpleName() + "=" + arg);
-    }
+      if (null == facet.sort) {
+        facet.sort = FacetSort.COUNT_DESC;
+      }
 
-    if (null == facet.sort) {
-      facet.sort = FacetRequest.FacetSort.COUNT_DESC;
+      return facet;
     }
 
-    return facet;
-  }
-
-  /**
-   * Parses, validates and returns the {@link FacetRequest.FacetSort} for given sortParam
-   * and facet field
-   * <p>
-   *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}
-   *   index - This is equivalent to 'index asc'
-   *   count - This is equivalent to 'count desc'
-   * </p>
-   *
-   * @param facet {@link FacetField} for which sort needs to be parsed and validated
-   * @param args map containing the sortVal for given sortParam
-   * @param sortParam parameter for which sort needs to parsed and validated
-   * @return parsed facet sort
-   */
-  private static FacetRequest.FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {
-    Object sort = args.get(sortParam);
-    if (sort == null) {
-      return null;
-    }
+    /**
+     * Parses, validates and returns the {@link FacetSort} for given sortParam
+     * and facet field
+     * <p>
+     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}
+     *   index - This is equivalent to 'index asc'
+     *   count - This is equivalent to 'count desc'
+     * </p>
+     *
+     * @param facet {@link FacetField} for which sort needs to be parsed and validated
+     * @param args map containing the sortVal for given sortParam
+     * @param sortParam parameter for which sort needs to parsed and validated
+     * @return parsed facet sort
+     */
+    private static FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {
+      Object sort = args.get(sortParam);
+      if (sort == null) {
+        return null;
+      }
 
-    FacetRequest.FacetSort facetSort = null;
+      FacetSort facetSort = null;
 
-    if (sort instanceof String) {
-      String sortStr = (String)sort;
-      if (sortStr.endsWith(" asc")) {
-        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-" asc".length()),
-            FacetRequest.SortDirection.asc);
-      } else if (sortStr.endsWith(" desc")) {
-        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-" desc".length()),
-            FacetRequest.SortDirection.desc);
+      if (sort instanceof String) {
+        String sortStr = (String)sort;
+        if (sortStr.endsWith(" asc")) {
+          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-" asc".length()),
+              SortDirection.asc);
+        } else if (sortStr.endsWith(" desc")) {
+          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-" desc".length()),
+              SortDirection.desc);
+        } else {
+          facetSort =  new FacetSort(sortStr,
+              // default direction for "index" is ascending
+              ("index".equals(sortStr)
+                  ? SortDirection.asc
+                  : SortDirection.desc));
+        }
+      } else if (sort instanceof Map) {
+        // { myvar : 'desc' }
+        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();
+        if (optional.isPresent()) {
+          Map.Entry<String, Object> entry = optional.get();
+          facetSort = new FacetSort(entry.getKey(), SortDirection.fromObj(entry.getValue()));
+        }
       } else {
-        facetSort =  new FacetRequest.FacetSort(sortStr,
-            // default direction for "index" is ascending
-            ("index".equals(sortStr)
-                ? FacetRequest.SortDirection.asc
-                : FacetRequest.SortDirection.desc));
-      }
-    } else if (sort instanceof Map) {
-      // { myvar : 'desc' }
-      Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();
-      if (optional.isPresent()) {
-        Map.Entry<String, Object> entry = optional.get();
-        facetSort = new FacetRequest.FacetSort(entry.getKey(), FacetRequest.SortDirection.fromObj(entry.getValue()));
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+            "Expected string/map for '" + sortParam +"', received "+ sort.getClass().getSimpleName() + "=" + sort);
       }
-    } else {
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
-          "Expected string/map for '" + sortParam +"', received "+ sort.getClass().getSimpleName() + "=" + sort);
-    }
 
-    Map<String, AggValueSource> facetStats = facet.facetStats;
-    // validate facet sort
-    boolean isValidSort = facetSort == null ||
-        "index".equals(facetSort.sortVariable) ||
-        "count".equals(facetSort.sortVariable) ||
-        (facetStats != null && facetStats.containsKey(facetSort.sortVariable));
+      Map<String, AggValueSource> facetStats = facet.facetStats;
+      // validate facet sort
+      boolean isValidSort = facetSort == null ||
+          "index".equals(facetSort.sortVariable) ||
+          "count".equals(facetSort.sortVariable) ||
+          (facetStats != null && facetStats.containsKey(facetSort.sortVariable));
 
-    if (!isValidSort) {
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
-          "Invalid " + sortParam + " option '" + sort + "' for field '" + facet.field + "'");
+      if (!isValidSort) {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+            "Invalid " + sortParam + " option '" + sort + "' for field '" + facet.field + "'");
+      }
+      return facetSort;
     }
-    return facetSort;
-  }
 
-}
+  }
 
+  static class FacetRangeParser extends FacetParser<FacetRange> {
+    public FacetRangeParser(FacetParser parent, String key) {
+      super(parent, key);
+      facet = new FacetRange();
+    }
 
+    public FacetRange parse(Object arg) throws SyntaxError {
+      parseCommonParams(arg);
 
-class FacetRangeParser extends FacetParser<FacetRange> {
-  public FacetRangeParser(FacetParser parent, String key) {
-    super(parent, key);
-    facet = new FacetRange();
-  }
+      if (!(arg instanceof Map)) {
+        throw err("Missing range facet arguments");
+      }
 
-  public FacetRange parse(Object arg) throws SyntaxError {
-    parseCommonParams(arg);
+      Map<String, Object> m = (Map<String, Object>) arg;
 
-    if (!(arg instanceof Map)) {
-      throw err("Missing range facet arguments");
-    }
+      facet.field = getString(m, "field", null);
+      facet.ranges = getVal(m, "ranges", false);
 
-    Map<String, Object> m = (Map<String, Object>) arg;
+      boolean required = facet.ranges == null;
+      facet.start = getVal(m, "start", required);
+      facet.end = getVal(m, "end", required);
+      facet.gap = getVal(m, "gap", required);
+      facet.hardend = getBoolean(m, "hardend", facet.hardend);
+      facet.mincount = getLong(m, "mincount", 0);
 
-    facet.field = getString(m, "field", null);
-    facet.ranges = getVal(m, "ranges", false);
+      // TODO: refactor list-of-options code
 
-    boolean required = facet.ranges == null;
-    facet.start = getVal(m, "start", required);
-    facet.end = getVal(m, "end", required);
-    facet.gap = getVal(m, "gap", required);
-    facet.hardend = getBoolean(m, "hardend", facet.hardend);
-    facet.mincount = getLong(m, "mincount", 0);
+      List<String> list = getStringList(m, "include", false);
+      String[] includeList = null;
+      if (list != null) {
+        includeList = list.toArray(new String[list.size()]);
+      }
+      facet.include = FacetParams.FacetRangeInclude.parseParam( includeList );
+      facet.others = EnumSet.noneOf(FacetParams.FacetRangeOther.class);
 
-    // TODO: refactor list-of-options code
+      List<String> other = getStringList(m, "other", false);
+      if (other != null) {
+        for (String otherStr : other) {
+          facet.others.add( FacetParams.FacetRangeOther.get(otherStr) );
+        }
+      }
 
-    List<String> list = getStringList(m, "include", false);
-    String[] includeList = null;
-    if (list != null) {
-      includeList = list.toArray(new String[list.size()]);
-    }
-    facet.include = FacetParams.FacetRangeInclude.parseParam( includeList );
-    facet.others = EnumSet.noneOf(FacetParams.FacetRangeOther.class);
+      Object facetObj = m.get("facet");
+      parseSubs(facetObj);
 
-    List<String> other = getStringList(m, "other", false);
-    if (other != null) {
-      for (String otherStr : other) {
-        facet.others.add( FacetParams.FacetRangeOther.get(otherStr) );
-      }
+      return facet;
     }
 
-    Object facetObj = m.get("facet");
-    parseSubs(facetObj);
-
-    return facet;
   }
-
 }
 
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/HLLAgg.java b/solr/core/src/java/org/apache/solr/search/facet/HLLAgg.java
index ff7b2a2a78f..222d4a34de4 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/HLLAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/HLLAgg.java
@@ -50,7 +50,7 @@ public class HLLAgg extends StrAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     SchemaField sf = fcontext.qcontext.searcher().getSchema().getField(getArg());
     if (sf.multiValued() || sf.getType().multiValuedFieldCache()) {
       if (sf.getType().isPointField()) {
@@ -121,7 +121,7 @@ public class HLLAgg extends StrAggValueSource {
   abstract class BaseNumericAcc extends DocValuesAcc {
     HLL[] sets;
 
-    public BaseNumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public BaseNumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, fcontext.qcontext.searcher().getSchema().getField(field));
       sets = new HLL[numSlots];
     }
@@ -179,7 +179,7 @@ public class HLLAgg extends StrAggValueSource {
   class NumericAcc extends BaseNumericAcc {
     NumericDocValues values;
 
-    public NumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public NumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, field, numSlots);
     }
 
@@ -205,7 +205,7 @@ public class HLLAgg extends StrAggValueSource {
   class SortedNumericAcc extends BaseNumericAcc {
     SortedNumericDocValues values;
 
-    public SortedNumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public SortedNumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, field, numSlots);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/MinMaxAgg.java b/solr/core/src/java/org/apache/solr/search/facet/MinMaxAgg.java
index d036ee1c362..0ff3ea746c2 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/MinMaxAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/MinMaxAgg.java
@@ -46,7 +46,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     SchemaField sf = null;
@@ -164,7 +164,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
     private int currentSlot;
     int[] result;
 
-    public MinMaxUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public MinMaxUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
       result = new int[numSlots];
       Arrays.fill(result, MISSING);
@@ -234,7 +234,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
   }
 
   class DFuncAcc extends DoubleFuncSlotAcc {
-    public DFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public DFuncAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots, Double.NaN);
     }
 
@@ -262,7 +262,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
 
   class LFuncAcc extends LongFuncSlotAcc {
     FixedBitSet exists;
-    public LFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public LFuncAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots, 0);
       exists = new FixedBitSet(numSlots);
     }
@@ -322,7 +322,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
 
   class DateFuncAcc extends LongFuncSlotAcc {
     private static final long MISSING = Long.MIN_VALUE;
-    public DateFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public DateFuncAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots, MISSING);
     }
 
@@ -351,7 +351,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
     SchemaField field;
     int[] slotOrd;
 
-    public OrdAcc(FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
+    public OrdAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
       super(fcontext);
       this.field = field;
       slotOrd = new int[numSlots];
@@ -394,7 +394,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
     LongValues toGlobal;
     SortedDocValues subDv;
 
-    public SingleValuedOrdAcc(FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
+    public SingleValuedOrdAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
       super(fcontext, field, numSlots);
     }
 
@@ -450,7 +450,7 @@ public class MinMaxAgg extends SimpleAggValueSource {
     SortedSetDocValues subDv;
     long[] slotOrd;
 
-    public MinMaxSortedSetDVAcc(FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
+    public MinMaxSortedSetDVAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots) throws IOException {
       super(fcontext, field);
       this.slotOrd = new long[numSlots];
       Arrays.fill(slotOrd, MISSING);
diff --git a/solr/core/src/java/org/apache/solr/search/facet/MissingAgg.java b/solr/core/src/java/org/apache/solr/search/facet/MissingAgg.java
index 4ff980f0ea9..55e4d69619d 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/MissingAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/MissingAgg.java
@@ -37,7 +37,7 @@ public class MissingAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -66,7 +66,7 @@ public class MissingAgg extends SimpleAggValueSource {
 
   class MissingSlotAcc extends LongFuncSlotAcc {
 
-    public MissingSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public MissingSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots, 0);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/PercentileAgg.java b/solr/core/src/java/org/apache/solr/search/facet/PercentileAgg.java
index 956b179b2dd..3f855b144ae 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/PercentileAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/PercentileAgg.java
@@ -49,7 +49,7 @@ public class PercentileAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -137,7 +137,7 @@ public class PercentileAgg extends SimpleAggValueSource {
     protected ByteBuffer buf;
     protected double[] sortvals;
 
-    public Acc(ValueSource values, FacetContext fcontext, int numSlots) {
+    public Acc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
       super(values, fcontext, numSlots);
       digests = new AVLTreeDigest[numSlots];
     }
@@ -220,7 +220,7 @@ public class PercentileAgg extends SimpleAggValueSource {
     protected ByteBuffer buf;
     double[] sortvals;
 
-    public BasePercentileDVAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public BasePercentileDVAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf);
       digests = new AVLTreeDigest[numSlots];
     }
@@ -289,7 +289,7 @@ public class PercentileAgg extends SimpleAggValueSource {
   class PercentileSortedNumericAcc extends BasePercentileDVAcc {
     SortedNumericDocValues values;
 
-    public PercentileSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public PercentileSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -339,7 +339,7 @@ public class PercentileAgg extends SimpleAggValueSource {
   class PercentileSortedSetAcc extends BasePercentileDVAcc {
     SortedSetDocValues values;
 
-    public PercentileSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public PercentileSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -376,7 +376,7 @@ public class PercentileAgg extends SimpleAggValueSource {
     protected double[] sortvals;
     private int currentSlot;
 
-    public PercentileUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public PercentileUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
       digests = new AVLTreeDigest[numSlots];
     }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.java b/solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.java
index 81d0f3b9e82..c8153a9cd3e 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.java
@@ -122,7 +122,7 @@ public class RelatednessAgg extends AggValueSource {
   }
 
 
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     // TODO: Ideally this is where we should check fgQ/bgQ for 'null' and apply defaults...
     //
     // we want to walk up the fcontext and inherit the queries from any ancestor SKGAgg
@@ -135,7 +135,7 @@ public class RelatednessAgg extends AggValueSource {
     
     List<Query> fgFilters = new ArrayList<Query>(3);
     fgFilters.add(fgQ);
-    for (FacetContext ctx = fcontext; ctx != null; ctx = ctx.parent) {
+    for (FacetRequest.FacetContext ctx = fcontext; ctx != null; ctx = ctx.parent) {
       if (null != ctx.filter) {
         fgFilters.add(ctx.filter);
       } else {
@@ -170,7 +170,7 @@ public class RelatednessAgg extends AggValueSource {
     private final DocSet bgSet;
     private final long fgSize;
     private final long bgSize;
-    public SKGSlotAcc(final RelatednessAgg agg, final FacetContext fcontext, final int numSlots,
+    public SKGSlotAcc(final RelatednessAgg agg, final FacetRequest.FacetContext fcontext, final int numSlots,
                       final DocSet fgSet, final DocSet bgSet) throws IOException {
       super(fcontext);
       this.agg = agg;
diff --git a/solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java b/solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java
index 99387bebe36..a241a6657ae 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java
@@ -44,11 +44,11 @@ import org.apache.solr.search.SolrIndexSearcher;
  */
 public abstract class SlotAcc implements Closeable {
   String key; // todo...
-  protected final FacetContext fcontext;
+  protected final FacetRequest.FacetContext fcontext;
   protected LeafReaderContext currentReaderContext;
   protected int currentDocBase;
 
-  public SlotAcc(FacetContext fcontext) {
+  public SlotAcc(FacetRequest.FacetContext fcontext) {
     this.fcontext = fcontext;
   }
 
@@ -257,7 +257,7 @@ abstract class FuncSlotAcc extends SlotAcc {
   protected final ValueSource valueSource;
   protected FunctionValues values;
 
-  public FuncSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public FuncSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(fcontext);
     this.valueSource = values;
   }
@@ -279,11 +279,11 @@ abstract class DoubleFuncSlotAcc extends FuncSlotAcc {
   double[] result; // TODO: use DoubleArray
   double initialValue;
 
-  public DoubleFuncSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public DoubleFuncSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     this(values, fcontext, numSlots, 0);
   }
 
-  public DoubleFuncSlotAcc(ValueSource values, FacetContext fcontext, int numSlots, double initialValue) {
+  public DoubleFuncSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots, double initialValue) {
     super(values, fcontext, numSlots);
     this.initialValue = initialValue;
     result = new double[numSlots];
@@ -317,7 +317,7 @@ abstract class LongFuncSlotAcc extends FuncSlotAcc {
   long[] result;
   long initialValue;
 
-  public LongFuncSlotAcc(ValueSource values, FacetContext fcontext, int numSlots, long initialValue) {
+  public LongFuncSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots, long initialValue) {
     super(values, fcontext, numSlots);
     this.initialValue = initialValue;
     result = new long[numSlots];
@@ -351,7 +351,7 @@ abstract class IntSlotAcc extends SlotAcc {
   int[] result; // use LongArray32
   int initialValue;
 
-  public IntSlotAcc(FacetContext fcontext, int numSlots, int initialValue) {
+  public IntSlotAcc(FacetRequest.FacetContext fcontext, int numSlots, int initialValue) {
     super(fcontext);
     this.initialValue = initialValue;
     result = new int[numSlots];
@@ -382,7 +382,7 @@ abstract class IntSlotAcc extends SlotAcc {
 }
 
 class SumSlotAcc extends DoubleFuncSlotAcc {
-  public SumSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public SumSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(values, fcontext, numSlots);
   }
 
@@ -393,7 +393,7 @@ class SumSlotAcc extends DoubleFuncSlotAcc {
 }
 
 class SumsqSlotAcc extends DoubleFuncSlotAcc {
-  public SumsqSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public SumsqSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(values, fcontext, numSlots);
   }
 
@@ -409,7 +409,7 @@ class SumsqSlotAcc extends DoubleFuncSlotAcc {
 class AvgSlotAcc extends DoubleFuncSlotAcc {
   int[] counts;
 
-  public AvgSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public AvgSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(values, fcontext, numSlots);
     counts = new int[numSlots];
   }
@@ -463,7 +463,7 @@ class VarianceSlotAcc extends DoubleFuncSlotAcc {
   int[] counts;
   double[] sum;
 
-  public VarianceSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public VarianceSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(values, fcontext, numSlots);
     counts = new int[numSlots];
     sum = new double[numSlots];
@@ -520,7 +520,7 @@ class StddevSlotAcc extends DoubleFuncSlotAcc {
   int[] counts;
   double[] sum;
 
-  public StddevSlotAcc(ValueSource values, FacetContext fcontext, int numSlots) {
+  public StddevSlotAcc(ValueSource values, FacetRequest.FacetContext fcontext, int numSlots) {
     super(values, fcontext, numSlots);
     counts = new int[numSlots];
     sum = new double[numSlots];
@@ -574,7 +574,7 @@ class StddevSlotAcc extends DoubleFuncSlotAcc {
 }
 
 abstract class CountSlotAcc extends SlotAcc {
-  public CountSlotAcc(FacetContext fcontext) {
+  public CountSlotAcc(FacetRequest.FacetContext fcontext) {
     super(fcontext);
   }
 
@@ -586,7 +586,7 @@ abstract class CountSlotAcc extends SlotAcc {
 class CountSlotArrAcc extends CountSlotAcc {
   long[] result;
 
-  public CountSlotArrAcc(FacetContext fcontext, int numSlots) {
+  public CountSlotArrAcc(FacetRequest.FacetContext fcontext, int numSlots) {
     super(fcontext);
     result = new long[numSlots];
   }
@@ -635,7 +635,7 @@ class CountSlotArrAcc extends CountSlotAcc {
 }
 
 class SortSlotAcc extends SlotAcc {
-  public SortSlotAcc(FacetContext fcontext) {
+  public SortSlotAcc(FacetRequest.FacetContext fcontext) {
     super(fcontext);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/StddevAgg.java b/solr/core/src/java/org/apache/solr/search/facet/StddevAgg.java
index d0fb90be588..4f9c9b8007d 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/StddevAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/StddevAgg.java
@@ -32,7 +32,7 @@ public class StddevAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -92,7 +92,7 @@ public class StddevAgg extends SimpleAggValueSource {
 
   class StddevSortedNumericAcc extends SDVSortedNumericAcc {
 
-    public StddevSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public StddevSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -104,7 +104,7 @@ public class StddevAgg extends SimpleAggValueSource {
 
   class StddevSortedSetAcc extends SDVSortedSetAcc {
 
-    public StddevSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public StddevSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -116,7 +116,7 @@ public class StddevAgg extends SimpleAggValueSource {
 
   class StddevUnInvertedFieldAcc extends SDVUnInvertedFieldAcc {
 
-    public StddevUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public StddevUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/SumAgg.java b/solr/core/src/java/org/apache/solr/search/facet/SumAgg.java
index 5fe5aed70f6..065faf6b967 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/SumAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/SumAgg.java
@@ -34,7 +34,7 @@ public class SumAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -82,7 +82,7 @@ public class SumAgg extends SimpleAggValueSource {
 
   class SumSortedNumericAcc extends DoubleSortedNumericDVAcc {
 
-    public SumSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -97,7 +97,7 @@ public class SumAgg extends SimpleAggValueSource {
 
   class SumSortedSetAcc extends DoubleSortedSetDVAcc {
 
-    public SumSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -115,7 +115,7 @@ public class SumAgg extends SimpleAggValueSource {
 
   class SumUnInvertedFieldAcc extends DoubleUnInvertedFieldAcc {
 
-    public SumUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/SumsqAgg.java b/solr/core/src/java/org/apache/solr/search/facet/SumsqAgg.java
index 4bb9e67d7ca..d8921797e7d 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/SumsqAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/SumsqAgg.java
@@ -33,7 +33,7 @@ public class SumsqAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -68,7 +68,7 @@ public class SumsqAgg extends SimpleAggValueSource {
 
   class SumSqSortedNumericAcc extends DoubleSortedNumericDVAcc {
 
-    public SumSqSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumSqSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -83,7 +83,7 @@ public class SumsqAgg extends SimpleAggValueSource {
 
   class SumSqSortedSetAcc extends DoubleSortedSetDVAcc {
 
-    public SumSqSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumSqSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
@@ -101,7 +101,7 @@ public class SumsqAgg extends SimpleAggValueSource {
 
   class SumSqUnInvertedFieldAcc extends DoubleUnInvertedFieldAcc {
 
-    public SumSqUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public SumSqUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots, 0);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UnInvertedFieldAcc.java b/solr/core/src/java/org/apache/solr/search/facet/UnInvertedFieldAcc.java
index 7f2d9eb56da..8fab3419725 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UnInvertedFieldAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UnInvertedFieldAcc.java
@@ -36,7 +36,7 @@ public abstract class UnInvertedFieldAcc extends SlotAcc implements UnInvertedFi
   UnInvertedField.DocToTerm docToTerm;
   SchemaField sf;
 
-  public UnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public UnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext);
     this.sf = sf;
     uif = UnInvertedField.getUnInvertedField(sf.getName(), fcontext.qcontext.searcher());
@@ -58,7 +58,7 @@ abstract class DoubleUnInvertedFieldAcc extends UnInvertedFieldAcc {
   int currentSlot;
   double initialValue;
 
-  public DoubleUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots, double initialValue) throws IOException {
+  public DoubleUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots, double initialValue) throws IOException {
     super(fcontext, sf, numSlots);
     result = new double[numSlots];
     if (initialValue != 0) {
@@ -102,7 +102,7 @@ abstract class SDVUnInvertedFieldAcc extends DoubleUnInvertedFieldAcc {
   int[] counts;
   double[] sum;
 
-  public SDVUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+  public SDVUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
     super(fcontext, sf, numSlots, 0);
     this.counts = new int[numSlots];
     this.sum = new double[numSlots];
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueAgg.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueAgg.java
index 240c1a7eb11..c6c520c6b07 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueAgg.java
@@ -42,7 +42,7 @@ public class UniqueAgg extends StrAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     SchemaField sf = fcontext.qcontext.searcher().getSchema().getField(getArg());
     if (sf.multiValued() || sf.getType().multiValuedFieldCache()) {
       if (sf.getType().isPointField()) {
@@ -126,7 +126,7 @@ public class UniqueAgg extends StrAggValueSource {
   static abstract class BaseNumericAcc extends DocValuesAcc {
     LongSet[] sets;
 
-    public BaseNumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public BaseNumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, fcontext.qcontext.searcher().getSchema().getField(field));
       sets = new LongSet[numSlots];
     }
@@ -212,7 +212,7 @@ public class UniqueAgg extends StrAggValueSource {
   static class NumericAcc extends BaseNumericAcc {
     NumericDocValues values;
 
-    public NumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public NumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, field, numSlots);
     }
 
@@ -235,7 +235,7 @@ public class UniqueAgg extends StrAggValueSource {
   static class SortedNumericAcc extends BaseNumericAcc {
     SortedNumericDocValues values;
 
-    public SortedNumericAcc(FacetContext fcontext, String field, int numSlots) throws IOException {
+    public SortedNumericAcc(FacetRequest.FacetContext fcontext, String field, int numSlots) throws IOException {
       super(fcontext, field, numSlots);
     }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockAgg.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockAgg.java
index 8d5a0c3fc9f..860cf28b01e 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockAgg.java
@@ -27,7 +27,7 @@ public abstract class UniqueBlockAgg extends UniqueAgg {
 
     protected int[] lastSeenValuesPerSlot;
 
-    protected UniqueBlockSlotAcc(FacetContext fcontext, SchemaField field, int numSlots)
+    protected UniqueBlockSlotAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots)
         throws IOException { //
       super(fcontext, field, /*numSlots suppressing inherited accumulator */0, null);
       counts = new int[numSlots];
@@ -79,7 +79,7 @@ public abstract class UniqueBlockAgg extends UniqueAgg {
   }
 
   @Override
-  public abstract SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException ;
+  public abstract SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException ;
   
   @Override
   public FacetMerger createFacetMerger(Object prototype) {
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockFieldAgg.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockFieldAgg.java
index fddb32d081c..de4476aee64 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockFieldAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockFieldAgg.java
@@ -27,7 +27,7 @@ public class UniqueBlockFieldAgg extends UniqueBlockAgg {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     final String fieldName = getArg();
     SchemaField sf = fcontext.qcontext.searcher().getSchema().getField(fieldName);
     if (sf.multiValued() || sf.getType().multiValuedFieldCache()) {
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockQueryAgg.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockQueryAgg.java
index 885725dfc00..e6350128f89 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockQueryAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueBlockQueryAgg.java
@@ -34,7 +34,7 @@ public class UniqueBlockQueryAgg extends UniqueBlockAgg {
     private Query query;
     private BitSet parentBitSet;
 
-    private UniqueBlockQuerySlotAcc(FacetContext fcontext, Query query, int numSlots)
+    private UniqueBlockQuerySlotAcc(FacetRequest.FacetContext fcontext, Query query, int numSlots)
         throws IOException { //
       super(fcontext, null, numSlots);
       this.query = query;
@@ -65,7 +65,7 @@ public class UniqueBlockQueryAgg extends UniqueBlockAgg {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     return new UniqueBlockQuerySlotAcc(fcontext, query, numSlots);
   }
 }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueMultiDvSlotAcc.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueMultiDvSlotAcc.java
index 839fc520a17..9596fbbc330 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueMultiDvSlotAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueMultiDvSlotAcc.java
@@ -36,7 +36,7 @@ class UniqueMultiDvSlotAcc extends UniqueSlotAcc {
   LongValues toGlobal;
   SortedSetDocValues subDv;
 
-  public UniqueMultiDvSlotAcc(FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
+  public UniqueMultiDvSlotAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
     super(fcontext, field, numSlots, factory);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueMultivaluedSlotAcc.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueMultivaluedSlotAcc.java
index 508da384045..a993248090d 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueMultivaluedSlotAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueMultivaluedSlotAcc.java
@@ -29,7 +29,7 @@ class UniqueMultivaluedSlotAcc extends UniqueSlotAcc implements UnInvertedField.
   private UnInvertedField uif;
   private UnInvertedField.DocToTerm docToTerm;
 
-  public UniqueMultivaluedSlotAcc(FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
+  public UniqueMultivaluedSlotAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
     super(fcontext, field, numSlots, factory);
     SolrIndexSearcher searcher = fcontext.qcontext.searcher();
     uif = UnInvertedField.getUnInvertedField(field.getName(), searcher);
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueSinglevaluedSlotAcc.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueSinglevaluedSlotAcc.java
index 6057dd00986..adbc29a76e4 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueSinglevaluedSlotAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueSinglevaluedSlotAcc.java
@@ -36,7 +36,7 @@ class UniqueSinglevaluedSlotAcc extends UniqueSlotAcc {
   LongValues toGlobal;
   SortedDocValues subDv;
 
-  public UniqueSinglevaluedSlotAcc(FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
+  public UniqueSinglevaluedSlotAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
     super(fcontext, field, numSlots, factory);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc.java b/solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc.java
index 29873125d96..0ef10ed2348 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc.java
@@ -35,7 +35,7 @@ abstract class UniqueSlotAcc extends SlotAcc {
   int[] counts;  // populated with the cardinality once
   int nTerms;
 
-  public UniqueSlotAcc(FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
+  public UniqueSlotAcc(FacetRequest.FacetContext fcontext, SchemaField field, int numSlots, HLLAgg.HLLFactory factory) throws IOException {
     super(fcontext);
     this.factory = factory;
     arr = new FixedBitSet[numSlots];
diff --git a/solr/core/src/java/org/apache/solr/search/facet/VarianceAgg.java b/solr/core/src/java/org/apache/solr/search/facet/VarianceAgg.java
index 892f5c5f3fd..e815c40cdda 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/VarianceAgg.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/VarianceAgg.java
@@ -31,7 +31,7 @@ public class VarianceAgg extends SimpleAggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     ValueSource vs = getArg();
 
     if (vs instanceof FieldNameValueSource) {
@@ -91,7 +91,7 @@ public class VarianceAgg extends SimpleAggValueSource {
 
   class VarianceSortedNumericAcc extends SDVSortedNumericAcc {
 
-    public VarianceSortedNumericAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public VarianceSortedNumericAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -103,7 +103,7 @@ public class VarianceAgg extends SimpleAggValueSource {
 
   class VarianceSortedSetAcc extends SDVSortedSetAcc {
 
-    public VarianceSortedSetAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public VarianceSortedSetAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
@@ -115,7 +115,7 @@ public class VarianceAgg extends SimpleAggValueSource {
 
   class VarianceUnInvertedFieldAcc extends SDVUnInvertedFieldAcc {
 
-    public VarianceUnInvertedFieldAcc(FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
+    public VarianceUnInvertedFieldAcc(FacetRequest.FacetContext fcontext, SchemaField sf, int numSlots) throws IOException {
       super(fcontext, sf, numSlots);
     }
 
diff --git a/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java b/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
index ee7f0e882f1..fb972dcc975 100644
--- a/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
+++ b/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
@@ -68,7 +68,7 @@ class DebugAgg extends AggValueSource {
   }
 
   @Override
-  public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) throws IOException {
+  public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) throws IOException {
     return new Acc(fcontext, numDocs, numSlots, inner.createSlotAcc(fcontext, numDocs, numSlots));
   }
 
@@ -94,7 +94,7 @@ class DebugAgg extends AggValueSource {
     public long numDocs;
     public int numSlots;
 
-    public Acc(FacetContext fcontext, long numDocs, int numSlots, SlotAcc sub) {
+    public Acc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots, SlotAcc sub) {
       super(fcontext);
       this.last = this;
       this.numDocs = numDocs;
@@ -173,7 +173,7 @@ class DebugAgg extends AggValueSource {
     }
     
     @Override
-    public SlotAcc createSlotAcc(FacetContext fcontext, long numDocs, int numSlots) {
+    public SlotAcc createSlotAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) {
       return new NumShardsAcc(fcontext, numDocs, numSlots);
     }
     
@@ -188,7 +188,7 @@ class DebugAgg extends AggValueSource {
     }
     
     public static class NumShardsAcc extends SlotAcc {
-      public NumShardsAcc(FacetContext fcontext, long numDocs, int numSlots) {
+      public NumShardsAcc(FacetRequest.FacetContext fcontext, long numDocs, int numSlots) {
         super(fcontext);
       }
       
diff --git a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
index db6095538cc..386aea044cb 100644
--- a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
+++ b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
@@ -136,7 +136,7 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
     try {
       int nShards = responsesAndTests.length / 2;
       Object jsonFacet = Utils.fromJSONString(facet);
-      FacetParser parser = new FacetTopParser(req);
+      FacetRequest.FacetParser parser = new FacetRequest.FacetTopParser(req);
       FacetRequest facetRequest = parser.parse(jsonFacet);
 
       FacetMerger merger = null;
