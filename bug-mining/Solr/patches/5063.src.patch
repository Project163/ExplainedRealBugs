diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 8540f745ad4..64a22878f23 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -277,8 +277,6 @@ Bug Fixes
 
 * SOLR-16861: Coordinator node does not have the correct collection/core in MDCLoggingContext (Patson Luk)
 
-
-
 Dependency Upgrades
 ---------------------
 * PR#1494: Upgrade forbiddenapis to 3.5 (Uwe Schindler)
diff --git a/solr/core/src/java/org/apache/solr/servlet/CoordinatorHttpSolrCall.java b/solr/core/src/java/org/apache/solr/servlet/CoordinatorHttpSolrCall.java
index df95f712a4c..ee30474a506 100644
--- a/solr/core/src/java/org/apache/solr/servlet/CoordinatorHttpSolrCall.java
+++ b/solr/core/src/java/org/apache/solr/servlet/CoordinatorHttpSolrCall.java
@@ -105,7 +105,16 @@ public class CoordinatorHttpSolrCall extends HttpSolrCall {
               .cores
               .getZkController()
               .getZkStateReader()
-              .registerDocCollectionWatcher(collectionName, collection -> collection == null);
+              .registerDocCollectionWatcher(
+                  collectionName,
+                  collection -> {
+                    if (collection == null) {
+                      factory.collectionVsCoreNameMapping.remove(collectionName);
+                      return true;
+                    } else {
+                      return false;
+                    }
+                  });
           if (log.isDebugEnabled()) {
             log.debug("coordinator node, returns synthetic core: {}", core.getName());
           }
diff --git a/solr/core/src/test/org/apache/solr/search/TestCoordinatorRole.java b/solr/core/src/test/org/apache/solr/search/TestCoordinatorRole.java
index 705429de5e5..14d866d1f3a 100644
--- a/solr/core/src/test/org/apache/solr/search/TestCoordinatorRole.java
+++ b/solr/core/src/test/org/apache/solr/search/TestCoordinatorRole.java
@@ -443,19 +443,32 @@ public class TestCoordinatorRole extends SolrCloudTestCase {
       assertTrue(!zkWatchAccessor.getWatchedCollections().contains(TEST_COLLECTION));
       new QueryRequest(new SolrQuery("*:*"))
           .setPreferredNodes(List.of(coordinatorJetty.getNodeName()))
-          .process(client, TEST_COLLECTION);
+          .process(client, TEST_COLLECTION); // ok no exception thrown
 
       // now it should be watching it after the query
       assertTrue(zkWatchAccessor.getWatchedCollections().contains(TEST_COLLECTION));
 
       CollectionAdminRequest.deleteReplica(TEST_COLLECTION, "shard1", 1).process(client);
       cluster.waitForActiveCollection(TEST_COLLECTION, 1, 1);
+      new QueryRequest(new SolrQuery("*:*"))
+          .setPreferredNodes(List.of(coordinatorJetty.getNodeName()))
+          .process(client, TEST_COLLECTION); // ok no exception thrown
 
       // still one replica left, should not remove the watch
       assertTrue(zkWatchAccessor.getWatchedCollections().contains(TEST_COLLECTION));
 
       CollectionAdminRequest.deleteCollection(TEST_COLLECTION).process(client);
       zkStateReader.waitForState(TEST_COLLECTION, 30, TimeUnit.SECONDS, Objects::isNull);
+      assertNull(zkStateReader.getCollection(TEST_COLLECTION)); // check the cluster state
+
+      // ensure querying throws exception
+      assertExceptionThrownWithMessageContaining(
+          SolrException.class,
+          List.of("Collection not found"),
+          () ->
+              new QueryRequest(new SolrQuery("*:*"))
+                  .setPreferredNodes(List.of(coordinatorJetty.getNodeName()))
+                  .process(client, TEST_COLLECTION));
 
       // watch should be removed after collection deletion
       assertTrue(!zkWatchAccessor.getWatchedCollections().contains(TEST_COLLECTION));
