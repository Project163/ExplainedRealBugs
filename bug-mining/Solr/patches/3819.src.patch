diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 3dc4b45d5e7..1f6299e9cba 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -252,6 +252,8 @@ Bug Fixes
 * SOLR-12020: JSON Facet API: terms facet on date field fails in refinement phase with
   "Invalid Date String" error. (yonik)
 
+* SOLR-12061: Fix substitution bug in API V1 to V2 migration when using SolrJ with V2 API. (Tomás Fernánadez Löbbe)
+
 Optimizations
 ----------------------
 
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/CollectionApiMapping.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/CollectionApiMapping.java
index 95e7008e92e..d950f1195c6 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/CollectionApiMapping.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/CollectionApiMapping.java
@@ -191,7 +191,8 @@ public class CollectionApiMapping {
         POST,
         COLLECTIONPROP,
         "set-collection-property",
-        Utils.makeMap(NAME, "collection",
+        Utils.makeMap(
+            NAME, "collection",
             "propertyName", "name",
             "propertyValue", "value")),
     ADD_ROLE(CLUSTER_CMD,
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/V1toV2ApiMapper.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/V1toV2ApiMapper.java
index c34f92c7aee..0ec1112c214 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/V1toV2ApiMapper.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/V1toV2ApiMapper.java
@@ -81,9 +81,9 @@ public class V1toV2ApiMapper {
       }
     }
 
-    public V2Request.Builder convert(SolrParams params) {
+    public V2Request.Builder convert(SolrParams paramsV1) {
       String[] list = new String[template.variables.size()];
-      MapWriter data = serializeToV2Format(params, list);
+      MapWriter data = serializeToV2Format(paramsV1, list);
       Map o = data.toMap(new LinkedHashMap<>());
       return new V2Request.Builder(template.apply(s -> {
         int idx = template.variables.indexOf(s);
@@ -94,9 +94,9 @@ public class V1toV2ApiMapper {
 
     }
 
-    private MapWriter serializeToV2Format(SolrParams params, String[] list) {
+    private MapWriter serializeToV2Format(SolrParams paramsV1, String[] list) {
       return ew -> ew.put(meta.commandName, (MapWriter) ew1 -> {
-        Iterator<String> iter = params.getParameterNamesIterator();
+        Iterator<String> iter = paramsV1.getParameterNamesIterator();
         Map<String, Map<String, String>> subProperties = null;
         while (iter.hasNext()) {
           String key = iter.next();
@@ -104,17 +104,18 @@ public class V1toV2ApiMapper {
           Object substitute = meta.getReverseParamSubstitute(key);
           int idx = template.variables.indexOf(substitute);
           if (idx > -1) {
-            String val = params.get(String.valueOf(substitute));
+            String val = paramsV1.get(key);
             if (val == null) throw new RuntimeException("null value is not valid for " + key);
             list[idx] = val;
             continue;
           }
           if (substitute instanceof Pair) {//this is a nested object
+            @SuppressWarnings("unchecked")
             Pair<String, String> p = (Pair<String, String>) substitute;
             if (subProperties == null) subProperties = new HashMap<>();
-            subProperties.computeIfAbsent(p.first(), s -> new HashMap<>()).put(p.second(), params.get(key));
+            subProperties.computeIfAbsent(p.first(), s -> new HashMap<>()).put(p.second(), paramsV1.get(key));
           } else {
-            Object val = params.get(key);
+            Object val = paramsV1.get(key);
             ew1.put(substitute.toString(), val);
           }
         }
@@ -128,7 +129,7 @@ public class V1toV2ApiMapper {
   }
 
 
-  public static V2Request.Builder convert(CollectionAdminRequest request) {
+  public static V2Request.Builder convert(CollectionAdminRequest<?> request) {
     ActionInfo info = mapping.get(request.action);
     if (info == null) throw new RuntimeException("Unsupported action :" + request.action);
 
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestV1toV2ApiMapper.java b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestV1toV2ApiMapper.java
index 7dd4e0644e1..21806dad9f2 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestV1toV2ApiMapper.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestV1toV2ApiMapper.java
@@ -29,7 +29,7 @@ import org.apache.solr.common.util.Utils;
 
 public class TestV1toV2ApiMapper extends LuceneTestCase {
 
-  public void testCommands() throws IOException {
+  public void testCreate() throws IOException {
     Create cmd = CollectionAdminRequest
         .createCollection("mycoll", "conf1", 3, 2)
         .setProperties(ImmutableMap.<String,String>builder()
@@ -37,28 +37,29 @@ public class TestV1toV2ApiMapper extends LuceneTestCase {
             .put("p2","v2")
             .build());
     V2Request v2r = V1toV2ApiMapper.convert(cmd).build();
-    Map m = (Map) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
+    Map<?,?> m = (Map<?,?>) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
     assertEquals("/c", v2r.getPath());
     assertEquals("v1", Utils.getObjectByPath(m,true,"/create/properties/p1"));
     assertEquals("v2", Utils.getObjectByPath(m,true,"/create/properties/p2"));
     assertEquals("3", Utils.getObjectByPath(m,true,"/create/numShards"));
     assertEquals("2", Utils.getObjectByPath(m,true,"/create/nrtReplicas"));
-
+  }
+  
+  public void testAddReplica() throws IOException {
     CollectionAdminRequest.AddReplica addReplica = CollectionAdminRequest.addReplicaToShard("mycoll", "shard1");
-    v2r = V1toV2ApiMapper.convert(addReplica).build();
-    m = (Map) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
+    V2Request v2r = V1toV2ApiMapper.convert(addReplica).build();
+    Map<?,?> m = (Map<?,?>) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
     assertEquals("/c/mycoll/shards", v2r.getPath());
     assertEquals("shard1", Utils.getObjectByPath(m,true,"/add-replica/shard"));
     assertEquals("NRT", Utils.getObjectByPath(m,true,"/add-replica/type"));
-
-//    CollectionAdminRequest.CollectionProp collectionProp = CollectionAdminRequest.setCollectionProperty("mycoll", "prop", "value");
-//    v2r = V1toV2ApiMapper.convert(collectionProp).build();
-//    m = (Map) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
-//    assertEquals("/c", v2r.getPath());
-//    assertEquals("mycoll", Utils.getObjectByPath(m,true,"/set-collection-property/name"));
-//    assertEquals("prop", Utils.getObjectByPath(m,true,"/set-collection-property/name"));
-//    assertEquals("value", Utils.getObjectByPath(m,true,"/set-collection-property/value"));
-
-
+  }
+  
+  public void testSetCollectionProperty() throws IOException {
+    CollectionAdminRequest.CollectionProp collectionProp = CollectionAdminRequest.setCollectionProperty("mycoll", "prop", "value");
+    V2Request v2r = V1toV2ApiMapper.convert(collectionProp).build();
+    Map<?,?> m = (Map<?,?>) Utils.fromJSON(ContentStreamBase.create(new BinaryRequestWriter(), v2r).getStream());
+    assertEquals("/c/mycoll", v2r.getPath());
+    assertEquals("prop", Utils.getObjectByPath(m,true,"/set-collection-property/name"));
+    assertEquals("value", Utils.getObjectByPath(m,true,"/set-collection-property/value"));
   }
 }
