diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 327e4003244..3bcc8d79a9b 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -128,6 +128,8 @@ Other Changes
 ---------------------
 * SOLR-17024: Remove support for the long-defunct "collectionDefaults" clusterprops key (Jason Gerlowski)
 
+* SOLR-17072: package CLI tool prints error JSONPath (Mikhail Khludnev)
+
 ==================  9.4.0 ==================
 New Features
 ---------------------
diff --git a/solr/core/src/java/org/apache/solr/packagemanager/PackageManager.java b/solr/core/src/java/org/apache/solr/packagemanager/PackageManager.java
index a21195add91..7c28fa9e4c2 100644
--- a/solr/core/src/java/org/apache/solr/packagemanager/PackageManager.java
+++ b/solr/core/src/java/org/apache/solr/packagemanager/PackageManager.java
@@ -19,6 +19,7 @@ package org.apache.solr.packagemanager;
 
 import static org.apache.solr.packagemanager.PackageUtils.getMapper;
 
+import com.jayway.jsonpath.InvalidPathException;
 import com.jayway.jsonpath.JsonPath;
 import com.jayway.jsonpath.PathNotFoundException;
 import java.io.Closeable;
@@ -769,11 +770,10 @@ public class PackageManager implements Closeable {
             PackageUtils.printGreen(response);
             String actualValue = null;
             try {
-              actualValue =
-                  JsonPath.parse(response, PackageUtils.jsonPathConfiguration())
-                      .read(
-                          PackageUtils.resolve(
-                              cmd.condition, pkg.parameterDefaults, overridesMap, systemParams));
+              String jsonPath =
+                  PackageUtils.resolve(
+                      cmd.condition, pkg.parameterDefaults, overridesMap, systemParams);
+              actualValue = jsonPathRead(response, jsonPath);
             } catch (PathNotFoundException ex) {
               PackageUtils.printRed("Failed to deploy plugin: " + plugin.name);
               success = false;
@@ -820,14 +820,13 @@ public class PackageManager implements Closeable {
               PackageUtils.printGreen(response);
               String actualValue = null;
               try {
-                actualValue =
-                    JsonPath.parse(response, PackageUtils.jsonPathConfiguration())
-                        .read(
-                            PackageUtils.resolve(
-                                cmd.condition,
-                                pkg.parameterDefaults,
-                                collectionParameterOverrides,
-                                systemParams));
+                String jsonPath =
+                    PackageUtils.resolve(
+                        cmd.condition,
+                        pkg.parameterDefaults,
+                        collectionParameterOverrides,
+                        systemParams);
+                actualValue = jsonPathRead(response, jsonPath);
               } catch (PathNotFoundException ex) {
                 PackageUtils.printRed("Failed to deploy plugin: " + plugin.name);
                 success = false;
@@ -856,6 +855,17 @@ public class PackageManager implements Closeable {
     return success;
   }
 
+  /** just adds problem XPath into {@link InvalidPathException} if occurs */
+  private static String jsonPathRead(String response, String jsonPath) {
+    try {
+      return JsonPath.parse(response, PackageUtils.jsonPathConfiguration()).read(jsonPath);
+    } catch (PathNotFoundException pne) {
+      throw pne;
+    } catch (InvalidPathException ipe) {
+      throw new InvalidPathException("Error in JSON Path:" + jsonPath, ipe);
+    }
+  }
+
   /**
    * Get the installed instance of a specific version of a package. If version is null,
    * PackageUtils.LATEST or PackagePluginHolder.LATEST, then it returns the highest version
@@ -1095,8 +1105,8 @@ public class PackageManager implements Closeable {
       String version = null;
       try {
         version =
-            JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())
-                .read("$['response'].['params'].['PKG_VERSIONS'].['" + packageName + "'])");
+            jsonPathRead(
+                paramsJson, "$['response'].['params'].['PKG_VERSIONS'].['" + packageName + "']");
       } catch (PathNotFoundException ex) {
         // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched
         // by the package manager.
diff --git a/solr/core/src/test/org/apache/solr/packagemanager/TestPackageManager.java b/solr/core/src/test/org/apache/solr/packagemanager/TestPackageManager.java
new file mode 100644
index 00000000000..270e4fb665d
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/packagemanager/TestPackageManager.java
@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.packagemanager;
+
+import com.jayway.jsonpath.InvalidPathException;
+import java.io.IOException;
+import java.net.URL;
+import java.util.Collections;
+import java.util.Map;
+import org.apache.solr.client.solrj.impl.Http2SolrClient;
+import org.apache.solr.client.solrj.request.CollectionAdminRequest;
+import org.apache.solr.cloud.SolrCloudTestCase;
+import org.apache.solr.common.cloud.SolrZkClient;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TestPackageManager extends SolrCloudTestCase {
+
+  private static final String COLLECTION_NAME = "collection1";
+
+  @Before
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    configureCluster(1).addConfig("conf", configset("conf3")).configure();
+    CollectionAdminRequest.createCollection(COLLECTION_NAME, "conf", 1, 1)
+        .process(cluster.getSolrClient());
+    cluster.waitForActiveCollection(COLLECTION_NAME, 1, 1);
+  }
+
+  @Test
+  public void testWrongVerificationJPathIsThrown() throws IOException {
+    SolrZkClient zkClient = cluster.getZkClient();
+    URL baseURLV2 = cluster.getJettySolrRunner(0).getBaseURLV2();
+    try (Http2SolrClient solrClient = new Http2SolrClient.Builder(baseURLV2.toString()).build()) {
+      try (PackageManager manager = new StubPackageManager(solrClient, zkClient)) {
+        SolrPackage.Plugin plugin = new SolrPackage.Plugin();
+        if (random().nextBoolean()) {
+          plugin.type = "cluster";
+        }
+        plugin.name = "foo";
+        plugin.verifyCommand = new SolrPackage.Command();
+        plugin.verifyCommand.method = "GET";
+        plugin.verifyCommand.path = /*"/api*/
+            "/collections/" + COLLECTION_NAME + "/config/requestHandler";
+        plugin.verifyCommand.condition = "&[no_quotes_error_jpath]";
+        manager.verify(
+            new SolrPackageInstance(
+                "",
+                "",
+                "1.0",
+                new SolrPackage.Manifest(),
+                Collections.singletonList(plugin),
+                Collections.emptyMap()),
+            Collections.singletonList(COLLECTION_NAME),
+            plugin.type.equals("cluster"),
+            new String[0]);
+        fail();
+      } catch (InvalidPathException e) {
+        assertTrue(e.getMessage().contains("&[no_quotes_error_jpath]"));
+      }
+    }
+  }
+
+  private static class StubPackageManager extends PackageManager {
+    public StubPackageManager(Http2SolrClient solrClient, SolrZkClient zkClient) {
+      super(
+          solrClient,
+          SolrCloudTestCase.cluster.getJettySolrRunners().get(0).getBaseUrl().toString(),
+          zkClient.getZkServerAddress());
+    }
+
+    @Override
+    Map<String, String> getPackageParams(String packageName, String collection) {
+      return Collections.emptyMap();
+    }
+  }
+}
