diff --git a/solr/core/src/java/org/apache/solr/cloud/DistributedClusterStateUpdater.java b/solr/core/src/java/org/apache/solr/cloud/DistributedClusterStateUpdater.java
index 9583e5b50f6..06a7ef9b624 100644
--- a/solr/core/src/java/org/apache/solr/cloud/DistributedClusterStateUpdater.java
+++ b/solr/core/src/java/org/apache/solr/cloud/DistributedClusterStateUpdater.java
@@ -299,7 +299,7 @@ public class DistributedClusterStateUpdater {
      * through {@link #getPerReplicaStatesOps()}). Any or both of these methods will return {@code null} if there is no
      * corresponding update to apply.
      */
-    void computeUpdates(ClusterState currentState);
+    void computeUpdates(ClusterState currentState, SolrZkClient client);
 
     /**
      * Method can only be called after {@link #computeUpdates} has been called.
@@ -398,7 +398,7 @@ public class DistributedClusterStateUpdater {
         // (it's read from ZK just above). So assumptions made in the mutators (like SliceMutator.removeReplica() deleting
         // the whole collection if it's not found) are ok. Actually in the removeReplica case, the collection will always
         // exist otherwise the call to fetchStateForCollection() above would have failed.
-        updater.computeUpdates(initialClusterState);
+        updater.computeUpdates(initialClusterState, zkStateReader.getZkClient());
 
         ClusterState updatedState = updater.getUpdatedClusterState();
         List<PerReplicaStatesOps> allStatesOps = updater.getPerReplicaStatesOps();
@@ -661,7 +661,7 @@ public class DistributedClusterStateUpdater {
       }
 
       @Override
-      public void computeUpdates(ClusterState clusterState) {
+      public void computeUpdates(ClusterState clusterState, SolrZkClient client) {
         boolean hasJsonUpdates = false;
         List<PerReplicaStatesOps> perReplicaStateOps = new LinkedList<>();
         for (Pair<MutatingCommand, ZkNodeProps> mutation : mutations) {
@@ -793,9 +793,9 @@ public class DistributedClusterStateUpdater {
     }
 
     @Override
-    public void computeUpdates(ClusterState clusterState) {
+    public void computeUpdates(ClusterState clusterState, SolrZkClient client) {
       final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);
-      Optional<ZkWriteCommand> result = docCollection != null ? NodeMutator.computeCollectionUpdate(nodeName, collectionName, docCollection, null) : Optional.empty();
+      Optional<ZkWriteCommand> result = docCollection != null ? NodeMutator.computeCollectionUpdate(nodeName, collectionName, docCollection, client) : Optional.empty();
 
       if (docCollection == null) {
         // This is possible but should be rare. Logging warn in case it is seen often and likely a sign of another issue
