diff --git a/solr/core/src/java/org/apache/solr/core/RequestParams.java b/solr/core/src/java/org/apache/solr/core/RequestParams.java
index 18839539800..da1ae633809 100644
--- a/solr/core/src/java/org/apache/solr/core/RequestParams.java
+++ b/solr/core/src/java/org/apache/solr/core/RequestParams.java
@@ -29,7 +29,7 @@ import org.apache.solr.cloud.ZkSolrResourceLoader;
 import org.apache.solr.common.MapSerializable;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.cloud.SolrZkClient;
-import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.MultiMapSolrParams;
 import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.data.Stat;
@@ -85,32 +85,27 @@ public class RequestParams implements MapSerializable {
    * This converts Lists to arrays of strings. Because Solr expects
    * params to be String[]
    */
-
-  @SuppressWarnings({"unchecked", "rawtypes"})
-  private static Map getMapCopy(Map value) {
-    @SuppressWarnings({"rawtypes"})
-    Map copy = new LinkedHashMap<>();
-    for (Object o1 : value.entrySet()) {
-      @SuppressWarnings({"rawtypes"})
-      Map.Entry entry = (Map.Entry) o1;
+  private static Map<String,String[]> getMapCopy(Map<String,?> value) {
+    Map<String, String[]> copy = new LinkedHashMap<>();
+    for (Map.Entry<String, ?> entry : value.entrySet()) {
       if ("".equals(entry.getKey())) {
-        copy.put(entry.getKey(), entry.getValue());
-        continue;
-      }
-      if (entry.getValue() != null) {
-        if (entry.getValue() instanceof List) {
-          @SuppressWarnings({"rawtypes"})
-          List l = (List) entry.getValue();
-          String[] sarr = new String[l.size()];
-          for (int i = 0; i < l.size(); i++) {
-            if (l.get(i) != null) sarr[i] = String.valueOf(l.get(i));
-          }
-          copy.put(entry.getKey(), sarr);
+        // Why is this a special case?
+        if (entry.getValue() instanceof String[]) {
+          copy.put("", (String[]) entry.getValue());
         } else {
-          copy.put(entry.getKey(), String.valueOf(entry.getValue()));
+          throw new IllegalArgumentException();
+        }
+      } else if (entry.getValue() == null) {
+        copy.put(entry.getKey(), null);
+      } else if (entry.getValue() instanceof List) {
+        List<?> l = (List<?>) entry.getValue();
+        String[] sarr = new String[l.size()];
+        for (int i = 0; i < l.size(); i++) {
+          if (l.get(i) != null) sarr[i] = String.valueOf(l.get(i));
         }
+        copy.put(entry.getKey(), sarr);
       } else {
-        copy.put(entry.getKey(), entry.getValue());
+        copy.put(entry.getKey(), new String[] { entry.getValue().toString() });
       }
     }
     return copy;
@@ -287,11 +282,10 @@ public class RequestParams implements MapSerializable {
     }
   }
 
-  public static class VersionedParams extends MapSolrParams {
+  public static class VersionedParams extends MultiMapSolrParams {
     final ParamSet paramSet;
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    public VersionedParams(Map map, ParamSet paramSet) {
+    public VersionedParams(Map<String,?> map, ParamSet paramSet) {
       super(getMapCopy(map));
       this.paramSet = paramSet;
     }
diff --git a/solr/core/src/java/org/apache/solr/handler/SchemaHandler.java b/solr/core/src/java/org/apache/solr/handler/SchemaHandler.java
index b6ba60f213e..fb24b0d6434 100644
--- a/solr/core/src/java/org/apache/solr/handler/SchemaHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/SchemaHandler.java
@@ -139,11 +139,7 @@ public class SchemaHandler extends RequestHandlerBase implements SolrCoreAware,
           break;
         }
         case "/schema/zkversion": {
-          int refreshIfBelowVersion = -1;
-          Object refreshParam = req.getParams().get("refreshIfBelowVersion");
-          if (refreshParam != null)
-            refreshIfBelowVersion = (refreshParam instanceof Number) ? ((Number) refreshParam).intValue()
-                : Integer.parseInt(refreshParam.toString());
+          int refreshIfBelowVersion = req.getParams().getInt("refreshIfBelowVersion");
           int zkVersion = -1;
           IndexSchema schema = req.getSchema();
           if (schema instanceof ManagedIndexSchema) {
diff --git a/solr/core/src/java/org/apache/solr/rest/BaseSolrResource.java b/solr/core/src/java/org/apache/solr/rest/BaseSolrResource.java
index 5a9310d84e9..cd1e897a342 100644
--- a/solr/core/src/java/org/apache/solr/rest/BaseSolrResource.java
+++ b/solr/core/src/java/org/apache/solr/rest/BaseSolrResource.java
@@ -125,12 +125,9 @@ public abstract class BaseSolrResource extends ServerResource {
             SolrCore.preDecorateResponse(solrRequest, solrResponse);
 
             // client application can set a timeout for update requests
-            Object updateTimeoutSecsParam = getSolrRequest().getParams().get(UPDATE_TIMEOUT_SECS);
+            String updateTimeoutSecsParam = getSolrRequest().getParams().get(UPDATE_TIMEOUT_SECS);
             if (updateTimeoutSecsParam != null)
-              updateTimeoutSecs = (updateTimeoutSecsParam instanceof Number)
-                  ? ((Number) updateTimeoutSecsParam).intValue()
-                  : Integer.parseInt(updateTimeoutSecsParam.toString());
-
+              updateTimeoutSecs = Integer.parseInt(updateTimeoutSecsParam);
           }
         }
       } catch (Throwable t) {
diff --git a/solr/solrj/src/java/org/apache/solr/common/params/MapSolrParams.java b/solr/solrj/src/java/org/apache/solr/common/params/MapSolrParams.java
index 5454fcac277..e8c40e97fe0 100644
--- a/solr/solrj/src/java/org/apache/solr/common/params/MapSolrParams.java
+++ b/solr/solrj/src/java/org/apache/solr/common/params/MapSolrParams.java
@@ -20,33 +20,29 @@ import java.util.Iterator;
 import java.util.Map;
 
 /**
- *
+ * {@link SolrParams} implementation that can be built from and is backed by a {@link Map}.
  */
 public class MapSolrParams extends SolrParams {
   protected final Map<String,String> map;
 
   public MapSolrParams(Map<String,String> map) {
+    assert map.entrySet().stream().allMatch(e -> {
+      boolean hasStringKey = e.getKey() == null || e.getKey().getClass() == String.class;
+      boolean hasStringValue = e.getValue() == null || e.getValue().getClass() == String.class;
+      return hasStringKey && hasStringValue;
+    });
     this.map = map;
   }
 
   @Override
   public String get(String name) {
-    Object  o = map.get(name);
-    if(o == null) return null;
-    if (o instanceof String) return  (String) o;
-    if (o instanceof String[]) {
-      String[] strings = (String[]) o;
-      if(strings.length == 0) return null;
-      return strings[0];
-    }
-    return String.valueOf(o);
+      return map.get(name);
   }
 
   @Override
   public String[] getParams(String name) {
-    Object val = map.get(name);
-    if (val instanceof String[]) return (String[]) val;
-    return val==null ? null : new String[]{String.valueOf(val)};
+    String val = map.get(name);
+    return val == null ? null : new String[] { val };
   }
 
   @Override
diff --git a/solr/solrj/src/java/org/apache/solr/common/params/MultiMapSolrParams.java b/solr/solrj/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
index 8a5416b4034..c544155e872 100644
--- a/solr/solrj/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
+++ b/solr/solrj/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
@@ -55,6 +55,11 @@ public class MultiMapSolrParams extends SolrParams {
 
 
   public MultiMapSolrParams(Map<String,String[]> map) {
+    assert map.entrySet().stream().allMatch(e -> {
+      boolean hasStringKey = e.getKey() == null || e.getKey().getClass() == String.class;
+      boolean hasStringArrayValue = e.getValue() == null || e.getValue().getClass() == String[].class;
+      return hasStringKey && hasStringArrayValue;
+    });
     this.map = map;
   }
 
