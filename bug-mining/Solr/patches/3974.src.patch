diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 83fbe5de243..d9696768107 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -124,6 +124,9 @@ Bug Fixes
 
 * SOLR-11665: Improve error handling of shard splitting. Fix splitting of mixed replica types. (ab)
 
+* SOLR-12326: JSON Facet API: terms facet shard requests now indicate if they have more buckets to prevent
+  unnecessary refinement requests. (yonk)
+
 Optimizations
 ----------------------
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldMerger.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldMerger.java
index 4f57bcd90c0..ef3045ef3d2 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldMerger.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldMerger.java
@@ -33,7 +33,7 @@ public class FacetFieldMerger extends FacetRequestSortedMerger<FacetField> {
   FacetBucket missingBucket;
   FacetBucket allBuckets;
   FacetMerger numBuckets;
-  int[] numReturnedPerShard;
+  int[] numReturnedPerShard;  // TODO: this is currently unused?
 
   // LinkedHashMap<Object,FacetBucket> buckets = new LinkedHashMap<>();
   // List<FacetBucket> sortedBuckets;
@@ -46,6 +46,7 @@ public class FacetFieldMerger extends FacetRequestSortedMerger<FacetField> {
 
   @Override
   public void merge(Object facetResult, Context mcontext) {
+    super.merge(facetResult, mcontext);
     if (numReturnedPerShard == null) {
       numReturnedPerShard = new int[mcontext.numShards];
     }
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
index 727659367c7..83ea39f3632 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor.java
@@ -296,6 +296,7 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
     // note: We avoid object allocation by having a Slot and re-using the 'bottom'.
     Slot bottom = null;
     Slot scratchSlot = new Slot();
+    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned
     for (int slotNum = 0; slotNum < numSlots; slotNum++) {
 
       // screen out buckets not matching mincount
@@ -311,6 +312,7 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
       numBuckets++;
 
       if (bottom != null) {
+        shardHasMoreBuckets = true;
         scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line
         if (orderPredicate.test(bottom, scratchSlot)) {
           bottom.slot = slotNum;
@@ -381,6 +383,11 @@ abstract class FacetFieldProcessor extends FacetProcessor<FacetField> {
       bucketList.add(bucket);
     }
 
+    if (fcontext.isShard() && shardHasMoreBuckets) {
+      // Currently, "more" is an internal implementation detail and only returned for distributed sub-requests
+      res.add("more", true);
+    }
+
     if (freq.missing) {
       // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.
       fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
index 9257ec7164e..d6d9cd4a253 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByEnumTermsStream.java
@@ -21,6 +21,7 @@ import java.io.Closeable;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.IntFunction;
 
 import org.apache.lucene.index.LeafReaderContext;
@@ -62,6 +63,7 @@ class FacetFieldProcessorByEnumTermsStream extends FacetFieldProcessor implement
   PostingsEnum postingsEnum;
   BytesRef startTermBytes;
   BytesRef term;
+  AtomicBoolean shardHasMoreBuckets = new AtomicBoolean(false);  // set after streaming as finished
 
   // at any point in processing where we need a SlotContext, all we care about is the current 'term'
   private IntFunction<SlotContext> slotContext = (slotNum) -> {
@@ -132,6 +134,9 @@ class FacetFieldProcessorByEnumTermsStream extends FacetFieldProcessor implement
         throw new UnsupportedOperationException();
       }
     });
+    if (fcontext.isShard()) {
+      response.add("more", shardHasMoreBuckets);  // lazily evaluated
+    }
   }
 
   private void setup() throws IOException {
@@ -325,6 +330,7 @@ class FacetFieldProcessorByEnumTermsStream extends FacetFieldProcessor implement
         }
 
         if (freq.limit >= 0 && ++bucketsReturned > freq.limit) {
+          shardHasMoreBuckets.set(true);
           return null;
         }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetRangeMerger.java b/solr/core/src/java/org/apache/solr/search/facet/FacetRangeMerger.java
index 6ddc05e06b9..a3bfdc818ae 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetRangeMerger.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetRangeMerger.java
@@ -40,6 +40,7 @@ public class FacetRangeMerger extends FacetRequestSortedMerger<FacetRange> {
 
   @Override
   public void merge(Object facetResult, Context mcontext) {
+    super.merge(facetResult, mcontext);
     merge((SimpleOrderedMap) facetResult , mcontext);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger.java b/solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger.java
index d7378855887..024866f4481 100644
--- a/solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger.java
+++ b/solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger.java
@@ -19,6 +19,7 @@ package org.apache.solr.search.facet;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.BitSet;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
@@ -33,11 +34,26 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 abstract class FacetRequestSortedMerger<FacetRequestT extends FacetRequestSorted> extends FacetBucketMerger<FacetRequestT> {
   LinkedHashMap<Object,FacetBucket> buckets = new LinkedHashMap<>();
   List<FacetBucket> sortedBuckets;
+  BitSet shardHasMoreBuckets;  // null, or "true" if we saw a result from this shard and it indicated that there are more results
+
 
   public FacetRequestSortedMerger(FacetRequestT freq) {
     super(freq);
   }
 
+  @Override
+  public void merge(Object facetResult, Context mcontext) {
+    SimpleOrderedMap res = (SimpleOrderedMap)facetResult;
+    Boolean more = (Boolean)res.get("more");
+    if (more != null && more) {
+      if (shardHasMoreBuckets == null) {
+        // We really only need this if it's a partial facet (has a limit)
+        shardHasMoreBuckets = new BitSet(mcontext.numShards);
+      }
+      shardHasMoreBuckets.set(mcontext.shardNum);
+    }
+  }
+
   private static class SortVal implements Comparable<SortVal> {
     FacetBucket bucket;
     FacetSortableMerger merger;  // make this class inner and access merger , direction in parent?
@@ -159,15 +175,16 @@ abstract class FacetRequestSortedMerger<FacetRequestT extends FacetRequestSorted
     Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);
 
     boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?
+    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets
+    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets
 
-    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)
     // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets
     boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?
-    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?
+    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)
 
     if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {
-      // this facet returned all possible buckets, and there were no sub-facets with partial results
-      // and sub-facets that require refining
+      // this shard returned all of its possible buckets, and there were no sub-facets with partial results
+      // or sub-facets that require refining
       return null;
     }
 
@@ -197,8 +214,8 @@ abstract class FacetRequestSortedMerger<FacetRequestT extends FacetRequestSorted
       // if this bucket is missing,
       assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;
       boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);
-      if (!saw) {
-        // we didn't see the bucket for this shard
+      if (!saw && !returnedAllBuckets) {
+        // we didn't see the bucket for this shard, and it's possible that the shard has it
         Map<String,Object> bucketRefinement = null;
 
         // find facets that we need to fill in buckets for
diff --git a/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java b/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
index c7ce7c31e7e..2b3e1bda2f3 100644
--- a/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
+++ b/solr/core/src/test/org/apache/solr/search/facet/DebugAgg.java
@@ -32,10 +32,12 @@ import org.apache.solr.search.ValueSourceParser;
 
 
 public class DebugAgg extends AggValueSource {
+  public static AtomicLong parses = new AtomicLong(0);
 
   public static class Parser extends ValueSourceParser {
     @Override
     public ValueSource parse(FunctionQParser fp) throws SyntaxError {
+      parses.incrementAndGet();
       return new DebugAgg();
     }
 
diff --git a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
index 687adde8e87..779e58b58fd 100644
--- a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
+++ b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement.java
@@ -160,12 +160,27 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
   @Test
   public void testMerge() throws Exception {
     doTestRefine("{x : {type:terms, field:X, limit:2, refine:true} }",  // the facet request
-        "{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }",  // shard0 response
-        "{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }",  // shard1 response
+        "{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }",  // shard0 response
+        "{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } }",  // shard1 response
         null,              // shard0 expected refinement info
         "=={x:{_l:[x1]}}"  // shard1 expected refinement info
     );
 
+    // same test as above, but shard1 indicates it doesn't have any more results, so there shouldn't be any refinement
+    doTestRefine("{x : {type:terms, field:X, limit:2, refine:true} }",  // the facet request
+        "{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } }",  // shard0 response
+        "{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }",  // shard1 response
+        null,              // shard0 expected refinement info
+        null               // shard1 expected refinement info
+    );
+
+    doTestRefine("{x : {type:terms, field:X, limit:2, refine:true} }",  // the facet request
+        "{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}],more:true } }",  // shard0 response
+        "{x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } }",  // shard1 response
+        null,  // shard0 expected refinement info
+        null   // shard1 expected refinement info  // without more:true, we should not attempt to get extra bucket
+    );
+
     // same test w/o refinement turned on
     doTestRefine("{x : {type:terms, field:X, limit:2} }",  // the facet request
         "{x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } }",  // shard0 response
@@ -176,8 +191,8 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
 
     // same test, but nested in query facet
     doTestRefine("{top:{type:query, q:'foo_s:myquery', facet:{x : {type:terms, field:X, limit:2, refine:true} } } }",  // the facet request
-        "{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}] } } }",  // shard0 response
-        "{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}] } } }",  // shard1 response
+        "{top: {x: {buckets:[{val:x1, count:5}, {val:x2, count:3}], more:true } } }",  // shard0 response
+        "{top: {x: {buckets:[{val:x2, count:4}, {val:x3, count:2}], more:true } } }",  // shard1 response
         null,              // shard0 expected refinement info
         "=={top:{x:{_l:[x1]}}}"  // shard1 expected refinement info
     );
@@ -192,8 +207,8 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
 
     // same test, but nested in a terms facet
     doTestRefine("{top:{type:terms, field:Afield, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }",
-        "{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }",
-        "{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }",
+        "{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}], more:true} } ] } }",
+        "{top: {buckets:[{val:'A', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}], more:true} } ] } }",
         null,
         "=={top: {" +
             "_s:[  ['A' , {x:{_l:[x1]}} ]  ]" +
@@ -203,8 +218,8 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
 
     // same test, but nested in range facet
     doTestRefine("{top:{type:range, field:R, start:0, end:1, gap:1, facet:{x : {type:terms, field:X, limit:2, refine:true} } } }",
-        "{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }",
-        "{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }",
+        "{top: {buckets:[{val:0, count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ] } }",
+        "{top: {buckets:[{val:0, count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ] } }",
         null,
         "=={top: {" +
             "_s:[  [0 , {x:{_l:[x1]}} ]  ]" +
@@ -214,8 +229,8 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
 
     // for testing partial _p, we need a partial facet within a partial facet
     doTestRefine("{top:{type:terms, field:Afield, refine:true, limit:1, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }",
-        "{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}]} } ] } }",
-        "{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} } ] } }",
+        "{top: {buckets:[{val:'A', count:2, x:{buckets:[{val:x1, count:5},{val:x2, count:3}],more:true} } ],more:true } }",
+        "{top: {buckets:[{val:'B', count:1, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} } ],more:true } }",
         null,
         "=={top: {" +
             "_p:[  ['A' , {x:{_l:[x1]}} ]  ]" +
@@ -225,8 +240,8 @@ public class TestJsonFacetRefinement extends SolrTestCaseHS {
 
     // test partial _p under a missing bucket
     doTestRefine("{top:{type:terms, field:Afield, refine:true, limit:1, missing:true, facet:{x : {type:terms, field:X, limit:1, refine:true} } } }",
-        "{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}]} }  } }",
-        "{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}]} }  } }",
+        "{top: {buckets:[], missing:{count:12, x:{buckets:[{val:x2, count:4},{val:x3, count:2}],more:true} }  } }",
+        "{top: {buckets:[], missing:{count:10, x:{buckets:[{val:x1, count:5},{val:x4, count:3}],more:true} }  } }",
         "=={top: {" +
             "missing:{x:{_l:[x1]}}" +
             "    }  " +
diff --git a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets.java b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets.java
index e19bb93b63f..ae556bd1f4a 100644
--- a/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets.java
+++ b/solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets.java
@@ -796,6 +796,7 @@ public class TestJsonFacets extends SolrTestCaseHS {
   }
 
   public static void doStatsTemplated(Client client, ModifiableSolrParams p) throws Exception {
+    int numShards = client.local() ? 1 : client.getClientProvider().all().size();
     p.set("Z_num_i", "Z_" + p.get("num_i") );
     p.set("Z_num_l", "Z_" + p.get("num_l") );
     p.set("sparse_num_d", "sparse_" + p.get("num_d") );
@@ -1969,6 +1970,33 @@ public class TestJsonFacets extends SolrTestCaseHS {
     }
     //////////////////////////////////////////////////////////////// end phase testing
 
+    //
+    // Refinement should not be needed to get exact results here, so this tests that
+    // extra refinement requests are not sent out.  This currently relies on counting the number of times
+    // debug() aggregation is parsed... which is somewhat fragile.  Please replace this with something
+    // better in the future - perhaps debug level info about number of refinements or additional facet phases.
+    //
+    for (String facet_field : new String[]{cat_s,where_s,num_d,num_i,num_is,num_fs,super_s,date,val_b,multi_ss}) {
+      ModifiableSolrParams test = params(p, "q", "id:(1 2)", "facet_field",facet_field, "debug", "true"
+          , "json.facet", "{ " +
+              " f1:{type:terms, field:'${facet_field}',  refine:${refine},  facet:{x:'debug()'}   }" +
+              ",f2:{type:terms, method:dvhash, field:'${facet_field}',  refine:${refine},  facet:{x:'debug()'}   }" +
+              ",f3:{type:terms, field:'${facet_field}',  refine:${refine},  facet:{x:'debug()',  y:{type:terms,field:'${facet_field}',refine:${refine}}}   }" +  // facet within facet
+              " }"
+      );
+      long startParses = DebugAgg.parses.get();
+      client.testJQ(params(test, "refine", "false")
+          , "facets==" + ""
+      );
+      long noRefineParses = DebugAgg.parses.get() - startParses;
+
+      startParses = DebugAgg.parses.get();
+      client.testJQ(params(test, "refine", "true")
+          , "facets==" + ""
+      );
+      long refineParses = DebugAgg.parses.get() - startParses;
+      assertEquals(noRefineParses, refineParses);
+    }
 
 
   }
