diff --git a/solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java b/solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java
index fc61d1894a2..b58da55859a 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java
@@ -267,7 +267,7 @@ public class HttpShardHandler extends ShardHandler {
     // Synchronize on canceled, so that we know precisely whether to add it to the responseFutureMap
     // or not.
     synchronized (canceled) {
-      if (canceled.get()) {
+      if (canceled.get() && !future.isDone()) {
         future.cancel(true);
         return;
       } else {
@@ -335,7 +335,17 @@ public class HttpShardHandler extends ShardHandler {
           responses.clear();
 
           // We want to return the last response we received, if possible
-          return previousResponse;
+          if (previousResponse == null) {
+            return null;
+          } else {
+            // If we have been canceled, return a response from this request that has an exception,
+            // since that is the contract of the method.
+            // Otherwise return the last response that we processed.
+            return previousResponse.getShardRequest().responses.stream()
+                .filter(sr -> sr.getException() != null)
+                .findFirst()
+                .orElse(previousResponse);
+          }
         } else {
           responseFutureMap.remove(rsp);
 
diff --git a/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java b/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
index 14f718ca2a1..1352164883f 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
@@ -37,6 +37,8 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
@@ -630,10 +632,17 @@ public class SearchHandler extends RequestHandlerBase
               rsp.setPartialResults(rb.req);
             }
             // Was there an exception?
-            if (srsp.getException() != null) {
+            // In the case of tolerant search, we need to check all responses to see if there was an
+            // exception.
+            Optional<Throwable> shardException =
+                srsp.getShardRequest().responses.stream()
+                    .map(ShardResponse::getException)
+                    .filter(Objects::nonNull)
+                    .findFirst();
+            if (shardException.isPresent()) {
               // If things are not tolerant, abort everything and rethrow
               if (!tolerant) {
-                throwSolrException(srsp.getException());
+                throwSolrException(shardException.get());
               } else {
                 // Check if the purpose includes 'PURPOSE_GET_TOP_IDS'
                 boolean includesTopIdsPurpose =
@@ -646,7 +655,7 @@ public class SearchHandler extends RequestHandlerBase
                 boolean allShardsFailed = includesTopIdsPurpose && allResponsesHaveExceptions;
                 // if all shards fail, fail the request despite shards.tolerant
                 if (allShardsFailed) {
-                  throwSolrException(srsp.getException());
+                  throwSolrException(shardException.get());
                 } else {
                   rsp.setPartialResults(rb.req);
                   if (publishCpuTime) {
