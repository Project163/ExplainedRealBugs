diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index d2788215401..519852ea5f7 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -129,6 +129,8 @@ Bug Fixes
 
 * SOLR-10101: TestLazyCores hangs (Erick Erickson)
 
+* SOLR-11332: Fix sorting on 'enum' fieldTypes that use sortMissingFirst or sortMissingLast (hossman)
+
 Optimizations
 ----------------------
 
@@ -199,6 +201,8 @@ Other Changes
 
 * SOLR-10990: Breakup QueryComponent.process method for readability. (Christine Poerschke)
 
+* SOLR-11132: Refactor common getSortField logic in various FieldTypes (Jason Gerlowski, hossman)
+
 ==================  7.0.0 ==================
 
 Versions of Major Components
diff --git a/solr/core/src/java/org/apache/solr/schema/AbstractEnumField.java b/solr/core/src/java/org/apache/solr/schema/AbstractEnumField.java
index 1111cec3d5e..d4ce2680454 100644
--- a/solr/core/src/java/org/apache/solr/schema/AbstractEnumField.java
+++ b/solr/core/src/java/org/apache/solr/schema/AbstractEnumField.java
@@ -250,11 +250,12 @@ public abstract class AbstractEnumField extends PrimitiveFieldType {
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-    final Object missingValue = Integer.MIN_VALUE;
-    SortField sf = new SortField(field.getName(), SortField.Type.INT, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    SortField result = getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);
+    if (null == result.getMissingValue()) {
+      // special case default behavior: assume missing values are "below" all enum values
+      result.setMissingValue(Integer.MIN_VALUE);
+    }
+    return result;
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/DatePointField.java b/solr/core/src/java/org/apache/solr/schema/DatePointField.java
index e43f70639f6..48619171548 100644
--- a/solr/core/src/java/org/apache/solr/schema/DatePointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DatePointField.java
@@ -190,20 +190,7 @@ public class DatePointField extends PointField implements DateValueFieldType {
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-
-    Object missingValue = null;
-    boolean sortMissingLast = field.sortMissingLast();
-    boolean sortMissingFirst = field.sortMissingFirst();
-
-    if (sortMissingLast) {
-      missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;
-    } else if (sortMissingFirst) {
-      missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;
-    }
-    SortField sf = new SortField(field.getName(), SortField.Type.LONG, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/DoublePointField.java b/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
index edc7c381d9c..ba71a8aeada 100644
--- a/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DoublePointField.java
@@ -134,20 +134,7 @@ public class DoublePointField extends PointField implements DoubleValueFieldType
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-
-    Object missingValue = null;
-    boolean sortMissingLast = field.sortMissingLast();
-    boolean sortMissingFirst = field.sortMissingFirst();
-
-    if (sortMissingLast) {
-      missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
-    } else if (sortMissingFirst) {
-      missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
-    }
-    SortField sf = new SortField(field.getName(), SortField.Type.DOUBLE, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/FieldType.java b/solr/core/src/java/org/apache/solr/schema/FieldType.java
index 3d38844d482..5494cf11080 100644
--- a/solr/core/src/java/org/apache/solr/schema/FieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/FieldType.java
@@ -48,6 +48,7 @@ import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.SortedSetSortField;
 import org.apache.lucene.search.SortedNumericSelector;
 import org.apache.lucene.search.SortedSetSelector;
 import org.apache.lucene.search.TermInSetQuery;
@@ -69,7 +70,6 @@ import org.apache.solr.query.SolrRangeQuery;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.QueryUtils;
-import org.apache.solr.search.Sorting;
 import org.apache.solr.uninverting.UninvertingReader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -662,17 +662,76 @@ public abstract class FieldType extends FieldProperties {
    * Returns the SortField instance that should be used to sort fields
    * of this type.
    * @see SchemaField#checkSortability
+   * @see #getSortField(SchemaField,SortField.Type,boolean,Object,Object)
    */
   public abstract SortField getSortField(SchemaField field, boolean top);
 
+  /**
+   * <p>A Helper utility method for use by subclasses.</p>
+   * <p>This method deals with:</p>
+   * <ul>
+   *  <li>{@link SchemaField#checkSortability}</li>
+   *  <li>Creating a {@link SortField} on <code>field</code> with the specified 
+   *      <code>reverse</code> &amp; <code>sortType</code></li>
+   *  <li>Setting the {@link SortField#setMissingValue} to <code>missingLow</code> or <code>missingHigh</code>
+   *      as appropriate based on the value of <code>reverse</code> and the 
+   *      <code>sortMissingFirst</code> &amp; <code>sortMissingLast</code> properties of the 
+   *      <code>field</code></li>
+   * </ul>
+   *
+   * @param field The SchemaField to sort on.  May use <code>sortMissingFirst</code> or <code>sortMissingLast</code> or neither.
+   * @param sortType The sort Type of the underlying values in the <code>field</code>
+   * @param reverse True if natural order of the <code>sortType</code> should be reversed
+   * @param missingLow The <code>missingValue</code> to be used if the other params indicate that docs w/o values should sort as "low" as possible.
+   * @param missingHigh The <code>missingValue</code> to be used if the other params indicate that docs w/o values should sort as "high" as possible.
+   * @see #getSortedSetSortField
+   */
+  protected static SortField getSortField(SchemaField field, SortField.Type sortType, boolean reverse,
+                                          Object missingLow, Object missingHigh) {
+    field.checkSortability();
+
+    SortField sf = new SortField(field.getName(), sortType, reverse);
+    applySetMissingValue(field, sf, missingLow, missingHigh);
+    
+    return sf;
+  }
+
+  /**
+   * Same as {@link #getSortField} but using {@link SortedSetSortField}
+   */
+  protected static SortField getSortedSetSortField(SchemaField field, SortedSetSelector.Type selector,
+                                                   boolean reverse, Object missingLow, Object missingHigh) {
+                                                   
+    field.checkSortability();
+
+    SortField sf = new SortedSetSortField(field.getName(), reverse, selector);
+    applySetMissingValue(field, sf, missingLow, missingHigh);
+    
+    return sf;
+  }
+  
+  /** 
+   * @see #getSortField 
+   * @see #getSortedSetSortField 
+   */
+  private static void applySetMissingValue(SchemaField field, SortField sortField, 
+                                           Object missingLow, Object missingHigh) {
+    final boolean reverse = sortField.getReverse();
+    
+    if (field.sortMissingLast()) {
+      sortField.setMissingValue(reverse ? missingLow : missingHigh);
+    } else if (field.sortMissingFirst()) {
+      sortField.setMissingValue(reverse ? missingHigh : missingLow);
+    }
+  }
+
   /**
    * Utility usable by subclasses when they want to get basic String sorting
    * using common checks.
    * @see SchemaField#checkSortability
    */
   protected SortField getStringSort(SchemaField field, boolean reverse) {
-    field.checkSortability();
-    return Sorting.getStringSortField(field.name, reverse, field.sortMissingLast(),field.sortMissingFirst());
+    return getSortField(field, SortField.Type.STRING, reverse, SortField.STRING_FIRST, SortField.STRING_LAST);
   }
 
   /** called to get the default value source (normally, from the
diff --git a/solr/core/src/java/org/apache/solr/schema/FloatPointField.java b/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
index c70655ad26b..f69a1dbdac1 100644
--- a/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/FloatPointField.java
@@ -134,20 +134,7 @@ public class FloatPointField extends PointField implements FloatValueFieldType {
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-
-    Object missingValue = null;
-    boolean sortMissingLast = field.sortMissingLast();
-    boolean sortMissingFirst = field.sortMissingFirst();
-
-    if (sortMissingLast) {
-      missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;
-    } else if (sortMissingFirst) {
-      missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
-    }
-    SortField sf = new SortField(field.getName(), SortField.Type.FLOAT, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/IntPointField.java b/solr/core/src/java/org/apache/solr/schema/IntPointField.java
index d5e4aec1423..b179c573e8d 100644
--- a/solr/core/src/java/org/apache/solr/schema/IntPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/IntPointField.java
@@ -132,20 +132,7 @@ public class IntPointField extends PointField implements IntValueFieldType {
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-
-    Object missingValue = null;
-    boolean sortMissingLast = field.sortMissingLast();
-    boolean sortMissingFirst = field.sortMissingFirst();
-
-    if (sortMissingLast) {
-      missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;
-    } else if (sortMissingFirst) {
-      missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;
-    }
-    SortField sf = new SortField(field.getName(), SortField.Type.INT, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/LongPointField.java b/solr/core/src/java/org/apache/solr/schema/LongPointField.java
index 7e3f5e19825..547725bfc3e 100644
--- a/solr/core/src/java/org/apache/solr/schema/LongPointField.java
+++ b/solr/core/src/java/org/apache/solr/schema/LongPointField.java
@@ -131,20 +131,7 @@ public class LongPointField extends PointField implements LongValueFieldType {
 
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-
-    Object missingValue = null;
-    boolean sortMissingLast = field.sortMissingLast();
-    boolean sortMissingFirst = field.sortMissingFirst();
-
-    if (sortMissingLast) {
-      missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;
-    } else if (sortMissingFirst) {
-      missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;
-    }
-    SortField sf = new SortField(field.getName(), SortField.Type.LONG, top);
-    sf.setMissingValue(missingValue);
-    return sf;
+    return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
index d2dc811d02a..f5affe147f5 100644
--- a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
+++ b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
@@ -34,13 +34,13 @@ import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.SortedSetFieldSource;
 import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.SortedSetSelector;
 import org.apache.lucene.util.AttributeFactory;
 import org.apache.lucene.util.AttributeSource.State;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.solr.analysis.SolrAnalyzer;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.Sorting;
 import org.apache.solr.uninverting.UninvertingReader.Type;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -132,8 +132,8 @@ public class PreAnalyzedField extends TextField implements HasImplicitIndexAnaly
   
   @Override
   public SortField getSortField(SchemaField field, boolean top) {
-    field.checkSortability();
-    return Sorting.getTextSortField(field.getName(), top, field.sortMissingLast(), field.sortMissingFirst());
+    return getSortedSetSortField(field, SortedSetSelector.Type.MIN, top,
+                                 SortField.STRING_FIRST, SortField.STRING_LAST);
   }
   
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/TextField.java b/solr/core/src/java/org/apache/solr/schema/TextField.java
index d8bae24df6e..effadc40cae 100644
--- a/solr/core/src/java/org/apache/solr/schema/TextField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TextField.java
@@ -32,7 +32,6 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.query.SolrRangeQuery;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.Sorting;
 import org.apache.solr.uninverting.UninvertingReader.Type;
 
 /** <code>TextField</code> is the basic type for configurable text analysis.
@@ -108,8 +107,8 @@ public class TextField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field, boolean reverse) {
     /* :TODO: maybe warn if isTokenized(), but doesn't use LimitTokenCountFilter in its chain? */
-    field.checkSortability();
-    return Sorting.getTextSortField(field.getName(), reverse, field.sortMissingLast(), field.sortMissingFirst());
+    return getSortedSetSortField(field, SortedSetSelector.Type.MIN, reverse,
+                                 SortField.STRING_FIRST, SortField.STRING_LAST);
   }
   
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieField.java b/solr/core/src/java/org/apache/solr/schema/TrieField.java
index 9e57159c2a4..ebe21033056 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -171,50 +171,14 @@ public class TrieField extends NumericFieldType {
 
     switch (type) {
       case INTEGER:
-        if( sortMissingLast ) {
-          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;
-        }
-        else if( sortMissingFirst ) {
-          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;
-        }
-        sf = new SortField( field.getName(), SortField.Type.INT, top);
-        sf.setMissingValue(missingValue);
-        return sf;
-      
+        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);
       case FLOAT:
-        if( sortMissingLast ) {
-          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;
-        }
-        else if( sortMissingFirst ) {
-          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
-        }
-        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);
-        sf.setMissingValue(missingValue);
-        return sf;
-      
+        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);
       case DATE: // fallthrough
       case LONG:
-        if( sortMissingLast ) {
-          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;
-        }
-        else if( sortMissingFirst ) {
-          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;
-        }
-        sf = new SortField( field.getName(), SortField.Type.LONG, top);
-        sf.setMissingValue(missingValue);
-        return sf;
-        
+        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);
       case DOUBLE:
-        if( sortMissingLast ) {
-          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
-        }
-        else if( sortMissingFirst ) {
-          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
-        }
-        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);
-        sf.setMissingValue(missingValue);
-        return sf;
-        
+        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
       default:
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + field.name);
     }
diff --git a/solr/core/src/java/org/apache/solr/search/Sorting.java b/solr/core/src/java/org/apache/solr/search/Sorting.java
index 8bb217111b5..c23b55895ec 100644
--- a/solr/core/src/java/org/apache/solr/search/Sorting.java
+++ b/solr/core/src/java/org/apache/solr/search/Sorting.java
@@ -16,15 +16,16 @@
  */
 package org.apache.solr.search;
 
+import org.apache.solr.schema.FieldType;
 import org.apache.lucene.search.*;
 
 /**
  * Extra lucene sorting utilities &amp; convenience methods
  *
  *
- *
+ * @deprecated custom {@link FieldType}s should use the helper methods in the base class.  Other usage should leverage th underling lucene {@link SortField} classes directly.
  */
-
+@Deprecated
 public class Sorting {
 
 
@@ -37,14 +38,19 @@ public class Sorting {
    * @param nullLast    true if null should come last, regardless of sort order
    * @param nullFirst   true if null should come first, regardless of sort order
    * @return SortField
+   * @deprecated custom {@link FieldType}s should use {@link FieldType#getSortField}.  Other usage should leverage th underling lucene {@link SortField} classes directly.
    */
+  @Deprecated
   public static SortField getStringSortField(String fieldName, boolean reverse, boolean nullLast, boolean nullFirst) {
     SortField sortField = new SortField(fieldName, SortField.Type.STRING, reverse);
     applyMissingFirstLast(sortField, reverse, nullLast, nullFirst);
     return sortField;
   }
 
-  /** Like {@link #getStringSortField}) except safe for tokenized fields */
+  /** Like {@link #getStringSortField}) except safe for tokenized fields
+   * @deprecated custom {@link FieldType}s should use {@link FieldType#getSortedSetSortField}.  Other usage should leverage th underling lucene {@link SortedSetSortField} classes directly.
+   */
+  @Deprecated
   public static SortField getTextSortField(String fieldName, boolean reverse, boolean nullLast, boolean nullFirst) {
     SortField sortField = new SortedSetSortField(fieldName, reverse);
     applyMissingFirstLast(sortField, reverse, nullLast, nullFirst);
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml b/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
index 29bede8ee40..2443da4e125 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-enums.xml
@@ -18,12 +18,22 @@
 <schema name="tiny" version="1.1">
   <field name="id" type="string" indexed="true" stored="true" required="true"/>
   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+  
   <!-- Test EnumField and EnumFieldType -->
   <field name="severity" type="severityType" indexed="${solr.tests.EnumFieldTest.indexed}" stored="true" multiValued="false" docValues="${solr.tests.numeric.dv}"/>
+  <!-- NOTE: because these test sortMissingLast/sortMissingFirst, we force indexed="true" so we don't get
+       random errors on schema init about inconsistent properties -->
+  <field name="severity_missingLast" type="severityType" indexed="true" stored="true" multiValued="false" docValues="${solr.tests.numeric.dv}" sortMissingLast="true"/>
+  <field name="severity_missingFirst" type="severityType" indexed="true" stored="true" multiValued="false" docValues="${solr.tests.numeric.dv}" sortMissingFirst="true"/>
+  
   <field name="severity_mv" type="severityType" indexed="${solr.tests.EnumFieldTest.indexed}" stored="true" multiValued="true" docValues="${solr.tests.numeric.dv}"/>
   <field name="text" type="text" indexed="true" stored="true" multiValued="true"/>
+  
   <uniqueKey>id</uniqueKey>
 
+  <copyField source="severity" dest="severity_missingLast" />
+  <copyField source="severity" dest="severity_missingFirst" />
+  
   <fieldType name="text" class="solr.TextField">
     <analyzer>
       <tokenizer class="solr.WhitespaceTokenizerFactory"/>
diff --git a/solr/core/src/test/org/apache/solr/schema/EnumFieldTest.java b/solr/core/src/test/org/apache/solr/schema/EnumFieldTest.java
index d01c57f3730..98e55fad6fe 100644
--- a/solr/core/src/test/org/apache/solr/schema/EnumFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/EnumFieldTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.solr.schema;
 
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -385,6 +386,21 @@ public class EnumFieldTest extends SolrTestCaseJ4 {
             "//doc[4]/str[@name='" + FIELD_NAME + "']/text()='High'",
             "//doc[5]/str[@name='" + FIELD_NAME + "']/text()='Critical'"
     );
+
+    // missing first....
+    for (String dir : Arrays.asList("asc", "desc")) {
+      assertQ(req("fl", "id", "q", "*:*", "sort", FIELD_NAME + "_missingFirst " + dir + ", id desc")
+              , "//doc[1]/str[@name='id']/text()='9'"
+              , "//doc[2]/str[@name='id']/text()='8'"
+              );
+    }
+    // missing last...
+    for (String dir : Arrays.asList("asc", "desc")) {
+      assertQ(req("fl", "id", "q", "*:*", "sort", FIELD_NAME + "_missingLast " + dir + ", id desc")
+              , "//doc[6]/str[@name='id']/text()='9'"
+              , "//doc[7]/str[@name='id']/text()='8'"
+              );
+    }
   }
 
   @Test
diff --git a/solr/core/src/test/org/apache/solr/search/TestSort.java b/solr/core/src/test/org/apache/solr/search/TestSort.java
index 18597dcd40a..eb3fd00cb6b 100644
--- a/solr/core/src/test/org/apache/solr/search/TestSort.java
+++ b/solr/core/src/test/org/apache/solr/search/TestSort.java
@@ -271,9 +271,9 @@ public class TestSort extends SolrTestCaseJ4 {
 
         if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));
         // hit both use-cases of sort-missing-last
-        sfields.add( Sorting.getStringSortField("f", reverse, sortMissingLast, sortMissingFirst) );
+        sfields.add( getStringSortField("f", reverse, sortMissingLast, sortMissingFirst) );
         if (secondary) {
-          sfields.add( Sorting.getStringSortField("f2", reverse2, sortMissingLast2, sortMissingFirst2) );
+          sfields.add( getStringSortField("f2", reverse2, sortMissingLast2, sortMissingFirst2) );
         }
         if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));
 
@@ -355,5 +355,20 @@ public class TestSort extends SolrTestCaseJ4 {
     return new BitDocIdSet(obs);
   }  
   
-
+  private static SortField getStringSortField(String fieldName, boolean reverse, boolean nullLast, boolean nullFirst) {
+    SortField sortField = new SortField(fieldName, SortField.Type.STRING, reverse);
+    
+    // 4 cases:
+    // missingFirst / forward: default lucene behavior
+    // missingFirst / reverse: set sortMissingLast
+    // missingLast  / forward: set sortMissingLast
+    // missingLast  / reverse: default lucene behavior
+    
+    if (nullFirst && reverse) {
+      sortField.setMissingValue(SortField.STRING_LAST);
+    } else if (nullLast && !reverse) {
+      sortField.setMissingValue(SortField.STRING_LAST);
+    }
+    return sortField;
+  }
 }
