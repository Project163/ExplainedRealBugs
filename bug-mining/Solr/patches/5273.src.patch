diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 28a44d546aa..6980b8678be 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -263,6 +263,8 @@ Bug Fixes
 
 * SOLR-17717: Starting solr on newer Windows 11 Home complained about missing wmic (Jan HÃ¸ydahl)
 
+* SOLR-17740: When the V2 API is receiving raw files, it could sometimes skip the first byte. (David Smiley)
+
 Dependency Upgrades
 ---------------------
 * SOLR-17471: Upgrade Lucene to 9.12.1. (Pierre Salagnac, Christine Poerschke)
diff --git a/solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers.java b/solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers.java
index d208106c874..ee2aa66a468 100644
--- a/solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers.java
+++ b/solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers.java
@@ -21,7 +21,6 @@ import static org.apache.solr.common.params.CommonParams.PATH;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.PushbackInputStream;
 import java.lang.invoke.MethodHandles;
 import java.net.URI;
 import java.nio.ByteBuffer;
@@ -39,8 +38,8 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.servlet.MultipartConfigElement;
-import javax.servlet.ServletInputStream;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.Part;
 import org.apache.commons.io.input.CloseShieldInputStream;
@@ -596,26 +595,21 @@ public class SolrRequestParsers {
 
   /** The raw parser just uses the params directly */
   static class RawRequestParser implements SolrRequestParser {
+
+    // Methods that shouldn't have a body according to HTTP spec
+    private static Set<String> NO_BODY_METHODS = Set.of("GET", "HEAD", "DELETE");
+
     @Override
     public SolrParams parseParamsAndFillStreams(
         final HttpServletRequest req, ArrayList<ContentStream> streams) throws Exception {
-      // If we wrongly add a stream that actually has no content, then it can confuse
-      //  some of our code that sees a stream but has no content-type.
-      // If we wrongly don't add a stream, then obviously we'll miss data.
-      final ServletInputStream inputStream = req.getInputStream(); // don't close it
-      if (req.getContentLengthLong() >= 0
+      if (req.getContentLengthLong() > 0
           || req.getHeader("Transfer-Encoding") != null
-          || inputStream.available() > 0) {
-        streams.add(new HttpRequestContentStream(req, inputStream));
-      } else if (!req.getMethod().equals("GET")) { // GET shouldn't have data
-        // We're not 100% sure there is no data, so check by reading a byte (and put back).
-        PushbackInputStream pbInputStream = new PushbackInputStream(inputStream);
-        int b = pbInputStream.read();
-        if (b != -1) {
-          pbInputStream.unread(b); // put back
-          streams.add(new HttpRequestContentStream(req, pbInputStream));
-        }
+          || !NO_BODY_METHODS.contains(req.getMethod())) {
+        // If Content-Length > 0 OR Transfer-Encoding exists OR
+        // it's a method that can have a body (POST/PUT/PATCH etc)
+        streams.add(new HttpRequestContentStream(req, req.getInputStream()));
       }
+
       return parseQueryString(req.getQueryString());
     }
   }
