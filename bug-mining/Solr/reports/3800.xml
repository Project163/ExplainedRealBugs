<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 04:30:55 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-8327] SolrDispatchFilter is not caching new state format, which results in live fetch from ZK per request if node does not contain core from collection</title>
                <link>https://issues.apache.org/jira/browse/SOLR-8327</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;While perf testing with non-solrj client (request can be sent to any solr node), we noticed a huge amount of data from Zookeeper in our tcpdump (~1G for 20 second dump). From the thread dump, we noticed this:&lt;/p&gt;

&lt;p&gt;java.lang.Object.wait (Native Method)&lt;br/&gt;
java.lang.Object.wait (Object.java:503)&lt;br/&gt;
org.apache.zookeeper.ClientCnxn.submitRequest (ClientCnxn.java:1309)&lt;br/&gt;
org.apache.zookeeper.ZooKeeper.getData (ZooKeeper.java:1152)&lt;br/&gt;
org.apache.solr.common.cloud.SolrZkClient$7.execute (SolrZkClient.java:345)&lt;br/&gt;
org.apache.solr.common.cloud.SolrZkClient$7.execute (SolrZkClient.java:342)&lt;br/&gt;
org.apache.solr.common.cloud.ZkCmdExecutor.retryOperation (ZkCmdExecutor.java:61)&lt;br/&gt;
org.apache.solr.common.cloud.SolrZkClient.getData (SolrZkClient.java:342)&lt;br/&gt;
org.apache.solr.common.cloud.ZkStateReader.getCollectionLive (ZkStateReader.java:841)&lt;br/&gt;
org.apache.solr.common.cloud.ZkStateReader$7.get (ZkStateReader.java:515)&lt;br/&gt;
org.apache.solr.common.cloud.ClusterState.getCollectionOrNull (ClusterState.java:175)&lt;br/&gt;
org.apache.solr.common.cloud.ClusterState.getLeader (ClusterState.java:98)&lt;br/&gt;
org.apache.solr.servlet.HttpSolrCall.getCoreByCollection (HttpSolrCall.java:784)&lt;br/&gt;
org.apache.solr.servlet.HttpSolrCall.init (HttpSolrCall.java:272)&lt;br/&gt;
org.apache.solr.servlet.HttpSolrCall.call (HttpSolrCall.java:417)&lt;br/&gt;
org.apache.solr.servlet.SolrDispatchFilter.doFilter (SolrDispatchFilter.java:210)&lt;br/&gt;
org.apache.solr.servlet.SolrDispatchFilter.doFilter (SolrDispatchFilter.java:179)&lt;br/&gt;
org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter (ServletHandler.java:1652)&lt;br/&gt;
org.eclipse.jetty.servlet.ServletHandler.doHandle (ServletHandler.java:585)&lt;br/&gt;
org.eclipse.jetty.server.handler.ScopedHandler.handle (ScopedHandler.java:143)&lt;br/&gt;
org.eclipse.jetty.security.SecurityHandler.handle (SecurityHandler.java:577)&lt;br/&gt;
org.eclipse.jetty.server.session.SessionHandler.doHandle (SessionHandler.java:223)&lt;br/&gt;
org.eclipse.jetty.server.handler.ContextHandler.doHandle (ContextHandler.java:1127)&lt;br/&gt;
org.eclipse.jetty.servlet.ServletHandler.doScope (ServletHandler.java:515)&lt;br/&gt;
org.eclipse.jetty.server.session.SessionHandler.doScope (SessionHandler.java:185)&lt;br/&gt;
org.eclipse.jetty.server.handler.ContextHandler.doScope (ContextHandler.java:1061)&lt;br/&gt;
org.eclipse.jetty.server.handler.ScopedHandler.handle (ScopedHandler.java:141)&lt;br/&gt;
org.eclipse.jetty.server.handler.ContextHandlerCollection.handle (ContextHandlerCollection.java:215)&lt;br/&gt;
org.eclipse.jetty.server.handler.HandlerCollection.handle (HandlerCollection.java:110)&lt;br/&gt;
org.eclipse.jetty.server.handler.HandlerWrapper.handle (HandlerWrapper.java:97)&lt;br/&gt;
org.eclipse.jetty.server.Server.handle (Server.java:499)&lt;br/&gt;
org.eclipse.jetty.server.HttpChannel.handle (HttpChannel.java:310)&lt;br/&gt;
org.eclipse.jetty.server.HttpConnection.onFillable (HttpConnection.java:257)&lt;br/&gt;
org.eclipse.jetty.io.AbstractConnection$2.run (AbstractConnection.java:540)&lt;br/&gt;
org.eclipse.jetty.util.thread.QueuedThreadPool.runJob (QueuedThreadPool.java:635)&lt;br/&gt;
org.eclipse.jetty.util.thread.QueuedThreadPool$3.run (QueuedThreadPool.java:555)&lt;br/&gt;
java.lang.Thread.run (Thread.java:745)&lt;/p&gt;

&lt;p&gt;Looks like SolrDispatchFilter doesn&apos;t have caching similar to the collectionStateCache in CloudSolrClient, so if the node doesn&apos;t know about a collection in the new state format, it just live-fetch it from Zookeeper on every request.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12914963">SOLR-8327</key>
            <summary>SolrDispatchFilter is not caching new state format, which results in live fetch from ZK per request if node does not contain core from collection</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ichattopadhyaya">Ishan Chattopadhyaya</assignee>
                                    <reporter username="mewmewball">Jessica Cheng Mallet</reporter>
                        <labels>
                            <label>solrcloud</label>
                    </labels>
                <created>Fri, 20 Nov 2015 19:47:20 +0000</created>
                <updated>Thu, 21 Nov 2019 00:41:38 +0000</updated>
                            <resolved>Sun, 25 Feb 2018 06:28:51 +0000</resolved>
                                    <version>5.3</version>
                                    <fixVersion>7.3</fixVersion>
                    <fixVersion>8.0</fixVersion>
                                    <component>SolrCloud</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="1200">20m</timespent>
                                <comments>
                            <comment id="15207019" author="dragonsinth" created="Tue, 22 Mar 2016 18:48:00 +0000"  >&lt;p&gt;There&apos;s a TODO in LazyCollectionRef:&lt;/p&gt;

&lt;p&gt;// TODO: consider limited caching&lt;/p&gt;

&lt;p&gt;I think the right answer here is that LazyCollectionRef would need to keep the last version fetched in memory, and probably set a watch in case the data changes.  The watch would simply invalidate the cache without refetching the data.  Thoughts?  I could take this one.&lt;/p&gt;</comment>
                            <comment id="15207038" author="noble.paul" created="Tue, 22 Mar 2016 18:55:15 +0000"  >&lt;p&gt;I don&apos;t think adding a watch for lazy collection ref is a good idea. We needed to minimize the number of watches for achieving scalability. The solution employed in solrj is very efficient. We can replicate the same logic here as well&lt;/p&gt;</comment>
                            <comment id="15207072" author="dragonsinth" created="Tue, 22 Mar 2016 19:12:41 +0000"  >&lt;p&gt;What does solrj do? How do you know when the cached data is stale?&lt;/p&gt;</comment>
                            <comment id="15207083" author="varunthacker" created="Tue, 22 Mar 2016 19:19:43 +0000"  >&lt;p&gt;Hi Scott,&lt;/p&gt;

&lt;p&gt;This is what I understand what CloudSolrClient does for caching -&lt;/p&gt;

&lt;p&gt;There is a in memory map {[Map&amp;lt;String, ExpiringCachedDocCollection&amp;gt; collectionStateCache}} . Now on every request it attaches the state versions from this cached map ( the collections that were referenced in the request )  by passing the &lt;tt&gt;STATE_VERSION&lt;/tt&gt; param. This code is in the &lt;tt&gt;CloudSolrClient#requestWithRetryOnStaleState&lt;/tt&gt; method.&lt;/p&gt;

&lt;p&gt;The server in the response will send back state versions if it does not match the one sent by the client. So the client will update it&apos;s local copy based on this information. &lt;/p&gt;</comment>
                            <comment id="15207085" author="noble.paul" created="Tue, 22 Mar 2016 19:21:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dragonsinth&quot; class=&quot;user-hover&quot; rel=&quot;dragonsinth&quot;&gt;dragonsinth&lt;/a&gt; Please refer to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-5474&quot; title=&quot;Add  stateFormat=2 support to CloudSolrServer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-5474&quot;&gt;&lt;del&gt;SOLR-5474&lt;/del&gt;&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-7130&quot; title=&quot;Make stale state notification work without failing the requests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-7130&quot;&gt;&lt;del&gt;SOLR-7130&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15207112" author="dragonsinth" created="Tue, 22 Mar 2016 19:34:04 +0000"  >&lt;p&gt;Thanks for the extra context.  So it looks like this falls outside the scope of what ZkStateReader wants to do, since you want context-sensitive caching.&lt;/p&gt;</comment>
                            <comment id="15207115" author="noble.paul" created="Tue, 22 Mar 2016 19:37:11 +0000"  >&lt;p&gt;Smart caching work flow is as follows&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;a request for a collection comes to solrj&lt;/li&gt;
	&lt;li&gt;look up in local cache . If not available read from ZK and populate local cache&lt;/li&gt;
	&lt;li&gt;make a request to the server optimistically assuming that the data in cache is latest. But send extra information as a request parameter (&amp;#95;stateVer_=&amp;lt;coll-name&amp;gt;:&amp;lt;zk-version-of-state.json-in-cache&amp;gt;)&lt;/li&gt;
	&lt;li&gt;at server. if this parameter is present, check locally if the version is correct . If this node serves this collection, it always has the latest state. So no ZK lookup is necessary&lt;/li&gt;
	&lt;li&gt;If the version at server is newer send the latest version of the state as a part of the payload&lt;/li&gt;
	&lt;li&gt;solrj looks for this  extra info in the payload. If there is no extra info, the state it has is the latest. nothing needs to be done. If the payload contains versions of the state, it means that the local version is stale, invalidate the cache&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="15207116" author="noble.paul" created="Tue, 22 Mar 2016 19:37:54 +0000"  >&lt;p&gt;you are right. It is not in the scope of &lt;tt&gt;ZkStateReader&lt;/tt&gt;&lt;/p&gt;</comment>
                            <comment id="15249540" author="varunthacker" created="Wed, 20 Apr 2016 09:16:04 +0000"  >&lt;p&gt;Patch which is still a work in progress.&lt;/p&gt;

&lt;p&gt;What is solves:&lt;br/&gt;
1. Caches the state when solr is hit directly and not queried via SolrJ&lt;br/&gt;
2. Caches when the &lt;tt&gt;&amp;amp;collection=collection1,collection2&lt;/tt&gt; param is used&lt;/p&gt;

&lt;p&gt;TODO&lt;br/&gt;
1. Cache invalidation when then  &lt;tt&gt;&amp;amp;collection=collection1,collection2&lt;/tt&gt; param is used . With this patch it would never invalidate it even if it has stale data&lt;br/&gt;
2. Tests&lt;/p&gt;
</comment>
                            <comment id="15250374" author="varunthacker" created="Wed, 20 Apr 2016 17:55:21 +0000"  >&lt;p&gt;Also the DistributedUpdateProcessor makes many calls to &lt;tt&gt;zkController.getClusterState().getCollection&lt;/tt&gt; . So for non-solrJ users I guess we need to cache at the DitributedUpdateProcessor as well so that update requests don&apos;t make multiple calls to ZK &lt;/p&gt;</comment>
                            <comment id="15250384" author="shalinmangar" created="Wed, 20 Apr 2016 18:00:38 +0000"  >&lt;p&gt;Varun, I am auditing all usages of ClusterState methods to ensure we don&apos;t end up going to ZK needlessly. See &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-9014&quot; title=&quot;Deprecate and reduce usage of ClusterState methods which may make calls to ZK via the lazy collection reference&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-9014&quot;&gt;&lt;del&gt;SOLR-9014&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15672391" author="erickerickson" created="Thu, 17 Nov 2016 01:57:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=shalin&quot; class=&quot;user-hover&quot; rel=&quot;shalin&quot;&gt;shalin&lt;/a&gt; Does &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-9014&quot; title=&quot;Deprecate and reduce usage of ClusterState methods which may make calls to ZK via the lazy collection reference&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-9014&quot;&gt;&lt;del&gt;SOLR-9014&lt;/del&gt;&lt;/a&gt; being fixed mean we can close this JIRA? I just happened across this while looking at something else and wondered.&lt;/p&gt;</comment>
                            <comment id="15672990" author="shalinmangar" created="Thu, 17 Nov 2016 07:01:28 +0000"  >&lt;p&gt;No, this is still very relevant. &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-9014&quot; title=&quot;Deprecate and reduce usage of ClusterState methods which may make calls to ZK via the lazy collection reference&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-9014&quot;&gt;&lt;del&gt;SOLR-9014&lt;/del&gt;&lt;/a&gt; was about ensuring that we don&apos;t repeatedly fetch the collection state from ZK in the context of the same request &amp;#8211; and admittedly, we&apos;re not quite there but better than before. This issue is about not going to ZK to fetch collection state for different requests because SolrDispatchFilter has no caching for collection states like the SolrJ client does.&lt;/p&gt;</comment>
                            <comment id="16297255" author="ichattopadhyaya" created="Tue, 19 Dec 2017 18:54:46 +0000"  >&lt;p&gt;I tested this today (dockerized Solr + TCPDump on ZK container) and confirm this still is still an open issue; I think Noble&apos;s proposal for &quot;smart caching&quot; (as used in CloudSolrClient) is the right solution here.&lt;/p&gt;</comment>
                            <comment id="16297371" author="dragonsinth" created="Tue, 19 Dec 2017 20:18:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16297372" author="githubbot" created="Tue, 19 Dec 2017 20:19:41 +0000"  >&lt;p&gt;Github user dragonsinth commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This approach seems fine to me.  Remind me why we use nanoTime vs. normal clock?  I&apos;m sure you&apos;re right I just want to refresh my brain.&lt;/p&gt;</comment>
                            <comment id="16297410" author="githubbot" created="Tue, 19 Dec 2017 20:51:18 +0000"  >&lt;p&gt;Github user elyograg commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Java programs are migrating to nanoTime instead of currentTimeMillis for elapsed time because many people have found that the latter will go &lt;b&gt;backwards&lt;/b&gt; on occasion.  It is not monotonic.&lt;/p&gt;

&lt;p&gt;    Using nanoTime should be far less likely to go backwards.  That undesirable behavior has been observed in the wild, but should be rare.  Supposedly nanoTime is monotonic if the OS properly supports a monotonic clock.  There&apos;s a lot of info out there about it:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://www.google.com/search?q=java+nanotime+monotonic&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.google.com/search?q=java+nanotime+monotonic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The fact that nanoTime &lt;b&gt;might&lt;/b&gt; produce elapsed times with greater accuracy than one millisecond is a bonus.&lt;/p&gt;</comment>
                            <comment id="16297445" author="ichattopadhyaya" created="Tue, 19 Dec 2017 21:20:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;This approach seems fine to me. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;My only concern with that solution is that within those 2 seconds (cache expiry time), the support for cache invalidation (in case of replicas being moved away from a node for example) is not there. I&apos;m not sure yet if that might lead to potentially failed queries/updates. With a &quot;smart caching&quot; &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, request re-tries (and subsequent cache refresh) can be built into the routing logic in case our-version-of-collection-state thinks the collection should be on a node, but it isn&apos;t. The other benefit with &quot;smart caching&quot; is that it doesn&apos;t rely on nodes to keep fetching the state from ZK every two seconds.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; - &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-8327?focusedCommentId=15207115&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15207115&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/SOLR-8327?focusedCommentId=15207115&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15207115&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16297495" author="githubbot" created="Tue, 19 Dec 2017 21:58:26 +0000"  >&lt;p&gt;Github user chatman commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Seems like there are some test failures due to this change:&lt;/p&gt;

&lt;p&gt;       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt; Tests with failures &lt;span class=&quot;error&quot;&gt;&amp;#91;seed: DE1D5337E38D2C32&amp;#93;&lt;/span&gt;:&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestPullReplica.testRemoveAllWriterReplicas&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestPullReplica.testAddRemovePullReplica&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.CollectionTooManyReplicasTest.testAddTooManyReplicas&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.CollectionsAPIDistributedZkTest.addReplicaTest&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.DeleteShardTest.testDirectoryCleanupAfterDeleteShard&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestCloudRecovery.corruptedLogTest&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestCloudRecovery.leaderRecoverFromLogOnStartupTest&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestUtilizeNode.test&lt;br/&gt;
       &lt;span class=&quot;error&quot;&gt;&amp;#91;junit4&amp;#93;&lt;/span&gt;   - org.apache.solr.cloud.TestTlogReplica.testAddRemoveTlogReplica&lt;/p&gt;

&lt;p&gt;    Haven&apos;t looked into them yet, though.&lt;/p&gt;</comment>
                            <comment id="16297686" author="githubbot" created="Wed, 20 Dec 2017 00:17:49 +0000"  >&lt;p&gt;Github user slackhappy commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;ll look into the test failures.  I actually didn&apos;t mean to create the PR yet &#128563; &lt;/p&gt;</comment>
                            <comment id="16299071" author="githubbot" created="Wed, 20 Dec 2017 20:52:06 +0000"  >&lt;p&gt;Github user slackhappy commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/lucene-solr/pull/294&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/pull/294&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I updated my PR to target &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-8327&quot; title=&quot;SolrDispatchFilter is not caching new state format, which results in live fetch from ZK per request if node does not contain core from collection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-8327&quot;&gt;&lt;del&gt;SOLR-8327&lt;/del&gt;&lt;/a&gt; more specifically, and got the tests to pass.  I think a smarter approach like that used by CloudSolrClient would be great. My understanding of the change in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-10524&quot; title=&quot;Better ZkStateWriter batching&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-10524&quot;&gt;&lt;del&gt;SOLR-10524&lt;/del&gt;&lt;/a&gt; is that even the smartest/fastest updates of zookeeper data won&apos;t match the real-world state of the cluster in many situations, such as replica state changes, because those will be batched, but certainly a smarter approach would narrow that gap as much as possible, in addition to reducing the amount of state fetching.&lt;/p&gt;</comment>
                            <comment id="16327615" author="ichattopadhyaya" created="Tue, 16 Jan 2018 19:12:56 +0000"  >&lt;p&gt;I plan to commit this shortly, unless there are any objections. We can open a follow up Jira to tackle the smart caching here, which will be an improvement over this.&lt;/p&gt;</comment>
                            <comment id="16328071" author="varunthacker" created="Wed, 17 Jan 2018 00:48:22 +0000"  >&lt;p&gt;So after this patch we will make one request every 2 seconds to ZK if a query comes in for a collection that has no replicas hosted locally?&lt;/p&gt;

&lt;p&gt;This seems much better than what we have currently .&lt;/p&gt;

&lt;p&gt;We seem to be inventing our own caching even though we can set ZK watches. What are the downsides if we actually set a watch on these znodes lazily? Is there a practical limitation to the number of watches that we could set? &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dragonsinth&quot; class=&quot;user-hover&quot; rel=&quot;dragonsinth&quot;&gt;dragonsinth&lt;/a&gt;&#160;/&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=noble.paul&quot; class=&quot;user-hover&quot; rel=&quot;noble.paul&quot;&gt;noble.paul&lt;/a&gt;&#160;any thoughts on this?&lt;/p&gt;</comment>
                            <comment id="16328289" author="noble.paul" created="Wed, 17 Jan 2018 05:35:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=varun&quot; class=&quot;user-hover&quot; rel=&quot;varun&quot;&gt;varun&lt;/a&gt; We really can&apos;t let every node listen to, get notified and update the state of every single collection if we want to scale to 10000&apos;s of collections. So, this was a deliberate design choice&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ichattopadhyaya&quot; class=&quot;user-hover&quot; rel=&quot;ichattopadhyaya&quot;&gt;ichattopadhyaya&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The following code snippet would fetch the state and parse it irrespective of whether the state is updated.  It should download the changed state  only if the znode version is changed&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; DocCollection get() {
 gets.incrementAndGet();
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (lastUpdateTime &amp;lt; 0 || &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.nanoTime() - lastUpdateTime &amp;gt; LAZY_CACHE_TIME) {
 cachedDocCollection = getCollectionLive(ZkStateReader.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, collName);
 lastUpdateTime = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.nanoTime();
 }
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; cachedDocCollection;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16336092" author="slackhappy" created="Tue, 23 Jan 2018 17:12:30 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=noble.paul&quot; class=&quot;user-hover&quot; rel=&quot;noble.paul&quot;&gt;noble.paul&lt;/a&gt; I&apos;m happy to try to make that change, if you can guide me!&lt;/p&gt;

&lt;p&gt;1) I looked into whether the child watch on collections would help me know the version without asking zk, but I didn&apos;t see a way that it could for collections that are lazy.&lt;/p&gt;

&lt;p&gt;2)&#160;If I have to make a Zookeeper request, it isn&apos;t clear to me that getting the Stat to check the version (say, via exists), followed by getting the data if it differs is more efficient than just getting the data, and also increases the size of this change.&lt;/p&gt;

&lt;p&gt;It would be my preference to first decouple the number of getCollectionLive&apos;s from the number of requests, then try to optimize the getCollectionLive, we already saw a 100x&#160;decrease in zk traffic with the above patch.&#160; However, I&apos;ll defer to your judgment.&#160; How would you like me to check the version without getting the data?&#160;&#160;&lt;/p&gt;</comment>
                            <comment id="16341284" author="ichattopadhyaya" created="Fri, 26 Jan 2018 17:01:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;The following code snippet would fetch the state and parse it irrespective of whether the state is updated. It should download the changed state only if the znode version is changed&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I couldn&apos;t find a way to do this without two calls to ZK. Noble/John, unless there&apos;s an easy optimization that can be done here, do you think we should just go with the current patch and optimize later (say, using the smart caching technique)?&lt;/p&gt;</comment>
                            <comment id="16342325" author="noble.paul" created="Sat, 27 Jan 2018 21:36:05 +0000"  >&lt;p&gt;Most of the times the state is downloaded unnecessarily because it is not changed. So, essentially, only one call is made&lt;/p&gt;</comment>
                            <comment id="16342326" author="slackhappy" created="Sat, 27 Jan 2018 21:38:53 +0000"  >&lt;p&gt;What call are you proposing? `exists` ?&lt;/p&gt;</comment>
                            <comment id="16360329" author="noble.paul" created="Mon, 12 Feb 2018 06:00:51 +0000"  >&lt;p&gt;Yes, use the &lt;tt&gt;zkClient.exists()&lt;/tt&gt; call which gives a  &lt;tt&gt;Stat&lt;/tt&gt; instance.&lt;/p&gt;
</comment>
                            <comment id="16362235" author="ichattopadhyaya" created="Tue, 13 Feb 2018 12:42:57 +0000"  >&lt;p&gt;Updated John&apos;s patch to use a lookup for version before fetching. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slackhappy&quot; class=&quot;user-hover&quot; rel=&quot;slackhappy&quot;&gt;slackhappy&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=noble.paul&quot; class=&quot;user-hover&quot; rel=&quot;noble.paul&quot;&gt;noble.paul&lt;/a&gt;, can you please review?&lt;/p&gt;</comment>
                            <comment id="16368669" author="slackhappy" created="Sun, 18 Feb 2018 20:42:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ichattopadhyaya&quot; class=&quot;user-hover&quot; rel=&quot;ichattopadhyaya&quot;&gt;ichattopadhyaya&lt;/a&gt; that update looks good to me!&lt;/p&gt;</comment>
                            <comment id="16368682" author="noble.paul" created="Sun, 18 Feb 2018 21:37:40 +0000"  >&lt;p&gt;LGTM&lt;/p&gt;</comment>
                            <comment id="16375957" author="jira-bot" created="Sun, 25 Feb 2018 06:24:47 +0000"  >&lt;p&gt;Commit b212f2e9b7b5d20ab8d6168b5ddcb164f536d1af in lucene-solr&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ishan1604&quot; class=&quot;user-hover&quot; rel=&quot;ishan1604&quot;&gt;ishan1604&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b212f2e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b212f2e&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-8327&quot; title=&quot;SolrDispatchFilter is not caching new state format, which results in live fetch from ZK per request if node does not contain core from collection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-8327&quot;&gt;&lt;del&gt;SOLR-8327&lt;/del&gt;&lt;/a&gt;: Cluster state caching for nodes not hosting the collection&lt;/p&gt;</comment>
                            <comment id="16375958" author="jira-bot" created="Sun, 25 Feb 2018 06:25:44 +0000"  >&lt;p&gt;Commit 72f23c89ec0a845d25129be2462c79147f6ff0e5 in lucene-solr&apos;s branch refs/heads/branch_7x from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ishan1604&quot; class=&quot;user-hover&quot; rel=&quot;ishan1604&quot;&gt;ishan1604&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=72f23c8&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=72f23c8&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-8327&quot; title=&quot;SolrDispatchFilter is not caching new state format, which results in live fetch from ZK per request if node does not contain core from collection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-8327&quot;&gt;&lt;del&gt;SOLR-8327&lt;/del&gt;&lt;/a&gt;: Cluster state caching for nodes not hosting the collection&lt;/p&gt;</comment>
                            <comment id="16375960" author="ichattopadhyaya" created="Sun, 25 Feb 2018 06:28:51 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=slackhappy&quot; class=&quot;user-hover&quot; rel=&quot;slackhappy&quot;&gt;slackhappy&lt;/a&gt;!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12910382" name="SOLR-8327.patch" size="7471" author="ichattopadhyaya" created="Tue, 13 Feb 2018 12:41:20 +0000"/>
                            <attachment id="12799709" name="SOLR-8327.patch" size="43316" author="varun" created="Wed, 20 Apr 2016 09:16:04 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 38 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2oq33:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>