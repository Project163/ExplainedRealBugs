<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 04:11:11 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-4619] Improve PreAnalyzedField query analysis</title>
                <link>https://issues.apache.org/jira/browse/SOLR-4619</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;PreAnalyzed field extends plain FieldType and mistakenly uses the DefaultAnalyzer as query analyzer, and doesn&apos;t allow for customization via &amp;lt;analyzer&amp;gt; schema elements.&lt;/p&gt;

&lt;p&gt;Instead it should extend TextField and support all query analysis supported by that type.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12638038">SOLR-4619</key>
            <summary>Improve PreAnalyzedField query analysis</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sarowe">Steven Rowe</assignee>
                                    <reporter username="ab">Andrzej Bialecki</reporter>
                        <labels>
                    </labels>
                <created>Wed, 20 Mar 2013 18:32:28 +0000</created>
                <updated>Mon, 9 May 2016 18:51:13 +0000</updated>
                            <resolved>Thu, 21 Jan 2016 06:25:44 +0000</resolved>
                                    <version>4.0</version>
                    <version>4.1</version>
                    <version>4.2</version>
                    <version>4.2.1</version>
                    <version>6.0</version>
                                    <fixVersion>5.5</fixVersion>
                    <fixVersion>6.0</fixVersion>
                                    <component>Schema and Analysis</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="13608048" author="ab" created="Wed, 20 Mar 2013 19:20:07 +0000"  >&lt;p&gt;Comments by John Berryman, copied from &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1535&quot; title=&quot;Pre-analyzed field type&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1535&quot;&gt;&lt;del&gt;SOLR-1535&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ah, I see. This is a bit lower level than I was thinking. Still useful, but different. I was thinking about having PreAnalyzedField extend directly from TextField rather than from FieldType, and then be able to build up whatever analysis chain that you want in the usual TextField sense. Query analysis would proceed as with a normal TextField, but index analysis would smart detect whether this input was already parsed or not. If the input was not parsed, then it would go through the normal analysis. On the other hand, if the input was already parsed, then the token stream would go straight into the index (the assumption being that someone upstream understands what they&apos;re doing).&lt;/p&gt;

&lt;p&gt;This way, in the SolrJ client you could build up some extra functionality so that the PreAnalyzedTextFields would be parsed client side and sent to Solr. In my current application, we have one Solr and N-indexers on different machines. The setup described here would take a big load off of Solr. The other benefit of this setup is that query analysis proceeds as it always does. I don&apos;t understand how someone would search over a PreAnalyzed field as it currently stands, without a bit of extra work/custom code on the client.&lt;/p&gt;

&lt;p&gt;One pitfall to my idea is that you&apos;d have to create a similar PreAnalyzedIntField, PreAnalyzedLocationField, PreAnalyzedDateField etc. I wish Java had mixins or multiple inheritance.&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="13608055" author="ab" created="Wed, 20 Mar 2013 19:23:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;having PreAnalyzedField extend directly from TextField rather than from FieldType&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Done in the patch above. This means you can specify query analyzers.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;index analysis would smart detect whether this input was already parsed or not&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, this should be possible with the pluggable parsers that this field supports. Since the formats can be vastly different, depending on the parserImpl, I&apos;m not sure if we could come up with a generic detection mechanism...&lt;/p&gt;</comment>
                            <comment id="13608062" author="steve_rowe" created="Wed, 20 Mar 2013 19:33:46 +0000"  >&lt;p&gt;FYI, Andrzej, I see you have set 4.2.1 as the fix version - Mark Miller said on #lucene earlier today about cutting a 4.2.1 release: &quot;i may go tonight or tomorrow depending&quot;.&lt;/p&gt;</comment>
                            <comment id="13608093" author="berryman" created="Wed, 20 Mar 2013 19:58:18 +0000"  >&lt;p&gt;Wow... thanks for being so proactive here. I&apos;ll need to look at this in more detail later.&lt;/p&gt;</comment>
                            <comment id="13608191" author="ab" created="Wed, 20 Mar 2013 20:55:45 +0000"  >&lt;p&gt;Removing 4.2.1 from Fix version - this apparently needs more discussion.&lt;/p&gt;</comment>
                            <comment id="13609012" author="dsmiley" created="Thu, 21 Mar 2013 15:02:23 +0000"  >&lt;p&gt;Instead of having a special pre-analyzed field type, I think it makes more sense to introduce smarts into Solr&apos;s DocumentBuilder that sees a pre-analyzed field type value (e.g. a &quot;Field&quot; or some TokenStream of some sort) and instead of calling createField() on the field type, it simply populates the document.  There are details to be worked out for sure, but I think this is superior to having a special field type that is pre-analyzed when other field types are not.  Arguably &lt;b&gt;all&lt;/b&gt; fields should be able to be pre-analyzed.&lt;/p&gt;</comment>
                            <comment id="13610058" author="ab" created="Fri, 22 Mar 2013 09:13:12 +0000"  >&lt;p&gt;David: hmm, I&apos;m not sure about that ... this would complicate the processing of all field types in order to support a use case that is very specific. If you throw in the ability to support different serializations then the detection of whether a field content is in a pre-analyzed format or not is not that simple anymore. Do you have a use case in mind that would require switching on the fly between the regular and pre-analyzed formats?&lt;/p&gt;

&lt;p&gt;John: please test the patch that I attached. If this is what you had in mind then I&apos;d like to commit it soon, as it&apos;s a clear improvement over the current functionality.&lt;/p&gt;</comment>
                            <comment id="13611191" author="dsmiley" created="Fri, 22 Mar 2013 20:28:22 +0000"  >&lt;p&gt;I guess we see this very differently.  I&apos;m not arguing for any &quot;switching on the fly&quot; of anything, even if incidentally what I describe makes that possible.  Your design couples the ability to pre-analyze with the choice of field type, and I think that coupling need not exist.  It&apos;s already creating problems like this very issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4619&quot; title=&quot;Improve PreAnalyzedField query analysis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4619&quot;&gt;&lt;del&gt;SOLR-4619&lt;/del&gt;&lt;/a&gt;).  Query analysis wouldn&apos;t need any improving, it shouldn&apos;t have anything to do with wether the field data was analyzed for indexing before it got to Solr or not.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;this would complicate the processing of all field types&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, but it&apos;s not much.  I&apos;ve already been poring over DocumentBuilder (as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4329&quot; title=&quot;Have DocumentBuilder give value collections to the FieldType&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4329&quot;&gt;SOLR-4329&lt;/a&gt;) and I think I know what&apos;s involved.  It needs to examine the field value: if it&apos;s &quot;Field&quot; then it gets added right to the document.  A Solr UpdateRequestProcessor could convert the external serialization of the token stream from JSON/Avro/whatever to Field.&lt;/p&gt;</comment>
                            <comment id="13611435" author="janhoy" created="Fri, 22 Mar 2013 23:41:59 +0000"  >&lt;p&gt;I like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dsmiley&quot; class=&quot;user-hover&quot; rel=&quot;dsmiley&quot;&gt;dsmiley&lt;/a&gt;s generalized approach. Could you perhaps throw up a patch for discussion?&lt;/p&gt;</comment>
                            <comment id="13611625" author="dsmiley" created="Sat, 23 Mar 2013 05:17:31 +0000"  >&lt;p&gt;Code matters more than words, for sure.  I already have more work than I can handle at the moment and I&apos;m sorry I can&apos;t contribute the implementation I describe right now.&lt;/p&gt;</comment>
                            <comment id="13611660" author="ab" created="Sat, 23 Mar 2013 08:11:29 +0000"  >&lt;p&gt;David, thanks for explaining - I see your point, and I like it too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It needs to examine the field value: if it&apos;s &quot;Field&quot; then it gets added right to the document.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Even if we push this functionality to an UpdateRequestProcessor it still needs to know when (not) to convert the input String to a Field. Do you have some thoughts about this?&lt;/p&gt;

&lt;p&gt;In UpdateRequestProcessor we deal with SolrInputDocument-s in the context of available schema and solrconfig - so there are a few options how to determine the need for conversion.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;It could be based on the document itself (tricky, in the light of multiple serialization formats).&lt;/li&gt;
	&lt;li&gt;OR, we could extend SolrInputField (and the document serializations) to support additional per-field flags to indicate this, but that would complicate matters even more.&lt;/li&gt;
	&lt;li&gt;OR, if this decision is going to be based on schema we would have to extend schema to pass additional flags to mark fields as preanalyzed - also tricky.&lt;/li&gt;
	&lt;li&gt;And finally, we could put the list of fields to always convert in the init args of this UpdateRequestProcessor in solrconfig ... but that&apos;s a bit ugly, mixing schema and solrconfig.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13611964" author="dsmiley" created="Sun, 24 Mar 2013 04:37:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;1. It could be based on the document itself (tricky, in the light of multiple serialization formats).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t understand.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2. OR, we could extend SolrInputField (and the document serializations) to support additional per-field flags to indicate this, but that would complicate matters even more.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If it were generalized, i.e. per-field map of metadata, then I rather like it.  Though it&apos;d take a fair amount of work I think to fully realize this (e.g. update SolrJ &amp;amp; XML &amp;amp; JSON input formats), and it might also make URP&apos;s into more of a full-fledged pipeline but I think such things are better done external to Solr.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3. OR, if this decision is going to be based on schema we would have to extend schema to pass additional flags to mark fields as preanalyzed - also tricky.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t like this, as it ties the choice of pre-analysis to the schema which I think is unnecessary coupling just as it is to the field type.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;4. And finally, we could put the list of fields to always convert in the init args of this UpdateRequestProcessor in solrconfig ... but that&apos;s a bit ugly, mixing schema and solrconfig.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t see it as &quot;mixing schema&quot; unless you simply mean to say that fields are referred to outside of the schema.  But heck, that&apos;s inevitable as fields are already referred to all over solrconfig.xml.  It&apos;s unrealistic to expect the names of fields in one&apos;s schema to not exist outside of schema.xml &amp;#8211; the app needs to know too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;One option would be to pass in a pseudo field &lt;tt&gt;&amp;#95;pre-analyzed&amp;#95;&lt;/tt&gt; (leading and trailing underscore) with a list of field names that are pre-analyzed.  The sender of the data is certainly aware of which fields are pre-analyzed as it had to pre-analyze them, so it can simply communicate that.&lt;/p&gt;</comment>
                            <comment id="13612533" author="ab" created="Mon, 25 Mar 2013 10:12:49 +0000"  >&lt;p&gt;So it looks to me like the least controversial option is to put the list of preanalyzed fields in solrconfig in the specification of the URP. The trick with a &quot;magic&quot; field name sounds useful too - it would allow overriding the list of fields on a per-document basis. This could be also achieved by passing the list of fields via SolrParams - although it would affect all documents in a given update request.&lt;/p&gt;

&lt;p&gt;Anyway, I think these are good ideas worth trying. I&apos;ll start working on a patch. Thanks for the comments!&lt;/p&gt;</comment>
                            <comment id="13615508" author="ab" created="Wed, 27 Mar 2013 17:15:22 +0000"  >&lt;p&gt;I came to conclusion that this is really a different issue, worth pursuing on its own, so I created &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4648&quot; title=&quot;Create a PreAnalyzedUpdateProcessor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4648&quot;&gt;&lt;del&gt;SOLR-4648&lt;/del&gt;&lt;/a&gt;. The improvements in analysis that I mentioned in the original description, and the patch, should be applied regardless of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4648&quot; title=&quot;Create a PreAnalyzedUpdateProcessor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4648&quot;&gt;&lt;del&gt;SOLR-4648&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15097417" author="steve_rowe" created="Thu, 14 Jan 2016 01:31:16 +0000"  >&lt;p&gt;Patch that brings Andrzej&apos;s patch up to date with trunk, and adds tests for query-time functionality.&lt;/p&gt;

&lt;p&gt;I had assumed that &lt;tt&gt;PreAnalyzedField&lt;/tt&gt;-s would use the &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt; at query time, but that is not (currently) the case: instead &lt;tt&gt;FieldType.DefaultAnalyzer&lt;/tt&gt; is used.  This patch changes the behavior when no analyzer is specified to instead use &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;However, there is a chicken-and-egg interaction between &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt; and &lt;tt&gt;QueryBuilder.createFieldQuery()&lt;/tt&gt;, which aborts before performing any tokenization if the supplied analyzer&apos;s attribute factory doesn&apos;t contain a &lt;tt&gt;TermToBytesRefAttribute&lt;/tt&gt;.  But &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt; doesn&apos;t have any attributes defined until the input stream is consumed, in &lt;tt&gt;reset()&lt;/tt&gt;. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rcmuir&quot; class=&quot;user-hover&quot; rel=&quot;rcmuir&quot;&gt;rcmuir&lt;/a&gt; added a comment as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-5388&quot; title=&quot;Eliminate construction over readers for Tokenizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-5388&quot;&gt;&lt;del&gt;LUCENE-5388&lt;/del&gt;&lt;/a&gt; to &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt;&apos;s ctor, where &lt;tt&gt;AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY&lt;/tt&gt; is set as the attribute factory rather than the default packed implementation: &quot;we don&apos;t pack attributes: since we are used for (de)serialization and dont want bloat.&quot;&lt;/p&gt;

&lt;p&gt;This patch moves the &lt;tt&gt;stream.reset()&lt;/tt&gt; call in &lt;tt&gt;QueryBuilder.createFieldQuery()&lt;/tt&gt; in front of the &lt;tt&gt;TermToBytesRefAttribute&lt;/tt&gt; check, so that &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt; (and other tokenizers that don&apos;t have a pre-added set of attributes) has a chance to populate its attributes, and also moves the &lt;tt&gt;addAttribute(PositionIncrementAttribute.class)&lt;/tt&gt; call to after the &lt;tt&gt;TermToBytesRefAttribute&lt;/tt&gt; check, since that won&apos;t be needed if no tokenization will be performed.&lt;/p&gt;

&lt;p&gt;An alternate approach to fix the chicken-and-egg problem might be to have &lt;tt&gt;PreAnalyzedTokenizer&lt;/tt&gt; always include a dummy &lt;tt&gt;TermToBytesRefAttribute&lt;/tt&gt; implementation, and then remove it when &lt;tt&gt;reset()&lt;/tt&gt; is called, but that seems hackish.&lt;/p&gt;

&lt;p&gt;I haven&apos;t run the full tests yet with this patch, but the included query-time &lt;tt&gt;PreAnalyzedField&lt;/tt&gt; tests succeed.&lt;/p&gt;

&lt;p&gt;I welcome feedback.&lt;/p&gt;</comment>
                            <comment id="15097440" author="rcmuir" created="Thu, 14 Jan 2016 01:48:35 +0000"  >&lt;blockquote&gt;
&lt;p&gt; But PreAnalyzedTokenizer doesn&apos;t have any attributes defined until the input stream is consumed, in reset()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, thats a bug really. According to TokenStream&apos;s class javadocs:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; The workflow of the new TokenStream API is as follows:&lt;/p&gt;

&lt;p&gt; 1.  Instantiation of TokenStream/TokenFilters which add/get attributes to/from the AttributeSource.&lt;br/&gt;
 2.  The consumer calls reset().&lt;br/&gt;
 3.  The consumer retrieves attributes from the stream and stores local references to all attributes it wants to access. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So we have consumers (such as QueryBuilder) doing stuff out of order: if they do step 3 before they do step 2.&lt;/p&gt;

&lt;p&gt;My question is, can we detect this in tests? If MockAnalyzer can enforce it, it is easier to fix it consistently everywhere. One idea is if MockTokenizer deferred initializing its attributes until reset()? Its not going to be the best (we need to tie it into its state machine logic somehow for that), but it might be an easy step.&lt;/p&gt;</comment>
                            <comment id="15097446" author="rcmuir" created="Thu, 14 Jan 2016 01:53:57 +0000"  >&lt;p&gt;Also, majority of TokenFilters (which basically also serve as consumers too), are doing step 3 before step 2 today. Most of them are just assigning to final variables in their constructor.&lt;/p&gt;

&lt;p&gt;So something is off: we gotta go one of two ways. Either fix the documentation to swap step 3 before step 2, and fix this TokenStream to somehow provide attributes before reset(), or we make a massive change to tons of tokenizers (making them more complex and less efficient).&lt;/p&gt;

&lt;p&gt;But I think we have to do something, at least we should fix the docs to be clear, they need to reflect reality.&lt;/p&gt;</comment>
                            <comment id="15098237" author="steve_rowe" created="Thu, 14 Jan 2016 15:15:33 +0000"  >&lt;p&gt;Massive change doesn&apos;t seem warranted.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But PreAnalyzedTokenizer doesn&apos;t have any attributes defined until the input stream is consumed, in reset()&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Right, thats a bug really.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;fix this TokenStream to somehow provide attributes before reset()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since the input reader must be consumed before the attributes can be provided, the tokenizer must somehow have access to the input reader prior to reset().  The most likely place is setReader(), but Tokenizer.setReader() is final.&lt;/p&gt;

&lt;p&gt;A new analyzer class employing PreAnalyzedTokenizer could override initReader() or setReader().  I&apos;ll try with setReader(), since the docs for initReader() are focused on reader conditioning via char filters.&lt;/p&gt;</comment>
                            <comment id="15098245" author="steve_rowe" created="Thu, 14 Jan 2016 15:23:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;A new analyzer class employing PreAnalyzedTokenizer could override initReader() or setReader(). I&apos;ll try with setReader(), since the docs for initReader() are focused on reader conditioning via char filters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was referring to TokenStreamComponents.setReader() here, which is called as part of Analyzer.tokenStream():  A subclass created in the new analyzer&apos;s overridden createComponents() could call a new method on PreAnalyzedTokenizer to consume the input reader and in so doing provide the attributes.&lt;/p&gt;</comment>
                            <comment id="15107788" author="steve_rowe" created="Wed, 20 Jan 2016 01:20:47 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;A new analyzer class employing PreAnalyzedTokenizer could override initReader() or setReader(). I&apos;ll try with setReader(), since the docs for initReader() are focused on reader conditioning via char filters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was referring to TokenStreamComponents.setReader() here, which is called as part of Analyzer.tokenStream(): A subclass created in the new analyzer&apos;s overridden createComponents() could call a new method on PreAnalyzedTokenizer to consume the input reader and in so doing provide the attributes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Patch implementing the idea, splitting reader consumption out from reset() into its own method: decodeInput().  This method first removes all attributes from PreAnalyzedTokenizer&apos;s AttributeSource, then adds needed ones as a side effect of parsing the input.&lt;/p&gt;

&lt;p&gt;There is a kludge here: because TokenStreamComponents.setReader() doesn&apos;t throw an exception, PreAnalyzedAnalyzer overrides createComponents() to create a TokenStreamComponents instance that catches and stores exceptions encountered during reader consumption with the stream&apos;s PreAnalyzedTokenizer instance, whose reset() method will then throw the stored exception, if any.&lt;/p&gt;

&lt;p&gt;With this patch, PreAnalyzedAnalyzer can be reused; previously PreAnalyzedTokenizer reuse would ignore new input and re-emit tokens deserialized from the initial input.&lt;/p&gt;

&lt;p&gt;With this patch, PreAnalyzedField analysis works like this: &lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;If a query analyzer is specified in the schema then it will be used at query time.&lt;/li&gt;
	&lt;li&gt;If an analyzer is specified in the schema with no type (i.e., it is neither of &quot;index&quot; nor &quot;query&quot; type), then this analyzer will be used for query parsing, but will be ignored at index time.&lt;/li&gt;
	&lt;li&gt;If only an analyzer of &quot;index&quot; type is specified in the schema, then this analyzer will be used for query parsing, but will be ignored at index time.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This patch adds a new method removeAllAttributes() to AttributeSource, to support reuse of token streams with variable attributes, like PreAnalyzedTokenizer.&lt;/p&gt;

&lt;p&gt;I think it&apos;s ready to go.&lt;/p&gt;</comment>
                            <comment id="15107809" author="steve_rowe" created="Wed, 20 Jan 2016 01:48:39 +0000"  >&lt;p&gt;Updated patch, fixes PreAnalyzedFieldTest.testInvalidJson() to properly initialize its PreAnalyzedField, and to call reset() on the token streams created with the invalid JSON snippets, so that the exceptions triggered by the invalid JSON and stored during token stream creation are appropriately thrown.  Also tests that PreAnalyzedAnalyzer can be reused with valid input after having been fed invalid input. &lt;/p&gt;</comment>
                            <comment id="15108838" author="steve_rowe" created="Wed, 20 Jan 2016 16:27:21 +0000"  >&lt;p&gt;I plan on committing this later today if there are no objections.&lt;/p&gt;</comment>
                            <comment id="15110110" author="jira-bot" created="Thu, 21 Jan 2016 05:51:37 +0000"  >&lt;p&gt;Commit 1725869 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=steve_rowe&quot; class=&quot;user-hover&quot; rel=&quot;steve_rowe&quot;&gt;steve_rowe&lt;/a&gt; in branch &apos;dev/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1725869&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1725869&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4619&quot; title=&quot;Improve PreAnalyzedField query analysis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4619&quot;&gt;&lt;del&gt;SOLR-4619&lt;/del&gt;&lt;/a&gt;: Improve PreAnalyzedField query analysis&lt;/p&gt;</comment>
                            <comment id="15110121" author="jira-bot" created="Thu, 21 Jan 2016 06:06:18 +0000"  >&lt;p&gt;Commit 1725871 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=steve_rowe&quot; class=&quot;user-hover&quot; rel=&quot;steve_rowe&quot;&gt;steve_rowe&lt;/a&gt; in branch &apos;dev/branches/branch_5x&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1725871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1725871&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4619&quot; title=&quot;Improve PreAnalyzedField query analysis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4619&quot;&gt;&lt;del&gt;SOLR-4619&lt;/del&gt;&lt;/a&gt;: Improve PreAnalyzedField query analysis (merged trunk r1725869)&lt;/p&gt;</comment>
                            <comment id="15110139" author="steve_rowe" created="Thu, 21 Jan 2016 06:25:44 +0000"  >&lt;p&gt;Committed to trunk and branch_5x.&lt;/p&gt;

&lt;p&gt;I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-6987&quot; title=&quot;Clarify TokenStream workflow documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-6987&quot;&gt;LUCENE-6987&lt;/a&gt; to address the TokenStream workflow documentation.&lt;/p&gt;</comment>
                            <comment id="15111111" author="jira-bot" created="Thu, 21 Jan 2016 19:08:43 +0000"  >&lt;p&gt;Commit 1726069 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=steve_rowe&quot; class=&quot;user-hover&quot; rel=&quot;steve_rowe&quot;&gt;steve_rowe&lt;/a&gt; in branch &apos;dev/branches/branch_5x&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1726069&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1726069&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4619&quot; title=&quot;Improve PreAnalyzedField query analysis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4619&quot;&gt;&lt;del&gt;SOLR-4619&lt;/del&gt;&lt;/a&gt;: Fix Java7-only javadoc warnings by removing &lt;/p&gt;
{@link}
&lt;p&gt; to private static nested class PreAnalyzedTokenizer&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12439559">SOLR-1535</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12783243" name="SOLR-4619.patch" size="21385" author="sarowe" created="Wed, 20 Jan 2016 01:48:39 +0000"/>
                            <attachment id="12783237" name="SOLR-4619.patch" size="20748" author="sarowe" created="Wed, 20 Jan 2016 01:20:47 +0000"/>
                            <attachment id="12782175" name="SOLR-4619.patch" size="9751" author="sarowe" created="Thu, 14 Jan 2016 01:31:16 +0000"/>
                            <attachment id="12574600" name="SOLR-4619.patch" size="3246" author="ab" created="Wed, 20 Mar 2013 18:42:56 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>318516</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 43 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1iyjj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>318857</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>