<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 04:41:19 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-13898] Non-atomic use of SolrCache get / put</title>
                <link>https://issues.apache.org/jira/browse/SOLR-13898</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;As pointed out by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ben.manes&quot; class=&quot;user-hover&quot; rel=&quot;ben.manes&quot;&gt;ben.manes&lt;/a&gt;&#160;in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13817&quot; title=&quot;Deprecate and remove legacy SolrCache implementations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13817&quot;&gt;&lt;del&gt;SOLR-13817&lt;/del&gt;&lt;/a&gt; Solr code base in many key places uses a similar pattern of non-atomic get / put calls to SolrCache-s. In multi-threaded environment this leads to cache misses and additional unnecessary computations when competing threads both discover a missing value, non-atomically compute it and update the cache.&lt;/p&gt;

&lt;p&gt;Some of these places are known performance bottlenecks where efficient caching is especially important, such as &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt;, &lt;tt&gt;SolrDocumentFetcher&lt;/tt&gt;, &lt;tt&gt;UninvertedField&lt;/tt&gt; and join queries .&lt;/p&gt;

&lt;p&gt;I propose to add &lt;tt&gt;SolrCache.computeIfAbsent(key, mappingFunction)&lt;/tt&gt; that will atomically retrieve existing values or compute and update the cache. This will require also changing how the &lt;tt&gt;SolrCache.get(...)&lt;/tt&gt;&#160;is used in many components.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13266403">SOLR-13898</key>
            <summary>Non-atomic use of SolrCache get / put</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ab">Andrzej Bialecki</assignee>
                                    <reporter username="ab">Andrzej Bialecki</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Nov 2019 19:12:49 +0000</created>
                <updated>Tue, 21 Jan 2020 16:58:18 +0000</updated>
                            <resolved>Thu, 5 Dec 2019 18:16:33 +0000</resolved>
                                    <version>8.3</version>
                                    <fixVersion>8.4</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="16968661" author="ab" created="Wed, 6 Nov 2019 20:13:41 +0000"  >&lt;p&gt;Initial patch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I added &lt;tt&gt;SolrCache.computeIfAbsent&lt;/tt&gt; method and implemented it in each subclass.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;UninvertedField&lt;/tt&gt; and &lt;tt&gt;SolrDocumentFetcher&lt;/tt&gt; (plus a few other minor use cases) have been changed to use &lt;tt&gt;computeIfAbsent&lt;/tt&gt;. However, the way caching is used in &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt; was too scary for me to touch ... so this still needs to be modified.&lt;/li&gt;
	&lt;li&gt;I&apos;d like to add some performance tests to see how the hit ratio is affected by concurrent initialization when using get / put vs. computeIfAbsent.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All existing tests are passing.&lt;/p&gt;</comment>
                            <comment id="16968676" author="ben.manes" created="Wed, 6 Nov 2019 20:26:07 +0000"  >&lt;p&gt;FYI,&lt;br/&gt;
&lt;tt&gt;ConcurrentHashMap#computeIfAbsent&lt;/tt&gt; is pessimistic and locks more aggressively than you might expect. In Java 8 it will always lock, even if present. In Java 9 it will perform a partial prescreen - if the first entry in the hashbin is the desired entry then return, else lock and scan the bucket. Caffeine always does a full prescreen, which means a present entry is always retrieved lock-free. When &lt;a href=&quot;http://jsr166-concurrency.10961.n7.nabble.com/Re-ConcurrentHashMap-computeIfAbsent-td11687.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;talking&lt;/a&gt; to Doug Lea in Java 8 time-frame, he adopted a pessimistic stance due to biased locking and safepoints at 32+ cores favors that approach.&lt;/p&gt;

&lt;p&gt;You may want to offer a similar optimization in your non-Caffeine implementations to perform a `get(key)` and fallback to &lt;tt&gt;computeIfAbsent&lt;/tt&gt;. I haven&apos;t benchmarked at Java 9, but you can see the results in Java 8 were &lt;a href=&quot;https://github.com/ben-manes/caffeine/wiki/Benchmarks#compute&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dramatic&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="16972678" author="ab" created="Tue, 12 Nov 2019 18:21:27 +0000"  >&lt;p&gt;Updated patch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a few bugfixes&lt;/li&gt;
	&lt;li&gt;use prescreen &lt;tt&gt;get(key)&lt;/tt&gt; first in legacy cache implementations.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I also added &lt;tt&gt;TestSolrCachePerf&lt;/tt&gt; test that tries to expose the difference in hit ratio between get / put and computeIfAbsent in a highly concurrent use. Basically the test attempts to create many racing put / get (or computeIfAbsent) accesses to show that the hit ratio is lower when using get / put than when using computeIfAbsent. The test passes, ie. it shows that computeIfAbsent results in a higher hit ratio, but I&apos;m not 100% sure it&apos;s the best way to prove this &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
In particular, the timings are a bit unexpected (I didn&apos;t assert anything yet about the timings in the test, because the results were puzzling). The test measures total elapsed time for the whole scenario run, for each cache implementation, and calculates an average across 100 runs. For &lt;tt&gt;LFUCache&lt;/tt&gt; and &lt;tt&gt;LRUCache&lt;/tt&gt; it actually takes longer when &lt;tt&gt;computeIfAbsent&lt;/tt&gt; is used. I suspect it has something to do with excessive synchronization in each impl. but I&apos;m worried that maybe something is wrong with the testing method (or with the computeIfAbsent implementation in these caches).&lt;/p&gt;</comment>
                            <comment id="16972682" author="ben.manes" created="Tue, 12 Nov 2019 18:33:59 +0000"  >&lt;p&gt;Since &lt;tt&gt;computeIfAbsent&lt;/tt&gt; is complex and so are the LRU &amp;amp; LFU caches, I wouldn&apos;t have felt confident enough to add an implementation. Of course I am less familiar with Solr&apos;s code, so Instead I would have used a racy version (ala &lt;tt&gt;ConcurrentMap&lt;/tt&gt;) rather than an atomic version. Then it is just refactoring of code structure for taking advantage of atomicity if supported by the &lt;tt&gt;SolrCache&lt;/tt&gt;. Since those versions would go away in 9.x and no one complained, it seems okay to be conservative. But if you&apos;re comfortable, it is great to do for current users.&lt;/p&gt;</comment>
                            <comment id="16972688" author="yseeley@gmail.com" created="Tue, 12 Nov 2019 18:42:42 +0000"  >&lt;p&gt;Using computeIfAbsent makes total sense for something like UnInvertedField, which is huge and expensive and you absolutely don&apos;t want to ever build a duplicate because of a race.&lt;br/&gt;
With something like the filter cache, the access pattern tends to be much different and using computeIfAbsent can be optimizing for the rare case and not the common case (well, the common case of 100% hit rate for the types of requests that hit the filter cache many times and expect that hit rate to get good performance... and on a miss, it&apos;s quick to compute anyway). All those cases (variants of faceting, join, etc) are all requesting filters for terms though, so perhaps that case could be handled differently from more complex queries.&lt;/p&gt;</comment>
                            <comment id="16972740" author="ab" created="Tue, 12 Nov 2019 20:13:21 +0000"  >&lt;p&gt;Yeah, at this point I&apos;m not very concerned about legacy caches, but until they are removed I&apos;d prefer them to at least behave correctly, even if they&apos;re not the most efficient.&lt;/p&gt;

&lt;p&gt;I briefly looked at how caches are accessed and populated in &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt; and I&apos;m not comfortable touching this code, except in a few obvious places (I&apos;ll update the patch in a moment).&lt;/p&gt;

&lt;p&gt;I noticed that &lt;tt&gt;UnifiedHighlighter&lt;/tt&gt; uses &lt;tt&gt;SolrIndexSearcher.doc(id, visitor)&lt;/tt&gt;, which in turn delegates to &lt;tt&gt;SolrDocumentFetcher.doc(id, visitor)&lt;/tt&gt;, which does not use cache. Is this on purpose? I would expect highlighting to benefit from caching ...&lt;/p&gt;</comment>
                            <comment id="16972743" author="ab" created="Tue, 12 Nov 2019 20:17:40 +0000"  >&lt;p&gt;Updated patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;modify &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt; &lt;tt&gt;getDocSet(Query)&lt;/tt&gt; , &lt;tt&gt;getDocSet(Query, Filter)&lt;/tt&gt;&#160;and &lt;tt&gt;getPositiveDocSet(Query)&lt;/tt&gt; to use &lt;tt&gt;computeIfAbsent&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All tests are passing. If there are no objections I&apos;d like to finish this issue at this stage and track further improvements in new Jira issues.&lt;/p&gt;</comment>
                            <comment id="16973008" author="dsmiley" created="Wed, 13 Nov 2019 04:34:25 +0000"  >&lt;p&gt;Indeed, &lt;tt&gt;org.apache.solr.search.SolrDocumentFetcher#doc(int, org.apache.lucene.index.StoredFieldVisitor)&lt;/tt&gt; does not populate the cache but it does try to fetch from the cache.  The highlighter, which uses this, is run after QueryComponent primes the cache in doPrefetch calling &lt;tt&gt;org.apache.solr.util.SolrPluginUtils#optimizePreFetchDocs&lt;/tt&gt; (see it&apos;s nice javadocs).  That code was added in 2006.  All this said... it&apos;d be nice if the cache were populated if for some reason it wasn&apos;t already populated.  Why not.&lt;/p&gt;</comment>
                            <comment id="16973242" author="ab" created="Wed, 13 Nov 2019 10:57:48 +0000"  >&lt;p&gt;Hmm, I got an interesting test failure caused by the changes in &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt;:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   [junit4]   2&amp;gt; 1816820 ERROR (qtp46186557-36639) [n:127.0.0.1:60103_solr c:org.apache.solr.search.facet.TestCloudJSONFacetJoinDomain_collection s:shard1 r:core_node2 x:org.apache.solr.search.facet.TestCloudJSONFacetJoinDomain_collection_shard1_replica_n1 ] o.a.s.s.HttpSolrCall &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;:java.lang.IllegalStateException: Recursive update
   [junit4]   2&amp;gt; 	at java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1063)
   [junit4]   2&amp;gt; 	at java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)
   [junit4]   2&amp;gt; 	at org.apache.solr.util.ConcurrentLRUCache.putCacheEntry(ConcurrentLRUCache.java:264)
   [junit4]   2&amp;gt; 	at org.apache.solr.util.ConcurrentLRUCache.put(ConcurrentLRUCache.java:254)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.FastLRUCache.put(FastLRUCache.java:240)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.SolrIndexSearcher.getDocSet(SolrIndexSearcher.java:1198)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.JoinQuery$JoinQueryWeight.getDocSetEnumerate(JoinQParserPlugin.java:442)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.JoinQuery$JoinQueryWeight.getDocSet(JoinQParserPlugin.java:324)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.JoinQuery$JoinQueryWeight.scorer(JoinQParserPlugin.java:253)
   [junit4]   2&amp;gt; 	at org.apache.lucene.search.Weight.bulkScorer(Weight.java:168)
   [junit4]   2&amp;gt; 	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:741)
   [junit4]   2&amp;gt; 	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:516)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.DocSetUtil.createDocSetGeneric(DocSetUtil.java:151)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.DocSetUtil.createDocSet(DocSetUtil.java:140)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.SolrIndexSearcher.getDocSetNC(SolrIndexSearcher.java:1206)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.SolrIndexSearcher.lambda$getDocSet$1(SolrIndexSearcher.java:812)
   [junit4]   2&amp;gt; 	at org.apache.solr.util.ConcurrentLRUCache.lambda$computeIfAbsent$1(ConcurrentLRUCache.java:223)
   [junit4]   2&amp;gt; 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705)
   [junit4]   2&amp;gt; 	at org.apache.solr.util.ConcurrentLRUCache.computeIfAbsent(ConcurrentLRUCache.java:222)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.FastLRUCache.computeIfAbsent(FastLRUCache.java:255)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.SolrIndexSearcher.getDocSet(SolrIndexSearcher.java:810)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.handleJoinField(FacetProcessor.java:244)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.handleDomainChanges(FacetProcessor.java:167)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.process(FacetProcessor.java:69)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetFieldProcessorByArray.process(FacetFieldProcessorByArray.java:61)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetRequest.process(FacetRequest.java:416)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.processSubs(FacetProcessor.java:475)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetFieldProcessor.fillBucketFromSlot(FacetFieldProcessor.java:545)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetFieldProcessor.findTopSlots(FacetFieldProcessor.java:446)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetFieldProcessorByArray.calcFacets(FacetFieldProcessorByArray.java:114)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetFieldProcessorByArray.process(FacetFieldProcessorByArray.java:62)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetRequest.process(FacetRequest.java:416)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.processSubs(FacetProcessor.java:475)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetProcessor.fillBucket(FacetProcessor.java:432)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetQueryProcessor.process(FacetQuery.java:64)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetRequest.process(FacetRequest.java:416)
   [junit4]   2&amp;gt; 	at org.apache.solr.search.facet.FacetModule.process(FacetModule.java:147)
   [junit4]   2&amp;gt; 	at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:328)
   [junit4]   2&amp;gt; 	at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:197)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t see any easy way out of this... I&apos;ll revert the changes in &lt;tt&gt;SolrIndexSearcher&lt;/tt&gt;, let&apos;s make this a separate battle.&lt;/p&gt;</comment>
                            <comment id="16973371" author="jira-bot" created="Wed, 13 Nov 2019 14:11:57 +0000"  >&lt;p&gt;Commit 0c3233877b61a8f6a1d9132ea8cac4d83fccb337 in lucene-solr&apos;s branch refs/heads/master from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=0c32338&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=0c32338&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Non-atomic use of SolrCache get / put.&lt;/p&gt;</comment>
                            <comment id="16973535" author="jira-bot" created="Wed, 13 Nov 2019 17:10:23 +0000"  >&lt;p&gt;Commit 3c06fbcad242c6b47d1499c8c3e1bdc49ec8f1d8 in lucene-solr&apos;s branch refs/heads/branch_8x from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=3c06fbc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=3c06fbc&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Non-atomic use of SolrCache get / put.&lt;/p&gt;</comment>
                            <comment id="16973538" author="jira-bot" created="Wed, 13 Nov 2019 17:11:09 +0000"  >&lt;p&gt;Commit 32c3255b938c04a9e25076da5f0ac448b6daa66c in lucene-solr&apos;s branch refs/heads/master from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=32c3255&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=32c3255&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: fix a typo.&lt;/p&gt;</comment>
                            <comment id="16975277" author="tomasflobbe" created="Fri, 15 Nov 2019 17:45:19 +0000"  >&lt;p&gt;There is a failure in Jenkins for &lt;tt&gt;TestSolrCachePerf&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;FAILED:  org.apache.solr.search.TestSolrCachePerf.testGetPutCompute

Error Message:
compute ratio (0.9992) should be higher or equal from get/put (0.9992000000000001)

Stack Trace:
java.lang.AssertionError: compute ratio (0.9992) should be higher or equal from get/put (0.9992000000000001)
        at __randomizedtesting.SeedInfo.seed([3444241481A864AF:B4ECA31C59217C30]:0)
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.assertTrue(Assert.java:41)
        at org.apache.solr.search.TestSolrCachePerf.lambda$testGetPutCompute$0(TestSolrCachePerf.java:75)
        at java.util.HashMap.forEach(HashMap.java:1289)
        at org.apache.solr.search.TestSolrCachePerf.testGetPutCompute(TestSolrCachePerf.java:73)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.carrotsearch.randomizedtesting.RandomizedRunner.invoke(RandomizedRunner.java:1750)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$8.evaluate(RandomizedRunner.java:938)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$9.evaluate(RandomizedRunner.java:974)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$10.evaluate(RandomizedRunner.java:988)
        at com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule$1.evaluate(SystemPropertiesRestoreRule.java:57)
        at org.apache.lucene.util.TestRuleSetupTeardownChained$1.evaluate(TestRuleSetupTeardownChained.java:49)
        at org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)
        at org.apache.lucene.util.TestRuleThreadAndTestName$1.evaluate(TestRuleThreadAndTestName.java:48)
        at org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:64)
        at org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:47)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:368)
        at com.carrotsearch.randomizedtesting.ThreadLeakControl.forkTimeoutingTask(ThreadLeakControl.java:817)
        at com.carrotsearch.randomizedtesting.ThreadLeakControl$3.evaluate(ThreadLeakControl.java:468)
        at com.carrotsearch.randomizedtesting.RandomizedRunner.runSingleTest(RandomizedRunner.java:947)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$5.evaluate(RandomizedRunner.java:832)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$6.evaluate(RandomizedRunner.java:883)
        at com.carrotsearch.randomizedtesting.RandomizedRunner$7.evaluate(RandomizedRunner.java:894)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule$1.evaluate(SystemPropertiesRestoreRule.java:57)
        at org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at org.apache.lucene.util.TestRuleStoreClassName$1.evaluate(TestRuleStoreClassName.java:41)
        at com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:40)
        at com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:40)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at org.apache.lucene.util.TestRuleAssertionsRequired$1.evaluate(TestRuleAssertionsRequired.java:53)
        at org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:47)
        at org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:64)
        at org.apache.lucene.util.TestRuleIgnoreTestSuites$1.evaluate(TestRuleIgnoreTestSuites.java:54)
        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)
        at com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:368)
        at java.lang.Thread.run(Thread.java:748)

 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16975283" author="hossman" created="Fri, 15 Nov 2019 17:57:18 +0000"  >&lt;p&gt;&lt;b&gt;UPDATE:&lt;/b&gt; Sorry, concurrent collision of comments with tomas .. but note also all the ERROR logging suggesting a lifecycle problem as well.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;New test TestSolrCachePerf.testGetPutCompute seems to be overly brittle in it&apos;s math comparisons? (note also all the ERROR logging suggesting the cache lifecyle is broken)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://fucit.org/solr-jenkins-reports/job-data/apache/Lucene-Solr-NightlyTests-8.x/269&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://fucit.org/solr-jenkins-reports/job-data/apache/Lucene-Solr-NightlyTests-8.x/269&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   [junit4] Suite: org.apache.solr.search.TestSolrCachePerf
   [junit4]   2&amp;gt; 1397484 INFO  (SUITE-TestSolrCachePerf-seed#[3444241481A864AF]-worker) [     ] o.a.s.SolrTestCaseJ4 Created dataDir: /home/jenkins/jenkins-slave/workspace/Lucene-Solr-NightlyTests-8.x/checkout/solr/build/solr-core/test/J2/temp/solr.search.TestSolrCachePerf_3444241481A864AF-001/data-dir-91-001
   [junit4]   2&amp;gt; 1397484 WARN  (SUITE-TestSolrCachePerf-seed#[3444241481A864AF]-worker) [     ] o.a.s.SolrTestCaseJ4 startTrackingSearchers: numOpens=32 numCloses=32
   [junit4]   2&amp;gt; 1397484 INFO  (SUITE-TestSolrCachePerf-seed#[3444241481A864AF]-worker) [     ] o.a.s.SolrTestCaseJ4 Using PointFields (NUMERIC_POINTS_SYSPROP=true) w/NUMERIC_DOCVALUES_SYSPROP=true
   [junit4]   2&amp;gt; 1397485 INFO  (SUITE-TestSolrCachePerf-seed#[3444241481A864AF]-worker) [     ] o.a.s.SolrTestCaseJ4 Randomized ssl (false) and clientAuth (false) via: @org.apache.solr.util.RandomizeSSL(reason=, value=NaN, ssl=NaN, clientAuth=NaN)
   [junit4]   2&amp;gt; 1397485 INFO  (SUITE-TestSolrCachePerf-seed#[3444241481A864AF]-worker) [     ] o.a.s.SolrTestCaseJ4 SecureRandom sanity checks: test.solr.allowed.securerandom=null &amp;amp; java.security.egd=file:/dev/./urandom
   [junit4]   2&amp;gt; 1397487 INFO  (TEST-TestSolrCachePerf.testGetPutCompute-seed#[3444241481A864AF]) [     ] o.a.s.SolrTestCaseJ4 ###Starting testGetPutCompute
   [junit4]   2&amp;gt; 1398323 ERROR (Finalizer) [     ] o.a.s.u.ConcurrentLFUCache ConcurrentLFUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!
   [junit4]   2&amp;gt; 1398323 ERROR (Finalizer) [     ] o.a.s.u.ConcurrentLFUCache ConcurrentLFUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!
   [junit4]   2&amp;gt; 1398323 ERROR (Finalizer) [     ] o.a.s.u.ConcurrentLFUCache ConcurrentLFUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!
   [junit4]   2&amp;gt; 1398323 ERROR (Finalizer) [     ] o.a.s.u.ConcurrentLFUCache ConcurrentLFUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!
      ...skip ~200 duplicate ERROR lines...
   [junit4]   2&amp;gt; 1414149 INFO  (TEST-TestSolrCachePerf.testGetPutCompute-seed#[3444241481A864AF]) [     ] o.a.s.SolrTestCaseJ4 ###Ending testGetPutCompute
   [junit4]   2&amp;gt; NOTE: download the large Jenkins line-docs file by running &apos;ant get-jenkins-line-docs&apos; in the lucene directory.
   [junit4]   2&amp;gt; NOTE: reproduce with: ant test  -Dtestcase=TestSolrCachePerf -Dtests.method=testGetPutCompute -Dtests.seed=3444241481A864AF -Dtests.multiplier=2 -Dtests.nightly=true -Dtests.slow=true -Dtests.linedocsfile=/home/jenkins/jenkins-slave/workspace/Lucene-Solr-NightlyTests-8.x/test-data/enwiki.random.lines.txt -Dtests.locale=en-SG -Dtests.timezone=America/Swift_Current -Dtests.asserts=true -Dtests.file.encoding=UTF-8
   [junit4] FAILURE 16.7s J2 | TestSolrCachePerf.testGetPutCompute &amp;lt;&amp;lt;&amp;lt;
   [junit4]    &amp;gt; Throwable #1: java.lang.AssertionError: compute ratio (0.9992) should be higher or equal from get/put (0.9992000000000001)
   [junit4]    &amp;gt;        at __randomizedtesting.SeedInfo.seed([3444241481A864AF:B4ECA31C59217C30]:0)
   [junit4]    &amp;gt;        at org.apache.solr.search.TestSolrCachePerf.lambda$testGetPutCompute$0(TestSolrCachePerf.java:75)
   [junit4]    &amp;gt;        at java.util.HashMap.forEach(HashMap.java:1289)
   [junit4]    &amp;gt;        at org.apache.solr.search.TestSolrCachePerf.testGetPutCompute(TestSolrCachePerf.java:73)
   [junit4]    &amp;gt;        at java.lang.Thread.run(Thread.java:748)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16975345" author="jira-bot" created="Fri, 15 Nov 2019 19:35:07 +0000"  >&lt;p&gt;Commit 4d1fff37fc799035e5294cb274761a662a70fa61 in lucene-solr&apos;s branch refs/heads/branch_8x from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4d1fff3&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4d1fff3&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Allow inexact double comparison. Close resources.&lt;/p&gt;</comment>
                            <comment id="16975348" author="jira-bot" created="Fri, 15 Nov 2019 19:38:35 +0000"  >&lt;p&gt;Commit 66e78ba7c5679fc27b09460aef4980725ff143f2 in lucene-solr&apos;s branch refs/heads/master from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=66e78ba&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=66e78ba&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Allow inexact double comparison. Close resources.&lt;/p&gt;</comment>
                            <comment id="16975745" author="jira-bot" created="Sat, 16 Nov 2019 16:37:03 +0000"  >&lt;p&gt;Commit 66e78ba7c5679fc27b09460aef4980725ff143f2 in lucene-solr&apos;s branch refs/heads/jira/&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13452&quot; title=&quot;Update the lucene-solr build from Ivy+Ant+Maven (shadow build) to Gradle.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13452&quot;&gt;&lt;del&gt;SOLR-13452&lt;/del&gt;&lt;/a&gt;_gradle_8 from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=66e78ba&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=66e78ba&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Allow inexact double comparison. Close resources.&lt;/p&gt;</comment>
                            <comment id="16977408" author="ab" created="Tue, 19 Nov 2019 11:31:33 +0000"  >&lt;p&gt;Hmm, weird, this still occasionally fails on 8x (I couldn&apos;t reproduce it locally using the same seed and the same JVM):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Build: https:&lt;span class=&quot;code-comment&quot;&gt;//builds.apache.org/job/Lucene-Solr-Tests-8.x/764/
&lt;/span&gt;
1 tests failed.
FAILED:  org.apache.solr.search.TestSolrCachePerf.testGetPutCompute

Error Message:
Compute ratio should be higher or equal to get/put ratio: 0.9975999999999999 &amp;gt;= 0.9986000000000004

Stack Trace:
java.lang.AssertionError: Compute ratio should be higher or equal to get/put ratio: 0.9975999999999999 &amp;gt;= 0.9986000000000004
	at __randomizedtesting.SeedInfo.seed([7FAFA6ED78D287C5:FF0721E5A05B9F5A]:0)
	at org.junit.Assert.fail(Assert.java:88)
	at org.apache.solr.search.TestSolrCachePerf.assertGreaterThanOrEqual(TestSolrCachePerf.java:84)
	at org.apache.solr.search.TestSolrCachePerf.lambda$testGetPutCompute$0(TestSolrCachePerf.java:75)
	at java.util.HashMap.forEach(HashMap.java:1289)
	at org.apache.solr.search.TestSolrCachePerf.testGetPutCompute(TestSolrCachePerf.java:73)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16977551" author="ben.manes" created="Tue, 19 Nov 2019 15:22:05 +0000"  >&lt;p&gt;Caffeine has a little randomness in its eviction policy to protect from HashDoS style of attacks. This means you may see very small differences between runs, even in a single threaded case. Your test is already non deterministic due to concurrency, so both could explain the slight differences.&lt;/p&gt;</comment>
                            <comment id="16977579" author="jira-bot" created="Tue, 19 Nov 2019 15:58:44 +0000"  >&lt;p&gt;Commit 4837e62989b2cedbab505f6231c58fc8644adab4 in lucene-solr&apos;s branch refs/heads/branch_8x from Andrzej Bialecki&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4837e62&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4837e62&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13898&quot; title=&quot;Non-atomic use of SolrCache get / put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13898&quot;&gt;&lt;del&gt;SOLR-13898&lt;/del&gt;&lt;/a&gt;: Add more information to the failure message.&lt;/p&gt;</comment>
                            <comment id="16989048" author="ab" created="Thu, 5 Dec 2019 18:16:33 +0000"  >&lt;p&gt;This hasn&apos;t failed for a while on jenkins, at least not because of this test (there are a few builds where every test was failing due to this or that issue) - closing as fixed.&lt;/p&gt;</comment>
                            <comment id="17004989" author="jpountz" created="Sun, 29 Dec 2019 20:50:59 +0000"  >&lt;p&gt;Closing after the 8.4.0 release.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12985653" name="SOLR-13898.patch" size="39732" author="ab" created="Tue, 12 Nov 2019 20:14:34 +0000"/>
                            <attachment id="12985646" name="SOLR-13898.patch" size="36160" author="ab" created="Tue, 12 Nov 2019 18:04:50 +0000"/>
                            <attachment id="12985113" name="SOLR-13898.patch" size="27667" author="ab" created="Wed, 6 Nov 2019 20:07:52 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 46 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z08a9k:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>