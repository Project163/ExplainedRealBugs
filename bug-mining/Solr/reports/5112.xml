<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 05:08:09 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-16992] Non-reproducible StreamingTest failures -- suggests CloudSolrStream concurency race condition</title>
                <link>https://issues.apache.org/jira/browse/SOLR-16992</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;Roughly 3% of all jenkins jobs that run &lt;tt&gt;StreamingTest&lt;/tt&gt; wind up having suite level failures.&lt;/p&gt;

&lt;p&gt;These failures have historically taken the form of &lt;tt&gt;com.carrotsearch.randomizedtesting.ThreadLeakError&lt;/tt&gt; and the leaked threads all have names like&lt;br/&gt;
&lt;tt&gt;&quot;h2sc-718-thread-2&quot;&lt;/tt&gt; indicating that they come from the internal &lt;tt&gt;ExecutorService&lt;/tt&gt; of an &lt;tt&gt;Http2SolrClient&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;In my experience, the seeds from these failures have never reproduced - suggesting that the problem is related to concurrency.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16983&quot; title=&quot;ObjectReleaseTracker completely useless in all SolrTestCaseJ4 based tests - masking unclosed InputStream in some SolrStream usecases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16983&quot;&gt;&lt;del&gt;SOLR-16983&lt;/del&gt;&lt;/a&gt; restored the (correct) use of &lt;tt&gt;ObjectReleaseTracker&lt;/tt&gt; which in theory should help pinpoint where &lt;tt&gt;Http2SolrClient&lt;/tt&gt; instances might not be getting closed (by causing &lt;tt&gt;ObjectReleaseTracker&lt;/tt&gt; to fail with stacktraces of when/where any unclosed instances were created - ie: which test method)&lt;/p&gt;

&lt;p&gt;In practice, I have managed to force one failure from &lt;tt&gt;StreamingTest&lt;/tt&gt; since the &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16983&quot; title=&quot;ObjectReleaseTracker completely useless in all SolrTestCaseJ4 based tests - masking unclosed InputStream in some SolrStream usecases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16983&quot;&gt;&lt;del&gt;SOLR-16983&lt;/del&gt;&lt;/a&gt; changes (logs to be attached soon) - but it still didn&apos;t indicate any leaked/unclosed &lt;tt&gt;Http2SolrClient&lt;/tt&gt; instances. What it instead indicated was a &lt;em&gt;single&lt;/em&gt; unclosed &lt;tt&gt;InputStream&lt;/tt&gt; instance related to &lt;tt&gt;Http2SolrClient&lt;/tt&gt; connections (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16983&quot; title=&quot;ObjectReleaseTracker completely useless in all SolrTestCaseJ4 based tests - masking unclosed InputStream in some SolrStream usecases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16983&quot;&gt;&lt;del&gt;SOLR-16983&lt;/del&gt;&lt;/a&gt; also added better tracking of this) coming from &lt;tt&gt;StreamingTest.testExceptionStream&lt;/tt&gt; - a test method that opens &lt;em&gt;five&lt;/em&gt; very similar &lt;tt&gt;ExceptionStream&lt;/tt&gt; instances, wrapping &lt;tt&gt;CloudSolrStream&lt;/tt&gt; instance, which expect to trigger server side errors.&lt;/p&gt;

&lt;p&gt;By it&apos;s very design, &lt;tt&gt;ExceptionStream&lt;/tt&gt; catches &amp;amp; records any exceptions from the stream it wraps, so even in the event of these &quot;expected&quot; server side errors, &lt;tt&gt;ExceptionStream.close()&lt;/tt&gt; should still be correctly getting called (and propagating down to the &lt;tt&gt;CloudStream&lt;/tt&gt; it wraps).&lt;/p&gt;

&lt;p&gt;I believe the underlying problem has to do with a concurrency race condition between the call to &lt;tt&gt;CloudStream.close()&lt;/tt&gt; and the &lt;tt&gt;ExecutorService&lt;/tt&gt; used internally by &lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt; (details to follow)&lt;/p&gt;</description>
                <environment></environment>
        <key id="13551597">SOLR-16992</key>
            <summary>Non-reproducible StreamingTest failures -- suggests CloudSolrStream concurency race condition</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="stillalex">Alex Deparvu</assignee>
                                    <reporter username="hossman">Chris M. Hostetter</reporter>
                        <labels>
                    </labels>
                <created>Fri, 22 Sep 2023 01:59:50 +0000</created>
                <updated>Sun, 15 Oct 2023 20:13:53 +0000</updated>
                            <resolved>Wed, 27 Sep 2023 20:50:25 +0000</resolved>
                                                    <fixVersion>9.4</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="1200">20m</timespent>
                                <comments>
                            <comment id="17767777" author="hossman" created="Fri, 22 Sep 2023 02:05:46 +0000"  >&lt;p&gt;I&apos;m attaching two files: a typical jenkins job failure of &lt;tt&gt;StreamingTest&lt;/tt&gt; (&lt;em&gt;before&lt;/em&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16983&quot; title=&quot;ObjectReleaseTracker completely useless in all SolrTestCaseJ4 based tests - masking unclosed InputStream in some SolrStream usecases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16983&quot;&gt;&lt;del&gt;SOLR-16983&lt;/del&gt;&lt;/a&gt;) and the non-reproducable failure i was able to locally coax out of branch_9x (&lt;em&gt;after&lt;/em&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16983&quot; title=&quot;ObjectReleaseTracker completely useless in all SolrTestCaseJ4 based tests - masking unclosed InputStream in some SolrStream usecases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16983&quot;&gt;&lt;del&gt;SOLR-16983&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Here&apos;s the important snippet from the output of the local failure...&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   &amp;gt;     java.lang.AssertionError: ObjectTracker found 1 object(s) that were not released!!! [Input]
   &amp;gt;     org.eclipse.jetty.client.util.InputStreamResponseListener$Input:org.apache.solr.common.util.ObjectReleaseTracker$ObjectTrackerException: org.eclipse.jetty.client.u
til.InputStreamResponseListener$Input
   &amp;gt;            at org.apache.solr.common.util.ObjectReleaseTracker.track(ObjectReleaseTracker.java:52)
   &amp;gt;            at org.apache.solr.client.solrj.impl.Http2SolrClient$InputStreamReleaseTrackingResponseListener$ObjectReleaseTrackedInputStream.&amp;lt;init&amp;gt;(Http2SolrClient.java:
1495)
   &amp;gt;            at org.apache.solr.client.solrj.impl.Http2SolrClient$InputStreamReleaseTrackingResponseListener.getInputStream(Http2SolrClient.java:1489)
   &amp;gt;            at org.apache.solr.client.solrj.impl.Http2SolrClient.request(Http2SolrClient.java:532)
   &amp;gt;            at org.apache.solr.client.solrj.SolrClient.request(SolrClient.java:1192)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.SolrStream.constructParser(SolrStream.java:304)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.SolrStream.open(SolrStream.java:129)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.CloudSolrStream$StreamOpener.call(CloudSolrStream.java:539)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.CloudSolrStream$StreamOpener.call(CloudSolrStream.java:527)
   &amp;gt;            at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
   &amp;gt;            at org.apache.solr.common.util.ExecutorUtil$MDCAwareThreadPoolExecutor.lambda$execute$0(ExecutorUtil.java:289)
   &amp;gt;            at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
   &amp;gt;            at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
   &amp;gt;            at java.base/java.lang.Thread.run(Thread.java:829)
   &amp;gt;     Caused by: java.lang.Exception: Submitter stack trace
   &amp;gt;            at org.apache.solr.common.util.ExecutorUtil$MDCAwareThreadPoolExecutor.execute(ExecutorUtil.java:256)
   &amp;gt;            at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.CloudSolrStream.lambda$openStreams$8(CloudSolrStream.java:419)
   &amp;gt;            at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195)
   &amp;gt;            at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655)
   &amp;gt;            at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
   &amp;gt;            at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
   &amp;gt;            at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913)
   &amp;gt;            at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
   &amp;gt;            at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.CloudSolrStream.openStreams(CloudSolrStream.java:420)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.CloudSolrStream.open(CloudSolrStream.java:292)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.ExceptionStream.open(ExceptionStream.java:52)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.StreamingTest.getTuple(StreamingTest.java:2895)
   &amp;gt;            at org.apache.solr.client.solrj.io.stream.StreamingTest.testExceptionStream(StreamingTest.java:662)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here is roughly what i think is happening...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;testExceptionStream()&lt;/tt&gt; calls &lt;tt&gt;getTuple(estream)&lt;/tt&gt; calls &lt;tt&gt;ExceptionStream.open()&lt;/tt&gt; calls &lt;tt&gt;CloudSolrStream.open()&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;CloudSolrStream.open()&lt;/tt&gt; initializes &lt;tt&gt;List&amp;lt;TupleStream&amp;gt; solrStreams&lt;/tt&gt; containing one &lt;tt&gt;SolrStream&lt;/tt&gt; per shard and calls &lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt; ...
	&lt;ul&gt;
		&lt;li&gt;spins up an &lt;tt&gt;ExecutorService servce = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(&quot;CloudSolrStream&quot;))&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;calls &lt;tt&gt;service.submit(new StreamOpener(...))&lt;/tt&gt; on every instance in &lt;tt&gt;solrStreams&lt;/tt&gt; and records the &lt;tt&gt;List&amp;lt;Future&amp;lt;TupleWrapper&amp;gt;&amp;gt; futures&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;loops over the &lt;tt&gt;futures&lt;/tt&gt; ...
		&lt;ul&gt;
			&lt;li&gt;If any throw an (Execution) exception: immediately wrap and rethrow that exception&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;call &lt;tt&gt;servce.shutdown()&lt;/tt&gt; in a &lt;tt&gt;finally&lt;/tt&gt; block
		&lt;ul&gt;
			&lt;li&gt;&lt;b&gt;This is not a blocking call!&lt;/b&gt;&lt;/li&gt;
			&lt;li&gt;It does not terminate (or wait for completion) of any &lt;tt&gt;StreamOpener&lt;/tt&gt; instances currently being executed by ThreadPool threads.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;ExceptionStream.open()&lt;/tt&gt; will catch the exception thrown by &lt;tt&gt;CloudSolrStream.open()&lt;/tt&gt; and store it in a Tuple&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;getTuple(estream)&lt;/tt&gt; gets the Tuple from &lt;tt&gt;ExceptionStream.read()&lt;/tt&gt; and calls &lt;tt&gt;ExceptionStream.close()&lt;/tt&gt; calls &lt;tt&gt;CloudStream.close()&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;At this point &lt;tt&gt;getTuple(estream)&lt;/tt&gt; returns the (expected) Tuple from &lt;tt&gt;ExceptionStream&lt;/tt&gt; and the test can make assertions on them and pass
	&lt;ul&gt;
		&lt;li&gt;&lt;b&gt;BUT MEANWHILE&lt;/b&gt; ...&lt;/li&gt;
		&lt;li&gt;&lt;em&gt;after&lt;/em&gt; the test thread has (cascadingly) called &lt;tt&gt;CloudStream.close()&lt;/tt&gt;, threads from the &lt;tt&gt;ExecutorService&lt;/tt&gt; may still be calling &lt;tt&gt;SolrStream.open()&lt;/tt&gt; on the instances in &lt;tt&gt;CloudStream.solrStreams&lt;/tt&gt;
		&lt;ul&gt;
			&lt;li&gt;Due to the way the &lt;tt&gt;SolrClientCache&lt;/tt&gt; works, These &lt;tt&gt;SolrStream.open()&lt;/tt&gt; calls can/will cause new &lt;tt&gt;Http2SolrClient&lt;/tt&gt; instances to be created
			&lt;ul&gt;
				&lt;li&gt;These &lt;tt&gt;Http2SolrClient&lt;/tt&gt; instances may be opened &lt;em&gt;after&lt;/em&gt; the test thread has called &lt;tt&gt;SolrClientCache.close()&lt;/tt&gt; ... causing them to leak&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;These &lt;tt&gt;SolrStream.open()&lt;/tt&gt; calls can/will cause new HTTP Connections to be initiated, opening new &lt;tt&gt;InputStream&lt;/tt&gt; instances
			&lt;ul&gt;
				&lt;li&gt;These &lt;tt&gt;InputStream&lt;/tt&gt; instances will never be closed, because the &lt;tt&gt;SolrStream&lt;/tt&gt; instances will never be &quot;re&quot;-closed.&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;
&lt;p&gt;I think at a minimum, &lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt; should be changed such that...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;It waits for the results of &lt;em&gt;every&lt;/em&gt; &lt;tt&gt;Future&lt;/tt&gt;, even if one of them throws an exception
	&lt;ul&gt;
		&lt;li&gt;The &lt;tt&gt;IOException&lt;/tt&gt; it ultimate throws should wrap one of these caught exceptions, and call &lt;tt&gt;addSuppressed&lt;/tt&gt; on all the rest
		&lt;ul&gt;
			&lt;li&gt;This seems like a cleaner/better behavior for the exception handling in &lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt;, independent of the concurrency race conditions being discussed&lt;/li&gt;
			&lt;li&gt;A key benefit of this, is that it ensures all the &lt;tt&gt;StreamOpener&lt;/tt&gt; instances will have completed before &lt;tt&gt;CloudSolrStream.openStreams()&lt;/tt&gt; returns &#8211; ensuring that no background threads can/will muck with the internals of &lt;tt&gt;CloudSolrStream&lt;/tt&gt; while the caller has moved on to calling &lt;tt&gt;CloudSolrStream.close()&lt;/tt&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;it might make sense to instead use &lt;tt&gt;shutdownNow() + awaitTermination()&lt;/tt&gt; if/when any &lt;tt&gt;Future&lt;/tt&gt; fails
	&lt;ul&gt;
		&lt;li&gt;but that would definitely be more complicated to implement (let alone implement correctly)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;
&lt;p&gt;Going above and beyond that, it&apos;s worth considering:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;update many &lt;tt&gt;Closeable&lt;/tt&gt; classes in solr to keep track of if/when &lt;tt&gt;close&lt;/tt&gt; is called more then once&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;ie: a new &lt;tt&gt;private transient boolean isClosed = false;&lt;/tt&gt; that &lt;tt&gt;close()&lt;/tt&gt; sets to &lt;tt&gt;true&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;In the specific case of streaming classes discussed in this jira...
	&lt;ul&gt;
		&lt;li&gt;Change &lt;tt&gt;SolrClientCache&lt;/tt&gt; so that any method that will add to &lt;tt&gt;solrClients&lt;/tt&gt; throws an &lt;tt&gt;IllegalStateException&lt;/tt&gt; if &lt;tt&gt;isClosed&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;make all &lt;tt&gt;TupleStream&lt;/tt&gt; instances throw an &lt;tt&gt;IllegalStateException&lt;/tt&gt; from &lt;tt&gt;open()&lt;/tt&gt; and/or &lt;tt&gt;read()&lt;/tt&gt; if &lt;tt&gt;isClosed&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;In the general case, maybe the &lt;tt&gt;close()&lt;/tt&gt; method of many solr &lt;tt&gt;Closeable&lt;/tt&gt; classes should...
	&lt;ul&gt;
		&lt;li&gt;log a &quot;WARN&quot; if &lt;tt&gt;isClosed&lt;/tt&gt; is already true&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;assert ! isClosed : &quot;already closed&quot;;&lt;/tt&gt; so we trip tests if this happens&lt;/li&gt;
		&lt;li&gt;(Neither of these are strictly idempotent, but I think the end results would be better then perfect idempotent-ness)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;/cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stillalex&quot; class=&quot;user-hover&quot; rel=&quot;stillalex&quot;&gt;stillalex&lt;/a&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17767781" author="hossman" created="Fri, 22 Sep 2023 02:35:13 +0000"  >&lt;p&gt;At a glance...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;ParallelListStream&lt;/tt&gt; &amp;amp; &lt;tt&gt;TopicStream&lt;/tt&gt; seems to have the exact same bug.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;TextLogitStream&lt;/tt&gt; &amp;amp; &lt;tt&gt;SignificantTermsStream&lt;/tt&gt; seem to have very similar bugs.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17768085" author="alex.parvulescu" created="Fri, 22 Sep 2023 16:33:36 +0000"  >&lt;p&gt;I agree with your analysis. makes perfect sense to me.&lt;/p&gt;

&lt;p&gt;given the proliferation of this pattern across multiple classes, does it make sense to move this to a common util class and call it everywhere? not sure if possible but it would help nail it down once for all cases.&lt;/p&gt;

&lt;p&gt;re. `I think at a minimum, CloudSolrStream.openStreams() should be changed such that...`&lt;/p&gt;

&lt;p&gt;&amp;gt; It waits for the results of every Future, even if one of them throws an exception&lt;br/&gt;
&amp;gt; it might make sense to instead use shutdownNow() + awaitTermination() if/when any Future fails&lt;/p&gt;

&lt;p&gt;it feels like there is some overlap between these 2 ideas. not sure how the impls would vary but I like waiting for everything to finish and discarding any useless results (prioritize the exception).&lt;/p&gt;

&lt;p&gt;re. `Going above and beyond that, it&apos;s worth considering:`&lt;/p&gt;

&lt;p&gt;&amp;gt; Change SolrClientCache so that any method that will add to solrClients throws an IllegalStateException if isClosed&lt;/p&gt;

&lt;p&gt;-0 it doesn&apos;t feel like this class is a correct place to tackle this.&lt;/p&gt;

&lt;p&gt;&amp;gt; make all TupleStream instances throw an IllegalStateException from open() and/or read() if isClosed&lt;/p&gt;

&lt;p&gt;+1 I like this option the most. this would prevent any bad patterns from escaping and fail in a clearer way in the test?&lt;br/&gt;
I think it can be legal to call close twice (treat it as an idempotent operation), but not open after close that feels like a strong breach of api contract.&lt;br/&gt;
Another idea can we shortcut `StreamOpener` to bail early if stream is closed? so we avoid some noise in the logs.&lt;/p&gt;
</comment>
                            <comment id="17768087" author="alex.parvulescu" created="Fri, 22 Sep 2023 16:36:06 +0000"  >&lt;p&gt;adding DeepRandomStream, FeaturesSelectionStream to evaluate for similar bugs&lt;/p&gt;</comment>
                            <comment id="17768110" author="hossman" created="Fri, 22 Sep 2023 17:55:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;given the proliferation of this pattern across multiple classes, does it make sense to move this to a common util class and call it everywhere? not sure if possible but it would help nail it down once for all cases.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah ... maybe some sort of &lt;tt&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; submitAllAndAwaitAggregatingExceptions(ExecutorService exec, List&amp;lt;Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws SolrException&lt;/tt&gt; that returns the list of all the results from the &lt;tt&gt;Future.get()&lt;/tt&gt; calls or throws a &lt;tt&gt;SolrException&lt;/tt&gt; if one of more &lt;tt&gt;get()&lt;/tt&gt; calls throws an exception, with the first exception encountered as the &lt;tt&gt;getCause()&lt;/tt&gt; and the rest as &lt;tt&gt;getSuppressed()&lt;/tt&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;it feels like there is some overlap between these 2 ideas. not sure how the impls would vary but I like waiting for everything to finish and discarding any useless results (prioritize the exception).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hmmm... i&apos;m not really sure how they would overlap?&lt;/p&gt;

&lt;p&gt;It seems to me we either:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;wait for every Future, aggregated the results (and or throw an aggregated exceptions), then shutdown&lt;br/&gt;
OR&lt;/li&gt;
	&lt;li&gt;as soon as any &lt;tt&gt;Future.get()&lt;/tt&gt; call throws an exception, call &lt;tt&gt;shutdownNow&lt;/tt&gt; (in place of the current &lt;tt&gt;shutdown&lt;/tt&gt;) then &lt;tt&gt;awaitTermination()&lt;/tt&gt; to make sure any currently executing &lt;tt&gt;StreamOpen&lt;/tt&gt; instances are done, so ther is no risk they are still running when we throw that exception we caught&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;&amp;gt; Change SolrClientCache so that any method that will add to solrClients throws an IllegalStateException if isClosed&lt;/p&gt;

&lt;p&gt;-0 it doesn&apos;t feel like this class is a correct place to tackle this.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t really understand your response (particularly given your responses to my later ideas) so i&apos;m suspicious that i was vague to the point of confusing you.&lt;/p&gt;

&lt;p&gt;what i&apos;m suggesting is that if this sequence of code happens...&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
SolrClientCache cache = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SolrClientCache();
cache.close();
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cloudMode) {
  cache.getCloudSolrClient(zkHost); &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; should &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; IllegalStateException
&lt;/span&gt;} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
  cache.getHttpSolrClient(url); &lt;span class=&quot;code-comment&quot;&gt;// and/or &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; should &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; IllegalStateException
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;&lt;p&gt;I think it can be legal to call close twice (treat it as an idempotent operation), but not open after close that feels like a strong breach of api contract.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct. the &lt;tt&gt;Closeable.close()&lt;/tt&gt; must be idempotent, but other methods in &lt;tt&gt;Closeable&lt;/tt&gt; impls are allowed to behave any way we want if they are caled after &lt;tt&gt;close()&lt;/tt&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Another idea can we shortcut `StreamOpener` to bail early if stream is closed? so we avoid some noise in the logs.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Even if we re-wrote &lt;tt&gt;StreamOpener&lt;/tt&gt; to look something like this, there would still be a concurrency race condition...&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; TupleWrapper call() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (stream.isClosed()) {
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;code-quote&quot;&gt;&quot;Stream closed&quot;&lt;/span&gt;);
      } &lt;span class=&quot;code-comment&quot;&gt;// RACE CONDITION: at &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; point some other thread could call stream.close()
&lt;/span&gt;      stream.open();
      TupleWrapper wrapper = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TupleWrapper(stream, comp);
      ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;checking &quot;isClosed ?&quot; really needs to happen internally to the logic in the &lt;tt&gt;TupleStream&lt;/tt&gt; instances, and it either needs to happen in blocks &lt;tt&gt;syncrhonized&lt;/tt&gt; by the same gate, or using a &lt;tt&gt;private volatile boolean isClosed&lt;/tt&gt;&lt;/p&gt;</comment>
                            <comment id="17768131" author="alex.parvulescu" created="Fri, 22 Sep 2023 19:20:02 +0000"  >&lt;p&gt;hmm, I think I&apos;m leaning more towards option number 1:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;wait for every Future, aggregated the results (and or throw an aggregated exceptions), then shutdown&lt;/p&gt;&lt;/blockquote&gt;


&lt;blockquote&gt;&lt;p&gt;I don&apos;t really understand your response (particularly given your responses to my later ideas) so i&apos;m suspicious that i was vague to the point of confusing you.&lt;br/&gt;
what i&apos;m suggesting is that if this sequence of code happens...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ah yes thank you for clarifying. now it makes more sense and I agree with this being useful.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Even if we re-wrote StreamOpener to look something like this, there would still be a concurrency race condition...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yes, I fully agree the race would still be there. I was proposing a best effort early termination to avoid having that exception in the logs. the alternative being: it calls open, the internal state check triggers an exception, it needs to bubble up and be handled on the parent close method.&lt;br/&gt;
the way I see it is a simple shortcut in the StreamOpener: `isClosed ? return null;`&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;checking &quot;isClosed ?&quot; really needs to happen internally to the logic in the TupleStream instances, and it either needs to happen in blocks syncrhonized by the same gate, or using a private volatile boolean isClosed&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree with all of this.&lt;/p&gt;

&lt;p&gt;I think there is another case we need to look at in the TupleStream#getReplicas where the cache close would not get called in case of an exception.&lt;/p&gt;


&lt;p&gt;are you already working on a patch for this or can I give it a go?&lt;/p&gt;

</comment>
                            <comment id="17768138" author="hossman" created="Fri, 22 Sep 2023 19:30:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;... I fully agree the race would still be there. I was proposing a best effort early termination to avoid having that exception in the logs. ...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh sure, if we make a &lt;tt&gt;public boolean isClosed()&lt;/tt&gt; then &lt;tt&gt;StreamOpener&lt;/tt&gt; can try to be a good citizen, but from an &quot;and/or ...&quot; perspective: if we use a subclass of &lt;tt&gt;IllegalStateException&lt;/tt&gt; like Lucene&apos;s &lt;tt&gt;AlreadyClosedException&lt;/tt&gt; then &lt;tt&gt;StreamOpener&lt;/tt&gt; can explicitly catch that say &quot;cool, never mind&quot; and return null no matter when/where/how the inner stream throws it (and reliably have hte same behavior regardless of wether the nner stream is closed before/after &lt;tt&gt;StreamOpener&lt;/tt&gt; &apos;s &quot;good citizen&quot; check.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;are you already working on a patch for this or can I give it a go?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;All yours dude, happy you&apos;re interested.&lt;/p&gt;</comment>
                            <comment id="17768392" author="alex.parvulescu" created="Sun, 24 Sep 2023 14:01:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hossman&quot; class=&quot;user-hover&quot; rel=&quot;hossman&quot;&gt;hossman&lt;/a&gt; pushed an early PR for review &lt;a href=&quot;https://github.com/apache/solr/pull/1955&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/solr/pull/1955&lt;/a&gt; please let me know what you think.&lt;/p&gt;

&lt;p&gt;re. the scope of changes. it feels like adding a closed flag to all tule stream impls would introduce a large amount of changes. I am thinking it could be done as a future improvement. let me know what you think.&lt;/p&gt;</comment>
                            <comment id="17768953" author="hossman" created="Tue, 26 Sep 2023 00:38:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;it feels like adding a closed flag to all tule stream impls would introduce a large amount of changes. I am thinking it could be done as a future improvement.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah, sure &#8211; totally fair game to open that as a distinct jira/PR&lt;/p&gt;

&lt;p&gt;(arguably the SolrClientCache changes could/should be a distinct jira from the &lt;tt&gt;Future&lt;/tt&gt; handling as well)&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;pushed an early PR...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;General impressions:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I like the impl of &lt;tt&gt;SolrClientCache.close()&lt;/tt&gt; a lot ... strictly speaking i don&apos;t think &lt;tt&gt;AtomicBoolean&lt;/tt&gt; is actually necessary given that (all?) the methods are synchronized, but i don&apos;t care. i prefer your AtomicBoolean approach over depending on the synchronization (maybe/hopefully enough of the methods can similarly be improved to the point we can remove the synchronization some day)&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;checkState();&lt;/tt&gt; is too vague of a method name to be readable in context w/o consulting javados. The convention in lucene is {{ensureOpen(); }} which i think is really self documenting as you skim code&lt;/li&gt;
	&lt;li&gt;I think having a &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions(...)&lt;/tt&gt; method that is re-used in multiple streams is a fine idea, but I think the &quot;guts&quot; of it should be re-implemented as an &lt;tt&gt;ExecutorUtil&lt;/tt&gt; class that takes an existing &lt;tt&gt;ExecutorService&lt;/tt&gt; as an argument (and does not close it even on exception)
	&lt;ul&gt;
		&lt;li&gt;but the &lt;tt&gt;if (result != null) ...&lt;/tt&gt; logic should not be part of a general &lt;tt&gt;ExecutorUtil&lt;/tt&gt; helper&lt;/li&gt;
		&lt;li&gt;arguably it shouldn&apos;t be part of &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions(...)&lt;/tt&gt; either ... i&apos;m pretty sure if you check the diffs of all the methods where you are using it in your PR not all of them currently ignore &lt;tt&gt;null&lt;/tt&gt; results.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17768964" author="alex.parvulescu" created="Tue, 26 Sep 2023 02:13:52 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I like the impl of&#160;&lt;tt&gt;SolrClientCache.close()&lt;/tt&gt;&#160;a lot ... strictly speaking i don&apos;t think&#160;&lt;tt&gt;AtomicBoolean&lt;/tt&gt;&#160;is actually necessary given that (all?) the methods are synchronized, but i don&apos;t care. i prefer your AtomicBoolean approach over depending on the synchronization (maybe/hopefully enough of the methods can similarly be improved to the point we can remove the synchronization some day)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;you are correct the atomic boolean is not strictly needed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;checkState(); is too vague of a method name to be readable in context w/o consulting javados. The convention in lucene is {{ensureOpen(); }} which i think is really self documenting as you skim code&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah, will move to ensureOpen, sounds better.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think having a StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions(...) method that is re-used in multiple streams is a fine idea, but I think the &quot;guts&quot; of it should be re-implemented as an ExecutorUtil class that takes an existing ExecutorService as an argument (and does not close it even on exception)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. will move it there&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;but the if (result != null) ... logic should not be part of a general ExecutorUtil helper&lt;br/&gt;
arguably it shouldn&apos;t be part of StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions(...) either ... i&apos;m pretty sure if you check the diffs of all the methods where you are using it in your PR not all of them currently ignore null results.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;this part, I am not sold on. looked at all uses again and the large majority filter nulls, one would NPE and the shards ones have no nulls. but I do see the point that a generic method does not need to concern itself with null values, it feels very &apos;implementation dependent&apos;&lt;/p&gt;

&lt;p&gt;thanks for the review so far, will update and ping again&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;edit&amp;#93;&lt;/span&gt; ninja edit. I updated the PR with all of the above except null filtering at the call location. I can add it tomorrow morning.&lt;/p&gt;</comment>
                            <comment id="17769158" author="alex.parvulescu" created="Tue, 26 Sep 2023 12:32:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hossman&quot; class=&quot;user-hover&quot; rel=&quot;hossman&quot;&gt;hossman&lt;/a&gt; the PR is updated please take another look. I will create a followup for the isClosed flag.&lt;/p&gt;</comment>
                            <comment id="17769354" author="hossman" created="Tue, 26 Sep 2023 22:06:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;...looked at all uses again and the large majority filter nulls, one would NPE and the shards ones have no nulls.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s fine ... if the only code paths you&apos;ve changed that &lt;em&gt;don&apos;t&lt;/em&gt; previously filter nulls are impossible to produce nulls (or would NPE if a null was produced) that i&apos;m fine with the idea of refactoring the null-filtering check into &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt; if you prefer that &#8211; as long as it&apos;s mentioned in the javadocs&lt;/p&gt;

&lt;p&gt;(but i&apos;m -1 to th null filtering being in &lt;tt&gt;ExecutorUtil.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt;)&lt;/p&gt;

&lt;p&gt;Only a few questions/concerns about your current diff...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I&apos;m wondering if &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt; and &lt;tt&gt;ExecutorUtil.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt; should return &lt;tt&gt;Collection&amp;lt;T&amp;gt;&lt;/tt&gt; instead of &lt;tt&gt;List&amp;lt;T&amp;gt;&lt;/tt&gt; to help discourage people from making assumptions about the order of the results?
	&lt;ul&gt;
		&lt;li&gt;Either that, or the javadocs should be explicit that the results are returned in the same order as the tasks
		&lt;ul&gt;
			&lt;li&gt;Except if you do refactor the null filtering into &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt; it definitely shouldn&apos;t say that, and should return &lt;tt&gt;Collection&lt;/tt&gt; instead of &lt;tt&gt;List&lt;/tt&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;ExecutorUtil.submitAllAndAwaitAggregatingExceptions&lt;/tt&gt;...
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;List&amp;lt;T&amp;gt; results = new ArrayList&amp;lt;&amp;gt;()&lt;/tt&gt; can be init&apos;ed using &lt;tt&gt;tasks.size()&lt;/tt&gt; as a micro optimization to eliminate the possibility that the &lt;tt&gt;ArrayList&lt;/tt&gt; will ever need to resize itself.&lt;/li&gt;
		&lt;li&gt;let&apos;s add a comment to the &lt;tt&gt;tasks.stream().map(service::submit).collect(Collectors.toUnmodifiableList())&lt;/tt&gt; call ...
		&lt;ul&gt;
			&lt;li&gt;&lt;tt&gt;// Could alternatively use service.invokeAll, but this way we can start looping over futures before all are done&lt;/tt&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;StreamExecutorHelperTest should extend SolrTestCase&lt;/li&gt;
	&lt;li&gt;Generally speaking, we avoid this pattern...
	&lt;ul&gt;
		&lt;li&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
  codeThatThrowsException()
  fail(&lt;span class=&quot;code-quote&quot;&gt;&quot;Expected exception&quot;&lt;/span&gt;);
} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (TypeOfExpectedExeption e) {
  assertThat(somethingAbout(e))
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;It tends to lead to developer confusion/mistakes when modifying tests&lt;/li&gt;
		&lt;li&gt;instead the lucene &amp;amp; solr code base convention is...
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
TypeOfExpectedExeption e = expetThrows(TypeOfExpectedExeption.class, &lt;span class=&quot;code-quote&quot;&gt;&quot;Expected exception&quot;&lt;/span&gt;, () -&amp;gt; codeThatThrowsException());
assertThat(somethingAbout(e))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17769370" author="alex.parvulescu" created="Tue, 26 Sep 2023 23:13:13 +0000"  >&lt;p&gt;I had already moved the null filtering so no trouble there.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I&apos;m wondering if StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions and ExecutorUtil.submitAllAndAwaitAggregatingExceptions should return Collection&amp;lt;T&amp;gt; instead of List&amp;lt;T&amp;gt; to help discourage people from making assumptions about the order of the results?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;sure changed to Collection&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;List&amp;lt;T&amp;gt; results = new ArrayList&amp;lt;&amp;gt;() can be init&apos;ed using tasks.size() as a micro optimization to eliminate the possibility that the ArrayList will ever need to resize itself.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;sure, added initial size, added comment too&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Generally speaking, we avoid this pattern...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;agreed, this looks much nicer.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;PR updated with all of the above&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17769682" author="alex.parvulescu" created="Wed, 27 Sep 2023 15:57:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hossman&quot; class=&quot;user-hover&quot; rel=&quot;hossman&quot;&gt;hossman&lt;/a&gt; I think this covers everything. all is missing is a quick +1 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17769727" author="hossman" created="Wed, 27 Sep 2023 17:56:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;I had already moved the null filtering so no trouble there.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;right.&#160; my point in that comment was that if you were sure all of the &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions()&lt;/tt&gt; callers didn&apos;t care about nulls, and you want to move the null check &lt;em&gt;BACK&lt;/em&gt; into &lt;tt&gt;StreamExecutorHelper.submitAllAndAwaitAggregatingExceptions()&lt;/tt&gt; i&apos;d be fine with that either way.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;sure changed to Collection&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think the javadocs may still refer to the results as a &quot;list&quot; ?&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;all is missing is a quick +1 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh, Sorry ... I&apos;m definitely +1 ... this is all just nitpick.&lt;/p&gt;

&lt;p&gt;commit &amp;amp; backport whenever you&apos;re happy&lt;/p&gt;</comment>
                            <comment id="17769793" author="jira-bot" created="Wed, 27 Sep 2023 20:44:21 +0000"  >&lt;p&gt;Commit f0fcd300c896b858ae83235ecdb0a109eaea5cea in solr&apos;s branch refs/heads/main from Alex Deparvu&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=solr.git;h=f0fcd300c89&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=solr.git;h=f0fcd300c89&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16992&quot; title=&quot;Non-reproducible StreamingTest failures -- suggests CloudSolrStream concurency race condition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16992&quot;&gt;&lt;del&gt;SOLR-16992&lt;/del&gt;&lt;/a&gt; Non-reproducible StreamingTest failures (#1955)&lt;/p&gt;

&lt;p&gt;&amp;#8211; suggests CloudSolrStream concurency race condition&lt;/p&gt;</comment>
                            <comment id="17769795" author="jira-bot" created="Wed, 27 Sep 2023 20:47:57 +0000"  >&lt;p&gt;Commit 12b7579573fb7598be3deca8498249c5f00eb821 in solr&apos;s branch refs/heads/branch_9x from Alex Deparvu&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=solr.git;h=12b7579573f&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=solr.git;h=12b7579573f&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-16992&quot; title=&quot;Non-reproducible StreamingTest failures -- suggests CloudSolrStream concurency race condition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-16992&quot;&gt;&lt;del&gt;SOLR-16992&lt;/del&gt;&lt;/a&gt; Non-reproducible StreamingTest failures (#1955)&lt;/p&gt;

&lt;p&gt;&amp;#8211; suggests CloudSolrStream concurency race condition&lt;/p&gt;

&lt;p&gt;(cherry picked from commit f0fcd300c896b858ae83235ecdb0a109eaea5cea)&lt;/p&gt;</comment>
                            <comment id="17769797" author="alex.parvulescu" created="Wed, 27 Sep 2023 20:50:25 +0000"  >&lt;p&gt;thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hossman&quot; class=&quot;user-hover&quot; rel=&quot;hossman&quot;&gt;hossman&lt;/a&gt; for the continued review! PR was merged and backported&lt;/p&gt;</comment>
                            <comment id="17775421" author="alex.parvulescu" created="Sun, 15 Oct 2023 19:57:02 +0000"  >&lt;p&gt;Closing after the 9.4.0 release&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13550899">SOLR-16983</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="13063105" name="OUTPUT-org.apache.solr.client.solrj.io.stream.StreamingTest.txt" size="88174" author="hossman" created="Fri, 22 Sep 2023 02:05:43 +0000"/>
                            <attachment id="13063106" name="thetaphi_solr_Solr-main-Linux_14679.log.txt" size="169373" author="hossman" created="Fri, 22 Sep 2023 02:05:28 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 4 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z1kim0:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>