<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 03:54:13 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-6137] Managed Schema / Schemaless and SolrCloud concurrency issues</title>
                <link>https://issues.apache.org/jira/browse/SOLR-6137</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;This is a follow up to a message on the mailing list, linked here: &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-dev/201406.mbox/%3CCAKfebOOcMeVEb010SsdcH8nta%3DyonMK5R7dSFOsbJ_tnre0O7w%40mail.gmail.com%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-dev/201406.mbox/%3CCAKfebOOcMeVEb010SsdcH8nta%3DyonMK5R7dSFOsbJ_tnre0O7w%40mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The Managed Schema integration with SolrCloud seems pretty limited.&lt;/p&gt;

&lt;p&gt;The issue I&apos;m running into is variants of the issue that schema changes are not pushed to all shards/replicas synchronously.  So, for example, I can make the following two requests:&lt;br/&gt;
1) add a field to the collection on server1 using the Schema API&lt;br/&gt;
2) add a document with the new field, the document is routed to a core on server2&lt;/p&gt;

&lt;p&gt;Then, there appears to be a race between when the document is processed by the core on server2 and when the core on server2, via the ZkIndexSchemaReader, gets the new schema.  If the document is processed first, I get a 400 error because the field doesn&apos;t exist.  This is easily reproducible by adding a sleep to the ZkIndexSchemaReader&apos;s processing.&lt;/p&gt;

&lt;p&gt;I hit a similar issue with Schemaless: the distributed request handler sends out the document updates, but there is no guarantee that the other shards/replicas see the schema changes made by the update.chain.&lt;/p&gt;

&lt;p&gt;Another issue I noticed today: making multiple schema API calls concurrently can block; that is, one may get through and the other may infinite loop.&lt;/p&gt;

&lt;p&gt;So, for reference, the issues include:&lt;br/&gt;
1) Schema API changes return success before all cores are updated; subsequent calls attempting to use new schema may fail&lt;br/&gt;
2) Schemaless changes may fail on replicas/other shards for the same reason&lt;br/&gt;
3) Concurrent Schema API changes may block&lt;/p&gt;

&lt;p&gt;From Steve Rowe on the mailing list:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Schema API users, delaying a couple of seconds after adding fields before using them should workaround this problem.  While not ideal, I think schema field additions are rare enough in the Solr collection lifecycle that this is not a huge problem.&lt;/p&gt;

&lt;p&gt;For schemaless users, the picture is worse, as you noted.  Immediate distribution of documents triggering schema field addition could easily prove problematic.  Maybe we need a schema update blocking mode, where after the ZK schema node watch is triggered, all new request processing is halted until the schema is finished downloading/parsing/swapping out? (Such a mode should help Schema API users too.)&lt;/p&gt;&lt;/blockquote&gt;</description>
                <environment></environment>
        <key id="12718524">SOLR-6137</key>
            <summary>Managed Schema / Schemaless and SolrCloud concurrency issues</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sarowe">Steven Rowe</assignee>
                                    <reporter username="gchanan">Gregory Chanan</reporter>
                        <labels>
                    </labels>
                <created>Thu, 5 Jun 2014 02:26:11 +0000</created>
                <updated>Wed, 30 Oct 2019 17:49:03 +0000</updated>
                            <resolved>Tue, 15 Jul 2014 19:30:17 +0000</resolved>
                                                    <fixVersion>4.10</fixVersion>
                    <fixVersion>6.0</fixVersion>
                                    <component>Schema and Analysis</component>
                    <component>SolrCloud</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="14018425" author="gchanan" created="Thu, 5 Jun 2014 02:36:36 +0000"  >&lt;p&gt;The Schema API blocking mode is an interesting idea, I&apos;d want to think more about that.&lt;/p&gt;

&lt;p&gt;In some sense, the schemaless issue seems easier to solve than the Schema API issue.  This is because if we run all (or more) of the update chain, instead of just skipping to the distributed update handler on the forwarded nodes, we could have all the cores apply the schema changes, so we are guaranteed of having the correct schema on each core.  We&apos;d need to be smarter about trying to update the schema in ZK (as I noted above, concurrent schema changes may fail currently).  But that doesn&apos;t seem impossible.&lt;/p&gt;

&lt;p&gt;The Schema API issue does seem more difficult.  A blocking mode could work in theory, though I guess one complication is you need to wait for all the cores that use the config, not just all the cores of the collection.  Although, perhaps we should just throw in some checks that only one collection is using a certain managed schema config at a time; it may make the logic easier and it seems very unlikely the user actually wants to use the same schema for multiple collections (I did that myself the first time before realizing why it didn&apos;t make any sense).&lt;/p&gt;

&lt;p&gt;As Steve noted above, a blocking mode could be used by the schemaless functionality as well, instead of what I wrote above.&lt;/p&gt;</comment>
                            <comment id="14018455" author="yseeley@gmail.com" created="Thu, 5 Jun 2014 03:52:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;In some sense, the schemaless issue seems easier to solve than the Schema API issue. This is because if we run all (or more) of the update chain, instead of just skipping to the distributed update handler on the forwarded nodes, we could have all the cores apply the schema changes, so we are guaranteed of having the correct schema on each core.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right.  Schemaless &lt;b&gt;should&lt;/b&gt; be a non-issue.  The type-guessing logic should be run on replicas as well.  If the replica hasn&apos;t seen the change yet, then it will guess the same type, and try to add it to the schema.  It should fail due to optimistic locking and the fact the leader already added it, re-read the schema, and then successfully find the field.  It&apos;s the same case as a single node with multiple threads both encountering the new field at around the same time.&lt;/p&gt;

&lt;p&gt;Although the schema API needs a blocking mode, no blocking mode should be added to schemaless... that&apos;s what the optimistic concurrency is for.&lt;/p&gt;</comment>
                            <comment id="14019403" author="steve_rowe" created="Thu, 5 Jun 2014 23:31:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;making multiple schema API calls concurrently can block; that is, one may get through and the other may infinite loop.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=alexey.serba&quot; class=&quot;user-hover&quot; rel=&quot;alexey.serba&quot;&gt;alexey.serba&lt;/a&gt; mentioned that problem to me a while back.  IIRC this is a bug in the optimistic concurrency implementation.  I&apos;ll dig up his info and make an issue.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Schema API changes return success before all cores are updated; subsequent calls attempting to use new schema may fail&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One way to fix this may be to return the schema ZK node version from Schema API modification methods, and add a request param requiring a minimum schema ZK node version prior to binding a schema snapshot to the request.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;no blocking mode should be added to schemaless... that&apos;s what the optimistic concurrency is for.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, thanks Yonik, I&apos;d forgotten optimistic concurrency&apos;s part in the schemaless design.&lt;/p&gt;</comment>
                            <comment id="14019432" author="steve_rowe" created="Thu, 5 Jun 2014 23:59:37 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;making multiple schema API calls concurrently can block; that is, one may get through and the other may infinite loop.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=alexey.serba&quot; class=&quot;user-hover&quot; rel=&quot;alexey.serba&quot;&gt;alexey.serba&lt;/a&gt; mentioned that problem to me a while back.  IIRC this is a bug in the optimistic concurrency implementation.  I&apos;ll dig up his info and make an issue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6145&quot; title=&quot;Concurrent Schema API field additions can result in endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6145&quot;&gt;&lt;del&gt;SOLR-6145&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14019456" author="yseeley@gmail.com" created="Fri, 6 Jun 2014 00:34:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;One way to fix this may be to return the schema ZK node version from Schema API modification methods, and add a request param requiring a minimum schema ZK node version prior to binding a schema snapshot to the request.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s an interesting idea, but it would then require users of the schema API to add versions to all their  subsequent update requests (and no clear idea when they could stop, and it gets even more interestnig with multiple update clients).&lt;br/&gt;
An alternative would be to proactively check if there is a new schema version if we fail to find a field.  The overhead shouldn&apos;t be an issue if we would otherwise fail the request.&lt;/p&gt;

&lt;p&gt;We should be careful to only do this check when necessary.  For example, it seems like that queries for non-existent fields should not normally trigger a ZK lookup (and the schema only changes with the IndexSearcher anyway).  But then again, a delete by query should check (it&apos;s indexing side, and one would want to be able to add a field, add a doc with that field, then do a DBQ with that field).  It&apos;s context specific - tricky stuff.&lt;/p&gt;</comment>
                            <comment id="14019582" author="gchanan" created="Fri, 6 Jun 2014 05:01:02 +0000"  >&lt;p&gt;This is indeed tricky stuff.  Consider too if the Schema API was expanded to allow the full range of actions you could do to an unmanaged schema with solr down, i.e. removing fields or changing types.  Then, only checking on non-existing fields wouldn&apos;t work.&lt;/p&gt;

&lt;p&gt;There&apos;s also the case of the same field being added simultaneously on different nodes with different types via schemaless.  I haven&apos;t actually tested that, but I bet it would hang like &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6145&quot; title=&quot;Concurrent Schema API field additions can result in endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6145&quot;&gt;&lt;del&gt;SOLR-6145&lt;/del&gt;&lt;/a&gt;...&lt;/p&gt;

&lt;p&gt;How about something like this for schemaless (I haven&apos;t totally thought this through, I&apos;ll take a closer look tomorrow to see if this is feasible):&lt;br/&gt;
As I suggested before, we run more of the update.chain so the fields are added on each core.  If the the update to ZK fails because of version mismatch, we download the new schema and try to apply our changes again.  If the field already exists with the correct type, we don&apos;t need to do anything.  If the field exists with the wrong type, we throw an exception and the update should fail (which seems correct, because that would happen if the updates were not done simultaneously).&lt;/p&gt;</comment>
                            <comment id="14019872" author="yseeley@gmail.com" created="Fri, 6 Jun 2014 14:16:37 +0000"  >&lt;p&gt;Gregory, the schemaless case is covered I think... we either re-run the type guessing logic on replicas, or pass in a requireSchema=&amp;lt;version&amp;gt; parameter that would be checked by the replicas.  Races between different nodes are handled via optimistic concurrency.&lt;/p&gt;</comment>
                            <comment id="14039660" author="gchanan" created="Sat, 21 Jun 2014 02:55:06 +0000"  >&lt;p&gt;Here&apos;s a patch that addresses the issue with schemaless in a distributed environment.&lt;/p&gt;

&lt;p&gt;Overview:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Fixes an NPE issue if there are no dynamic fields and the schema is reloaded&lt;/li&gt;
	&lt;li&gt;The AddSchemaFieldsUpdateProcessorFactory now implements UpdateRequestProcessorFactory.RunAlways so we can guarantee that the schema additions happen on every core&lt;/li&gt;
	&lt;li&gt;The AddSchemaFieldsUpdateProcessor is careful about not updating the to the latest schema while it is processing.  Without this, it can detect that the field exists from the latest schema, but the request&apos;s schema won&apos;t be updated and an unknown field error will occur.  There may be a more efficient way to do this by making sure the request schema is updated, but the above approach should work&lt;/li&gt;
	&lt;li&gt;Adds a test that fails without the patch&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14039662" author="gchanan" created="Sat, 21 Jun 2014 03:03:19 +0000"  >&lt;p&gt;Forgot to mention, the above patch assumes &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6180&quot; title=&quot;Callers of ManagedIndexSchema mutators should hold the schemaUpdateLock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6180&quot;&gt;&lt;del&gt;SOLR-6180&lt;/del&gt;&lt;/a&gt; is applied.&lt;/p&gt;</comment>
                            <comment id="14039699" author="gchanan" created="Sat, 21 Jun 2014 05:08:41 +0000"  >&lt;p&gt;v2 patch: test handles setting the schema file in a standard way.&lt;/p&gt;</comment>
                            <comment id="14044359" author="gchanan" created="Thu, 26 Jun 2014 05:28:15 +0000"  >&lt;p&gt;Here&apos;s a new version of the patch.  The previous one is dependent on javabin serialization.  In particular, the javabin serialization preserves the types of field values, whereas XML does not.  This means that if the parsing/schema addition happen before the distributed phase and we use XML serialization, the types can switch during the distributed phase and the field types may end up incorrect.&lt;/p&gt;

&lt;p&gt;Instead, a better solution seems to be to move the parsing/schema addition to after the distributed phase.  That way, we&apos;ll run the parsing on the replicas and the types will be correct.&lt;/p&gt;</comment>
                            <comment id="14044366" author="gchanan" created="Thu, 26 Jun 2014 05:41:42 +0000"  >&lt;p&gt;One small issue I noticed is that there is a race between parsing and schema addition.  The AddSchemaFieldsUpdateProcessor handles this by only working on a fixed schema, so the schema doesn&apos;t change underneath it.  If it decides on a schema addition and that fails (because another addition beat it), it will grab the latest schema and retry.  But the parsers don&apos;t do that so the core&apos;s schema can change in the middle of parsing.  It may make sense to defend against that by moving the retry code from the AddSchemaFieldsUpdateProcessor to some processor that runs before all the parsers.  The downside is if the schema addition fails, you have to rerun all the parsers, but that may be a minor concern.&lt;/p&gt;

&lt;p&gt;This may not actually matter.  Consider the case tested at the end of the test: two documents are simultaneously inserted with the same field having a Long and Date value.  Assume the Date wins the schema &quot;race&quot; and is updated first.  While parsing the Long, each parser may see the schema as having a date field or no field.  If a valid parser (that is, one that can modify the field value) sees a date field, it won&apos;t do any modifications because shouldMutate will fail, leaving the object in whatever state the serializer left it (either Long or String).  If it sees no field, it will mutate the object to create a Long object.  In either case, we should get an error at the point we actually create the lucene document, because neither a Long nor String-representation-of-a-long can be stored in a Date field.  This is pretty difficult to reason about though, it may be better to just do the above.  But I would prefer to tackle that in another jira.&lt;/p&gt;</comment>
                            <comment id="14044371" author="gchanan" created="Thu, 26 Jun 2014 05:53:00 +0000"  >&lt;p&gt;attached the wrong patch previously.&lt;/p&gt;</comment>
                            <comment id="14050613" author="steve_rowe" created="Wed, 2 Jul 2014 19:40:38 +0000"  >&lt;p&gt;Patch against current trunk, along with &lt;tt&gt;AddSchemaFieldsUpdateProcessorFactory.java.svnpatch.rej&lt;/tt&gt;, the rejected elements of &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gchanan&quot; class=&quot;user-hover&quot; rel=&quot;gchanan&quot;&gt;gchanan&lt;/a&gt;&apos;s v4 patch - it looks like the v4 patch was against an earlier version of the patch or something, since the removed lines don&apos;t exist on trunk.  The patch is my attempt at merging current trunk with the additions from the v4 patch.&lt;/p&gt;

&lt;p&gt;One problem blocking compilation: &lt;tt&gt;oldSchema&lt;/tt&gt;&apos;s update lock is pulled from &lt;tt&gt;IndexSchema.getSchemaUpdateLock()&lt;/tt&gt;, which doesn&apos;t exist (that method is on &lt;tt&gt;ManagedIndexSchema&lt;/tt&gt;) - in my patch, I&apos;ve cast to &lt;tt&gt;oldSchema&lt;/tt&gt; to &lt;tt&gt;ManagedIndexSchema&lt;/tt&gt; to make that compile, but maybe the intent was to move &lt;tt&gt;getSchemaUpdateLock()&lt;/tt&gt; to &lt;tt&gt;IndexSchema&lt;/tt&gt;?  (That&apos;s not part of the v4 patch, maybe &lt;tt&gt;git add&lt;/tt&gt; is needed?)&lt;/p&gt;

&lt;p&gt;Also, Gregory, when you post patches on JIRA issues, please use the same name for each iteration of your patch, rather than adding &quot;vN&quot;, where N increases with each patch version - JIRA will gray out older versions.&lt;/p&gt;</comment>
                            <comment id="14050630" author="steve_rowe" created="Wed, 2 Jul 2014 19:54:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;it looks like the v4 patch was against an earlier version of the patch or something&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Crap, re-reading the comments I see that &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gchanan&quot; class=&quot;user-hover&quot; rel=&quot;gchanan&quot;&gt;gchanan&lt;/a&gt;&apos;s patch assumes that the patch on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6180&quot; title=&quot;Callers of ManagedIndexSchema mutators should hold the schemaUpdateLock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6180&quot;&gt;&lt;del&gt;SOLR-6180&lt;/del&gt;&lt;/a&gt; is applied first, I&apos;ll start looking there now - I&apos;m guessing that this is the source of the patch problems I noted above.&lt;/p&gt;</comment>
                            <comment id="14054101" author="gchanan" created="Mon, 7 Jul 2014 19:46:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;Crap, re-reading the comments I see that Gregory Chanan&apos;s patch assumes that the patch on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6180&quot; title=&quot;Callers of ManagedIndexSchema mutators should hold the schemaUpdateLock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6180&quot;&gt;&lt;del&gt;SOLR-6180&lt;/del&gt;&lt;/a&gt; is applied first, I&apos;ll start looking there now - I&apos;m guessing that this is the source of the patch problems I noted above.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=steve_rowe&quot; class=&quot;user-hover&quot; rel=&quot;steve_rowe&quot;&gt;steve_rowe&lt;/a&gt; thanks for taking a look.  You are correct that &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6180&quot; title=&quot;Callers of ManagedIndexSchema mutators should hold the schemaUpdateLock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6180&quot;&gt;&lt;del&gt;SOLR-6180&lt;/del&gt;&lt;/a&gt; should be looked at first &amp;#8211; sorry for not making that clearer above.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, Gregory, when you post patches on JIRA issues, please use the same name for each iteration of your patch, rather than adding &quot;vN&quot;, where N increases with each patch version - JIRA will gray out older versions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;thanks for letting me know, I&apos;ll do that from now on.&lt;/p&gt;</comment>
                            <comment id="14061013" author="steve_rowe" created="Mon, 14 Jul 2014 18:47:08 +0000"  >&lt;p&gt;Patch with minor modifications from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gchanan&quot; class=&quot;user-hover&quot; rel=&quot;gchanan&quot;&gt;gchanan&lt;/a&gt;&apos;s v4 patch:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Modified other schemaless solrconfig.xml update chains (including in the schemaless example) to put Log &amp;amp; DistributedUpdateProcessorFactory before parsing, as in the test config file solrconfig-schemaless.xml&lt;/li&gt;
	&lt;li&gt;Renamed TestCloudManagedSchemaless-&amp;gt;TestCloudSchemaless (schemaless requires managed; shorter = better)&lt;/li&gt;
	&lt;li&gt;In TestCloudSchemaless, randomized the client to send updates to.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;A couple of points about the previous overview:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Overview:&lt;br/&gt;
Fixes an NPE issue if there are no dynamic fields and the schema is reloaded&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is &quot;dynamic copy fields&quot;, not &quot;dynamic fields&quot; - I had to enable this fix to run the new test without the other changes, since Solr will NPE otherwise.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The AddSchemaFieldsUpdateProcessorFactory now implements UpdateRequestProcessorFactory.RunAlways so we can guarantee that the schema additions happen on every core&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is no longer necessary, since &lt;tt&gt;RunAlways&lt;/tt&gt; only affects processors ordered before the distributed update processor; with Gregory&apos;s v4 patch, only the log update processor comes before the distributed update processor, and it already implements &lt;tt&gt;RunAlways&lt;/tt&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I&apos;ll commit tomorrow if there are no objections.&lt;/p&gt;</comment>
                            <comment id="14062352" author="steve_rowe" created="Tue, 15 Jul 2014 17:20:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gchanan&quot; class=&quot;user-hover&quot; rel=&quot;gchanan&quot;&gt;gchanan&lt;/a&gt;, I&apos;ve committed your patch to trunk and branch_4x with minor modifications (see previous comment).&lt;/p&gt;

&lt;p&gt;I think what&apos;s left are:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Schema API changes return success before all cores are updated; subsequent calls attempting to use new schema may fail&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;and &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One small issue I noticed is that there is a race between parsing and schema addition. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A new issue for this one seems like a good idea.&lt;/p&gt;

&lt;p&gt;Anything else?&lt;/p&gt;</comment>
                            <comment id="14062508" author="gchanan" created="Tue, 15 Jul 2014 19:12:46 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sarowe%40syr.edu&quot; class=&quot;user-hover&quot; rel=&quot;sarowe@syr.edu&quot;&gt;sarowe@syr.edu&lt;/a&gt;!  Your changes make sense.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Schema API changes return success before all cores are updated; subsequent calls attempting to use new schema may fail&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I filed &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6249&quot; title=&quot;Schema API changes return success before all cores are updated&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6249&quot;&gt;&lt;del&gt;SOLR-6249&lt;/del&gt;&lt;/a&gt; for this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One small issue I noticed is that there is a race between parsing and schema addition.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I filed &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6250&quot; title=&quot;Schemaless parsing does not work on a consistent schema&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6250&quot;&gt;SOLR-6250&lt;/a&gt; for this&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anything else?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nope.&lt;/p&gt;</comment>
                            <comment id="14062529" author="steve_rowe" created="Tue, 15 Jul 2014 19:30:17 +0000"  >&lt;p&gt;Resolving - remaining issues will be dealt with on the issues Gregory raised.&lt;/p&gt;

&lt;p&gt;Thanks Gregory!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12655591" name="SOLR-6137.patch" size="28173" author="sarowe" created="Mon, 14 Jul 2014 18:47:08 +0000"/>
                            <attachment id="12651798" name="SOLR-6137.patch" size="27345" author="gchanan" created="Sat, 21 Jun 2014 02:55:06 +0000"/>
                            <attachment id="12651808" name="SOLR-6137v2.patch" size="26007" author="gchanan" created="Sat, 21 Jun 2014 05:08:41 +0000"/>
                            <attachment id="12652555" name="SOLR-6137v3.patch" size="4785" author="gchanan" created="Thu, 26 Jun 2014 05:28:15 +0000"/>
                            <attachment id="12652559" name="SOLR-6137v4.patch" size="25795" author="gchanan" created="Thu, 26 Jun 2014 05:53:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>396723</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 19 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1waun:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>396842</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>