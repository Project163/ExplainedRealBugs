<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 03:35:24 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-4589] 4.x + enableLazyFieldLoading + large multivalued fields + varying fl = pathological CPU load &amp; response time</title>
                <link>https://issues.apache.org/jira/browse/SOLR-4589</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;Following up on a &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-solr-user/201302.mbox/%3C1362019882934-4043543.post@n3.nabble.com%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;user report of exterme CPU usage in 4.1&lt;/a&gt;, I&apos;ve discovered that the following combination of factors can result in extreme CPU usage and excessively HTTP response times...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Solr 4.x (tested 3.6.1, 4.0.0, and 4.2.0)&lt;/li&gt;
	&lt;li&gt;enableLazyFieldLoading == true (included in example solrconfig.xml)&lt;/li&gt;
	&lt;li&gt;documents with a large number of values in multivalued fields (eg: tested ~10-15K values)&lt;/li&gt;
	&lt;li&gt;multiple requests returning the same doc with different &quot;fl&quot; lists&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I haven&apos;t dug into the route cause yet, but the essential observations is: if lazyloading is used in 4.x, then once a document has been fetched with an initial fl list X, subsequent requests for that document using a differnet fl list Y can be many orders of magnitute slower (while pegging the CPU) &amp;#8211; even if those same requests using fl Y uncached (or w/o lazy laoding) would be extremely fast.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12637241">SOLR-4589</key>
            <summary>4.x + enableLazyFieldLoading + large multivalued fields + varying fl = pathological CPU load &amp; response time</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hossman">Chris M. Hostetter</assignee>
                                    <reporter username="hossman">Chris M. Hostetter</reporter>
                        <labels>
                    </labels>
                <created>Fri, 15 Mar 2013 18:25:14 +0000</created>
                <updated>Mon, 9 May 2016 18:48:09 +0000</updated>
                            <resolved>Wed, 20 Mar 2013 17:15:14 +0000</resolved>
                                    <version>4.0</version>
                    <version>4.1</version>
                    <version>4.2</version>
                                    <fixVersion>4.2.1</fixVersion>
                    <fixVersion>4.3</fixVersion>
                    <fixVersion>6.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13603645" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"  >
&lt;p&gt;The attached files include a test.sh script that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;creates some data where fields have a large number of values&lt;/li&gt;
	&lt;li&gt;loads the data into solr&lt;/li&gt;
	&lt;li&gt;execs 2 queries for a single doc using two different fl options&lt;/li&gt;
	&lt;li&gt;triggers a commit to flush caches&lt;/li&gt;
	&lt;li&gt;execs the same two queries in a differnet order&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Also attached are the raw results of running this script on my Thinkpad T430s against the example jetty &amp;amp; solr configs where the version of solr, lazyfield loading, and the directory impl were varried...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;version of solr
	&lt;ul&gt;
		&lt;li&gt;3.6.1&lt;/li&gt;
		&lt;li&gt;4.0.0&lt;/li&gt;
		&lt;li&gt;4.2.0&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;lazy field loading:
	&lt;ul&gt;
		&lt;li&gt;lazy: default example configs&lt;/li&gt;
		&lt;li&gt;nolazy: perl -i -pe &apos;s
{&amp;lt;enableLazyFieldLoading&amp;gt;true}
{&amp;lt;enableLazyFieldLoading&amp;gt;false}
&lt;p&gt;&apos; solrconfig.xml&lt;/p&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;directory impl:
	&lt;ul&gt;
		&lt;li&gt;mmap: java -Dsolr.directoryFactory=solr.MMapDirectoryFactory -jar start.jar&lt;/li&gt;
		&lt;li&gt;nio: java -Dsolr.directoryFactory=solr.NIOFSDirectoryFactory -jar start.jar&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There was no apparent difference in the directory impl choosen, or between 4.0 and 4.2.  Here&apos;s the summary results for 3.6 vs 4.0 using mmap...&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; step &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; 3.6 nolazy &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; 3.6 lazy &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; 4.0 nolazy &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; 4.0 lazy &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; small fl &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.308s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.998s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.260s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.202s &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; big fl &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.178s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.263s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.084s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;b&gt;16m15.735s&lt;/b&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; commit &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; XXXXXXX &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; XXXXXXX &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; XXXXXXX &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; XXXXXXX &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; big fl &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.157s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.118s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.218s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.133s &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; small fl &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.036s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.035s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0m0.049s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;b&gt;3m2.814s&lt;/b&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;Also attached is also the results of a single test I did running Solr 4.0 pointed at the configs &amp;amp; index built with 3.6.1 to rule out codec changes: it behaved essentially the same as the 4.0 tests that built the index from scratch.&lt;/p&gt;</comment>
                            <comment id="13603649" author="yseeley@gmail.com" created="Fri, 15 Mar 2013 18:29:59 +0000"  >&lt;p&gt;I wonder if this could be related to index compression (and maybe the same block being repeatedly decompressed for each lazy field being accessed?)&lt;/p&gt;</comment>
                            <comment id="13603683" author="thetaphi" created="Fri, 15 Mar 2013 18:52:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;I wonder if this could be related to index compression (and maybe the same block being repeatedly decompressed for each lazy field being accessed?)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This also happens in Solr 4.0, which had no compression.&lt;/p&gt;

&lt;p&gt;The reason here might be the changes in stored fields altogether. Lucene natively no longer has support for lazy field loading, but there is a &quot;backwards layer&quot; just for Solr in modules/misc (LazyDocument.java). The document does not use maps to lookup, if you have many fields its always a scan through the ArrayList of all fields in the document. The lazyness in LazyDocument is only that the &lt;b&gt;whole&lt;/b&gt; document is loaded delayed, but no longer single fields.&lt;/p&gt;</comment>
                            <comment id="13603845" author="hossman" created="Fri, 15 Mar 2013 21:02:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;Lucene natively no longer has support for lazy field loading, but there is a &quot;backwards layer&quot; just for Solr in modules/misc (LazyDocument.java)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah .. LazyDocument is seriously evil...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The document does not use maps to lookup, if you have many fields its always a scan through the ArrayList of all fields in the document.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s worse then that though &amp;#8211; having many fields and scanning through them all to fetch a single field value (or an array of field values for a single name) is a cost that has to be paid in 4.x regardless of whether you are using LazyDocument or not, the root problem here seems to be having fields that contain many &lt;em&gt;values&lt;/em&gt;.  That problem is exacerbated by the fact that unlike 3.x lazy loading, 4.x LaxyDocument/LazyField doesn&apos;t do anything to &quot;cache&quot; the fields you&apos;ve already asked for.&lt;/p&gt;

&lt;p&gt;Below are my notes from investigating this and trying to get up to speed on the new world order of document loading w/o FieldSelector.  I&apos;ll experiment with some fixes after i get some food...&lt;/p&gt;

&lt;hr /&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2308&quot; title=&quot;Separately specify a field&amp;#39;s type&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-2308&quot;&gt;&lt;del&gt;LUCENE-2308&lt;/del&gt;&lt;/a&gt; - r1162347&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;IndexReader.doc(int,FieldSelector) deleted&lt;/li&gt;
	&lt;li&gt;FieldSelector moved to misc&lt;/li&gt;
	&lt;li&gt;new concept StoredFieldVisitor introduced
	&lt;ul&gt;
		&lt;li&gt;void IndexReader.document(int docID, StoredFieldVisitor visitor)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;new impl DocumentStoredFieldVisitor extends StoredFieldVisitor&lt;/li&gt;
	&lt;li&gt;new impl FieldSelectorVisitor extends StoredFieldVisitor
	&lt;ul&gt;
		&lt;li&gt;appears all the old FieldSelector logic from IndexReader moved here?&lt;/li&gt;
		&lt;li&gt;contains a private &quot;LazyField extends Field&quot; that caches field values once fetched&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;SolrIndexSearcher modified to use FieldSelectorVisitor&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2621&quot; title=&quot;Extend Codec to handle also stored fields and term vectors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-2621&quot;&gt;&lt;del&gt;LUCENE-2621&lt;/del&gt;&lt;/a&gt; - r1199779&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;eliminates FieldSelector &amp;amp; FieldSelectorVisitor&lt;/li&gt;
	&lt;li&gt;leaves StoredFieldVisitor &amp;amp; DocumentStoredFieldVisitor intact&lt;/li&gt;
	&lt;li&gt;introduced public LazyDocument containing &quot;LazyField implements IndexableField&quot;
	&lt;ul&gt;
		&lt;li&gt;this version of LazyField does &lt;em&gt;not&lt;/em&gt; cache any data once fetched&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;changes SolrIndexSearcher&apos;s SetNonLazyFieldSelector to extend StoredFieldVisitor
	&lt;ul&gt;
		&lt;li&gt;add&apos;s LazyField to the Document for any fields not immediately needed&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;The crux of the problem is that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;LazyDocument is lazy about loading the doc, but once you ask for the value any LazyField, the entire Document (with all underlying IndexableField values) is loaded.&lt;/li&gt;
	&lt;li&gt;even though the entire document has been loaded once a single LazyField is used, the performance of iterating over LazyField&apos;s is &lt;b&gt;TERRIBLE&lt;/b&gt; when there are lots of values for a single field&lt;/li&gt;
	&lt;li&gt;requests for the value of individual LazyFields are not cached/stored anywhere, so the poor performace affects all subsequent re-uses of the same LazyDocuments&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Details...&lt;/p&gt;

&lt;p&gt;The state tracked in a LazyField is a refrence back to the underlying LazyDocument, the field name, and the &quot;num&quot; offset of this IndexableField in the list of values for that field name.  When you ask the LazyField for it&apos;s value, it asks the underlying LazyDocument to fetch the entire Document (if it hasn&apos;t already) and then it asks that Document for &lt;em&gt;all&lt;/em&gt; values of the assocaited field name as an arry, and then it looks up it&apos;s &quot;num&quot; offset in that array.&lt;/p&gt;

&lt;p&gt;So if you build up an (outer) Document containing N LazyField instances for field named &quot;foo&quot; (as is done in Solr&apos;s SetNonLazyFieldSelector), and then try to iterate over the values with something like &lt;tt&gt;String[] values = outerDoc.getValues(&quot;foo&quot;);&lt;/tt&gt; under the covers LazyField will load every value of every field of that document into memory as an &quot;innerDoc&quot;, that innerDoc will be asked N times to generate a new IndexableField[] of every value of field &quot;foo&quot; (which BTW: involves iterating over every IndexableField value of every field) and N-1 elements of that array will then be ignored and thrown away.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;It&apos;s not clear to me why FieldSelectorVisitor was eliminated in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2621&quot; title=&quot;Extend Codec to handle also stored fields and term vectors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-2621&quot;&gt;&lt;del&gt;LUCENE-2621&lt;/del&gt;&lt;/a&gt; (no discussion in the comments on point) but it&apos;s also not clear to me why LazyDocument+LazyField would ever be a good idea in any application that had more then a handful of fields (and if you don&apos;t have very many fields, why are you lazy loading?).  &lt;/p&gt;

&lt;p&gt;It&apos;s also not clear to me why the LazyDocument version of LazyField doesn&apos;t include the same caching logic as the version that was included in FieldSelectorVisitor (or the older lazy loading code in 3.6) because w/o that the usage pattern in Solr &amp;#8211; in which Document objects are cached &amp;#8211; results in the worst of all possible worlds: once a Document is cached with only a small subset of &quot;real&quot; fields, and the rest are &quot;LazyField&quot; instances, every subsequent request for that document that involves those LazyFields is slow, even if they ask for the same LazyField over and over.&lt;/p&gt;</comment>
                            <comment id="13604124" author="hossman" created="Sat, 16 Mar 2013 05:25:44 +0000"  >&lt;p&gt;Digression...&lt;/p&gt;

&lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;It really feals like the whole LazyDocument API and usage pattern &amp;#8211; particularly the semantics in which &quot;LazyDocument.getField(FieldInfo)&quot; can be used &amp;#8211; is really brittle and confusiong.&lt;/p&gt;

&lt;p&gt;It assumes it will be called exactly once for each StorableField that exists for that field name, in order because the internal counter is assumed to correspond exactly wit the array index of the corresponding array of values. (In short: it&apos;s really only useful when called from StoredFieldVisitor)&lt;/p&gt;

&lt;p&gt;If, for example, a client app tries to use the same LazyDocument instance to generate LazyField instances for the same field twice &amp;#8211; it will most likeley get an ArrayIndexOutOfBoundsError.  Likewise a user could read the jacadocs for LazyDocument.getField and assume that it works simlar to StorableDocument.getField expecting it to return a LazyField of the &lt;em&gt;first&lt;/em&gt; field value for the specified field.  They could wind up calling the method twice on the same field and getting lazy fields pointing at two differnet values (the first and second StorableField instances for that field name)&lt;/p&gt;

&lt;p&gt;none of which directly relates to this particular bug, but since this public class seems to have been added solely for solr, it may be worth considering deprecating it, and moving the logic solr needs into protected/private classes.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...as for the matter at hand...&lt;/p&gt;

&lt;p&gt;I reworked the internals of hte class a bit so that:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;LazyField instances cache their underlying values similar to how lazy loading worked in 3.x&lt;/li&gt;
	&lt;li&gt;Asking for the value of a LazyField instance causes all LazyField&apos;s (produced by the same LazyDocument) with the same field name to be &quot;actualized&quot; in a single pass over the underlying document&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The changes eliminate the pathalogical case of iterating over many LazyFields, and shouldn&apos;t add much even in the edge case of only carrying about a single field value when there are many &amp;#8211; it&apos;s still a single loop in the underlying Document of the fields, there&apos;s just no more short circut for hte single value case.&lt;/p&gt;

&lt;p&gt;In order for these changes to work, the LazDocument has to now keep a reference to every LazyField it generates so that they can all be repopulated when one of their filed name brothers is repopulated.  The memory footprint of this shouldn&apos;t be too bad in the common case (afterall: the LazyDocument was already fetching the entire underlying Document keeping the whole thing around as long as there was a single LazyField in the heap) but just to be safe i made it track the list of LazyFields using weak refrences &amp;#8211; so even if someone asks for a bunch of LazyField instance for a field named &quot;foo&quot;, and then throws away all but a few of them, they can be garbage collected regardless of how many other &quot;foo&quot; LazyFields are still arround or when/if their real values are loaded.&lt;/p&gt;

&lt;p&gt;Patch includes a few test updates in solr to sanity check that lazy loading value caching works, but i definitely want to add some true LazyDocument unit tests to the module (there don&apos;t seem to be any at all at the moment) to exercise the &quot;all lazy fields with the same name get populated at the same time&quot; and &quot;what if a weakref LazyField goes away&quot; logic before i&apos;d consider committing.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Feedback would be greatly appreciated.&lt;/p&gt;</comment>
                            <comment id="13605968" author="hossman" created="Tue, 19 Mar 2013 02:34:05 +0000"  >&lt;p&gt;updated patch&lt;/p&gt;

&lt;p&gt;in addition to adding more tests, i added logic so that when the underlying document is fetched to populate the lazy fields, only the specific fields needed will be loaded (so if a doc contains fields w, x, y, and z, and the client code fetches field w and requests that fields y and z be lazy loaded, then field x will never be read. and field w will not be fetched redundantly.&lt;/p&gt;

&lt;p&gt;would really appreciate feedback, i&apos;d like to get this into th 4.2.1 bug fix release&lt;/p&gt;</comment>
                            <comment id="13606388" author="yseeley@gmail.com" created="Tue, 19 Mar 2013 15:08:59 +0000"  >&lt;p&gt;Still trying to wrap my head around how all this works... particularly with synchronization and why the old implementation, or the patch, are thread safe.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure we should be using weak references though.  They could cause problems at the rate they could be generated.&lt;/p&gt;</comment>
                            <comment id="13606458" author="hossman" created="Tue, 19 Mar 2013 16:19:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=yonik%40apache.org&quot; class=&quot;user-hover&quot; rel=&quot;yonik@apache.org&quot;&gt;yonik@apache.org&lt;/a&gt;: I can remove the weak references easy enough, but cna you elaborate on what concerns you have about the thread safety?&lt;/p&gt;

&lt;p&gt;can you give me an example of a sequence of (parallel) events that you think would be problematic so i can try to address it?&lt;/p&gt;</comment>
                            <comment id="13606838" author="hossman" created="Tue, 19 Mar 2013 21:21:06 +0000"  >&lt;p&gt;updated patch removing the weak refs and fixing a few doc typoes&lt;/p&gt;</comment>
                            <comment id="13606910" author="yseeley@gmail.com" created="Tue, 19 Mar 2013 22:11:52 +0000"  >&lt;p&gt;I was initially worried about LazyDocument.getField, but I now realize that LazyDocument is not a &quot;Document&quot; (i.e. it is not what you will ever retrieve from the document cache).  It&apos;s more of a LazyFieldSource&lt;/p&gt;

&lt;p&gt;I think there may still be an issue with LazyField.realValue though, in that it may return a partially constructed object (unless realValue is guaranteed to be effectively immutable).  The easiest fix would be to make realValue volatile (and readers will thus cross a read memory barrier).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;      &lt;span class=&quot;code-comment&quot;&gt;// edge &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;: &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; someone asks &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; LazyDoc &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; more LazyFields
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// after other LazyFields from the same LazyDoc have been
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// actuallized, we need to force the doc to be re-fetched
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// so the &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LazyFields are also populated.
&lt;/span&gt;      doc = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does this happen with Solr?&lt;/p&gt;
</comment>
                            <comment id="13606933" author="hossman" created="Tue, 19 Mar 2013 22:22:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;The easiest fix would be to make realValue volatile (and readers will thus cross a read memory barrier).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t fully understand what situation you are concerned about here, but making it volatile is easy .. running tests now.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Does this happen with Solr?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;no, but the way the public API for LazyDocument is defined, it is possible (even though it wouldn&apos;t really make any sense given the way the API is really only usable from a StoredFieldVisitor) so i wanted to protect against it  &amp;#8211; i included test randomization to verify that the edge case works.&lt;/p&gt;</comment>
                            <comment id="13607107" author="hossman" created="Wed, 20 Mar 2013 00:39:28 +0000"  >
&lt;p&gt;I switched to using volatile per yonik&apos;s suggestion, but in the process of testing i encountered a test failure that has me convinced that either i&apos;m going insane, or there is some weird state info that gets corrupted if you attempt to use an IndexReader to fetch the stored field values of a doc while a StoredFieldVisitor is already being used to fetch those fields &amp;#8211; and if i can encounter this kind of problem in a single threaded test, it scares me about any multi-threaded usages in any solr/lucene instance.&lt;/p&gt;

&lt;p&gt;The attached patch updates the test with a bunch of nocommit System.out&apos;s as well as a new &quot;sanity&quot; test where i tried to recreate the underlying problem w/o using LazyDocument at all...&lt;/p&gt;

&lt;p&gt;This is the first failure i encountered...&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ant test  -Dtestcase=TestLazyDocument -Dtests.method=testLazy -Dtests.seed=553F22658CE2D9A9 -Dtests.slow=true -Dtests.locale=sk -Dtests.timezone=Africa/Ndjamena -Dtests.file.encoding=UTF-8

...

[junit4:junit4]    &amp;gt; Throwable #1: java.lang.AssertionError: fieldName count: b expected:&amp;lt;112&amp;gt; but was:&amp;lt;1229&amp;gt;
[junit4:junit4]    &amp;gt; 	at __randomizedtesting.SeedInfo.seed([553F22658CE2D9A9:64E62F373CBE0D02]:0)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.fail(Assert.java:93)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.failNotEquals(Assert.java:647)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.assertEquals(Assert.java:128)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.assertEquals(Assert.java:472)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.document.TestLazyDocument.testLazy(TestLazyDocument.java:170)
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;you can see from the sysout calls prior to the failure that the &quot;needsField&quot; method of the LazyTestingStoredFieldVisitor seems to be getting called the correct number of times, but with the wrong field name &amp;#8211; once it randomly calls &lt;tt&gt;assertNotNull(lazyDoc.getDocument());&lt;/tt&gt; (which calls reader.doc(int)) every successive call to needsField winds up refering to the next field name (&quot;b&quot;) instead of all the other field names in the document.&lt;/p&gt;

&lt;p&gt;if you comment out the &lt;tt&gt;assertNotNull(lazyDoc.getDocument());&lt;/tt&gt; call, the test passes.&lt;/p&gt;

&lt;p&gt;This lead me to write testHossssSanity which doesn&apos;t use any of hte lazy loading code at all, it just uses a simple StoredFieldsVisitor whose needsField method always returns NO but also arbitrarily calls &lt;tt&gt;reader.document(doc)&lt;/tt&gt; for no reason once we start getting to the first lettered field name...&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ant test  -Dtestcase=TestLazyDocument -Dtests.method=testHossssSanity -Dtests.seed=553F22658CE2D9A9 -Dtests.slow=true -Dtests.locale=sk -Dtests.timezone=Africa/Ndjamena -Dtests.file.encoding=UTF-8

...

[junit4:junit4]    &amp;gt; Throwable #1: java.lang.AssertionError: fieldName count: b expected:&amp;lt;139&amp;gt; but was:&amp;lt;1528&amp;gt;
[junit4:junit4]    &amp;gt; 	at __randomizedtesting.SeedInfo.seed([553F22658CE2D9A9:FE3621EFA9383F64]:0)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.fail(Assert.java:93)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.failNotEquals(Assert.java:647)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.assertEquals(Assert.java:128)
[junit4:junit4]    &amp;gt; 	at org.junit.Assert.assertEquals(Assert.java:472)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.document.TestLazyDocument.testHossssSanity(TestLazyDocument.java:120)
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...you can again see from the sysout calls that needsField is called the expected number of times, but always with field named &quot;b&quot; (the first field name to exist &lt;em&gt;after&lt;/em&gt; the first field name that calls reader.document.&lt;/p&gt;

&lt;p&gt;What finally convinced me that i wasn&apos;t insane was when i found a diffenret seed that produced a different low error at a lower level...&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ant test  -Dtestcase=TestLazyDocument -Dtests.method=testHossssSanity -Dtests.seed=4C348A26E496AC38 -Dtests.slow=true -Dtests.locale=fr_CH -Dtests.timezone=Antarctica/Vostok -Dtests.file.encoding=UTF-8

...

[junit4:junit4]    &amp;gt; Throwable #1: java.lang.AssertionError: bits=5f
[junit4:junit4]    &amp;gt; 	at __randomizedtesting.SeedInfo.seed([4C348A26E496AC38:E73D89ACC14C4AF5]:0)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsReader.visitDocument(Lucene40StoredFieldsReader.java:155)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.index.SegmentReader.document(SegmentReader.java:139)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.index.BaseCompositeReader.document(BaseCompositeReader.java:116)
[junit4:junit4]    &amp;gt; 	at org.apache.lucene.document.TestLazyDocument.testHossssSanity(TestLazyDocument.java:118)
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...which suggests to me that maybe there really is a bug in the underlying StoredFieldsVisitor logic (or perhaps just in the Lucene40StoredFieldsReader) ?&lt;/p&gt;</comment>
                            <comment id="13607125" author="hossman" created="Wed, 20 Mar 2013 00:52:44 +0000"  >&lt;p&gt;Ok ... dug into SegmentReader a bit and confirmed that under the covers SegmentCoreReaders is using ThreadLocal to track a stored StoredFieldsReader instance ... so there doesn&apos;t seem to be a a true thread safety problem here (whew), you just have to be careful as a StoredFieldVistor writer not to try and do any other stored field visiting inside your visitor callbacks or you&apos;ll corrupt internal state.&lt;/p&gt;

&lt;p&gt;so i need to change my testLazy to be less evil and not do that.&lt;/p&gt;</comment>
                            <comment id="13607152" author="hossman" created="Wed, 20 Mar 2013 01:13:29 +0000"  >&lt;p&gt;Ok ... made the test less evil so it doesn&apos;t trip over the StoredFieldsReader threadlocal, but modified it so it still excercises the possibility that a client might use the LazyDoc to ask for additional LazyField instances after already actualizing other instances&lt;/p&gt;

&lt;p&gt;I&apos;m still hammering on the tests, but i&apos;d appreciate review.&lt;/p&gt;</comment>
                            <comment id="13607170" author="hossman" created="Wed, 20 Mar 2013 01:46:57 +0000"  >&lt;p&gt;Sigh .. this time with nocommits removed for real.&lt;/p&gt;</comment>
                            <comment id="13607469" author="mikemccand" created="Wed, 20 Mar 2013 10:15:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;Ok ... dug into SegmentReader a bit and confirmed that under the covers SegmentCoreReaders is using ThreadLocal to track a stored StoredFieldsReader instance &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh that&apos;s right ... so, the IR.document(int, visitor) is non-reentrant: your visitor cannot go and call IR.document again ... I think we should at least update the javadocs for StoredFieldVisitor to explain this?  I&apos;ll do that...&lt;/p&gt;</comment>
                            <comment id="13607726" author="hossman" created="Wed, 20 Mar 2013 15:34:32 +0000"  >&lt;p&gt;Fixed on trunk, working on backport now...&lt;/p&gt;

&lt;p&gt;Committed revision 1458887.&lt;/p&gt;</comment>
                            <comment id="13607839" author="commit-tag-bot" created="Wed, 20 Mar 2013 16:45:02 +0000"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;trunk commit&amp;#93;&lt;/span&gt; Chris M. Hostetter&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1458887&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1458887&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4589&quot; title=&quot;4.x + enableLazyFieldLoading + large multivalued fields + varying fl = pathological CPU load &amp;amp; response time&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4589&quot;&gt;&lt;del&gt;SOLR-4589&lt;/del&gt;&lt;/a&gt;: Fixed CPU spikes and poor performance in lazy field loading of multivalued fields&lt;/p&gt;</comment>
                            <comment id="13607871" author="hossman" created="Wed, 20 Mar 2013 17:15:14 +0000"  >&lt;p&gt;Committed revision 1458938.&lt;br/&gt;
Committed revision 1458959.&lt;br/&gt;
h&lt;/p&gt;</comment>
                            <comment id="13607878" author="commit-tag-bot" created="Wed, 20 Mar 2013 17:22:31 +0000"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;branch_4x commit&amp;#93;&lt;/span&gt; Chris M. Hostetter&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1458938&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1458938&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4589&quot; title=&quot;4.x + enableLazyFieldLoading + large multivalued fields + varying fl = pathological CPU load &amp;amp; response time&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-4589&quot;&gt;&lt;del&gt;SOLR-4589&lt;/del&gt;&lt;/a&gt;: Fixed CPU spikes and poor performance in lazy field loading of multivalued fields (merge r1458887)&lt;/p&gt;</comment>
                            <comment id="13654216" author="thetaphi" created="Fri, 10 May 2013 10:34:25 +0000"  >&lt;p&gt;Closed after release.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12574476" name="SOLR-4589.patch" size="20801" author="hossman" created="Wed, 20 Mar 2013 01:46:57 +0000"/>
                            <attachment id="12574469" name="SOLR-4589.patch" size="21086" author="hossman" created="Wed, 20 Mar 2013 01:13:29 +0000"/>
                            <attachment id="12574462" name="SOLR-4589.patch" size="21443" author="hossman" created="Wed, 20 Mar 2013 00:39:28 +0000"/>
                            <attachment id="12574407" name="SOLR-4589.patch" size="18446" author="hossman" created="Tue, 19 Mar 2013 21:21:06 +0000"/>
                            <attachment id="12574301" name="SOLR-4589.patch" size="18581" author="hossman" created="Tue, 19 Mar 2013 02:34:05 +0000"/>
                            <attachment id="12573995" name="SOLR-4589.patch" size="9713" author="hossman" created="Sat, 16 Mar 2013 05:25:44 +0000"/>
                            <attachment id="12573918" name="test-just-queries.out__4.0.0_mmap_lazy_using36index.txt" size="245" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573919" name="test-just-queries.sh" size="1065" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573905" name="test.out__3.6.1_mmap_lazy.txt" size="648" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573906" name="test.out__3.6.1_mmap_nolazy.txt" size="371" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573907" name="test.out__3.6.1_nio_lazy.txt" size="648" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573908" name="test.out__3.6.1_nio_nolazy.txt" size="648" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573909" name="test.out__4.0.0_mmap_lazy.txt" size="373" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573910" name="test.out__4.0.0_mmap_nolazy.txt" size="371" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573911" name="test.out__4.0.0_nio_lazy.txt" size="373" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573912" name="test.out__4.0.0_nio_nolazy.txt" size="371" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573913" name="test.out__4.2.0_mmap_lazy.txt" size="374" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573914" name="test.out__4.2.0_mmap_nolazy.txt" size="372" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573915" name="test.out__4.2.0_nio_lazy.txt" size="374" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573916" name="test.out__4.2.0_nio_nolazy.txt" size="372" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                            <attachment id="12573917" name="test.sh" size="1693" author="hossman" created="Fri, 15 Mar 2013 18:27:53 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>317733</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 28 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1itpj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>318074</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>