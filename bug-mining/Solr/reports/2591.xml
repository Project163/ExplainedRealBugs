<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 04:06:53 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-7869] Overseer does not handle BadVersionException correctly</title>
                <link>https://issues.apache.org/jira/browse/SOLR-7869</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;If the /clusterstate.json is modified externally then the Overseer can go into an infinite loop upon a BadVersionException alternately trying to execute main queue and then the work queue:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;ERROR - 2015-08-04 18:49:56.224; [   ] org.apache.solr.cloud.Overseer$ClusterStateUpdater; Exception in Overseer work queue loop
org.apache.zookeeper.KeeperException$BadVersionException: KeeperErrorCode = BadVersion &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; /clusterstate.json
        at org.apache.zookeeper.KeeperException.create(KeeperException.java:115)
        at org.apache.zookeeper.KeeperException.create(KeeperException.java:51)
        at org.apache.zookeeper.ZooKeeper.setData(ZooKeeper.java:1270)
        at org.apache.solr.common.cloud.SolrZkClient$8.execute(SolrZkClient.java:362)
        at org.apache.solr.common.cloud.SolrZkClient$8.execute(SolrZkClient.java:359)
        at org.apache.solr.common.cloud.ZkCmdExecutor.retryOperation(ZkCmdExecutor.java:61)
        at org.apache.solr.common.cloud.SolrZkClient.setData(SolrZkClient.java:359)
        at org.apache.solr.cloud.overseer.ZkStateWriter.writePendingUpdates(ZkStateWriter.java:180)
        at org.apache.solr.cloud.overseer.ZkStateWriter.enqueueUpdate(ZkStateWriter.java:67)
        at org.apache.solr.cloud.Overseer$ClusterStateUpdater.processQueueItem(Overseer.java:286)
        at org.apache.solr.cloud.Overseer$ClusterStateUpdater.run(Overseer.java:168)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:745)
INFO  - 2015-08-04 18:49:56.224; [   ] org.apache.solr.cloud.Overseer$ClusterStateUpdater; processMessage: queueSize: 1, message = {
  &lt;span class=&quot;code-quote&quot;&gt;&quot;operation&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;state&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;state&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;down&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;base_url&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//127.0.1.1:7574/solr&quot;&lt;/span&gt;,
&lt;/span&gt;  &lt;span class=&quot;code-quote&quot;&gt;&quot;core&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_shard1_replica1&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;roles&quot;&lt;/span&gt;:&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;node_name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;127.0.1.1:7574_solr&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;shard&quot;&lt;/span&gt;:&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;collection&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;core_node_name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;core_node1&quot;&lt;/span&gt;} current state version: 9
INFO  - 2015-08-04 18:49:56.224; [   ] org.apache.solr.cloud.overseer.ReplicaMutator; Update state numShards=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; message={
  &lt;span class=&quot;code-quote&quot;&gt;&quot;operation&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;state&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;state&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;down&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;base_url&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//127.0.1.1:7574/solr&quot;&lt;/span&gt;,
&lt;/span&gt;  &lt;span class=&quot;code-quote&quot;&gt;&quot;core&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_shard1_replica1&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;roles&quot;&lt;/span&gt;:&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;node_name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;127.0.1.1:7574_solr&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;shard&quot;&lt;/span&gt;:&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;collection&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;,
  &lt;span class=&quot;code-quote&quot;&gt;&quot;core_node_name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;core_node1&quot;&lt;/span&gt;}
INFO  - 2015-08-04 18:49:56.224; [   ] org.apache.solr.cloud.overseer.ReplicaMutator; shard=shard1 is already registered
ERROR - 2015-08-04 18:49:56.225; [   ] org.apache.solr.cloud.Overseer$ClusterStateUpdater; Exception in Overseer main queue loop
org.apache.zookeeper.KeeperException$BadVersionException: KeeperErrorCode = BadVersion &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; /clusterstate.json
        at org.apache.zookeeper.KeeperException.create(KeeperException.java:115)
        at org.apache.zookeeper.KeeperException.create(KeeperException.java:51)
        at org.apache.zookeeper.ZooKeeper.setData(ZooKeeper.java:1270)
        at org.apache.solr.common.cloud.SolrZkClient$8.execute(SolrZkClient.java:362)
        at org.apache.solr.common.cloud.SolrZkClient$8.execute(SolrZkClient.java:359)
        at org.apache.solr.common.cloud.ZkCmdExecutor.retryOperation(ZkCmdExecutor.java:61)
        at org.apache.solr.common.cloud.SolrZkClient.setData(SolrZkClient.java:359)
        at org.apache.solr.cloud.overseer.ZkStateWriter.writePendingUpdates(ZkStateWriter.java:180)
        at org.apache.solr.cloud.overseer.ZkStateWriter.enqueueUpdate(ZkStateWriter.java:67)
        at org.apache.solr.cloud.Overseer$ClusterStateUpdater.processQueueItem(Overseer.java:286)
        at org.apache.solr.cloud.Overseer$ClusterStateUpdater.run(Overseer.java:213)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:745)
INFO  - 2015-08-04 18:49:56.225; [   ] org.apache.solr.common.cloud.ZkStateReader; Updating data &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; gettingstarted to ver 8
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="12851472">SOLR-7869</key>
            <summary>Overseer does not handle BadVersionException correctly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="shalin">Shalin Shekhar Mangar</assignee>
                                    <reporter username="shalin">Shalin Shekhar Mangar</reporter>
                        <labels>
                            <label>difficulty-medium</label>
                            <label>impact-low</label>
                    </labels>
                <created>Tue, 4 Aug 2015 18:52:01 +0000</created>
                <updated>Mon, 9 May 2016 18:53:26 +0000</updated>
                            <resolved>Thu, 13 Aug 2015 19:37:38 +0000</resolved>
                                    <version>5.2.1</version>
                                    <fixVersion>5.4</fixVersion>
                    <fixVersion>6.0</fixVersion>
                                    <component>SolrCloud</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="14654472" author="dragonsinth" created="Tue, 4 Aug 2015 22:29:06 +0000"  >&lt;p&gt;But what&apos;s the right fix?  Having looked through the code a bit now, OverSeer.ClusterUpdater has a &lt;b&gt;very&lt;/b&gt; baked-in assumption that no one else is updating cluster state.  Copies of ClusterState float around and get updated over and over during processing, with the assumption that the local node is performing an atomic sequence of operations to get to a desired end state.  How can external changes be merged in?  My impulse was to catch BadVersionException, refresh ClusterState from ZK, then re-apply all the queued updates against the refreshed state.  However, I&apos;m afraid that approach violates all of ClusterUpdater&apos;s assumptions.  I think the only thing to do is just clobber whatever is in ZK with what Overseer wants to write, even though that seems less than ideal.&lt;/p&gt;</comment>
                            <comment id="14654476" author="dragonsinth" created="Tue, 4 Aug 2015 22:31:00 +0000"  >&lt;p&gt;Attached a TEST ONLY that repros the failure.  This is not a fix.&lt;/p&gt;</comment>
                            <comment id="14655057" author="shalinmangar" created="Wed, 5 Aug 2015 09:20:03 +0000"  >&lt;p&gt;Thanks Scott!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;My impulse was to catch BadVersionException, refresh ClusterState from ZK, then re-apply all the queued updates against the refreshed state.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is the right fix. That is how I intended it to work but I obviously didn&apos;t write enough tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;However, I&apos;m afraid that approach violates all of ClusterUpdater&apos;s assumptions. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Originally the overseer would force update the cluster state at the beginning of the loop, apply the updates and write to ZK. This was wasteful because most of the time, the Overseer is the only guy writing to ZK state. This is why I introduced a local cluster state which is written to ZK using CAS removing the need for refreshing the cluster state. If that CAS fails then that means that someone has changed state externally or due to a bug multiple overseers have started processing. At this point, we go back to the beginning of the loop, check if we are still leader, force refresh the cluster state, process work queue and the continue on to the main queue.&lt;/p&gt;</comment>
                            <comment id="14655191" author="shalinmangar" created="Wed, 5 Aug 2015 11:05:54 +0000"  >&lt;p&gt;We can fix ZkStateWriter easily with the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (clusterState != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !prevState.getZkClusterStateVersion().equals(clusterState.getZkClusterStateVersion()))  {
      &lt;span class=&quot;code-comment&quot;&gt;// our local cluster state is out of sync with what is in ZK, re-initialize
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is safe because either 1) any pending updates are in #updates and will be applied again, or
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// 2) they have already been written to ZK
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// i.e. it is guaranteed that overwriting cluster state with prevState will not discard any updates
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// that Overseer had performed unless such an act was done externally by the user
&lt;/span&gt;      clusterState = prevState;
      isClusterStateModified = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, the test isn&apos;t quite right. We can&apos;t handle BadVersionException inside ZkStateWriter itself. It has to be propagated to Overseer which should do the logic I outlined in the previous comment. So any test should test at the Overseer level and not just the ZkStateWriter.&lt;/p&gt;</comment>
                            <comment id="14662813" author="shalinmangar" created="Sat, 8 Aug 2015 05:21:08 +0000"  >&lt;p&gt;Test + fix. I tried to reproduce this in the OverseerTest but it was proving to be too difficult. The randomized test I had would maybe reproduce once in 5 times so I went back to the test Scott had written and augmented it.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;I wonder if it is better to assert that given cluster state version is greater than ZkStateWriter&apos;s internal cluster state instead of blindly using given cluster state when version is not equal.&lt;/li&gt;
	&lt;li&gt;I also wonder if a better fix is to re-create ZkStateWriter object entirely if refreshClusterState is true in the Overseer? The reason is what if a user modifies a collection&apos;s state.json directly but doesn&apos;t modify the /clusterstate.json. In that case, our current fix won&apos;t work.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="14679319" author="dragonsinth" created="Sun, 9 Aug 2015 20:16:16 +0000"  >&lt;p&gt;1) So this doesn&apos;t actually fix anything yet, because there are no changes to Overseer itself?  Presumably you&apos;d need to catch BVE in overseer and force-refresh reader clusterState?&lt;/p&gt;

&lt;p&gt;2) Just noting that this seems the opposite of what we discussed earlier.  I interpreted your earlier comments to mean that we should blow away the ZK data in favor of the overseer data, since overseer is authoritative.  This patch seems do the opposite, preferring external user changes.  To wit &quot;it is guaranteed that overwriting cluster state with prevState will not discard any updates that Overseer had performed unless such an act was done externally by the user&quot;.&lt;/p&gt;

&lt;p&gt;3) In ZkStateWriterTest, I note that ZkStateWriter isn&apos;t super amenable to testing, it&apos;s kind of subtle that enqueuing an update sometimes causes a flush, and sometimes does.  Dunno if it&apos;s better or worse to have test-visible methods for doing a queue-without-flush and then explicit flush.&lt;/p&gt;

&lt;p&gt;4) In ZkStateWriterTest.testExternalModificationToSharedClusterState(), first try block, you&apos;re missing a fail() after the enqueueUpdate to test that the exception really did occur.  In the first catch block, I&apos;m not sure it&apos;s good to log the expected exception, I always find it confusing when tests log exceptions that don&apos;t actually cause the test to fail.  I would remove the second catch block; if you get any other exception than the one you expect, best to just let it escape and let the test framework get it.&lt;/p&gt;

&lt;p&gt;5) In a similar fashion, I would remove the second try/catch block entirely, just keeping the body of the try.  You expect that none of it will throw an exception, so just leave it unadorned and the test framework will handle if there is.&lt;/p&gt;</comment>
                            <comment id="14679667" author="shalinmangar" created="Mon, 10 Aug 2015 06:52:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;1) So this doesn&apos;t actually fix anything yet, because there are no changes to Overseer itself? Presumably you&apos;d need to catch BVE in overseer and force-refresh reader clusterState?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually Overseer already has code that catches all exceptions and refreshes the cluster state. The bug is in ZkStateWriter which does not use the refreshed cluster state if maybeRefreshBefore returns true and hence tries to compare-and-set using the outdated cluster state version.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2) Just noting that this seems the opposite of what we discussed earlier. I interpreted your earlier comments to mean that we should blow away the ZK data in favor of the overseer data, since overseer is authoritative. This patch seems do the opposite, preferring external user changes. To wit &quot;it is guaranteed that overwriting cluster state with prevState will not discard any updates that Overseer had performed unless such an act was done externally by the user&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe I wasn&apos;t clear enough. But I did mean the opposite of what you understood. The user has made some changes either accidentally in which case they totally deserve what&apos;s coming &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; or presumably to fix something that went wrong in the cluster state (which could be because of a genuine bug). In both cases, overwriting stuff that a user has himself done seems wrong to me. We should just roll with it. Therefore the overseer refreshes the cluster state and starts using it as the base for future operations.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3) In ZkStateWriterTest, I note that ZkStateWriter isn&apos;t super amenable to testing, it&apos;s kind of subtle that enqueuing an update sometimes causes a flush, and sometimes does. Dunno if it&apos;s better or worse to have test-visible methods for doing a queue-without-flush and then explicit flush.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You are right. The testZkStateWriterBatching is a horrible test and I should have written a better one. In particular, maybeFlushAfter also updates the local state (lastStateFormat, lastCollectionName) before the write happens. We should change that. But I am not sure what you mean by &quot;Dunno if it&apos;s better or worse to have test-visible methods for doing a queue-without-flush and then explicit flush.&quot;?&lt;/p&gt;

&lt;p&gt;Re: #4 and #5 &amp;#8211; good point. I&apos;ll fix that.&lt;/p&gt;</comment>
                            <comment id="14680558" author="dragonsinth" created="Mon, 10 Aug 2015 18:57:40 +0000"  >&lt;p&gt;1) bq &quot;Actually Overseer already has code that catches all exceptions and refreshes the cluster state.&lt;/p&gt;

&lt;p&gt;In that case, I would suggest an explicit catch block there for BadVersionException, and log something milder than error?  The current KeeperException catch block always logs an error.&lt;/p&gt;

&lt;p&gt;2) Okay, I totally buy that argument!  But see note below.&lt;/p&gt;

&lt;p&gt;3) I&apos;m merely saying that the refactoring that would be necessary to make ZkStateWriter more easily testable might negatively impact the flow of the existing code.  I&apos;m not sure, you&apos;d have to try it.&lt;/p&gt;


&lt;p&gt;Having stewed on this a bit, I think there&apos;s somewhat of a fundamental disconnect in how ZkStateWriter&apos;s batching interacts with the Overseer work queue.&lt;/p&gt;

&lt;p&gt;Work items get removed from the queue before the corresponding change is actually written out to the cluster state.  You can see in the original design that there&apos;s this neat peek-&amp;gt;poll dance in the Overseer loop that attempts to enforce guaranteed state updates by not discarding the work item until after the state is written out.  But the batching implementation gets rid of this guarantee, and that&apos;s why I perceive we&apos;re now in a state where the overseer updates and external updates can even be in conflict with each other.&lt;/p&gt;

&lt;p&gt;Imagine (as a thought experiment) we got rid of batching.  If we did that, no external change could &quot;lose&quot; a work item, because we&apos;d be committing one item at a time, so the retry operation on a bad version exception would always re-grab the most recent, unapplied work item.  Now obviously, we don&apos;t want to get rid of batching, because efficiency.  But I really do think we&apos;re batching in the wrong place.  I think batching actually needs to happen in Overseer, because it has to be tied to discarding work items.  Ideally, we&apos;d peek N work items from the head of the queue, setup all the pending updates / cluster state mods in ZkStateWriter, then try to commit everything.  If it succeeds, great, remove all the processed items from the queue.  If it fails, then reread cluster state and retry all the items again.&lt;/p&gt;

&lt;p&gt;Make any sense?&lt;/p&gt;

&lt;p&gt;(Now, all that said, that work may be more effort than it&apos;s worth, and maybe we should just focus on not having to use the queue to make cluster state updates in the format v2 world.)&lt;/p&gt;</comment>
                            <comment id="14680727" author="shalinmangar" created="Mon, 10 Aug 2015 20:38:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;In that case, I would suggest an explicit catch block there for BadVersionException, and log something milder than error? The current KeeperException catch block always logs an error.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Work items get removed from the queue before the corresponding change is actually written out to the cluster state. You can see in the original design that there&apos;s this neat peek-&amp;gt;poll dance in the Overseer loop that attempts to enforce guaranteed state updates by not discarding the work item until after the state is written out. But the batching implementation gets rid of this guarantee, and that&apos;s why I perceive we&apos;re now in a state where the overseer updates and external updates can even be in conflict with each other.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, items are never removed until they&apos;re flushed to ZK. This invariant is maintained everywhere. If you find that I have missed a case then please do let me know. When operating on the work queue, batching is completely disabled because we have no fallback in case we fail. When operating on the main queue &amp;#8211; we add operation to work queue when onEnqueue event is called and we remove item from work queue once onWrite event is called. This ensures that we never lose an operation.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I really do think we&apos;re batching in the wrong place. I think batching actually needs to happen in Overseer, because it has to be tied to discarding work items.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That used to be the case. I refactored Overseer extensively in 5.0 in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6554&quot; title=&quot;Speed up overseer operations for collections with stateFormat &amp;gt; 1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6554&quot;&gt;&lt;del&gt;SOLR-6554&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(Now, all that said, that work may be more effort than it&apos;s worth, and maybe we should just focus on not having to use the queue to make cluster state updates in the format v2 world.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I think a more worthwhile improvement would be &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-6760&quot; title=&quot;New optimized DistributedQueue implementation for overseer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-6760&quot;&gt;&lt;del&gt;SOLR-6760&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;
</comment>
                            <comment id="14695059" author="shalinmangar" created="Thu, 13 Aug 2015 11:01:21 +0000"  >&lt;p&gt;Here&apos;s a better fix which discards ZkStateWriter on a BadVersionException and starts afresh. The previous approach didn&apos;t work when an external change was made on state.json with no changes to /clusterstate.json. Although such changes can be detected and resolved inside ZkStateWriter but that would make this class unnecessarily complex.&lt;/p&gt;

&lt;p&gt;ZkStateWriter will put itself into an invalid state upon a BadVersionException and will disallow all future operations. Callers are expected to discard such an instance and create a fresh ZkStateWriter instance for future use.&lt;/p&gt;

&lt;p&gt;I added two tests in ZkStateWriterTest which simulate an external change to /clusterstate.json and a state.json and asserts that an IllegalStateException is thrown on any future invocation of enqueueUpdate or writePendingUpdates.&lt;/p&gt;

&lt;p&gt;I also added a test in Overseer which asserts that the overseer can keep processing events on a BadVersionException (indirectly testing that a fresh ZkStateWriter is created upon said exception).&lt;/p&gt;

&lt;p&gt;I also added copious amounts of javadocs to the ZkStateWriter class for future reference.&lt;/p&gt;</comment>
                            <comment id="14695501" author="dragonsinth" created="Thu, 13 Aug 2015 16:27:19 +0000"  >&lt;p&gt;Great change!  Couple of minor nits:&lt;/p&gt;

&lt;p&gt;1) There&apos;s a log(SHALIN) to remove in OverseerTest&lt;/p&gt;

&lt;p&gt;2) testExternalModificationToSharedClusterState() has 2 try/catch(expected) with no fail() statement at the end of the try block. testExternalModificationToStateFormat2() has 3 instances of this problem.&lt;/p&gt;</comment>
                            <comment id="14695621" author="shalinmangar" created="Thu, 13 Aug 2015 17:32:58 +0000"  >&lt;p&gt;Thanks for the review Scott!&lt;/p&gt;

&lt;p&gt;Both of your comments are now incorporated into this patch. I&apos;ll run precommit and tests and commit once they succeed.&lt;/p&gt;</comment>
                            <comment id="14695738" author="jira-bot" created="Thu, 13 Aug 2015 18:31:11 +0000"  >&lt;p&gt;Commit 1695746 from shalin@apache.org in branch &apos;dev/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1695746&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1695746&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-7869&quot; title=&quot;Overseer does not handle BadVersionException correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-7869&quot;&gt;&lt;del&gt;SOLR-7869&lt;/del&gt;&lt;/a&gt;: Overseer does not handle BadVersionException correctly and, in some cases, can go into an infinite loop if cluster state in ZooKeeper is modified externally&lt;/p&gt;</comment>
                            <comment id="14695815" author="jira-bot" created="Thu, 13 Aug 2015 19:36:55 +0000"  >&lt;p&gt;Commit 1695763 from shalin@apache.org in branch &apos;dev/branches/branch_5x&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1695763&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/r1695763&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-7869&quot; title=&quot;Overseer does not handle BadVersionException correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-7869&quot;&gt;&lt;del&gt;SOLR-7869&lt;/del&gt;&lt;/a&gt;: Overseer does not handle BadVersionException correctly and, in some cases, can go into an infinite loop if cluster state in ZooKeeper is modified externally&lt;/p&gt;</comment>
                            <comment id="14695816" author="shalinmangar" created="Thu, 13 Aug 2015 19:37:38 +0000"  >&lt;p&gt;Thanks Scott!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12750342" name="SOLR-7869.patch" size="23896" author="shalin" created="Thu, 13 Aug 2015 17:32:58 +0000"/>
                            <attachment id="12750269" name="SOLR-7869.patch" size="23577" author="shalin" created="Thu, 13 Aug 2015 11:01:21 +0000"/>
                            <attachment id="12749403" name="SOLR-7869.patch" size="7953" author="shalin" created="Sat, 8 Aug 2015 05:21:08 +0000"/>
                            <attachment id="12748743" name="SOLR-7869.patch" size="2633" author="dragonsinth" created="Tue, 4 Aug 2015 22:31:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 14 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ibu7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>