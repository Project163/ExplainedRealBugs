<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 04:39:45 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SOLR-13616] Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)</title>
                <link>https://issues.apache.org/jira/browse/SOLR-13616</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>
&lt;p&gt;Based on some recent jenkins failures in TestPolicyCloud, I suspect there is a possible deadlock condition when attempting to delete a collection while recovery is in progress.&lt;/p&gt;

&lt;p&gt;I haven&apos;t been able to identify exactly where/why/how the problem occurs, but it does not appear to be a test specific problem, and seems like it could potentially affect anyone unlucky enough to issue poorly timed DELETE.&lt;/p&gt;

&lt;p&gt;Details to follow in comments...&lt;/p&gt;</description>
                <environment></environment>
        <key id="13243973">SOLR-13616</key>
            <summary>Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="hossman">Chris M. Hostetter</reporter>
                        <labels>
                    </labels>
                <created>Tue, 9 Jul 2019 22:10:57 +0000</created>
                <updated>Sat, 27 Jul 2019 02:21:29 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16881590" author="hossman" created="Tue, 9 Jul 2019 22:14:23 +0000"  >&lt;p&gt;Unlike most tests that explicitly waitFor/assert &lt;b&gt;active&lt;/b&gt; replicas, TestPolicyCloud (currently) has several tests that only assert the quanity and location of a replica &#8211; it doesn&apos;t wait for them to become active, so when testing an ADDREPLICA or a SPLITSHARD, those new replicas are still in recovery (or PrepRecovery) when the test tries to do cleanup and delete the collection &#8211; which frequently fails with timeout problems.&lt;/p&gt;

&lt;p&gt;While we can certainly &quot;improve&quot; TestPolicyCloud to wait for recoveries to finish, and all replicas to be active before attempting to delete the collection, a better question is why this is needed?&lt;/p&gt;

&lt;p&gt;I&apos;m attaching &lt;tt&gt;thetaphi_Lucene-Solr-master-Linux_24358.log.txt&lt;/tt&gt; which demonstrates the problem in &lt;tt&gt;TestPolicyCloud.testCreateCollectionAddReplica&lt;/tt&gt; here are some highlights...&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;# thetaphi_Lucene-Solr-master-Linux_24358.log.txt
#
# testCreateCollectionAddReplica

# bulk of test logic is finished, test has added a replica and confirmed it&apos;s on the expected node
# 
# but meanwhile, recovery is still ongoing...

  [junit4]   2&amp;gt; 959699 INFO  (recoveryExecutor-5888-thread-1-processing-n:127.0.0.1:42097_solr x:testCreateCollectionAddReplica_shard1_replica_n3 c:testCreateCollectionAddReplica s:shard1 r:core_node4) [n:127.0.0.1:42097_solr c:testCreateCollectionAddReplica s:shard1 r:core_node4 x:testCreateCollectionAddReplica_shard1_replica_n3 ] o.a.s.c.RecoveryStrategy Sending prep recovery command to [https://127.0.0.1:42097/solr]; [WaitForState: action=PREPRECOVERY&amp;amp;core=testCreateCollectionAddReplica_shard1_replica_n1&amp;amp;nodeName=127.0.0.1:42097_solr&amp;amp;coreNodeName=core_node4&amp;amp;state=recovering&amp;amp;checkLive=true&amp;amp;onlyIfLeader=true&amp;amp;onlyIfLeaderActive=true]
   [junit4]   2&amp;gt; 959701 INFO  (qtp531873617-17025) [n:127.0.0.1:42097_solr    x:testCreateCollectionAddReplica_shard1_replica_n1 ] o.a.s.h.a.PrepRecoveryOp Going to wait for coreNodeName: core_node4, state: recovering, checkLive: true, onlyIfLeader: true, onlyIfLeaderActive: true
   [junit4]   2&amp;gt; 959701 INFO  (qtp531873617-17025) [n:127.0.0.1:42097_solr    x:testCreateCollectionAddReplica_shard1_replica_n1 ] o.a.s.h.a.PrepRecoveryOp In WaitForState(recovering): collection=testCreateCollectionAddReplica, shard=shard1, thisCore=testCreateCollectionAddReplica_shard1_replica_n1, leaderDoesNotNeedRecovery=false, isLeader? true, live=true, checkLive=true, currentState=down, localState=active, nodeName=127.0.0.1:42097_solr, coreNodeName=core_node4, onlyIfActiveCheckResult=false, nodeProps: core_node4:{
   [junit4]   2&amp;gt;   &quot;core&quot;:&quot;testCreateCollectionAddReplica_shard1_replica_n3&quot;,
   [junit4]   2&amp;gt;   &quot;base_url&quot;:&quot;https://127.0.0.1:42097/solr&quot;,
   [junit4]   2&amp;gt;   &quot;state&quot;:&quot;down&quot;,
   [junit4]   2&amp;gt;   &quot;node_name&quot;:&quot;127.0.0.1:42097_solr&quot;,
   [junit4]   2&amp;gt;   &quot;type&quot;:&quot;NRT&quot;}
   ...

# the test thread moves on to @After method which calls MiniSolrCloudCluster.deleteAllCollections() ...
   ...
   [junit4]   2&amp;gt; 959703 INFO  (qtp531873617-17021) [n:127.0.0.1:42097_solr     ] o.a.s.h.a.CollectionsHandler Invoked Collection Action :delete with params name=testCreateCollectionAddReplica&amp;amp;action=DELETE&amp;amp;wt=javabin&amp;amp;version=2 and sendToOCPQueue=true
   ...
   [junit4]   2&amp;gt; 959709 INFO  (OverseerThreadFactory-5345-thread-5-processing-n:127.0.0.1:44991_solr) [n:127.0.0.1:44991_solr     ] o.a.s.c.a.c.OverseerCollectionMessageHandler Executing Collection Cmd=action=UNLOAD&amp;amp;deleteInstanceDir=true&amp;amp;deleteDataDir=true&amp;amp;deleteMetricsHistory=true, asyncId=null
   ...
   [junit4]   2&amp;gt; 959750 INFO  (qtp531873617-17325) [n:127.0.0.1:42097_solr    x:testCreateCollectionAddReplica_shard1_replica_n1 ] o.a.s.c.SolrCore [testCreateCollectionAddReplica_shard1_replica_n1]  CLOSING SolrCore org.apache.solr.core.SolrCore@39444e66
   ...
   [junit4]   2&amp;gt; 959753 INFO  (qtp531873617-17325) [n:127.0.0.1:42097_solr    x:testCreateCollectionAddReplica_shard1_replica_n1 ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={deleteInstanceDir=true&amp;amp;deleteMetricsHistory=true&amp;amp;core=testCreateCollectionAddReplica_shard1_replica_n1&amp;amp;qt=/admin/cores&amp;amp;deleteDataDir=true&amp;amp;action=UNLOAD&amp;amp;wt=javabin&amp;amp;version=2} status=0 QTime=17


# but meanwhile, PrepRecoveryOp is currently blocked on a call to ZkStateReader.waitForState
# looking for specific conditions for the leader and (new) replica (that needs to recover)
# ... BUT!... the leader core has already been closed, so the watcher never succeeds,
# ...so PrepRecovery keeps waitForState ...

   [junit4]   2&amp;gt; 959855 WARN  (watches-5915-thread-1) [     ] o.a.s.c.c.ZkStateReader Error on calling watcher
   [junit4]   2&amp;gt;           =&amp;gt; org.apache.solr.common.SolrException: core not found:testCreateCollectionAddReplica_shard1_replica_n1
   [junit4]   2&amp;gt;        at org.apache.solr.handler.admin.PrepRecoveryOp.lambda$execute$0(PrepRecoveryOp.java:83)
   [junit4]   2&amp;gt; org.apache.solr.common.SolrException: core not found:testCreateCollectionAddReplica_shard1_replica_n1
   [junit4]   2&amp;gt;        at org.apache.solr.handler.admin.PrepRecoveryOp.lambda$execute$0(PrepRecoveryOp.java:83) ~[java/:?]
   [junit4]   2&amp;gt;        at org.apache.solr.common.cloud.ZkStateReader.lambda$waitForState$13(ZkStateReader.java:1742) ~[java/:?]
   [junit4]   2&amp;gt;        at org.apache.solr.common.cloud.ZkStateReader$DocCollectionAndLiveNodesWatcherWrapper.onStateChanged(ZkStateReader.java:2309) ~[java/:?]
   [junit4]   2&amp;gt;        at org.apache.solr.common.cloud.ZkStateReader$Notification.run(ZkStateReader.java:2041) ~[java/:?]
   [junit4]   2&amp;gt;        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) ~[?:?]
   [junit4]   2&amp;gt;        at java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[?:?]
   [junit4]   2&amp;gt;        at org.apache.solr.common.util.ExecutorUtil$MDCAwareThreadPoolExecutor.lambda$execute$0(ExecutorUtil.java:209) ~[java/:?]
   [junit4]   2&amp;gt;        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[?:?]
   [junit4]   2&amp;gt;        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[?:?]
   [junit4]   2&amp;gt;        at java.lang.Thread.run(Thread.java:835) [?:?]

#  ... repeats 3 times, same millisecond, diff threads
#       (watches-5915-thread-2 &amp;amp; watches-5915-thread-3

# Other then some intranode /admin/metrics requests, *NOTHING* else happens for ~90 seconds
# Until finally the DELETE collection request times out...

   [junit4]   2&amp;gt; 1049792 INFO  (TEST-TestPolicyCloud.testCreateCollectionAddReplica-seed#[CA8FB8D61B016EFE]) [     ] o.a.s.SolrTestCaseJ4 ###Ending testCreateCollectionAddReplica
   [junit4]   2&amp;gt; NOTE: reproduce with: ant test  -Dtestcase=TestPolicyCloud -Dtests.method=testCreateCollectionAddReplica -Dtests.seed=CA8FB8D61B016EFE -Dtests.multiplier=3 -Dtests.slow=true -Dtests.locale=yi-001 -Dtests.timezone=America/Indiana/Indianapolis -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1
   [junit4] ERROR   92.6s J0 | TestPolicyCloud.testCreateCollectionAddReplica &amp;lt;&amp;lt;&amp;lt;
   [junit4]    &amp;gt; Throwable #1: org.apache.solr.client.solrj.SolrServerException: Timeout occurred while waiting response from server at: https://127.0.0.1:42097/solr
   [junit4]    &amp;gt;        at __randomizedtesting.SeedInfo.seed([CA8FB8D61B016EFE:4AAFDDF80A428658]:0)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.executeMethod(HttpSolrClient.java:667)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:262)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:245)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.LBSolrClient.doRequest(LBSolrClient.java:368)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.LBSolrClient.request(LBSolrClient.java:296)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.sendRequest(BaseCloudSolrClient.java:1128)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.requestWithRetryOnStaleState(BaseCloudSolrClient.java:897)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.request(BaseCloudSolrClient.java:829)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.SolrRequest.process(SolrRequest.java:211)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.SolrRequest.process(SolrRequest.java:228)
   [junit4]    &amp;gt;        at org.apache.solr.cloud.MiniSolrCloudCluster.deleteAllCollections(MiniSolrCloudCluster.java:547)
   [junit4]    &amp;gt;        at org.apache.solr.cloud.autoscaling.TestPolicyCloud.after(TestPolicyCloud.java:87)
   [junit4]    &amp;gt;        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   [junit4]    &amp;gt;        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   [junit4]    &amp;gt;        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   [junit4]    &amp;gt;        at java.base/java.lang.reflect.Method.invoke(Method.java:567)
   [junit4]    &amp;gt;        at java.base/java.lang.Thread.run(Thread.java:835)
   [junit4]    &amp;gt; Caused by: java.net.SocketTimeoutException: Read timed out
   [junit4]    &amp;gt;        at java.base/java.net.SocketInputStream.socketRead0(Native Method)
   [junit4]    &amp;gt;        at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
   [junit4]    &amp;gt;        at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
   [junit4]    &amp;gt;        at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
   [junit4]    &amp;gt;        at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:448)
   [junit4]    &amp;gt;        at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:68)
   [junit4]    &amp;gt;        at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1132)
   [junit4]    &amp;gt;        at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:828)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This pattern of &quot;RECOVERY happens concurrently with DELETE, lots of wasted time with nothing logged, DELETE times out or fails&quot; repeats in other jenkins jobs, and in other test methods like &lt;tt&gt;testCreateCollectionSplitShard&lt;/tt&gt; ... when these failures happen, the effects sometimes bleed over into toehr test methods &#8211; aparently because the old collection is &quot;partially&quot; deleted &#8211; the cores are unloaded, but the collection still exists in the cluster state causing problems when future invokations of the &lt;tt&gt;@After&lt;/tt&gt; method calls &lt;tt&gt;MiniSolrCloudCluster.deleteAllCollections()&lt;/tt&gt; ...&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   [junit4]   2&amp;gt; 1081521 INFO  (TEST-TestPolicyCloud.testDataProvider-seed#[CA8FB8D61B016EFE]) [     ] o.a.s.SolrTestCaseJ4 ###Ending testDataProvider
   [junit4]   2&amp;gt; NOTE: reproduce with: ant test  -Dtestcase=TestPolicyCloud -Dtests.method=testDataProvider -Dtests.seed=CA8FB8D61B016EFE -Dtests.multiplier=3 -Dtests.slow=true -Dtests.locale=yi-001 -Dtests.timezone=America/Indiana/Indianapolis -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1
   [junit4] ERROR   31.7s J0 | TestPolicyCloud.testDataProvider &amp;lt;&amp;lt;&amp;lt;
   [junit4]    &amp;gt; Throwable #1: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at https://127.0.0.1:42097/solr: Could not find collection : testCreateCollectionAddReplica
   [junit4]    &amp;gt;        at __randomizedtesting.SeedInfo.seed([CA8FB8D61B016EFE:F22410E3A9C36A27]:0)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.executeMethod(HttpSolrClient.java:656)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:262)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:245)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.LBSolrClient.doRequest(LBSolrClient.java:368)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.LBSolrClient.request(LBSolrClient.java:296)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.sendRequest(BaseCloudSolrClient.java:1128)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.requestWithRetryOnStaleState(BaseCloudSolrClient.java:897)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.impl.BaseCloudSolrClient.request(BaseCloudSolrClient.java:829)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.SolrRequest.process(SolrRequest.java:211)
   [junit4]    &amp;gt;        at org.apache.solr.client.solrj.SolrRequest.process(SolrRequest.java:228)
   [junit4]    &amp;gt;        at org.apache.solr.cloud.MiniSolrCloudCluster.deleteAllCollections(MiniSolrCloudCluster.java:547)
   [junit4]    &amp;gt;        at org.apache.solr.cloud.autoscaling.TestPolicyCloud.after(TestPolicyCloud.java:87)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;FWIW, I should note:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I&apos;ve been unable to reproduce this locally&lt;/li&gt;
	&lt;li&gt;the failures happen on diff jenkins servers, on diff branches, and different OSes&lt;/li&gt;
	&lt;li&gt;so far all of the failures i&apos;ve seen occur when randomized ssl=true, but AFAICT there isn&apos;t any obvious indicatiion that the problem relates to the use of ssl &#8211; i think that just that the added CPU contention caused by using SSL seems to slow things down enough on the jenkins machine that the race contidion happens
	&lt;ul&gt;
		&lt;li&gt;ie: because of SSL slowdown, the recovery isn&apos;t fully completed before the DELETE collection cleanup requests are processed&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;
&lt;p&gt;My initial hunch/impression was that Overseer (Queue) was getting deadlocked trying to invoke the PrepRecoveryOp (which was blocked waiting for a leader that no longer exists) preventing the DeleteCollectionCmd from executing (which would remove the collection from the ClusterState &#8211; the only state change possible to cause the PrepRecoveryOp&apos;s waitForState call to abort.&lt;/p&gt;

&lt;p&gt;I tried to write a new test forcing this specific situation (attached), using a &lt;tt&gt;CloseHook&lt;/tt&gt; on the leader &lt;tt&gt;SolrCore&lt;/tt&gt; and &lt;tt&gt;waitForState()&lt;/tt&gt; predicate that would gate eachother using &lt;tt&gt;CountDownLatches&lt;/tt&gt; to try and coerce the specific sequence of events that seemed to be problematic &#8211; but i can&apos;t seem to force a this type of failure (or even semi-reliably trigger it given that the ZkStateReader executes watchers in a random order).&lt;/p&gt;

&lt;p&gt;If anyone else has any ideas what&apos;s going on here i&apos;m all ears ... in the meantime I&apos;m going to try and work up some general improvements to TestPolicyCLoud to make the assertions tighter and insure all the expected replicas are fully active before finishing the test.&lt;/p&gt;</comment>
                            <comment id="16881790" author="caomanhdat" created="Wed, 10 Jul 2019 07:27:56 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hossman&quot; class=&quot;user-hover&quot; rel=&quot;hossman&quot;&gt;hossman&lt;/a&gt;, thanks a lot for taking a look at this failure. Your analysis make tracking down things much faster.&lt;/p&gt;

&lt;p&gt;I think the problem here belongs to &lt;tt&gt;ZkStateReader&lt;/tt&gt; (or the way we use it in &lt;tt&gt;PreRecoveryOp&lt;/tt&gt;).&lt;br/&gt;
In &lt;tt&gt;PreRecoveryOp&lt;/tt&gt; (this call was added/refactored in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-12801&quot; title=&quot;Fix the tests, remove BadApples and AwaitsFix annotations, improve env for test development.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-12801&quot;&gt;SOLR-12801&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -&amp;gt; {

        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (SolrCore core = coreContainer.getCore(cname)) {
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (core == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SolrException(SolrException.ErrorCode.BAD_REQUEST, &lt;span class=&quot;code-quote&quot;&gt;&quot;core not found:&quot;&lt;/span&gt; + cname);
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So the idea here is we throw an SolrException whenever the core (leader) is not found, so the method will terminate and return response to the replica which is doing recovery.&lt;br/&gt;
But ZkStateReader will never throw any exception happened in Watcher (CollectionStatePredicate) to the upper level, it just log out the exception and continue.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/lucene-solr/blob/fb30ded6436a577af86e5db201eed01170102a97/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java#L2045&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/lucene-solr/blob/fb30ded6436a577af86e5db201eed01170102a97/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java#L2045&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Furthermore that exception watcher never get removed from the list of watchers, so whenever clusterstate get changed, this method will get invoked -&amp;gt; that is the reason why that &lt;tt&gt;&quot;Error on calling watcher&quot;&lt;/tt&gt; appeared multiple times.&lt;/p&gt;</comment>
                            <comment id="16881792" author="caomanhdat" created="Wed, 10 Jul 2019 07:30:39 +0000"  >&lt;p&gt;I&apos;m not sure we should change the &lt;tt&gt;waitForState&lt;/tt&gt; logic to rethrow Exceptions or revert back PrepRecoveryOp to its previous version (before &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-12801&quot; title=&quot;Fix the tests, remove BadApples and AwaitsFix annotations, improve env for test development.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-12801&quot;&gt;SOLR-12801&lt;/a&gt;). &lt;br/&gt;
Need more thought about it.&lt;/p&gt;</comment>
                            <comment id="16881858" author="shalinmangar" created="Wed, 10 Jul 2019 08:44:53 +0000"  >&lt;p&gt;Hoss and Dat &amp;#8211; thank you for investigating this! All usages of CollectionStateWatcher or LiveNodesWatcher will suffer from this problem i.e. the thread that runs the watcher swallows the exception so we should audit all their usages regardless of what solution we go for.&lt;/p&gt;</comment>
                            <comment id="16882245" author="hossman" created="Wed, 10 Jul 2019 16:41:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure we should change the waitForState logic to rethrow Exceptions or revert back PrepRecoveryOp to its previous version ...&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hoss and Dat &#8211; thank you for investigating this! All usages of CollectionStateWatcher or LiveNodesWatcher will suffer from this problem i.e. the thread that runs the watcher swallows the exception ...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Well, generally speaking there isn&apos;t any way (i can think of) for the thread executing a Watcher to do anything &lt;em&gt;but&lt;/em&gt; swallow any exceptions from the watcher &#8211; it can&apos;t propogated it back to the &quot;caller&quot; of registrWatcher or anything like that .. if the caller wanted to be informed then the Watcher it registered should be catching the exceptions itself.&lt;/p&gt;

&lt;p&gt;But to Dat&apos;s point: in the specific case of &lt;tt&gt;waitForState&lt;/tt&gt; &#8211; there ZkStateReader &lt;b&gt;is&lt;/b&gt; creating it&apos;s own Watcher to wrap the input Predicate, and we could in fact make waitForState do something inside that Watcher that catches any Exception thrown by the Predicate and short circuts out of the &lt;tt&gt;waitForState&lt;/tt&gt; call, wrapping/re-throwing the exception in the meantime.&lt;/p&gt;

&lt;p&gt;But those seem like &quot;broader&quot; problems with regards to where/how the different callers are using the Watcher/waitForState APIs that we should probably create a new issue to track (for auditing all of them and clarifying the behavior in the javadocs) ... frankly i think in this specific jira we should be asking a lot more questions about the &lt;em&gt;specific&lt;/em&gt; predicate used in PrepForRecovery&apos;s waitForState call ... notably what exactly is the expectation here when the SolrCore (that prepRecovery wants to recover from) can&apos;t be found &lt;em&gt;in the local CoreContainer&lt;/em&gt; ... deleting the collection is just one example, are there other situations where the core may not be found at this point in the code? (node shutdown perhaps? autoscaling removing a replica) ?&lt;/p&gt;

&lt;p&gt;what about a few lines later...&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (onlyIfLeader != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; onlyIfLeader) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {
              &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SolrException(SolrException.ErrorCode.BAD_REQUEST, &lt;span class=&quot;code-quote&quot;&gt;&quot;We are not the leader&quot;&lt;/span&gt;);
            }
          }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;...even if the SolrCore is found, if we expect it to be the shard leader, and it&apos;s not (what if there has beena leader election in the meantime?) then that&apos;s another type of problem that will also cause the predicate to throw an exception that will (aparently) cause PrepRecovery to stall. what should PrepRecovery do here?&lt;/p&gt;

&lt;p&gt;i suspect that in general the use of waitForState here in PrepRecoveryOp is &quot;ok in concept&quot; ... we just need to make the predicate smarter about exiting immeidately in these situations instead of throwing an exception that gets swallowed ... i&apos;m just not sure what the right behavior for PrepRecovery &lt;b&gt;is&lt;/b&gt; in these sitautions.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I don&apos;t suppose either of you were able to spot what&apos;s &quot;wrong&quot; with my test that it doesn&apos;t force a failure in this situation?&lt;/p&gt;</comment>
                            <comment id="16882523" author="jira-bot" created="Thu, 11 Jul 2019 00:17:13 +0000"  >&lt;p&gt;Commit 8a277cab7d15c03ff59577efceb6a0cb281d095a in lucene-solr&apos;s branch refs/heads/master from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=8a277ca&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=8a277ca&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden TestPolicyCloud&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ensure all collections/replicas are active&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;tighten assertions around expected replica locations&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;eliminate some redundent code&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;These changes should also help ensure we don&apos;t get (more) spurious failures due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16883157" author="hossman" created="Thu, 11 Jul 2019 16:38:12 +0000"  >&lt;p&gt;not sure why/how gitbox missed the 8x cherry-pick: &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=81b2e06ffe6bddcd8d25b24c79683281da85baee&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=81b2e06ffe6bddcd8d25b24c79683281da85baee&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16883471" author="jira-bot" created="Fri, 12 Jul 2019 02:23:29 +0000"  >&lt;p&gt;Commit 8a277cab7d15c03ff59577efceb6a0cb281d095a in lucene-solr&apos;s branch refs/heads/jira/&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13565&quot; title=&quot;Node level runtime libs loaded from remote urls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13565&quot;&gt;&lt;del&gt;SOLR-13565&lt;/del&gt;&lt;/a&gt; from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=8a277ca&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=8a277ca&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden TestPolicyCloud&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ensure all collections/replicas are active&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;tighten assertions around expected replica locations&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;eliminate some redundent code&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;These changes should also help ensure we don&apos;t get (more) spurious failures due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16884390" author="jira-bot" created="Sat, 13 Jul 2019 15:03:08 +0000"  >&lt;p&gt;Commit 7ddba3b7123f11d387ff395516cf46c607ac21ee in lucene-solr&apos;s branch refs/heads/master from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=7ddba3b&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=7ddba3b&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden DeleteReplicaTest&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;tighten assertions related to type of watcher that should be removed&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;use waitForActiveCollection before deleting collections to work around &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt; and/or &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13627&quot; title=&quot;newly created collection can see all replicas go into recovery immediately on first document addition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13627&quot;&gt;SOLR-13627&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16884403" author="jira-bot" created="Sat, 13 Jul 2019 15:38:17 +0000"  >&lt;p&gt;Commit d91900a4a271829325a948aff874301979aba202 in lucene-solr&apos;s branch refs/heads/branch_8x from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=d91900a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=d91900a&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden DeleteReplicaTest&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;tighten assertions related to type of watcher that should be removed&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;use waitForActiveCollection before deleting collections to work around &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt; and/or &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13627&quot; title=&quot;newly created collection can see all replicas go into recovery immediately on first document addition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13627&quot;&gt;SOLR-13627&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(cherry picked from commit 7ddba3b7123f11d387ff395516cf46c607ac21ee)&lt;/p&gt;</comment>
                            <comment id="16894231" author="jira-bot" created="Sat, 27 Jul 2019 02:21:28 +0000"  >&lt;p&gt;Commit 32da33936532a13523be522a8e86820c5bd9a497 in lucene-solr&apos;s branch refs/heads/branch_8x from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=32da339&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=32da339&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden RulesTest&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;ensure all collections/replicas are active&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;use waitForState or waitForActiveCollection before checking rules/snitch to prevent false failures on stale state&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ensure cluster policy is cleared after each test method&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Some of these changes should also help ensure we don&apos;t get (more) spurious failures due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(cherry picked from commit 4050ddc59beeff2be5a862782579ceb8e5775c60)&lt;/p&gt;</comment>
                            <comment id="16894232" author="jira-bot" created="Sat, 27 Jul 2019 02:21:29 +0000"  >&lt;p&gt;Commit 4050ddc59beeff2be5a862782579ceb8e5775c60 in lucene-solr&apos;s branch refs/heads/master from Chris M. Hostetter&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4050ddc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gitbox.apache.org/repos/asf?p=lucene-solr.git;h=4050ddc&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Harden RulesTest&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;ensure all collections/replicas are active&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;use waitForState or waitForActiveCollection before checking rules/snitch to prevent false failures on stale state&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ensure cluster policy is cleared after each test method&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Some of these changes should also help ensure we don&apos;t get (more) spurious failures due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-13616&quot; title=&quot;Possible racecondition/deadlock between collection DELETE and PrepRecovery ? (TestPolicyCloud failures)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-13616&quot;&gt;SOLR-13616&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12974104" name="SOLR-13616.test-incomplete.patch" size="7161" author="hossman" created="Tue, 9 Jul 2019 22:12:01 +0000"/>
                            <attachment id="12974103" name="thetaphi_Lucene-Solr-master-Linux_24358.log.txt" size="7849732" author="hossman" created="Tue, 9 Jul 2019 22:12:23 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 16 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z04ic8:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12313321" key="com.atlassian.jira.toolkit:message">
                        <customfieldname>Solr Mailing List Info</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>