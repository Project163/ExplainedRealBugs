diff --git a/packages/react-router-dom/__tests__/link-href-test.tsx b/packages/react-router-dom/__tests__/link-href-test.tsx
index ae8eedcef..a1aeaac16 100644
--- a/packages/react-router-dom/__tests__/link-href-test.tsx
+++ b/packages/react-router-dom/__tests__/link-href-test.tsx
@@ -1,131 +1,454 @@
 import * as React from "react";
 import { create as createTestRenderer } from "react-test-renderer";
-import { MemoryRouter as Router, Routes, Route, Link } from "react-router-dom";
+import { MemoryRouter, Routes, Route, Link, Outlet } from "react-router-dom";
 
-describe("<Link> anchor href", () => {
-  test("absolute <Link to> resolves relative to the root URL", () => {
-    let renderer = createTestRenderer(
-      <Router initialEntries={["/home"]}>
-        <Routes>
-          <Route path="home" element={<Link to="/about" />} />
-        </Routes>
-      </Router>
-    );
+describe("<Link> href", () => {
+  describe("in a static route", () => {
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox" element={<Link to="/about" />} />
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox" element={<Link to="." />} />
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
 
-    let anchor = renderer.root.findByType("a");
+    test('<Link to=".."> resolves relative to the parent route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages" element={<Link to=".." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
+
+    test('<Link to=".."> with more .. segments than parent routes resolves to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages" element={<Link to="../../about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
 
-    expect(anchor.props.href).toEqual("/about");
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
   });
 
-  test("absolute <Link to> in an index route resolves relative to the root URL", () => {
-    let renderer = createTestRenderer(
-      <Router initialEntries={["/home"]}>
-        <Routes>
-          <Route path="home">
-            <Route index element={<Link to="/about" />} />
-          </Route>
-        </Routes>
-      </Router>
-    );
+  describe("in a dynamic route", () => {
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/:id" element={<Link to="/about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/:id" element={<Link to="." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual(
+        "/inbox/messages/abc"
+      );
+    });
+
+    test('<Link to=".."> resolves relative to the parent route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/:id" element={<Link to=".." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
 
-    let anchor = renderer.root.findByType("a");
+    test('<Link to=".."> with more .. segments than parent routes resolves to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/:id" element={<Link to="../../about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
 
-    expect(anchor.props.href).toEqual("/about");
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
   });
 
-  test("absolute <Link to> in descendant <Routes> resolves relative to the root URL", () => {
-    let renderer = createTestRenderer(
-      <Router initialEntries={["/auth/login"]}>
-        <Routes>
-          <Route
-            path="auth/*"
-            element={
-              <Routes>
-                <Route
-                  path="login"
-                  element={<Link to="/auth/forgot-password" />}
-                />
-              </Routes>
-            }
-          />
-        </Routes>
-      </Router>
-    );
-
-    let anchor = renderer.root.findByType("a");
-
-    expect(anchor.props.href).toEqual("/auth/forgot-password");
+  describe("in an index route", () => {
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route index element={<Link to="/home" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/home");
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route index element={<Link to="." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
+
+    test('<Link to=".."> resolves relative to the parent route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route index element={<Link to=".." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
+
+    test('<Link to=".."> with more .. segments than parent routes resolves to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route index element={<Link to="../../about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
   });
 
-  test('<Link to="."> resolves relative to the current route', () => {
-    let renderer = createTestRenderer(
-      <Router initialEntries={["/home"]}>
-        <Routes>
-          <Route path="home" element={<Link to="." />} />
-        </Routes>
-      </Router>
-    );
+  describe("in a layout route", () => {
+    function MessagesLayout({ link }: { link: React.ReactElement }) {
+      return (
+        <div>
+          {link}
+          <Outlet />
+        </div>
+      );
+    }
+
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route element={<MessagesLayout link={<Link to="/home" />} />}>
+                <Route path="messages" element={<h1>Messages</h1>} />
+              </Route>
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/home");
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route element={<MessagesLayout link={<Link to="." />} />}>
+                <Route path="messages" element={<h1>Messages</h1>} />
+              </Route>
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
+
+    test('<Link to=".."> resolves relative to the parent route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route element={<MessagesLayout link={<Link to=".." />} />}>
+                <Route path="messages" element={<h1>Messages</h1>} />
+              </Route>
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
 
-    let anchor = renderer.root.findByType("a");
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
 
-    expect(anchor.props.href).toEqual("/home");
+    test('<Link to=".."> with more .. segments than parent routes resolves to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route
+                element={<MessagesLayout link={<Link to="../../about" />} />}
+              >
+                <Route path="messages" element={<h1>Messages</h1>} />
+              </Route>
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
   });
 
-  test('<Link to="."> in a splat route resolves relative to the current route', () => {
-    let renderer = createTestRenderer(
-      <Router initialEntries={["/home/inbox"]}>
-        <Routes>
-          <Route path="home/*" element={<Link to="." />} />
-        </Routes>
-      </Router>
-    );
+  describe("in a splat route", () => {
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/123"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/*" element={<Link to="/about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/*" element={<Link to="." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual(
+        "/inbox/messages"
+      );
+    });
+
+    test('<Link to=".."> resolves relative to the parent route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/*" element={<Link to=".." />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/inbox");
+    });
+
+    test("<Link to> pointing to a sibling route resolves relative to its parent route", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages/abc"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route
+                path="messages/*"
+                element={<Link to="../messages/def" />}
+              />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
 
-    let anchor = renderer.root.findByType("a");
+      expect(renderer.root.findByType("a").props.href).toEqual(
+        "/inbox/messages/def"
+      );
+    });
+
+    test('<Link to=".."> with more .. segments than parent routes resolves to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/inbox/messages"]}>
+          <Routes>
+            <Route path="inbox">
+              <Route path="messages/*" element={<Link to="../../../about" />} />
+            </Route>
+          </Routes>
+        </MemoryRouter>
+      );
 
-    expect(anchor.props.href).toEqual("/home/inbox");
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
+    });
   });
 
   describe("under a <Router basename>", () => {
     test("absolute <Link to> resolves relative to the basename", () => {
       let renderer = createTestRenderer(
-        <Router basename="/app" initialEntries={["/app/home"]}>
+        <MemoryRouter basename="/app" initialEntries={["/app/inbox"]}>
           <Routes>
-            <Route path="home" element={<Link to="/about" />} />
+            <Route path="inbox" element={<Link to="/about" />} />
           </Routes>
-        </Router>
+        </MemoryRouter>
       );
 
-      let anchor = renderer.root.findByType("a");
-
-      expect(anchor.props.href).toEqual("/app/about");
+      expect(renderer.root.findByType("a").props.href).toEqual("/app/about");
     });
 
     test('<Link to="."> resolves relative to the current route', () => {
       let renderer = createTestRenderer(
-        <Router basename="/app" initialEntries={["/app/home"]}>
+        <MemoryRouter basename="/app" initialEntries={["/app/inbox"]}>
           <Routes>
-            <Route path="home" element={<Link to="." />} />
+            <Route path="inbox" element={<Link to="." />} />
           </Routes>
-        </Router>
+        </MemoryRouter>
       );
 
-      let anchor = renderer.root.findByType("a");
-
-      expect(anchor.props.href).toEqual("/app/home");
+      expect(renderer.root.findByType("a").props.href).toEqual("/app/inbox");
     });
 
     test('<Link to=".."> with no parent route resolves relative to the basename', () => {
       let renderer = createTestRenderer(
-        <Router basename="/app" initialEntries={["/app/home"]}>
+        <MemoryRouter basename="/app" initialEntries={["/app/inbox"]}>
+          <Routes>
+            <Route path="inbox" element={<Link to="../about" />} />
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/app/about");
+    });
+  });
+
+  describe("in a descendant <Routes>", () => {
+    test("absolute <Link to> resolves relative to the root URL", () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/auth/login"]}>
           <Routes>
-            <Route path="home" element={<Link to="../about" />} />
+            <Route
+              path="auth/*"
+              element={
+                <Routes>
+                  <Route
+                    path="login"
+                    element={<Link to="/auth/forgot-password" />}
+                  />
+                </Routes>
+              }
+            />
           </Routes>
-        </Router>
+        </MemoryRouter>
       );
 
-      let anchor = renderer.root.findByType("a");
+      expect(renderer.root.findByType("a").props.href).toEqual(
+        "/auth/forgot-password"
+      );
+    });
+
+    test('<Link to="."> resolves relative to the current route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/auth/login"]}>
+          <Routes>
+            <Route
+              path="auth/*"
+              element={
+                <Routes>
+                  <Route path="login" element={<Link to="." />} />
+                </Routes>
+              }
+            />
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/auth/login");
+    });
+
+    test('<Link to=".."> resolves relative to the ancestor route', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/auth/login"]}>
+          <Routes>
+            <Route
+              path="auth/*"
+              element={
+                <Routes>
+                  <Route path="login" element={<Link to=".." />} />
+                </Routes>
+              }
+            />
+          </Routes>
+        </MemoryRouter>
+      );
+
+      expect(renderer.root.findByType("a").props.href).toEqual("/auth");
+    });
+
+    test('<Link to=".."> with more .. segments than ancestor routes resolves relative to the root URL', () => {
+      let renderer = createTestRenderer(
+        <MemoryRouter initialEntries={["/auth/login"]}>
+          <Routes>
+            <Route
+              path="auth/*"
+              element={
+                <Routes>
+                  <Route path="login" element={<Link to="../../../about" />} />
+                </Routes>
+              }
+            />
+          </Routes>
+        </MemoryRouter>
+      );
 
-      expect(anchor.props.href).toEqual("/app/about");
+      expect(renderer.root.findByType("a").props.href).toEqual("/about");
     });
   });
 });
diff --git a/packages/react-router/__tests__/useHref-test.tsx b/packages/react-router/__tests__/useHref-test.tsx
index f41d21758..80a8d1f6b 100644
--- a/packages/react-router/__tests__/useHref-test.tsx
+++ b/packages/react-router/__tests__/useHref-test.tsx
@@ -140,7 +140,9 @@ describe("useHref", () => {
       createTestRenderer(
         <Router initialEntries={["/courses/advanced-react"]}>
           <Routes>
-            <Route path="courses/advanced-react" element={<AdvancedReact />} />
+            <Route path="courses">
+              <Route path="advanced-react" element={<AdvancedReact />} />
+            </Route>
           </Routes>
         </Router>
       );
@@ -159,10 +161,9 @@ describe("useHref", () => {
         createTestRenderer(
           <Router initialEntries={["/courses/advanced-react/"]}>
             <Routes>
-              <Route
-                path="courses/advanced-react"
-                element={<AdvancedReact />}
-              />
+              <Route path="courses">
+                <Route path="advanced-react" element={<AdvancedReact />} />
+              </Route>
             </Routes>
           </Router>
         );
@@ -182,10 +183,9 @@ describe("useHref", () => {
         createTestRenderer(
           <Router initialEntries={["/courses/advanced-react"]}>
             <Routes>
-              <Route
-                path="courses/advanced-react"
-                element={<AdvancedReact />}
-              />
+              <Route path="courses">
+                <Route path="advanced-react" element={<AdvancedReact />} />
+              </Route>
             </Routes>
           </Router>
         );
diff --git a/packages/react-router/__tests__/useResolvedPath-test.tsx b/packages/react-router/__tests__/useResolvedPath-test.tsx
index 07def7898..69d4b7f2c 100644
--- a/packages/react-router/__tests__/useResolvedPath-test.tsx
+++ b/packages/react-router/__tests__/useResolvedPath-test.tsx
@@ -94,7 +94,7 @@ describe("useResolvedPath", () => {
 
       expect(renderer.toJSON()).toMatchInlineSnapshot(`
         <pre>
-          {"pathname":"/users/mj","search":"","hash":""}
+          {"pathname":"/users","search":"","hash":""}
         </pre>
       `);
     });
diff --git a/packages/react-router/index.tsx b/packages/react-router/index.tsx
index 254ef50e1..36a12c4aa 100644
--- a/packages/react-router/index.tsx
+++ b/packages/react-router/index.tsx
@@ -82,20 +82,14 @@ if (__DEV__) {
   LocationContext.displayName = "Location";
 }
 
-interface RouteContextObject<ParamKey extends string = string> {
+interface RouteContextObject {
   outlet: React.ReactElement | null;
-  params: Readonly<Params<ParamKey>>;
-  pathname: string;
-  pathnameBase: string;
-  route: RouteObject | null;
+  matches: RouteMatch[];
 }
 
 const RouteContext = React.createContext<RouteContextObject>({
   outlet: null,
-  params: {},
-  pathname: "/",
-  pathnameBase: "/",
-  route: null
+  matches: []
 });
 
 if (__DEV__) {
@@ -492,9 +486,13 @@ export function useNavigate(): NavigateFunction {
   );
 
   let { basename, navigator } = React.useContext(NavigationContext);
-  let { pathname: routePathname } = React.useContext(RouteContext);
+  let { matches } = React.useContext(RouteContext);
   let { pathname: locationPathname } = useLocation();
 
+  let routePathnamesJson = JSON.stringify(
+    matches.map(match => match.pathnameBase)
+  );
+
   let activeRef = React.useRef(false);
   React.useEffect(() => {
     activeRef.current = true;
@@ -515,7 +513,11 @@ export function useNavigate(): NavigateFunction {
         return;
       }
 
-      let path = resolveTo(to, routePathname, locationPathname);
+      let path = resolveTo(
+        to,
+        JSON.parse(routePathnamesJson),
+        locationPathname
+      );
 
       if (basename !== "/") {
         path.pathname = joinPaths([basename, path.pathname]);
@@ -526,7 +528,7 @@ export function useNavigate(): NavigateFunction {
         options.state
       );
     },
-    [basename, navigator, routePathname, locationPathname]
+    [basename, navigator, routePathnamesJson, locationPathname]
   );
 
   return navigate;
@@ -551,7 +553,9 @@ export function useOutlet(): React.ReactElement | null {
 export function useParams<Key extends string = string>(): Readonly<
   Params<Key>
 > {
-  return React.useContext(RouteContext).params;
+  let { matches } = React.useContext(RouteContext);
+  let routeMatch = matches[matches.length - 1];
+  return routeMatch ? (routeMatch.params as any) : {};
 }
 
 /**
@@ -560,12 +564,16 @@ export function useParams<Key extends string = string>(): Readonly<
  * @see https://reactrouter.com/api/useResolvedPath
  */
 export function useResolvedPath(to: To): Path {
-  let { pathname: routePathname } = React.useContext(RouteContext);
+  let { matches } = React.useContext(RouteContext);
   let { pathname: locationPathname } = useLocation();
 
+  let routePathnamesJson = JSON.stringify(
+    matches.map(match => match.pathnameBase)
+  );
+
   return React.useMemo(
-    () => resolveTo(to, routePathname, locationPathname),
-    [to, routePathname, locationPathname]
+    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),
+    [to, routePathnamesJson, locationPathname]
   );
 }
 
@@ -588,12 +596,12 @@ export function useRoutes(
     `useRoutes() may be used only in the context of a <Router> component.`
   );
 
-  let {
-    params: parentParams,
-    pathname: parentPathname,
-    pathnameBase: parentPathnameBase,
-    route: parentRoute
-  } = React.useContext(RouteContext);
+  let { matches: parentMatches } = React.useContext(RouteContext);
+  let routeMatch = parentMatches[parentMatches.length - 1];
+  let parentParams = routeMatch ? routeMatch.params : {};
+  let parentPathname = routeMatch ? routeMatch.pathname : "/";
+  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
+  let parentRoute = routeMatch && routeMatch.route;
 
   if (__DEV__) {
     // You won't get a warning about 2 different <Routes> under a <Route>
@@ -665,7 +673,7 @@ export function useRoutes(
     );
   }
 
-  return renderMatches(
+  return _renderMatches(
     matches &&
       matches.map(match =>
         Object.assign({}, match, {
@@ -673,7 +681,8 @@ export function useRoutes(
           pathname: joinPaths([parentPathnameBase, match.pathname]),
           pathnameBase: joinPaths([parentPathnameBase, match.pathnameBase])
         })
-      )
+      ),
+    parentMatches
   );
 }
 
@@ -968,7 +977,9 @@ function matchRouteBranch<ParamKey extends string = string>(
       route
     });
 
-    matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
+    if (match.pathnameBase !== "/") {
+      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
+    }
 
     routes = route.children!;
   }
@@ -981,19 +992,23 @@ function matchRouteBranch<ParamKey extends string = string>(
  */
 export function renderMatches(
   matches: RouteMatch[] | null
+): React.ReactElement | null {
+  return _renderMatches(matches);
+}
+
+function _renderMatches(
+  matches: RouteMatch[] | null,
+  parentMatches: RouteMatch[] = []
 ): React.ReactElement | null {
   if (matches == null) return null;
 
-  return matches.reduceRight((outlet, match) => {
+  return matches.reduceRight((outlet, match, index) => {
     return (
       <RouteContext.Provider
         children={match.route.element || <Outlet />}
         value={{
           outlet,
-          params: match.params,
-          pathname: match.pathname,
-          pathnameBase: match.pathnameBase,
-          route: match.route
+          matches: parentMatches.concat(matches.slice(0, index + 1))
         }}
       />
     );
@@ -1203,23 +1218,58 @@ function resolvePathname(relativePath: string, fromPathname: string): string {
 }
 
 function resolveTo(
-  to: To,
-  routePathname: string,
+  toArg: To,
+  routePathnames: string[],
   locationPathname: string
 ): Path {
-  return resolvePath(
-    to,
-    // If a pathname is explicitly provided in `to`, it should be
-    // relative to the route context. This is explained in `Note on
-    // `<Link to>` values` in our migration guide from v5 as a means of
-    // disambiguation between `to` values that begin with `/` and those
-    // that do not. However, this is problematic for `to` values that do
-    // not provide a pathname. `to` can simply be a search or hash
-    // string, in which case we should assume that the navigation is
-    // relative to the current location's pathname and *not* the
-    // route pathname.
-    getToPathname(to) == null ? locationPathname : routePathname
-  );
+  let to = typeof toArg === "string" ? parsePath(toArg) : toArg;
+  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
+
+  // If a pathname is explicitly provided in `to`, it should be relative to the
+  // route context. This is explained in `Note on `<Link to>` values` in our
+  // migration guide from v5 as a means of disambiguation between `to` values
+  // that begin with `/` and those that do not. However, this is problematic for
+  // `to` values that do not provide a pathname. `to` can simply be a search or
+  // hash string, in which case we should assume that the navigation is relative
+  // to the current location's pathname and *not* the route pathname.
+  let from: string;
+  if (toPathname == null) {
+    from = locationPathname;
+  } else {
+    let routePathnameIndex = routePathnames.length - 1;
+
+    if (toPathname.startsWith("..")) {
+      let toSegments = toPathname.split("/");
+
+      // Each leading .. segment means "go up one route" instead of "go up one
+      // URL segment".  This is a key difference from how <a href> works and a
+      // major reason we call this a "to" value instead of a "href".
+      while (toSegments[0] === "..") {
+        toSegments.shift();
+        routePathnameIndex -= 1;
+      }
+
+      to.pathname = toSegments.join("/");
+    }
+
+    // If there are more ".." segments than parent routes, resolve relative to
+    // the root / URL.
+    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
+  }
+
+  let path = resolvePath(to, from);
+
+  // Ensure the pathname has a trailing slash if the original to value had one.
+  if (
+    toPathname &&
+    toPathname !== "/" &&
+    toPathname.endsWith("/") &&
+    !path.pathname.endsWith("/")
+  ) {
+    path.pathname += "/";
+  }
+
+  return path;
 }
 
 function getToPathname(to: To): string | undefined {
