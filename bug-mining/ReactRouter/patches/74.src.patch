diff --git a/packages/react-router/__tests__/matchPath-test.tsx b/packages/react-router/__tests__/matchPath-test.tsx
index 8453689ba..fdcc5809b 100644
--- a/packages/react-router/__tests__/matchPath-test.tsx
+++ b/packages/react-router/__tests__/matchPath-test.tsx
@@ -241,6 +241,63 @@ describe("matchPath", () => {
   });
 });
 
+describe("matchPath *", () => {
+  it("matches the root URL", () => {
+    expect(matchPath("*", "/")).toMatchObject({
+      pathname: "/",
+      pathnameBase: "/"
+    });
+    expect(matchPath("/*", "/")).toMatchObject({
+      pathname: "/",
+      pathnameBase: "/"
+    });
+  });
+
+  it("matches a URL with a segment", () => {
+    expect(matchPath("*", "/users")).toMatchObject({
+      pathname: "/users",
+      pathnameBase: "/"
+    });
+    expect(matchPath("/*", "/users")).toMatchObject({
+      pathname: "/users",
+      pathnameBase: "/"
+    });
+  });
+
+  it("matches a URL with a segment and a trailing slash", () => {
+    expect(matchPath("*", "/users/")).toMatchObject({
+      pathname: "/users/",
+      pathnameBase: "/"
+    });
+    expect(matchPath("/*", "/users/")).toMatchObject({
+      pathname: "/users/",
+      pathnameBase: "/"
+    });
+  });
+
+  it("matches a URL with multiple segments", () => {
+    expect(matchPath("*", "/users/mj")).toMatchObject({
+      pathname: "/users/mj",
+      pathnameBase: "/"
+    });
+    expect(matchPath("/*", "/users/mj")).toMatchObject({
+      pathname: "/users/mj",
+      pathnameBase: "/"
+    });
+  });
+
+  it("matches a URL with multiple segments and a trailing slash", () => {
+    expect(matchPath("*", "/users/mj/")).toMatchObject({
+      pathname: "/users/mj/",
+      pathnameBase: "/"
+    });
+    expect(matchPath("/*", "/users/mj/")).toMatchObject({
+      pathname: "/users/mj/",
+      pathnameBase: "/"
+    });
+  });
+});
+
 describe("matchPath warnings", () => {
   let consoleWarn: jest.SpyInstance<void, any>;
   beforeEach(() => {
diff --git a/packages/react-router/__tests__/params-decode-test.tsx b/packages/react-router/__tests__/params-decode-test.tsx
new file mode 100644
index 000000000..aa4512e03
--- /dev/null
+++ b/packages/react-router/__tests__/params-decode-test.tsx
@@ -0,0 +1,33 @@
+import * as React from "react";
+import { create as createTestRenderer } from "react-test-renderer";
+import { MemoryRouter as Router, Routes, Route, useParams } from "react-router";
+
+describe("Decoding params", () => {
+  it("works", () => {
+    function Content() {
+      return <p>The params are {JSON.stringify(useParams())}</p>;
+    }
+
+    let renderer = createTestRenderer(
+      <Router initialEntries={["/content/%2F"]}>
+        <Routes>
+          <Route
+            path="content/*"
+            element={
+              <Routes>
+                <Route path=":id" element={<Content />} />
+              </Routes>
+            }
+          />
+        </Routes>
+      </Router>
+    );
+
+    expect(renderer.toJSON()).toMatchInlineSnapshot(`
+      <p>
+        The params are 
+        {"*":"/","id":"/"}
+      </p>
+    `);
+  });
+});
diff --git a/packages/react-router/__tests__/path-matching-test.tsx b/packages/react-router/__tests__/path-matching-test.tsx
index 68c797423..feae708df 100644
--- a/packages/react-router/__tests__/path-matching-test.tsx
+++ b/packages/react-router/__tests__/path-matching-test.tsx
@@ -145,8 +145,9 @@ describe("path matching with a basename", () => {
     expect(matches).toHaveLength(1);
     expect(matches).toMatchObject([
       {
+        params: { userId: "michael" },
         pathname: "/users/michael",
-        params: { userId: "michael" }
+        pathnameBase: "/users/michael"
       }
     ]);
   });
@@ -159,16 +160,19 @@ describe("path matching with a basename", () => {
     expect(matches).toHaveLength(3);
     expect(matches).toMatchObject([
       {
+        params: { userId: "michael", courseId: "react" },
         pathname: "/users/michael",
-        params: { userId: "michael", courseId: "react" }
+        pathnameBase: "/users/michael"
       },
       {
+        params: { userId: "michael", courseId: "react" },
         pathname: "/users/michael/subjects",
-        params: { userId: "michael", courseId: "react" }
+        pathnameBase: "/users/michael/subjects"
       },
       {
+        params: { userId: "michael", courseId: "react" },
         pathname: "/users/michael/subjects/react",
-        params: { userId: "michael", courseId: "react" }
+        pathnameBase: "/users/michael/subjects/react"
       }
     ]);
   });
@@ -184,7 +188,8 @@ describe("path matching with splats", () => {
       expect(match).not.toBeNull();
       expect(match[0]).toMatchObject({
         params: { id: "mj", "*": "secrets.txt" },
-        pathname: "/users/mj/files/secrets.txt"
+        pathname: "/users/mj/files/secrets.txt",
+        pathnameBase: "/users/mj/files"
       });
     });
 
@@ -196,18 +201,7 @@ describe("path matching with splats", () => {
     });
   });
 
-  test("splat after something other than /", () => {
-    let routes = [{ path: "users/:id/files-*" }];
-    let match = matchRoutes(routes, "/users/mj/files-secrets.txt")!;
-
-    expect(match).not.toBeNull();
-    expect(match[0]).toMatchObject({
-      params: { id: "mj", "*": "secrets.txt" },
-      pathname: "/users/mj/files-secrets.txt"
-    });
-  });
-
-  test("parent route with splat after /", () => {
+  test("parent route with splat", () => {
     let routes = [
       { path: "users/:id/files/*", children: [{ path: "secrets.txt" }] }
     ];
@@ -216,7 +210,8 @@ describe("path matching with splats", () => {
     expect(match).not.toBeNull();
     expect(match[0]).toMatchObject({
       params: { id: "mj", "*": "secrets.txt" },
-      pathname: "/users/mj/files/secrets.txt"
+      pathname: "/users/mj/files/secrets.txt",
+      pathnameBase: "/users/mj/files"
     });
     expect(match[1]).toMatchObject({
       params: { id: "mj", "*": "secrets.txt" },
@@ -233,15 +228,18 @@ describe("path matching with splats", () => {
     expect(match).not.toBeNull();
     expect(match[0]).toMatchObject({
       params: { "*": "one/two/three" },
-      pathname: "/one/two/three"
+      pathname: "/one/two/three",
+      pathnameBase: "/"
     });
     expect(match[1]).toMatchObject({
       params: { "*": "one/two/three" },
-      pathname: "/one/two/three"
+      pathname: "/one/two/three",
+      pathnameBase: "/"
     });
     expect(match[2]).toMatchObject({
       params: { "*": "one/two/three" },
-      pathname: "/one/two/three"
+      pathname: "/one/two/three",
+      pathnameBase: "/"
     });
   });
 });
diff --git a/packages/react-router/index.tsx b/packages/react-router/index.tsx
index ed3f137c1..254ef50e1 100644
--- a/packages/react-router/index.tsx
+++ b/packages/react-router/index.tsx
@@ -86,6 +86,7 @@ interface RouteContextObject<ParamKey extends string = string> {
   outlet: React.ReactElement | null;
   params: Readonly<Params<ParamKey>>;
   pathname: string;
+  pathnameBase: string;
   route: RouteObject | null;
 }
 
@@ -93,6 +94,7 @@ const RouteContext = React.createContext<RouteContextObject>({
   outlet: null,
   params: {},
   pathname: "/",
+  pathnameBase: "/",
   route: null
 });
 
@@ -589,6 +591,7 @@ export function useRoutes(
   let {
     params: parentParams,
     pathname: parentPathname,
+    pathnameBase: parentPathnameBase,
     route: parentRoute
   } = React.useContext(RouteContext);
 
@@ -628,18 +631,31 @@ export function useRoutes(
   }
 
   let locationFromContext = useLocation();
-  let location = locationArg
-    ? typeof locationArg === "string"
-      ? parsePath(locationArg)
-      : locationArg
-    : locationFromContext;
-  let pathname = location.pathname || "/";
 
-  let parentPathnameStart = getPathnameStart(parentPathname, parentParams);
+  let location;
+  if (locationArg) {
+    let parsedLocationArg =
+      typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
+
+    invariant(
+      parentPathnameBase === "/" ||
+        parsedLocationArg.pathname?.startsWith(parentPathnameBase),
+      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, ` +
+        `the location pathname must begin with the portion of the URL pathname that was ` +
+        `matched by all parent routes. The current pathname base is "${parentPathnameBase}" ` +
+        `but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
+    );
+
+    location = parsedLocationArg;
+  } else {
+    location = locationFromContext;
+  }
+
+  let pathname = location.pathname || "/";
   let remainingPathname =
-    parentPathnameStart === "/"
+    parentPathnameBase === "/"
       ? pathname
-      : pathname.slice(parentPathnameStart.length);
+      : pathname.slice(parentPathnameBase.length) || "/";
   let matches = matchRoutes(routes, { pathname: remainingPathname });
 
   if (__DEV__) {
@@ -654,7 +670,8 @@ export function useRoutes(
       matches.map(match =>
         Object.assign({}, match, {
           params: Object.assign({}, parentParams, match.params),
-          pathname: joinPaths([parentPathnameStart, match.pathname])
+          pathname: joinPaths([parentPathnameBase, match.pathname]),
+          pathnameBase: joinPaths([parentPathnameBase, match.pathnameBase])
         })
       )
   );
@@ -756,6 +773,10 @@ export interface RouteMatch<ParamKey extends string = string> {
    * The portion of the URL pathname that was matched.
    */
   pathname: string;
+  /**
+   * The portion of the URL pathname that was matched before child routes.
+   */
+  pathnameBase: string;
   /**
    * The route object that was used to match.
    */
@@ -912,6 +933,7 @@ function compareIndexes(a: number[], b: number[]): number {
 
 function matchRouteBranch<ParamKey extends string = string>(
   branch: RouteBranch,
+  // TODO: attach original route object inside routesMeta so we don't need this arg
   routesArg: RouteObject[],
   pathname: string
 ): RouteMatch<ParamKey>[] | null {
@@ -924,13 +946,13 @@ function matchRouteBranch<ParamKey extends string = string>(
   for (let i = 0; i < routesMeta.length; ++i) {
     let meta = routesMeta[i];
     let end = i === routesMeta.length - 1;
-    let trailingPathname =
+    let remainingPathname =
       matchedPathname === "/"
         ? pathname
         : pathname.slice(matchedPathname.length) || "/";
     let match = matchPath(
       { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
-      trailingPathname
+      remainingPathname
     );
 
     if (!match) return null;
@@ -941,20 +963,12 @@ function matchRouteBranch<ParamKey extends string = string>(
 
     matches.push({
       params: matchedParams,
-      pathname:
-        match.pathname === "/"
-          ? matchedPathname
-          : joinPaths([matchedPathname, match.pathname]),
+      pathname: joinPaths([matchedPathname, match.pathname]),
+      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
       route
     });
 
-    let pathnameStart = getPathnameStart(match.pathname, match.params);
-    if (pathnameStart !== "/") {
-      // Add only the portion of the match.pathname that comes before the * to
-      // the matchedPathname. This allows child routes to match against the
-      // portion of the pathname that was matched by the *.
-      matchedPathname = joinPaths([matchedPathname, pathnameStart]);
-    }
+    matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
 
     routes = route.children!;
   }
@@ -978,6 +992,7 @@ export function renderMatches(
           outlet,
           params: match.params,
           pathname: match.pathname,
+          pathnameBase: match.pathnameBase,
           route: match.route
         }}
       />
@@ -1092,10 +1107,11 @@ function compilePath(
   end = true
 ): [RegExp, string[]] {
   warning(
-    !path.endsWith("*") || path.endsWith("/*"),
-    `Route path "${path}" ends with \`*\` but it will be treated as ` +
-      `if it ended with \`/*\`. To get rid of this warning, please ` +
-      `adjust the route path to end with \`/*\`.`
+    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
+    `Route path "${path}" will be treated as if it were ` +
+      `"${path.replace(/\*$/, "/*")}" because the \`*\` character must ` +
+      `always follow a \`/\` in the pattern. To get rid of this warning, ` +
+      `please change the route path to "${path.replace(/\*$/, "/*")}".`
   );
 
   let paramNames: string[] = [];
@@ -1113,7 +1129,7 @@ function compilePath(
   if (path.endsWith("*")) {
     paramNames.push("*");
     regexpSource +=
-      path === "/*"
+      path === "*" || path === "/*"
         ? "(.*)$" // Already matched the initial /, just match the rest
         : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
   } else {
@@ -1215,16 +1231,6 @@ function getToPathname(to: To): string | undefined {
     : to.pathname;
 }
 
-function getPathnameStart(pathname: string, params: Params): string {
-  let splat = params["*"];
-  if (!splat) return pathname;
-  let pathnameStart = pathname.slice(0, -splat.length);
-  if (splat.startsWith("/")) return pathnameStart;
-  let index = pathnameStart.lastIndexOf("/");
-  if (index > 0) return pathnameStart.slice(0, index);
-  return "/";
-}
-
 function stripBasename(pathname: string, basename: string): string | null {
   if (basename === "/") return pathname;
 
