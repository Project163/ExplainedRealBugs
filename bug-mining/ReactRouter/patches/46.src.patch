diff --git a/packages/react-router/modules/Lifecycle.js b/packages/react-router/modules/Lifecycle.js
new file mode 100644
index 000000000..a672c0ed1
--- /dev/null
+++ b/packages/react-router/modules/Lifecycle.js
@@ -0,0 +1,21 @@
+import React from "react";
+
+class Lifecycle extends React.Component {
+  componentDidMount() {
+    if (this.props.onMount) this.props.onMount.call(this, this);
+  }
+
+  componentDidUpdate(prevProps) {
+    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
+  }
+
+  componentWillUnmount() {
+    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
+  }
+
+  render() {
+    return null;
+  }
+}
+
+export default Lifecycle;
diff --git a/packages/react-router/modules/Prompt.js b/packages/react-router/modules/Prompt.js
index da7fdc898..3e0761a3b 100644
--- a/packages/react-router/modules/Prompt.js
+++ b/packages/react-router/modules/Prompt.js
@@ -2,39 +2,9 @@ import React from "react";
 import PropTypes from "prop-types";
 import invariant from "invariant";
 
+import Lifecycle from "./Lifecycle";
 import RouterContext from "./RouterContext";
 
-class Block extends React.Component {
-  constructor(props) {
-    super(props);
-    this.release = props.method(props.message);
-  }
-
-  componentDidUpdate(prevProps) {
-    if (prevProps.message !== this.props.message) {
-      this.release();
-      this.release = this.props.method(this.props.message);
-    }
-  }
-
-  componentWillUnmount() {
-    this.release();
-  }
-
-  render() {
-    return null;
-  }
-}
-
-if (__DEV__) {
-  const messageType = PropTypes.oneOfType([PropTypes.func, PropTypes.string]);
-
-  Block.propTypes = {
-    method: PropTypes.func.isRequired,
-    message: messageType.isRequired
-  };
-}
-
 /**
  * The public API for prompting the user before navigating away from a screen.
  */
@@ -44,9 +14,27 @@ function Prompt(props) {
       {context => {
         invariant(context, "You should not use <Prompt> outside a <Router>");
 
-        return props.when ? (
-          <Block method={context.history.block} message={props.message} />
-        ) : null;
+        if (!props.when) return null;
+
+        const method = context.history.block;
+        const message = props.message;
+
+        return (
+          <Lifecycle
+            onMount={self => {
+              self.release = method(message);
+            }}
+            onUpdate={(self, prevProps) => {
+              if (prevProps.message !== message) {
+                self.release();
+                self.release = method(message);
+              }
+            }}
+            onUnmount={self => {
+              self.release();
+            }}
+          />
+        );
       }}
     </RouterContext.Consumer>
   );
diff --git a/packages/react-router/modules/Redirect.js b/packages/react-router/modules/Redirect.js
index 7c054f945..657b133ce 100644
--- a/packages/react-router/modules/Redirect.js
+++ b/packages/react-router/modules/Redirect.js
@@ -3,39 +3,10 @@ import PropTypes from "prop-types";
 import { createLocation, locationsAreEqual } from "history";
 import invariant from "invariant";
 
+import Lifecycle from "./Lifecycle";
 import RouterContext from "./RouterContext";
 import generatePath from "./generatePath";
 
-class Navigate extends React.Component {
-  constructor(props) {
-    super(props);
-    props.method(props.to);
-  }
-
-  componentDidUpdate(prevProps) {
-    if (!locationsAreEqual(prevProps.to, this.props.to)) {
-      this.props.method(this.props.to);
-    }
-  }
-
-  render() {
-    return null;
-  }
-}
-
-if (__DEV__) {
-  const locationType = PropTypes.shape({
-    pathname: PropTypes.string.isRequired,
-    search: PropTypes.string.isRequired,
-    hash: PropTypes.string.isRequired
-  });
-
-  Navigate.propTypes = {
-    method: PropTypes.func.isRequired,
-    to: locationType.isRequired
-  };
-}
-
 /**
  * The public API for navigating programmatically with a component.
  */
@@ -62,7 +33,26 @@ function Redirect(props) {
             : props.to
         );
 
-        return <Navigate method={method} to={to} />;
+        // When rendering in a static context,
+        // set the new location immediately.
+        if (context.staticContext) {
+          method(to);
+          return null;
+        }
+
+        return (
+          <Lifecycle
+            onMount={() => {
+              method(to);
+            }}
+            onUpdate={(self, prevProps) => {
+              if (!locationsAreEqual(prevProps.to, to)) {
+                method(to);
+              }
+            }}
+            to={to}
+          />
+        );
       }}
     </RouterContext.Consumer>
   );
diff --git a/packages/react-router/modules/Route.js b/packages/react-router/modules/Route.js
index 5a7214626..7a2d044ca 100644
--- a/packages/react-router/modules/Route.js
+++ b/packages/react-router/modules/Route.js
@@ -80,7 +80,7 @@ class Route extends React.Component {
   }
 }
 
-// TODO: Remove this
+// TODO: Remove this in v5
 if (!React.createContext) {
   Route.contextTypes = {
     router: PropTypes.object.isRequired
diff --git a/packages/react-router/modules/Router.js b/packages/react-router/modules/Router.js
index df2a9dbb8..bcc6c07b0 100644
--- a/packages/react-router/modules/Router.js
+++ b/packages/react-router/modules/Router.js
@@ -29,11 +29,31 @@ class Router extends React.Component {
       location: props.history.location
     };
 
+    // This is a bit of a hack. We have to start listening for location
+    // changes here in the constructor in case there are any <Redirect>s
+    // on the initial render. If there are, they will replace/push when
+    // they mount and since cDM fires in children before parents, we may
+    // get a new location before the <Router> is mounted.
+    this._isMounted = false;
+    this._pendingLocation = null;
+
     this.unlisten = props.history.listen(location => {
-      this.setState({ location });
+      if (this._isMounted) {
+        this.setState({ location });
+      } else {
+        this._pendingLocation = location;
+      }
     });
   }
 
+  componentDidMount() {
+    this._isMounted = true;
+
+    if (this._pendingLocation) {
+      this.setState({ location: this._pendingLocation });
+    }
+  }
+
   componentWillUnmount() {
     this.unlisten();
   }
@@ -50,7 +70,7 @@ class Router extends React.Component {
   }
 }
 
-// TODO: Remove this
+// TODO: Remove this in v5
 if (!React.createContext) {
   Router.childContextTypes = {
     router: PropTypes.object.isRequired
diff --git a/packages/react-router/modules/__tests__/Switch-test.js b/packages/react-router/modules/__tests__/Switch-test.js
index 842152bee..007d6d7b7 100644
--- a/packages/react-router/modules/__tests__/Switch-test.js
+++ b/packages/react-router/modules/__tests__/Switch-test.js
@@ -4,6 +4,7 @@ import ReactDOM from "react-dom";
 import { MemoryRouter, Route, Redirect, Switch } from "react-router";
 
 import renderStrict from "./utils/renderStrict";
+import waitForRedirects from "./utils/waitForRedirects";
 
 describe("A <Switch>", () => {
   const node = document.createElement("div");
@@ -50,7 +51,7 @@ describe("A <Switch>", () => {
     expect(node.innerHTML).not.toContain("two");
   });
 
-  it("renders the first <Redirect> that matches the URL", () => {
+  it("renders the first <Redirect> that matches the URL", done => {
     renderStrict(
       <MemoryRouter initialEntries={["/three"]}>
         <Switch>
@@ -62,10 +63,13 @@ describe("A <Switch>", () => {
       node
     );
 
-    expect(node.innerHTML).toContain("two");
+    waitForRedirects(() => {
+      expect(node.innerHTML).toContain("two");
+      done();
+    });
   });
 
-  it("does not render a second <Redirect> that also matches the URL", () => {
+  it("does not render a second <Redirect> that also matches the URL", done => {
     renderStrict(
       <MemoryRouter initialEntries={["/three"]}>
         <Switch>
@@ -78,7 +82,10 @@ describe("A <Switch>", () => {
       node
     );
 
-    expect(node.innerHTML).toContain("two");
+    waitForRedirects(() => {
+      expect(node.innerHTML).toContain("two");
+      done();
+    });
   });
 
   it("renders a Route with no `path` prop", () => {
@@ -95,7 +102,7 @@ describe("A <Switch>", () => {
     expect(node.innerHTML).toContain("two");
   });
 
-  it("renders a Redirect with no `from` prop", () => {
+  it("renders a Redirect with no `from` prop", done => {
     renderStrict(
       <MemoryRouter initialEntries={["/three"]}>
         <Switch>
@@ -107,10 +114,13 @@ describe("A <Switch>", () => {
       node
     );
 
-    expect(node.innerHTML).toContain("one");
+    waitForRedirects(() => {
+      expect(node.innerHTML).toContain("one");
+      done();
+    });
   });
 
-  it("handles subsequent redirects", () => {
+  it("handles subsequent redirects", done => {
     renderStrict(
       <MemoryRouter initialEntries={["/one"]}>
         <Switch>
@@ -122,7 +132,10 @@ describe("A <Switch>", () => {
       node
     );
 
-    expect(node.innerHTML).toContain("three");
+    waitForRedirects(() => {
+      expect(node.innerHTML).toContain("three");
+      done();
+    });
   });
 
   it("handles comments", () => {
diff --git a/packages/react-router/modules/__tests__/utils/waitForRedirects.js b/packages/react-router/modules/__tests__/utils/waitForRedirects.js
new file mode 100644
index 000000000..d6b0ecf25
--- /dev/null
+++ b/packages/react-router/modules/__tests__/utils/waitForRedirects.js
@@ -0,0 +1,7 @@
+function waitForRedirects(callback) {
+  // TODO: Hook into <Redirect> so we can know when
+  // the redirect actually happens instead of guessing.
+  setTimeout(callback, 100);
+}
+
+export default waitForRedirects;
