diff --git a/packages/react-router/__tests__/greedy-matching-test.tsx b/packages/react-router/__tests__/greedy-matching-test.tsx
new file mode 100644
index 000000000..cb48052e7
--- /dev/null
+++ b/packages/react-router/__tests__/greedy-matching-test.tsx
@@ -0,0 +1,82 @@
+import * as React from "react";
+import { create as createTestRenderer } from "react-test-renderer";
+import {
+  MemoryRouter as Router,
+  Routes,
+  Route,
+  Outlet
+} from "react-router-dom";
+
+describe("greedy matching", () => {
+  let routes = (
+    <Routes>
+      <Route path="/" element={<p>Root</p>} />
+      <Route
+        path="home"
+        element={
+          <div>
+            Home Layout <Outlet />
+          </div>
+        }
+      >
+        <Route index element={<p>Home</p>} />
+        <Route path="*" element={<p>Home Not Found</p>} />
+      </Route>
+      <Route path="*" element={<p>Not Found</p>} />
+    </Routes>
+  );
+
+  it("matches the root route", () => {
+    let renderer = createTestRenderer(
+      <Router initialEntries={["/"]} children={routes} />
+    );
+
+    expect(renderer.toJSON()).toMatchInlineSnapshot(`
+      <p>
+        Root
+      </p>
+    `);
+  });
+
+  it("matches the index route", () => {
+    let renderer = createTestRenderer(
+      <Router initialEntries={["/home"]} children={routes} />
+    );
+
+    expect(renderer.toJSON()).toMatchInlineSnapshot(`
+      <div>
+        Home Layout 
+        <p>
+          Home
+        </p>
+      </div>
+    `);
+  });
+
+  it('matches the nested "not found" route', () => {
+    let renderer = createTestRenderer(
+      <Router initialEntries={["/home/typo"]} children={routes} />
+    );
+
+    expect(renderer.toJSON()).toMatchInlineSnapshot(`
+      <div>
+        Home Layout 
+        <p>
+          Home Not Found
+        </p>
+      </div>
+    `);
+  });
+
+  it('matches the "not found" route', () => {
+    let renderer = createTestRenderer(
+      <Router initialEntries={["/hometypo"]} children={routes} />
+    );
+
+    expect(renderer.toJSON()).toMatchInlineSnapshot(`
+      <p>
+        Not Found
+      </p>
+    `);
+  });
+});
diff --git a/packages/react-router/__tests__/matchPath-test.tsx b/packages/react-router/__tests__/matchPath-test.tsx
new file mode 100644
index 000000000..3f2a59caa
--- /dev/null
+++ b/packages/react-router/__tests__/matchPath-test.tsx
@@ -0,0 +1,132 @@
+import { matchPath } from "react-router";
+
+describe("matchPath", () => {
+  it("matches the root / URL", () => {
+    let match = matchPath("/", "/")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/",
+      pathnameStart: "/"
+    });
+  });
+
+  it("matches a pathname", () => {
+    let match = matchPath("users", "/users")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/users",
+      pathnameStart: "/users"
+    });
+  });
+
+  it("matches a pathname with multiple segments", () => {
+    let match = matchPath("users/mj", "/users/mj")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/users/mj",
+      pathnameStart: "/users/mj"
+    });
+  });
+
+  it("matches a pathname with a trailing slash", () => {
+    let match = matchPath("/users", "/users/")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/users/",
+      pathnameStart: "/users/"
+    });
+  });
+
+  it("matches a pathname with multiple segments and a trailing slash", () => {
+    let match = matchPath("/users/mj", "/users/mj/")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/users/mj/",
+      pathnameStart: "/users/mj/"
+    });
+  });
+
+  describe("with a / pattern and { end: false }", () => {
+    it("matches a pathname", () => {
+      let match = matchPath({ path: "/", end: false }, "/users")!;
+      expect(match).not.toBeNull();
+      expect(match).toMatchObject({
+        pathname: "/",
+        pathnameStart: "/"
+      });
+    });
+
+    it("matches a pathname with multiple segments", () => {
+      let match = matchPath({ path: "/", end: false }, "/users/mj")!;
+      expect(match).not.toBeNull();
+      expect(match).toMatchObject({
+        pathname: "/",
+        pathnameStart: "/"
+      });
+    });
+
+    it("matches a pathname with a trailing slash", () => {
+      let match = matchPath({ path: "/", end: false }, "/users/")!;
+      expect(match).not.toBeNull();
+      expect(match).toMatchObject({
+        pathname: "/",
+        pathnameStart: "/"
+      });
+    });
+
+    it("matches a pathname with multiple segments and a trailing slash", () => {
+      let match = matchPath({ path: "/", end: false }, "/users/mj/")!;
+      expect(match).not.toBeNull();
+      expect(match).toMatchObject({
+        pathname: "/",
+        pathnameStart: "/"
+      });
+    });
+  });
+
+  it("is not case-sensitive by default", () => {
+    let match = matchPath({ path: "/SystemDashboard" }, "/systemdashboard")!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/systemdashboard",
+      pathnameStart: "/systemdashboard"
+    });
+  });
+
+  it("matches a case-sensitive pathname", () => {
+    let match = matchPath(
+      { path: "/SystemDashboard", caseSensitive: true },
+      "/SystemDashboard"
+    )!;
+    expect(match).not.toBeNull();
+    expect(match).toMatchObject({
+      pathname: "/SystemDashboard",
+      pathnameStart: "/SystemDashboard"
+    });
+  });
+
+  it("does not match a case-sensitive pathname with the wrong case", () => {
+    let match = matchPath(
+      { path: "/SystemDashboard", caseSensitive: true },
+      "/systemDashboard"
+    );
+    expect(match).toBeNull();
+  });
+
+  describe("when the pattern has a trailing *", () => {
+    it("matches the remaining portion of the pathname", () => {
+      let match = matchPath("/files/*", "/files/mj.jpg")!;
+      expect(match).not.toBeNull();
+      expect(match).toMatchObject({
+        params: { "*": "mj.jpg" },
+        pathname: "/files/mj.jpg",
+        pathnameStart: "/files"
+      });
+    });
+
+    it("matches only after a slash", () => {
+      let match = matchPath("/files/*", "/filestypo");
+      expect(match).toBeNull();
+    });
+  });
+});
diff --git a/packages/react-router/__tests__/matchRoutes-test.tsx b/packages/react-router/__tests__/matchRoutes-test.tsx
index 64256a204..1e8cf2157 100644
--- a/packages/react-router/__tests__/matchRoutes-test.tsx
+++ b/packages/react-router/__tests__/matchRoutes-test.tsx
@@ -42,6 +42,7 @@ describe("matchRoutes", () => {
 
   it("matches root * routes correctly", () => {
     expect(pickPaths(routes, "/not-found")).toEqual(["*"]);
+    expect(pickPaths(routes, "/hometypo")).toEqual(["*"]);
   });
 
   it("matches index routes correctly", () => {
diff --git a/packages/react-router/__tests__/nested-params-test.tsx b/packages/react-router/__tests__/nested-params-test.tsx
deleted file mode 100644
index 6849b9268..000000000
--- a/packages/react-router/__tests__/nested-params-test.tsx
+++ /dev/null
@@ -1,86 +0,0 @@
-import * as React from "react";
-import * as ReactDOM from "react-dom";
-import { act } from "react-dom/test-utils";
-import {
-  MemoryRouter as Router,
-  Outlet,
-  Routes,
-  Route,
-  useParams
-} from "react-router";
-
-describe("nested routes", () => {
-  let node: HTMLDivElement;
-  beforeEach(() => {
-    node = document.createElement("div");
-    document.body.appendChild(node);
-  });
-
-  afterEach(() => {
-    document.body.removeChild(node);
-    node = null!;
-  });
-
-  it("gets all params from parent routes", () => {
-    function Users() {
-      return (
-        <div>
-          <h1>Users</h1>
-          <Outlet />
-        </div>
-      );
-    }
-
-    function User() {
-      let { username } = useParams();
-      return (
-        <div>
-          <h1>User: {username}</h1>
-          <Routes>
-            <Route path="courses" element={<Courses />}>
-              <Route path=":courseId" element={<Course />} />
-            </Route>
-          </Routes>
-        </div>
-      );
-    }
-
-    function Courses() {
-      return (
-        <div>
-          <h1>Courses</h1>
-          <Outlet />
-        </div>
-      );
-    }
-
-    function Course() {
-      // We should be able to access the username param here even though it was
-      // defined in a parent route from another set of <Routes>
-      let { username, courseId } = useParams();
-      return (
-        <div>
-          <h1 id="course">
-            User: {username}, course {courseId}
-          </h1>
-        </div>
-      );
-    }
-
-    act(() => {
-      ReactDOM.render(
-        <Router initialEntries={["/users/michael/courses/routing"]}>
-          <Routes>
-            <Route path="users" element={<Users />}>
-              <Route path=":username/*" element={<User />} />
-            </Route>
-          </Routes>
-        </Router>,
-        node
-      );
-    });
-
-    let elem = document.querySelector<HTMLHeadingElement>("#course")!;
-    expect(elem.innerHTML).toBe("User: michael, course routing");
-  });
-});
diff --git a/packages/react-router/__tests__/path-matching-test.tsx b/packages/react-router/__tests__/path-matching-test.tsx
index c6642f648..484639f95 100644
--- a/packages/react-router/__tests__/path-matching-test.tsx
+++ b/packages/react-router/__tests__/path-matching-test.tsx
@@ -160,11 +160,11 @@ describe("path matching with a basename", () => {
     expect(matches).toMatchObject([
       {
         pathname: "/users/michael",
-        params: { userId: "michael" }
+        params: { userId: "michael", courseId: "react" }
       },
       {
         pathname: "/users/michael/subjects",
-        params: { userId: "michael" }
+        params: { userId: "michael", courseId: "react" }
       },
       {
         pathname: "/users/michael/subjects/react",
@@ -177,19 +177,21 @@ describe("path matching with a basename", () => {
 describe("path matching with splats", () => {
   describe("splat after /", () => {
     let routes = [{ path: "users/:id/files/*" }];
-    let match = matchRoutes(routes, "/users/mj/files/secrets.md");
 
     it("finds the correct match", () => {
+      let match = matchRoutes(routes, "/users/mj/files/secrets.txt")!;
+
       expect(match).not.toBeNull();
-      expect(match?.[0]).toMatchObject({
-        pathname: "/users/mj/files",
-        params: { id: "mj", "*": "secrets.md" }
+      expect(match[0]).toMatchObject({
+        params: { id: "mj", "*": "secrets.txt" },
+        pathname: "/users/mj/files/secrets.txt",
+        pathnameStart: "/users/mj/files"
       });
     });
 
     describe("when other characters come before the /", () => {
       it("does not find a match", () => {
-        let match = matchRoutes(routes, "/users/mj/filesssss/secrets.md");
+        let match = matchRoutes(routes, "/users/mj/filesssss/secrets.txt");
         expect(match).toBeNull();
       });
     });
@@ -197,29 +199,28 @@ describe("path matching with splats", () => {
 
   test("splat after something other than /", () => {
     let routes = [{ path: "users/:id/files-*" }];
-    let match = matchRoutes(routes, "/users/mj/files-secrets.md");
+    let match = matchRoutes(routes, "/users/mj/files-secrets.txt");
 
-    expect(match).not.toBeNull();
-    expect(match?.[0]).toMatchObject({
-      pathname: "/users/mj/files-",
-      params: { id: "mj", "*": "secrets.md" }
-    });
+    // TODO: Maybe throw an error if the path ends with * but not /*?
+    expect(match).toBeNull();
   });
 
   test("parent route with splat after /", () => {
     let routes = [
-      { path: "users/:id/files/*", children: [{ path: "secrets.md" }] }
+      { path: "users/:id/files/*", children: [{ path: "secrets.txt" }] }
     ];
-    let match = matchRoutes(routes, "/users/mj/files/secrets.md");
+    let match = matchRoutes(routes, "/users/mj/files/secrets.txt")!;
 
     expect(match).not.toBeNull();
-    expect(match?.[0]).toMatchObject({
-      pathname: "/users/mj/files",
-      params: { id: "mj", "*": "secrets.md" }
+    expect(match[0]).toMatchObject({
+      params: { id: "mj", "*": "secrets.txt" },
+      pathname: "/users/mj/files/secrets.txt",
+      pathnameStart: "/users/mj/files"
     });
-    expect(match?.[1]).toMatchObject({
-      pathname: "/users/mj/files/secrets.md",
-      params: { id: "mj" }
+    expect(match[1]).toMatchObject({
+      params: { id: "mj", "*": "secrets.txt" },
+      pathname: "/users/mj/files/secrets.txt",
+      pathnameStart: "/users/mj/files/secrets.txt"
     });
   });
 
@@ -227,20 +228,23 @@ describe("path matching with splats", () => {
     let routes = [
       { path: "*", children: [{ path: "*", children: [{ path: "*" }] }] }
     ];
-    let match = matchRoutes(routes, "/one/two/three");
+    let match = matchRoutes(routes, "/one/two/three")!;
 
     expect(match).not.toBeNull();
-    expect(match?.[0]).toMatchObject({
-      pathname: "/",
-      params: { "*": "/one/two/three" }
+    expect(match[0]).toMatchObject({
+      params: { "*": "one/two/three" },
+      pathname: "/one/two/three",
+      pathnameStart: "/"
     });
-    expect(match?.[1]).toMatchObject({
-      pathname: "/",
-      params: { "*": "/one/two/three" }
+    expect(match[1]).toMatchObject({
+      params: { "*": "one/two/three" },
+      pathname: "/one/two/three",
+      pathnameStart: "/"
     });
-    expect(match?.[2]).toMatchObject({
-      pathname: "/",
-      params: { "*": "/one/two/three" }
+    expect(match[2]).toMatchObject({
+      params: { "*": "one/two/three" },
+      pathname: "/one/two/three",
+      pathnameStart: "/"
     });
   });
 });
diff --git a/packages/react-router/__tests__/useMatch-test.tsx b/packages/react-router/__tests__/useMatch-test.tsx
index d7e8941af..b3dac2339 100644
--- a/packages/react-router/__tests__/useMatch-test.tsx
+++ b/packages/react-router/__tests__/useMatch-test.tsx
@@ -50,7 +50,7 @@ describe("useMatch", () => {
 
       expect(match).toMatchObject({
         params: {},
-        pathname: "/home",
+        pathname: "/home/",
         pattern: { path: "home" }
       });
     });
diff --git a/packages/react-router/__tests__/useResolvedPath-test.tsx b/packages/react-router/__tests__/useResolvedPath-test.tsx
index eacf4d5e1..06973b2e2 100644
--- a/packages/react-router/__tests__/useResolvedPath-test.tsx
+++ b/packages/react-router/__tests__/useResolvedPath-test.tsx
@@ -9,6 +9,30 @@ import {
 import type { Path } from "history";
 
 describe("useResolvedPath", () => {
+  it("resolves . to the route path inside a * route", () => {
+    let path!: Path;
+    function ResolvePath({ path: pathProp }: { path: string }) {
+      path = useResolvedPath(pathProp);
+      return null;
+    }
+
+    createTestRenderer(
+      <Router initialEntries={["/users/mj"]}>
+        <Routes>
+          <Route path="/users">
+            <Route path="*" element={<ResolvePath path="." />} />
+          </Route>
+        </Routes>
+      </Router>
+    );
+
+    expect(path).toMatchObject({
+      pathname: "/users/mj",
+      search: "",
+      hash: ""
+    });
+  });
+
   it("path string resolves to Path object", () => {
     let path!: Path;
     function ResolvePath({ path: pathProp }: { path: string }) {
diff --git a/packages/react-router/index.tsx b/packages/react-router/index.tsx
index 2ec00385c..1546b9409 100644
--- a/packages/react-router/index.tsx
+++ b/packages/react-router/index.tsx
@@ -12,9 +12,9 @@ import type {
   Transition
 } from "history";
 
-type Mutable<T> = {
-  -readonly [P in keyof T]: T[P];
-};
+// type Mutable<T> = {
+//   -readonly [P in keyof T]: T[P];
+// };
 
 function invariant(cond: any, message: string): asserts cond {
   if (!cond) throw new Error(message);
@@ -80,18 +80,20 @@ if (__DEV__) {
 }
 
 const RouteContext = React.createContext<RouteContextObject>({
+  basename: "/",
   outlet: null,
   params: {},
-  pathname: "",
-  basename: "",
+  pathname: "/",
+  pathnameStart: "/",
   route: null
 });
 
 interface RouteContextObject<ParamKey extends string = string> {
+  basename: string;
   outlet: React.ReactElement | null;
   params: Readonly<Params<ParamKey>>;
   pathname: string;
-  basename: string; // TODO: this shouldn't need to live in route context. it should live higher up in a <Routes> context
+  pathnameStart: string;
   route: RouteObject | null;
 }
 
@@ -260,7 +262,7 @@ interface PartialLocation<S extends State = State>
 export interface RoutesProps {
   basename?: string;
   children?: React.ReactNode;
-  location?: PartialLocation;
+  location?: PartialLocation | string;
 }
 
 /**
@@ -270,7 +272,7 @@ export interface RoutesProps {
  * @see https://reactrouter.com/api/Routes
  */
 export function Routes({
-  basename = "",
+  basename,
   children,
   location
 }: RoutesProps): React.ReactElement | null {
@@ -518,11 +520,11 @@ export function useResolvedPath(to: To): Path {
 export function useRoutes(
   routes: RouteObject[],
   {
-    basename = "",
+    basename: basenameArg = "/",
     location: locationArg
   }: {
     basename?: string;
-    location?: PartialLocation;
+    location?: PartialLocation | string;
   } = {}
 ): React.ReactElement | null {
   invariant(
@@ -533,11 +535,21 @@ export function useRoutes(
   );
 
   let {
-    route: parentRoute,
+    basename: parentBasename,
     pathname: parentPathname,
-    params: parentParams
+    pathnameStart: parentPathnameStart,
+    route: parentRoute
   } = React.useContext(RouteContext);
 
+  invariant(
+    !parentRoute || basenameArg === "/",
+    `You cannot use a \`basename\` on a descendant <Routes> element ` +
+      `or \`useRoutes()\`. Please remove the \`basename\` prop from ` +
+      `<Routes basename="${basenameArg}">.`
+  );
+
+  let basename = parentRoute ? parentBasename : normalizePathname(basenameArg);
+
   if (__DEV__) {
     // You won't get a warning about 2 different <Routes> under a <Route>
     // without a trailing *, but this is a best-effort warning anyway since we
@@ -574,35 +586,30 @@ export function useRoutes(
   }
 
   let locationFromContext = useLocation();
-  let location = locationArg ?? locationFromContext;
+  let location = locationArg
+    ? typeof locationArg === "string"
+      ? parsePath(locationArg)
+      : locationArg
+    : locationFromContext;
 
-  let basenameForMatching = basename
-    ? joinPaths([parentPathname, basename])
-    : parentPathname;
-
-  let matches = React.useMemo(
-    () => matchRoutes(routes, location, basenameForMatching),
-    [routes, location, basenameForMatching]
-  );
+  let basenameForMatching = joinPaths([basename, parentPathnameStart]);
+  let matches = matchRoutes(routes, location, basenameForMatching);
 
   if (!matches) {
-    // TODO: Warn about nothing matching, suggest using a catch-all route.
+    // No routes match the location.
     return null;
   }
 
-  // Otherwise render an element.
-  let params: Params = Object.assign({}, parentParams);
   let element = matches.reduceRight((outlet, match) => {
-    Object.assign(params, match.params);
-
     return (
       <RouteContext.Provider
         children={match.route.element || <Outlet />}
         value={{
-          outlet,
-          params: params,
-          pathname: joinPaths([basenameForMatching, match.pathname]),
           basename,
+          outlet,
+          params: match.params,
+          pathname: joinPaths([parentPathnameStart, match.pathname]),
+          pathnameStart: match.pathnameStart,
           route: match.route
         }}
       />
@@ -708,6 +715,11 @@ export interface RouteMatch<ParamKey extends string = string> {
    * The portion of the URL pathname that was matched.
    */
   pathname: string;
+  /**
+   * The portion of the URL pathname that was matched before child routes will
+   * match.
+   */
+  pathnameStart: string;
   /**
    * The route object that was used to match.
    */
@@ -722,31 +734,37 @@ export interface RouteMatch<ParamKey extends string = string> {
 export function matchRoutes(
   routes: RouteObject[],
   location: Partial<Location> | string,
-  basename = ""
+  basenameArg: string = "/"
 ): RouteMatch[] | null {
   if (typeof location === "string") {
     location = parsePath(location);
   }
 
+  let basename = normalizePathname(basenameArg);
   let pathname = location.pathname || "/";
-  if (basename) {
-    let base = basename.replace(/^\/*/, "/").replace(/\/+$/, "");
 
-    // Basename should be case-insensitive
-    // https://github.com/remix-run/react-router/issues/7997#issuecomment-911916907
-    if (!pathname.toLowerCase().startsWith(base.toLowerCase())) {
+  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
+    // URL pathname does not start with the basename.
+    return null;
+  }
+
+  if (basename !== "/") {
+    let nextChar = pathname.charAt(basename.length);
+    if (nextChar && nextChar !== "/") {
+      // URL pathname does not start with basename/.
       return null;
     }
-
-    pathname = pathname.slice(base.length) || "/";
   }
 
+  let remainingPathname =
+    basename === "/" ? pathname : pathname.slice(basename.length) || "/";
+
   let branches = flattenRoutes(routes);
   rankRouteBranches(branches);
 
   let matches = null;
   for (let i = 0; matches == null && i < branches.length; ++i) {
-    matches = matchRouteBranch(branches[i], pathname, routes);
+    matches = matchRouteBranch(branches[i], routes, remainingPathname);
   }
 
   return matches;
@@ -866,15 +884,14 @@ function compareIndexes(a: number[], b: number[]): number {
 
 function matchRouteBranch<ParamKey extends string = string>(
   branch: RouteBranch,
-  pathname: string,
-  originalRoutes: RouteObject[]
+  routesArg: RouteObject[],
+  pathname: string
 ): RouteMatch<ParamKey>[] | null {
-  let matchedPathname = "/";
-  let matchedParams = {} as Params<ParamKey>;
-
+  let routes = routesArg;
   let { routesMeta } = branch;
-  let routes = originalRoutes;
 
+  let matchedParams = {};
+  let matchedPathname = "/";
   let matches: RouteMatch[] = [];
   for (let i = 0; i < routesMeta.length; ++i) {
     let meta = routesMeta[i];
@@ -893,17 +910,25 @@ function matchRouteBranch<ParamKey extends string = string>(
 
     if (!match) return null;
 
-    matchedParams = { ...matchedParams, ...match.params };
-    matchedPathname = joinPaths([matchedPathname, match.pathname]);
+    Object.assign(matchedParams, match.params);
 
     let route = routes[meta.childrenIndex];
-
-    matches.push({
+    let routeMatch = {
       params: matchedParams,
-      pathname: matchedPathname,
+      pathname:
+        match.pathname === "/"
+          ? matchedPathname
+          : joinPaths([matchedPathname, match.pathname]),
+      pathnameStart:
+        match.pathnameStart === "/"
+          ? matchedPathname
+          : joinPaths([matchedPathname, match.pathnameStart]),
       route
-    });
+    };
+
+    matches.push(routeMatch);
 
+    matchedPathname = routeMatch.pathnameStart;
     routes = route.children!;
   }
 
@@ -943,6 +968,11 @@ export interface PathMatch<ParamKey extends string = string> {
    * The portion of the URL pathname that was matched.
    */
   pathname: string;
+  /**
+   * The portion of the URL pathname that was matched before child routes will
+   * match.
+   */
+  pathnameStart: string;
   /**
    * The pattern that was used to match.
    */
@@ -963,66 +993,89 @@ export function matchPath<ParamKey extends string = string>(
     pattern = { path: pattern, caseSensitive: false, end: true };
   }
 
-  let [matcher, paramNames] = compilePath(
-    pattern.path,
-    pattern.caseSensitive,
-    pattern.end
-  );
-  let match = pathname.match(matcher);
+  let { path: pathArg, caseSensitive = false, end = true } = pattern;
+  let path = normalizePathname(pathArg);
 
-  if (!match) return null;
+  if (path === "/") {
+    return !end || pathname === "/"
+      ? {
+          params: {} as Params,
+          pathname: "/",
+          pathnameStart: "/",
+          pattern
+        }
+      : null;
+  }
 
-  let matchedPathname = match[1];
-  let values = match.slice(2);
-  let params: Params = paramNames.reduce<Mutable<Params>>(
-    (memo, paramName, index) => {
-      memo[paramName] = safelyDecodeURIComponent(
-        values[index] || "",
-        paramName
-      );
-      return memo;
-    },
-    {}
-  );
+  let needsTrailingSlash = false;
+  if (pathname !== "/" && pathname.endsWith("/")) {
+    needsTrailingSlash = true;
+    pathname = pathname.slice(0, -1);
+  }
 
-  return { params, pathname: matchedPathname, pattern };
-}
+  let matchers = path.split("/");
+  let segments = pathname.split("/");
+
+  let matchedSegments: string[] = [];
+  let matchedParams: any = {};
 
-function compilePath(
-  path: string,
-  caseSensitive = false,
-  end = true
-): [RegExp, string[]] {
-  let keys: string[] = [];
-  let source =
-    "^(" +
-    path
-      .replace(/^\/*/, "/") // Make sure it has a leading /
-      .replace(/\/?\*?$/, "") // Ignore trailing / and /*, we'll handle it below
-      .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
-      .replace(/:(\w+)/g, (_: string, key: string) => {
-        keys.push(key);
-        return "([^\\/]+)";
-      }) +
-    ")";
-
-  if (path.endsWith("*")) {
-    if (path.endsWith("/*")) {
-      source += "(?:\\/(.+)|\\/?)"; // Don't include the / in params['*']
-    } else {
-      source += "(.*)";
+  if (segments.length > matchers.length && end && !path.endsWith("*")) {
+    // URL pathname is longer than pattern with no trailing *. No match.
+    return null;
+  }
+
+  for (let i = 0; i < matchers.length; ++i) {
+    let matcher = matchers[i];
+    let segment = segments[i];
+
+    if (segment == null) return null;
+
+    if (matcher === "*") {
+      let pathnameStart = segments.slice(0, i).join("/") || "/";
+      matchedParams["*"] = segments.slice(i).join("/");
+      return {
+        params: matchedParams,
+        pathname,
+        pathnameStart,
+        pattern
+      };
+    }
+
+    if (matcher.startsWith(":")) {
+      if (segment === "") return null;
+      let paramName = matcher.slice(1);
+      matchedParams[paramName] = safelyDecodeURIComponent(segment, paramName);
+      matchedSegments.push(segment);
+      continue;
+    }
+
+    if (
+      matcher === segment ||
+      (!caseSensitive && matcher.toLowerCase() === segment.toLowerCase())
+    ) {
+      matchedSegments.push(segment);
+      continue;
     }
-    keys.push("*");
-  } else if (end) {
-    source += "\\/?";
+
+    return null;
   }
 
-  if (end) source += "$";
+  if (end && matchedSegments.length !== segments.length) {
+    return null;
+  }
 
-  let flags = caseSensitive ? undefined : "i";
-  let matcher = new RegExp(source, flags);
+  if (needsTrailingSlash) {
+    matchedSegments.push("");
+  }
+
+  let matchedPathname = matchedSegments.join("/") || "/";
 
-  return [matcher, keys];
+  return {
+    params: matchedParams,
+    pathname: matchedPathname,
+    pathnameStart: matchedPathname,
+    pattern
+  };
 }
 
 function safelyDecodeURIComponent(value: string, paramName: string) {
@@ -1045,21 +1098,24 @@ function safelyDecodeURIComponent(value: string, paramName: string) {
  *
  * @see https://reactrouter.com/api/resolvePath
  */
-export function resolvePath(to: To, fromPathname = "/", basename = ""): Path {
+export function resolvePath(
+  to: To,
+  fromPathname = "/",
+  basenameArg = "/"
+): Path {
   let {
     pathname: toPathname,
     search = "",
     hash = ""
   } = typeof to === "string" ? parsePath(to) : to;
+  let basename = normalizePathname(basenameArg);
 
   let pathname = toPathname
     ? resolvePathname(
         toPathname,
         toPathname.startsWith("/")
           ? basename
-            ? normalizeSlashes(`/${basename}`)
-            : "/"
-          : fromPathname
+          : joinPaths([basename, fromPathname])
       )
     : fromPathname;
 
@@ -1070,22 +1126,9 @@ export function resolvePath(to: To, fromPathname = "/", basename = ""): Path {
   };
 }
 
-const trimTrailingSlashes = (path: string) => path.replace(/\/+$/, "");
-const normalizeSlashes = (path: string) => path.replace(/\/\/+/g, "/");
-const joinPaths = (paths: string[]) => normalizeSlashes(paths.join("/"));
-const splitPath = (path: string) => normalizeSlashes(path).split("/");
-const normalizeSearch = (search: string) =>
-  !search || search === "?"
-    ? ""
-    : search.startsWith("?")
-    ? search
-    : "?" + search;
-const normalizeHash = (hash: string) =>
-  !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
-
 function resolvePathname(toPathname: string, fromPathname: string): string {
-  let segments = splitPath(trimTrailingSlashes(fromPathname));
-  let relativeSegments = splitPath(toPathname);
+  let segments = fromPathname.replace(/\/+$/, "").split("/");
+  let relativeSegments = toPathname.split("/");
 
   relativeSegments.forEach(segment => {
     if (segment === "..") {
@@ -1099,6 +1142,22 @@ function resolvePathname(toPathname: string, fromPathname: string): string {
   return segments.length > 1 ? joinPaths(segments) : "/";
 }
 
+const joinPaths = (paths: string[]): string =>
+  paths.join("/").replace(/\/\/+/g, "/");
+
+const normalizePathname = (pathname: string): string =>
+  pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
+
+const normalizeSearch = (search: string): string =>
+  !search || search === "?"
+    ? ""
+    : search.startsWith("?")
+    ? search
+    : "?" + search;
+
+const normalizeHash = (hash: string): string =>
+  !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
+
 ///////////////////////////////////////////////////////////////////////////////
 // DANGER! PLEASE READ ME!
 // We provide these exports as an escape hatch in the event that you need any
