diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeDeserializer.java
deleted file mode 100644
index f07523353..000000000
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeDeserializer.java
+++ /dev/null
@@ -1,156 +0,0 @@
-package com.fasterxml.jackson.databind.jsontype.impl;
-
-import java.io.IOException;
-
-import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
-import com.fasterxml.jackson.core.*;
-import com.fasterxml.jackson.core.util.JsonParserSequence;
-import com.fasterxml.jackson.databind.*;
-import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
-import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
-import com.fasterxml.jackson.databind.util.TokenBuffer;
-
-/**
- * Type deserializer used with {@link As#EXISTING_PROPERTY}
- * inclusion mechanism.
- * 
- * @author fleeman (modeled after code by tatus)
- */
-public class AsExistingPropertyTypeDeserializer extends AsArrayTypeDeserializer
-{
-    private static final long serialVersionUID = 1L;
-
-    public AsExistingPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,
-            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)
-    {
-        super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);
-    }
-
-    public AsExistingPropertyTypeDeserializer(AsExistingPropertyTypeDeserializer src, BeanProperty property) {
-        super(src, property);
-    }
-    
-    @Override
-    public TypeDeserializer forProperty(BeanProperty prop) {
-        return (prop == _property) ? this : new AsExistingPropertyTypeDeserializer(this, prop);
-    }
-    
-    @Override
-    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }
-
-    /**
-     * This is the trickiest thing to handle, since property we are looking
-     * for may be anywhere...
-     */
-    @Override
-    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
-    {
-        // 02-Aug-2013, tatu: May need to use native type ids
-        if (jp.canReadTypeId()) {
-            Object typeId = jp.getTypeId();
-            if (typeId != null) {
-                return _deserializeWithNativeTypeId(jp, ctxt, typeId);
-            }
-        }
-        
-        // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME
-        JsonToken t = jp.getCurrentToken();
-        if (t == JsonToken.START_OBJECT) {
-            t = jp.nextToken();
-        } else if (t == JsonToken.START_ARRAY) {
-            /* This is most likely due to the fact that not all Java types are
-             * serialized as JSON Objects; so if "as-property" inclusion is requested,
-             * serialization of things like Lists must be instead handled as if
-             * "as-wrapper-array" was requested.
-             * But this can also be due to some custom handling: so, if "defaultImpl"
-             * is defined, it will be asked to handle this case.
-             */
-            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
-        } else if (t != JsonToken.FIELD_NAME) {
-            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
-        }
-        // Ok, let's try to find the property. But first, need token buffer...
-        TokenBuffer tb = null;
-
-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {
-            String name = jp.getCurrentName();
-            jp.nextToken(); // to point to the value
-            if (_typePropertyName.equals(name)) { // gotcha!
-                return _deserializeTypedForId(jp, ctxt, tb);
-            }
-            if (tb == null) {
-                tb = new TokenBuffer(null, false);
-            }
-            tb.writeFieldName(name);
-            tb.copyCurrentStructure(jp);
-        }
-        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);
-    }
-
-    @SuppressWarnings("resource")
-    protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
-    {
-        String typeId = jp.getText();
-        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
-        if (_typeIdVisible) { // need to merge id back in JSON input?
-            if (tb == null) {
-                tb = new TokenBuffer(null, false);
-            }
-            tb.writeFieldName(jp.getCurrentName());
-            tb.writeString(typeId);
-        }
-        if (tb != null) { // need to put back skipped properties?
-            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);
-        }
-        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:
-        jp.nextToken(); // to skip past String value
-        // deserializer should take care of closing END_OBJECT as well
-        return deser.deserialize(jp, ctxt);
-    }
-    
-    // off-lined to keep main method lean and mean...
-    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
-    {
-        // As per [JACKSON-614], may have default implementation to use
-        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);
-        if (deser != null) {
-            if (tb != null) {
-                tb.writeEndObject();
-                jp = tb.asParser(jp);
-                // must move to point to the first token:
-                jp.nextToken();
-            }
-            return deser.deserialize(jp, ctxt);
-        }
-        // or, perhaps we just bumped into a "natural" value (boolean/int/double/String)?
-        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);
-        if (result != null) {
-            return result;
-        }
-        // or, something for which "as-property" won't work, changed into "wrapper-array" type:
-        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
-            return super.deserializeTypedFromAny(jp, ctxt);
-        }
-        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,
-                "missing property '"+_typePropertyName+"' that is to contain type id  (for class "+baseTypeName()+")");
-    }
-
-    /* As per [JACKSON-352], also need to re-route "unknown" version. Need to think
-     * this through bit more in future, but for now this does address issue and has
-     * no negative side effects (at least within existing unit test suite).
-     */
-    @Override
-    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {
-        /* [JACKSON-387]: Sometimes, however, we get an array wrapper; specifically
-         *   when an array or list has been serialized with type information.
-         */
-        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
-            return super.deserializeTypedFromArray(jp, ctxt);
-        }
-        return deserializeTypedFromObject(jp, ctxt);
-    }    
-    
-    // These are fine from base class:
-    //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)
-    //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    
-}
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java
index b669106d7..131191622 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java
@@ -12,20 +12,15 @@ import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
  * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.
  * Expects type information to be a well-defined property on all sub-classes.
  * 
- * 10/15/2014 - At time of commit, deserialization identical to deserializer
- * for {@link As#PROPERTY} inclusion mechanism
- * 
  * @author fleeman (modeled after code by tatus)
  */
 public class AsExistingPropertyTypeSerializer
-    extends AsArrayTypeSerializer
+    extends AsPropertyTypeSerializer
 {
-    protected final String _typePropertyName;
 
     public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)
     {
-        super(idRes, property);
-        _typePropertyName = propName;
+        super(idRes, property, propName);
     }
 
     @Override
@@ -33,9 +28,6 @@ public class AsExistingPropertyTypeSerializer
         return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);
     }
     
-    @Override
-    public String getPropertyName() { return _typePropertyName; }
-
     @Override
     public As getTypeInclusion() { return As.EXISTING_PROPERTY; }
     
@@ -63,21 +55,6 @@ public class AsExistingPropertyTypeSerializer
         }
     }
     
-    @Override
-    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException {
-        // always need to close, regardless of whether its native type id or not
-    	jgen.writeEndObject();
-    }
-
-
-    /*
-    /**********************************************************
-    /* Writing with custom type id
-    /**********************************************************
-     */
-
-    // Only need to override Object-variants
-    
     @Override
     public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException
     {
@@ -89,8 +66,4 @@ public class AsExistingPropertyTypeSerializer
         }
     }
 
-    @Override
-    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
-        jgen.writeEndObject();
-    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
index 1edadbeca..8604c543d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
@@ -120,7 +120,7 @@ public class StdTypeResolverBuilder
                     _typeProperty, _typeIdVisible, _defaultImpl);
         case EXISTING_PROPERTY:
         	// as per [#528]
-        	return new AsExistingPropertyTypeDeserializer(baseType, idRes,
+        	return new AsPropertyTypeDeserializer(baseType, idRes,
                     _typeProperty, _typeIdVisible, _defaultImpl);
         }
         throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: "+_includeAs);
