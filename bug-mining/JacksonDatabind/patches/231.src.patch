diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
index 921d67edc..9d13cd60a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
@@ -4,6 +4,7 @@ import java.util.*;
 import java.util.concurrent.atomic.AtomicReference;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
 import com.fasterxml.jackson.annotation.ObjectIdGenerator;
 import com.fasterxml.jackson.annotation.ObjectIdGenerators;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
@@ -20,8 +21,11 @@ import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;
 import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;
 import com.fasterxml.jackson.databind.ser.std.AtomicReferenceSerializer;
 import com.fasterxml.jackson.databind.ser.std.MapSerializer;
+import com.fasterxml.jackson.databind.ser.std.ReferenceTypeSerializer;
 import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;
 import com.fasterxml.jackson.databind.type.ReferenceType;
+import com.fasterxml.jackson.databind.util.ArrayBuilders;
+import com.fasterxml.jackson.databind.util.BeanUtil;
 import com.fasterxml.jackson.databind.util.ClassUtil;
 import com.fasterxml.jackson.databind.util.Converter;
 
@@ -369,6 +373,58 @@ public class BeanSerializerFactory
         return typeSer;
     }
 
+    protected ReferenceTypeSerializer<?> _checkMapContentInclusion(SerializerProvider prov,
+            BeanDescription beanDesc, ReferenceTypeSerializer<?> refSer)
+        throws JsonMappingException
+    {
+        final JavaType contentType = refSer.getReferredType();
+        JsonInclude.Value inclV = _findInclusionWithContent(prov, beanDesc,
+                contentType, Map.class);
+
+        // Need to support global legacy setting, for now:
+        JsonInclude.Include incl = (inclV == null) ? JsonInclude.Include.USE_DEFAULTS : inclV.getContentInclusion();
+        if (incl == JsonInclude.Include.USE_DEFAULTS
+                || incl == JsonInclude.Include.ALWAYS) {
+            return refSer;
+        }
+
+        // NOTE: mostly copied from `PropertyBuilder`; would be nice to refactor
+        // but code is not identical nor are these types related
+        Object valueToSuppress;
+        boolean suppressNulls = true; // almost always, but possibly not with CUSTOM
+
+        switch (incl) {
+        case NON_DEFAULT:
+            valueToSuppress = BeanUtil.getDefaultValue(contentType);
+            if (valueToSuppress != null) {
+                if (valueToSuppress.getClass().isArray()) {
+                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
+                }
+            }
+            break;
+        case NON_ABSENT:
+            valueToSuppress = contentType.isReferenceType()
+                    ? MapSerializer.MARKER_FOR_EMPTY : null;
+            break;
+        case NON_EMPTY:
+            valueToSuppress = MapSerializer.MARKER_FOR_EMPTY;
+            break;
+        case CUSTOM: // new with 2.9
+            valueToSuppress = prov.includeFilterInstance(null, inclV.getContentFilter());
+            if (valueToSuppress == null) { // is this legal?
+                suppressNulls = true;
+            } else {
+                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);
+            }
+            break;
+        case NON_NULL:
+        default: // should not matter but...
+            valueToSuppress = null;
+            break;
+        }
+        return refSer.withContentInclusion(valueToSuppress, suppressNulls);
+    }
+
     /*
     /**********************************************************
     /* Overridable non-public factory methods
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java
index 012bcc031..52d0730ac 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java
@@ -318,9 +318,9 @@ public class MapEntrySerializer
             }
         }
         if (_suppressableValue == MARKER_FOR_EMPTY) {
-            return !valueSer.isEmpty(prov, value);
+            return valueSer.isEmpty(prov, value);
         }
-        return !_suppressableValue.equals(value);
+        return _suppressableValue.equals(value);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java
index 7726bb0e9..f7ad12b83 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java
@@ -2,8 +2,6 @@ package com.fasterxml.jackson.databind.ser.std;
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import com.fasterxml.jackson.annotation.JsonInclude;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
 import com.fasterxml.jackson.databind.type.ReferenceType;
@@ -29,23 +27,37 @@ public class AtomicReferenceSerializer
     protected AtomicReferenceSerializer(AtomicReferenceSerializer base, BeanProperty property,
             TypeSerializer vts, JsonSerializer<?> valueSer,
             NameTransformer unwrapper,
-            JsonInclude.Include contentIncl)
+            Object suppressableValue, boolean suppressNull)
     {
-        super(base, property, vts, valueSer, unwrapper, contentIncl);
+        super(base, property, vts, valueSer, unwrapper,
+                suppressableValue, suppressNull);
     }
 
     @Override
-    protected AtomicReferenceSerializer withResolved(BeanProperty prop,
+    protected ReferenceTypeSerializer<AtomicReference<?>> withResolved(BeanProperty prop,
             TypeSerializer vts, JsonSerializer<?> valueSer,
-            NameTransformer unwrapper,
-            JsonInclude.Include contentIncl)
+            NameTransformer unwrapper)
     {
-        if ((_property == prop) && (contentIncl == _contentInclusion)
+        if ((_property == prop)
                 && (_valueTypeSerializer == vts) && (_valueSerializer == valueSer)
                 && (_unwrapper == unwrapper)) {
             return this;
         }
-        return new AtomicReferenceSerializer(this, prop, vts, valueSer, unwrapper, contentIncl);
+        return new AtomicReferenceSerializer(this, prop, vts, valueSer, unwrapper,
+                _suppressableValue, _suppressNulls);
+    }
+
+    @Override
+    public ReferenceTypeSerializer<AtomicReference<?>> withContentInclusion(Object suppressableValue,
+            boolean suppressNulls)
+    {
+        if ((_suppressableValue == suppressableValue)
+                && (_suppressNulls == suppressNulls)) {
+            return this;
+        }
+        return new AtomicReferenceSerializer(this, _property, _valueTypeSerializer,
+                _valueSerializer, _unwrapper,
+                _suppressableValue, _suppressNulls);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
index fe0be6d63..14665014f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
@@ -538,7 +538,6 @@ public class MapSerializer
         // 05-Nove-2015, tatu: Simple cases are cheap, but for recursive
         //   emptiness checking we actually need to see if values are empty as well.
         Object supp = _suppressableValue;
-
         if ((supp == null) && !_suppressNulls) {
             return false;
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
index 64aefbcc7..6aca3ef06 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
@@ -12,6 +12,8 @@ import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
 import com.fasterxml.jackson.databind.ser.ContextualSerializer;
 import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;
 import com.fasterxml.jackson.databind.type.ReferenceType;
+import com.fasterxml.jackson.databind.util.ArrayBuilders;
+import com.fasterxml.jackson.databind.util.BeanUtil;
 import com.fasterxml.jackson.databind.util.NameTransformer;
 
 /**
@@ -27,6 +29,11 @@ public abstract class ReferenceTypeSerializer<T>
 {
     private static final long serialVersionUID = 1L;
 
+    /**
+     * @since 2.9
+     */
+    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;
+    
     /**
      * Value type
      */
@@ -49,18 +56,38 @@ public abstract class ReferenceTypeSerializer<T>
      */
     protected final NameTransformer _unwrapper;
 
-    /**
-     * Further guidance on serialization-inclusion (or not), regarding
-     * contained value (if any).
-     */
-    protected final JsonInclude.Include _contentInclusion;
-    
     /**
      * If element type can not be statically determined, mapping from
      * runtime type to serializer is handled using this object
      */
     protected transient PropertySerializerMap _dynamicSerializers;
 
+    /*
+    /**********************************************************
+    /* Config settings, filtering
+    /**********************************************************
+     */
+
+    /**
+     * Value that indicates suppression mechanism to use for <b>values contained</b>;
+     * either "filter" (of which <code>equals()</code> is called), or marker
+     * value of {@link #MARKER_FOR_EMPTY}, or null to indicate no filtering for
+     * non-null values.
+     * Note that inclusion value for Map instance itself is handled by caller (POJO
+     * property that refers to the Map value).
+     *
+     * @since 2.9
+     */
+    protected final Object _suppressableValue;
+
+    /**
+     * Flag that indicates what to do with `null` values, distinct from
+     * handling of {@link #_suppressableValue}
+     *
+     * @since 2.9
+     */
+    protected final boolean _suppressNulls;
+
     /*
     /**********************************************************
     /* Constructors, factory methods
@@ -76,7 +103,8 @@ public abstract class ReferenceTypeSerializer<T>
         _valueTypeSerializer = vts;
         _valueSerializer = ser;
         _unwrapper = null;
-        _contentInclusion = null;
+        _suppressableValue = null;
+        _suppressNulls = false;
         _dynamicSerializers = PropertySerializerMap.emptyForProperties();
     }
 
@@ -84,7 +112,7 @@ public abstract class ReferenceTypeSerializer<T>
     protected ReferenceTypeSerializer(ReferenceTypeSerializer<?> base, BeanProperty property,
             TypeSerializer vts, JsonSerializer<?> valueSer,
             NameTransformer unwrapper,
-            JsonInclude.Include contentIncl)
+            Object suppressableValue, boolean suppressNulls)
     {
         super(base);
         _referredType = base._referredType;
@@ -93,12 +121,8 @@ public abstract class ReferenceTypeSerializer<T>
         _valueTypeSerializer = vts;
         _valueSerializer = (JsonSerializer<Object>) valueSer;
         _unwrapper = unwrapper;
-        if ((contentIncl == JsonInclude.Include.USE_DEFAULTS)
-                || (contentIncl == JsonInclude.Include.ALWAYS)) {
-            _contentInclusion = null;
-        } else {
-            _contentInclusion = contentIncl;
-        }
+        _suppressableValue = suppressableValue;
+        _suppressNulls = suppressNulls;
     }
 
     @Override
@@ -109,7 +133,7 @@ public abstract class ReferenceTypeSerializer<T>
         }
         NameTransformer unwrapper = (_unwrapper == null) ? transformer
                 : NameTransformer.chainedTransformer(transformer, _unwrapper);
-        return withResolved(_property, _valueTypeSerializer, ser, unwrapper, _contentInclusion);
+        return withResolved(_property, _valueTypeSerializer, ser, unwrapper);
     }
 
     /*
@@ -117,11 +141,19 @@ public abstract class ReferenceTypeSerializer<T>
     /* Abstract methods to implement
     /**********************************************************
      */
-    
+
+    /**
+     * @since 2.9
+     */
     protected abstract ReferenceTypeSerializer<T> withResolved(BeanProperty prop,
             TypeSerializer vts, JsonSerializer<?> valueSer,
-            NameTransformer unwrapper,
-            JsonInclude.Include contentIncl);
+            NameTransformer unwrapper);
+
+    /**
+     * @since 2.9
+     */
+    public abstract ReferenceTypeSerializer<T> withContentInclusion(Object suppressableValue,
+            boolean suppressNulls);
 
     protected abstract boolean _isValueEmpty(T value);
 
@@ -157,14 +189,61 @@ public abstract class ReferenceTypeSerializer<T>
                 ser = provider.handlePrimaryContextualization(ser, property);
             }
         }
-        // Also: may want to have more refined exclusion based on referenced value
-        JsonInclude.Include contentIncl = _contentInclusion;
-        JsonInclude.Value incl = findIncludeOverrides(provider, property, handledType());
-        JsonInclude.Include newIncl = incl.getContentInclusion();
-        if ((newIncl != contentIncl) && (newIncl != JsonInclude.Include.USE_DEFAULTS)) {
-            contentIncl = newIncl;
+        // First, resolve wrt property, resolved serializers
+        ReferenceTypeSerializer<?> refSer = withResolved(property, typeSer, ser, _unwrapper);
+        // and then see if we have property-inclusion overrides
+        if (property != null) {
+            JsonInclude.Value inclV = property.findPropertyInclusion(provider.getConfig(), null);
+            if (inclV != null) {
+                JsonInclude.Include incl = inclV.getContentInclusion();
+
+                if (incl != JsonInclude.Include.USE_DEFAULTS) {
+                    Object valueToSuppress;
+                    boolean suppressNulls;
+                    switch (incl) {
+                    case NON_DEFAULT:
+                        valueToSuppress = BeanUtil.getDefaultValue(_referredType);
+                        suppressNulls = true;
+                        if (valueToSuppress != null) {
+                            if (valueToSuppress.getClass().isArray()) {
+                                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
+                            }
+                        }
+                        break;
+                    case NON_ABSENT:
+                        suppressNulls = true;
+                        valueToSuppress = _referredType.isReferenceType() ? MARKER_FOR_EMPTY : null;
+                        break;
+                    case NON_EMPTY:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case CUSTOM:
+                        valueToSuppress = provider.includeFilterInstance(null, inclV.getContentFilter());
+                        if (valueToSuppress == null) { // is this legal?
+                            suppressNulls = true;
+                        } else {
+                            suppressNulls = provider.includeFilterSuppressNulls(valueToSuppress);
+                        }
+                        break;
+                    case NON_NULL:
+                        valueToSuppress = null;
+                        suppressNulls = true;
+                        break;
+                    case ALWAYS: // default
+                    default:
+                        valueToSuppress = null;
+                        suppressNulls = false;
+                        break;
+                    }
+                    if ((_suppressableValue != valueToSuppress)
+                            || (_suppressNulls != suppressNulls)) {
+                        refSer = refSer.withContentInclusion(valueToSuppress, suppressNulls);
+                    }
+                }
+            }
         }
-        return withResolved(property, typeSer, ser, _unwrapper, contentIncl);
+        return refSer;
     }
 
     protected boolean _useStatic(SerializerProvider provider, BeanProperty property,
@@ -212,10 +291,13 @@ public abstract class ReferenceTypeSerializer<T>
         if ((value == null) || _isValueEmpty(value)) {
             return true;
         }
-        if (_contentInclusion == null) {
+        if ((_suppressableValue == null) && !_suppressNulls) {
             return false;
         }
-        Object contents = _getReferenced(value);
+        Object contents = _getReferencedIfPresent(value);
+        if (contents == null) {
+            return _suppressNulls;
+        }
         JsonSerializer<Object> ser = _valueSerializer;
         if (ser == null) {
             try {
@@ -224,7 +306,10 @@ public abstract class ReferenceTypeSerializer<T>
                 throw new RuntimeJsonMappingException(e);
             }
         }
-        return ser.isEmpty(provider, contents);
+        if (_suppressableValue == MARKER_FOR_EMPTY) {
+            return ser.isEmpty(provider, contents);
+        }
+        return _suppressableValue.equals(contents);
     }
 
     @Override
@@ -232,6 +317,13 @@ public abstract class ReferenceTypeSerializer<T>
         return (_unwrapper != null);
     }
 
+    /**
+     * @since 2.9
+     */
+    public JavaType getReferredType() {
+        return _referredType;
+    }
+
     /*
     /**********************************************************
     /* Serialization methods
