diff --git a/release-notes/VERSION b/release-notes/VERSION
index 4a8154dfb..bc1478a50 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -87,6 +87,8 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #4865: Add spliterator support in `JsonNode`
  (contributed by @pjfanning)
 #4875: Remove `JsonNode.fields()` from 3.0
+#4879: Rename `TextNode` as `StringNode`; `JsonNode.xxxTextYyy()` (mostly) as
+  `JsonNode.xxxStringYyy()` [JSTEP-3]
 - Remove `MappingJsonFactory`
 - Add context parameter for `TypeSerializer` contextualization (`forProperty()`)
 - Default for `JsonNodeFeature.STRIP_TRAILING_BIGDECIMAL_ZEROES` changed to `false` for 3.0
diff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java
index cc692571e..b715750c9 100644
--- a/src/main/java/tools/jackson/databind/JsonNode.java
+++ b/src/main/java/tools/jackson/databind/JsonNode.java
@@ -200,7 +200,7 @@ public abstract class JsonNode
      *   field. Null otherwise.
      */
     @Override
-    public JsonNode get(String fieldName) { return null; }
+    public JsonNode get(String propertyName) { return null; }
 
     /**
      * Method for accessing value of the specified element of
@@ -259,7 +259,7 @@ public abstract class JsonNode
      */
 
     @Override
-    public abstract JsonNode path(String fieldName);
+    public abstract JsonNode path(String propertyName);
 
     /**
      * This method is similar to {@link #get(int)}, except
@@ -424,13 +424,21 @@ public abstract class JsonNode
     public boolean isBigInteger() { return false; }
 
     /**
-     * Method that checks whether this node represents basic JSON String
+     * Method that checks whether this node represents JSON String
      * value.
      */
-    public final boolean isTextual() {
+    public final boolean isString() {
         return getNodeType() == JsonNodeType.STRING;
     }
 
+    /**
+     * @deprecated Use {@link #isString} instead.
+     */
+    @Deprecated // since 3.0
+    public boolean isTextual() {
+        return isString();
+    }
+    
     /**
      * Method that can be used to check if this node was created from
      * JSON boolean value (literals "true" and "false").
@@ -451,7 +459,7 @@ public abstract class JsonNode
     /**
      * Method that can be used to check if this node represents
      * binary data (Base64 encoded). Although this will be externally
-     * written as JSON String value, {@link #isTextual} will
+     * written as JSON String value, {@link #isString} will
      * return false if this method returns true.
      *
      * @return True if this node represents base64 encoded binary data
@@ -522,19 +530,21 @@ public abstract class JsonNode
     /**
      * Method to use for accessing String values.
      * Does <b>NOT</b> do any conversions for non-String value nodes;
-     * for non-String values (ones for which {@link #isTextual} returns
+     * for non-String values (ones for which {@link #isString} returns
      * false) null will be returned.
      * For String values, null is never returned (but empty Strings may be)
+     *<p>
+     * NOTE: in Jackson 2.x, was {@code textValue()}.
      *
-     * @return Textual value this node contains, iff it is a textual
-     *   JSON node (comes from JSON String value entry)
+     * @return String value this node contains, iff node is created from
+     *   a String value.
      */
-    public String textValue() { return null; }
+    public String stringValue() { return null; }
 
     /**
      * Method to use for accessing binary content of binary nodes (nodes
-     * for which {@link #isBinary} returns true); or for Text Nodes
-     * (ones for which {@link #textValue} returns non-null value),
+     * for which {@link #isBinary} returns true); or for String Nodes
+     * (ones for which {@link #stringValue} returns non-null value),
      * to read decoded base64 data.
      * For other types of nodes, returns null.
      *
@@ -652,11 +662,15 @@ public abstract class JsonNode
 
     /**
      * Method that will return a valid String representation of
-     * the container value, if the node is a value node
+     * the contained value, if the node is a value node
      * (method {@link #isValueNode} returns true),
      * otherwise empty String.
+     *<p>
+     * NOTE: this is NOT same as {@link #toString()} in that result is
+     * <p>NOT VALID ENCODED JSON</p> for all nodes (but is for some, like
+     * {@code NumberNode}s and {@code BooleanNode}s).
      */
-    public abstract String asText();
+    public abstract String asString();
 
     /**
      * Returns the text value of this node or the provided {@code defaultValue} if this node
@@ -666,11 +680,27 @@ public abstract class JsonNode
      * @param defaultValue The default value to return if this node's text value is absent.
      * @return The text value of this node, or {@code defaultValue} if the text value is absent.
      */
-    public String asText(String defaultValue) {
-        String str = asText();
+    public String asString(String defaultValue) {
+        String str = asString();
         return (str == null) ? defaultValue : str;
     }
 
+    /**
+     * @deprecated Use {@link #asString()} instead.
+     */
+    @Deprecated // since 3.0
+    public final String asText() {
+        return asString();
+    }
+
+    /**
+     * @deprecated Use {@link #asString(String)} instead.
+     */
+    @Deprecated // since 3.0
+    public String asText(String defaultValue) {
+        return asString(defaultValue);
+    }
+
     /**
      * Method that will try to convert value of this node to a Java <b>int</b>.
      * Numbers are coerced using default Java rules; booleans convert to 0 (false)
@@ -832,10 +862,10 @@ public abstract class JsonNode
     /**
      * Method is functionally equivalent to
      *{@code
-     *   path(fieldName).required()
+     *   path(propertyName).required()
      *}
      * and can be used to check that this node is an {@code ObjectNode} (that is, represents
-     * JSON Object value) and has value for specified property with key {@code fieldName}
+     * JSON Object value) and has value for specified property with key {@code propertyName}
      * (but note that value may be explicit JSON null value).
      * If this node is Object Node and has value for specified property, matching value
      * is returned; otherwise {@link IllegalArgumentException} is thrown.
@@ -943,20 +973,20 @@ public abstract class JsonNode
      *<p>
      * This method is equivalent to:
      *<pre>
-     *   node.get(fieldName) != null
+     *   node.get(propertyName) != null
      *</pre>
      * (since return value of get() is node, not value node contains)
      *<p>
      * NOTE: when explicit <code>null</code> values are added, this
      * method will return <code>true</code> for such properties.
      *
-     * @param fieldName Name of element to check
+     * @param propertyName Name of element to check
      *
      * @return True if this node is a JSON Object node, and has a property
      *   entry with specified name (with any value, including null value)
      */
-    public boolean has(String fieldName) {
-        return get(fieldName) != null;
+    public boolean has(String propertyName) {
+        return get(propertyName) != null;
     }
 
     /**
@@ -991,13 +1021,11 @@ public abstract class JsonNode
      *<p>
      * This method is functionally equivalent to:
      *<pre>
-     *   node.get(fieldName) != null &amp;&amp; !node.get(fieldName).isNull()
+     *   node.get(propertyName) != null &amp;&amp; !node.get(propertyName).isNull()
      *</pre>
-     *
-     * @since 2.1
      */
-    public boolean hasNonNull(String fieldName) {
-        JsonNode n = get(fieldName);
+    public boolean hasNonNull(String propertyName) {
+        JsonNode n = get(propertyName);
         return (n != null) && !n.isNull();
     }
 
@@ -1009,8 +1037,6 @@ public abstract class JsonNode
      *<pre>
      *   node.get(index) != null &amp;&amp; !node.get(index).isNull()
      *</pre>
-     *
-     * @since 2.1
      */
     public boolean hasNonNull(int index) {
         JsonNode n = get(index);
@@ -1135,11 +1161,11 @@ public abstract class JsonNode
      * Note that traversal is done in document order (that is, order in which
      * nodes are iterated if using {@link JsonNode#values()})
      *
-     * @param fieldName Name of field to look for
+     * @param propertyName Name of field to look for
      *
      * @return Value of first matching node found, if any; null if none
      */
-    public abstract JsonNode findValue(String fieldName);
+    public abstract JsonNode findValue(String propertyName);
 
     /**
      * Method for finding JSON Object fields with specified name -- both immediate
@@ -1150,11 +1176,11 @@ public abstract class JsonNode
      * If no matching fields are found in this node or its descendants, returns
      * an empty List.
      *
-     * @param fieldName Name of field to look for
+     * @param propertyName Name of field to look for
      */
-    public final List<JsonNode> findValues(String fieldName)
+    public final List<JsonNode> findValues(String propertyName)
     {
-        List<JsonNode> result = findValues(fieldName, null);
+        List<JsonNode> result = findValues(propertyName, null);
         if (result == null) {
             return Collections.emptyList();
         }
@@ -1165,9 +1191,9 @@ public abstract class JsonNode
      * Similar to {@link #findValues}, but will additionally convert
      * values into Strings, calling {@link #asText}.
      */
-    public final List<String> findValuesAsText(String fieldName)
+    public final List<String> findValuesAsString(String propertyName)
     {
-        List<String> result = findValuesAsText(fieldName, null);
+        List<String> result = findValuesAsString(propertyName, null);
         if (result == null) {
             return Collections.emptyList();
         }
@@ -1181,45 +1207,45 @@ public abstract class JsonNode
      * returns true; and all value access methods return empty or
      * missing value.
      *
-     * @param fieldName Name of field to look for
+     * @param propertyName Name of field to look for
      *
      * @return Value of first matching node found; or if not found, a
      *    "missing node" (non-null instance that has no value)
      */
-    public abstract JsonNode findPath(String fieldName);
+    public abstract JsonNode findPath(String propertyName);
 
     /**
      * Method for finding a JSON Object that contains specified field,
      * within this node or its descendants.
      * If no matching field is found in this node or its descendants, returns null.
      *
-     * @param fieldName Name of field to look for
+     * @param propertyName Name of field to look for
      *
      * @return Value of first matching node found, if any; null if none
      */
-    public abstract JsonNode findParent(String fieldName);
+    public abstract JsonNode findParent(String propertyName);
 
     /**
      * Method for finding a JSON Object that contains specified field,
      * within this node or its descendants.
      * If no matching field is found in this node or its descendants, returns null.
      *
-     * @param fieldName Name of field to look for
+     * @param propertyName Name of field to look for
      *
      * @return Value of first matching node found, if any; null if none
      */
-    public final List<JsonNode> findParents(String fieldName)
+    public final List<JsonNode> findParents(String propertyName)
     {
-        List<JsonNode> result = findParents(fieldName, null);
+        List<JsonNode> result = findParents(propertyName, null);
         if (result == null) {
             return Collections.emptyList();
         }
         return result;
     }
 
-    public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar);
-    public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar);
-    public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar);
+    public abstract List<JsonNode> findValues(String propertyName, List<JsonNode> foundSoFar);
+    public abstract List<String> findValuesAsString(String propertyName, List<String> foundSoFar);
+    public abstract List<JsonNode> findParents(String propertyName, List<JsonNode> foundSoFar);
 
     /*
     /**********************************************************************
diff --git a/src/main/java/tools/jackson/databind/node/ArrayNode.java b/src/main/java/tools/jackson/databind/node/ArrayNode.java
index c335b2652..475680120 100644
--- a/src/main/java/tools/jackson/databind/node/ArrayNode.java
+++ b/src/main/java/tools/jackson/databind/node/ArrayNode.java
@@ -361,10 +361,10 @@ public class ArrayNode
     }
 
     @Override
-    public List<String> findValuesAsText(String propertyName, List<String> foundSoFar)
+    public List<String> findValuesAsString(String propertyName, List<String> foundSoFar)
     {
         for (JsonNode node : _children) {
-            foundSoFar = node.findValuesAsText(propertyName, foundSoFar);
+            foundSoFar = node.findValuesAsString(propertyName, foundSoFar);
         }
         return foundSoFar;
     }
diff --git a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
index 1114020e9..9e571a21f 100644
--- a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
+++ b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
@@ -93,7 +93,7 @@ public class BigIntegerNode
      */
 
     @Override
-    public String asText() {
+    public String asString() {
         return _value.toString();
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/BinaryNode.java b/src/main/java/tools/jackson/databind/node/BinaryNode.java
index 457820e29..476b30c42 100644
--- a/src/main/java/tools/jackson/databind/node/BinaryNode.java
+++ b/src/main/java/tools/jackson/databind/node/BinaryNode.java
@@ -84,7 +84,7 @@ public class BinaryNode
      * but will work correctly.
      */
     @Override
-    public String asText() {
+    public String asString() {
         return Base64Variants.getDefaultVariant().encode(_data, false);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/BooleanNode.java b/src/main/java/tools/jackson/databind/node/BooleanNode.java
index 354573aed..0cf23b614 100644
--- a/src/main/java/tools/jackson/databind/node/BooleanNode.java
+++ b/src/main/java/tools/jackson/databind/node/BooleanNode.java
@@ -62,7 +62,7 @@ public class BooleanNode
     }
 
     @Override
-    public String asText() {
+    public String asString() {
         return _value ? "true" : "false";
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/ContainerNode.java b/src/main/java/tools/jackson/databind/node/ContainerNode.java
index edfd74ca8..66ed9fe3f 100644
--- a/src/main/java/tools/jackson/databind/node/ContainerNode.java
+++ b/src/main/java/tools/jackson/databind/node/ContainerNode.java
@@ -38,7 +38,7 @@ public abstract class ContainerNode<T extends ContainerNode<T>>
     public abstract JsonToken asToken();
 
     @Override
-    public String asText() { return ""; }
+    public String asString() { return ""; }
 
     /*
     /**********************************************************************
@@ -145,7 +145,7 @@ public abstract class ContainerNode<T extends ContainerNode<T>>
     public final ValueNode numberNode(Double v) { return _nodeFactory.numberNode(v); }
 
     @Override
-    public final TextNode textNode(String text) { return _nodeFactory.textNode(text); }
+    public final StringNode textNode(String text) { return _nodeFactory.textNode(text); }
 
     @Override
     public final BinaryNode binaryNode(byte[] data) { return _nodeFactory.binaryNode(data); }
diff --git a/src/main/java/tools/jackson/databind/node/DecimalNode.java b/src/main/java/tools/jackson/databind/node/DecimalNode.java
index fd0fa057d..00572999c 100644
--- a/src/main/java/tools/jackson/databind/node/DecimalNode.java
+++ b/src/main/java/tools/jackson/databind/node/DecimalNode.java
@@ -103,7 +103,7 @@ public class DecimalNode
     public BigDecimal decimalValue() { return _value; }
 
     @Override
-    public String asText() {
+    public String asString() {
         return _value.toString();
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/DoubleNode.java b/src/main/java/tools/jackson/databind/node/DoubleNode.java
index 518098964..f4679eb3c 100644
--- a/src/main/java/tools/jackson/databind/node/DoubleNode.java
+++ b/src/main/java/tools/jackson/databind/node/DoubleNode.java
@@ -93,7 +93,7 @@ public class DoubleNode
     }
 
     @Override
-    public String asText() {
+    public String asString() {
         return String.valueOf(_value);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/FloatNode.java b/src/main/java/tools/jackson/databind/node/FloatNode.java
index 445d6490d..2b547af15 100644
--- a/src/main/java/tools/jackson/databind/node/FloatNode.java
+++ b/src/main/java/tools/jackson/databind/node/FloatNode.java
@@ -93,7 +93,7 @@ public class FloatNode extends NumericNode
     }
 
     @Override
-    public String asText() {
+    public String asString() {
         return String.valueOf(_value);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/IntNode.java b/src/main/java/tools/jackson/databind/node/IntNode.java
index f9685b9cc..0c4facfaa 100644
--- a/src/main/java/tools/jackson/databind/node/IntNode.java
+++ b/src/main/java/tools/jackson/databind/node/IntNode.java
@@ -100,7 +100,7 @@ public class IntNode
     public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public String asText() {
+    public String asString() {
         return String.valueOf(_value);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/JsonNodeFactory.java b/src/main/java/tools/jackson/databind/node/JsonNodeFactory.java
index ade2272a6..1c0fb6bf9 100644
--- a/src/main/java/tools/jackson/databind/node/JsonNodeFactory.java
+++ b/src/main/java/tools/jackson/databind/node/JsonNodeFactory.java
@@ -241,7 +241,7 @@ public class JsonNodeFactory
      * String value
      */
     @Override
-    public TextNode textNode(String text) { return TextNode.valueOf(text); }
+    public StringNode textNode(String text) { return StringNode.valueOf(text); }
 
     /**
      * Factory method for constructing a node that represents given
diff --git a/src/main/java/tools/jackson/databind/node/LongNode.java b/src/main/java/tools/jackson/databind/node/LongNode.java
index 35c196aae..2d54c5267 100644
--- a/src/main/java/tools/jackson/databind/node/LongNode.java
+++ b/src/main/java/tools/jackson/databind/node/LongNode.java
@@ -76,7 +76,7 @@ public class LongNode
     public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public String asText() {
+    public String asString() {
         return String.valueOf(_value);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/MissingNode.java b/src/main/java/tools/jackson/databind/node/MissingNode.java
index ef5ea45e6..48e3758fe 100644
--- a/src/main/java/tools/jackson/databind/node/MissingNode.java
+++ b/src/main/java/tools/jackson/databind/node/MissingNode.java
@@ -52,9 +52,9 @@ public final class MissingNode
 
     @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }
 
-    @Override public String asText() { return ""; }
+    @Override public String asString() { return ""; }
 
-    @Override public String asText(String defaultValue) { return defaultValue; }
+    @Override public String asString(String defaultValue) { return defaultValue; }
 
     // // Note: not a numeric node, hence default 'asXxx()' are fine:
 
@@ -114,7 +114,7 @@ public final class MissingNode
     }
 
     @Override
-    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {
+    public List<String> findValuesAsString(String fieldName, List<String> foundSoFar) {
         return foundSoFar;
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/NullNode.java b/src/main/java/tools/jackson/databind/node/NullNode.java
index a8af62c57..862dd935f 100644
--- a/src/main/java/tools/jackson/databind/node/NullNode.java
+++ b/src/main/java/tools/jackson/databind/node/NullNode.java
@@ -37,9 +37,9 @@ public class NullNode
     public NullNode deepCopy() { return this; }
 
     @Override
-    public String asText(String defaultValue) { return defaultValue; }
+    public String asString(String defaultValue) { return defaultValue; }
 
-    @Override public String asText() { return "null"; }
+    @Override public String asString() { return "null"; }
 
     @SuppressWarnings("unchecked")
     @Override
diff --git a/src/main/java/tools/jackson/databind/node/NumericNode.java b/src/main/java/tools/jackson/databind/node/NumericNode.java
index 4173ec8f2..7368fae32 100644
--- a/src/main/java/tools/jackson/databind/node/NumericNode.java
+++ b/src/main/java/tools/jackson/databind/node/NumericNode.java
@@ -47,7 +47,7 @@ public abstract class NumericNode
      */
 
     @Override
-    public abstract String asText();
+    public abstract String asString();
 
     @Override
     public final int asInt() {
diff --git a/src/main/java/tools/jackson/databind/node/ObjectNode.java b/src/main/java/tools/jackson/databind/node/ObjectNode.java
index f914e8651..0df5a1a63 100644
--- a/src/main/java/tools/jackson/databind/node/ObjectNode.java
+++ b/src/main/java/tools/jackson/databind/node/ObjectNode.java
@@ -381,16 +381,16 @@ child.getClass().getName(), propName, OverwriteMode.NULLS);
     }
 
     @Override
-    public List<String> findValuesAsText(String propertyName, List<String> foundSoFar)
+    public List<String> findValuesAsString(String propertyName, List<String> foundSoFar)
     {
         for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {
             if (propertyName.equals(entry.getKey())) {
                 if (foundSoFar == null) {
                     foundSoFar = new ArrayList<String>();
                 }
-                foundSoFar.add(entry.getValue().asText());
+                foundSoFar.add(entry.getValue().asString());
             } else { // only add children if parent not added
-                foundSoFar = entry.getValue().findValuesAsText(propertyName,
+                foundSoFar = entry.getValue().findValuesAsString(propertyName,
                     foundSoFar);
             }
         }
diff --git a/src/main/java/tools/jackson/databind/node/POJONode.java b/src/main/java/tools/jackson/databind/node/POJONode.java
index d7e9943d7..4d7fafc08 100644
--- a/src/main/java/tools/jackson/databind/node/POJONode.java
+++ b/src/main/java/tools/jackson/databind/node/POJONode.java
@@ -57,10 +57,10 @@ public class POJONode
      */
 
     @Override
-    public String asText() { return (_value == null) ? "null" : _value.toString(); }
+    public String asString() { return (_value == null) ? "null" : _value.toString(); }
 
     @Override
-    public String asText(String defaultValue) {
+    public String asString(String defaultValue) {
         return (_value == null) ? defaultValue : _value.toString();
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/ShortNode.java b/src/main/java/tools/jackson/databind/node/ShortNode.java
index 5fe60381c..3702439cc 100644
--- a/src/main/java/tools/jackson/databind/node/ShortNode.java
+++ b/src/main/java/tools/jackson/databind/node/ShortNode.java
@@ -74,7 +74,7 @@ public class ShortNode
     public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public String asText() {
+    public String asString() {
         return String.valueOf(_value);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/TextNode.java b/src/main/java/tools/jackson/databind/node/StringNode.java
similarity index 81%
rename from src/main/java/tools/jackson/databind/node/TextNode.java
rename to src/main/java/tools/jackson/databind/node/StringNode.java
index 8cbf2cabc..edaa2025b 100644
--- a/src/main/java/tools/jackson/databind/node/TextNode.java
+++ b/src/main/java/tools/jackson/databind/node/StringNode.java
@@ -9,19 +9,19 @@ import tools.jackson.databind.SerializationContext;
 import tools.jackson.databind.exc.InvalidFormatException;
 
 /**
- * Value node that contains a text value.
+ * Value node that contains a String value.
  */
-public class TextNode
+public class StringNode
     extends ValueNode
 {
     private static final long serialVersionUID = 3L;
 
-    final static TextNode EMPTY_STRING_NODE = new TextNode("");
+    final static StringNode EMPTY_STRING_NODE = new StringNode("");
 
     protected final String _value;
 
-    public TextNode(String v) {
-        // 01-Mar-2024, tatu: [databind#4381] No null-valued TextNodes
+    public StringNode(String v) {
+        // 01-Mar-2024, tatu: [databind#4381] No null-valued StringNodes
         _value = Objects.requireNonNull(v);
     }
 
@@ -31,10 +31,10 @@ public class TextNode
      * this is the case for empty Strings, in future possible for
      * others as well. If null is passed, will return null.
      *
-     * @return Resulting {@link TextNode} object, if <b>v</b>
+     * @return Resulting {@link StringNode} object, if <b>v</b>
      *   is NOT null; null if it is.
      */
-    public static TextNode valueOf(String v)
+    public static StringNode valueOf(String v)
     {
         if (v == null) {
             return null;
@@ -42,7 +42,7 @@ public class TextNode
         if (v.isEmpty()) {
             return EMPTY_STRING_NODE;
         }
-        return new TextNode(v);
+        return new StringNode(v);
     }
 
     @Override
@@ -53,19 +53,19 @@ public class TextNode
     @Override public JsonToken asToken() { return JsonToken.VALUE_STRING; }
 
     @Override
-    public TextNode deepCopy() { return this; }
+    public StringNode deepCopy() { return this; }
 
     @Override
-    public String textValue() {
+    public String stringValue() {
         return _value;
     }
 
     /**
-     * Method for accessing textual contents assuming they were
-     * base64 encoded; if so, they are decoded and resulting binary
+     * Method for accessing content String assuming they were
+     * base64 encoded; if so, content is decoded and resulting binary
      * data is returned.
      *
-     * @throws JacksonException if textual contents are not valid Base64 content
+     * @throws JacksonException if String contents are not valid Base64 encoded content
      */
     @SuppressWarnings("resource")
     public byte[] getBinaryValue(Base64Variant b64variant) throws JacksonException
@@ -84,7 +84,7 @@ public class TextNode
             throw InvalidFormatException.from(
                     null, /* Alas, no processor to pass */
                     String.format(
-"Cannot access contents of TextNode as binary due to broken Base64 encoding: %s",
+"Cannot access contents of `StringNode` as binary due to broken Base64 encoding: %s",
 e.getMessage()),
                     str, byte[].class);
         }
@@ -103,12 +103,12 @@ e.getMessage()),
      */
 
     @Override
-    public String asText() {
+    public String asString() {
         return _value;
     }
 
     @Override
-    public String asText(String defaultValue) {
+    public String asString(String defaultValue) {
         return (_value == null) ? defaultValue : _value;
     }
 
@@ -167,8 +167,8 @@ e.getMessage()),
     {
         if (o == this) return true;
         if (o == null) return false;
-        if (o instanceof TextNode) {
-            return Objects.equals(((TextNode) o)._value, _value);
+        if (o instanceof StringNode) {
+            return Objects.equals(((StringNode) o)._value, _value);
         }
         return false;
     }
diff --git a/src/main/java/tools/jackson/databind/node/TreeTraversingParser.java b/src/main/java/tools/jackson/databind/node/TreeTraversingParser.java
index 7ffc01e20..88711498b 100644
--- a/src/main/java/tools/jackson/databind/node/TreeTraversingParser.java
+++ b/src/main/java/tools/jackson/databind/node/TreeTraversingParser.java
@@ -204,7 +204,7 @@ public class TreeTraversingParser
         case PROPERTY_NAME:
             return _nodeCursor.currentName();
         case VALUE_STRING:
-            return currentNode().textValue();
+            return currentNode().stringValue();
         case VALUE_NUMBER_INT:
         case VALUE_NUMBER_FLOAT:
             return String.valueOf(currentNode().numberValue());
@@ -212,7 +212,7 @@ public class TreeTraversingParser
             JsonNode n = currentNode();
             if (n != null && n.isBinary()) {
                 // this will convert it to base64
-                return n.asText();
+                return n.asString();
             }
         default:
             return _currToken.asString();
@@ -359,9 +359,9 @@ public class TreeTraversingParser
         JsonNode n = currentNode();
         if (n != null) {
             // [databind#2096]: although `binaryValue()` works for real binary node
-            // and embedded "POJO" node, coercion from TextNode may require variant, so:
-            if (n instanceof TextNode) {
-                return ((TextNode) n).getBinaryValue(b64variant);
+            // and embedded "POJO" node, coercion from `StringNode` may require variant, so:
+            if (n instanceof StringNode) {
+                return ((StringNode) n).getBinaryValue(b64variant);
             }
             return n.binaryValue();
         }
diff --git a/src/main/java/tools/jackson/databind/node/ValueNode.java b/src/main/java/tools/jackson/databind/node/ValueNode.java
index b9c32450b..336381d36 100644
--- a/src/main/java/tools/jackson/databind/node/ValueNode.java
+++ b/src/main/java/tools/jackson/databind/node/ValueNode.java
@@ -111,7 +111,7 @@ public abstract class ValueNode
     }
 
     @Override
-    public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {
+    public final List<String> findValuesAsString(String fieldName, List<String> foundSoFar) {
         return foundSoFar;
     }
 
diff --git a/src/test/java/tools/jackson/databind/ObjectMapperTest.java b/src/test/java/tools/jackson/databind/ObjectMapperTest.java
index b433a3f30..8e577e493 100644
--- a/src/test/java/tools/jackson/databind/ObjectMapperTest.java
+++ b/src/test/java/tools/jackson/databind/ObjectMapperTest.java
@@ -527,7 +527,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         InputStream inputStream = new ByteArrayInputStream("\"value\"".getBytes(StandardCharsets.UTF_8));
         JsonNode jsonNode =  MAPPER.readTree(inputStream);
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
@@ -537,7 +537,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         Files.write(path, "\"value\"".getBytes(StandardCharsets.UTF_8));
         JsonNode jsonNode = MAPPER.readTree(path.toFile());
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
@@ -547,7 +547,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         Files.write(path, "\"value\"".getBytes(StandardCharsets.UTF_8));
         JsonNode jsonNode = MAPPER.readTree(path);
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
@@ -557,7 +557,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         Files.write(path, "\"value\"".getBytes(StandardCharsets.UTF_8));
         JsonNode jsonNode = MAPPER.readTree(path.toUri().toURL());
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
@@ -566,7 +566,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         Reader reader = new StringReader("\"value\"");
         JsonNode jsonNode = MAPPER.readTree(reader);
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
@@ -576,12 +576,12 @@ public class ObjectMapperTest extends DatabindTestUtil
         byte[] bytes = "\"value\"".getBytes(StandardCharsets.UTF_8);
         JsonNode jsonNode1 = MAPPER.readTree(bytes);
 
-        assertEquals(jsonNode1.textValue(), "value");
+        assertEquals(jsonNode1.stringValue(), "value");
 
         // without offset and length
         JsonNode jsonNode2 = MAPPER.readTree(bytes, 0, bytes.length);
 
-        assertEquals(jsonNode2.textValue(), "value");
+        assertEquals(jsonNode2.stringValue(), "value");
     }
 
     @Test
@@ -590,7 +590,7 @@ public class ObjectMapperTest extends DatabindTestUtil
         String string = "\"value\"";
         JsonNode jsonNode = MAPPER.readTree(string);
 
-        assertEquals(jsonNode.textValue(), "value");
+        assertEquals(jsonNode.stringValue(), "value");
     }
 
     @Test
diff --git a/src/test/java/tools/jackson/databind/ObjectReaderTest.java b/src/test/java/tools/jackson/databind/ObjectReaderTest.java
index 593915e0a..beeb8d338 100644
--- a/src/test/java/tools/jackson/databind/ObjectReaderTest.java
+++ b/src/test/java/tools/jackson/databind/ObjectReaderTest.java
@@ -582,7 +582,7 @@ public class ObjectReaderTest extends DatabindTestUtil
         }
 
         @Override
-        public String asText() {
+        public String asString() {
             return "";
         }
 
@@ -602,7 +602,7 @@ public class ObjectReaderTest extends DatabindTestUtil
         }
 
         @Override
-        public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {
+        public List<String> findValuesAsString(String fieldName, List<String> foundSoFar) {
             return foundSoFar;
         }
 
@@ -702,7 +702,7 @@ public class ObjectReaderTest extends DatabindTestUtil
         }
 
         @Override
-        public String asText() {
+        public String asString() {
             return "";
         }
 
@@ -722,7 +722,7 @@ public class ObjectReaderTest extends DatabindTestUtil
         }
 
         @Override
-        public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {
+        public List<String> findValuesAsString(String fieldName, List<String> foundSoFar) {
             return foundSoFar;
         }
 
diff --git a/src/test/java/tools/jackson/databind/deser/CustomDeserializersTest.java b/src/test/java/tools/jackson/databind/deser/CustomDeserializersTest.java
index 1c7e4ebb0..cb3178868 100644
--- a/src/test/java/tools/jackson/databind/deser/CustomDeserializersTest.java
+++ b/src/test/java/tools/jackson/databind/deser/CustomDeserializersTest.java
@@ -349,7 +349,7 @@ public class CustomDeserializersTest
         public NamedPoint deserialize(JsonParser p, DeserializationContext ctxt)
         {
             JsonNode tree = ctxt.readTree(p);
-            String name = tree.path("name").asText(null);
+            String name = tree.path("name").asString(null);
             Point point = ctxt.readTreeAsValue(tree.get("point"), Point.class);
             return new NamedPoint(name, point);
         }
diff --git a/src/test/java/tools/jackson/databind/deser/creators/EnumCreatorTest.java b/src/test/java/tools/jackson/databind/deser/creators/EnumCreatorTest.java
index 8e3586982..76737e803 100644
--- a/src/test/java/tools/jackson/databind/deser/creators/EnumCreatorTest.java
+++ b/src/test/java/tools/jackson/databind/deser/creators/EnumCreatorTest.java
@@ -101,7 +101,7 @@ public class EnumCreatorTest extends DatabindTestUtil
 
         @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
         public static EnumWithDelegateModeJsonCreator create(JsonNode json) {
-            return EnumWithDelegateModeJsonCreator.valueOf(json.get("name").asText());
+            return EnumWithDelegateModeJsonCreator.valueOf(json.get("name").asString());
         }
     }
 
diff --git a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
index f5464ab57..af3337454 100644
--- a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
+++ b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
@@ -52,7 +52,7 @@ public class Base64DecodingTest
             /*byte[] b =*/ nodeValue.binaryValue();
             fail("Should not pass");
         } catch (MismatchedInputException e) {
-            verifyException(e, "Cannot access contents of TextNode as binary");
+            verifyException(e, "Cannot access contents of `StringNode` as binary");
             verifyException(e, "Illegal character '!'");
         }
     }
diff --git a/src/test/java/tools/jackson/databind/deser/merge/NodeMergeTest.java b/src/test/java/tools/jackson/databind/deser/merge/NodeMergeTest.java
index 637cf0182..977fff591 100644
--- a/src/test/java/tools/jackson/databind/deser/merge/NodeMergeTest.java
+++ b/src/test/java/tools/jackson/databind/deser/merge/NodeMergeTest.java
@@ -55,8 +55,8 @@ public class NodeMergeTest
                 MAPPER.readerForUpdating(base)
                 .readValue(a2q("{'second':'bar', 'third':5, 'fourth':true}")));
         assertEquals(4, base.size());
-        assertEquals("bar", base.path("second").asText());
-        assertEquals("foo", base.path("first").asText());
+        assertEquals("bar", base.path("second").asString());
+        assertEquals("foo", base.path("first").asString());
         assertEquals(5, base.path("third").asInt());
         assertTrue(base.path("fourth").asBoolean());
     }
@@ -67,8 +67,8 @@ public class NodeMergeTest
         ObjectNodeWrapper w = MAPPER.readValue(a2q("{'props':{'stuff':'xyz'}}"),
                 ObjectNodeWrapper.class);
         assertEquals(2, w.props.size());
-        assertEquals("enabled", w.props.path("default").asText());
-        assertEquals("xyz", w.props.path("stuff").asText());
+        assertEquals("enabled", w.props.path("default").asString());
+        assertEquals("xyz", w.props.path("stuff").asString());
     }
 
     @Test
@@ -107,8 +107,8 @@ public class NodeMergeTest
                 MAPPER.readerForUpdating(base)
                 .readValue(a2q("['second',false,null]")));
         assertEquals(4, base.size());
-        assertEquals("first", base.path(0).asText());
-        assertEquals("second", base.path(1).asText());
+        assertEquals("first", base.path(0).asString());
+        assertEquals("second", base.path(1).asString());
         assertFalse(base.path(2).asBoolean());
         assertTrue(base.path(3).isNull());
     }
@@ -128,7 +128,7 @@ public class NodeMergeTest
         n = w.list.get(4);
         assertTrue(n.isArray());
         assertEquals(0, n.size());
-        assertEquals("foo", w.list.get(5).asText());
+        assertEquals("foo", w.list.get(5).asString());
     }
 
     // [databind#3056]
diff --git a/src/test/java/tools/jackson/databind/exc/ExceptionSerializationTest.java b/src/test/java/tools/jackson/databind/exc/ExceptionSerializationTest.java
index fbde20a0f..3b62da5a2 100644
--- a/src/test/java/tools/jackson/databind/exc/ExceptionSerializationTest.java
+++ b/src/test/java/tools/jackson/databind/exc/ExceptionSerializationTest.java
@@ -138,7 +138,7 @@ public class ExceptionSerializationTest
         // but should be able to serialize new exception we got
         String json = MAPPER.writeValueAsString(e);
         JsonNode root = MAPPER.readTree(json);
-        String msg = root.path("message").asText();
+        String msg = root.path("message").asString();
         String MATCH = "cannot construct instance";
         if (!msg.toLowerCase().contains(MATCH)) {
             fail("Exception should contain '"+MATCH+"', does not: '"+msg+"'");
diff --git a/src/test/java/tools/jackson/databind/introspect/TestNamingStrategyStd.java b/src/test/java/tools/jackson/databind/introspect/TestNamingStrategyStd.java
index 73f3919e5..73b278acf 100644
--- a/src/test/java/tools/jackson/databind/introspect/TestNamingStrategyStd.java
+++ b/src/test/java/tools/jackson/databind/introspect/TestNamingStrategyStd.java
@@ -579,7 +579,7 @@ public class TestNamingStrategyStd extends DatabindTestUtil
         assertEquals("1", result.id);
         assertNotNull(result.json);
         assertEquals(2, result.json.size());
-        assertEquals("bing", result.json.path("baz").asText());
+        assertEquals("bing", result.json.path("baz").asString());
     }
 
     @Test
diff --git a/src/test/java/tools/jackson/databind/jsontype/deftyping/TestDefaultForTreeNodes.java b/src/test/java/tools/jackson/databind/jsontype/deftyping/TestDefaultForTreeNodes.java
index 9c62ebaff..893a860c7 100644
--- a/src/test/java/tools/jackson/databind/jsontype/deftyping/TestDefaultForTreeNodes.java
+++ b/src/test/java/tools/jackson/databind/jsontype/deftyping/TestDefaultForTreeNodes.java
@@ -37,7 +37,7 @@ public class TestDefaultForTreeNodes extends DatabindTestUtil
         String json = DEFAULT_MAPPER.writeValueAsString(foo);
 
         JsonNode jsonNode = DEFAULT_MAPPER.readTree(json);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 
     @Test
@@ -45,6 +45,6 @@ public class TestDefaultForTreeNodes extends DatabindTestUtil
     {
         Foo foo = new Foo("baz");
         JsonNode jsonNode = DEFAULT_MAPPER.valueToTree(foo);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 }
diff --git a/src/test/java/tools/jackson/databind/node/AbsentNodeViaCreator3214Test.java b/src/test/java/tools/jackson/databind/node/AbsentNodeViaCreator3214Test.java
index eced75f99..b54b6e6ec 100644
--- a/src/test/java/tools/jackson/databind/node/AbsentNodeViaCreator3214Test.java
+++ b/src/test/java/tools/jackson/databind/node/AbsentNodeViaCreator3214Test.java
@@ -14,8 +14,8 @@ public class AbsentNodeViaCreator3214Test extends DatabindTestUtil
 {
     static class Pojo3214
     {
-        JsonNode fromCtor = TextNode.valueOf("x");
-        JsonNode fromSetter = TextNode.valueOf("x");
+        JsonNode fromCtor = StringNode.valueOf("x");
+        JsonNode fromSetter = StringNode.valueOf("x");
 
         @JsonCreator
         public Pojo3214(@JsonProperty("node") JsonNode n) {
diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
index d978becad..bca3813d5 100644
--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
@@ -28,7 +28,7 @@ public class ArrayNodeTest
         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);
 
         assertFalse(n.isBoolean());
-        assertFalse(n.isTextual());
+        assertFalse(n.isString());
         assertFalse(n.isNumber());
         assertFalse(n.canConvertToInt());
         assertFalse(n.canConvertToLong());
@@ -39,7 +39,7 @@ public class ArrayNodeTest
         assertEquals(0, n.valueSpliterator().estimateSize());
         assertTrue(n.propertyNames().isEmpty());
         assertTrue(n.isEmpty());
-        TextNode text = TextNode.valueOf("x");
+        StringNode text = StringNode.valueOf("x");
         n.add(text);
         assertEquals(1, n.size());
         assertFalse(n.isEmpty());
@@ -78,10 +78,10 @@ public class ArrayNodeTest
         n.addAll(n2);
         assertEquals(3, n.size());
 
-        assertFalse(n.get(0).isTextual());
+        assertFalse(n.get(0).isString());
         assertNotNull(n.remove(0));
         assertEquals(2, n.size());
-        assertTrue(n.get(0).isTextual());
+        assertTrue(n.get(0).isString());
         assertNull(n.remove(-1));
         assertNull(n.remove(100));
         assertEquals(2, n.size());
@@ -93,7 +93,7 @@ public class ArrayNodeTest
         assertNull(n.get(10000));
         assertNull(n.remove(-4));
 
-        TextNode text2 = TextNode.valueOf("b");
+        StringNode text2 = StringNode.valueOf("b");
         n.insert(0, text2);
         assertEquals(4, n.size());
         assertSame(text2, n.get(0));
@@ -117,7 +117,7 @@ public class ArrayNodeTest
         ArrayNode n = new ArrayNode(f, list);
         assertEquals(2, n.size());
         assertTrue(n.get(0).isBoolean());
-        assertTrue(n.get(1).isTextual());
+        assertTrue(n.get(1).isString());
 
         // also, should fail with invalid set attempt
         try {
@@ -130,7 +130,7 @@ public class ArrayNodeTest
         assertEquals(3, n.size());
         assertTrue(n.get(0).isBoolean());
         assertTrue(n.get(1).isNull());
-        assertTrue(n.get(2).isTextual());
+        assertTrue(n.get(2).isString());
 
         n.removeAll();
         n.insert(0, (JsonNode) null);
@@ -180,7 +180,7 @@ public class ArrayNodeTest
         assertEquals(231.5D, array.get(12).doubleValue(), 0.000000001d);
         assertEquals(0, BigDecimal.TEN.compareTo(array.get(13).decimalValue()));
         assertEquals(BigInteger.ONE, array.get(14).bigIntegerValue());
-        assertEquals("Modified Data", array.get(15).textValue());
+        assertEquals("Modified Data", array.get(15).stringValue());
         assertTrue(array.get(16).booleanValue());
         assertFalse(array.get(17).booleanValue());
         assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, array.get(18).binaryValue());
@@ -188,9 +188,9 @@ public class ArrayNodeTest
         assertEquals(20, array.size());
         for (int i = 0; i < 20; i++) {
             if (i <= 18) {
-                assertNotEquals("Original Data", array.get(i).textValue());
+                assertNotEquals("Original Data", array.get(i).stringValue());
             } else {
-                assertEquals("Original Data", array.get(i).textValue());
+                assertEquals("Original Data", array.get(i).stringValue());
             }
         }
     }
@@ -404,12 +404,12 @@ public class ArrayNodeTest
         assertTrue(n1.equals(n2));
         assertTrue(n2.equals(n1));
 
-        n1.add(TextNode.valueOf("Test"));
+        n1.add(StringNode.valueOf("Test"));
 
         assertFalse(n1.equals(n2));
         assertFalse(n2.equals(n1));
 
-        n2.add(TextNode.valueOf("Test"));
+        n2.add(StringNode.valueOf("Test"));
 
         assertTrue(n1.equals(n2));
         assertTrue(n2.equals(n1));
@@ -426,7 +426,7 @@ public class ArrayNodeTest
         assertFalse(result.isObject());
         assertFalse(result.isNumber());
         assertFalse(result.isNull());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
 
         // and let's add stuff...
         result.add(false);
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
index cf1dde60b..ca1295cde 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
@@ -31,7 +31,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         assertStandardEquals(f);
         assertFalse(f.booleanValue());
         assertFalse(f.asBoolean());
-        assertEquals("false", f.asText());
+        assertEquals("false", f.asString());
         assertEquals(JsonToken.VALUE_FALSE, f.asToken());
 
         assertFalse(f.isNumber());
@@ -47,7 +47,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         assertStandardEquals(t);
         assertTrue(t.booleanValue());
         assertTrue(t.asBoolean());
-        assertEquals("true", t.asText());
+        assertEquals("true", t.asString());
         assertEquals(JsonToken.VALUE_TRUE, t.asToken());
 
         assertNodeNumbers(f, 0, 0.0);
@@ -56,11 +56,11 @@ public class JsonNodeBasicTest extends NodeTestBase
         JsonNode result = objectMapper().readTree("true\n");
         assertFalse(result.isNull());
         assertFalse(result.isNumber());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertTrue(result.isBoolean());
         assertType(result, BooleanNode.class);
         assertTrue(result.booleanValue());
-        assertEquals("true", result.asText());
+        assertEquals("true", result.asString());
         assertFalse(result.isMissingNode());
 
         // also, equality should work ok
@@ -93,7 +93,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         assertTrue(n.equals(n2));
         assertEquals("\"Aw==\"", n.toString());
 
-        assertEquals("AAMD", new BinaryNode(data).asText());
+        assertEquals("AAMD", new BinaryNode(data).asString());
         assertNodeNumbersForNonNumeric(n);
 
         assertNonContainerStreamMethods(n2);
@@ -105,7 +105,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         POJONode n = new POJONode("x"); // not really a pojo but that's ok
         assertStandardEquals(n);
         assertEquals(n, new POJONode("x"));
-        assertEquals("x", n.asText());
+        assertEquals("x", n.asString());
         // 10-Dec-2018, tatu: With 2.10, should serialize same as via ObjectMapper/ObjectWriter
         assertEquals("\"x\"", n.toString());
 
@@ -222,7 +222,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         ArrayNode arrayNode = MAPPER.createArrayNode();
         arrayNode.add("firstElement");
         assertTrue(arrayNode.optional(0).isPresent());
-        assertEquals("firstElement", arrayNode.optional(0).get().asText());
+        assertEquals("firstElement", arrayNode.optional(0).get().asString());
         assertFalse(arrayNode.optional(1).isPresent());
         assertFalse(arrayNode.optional(-1).isPresent());
         assertFalse(arrayNode.optional(999).isPresent());
@@ -234,7 +234,7 @@ public class JsonNodeBasicTest extends NodeTestBase
         ObjectNode objectNode = MAPPER.createObjectNode();
         objectNode.put("existingField", "value");
         assertTrue(objectNode.optional("existingField").isPresent());
-        assertEquals("value", objectNode.optional("existingField").get().asText());
+        assertEquals("value", objectNode.optional("existingField").get().asString());
         assertFalse(objectNode.optional("missingField").isPresent());
         assertFalse(objectNode.optional(0).isPresent());
         assertFalse(objectNode.optional(-1).isPresent());
@@ -267,17 +267,14 @@ public class JsonNodeBasicTest extends NodeTestBase
     @Test
     public void testOptionalAccessorOnOtherTypes() throws Exception
     {
-        // Test TextNode
-        TextNode textNode = TextNode.valueOf("sampleText");
-        assertFalse(textNode.optional("anyField").isPresent());
-        assertFalse(textNode.optional(0).isPresent());
+        StringNode stringNode = StringNode.valueOf("sampleText");
+        assertFalse(stringNode.optional("anyField").isPresent());
+        assertFalse(stringNode.optional(0).isPresent());
 
-        // Test NullNode
         NullNode nullNode = NullNode.getInstance();
         assertFalse(nullNode.optional("anyField").isPresent());
         assertFalse(nullNode.optional(0).isPresent());
 
-        // Test BooleanNode
         BooleanNode booleanNode = BooleanNode.TRUE;
         assertFalse(booleanNode.optional("anyField").isPresent());
         assertFalse(booleanNode.optional(0).isPresent());
@@ -303,11 +300,11 @@ public class JsonNodeBasicTest extends NodeTestBase
         assertTrue(arrayOptional.isPresent());
         assertEquals(arrayNode, arrayOptional.get());
 
-        // Test with TextNode
-        TextNode textNode = TextNode.valueOf("text");
-        Optional<JsonNode> textOptional = textNode.asOptional();
+        // Test with StringNode
+        StringNode stringNode = StringNode.valueOf("text");
+        Optional<JsonNode> textOptional = stringNode.asOptional();
         assertTrue(textOptional.isPresent());
-        assertEquals(textNode, textOptional.get());
+        assertEquals(stringNode, textOptional.get());
 
         // Test with NullNode
         NullNode nullNode = NullNode.getInstance();
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
index 52a81eca4..50d1228dd 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
@@ -132,9 +132,9 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
     {
         assertEquals(9, IntNode.valueOf(9).asInt());
         assertEquals(7, LongNode.valueOf(7L).asInt());
-        assertEquals(13, new TextNode("13").asInt());
-        assertEquals(0, new TextNode("foobar").asInt());
-        assertEquals(27, new TextNode("foobar").asInt(27));
+        assertEquals(13, new StringNode("13").asInt());
+        assertEquals(0, new StringNode("foobar").asInt());
+        assertEquals(27, new StringNode("foobar").asInt(27));
         assertEquals(1, BooleanNode.TRUE.asInt());
     }
 
@@ -147,10 +147,10 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
         assertTrue(IntNode.valueOf(1).asBoolean());
         assertFalse(LongNode.valueOf(0).asBoolean());
         assertTrue(LongNode.valueOf(-34L).asBoolean());
-        assertTrue(new TextNode("true").asBoolean());
-        assertFalse(new TextNode("false").asBoolean());
-        assertFalse(new TextNode("barf").asBoolean());
-        assertTrue(new TextNode("barf").asBoolean(true));
+        assertTrue(new StringNode("true").asBoolean());
+        assertFalse(new StringNode("false").asBoolean());
+        assertFalse(new StringNode("barf").asBoolean());
+        assertTrue(new StringNode("barf").asBoolean(true));
 
         assertTrue(new POJONode(Boolean.TRUE).asBoolean());
     }
@@ -231,7 +231,7 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
                 input[i] = (byte) i;
             }
             for (Base64Variant variant : VARIANTS) {
-                TextNode n = new TextNode(variant.encode(input));
+                StringNode n = new StringNode(variant.encode(input));
                 byte[] data = null;
                 try {
                     data = n.getBinaryValue(variant);
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeFindMethodsTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeFindMethodsTest.java
index 198b52eda..88664c9d6 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeFindMethodsTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeFindMethodsTest.java
@@ -81,7 +81,7 @@ public class JsonNodeFindMethodsTest
         assertEquals(42, nodes.get(1).path("value").intValue());
 
         // and finally, convenience conversion method
-        List<String> values = root.findValuesAsText("value");
+        List<String> values = root.findValuesAsString("value");
         assertEquals(2, values.size());
         assertEquals("3", values.get(0));
         assertEquals("42", values.get(1));
diff --git a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
index 8516af27b..0f33ad83c 100644
--- a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
@@ -18,8 +18,8 @@ public class MissingNodeTest extends NodeTestBase
         MissingNode n = MissingNode.getInstance();
         assertTrue(n.isMissingNode());
         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());
-        assertEquals("", n.asText());
-        assertEquals("default", n.asText("default"));
+        assertEquals("", n.asString());
+        assertEquals("default", n.asString("default"));
         assertStandardEquals(n);
         // 10-Dec-2018, tatu: With 2.10, should serialize same as via ObjectMapper/ObjectWriter
         // 10-Dec-2019, tatu: Surprise! No, this is not how it worked in 2.9, nor does it make
@@ -63,7 +63,7 @@ public class MissingNodeTest extends NodeTestBase
         assertEquals(0, onode.size());
         assertFalse(onode.isMissingNode()); // real node
         assertTrue(onode.asOptional().isPresent());
-        assertNull(onode.textValue());
+        assertNull(onode.stringValue());
 
         // how about dereferencing?
         assertNull(onode.get(0));
diff --git a/src/test/java/tools/jackson/databind/node/NullNodeTest.java b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
index 86f996356..6eea5da8f 100644
--- a/src/test/java/tools/jackson/databind/node/NullNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
@@ -54,8 +54,8 @@ public class NullNodeTest extends NodeTestBase
         assertEquals(BigDecimal.ZERO, n.decimalValue());
         assertEquals(BigInteger.ZERO, n.bigIntegerValue());
         // may be odd but...
-        assertEquals("null", n.asText());
-        assertEquals("fallback", n.asText("fallback"));
+        assertEquals("null", n.asString());
+        assertEquals("fallback", n.asString("fallback"));
 
         assertEquals(0, n.size());
         assertTrue(n.isEmpty());
@@ -70,7 +70,7 @@ public class NullNodeTest extends NodeTestBase
 
         assertNodeNumbersForNonNumeric(n);
 
-        assertEquals("null", n.asText());
+        assertEquals("null", n.asString());
 
         assertNonContainerStreamMethods(n);
     }
@@ -83,8 +83,8 @@ public class NullNodeTest extends NodeTestBase
         assertNotNull(n);
         assertTrue(n.isNull());
         assertFalse(n.isNumber());
-        assertFalse(n.isTextual());
-        assertEquals("null", n.asText());
+        assertFalse(n.isString());
+        assertEquals("null", n.asString());
         assertEquals(n, NullNode.instance);
 
         n = objectMapper().readTree("null");
diff --git a/src/test/java/tools/jackson/databind/node/NumberNodesTest.java b/src/test/java/tools/jackson/databind/node/NumberNodesTest.java
index c3a5cd0a1..9c87f5f0d 100644
--- a/src/test/java/tools/jackson/databind/node/NumberNodesTest.java
+++ b/src/test/java/tools/jackson/databind/node/NumberNodesTest.java
@@ -34,7 +34,7 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(1L, n.longValue());
         assertEquals(BigDecimal.ONE, n.decimalValue());
         assertEquals(BigInteger.ONE, n.bigIntegerValue());
-        assertEquals("1", n.asText());
+        assertEquals("1", n.asString());
 
         assertNodeNumbers(n, 1, 1.0);
 
@@ -62,7 +62,7 @@ public class NumberNodesTest extends NodeTestBase
         assertFalse(result.isFloatingPointNumber());
         assertFalse(result.isDouble());
         assertFalse(result.isNull());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertFalse(result.isMissingNode());
 
         assertTrue(result.canConvertToInt());
@@ -71,7 +71,7 @@ public class NumberNodesTest extends NodeTestBase
 
         assertEquals(value, result.numberValue().intValue());
         assertEquals(value, result.intValue());
-        assertEquals(String.valueOf(value), result.asText());
+        assertEquals(String.valueOf(value), result.asString());
         assertEquals((double) value, result.doubleValue());
         assertEquals((long) value, result.longValue());
 
@@ -91,9 +91,9 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(1L, n.longValue());
         assertEquals(BigDecimal.ONE, n.decimalValue());
         assertEquals(BigInteger.ONE, n.bigIntegerValue());
-        assertEquals("1", n.asText());
+        assertEquals("1", n.asString());
         // 2.4
-        assertEquals("1", n.asText("foo"));
+        assertEquals("1", n.asString("foo"));
 
         assertNodeNumbers(n, 1, 1.0);
 
@@ -120,7 +120,7 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(1L, n.longValue());
         assertEquals(BigDecimal.ONE, n.decimalValue());
         assertEquals(BigInteger.ONE, n.bigIntegerValue());
-        assertEquals("1", n.asText());
+        assertEquals("1", n.asString());
 
         assertNodeNumbers(n, 1, 1.0);
 
@@ -153,12 +153,12 @@ public class NumberNodesTest extends NodeTestBase
         assertFalse(result.isFloatingPointNumber());
         assertFalse(result.isDouble());
         assertFalse(result.isNull());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertFalse(result.isMissingNode());
 
         assertEquals(value, result.numberValue().longValue());
         assertEquals(value, result.longValue());
-        assertEquals(String.valueOf(value), result.asText());
+        assertEquals(String.valueOf(value), result.asString());
         assertEquals((double) value, result.doubleValue());
 
         assertFalse(result.canConvertToInt());
@@ -181,7 +181,7 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(0.25, n.doubleValue());
         assertNotNull(n.decimalValue());
         assertEquals(BigInteger.ZERO, n.bigIntegerValue());
-        assertEquals("0.25", n.asText());
+        assertEquals("0.25", n.asString());
 
         assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);
 
@@ -219,14 +219,14 @@ public class NumberNodesTest extends NodeTestBase
         assertFalse(result.isInt());
         assertFalse(result.isLong());
         assertFalse(result.isIntegralNumber());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertFalse(result.isMissingNode());
 
         assertEquals(value, result.doubleValue());
         assertEquals(value, result.numberValue().doubleValue());
         assertEquals((int) value, result.intValue());
         assertEquals((long) value, result.longValue());
-        assertEquals(String.valueOf(value), result.asText());
+        assertEquals(String.valueOf(value), result.asString());
 
         // also, equality should work ok
         assertEquals(result, DoubleNode.valueOf(value));
@@ -248,7 +248,7 @@ public class NumberNodesTest extends NodeTestBase
 
         // NOTE: conversion to double NOT as simple as with exact numbers like 0.25:
         assertEquals(0.45f, n.floatValue());
-        assertEquals("0.45", n.asText());
+        assertEquals("0.45", n.asString());
 
         // so; as double we'll get more complex number; however, should round-trip
         // to something that gets printed the same way. But not exact value, alas, hence:
@@ -257,7 +257,7 @@ public class NumberNodesTest extends NodeTestBase
         assertNotNull(n.decimalValue());
         // possibly surprisingly, however, this will produce same output:
         assertEquals(BigInteger.ZERO, n.bigIntegerValue());
-        assertEquals("0.45", n.asText());
+        assertEquals("0.45", n.asString());
 
         // 1.6:
         assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f);
@@ -293,7 +293,7 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(1, n.intValue());
         assertEquals(1L, n.longValue());
         assertEquals(BigDecimal.ONE, n.decimalValue());
-        assertEquals("1", n.asText());
+        assertEquals("1", n.asString());
 
         assertNodeNumbers(n, 1, 1.0);
 
@@ -321,7 +321,7 @@ public class NumberNodesTest extends NodeTestBase
         assertTrue(result.isBigDecimal());
         assertFalse(result.isDouble());
         assertFalse(result.isNull());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertFalse(result.isMissingNode());
 
         assertFalse(result.canConvertToExactIntegral());
@@ -329,7 +329,7 @@ public class NumberNodesTest extends NodeTestBase
         assertTrue(result.canConvertToLong());
 
         assertEquals(value, result.numberValue());
-        assertEquals(value.toString(), result.asText());
+        assertEquals(value.toString(), result.asString());
 
         // also, equality should work ok
         assertEquals(result, DecimalNode.valueOf(value));
@@ -374,7 +374,7 @@ public class NumberNodesTest extends NodeTestBase
         assertEquals(1, n.intValue());
         assertEquals(1L, n.longValue());
         assertEquals(BigInteger.ONE, n.bigIntegerValue());
-        assertEquals("1", n.asText());
+        assertEquals("1", n.asString());
         assertNodeNumbers(n, 1, 1.0);
 
         BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);
diff --git a/src/test/java/tools/jackson/databind/node/ObjectNodeTest.java b/src/test/java/tools/jackson/databind/node/ObjectNodeTest.java
index 0be8feeeb..5926f0f09 100644
--- a/src/test/java/tools/jackson/databind/node/ObjectNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ObjectNodeTest.java
@@ -87,7 +87,7 @@ public class ObjectNodeTest
         assertFalse(root.isEmpty());
 
         assertFalse(root.isBoolean());
-        assertFalse(root.isTextual());
+        assertFalse(root.isString());
         assertFalse(root.isNumber());
         assertFalse(root.canConvertToInt());
         assertFalse(root.canConvertToLong());
@@ -103,7 +103,7 @@ public class ObjectNodeTest
         assertTrue(it.hasNext());
         n = it.next();
         assertNotNull(n);
-        assertEquals(TextNode.valueOf("x"), n);
+        assertEquals(StringNode.valueOf("x"), n);
 
         assertFalse(it.hasNext());
 
@@ -119,7 +119,7 @@ public class ObjectNodeTest
         assertTrue(fit.hasNext());
         en = fit.next();
         assertEquals("b", en.getKey());
-        assertEquals(TextNode.valueOf("x"), en.getValue());
+        assertEquals(StringNode.valueOf("x"), en.getValue());
 
         // Plus: we should be able to modify the node via iterator too:
         fit.remove();
@@ -150,7 +150,7 @@ public class ObjectNodeTest
         assertFalse(n.optional("a").isPresent());
         assertTrue(n.path("a").isMissingNode());
 
-        TextNode text = TextNode.valueOf("x");
+        StringNode text = StringNode.valueOf("x");
         assertSame(n, n.set("a", text));
 
         assertEquals(1, n.size());
@@ -211,7 +211,7 @@ public class ObjectNodeTest
         // but can replace with straight set
         old = root.replace("key", f.numberNode(72));
         assertNotNull(old);
-        assertEquals("foobar", old.textValue());
+        assertEquals("foobar", old.stringValue());
     }
 
     @Test
@@ -293,7 +293,7 @@ public class ObjectNodeTest
         assertEquals(3, ob.size());
         assertSame(ob, ob.without(Arrays.asList("a", "c")));
         assertEquals(1, ob.size());
-        assertEquals("b", ob.get("b").textValue());
+        assertEquals("b", ob.get("b").stringValue());
     }
 
     @Test
@@ -306,9 +306,9 @@ public class ObjectNodeTest
         assertEquals(3, ob.size());
         assertSame(ob, ob.retain("a", "c"));
         assertEquals(2, ob.size());
-        assertEquals("a", ob.get("a").textValue());
+        assertEquals("a", ob.get("a").stringValue());
         assertNull(ob.get("b"));
-        assertEquals("c", ob.get("c").textValue());
+        assertEquals("c", ob.get("c").stringValue());
     }
 
     @Test
diff --git a/src/test/java/tools/jackson/databind/node/POJONodeTest.java b/src/test/java/tools/jackson/databind/node/POJONodeTest.java
index 7943d1aab..09b96dab2 100644
--- a/src/test/java/tools/jackson/databind/node/POJONodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/POJONodeTest.java
@@ -61,7 +61,7 @@ public class POJONodeTest extends NodeTestBase
     // `JsonNode.toString()` will use internal "default" ObjectMapper which
     // does not (and cannot) have modules for external datatypes, such as
     // Java 8 Date/Time types. So we'll catch IOException/RuntimeException for
-    // POJONode, produce something like "[ERROR: (type) [msg]" TextNode for that case?
+    // POJONode, produce something like "[ERROR: (type) [msg]" StringNode for that case?
     @Test
     public void testAddJava8DateAsPojo() throws Exception
     {
@@ -70,7 +70,7 @@ public class POJONodeTest extends NodeTestBase
         assertNotNull(json);
 
         JsonNode result = MAPPER.readTree(json);
-        String msg = result.path("test").asText();
+        String msg = result.path("test").asString();
         assertTrue(msg.startsWith("[ERROR:"),
                 "Wrong fail message: "+msg);
         assertTrue(msg.contains("InvalidDefinitionException"),
diff --git a/src/test/java/tools/jackson/databind/node/StringNodeTest.java b/src/test/java/tools/jackson/databind/node/StringNodeTest.java
new file mode 100644
index 000000000..a1653c29b
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/node/StringNodeTest.java
@@ -0,0 +1,59 @@
+package tools.jackson.databind.node;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class StringNodeTest extends NodeTestBase
+{
+    @Test
+    public void testBasics()
+    {
+        assertNull(StringNode.valueOf(null));
+        StringNode empty = StringNode.valueOf("");
+        assertStandardEquals(empty);
+        assertSame(StringNode.EMPTY_STRING_NODE, empty);
+
+        assertEquals(0, empty.size());
+        assertTrue(empty.isEmpty());
+
+        assertNodeNumbers(StringNode.valueOf("-3"), -3, -3.0);
+        assertNodeNumbers(StringNode.valueOf("17.75"), 17, 17.75);
+
+        long value = 127353264013893L;
+        StringNode n = StringNode.valueOf(String.valueOf(value));
+        assertEquals(value, n.asLong());
+
+        assertFalse(n.isNumber());
+        assertFalse(n.canConvertToInt());
+        assertFalse(n.canConvertToLong());
+        assertFalse(n.canConvertToExactIntegral());
+
+        // and then with non-numeric input
+        n = StringNode.valueOf("foobar");
+        assertNodeNumbersForNonNumeric(n);
+
+        assertEquals("foobar", n.asString());
+        assertEquals("", empty.asString());
+
+        assertTrue(StringNode.valueOf("true").asBoolean(true));
+        assertTrue(StringNode.valueOf("true").asBoolean(false));
+        assertFalse(StringNode.valueOf("false").asBoolean(true));
+        assertFalse(StringNode.valueOf("false").asBoolean(false));
+
+        assertNonContainerStreamMethods(n);
+    }
+
+    @Test
+    public void testEquals()
+    {
+        assertEquals(new StringNode("abc"), new StringNode("abc"));
+        assertNotEquals(new StringNode("abc"), new StringNode("def"));
+    }
+
+    @Test
+    public void testHashCode()
+    {
+        assertEquals("abc".hashCode(), new StringNode("abc").hashCode());
+    }
+}
diff --git a/src/test/java/tools/jackson/databind/node/TextNodeTest.java b/src/test/java/tools/jackson/databind/node/TextNodeTest.java
deleted file mode 100644
index 4a7a8f335..000000000
--- a/src/test/java/tools/jackson/databind/node/TextNodeTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package tools.jackson.databind.node;
-
-import org.junit.jupiter.api.Test;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-public class TextNodeTest extends NodeTestBase
-{
-    @Test
-    public void testText()
-    {
-        assertNull(TextNode.valueOf(null));
-        TextNode empty = TextNode.valueOf("");
-        assertStandardEquals(empty);
-        assertSame(TextNode.EMPTY_STRING_NODE, empty);
-
-        assertEquals(0, empty.size());
-        assertTrue(empty.isEmpty());
-
-        assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0);
-        assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75);
-
-        long value = 127353264013893L;
-        TextNode n = TextNode.valueOf(String.valueOf(value));
-        assertEquals(value, n.asLong());
-
-        assertFalse(n.isNumber());
-        assertFalse(n.canConvertToInt());
-        assertFalse(n.canConvertToLong());
-        assertFalse(n.canConvertToExactIntegral());
-
-        // and then with non-numeric input
-        n = TextNode.valueOf("foobar");
-        assertNodeNumbersForNonNumeric(n);
-
-        assertEquals("foobar", n.asText());
-        assertEquals("", empty.asText());
-
-        assertTrue(TextNode.valueOf("true").asBoolean(true));
-        assertTrue(TextNode.valueOf("true").asBoolean(false));
-        assertFalse(TextNode.valueOf("false").asBoolean(true));
-        assertFalse(TextNode.valueOf("false").asBoolean(false));
-
-        assertNonContainerStreamMethods(n);
-    }
-
-    @Test
-    public void testEquals()
-    {
-        assertEquals(new TextNode("abc"), new TextNode("abc"));
-        assertNotEquals(new TextNode("abc"), new TextNode("def"));
-    }
-
-    @Test
-    public void testHashCode()
-    {
-        assertEquals("abc".hashCode(), new TextNode("abc").hashCode());
-    }
-}
diff --git a/src/test/java/tools/jackson/databind/node/TreeDeserializationTest.java b/src/test/java/tools/jackson/databind/node/TreeDeserializationTest.java
index 10bbe401a..68c81bf01 100644
--- a/src/test/java/tools/jackson/databind/node/TreeDeserializationTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeDeserializationTest.java
@@ -38,12 +38,12 @@ public class TreeDeserializationTest
         assertTrue(n1.equals(n2));
         assertTrue(n2.equals(n1));
 
-        n1.set("x", TextNode.valueOf("Test"));
+        n1.set("x", StringNode.valueOf("Test"));
 
         assertFalse(n1.equals(n2));
         assertFalse(n2.equals(n1));
 
-        n2.set("x", TextNode.valueOf("Test"));
+        n2.set("x", StringNode.valueOf("Test"));
 
         assertTrue(n1.equals(n2));
         assertTrue(n2.equals(n1));
@@ -60,7 +60,7 @@ public class TreeDeserializationTest
         JsonNode out = mapper.readValue( generated, JsonNode.class );   //crashes here
         assertTrue(out.isObject());
         assertEquals(1, out.size());
-        String value = out.path("field").asText();
+        String value = out.path("field").asString();
         assertNotNull(value);
     }
 }
diff --git a/src/test/java/tools/jackson/databind/node/TreeReadViaMapperTest.java b/src/test/java/tools/jackson/databind/node/TreeReadViaMapperTest.java
index 2e58ec367..9ba55244f 100644
--- a/src/test/java/tools/jackson/databind/node/TreeReadViaMapperTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeReadViaMapperTest.java
@@ -55,21 +55,21 @@ public class TreeReadViaMapperTest extends DatabindTestUtil
             assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());
 
             ob = imageMap.get("Title");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());
+            assertTrue(ob.isString());
+            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.stringValue());
 
             ob = imageMap.get("Thumbnail");
             assertType(ob, ObjectNode.class);
             ObjectNode tn = (ObjectNode) ob;
             ob = tn.get("Url");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());
+            assertTrue(ob.isString());
+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.stringValue());
             ob = tn.get("Height");
             assertTrue(ob.isIntegralNumber());
             assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());
             ob = tn.get("Width");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());
+            assertTrue(ob.isString());
+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.stringValue());
 
             ob = imageMap.get("IDs");
             assertTrue(ob.isArray());
@@ -153,14 +153,14 @@ public class TreeReadViaMapperTest extends DatabindTestUtil
 
         assertTrue(result.isIntegralNumber());
         assertTrue(result.isInt());
-        assertFalse(result.isTextual());
+        assertFalse(result.isString());
         assertEquals(12, result.intValue());
 
         result = mapper.readTree(p);
-        assertTrue(result.isTextual());
+        assertTrue(result.isString());
         assertFalse(result.isIntegralNumber());
         assertFalse(result.isInt());
-        assertEquals("string", result.textValue());
+        assertEquals("string", result.stringValue());
 
         result = mapper.readTree(p);
         assertTrue(result.isArray());
diff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
index 08d92f1c5..742c93f11 100644
--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
@@ -223,7 +223,7 @@ public class TreeTraversingParserTest
     @Test
     public void testTextAsBinary() throws Exception
     {
-        TextNode n = new TextNode("   APs=\n");
+        StringNode n = new StringNode("   APs=\n");
         JsonParser p = n.traverse(ObjectReadContext.empty());
         assertNull(p.currentToken());
         assertToken(JsonToken.VALUE_STRING, p.nextToken());
@@ -236,7 +236,7 @@ public class TreeTraversingParserTest
         assertTrue(p.isClosed());
 
         // Also: let's verify we get an exception for garbage...
-        n = new TextNode("?!??");
+        n = new StringNode("?!??");
         p = n.traverse(ObjectReadContext.empty());
         assertToken(JsonToken.VALUE_STRING, p.nextToken());
         try {
diff --git a/src/test/java/tools/jackson/databind/node/TreeWithTypeTest.java b/src/test/java/tools/jackson/databind/node/TreeWithTypeTest.java
index fd606e228..991053ef4 100644
--- a/src/test/java/tools/jackson/databind/node/TreeWithTypeTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeWithTypeTest.java
@@ -42,8 +42,8 @@ public class TreeWithTypeTest extends DatabindTestUtil
         {
            ObjectReadContext oc = jsonParser.objectReadContext();
            JsonNode node = oc.readTree(jsonParser);
-           return new SavedCookie(node.path("name").textValue(),
-                   node.path("value").textValue());
+           return new SavedCookie(node.path("name").stringValue(),
+                   node.path("value").stringValue());
         }
 
         @Override
@@ -69,7 +69,7 @@ public class TreeWithTypeTest extends DatabindTestUtil
         String json = MAPPER.writeValueAsString(foo);
 
         JsonNode jsonNode = MAPPER.readTree(json);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 
     @Test
@@ -82,7 +82,7 @@ public class TreeWithTypeTest extends DatabindTestUtil
         String json = mapper.writeValueAsString(foo);
 
         JsonNode jsonNode = mapper.readTree(json);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 
     @Test
@@ -96,7 +96,7 @@ public class TreeWithTypeTest extends DatabindTestUtil
                 .build();
         String json = "{\"@class\":\""+CLASS+"\",\"bar\":\"baz\"}";
         JsonNode jsonNode = mapper.readTree(json);
-        assertEquals(jsonNode.get("bar").textValue(), "baz");
+        assertEquals(jsonNode.get("bar").stringValue(), "baz");
     }
 
     @Test
@@ -104,7 +104,7 @@ public class TreeWithTypeTest extends DatabindTestUtil
 
         Foo foo = new Foo("baz");
         JsonNode jsonNode = MAPPER.valueToTree(foo);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 
     @Test
@@ -116,7 +116,7 @@ public class TreeWithTypeTest extends DatabindTestUtil
                 .build();
         Foo foo = new Foo("baz");
         JsonNode jsonNode = mapper.valueToTree(foo);
-        assertEquals(jsonNode.get("bar").textValue(), foo.bar);
+        assertEquals(jsonNode.get("bar").stringValue(), foo.bar);
     }
 
     @Test
diff --git a/src/test/java/tools/jackson/databind/objectid/JSOGDeserialize622Test.java b/src/test/java/tools/jackson/databind/objectid/JSOGDeserialize622Test.java
index 03a875877..8453e456d 100644
--- a/src/test/java/tools/jackson/databind/objectid/JSOGDeserialize622Test.java
+++ b/src/test/java/tools/jackson/databind/objectid/JSOGDeserialize622Test.java
@@ -90,7 +90,7 @@ public class JSOGDeserialize622Test extends DatabindTestUtil
         public JSOGRef deserialize(JsonParser p, DeserializationContext ctx)
         {
             JsonNode node = p.readValueAsTree();
-            if (node.isTextual()) {
+            if (node.isString()) {
                 return new JSOGRef(node.asInt());
             }
             JsonNode n = node.get(REF_KEY);
diff --git a/src/test/java/tools/jackson/databind/records/RecordWithJsonUnwrappedTest.java b/src/test/java/tools/jackson/databind/records/RecordWithJsonUnwrappedTest.java
index 93bf33f4a..e76ba6f6c 100644
--- a/src/test/java/tools/jackson/databind/records/RecordWithJsonUnwrappedTest.java
+++ b/src/test/java/tools/jackson/databind/records/RecordWithJsonUnwrappedTest.java
@@ -26,9 +26,9 @@ public class RecordWithJsonUnwrappedTest extends DatabindTestUtil
 
         ObjectNode tree = MAPPER.valueToTree(initial);
 
-        assertEquals("unrelatedValue", tree.get("unrelated").textValue());
-        assertEquals("value1", tree.get("property1").textValue());
-        assertEquals("value2", tree.get("property2").textValue());
+        assertEquals("unrelatedValue", tree.get("unrelated").stringValue());
+        assertEquals("value1", tree.get("property1").stringValue());
+        assertEquals("value2", tree.get("property2").stringValue());
 
         RecordWithJsonUnwrapped outer = MAPPER.treeToValue(tree, RecordWithJsonUnwrapped.class);
 
