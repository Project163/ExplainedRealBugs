diff --git a/release-notes/VERSION b/release-notes/VERSION
index 41d64c56c..2416a99a2 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -4,43 +4,44 @@ New minor version.
 
 Fixes:
 
-* [Issue#118]: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly
+#118: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly
  with missing type id, scalar types
-* [Issue#130]: TimeZone not set for GregorianCalendar, even if configured
-* [Issue#144]: MissingNode.isValueNode() should return 'false'
+#130: TimeZone not set for GregorianCalendar, even if configured
+#144: MissingNode.isValueNode() should return 'false'
  (reported by 'fge@github')
-* [Issue#146]: Creator properties were not being renamed as expected
+#146: Creator properties were not being renamed as expected
  (contributed by Christoper C)
+#188: Problem with ObjectId serialization, 'alwaysAsId' references
 
 Improvements:
 
-* [#116]: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)
-* [#147]: Defer reporting of problems with missing creator parameters
+#116: JavaType implements `java.lang.reflect.Type` (as does `TypeReference`)
+#147: Defer reporting of problems with missing creator parameters
  (contributed by Christoper C)
-* [#155]: Make `ObjectNode` and `ArrayNode` final (other node types already were)
+#155: Make `ObjectNode` and `ArrayNode` final (other node types already were)
  (requested by fge@github)
-* [#161]: Add deserializer for java.util.concurrent.ArrayBlockingQueue
-* [#173]: Add 'JsonNode.traverse(ObjectCodec)' for convenience
+#161: Add deserializer for java.util.concurrent.ArrayBlockingQueue
+#173: Add 'JsonNode.traverse(ObjectCodec)' for convenience
 
 New features:
 
-* [#120]: Extend BeanDeserializerModifier to work with non-POJO deserializers
-* [#121]: Extend BeanSerializerModifier to work with non-POJO serializers
-* [#124]: Add support for serialization converters (@JsonSerializer(converter=...))
-* [#124]: Add support for deserialization converters (@JsonDeserializer(converter=...))
-* [#140]: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing
+#120: Extend BeanDeserializerModifier to work with non-POJO deserializers
+#121: Extend BeanSerializerModifier to work with non-POJO serializers
+#124: Add support for serialization converters (@JsonSerializer(converter=...))
+#124: Add support for deserialization converters (@JsonDeserializer(converter=...))
+#140: Add 'SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN' to allow forcing
   of non-scientific notation when serializing BigDecimals.
  (suggested by phedny@github)
-* [#148]: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping
+#148: Add 'DeserializationFeature.FAIL_ON_INVALID_SUBTYPE`, which allows mapping
   entries with missing or invalid type id into null references (instead of failing).
   Also allows use of '@JsonTypeInfo.defaultImpl = NoClass.class' as alternative.
-* [#159]: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),
+#159: Add more accessors in 'MappingIterator': getParser(), getParserSchema(),
   readAll()
  (suggested by Tom D)
 
 Other:
 
-* [#126]: Update JDK baseline to 1.6
+#126: Update JDK baseline to 1.6
 * API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly
   based on experiences with external JSON Schema generator.
 * Version information accessed via code-generated access class, instead of reading
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java
index e00c0dcce..7098f1f6e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java
@@ -4,12 +4,11 @@ import java.io.IOException;
 
 import com.fasterxml.jackson.core.JsonGenerationException;
 import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.io.SerializedString;
+
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;
 import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;
 import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;
-import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;
 import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;
 import com.fasterxml.jackson.databind.util.NameTransformer;
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java
index 8d237bccf..9e0b99d88 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java
@@ -1,7 +1,13 @@
 package com.fasterxml.jackson.databind.ser.impl;
 
+import java.io.IOException;
+
 import com.fasterxml.jackson.annotation.ObjectIdGenerator;
-import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.core.JsonGenerationException;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.io.SerializedString;
+
+import com.fasterxml.jackson.databind.SerializerProvider;
 
 /**
  * Simple value container used to keep track of Object Ids during
@@ -10,12 +16,38 @@ import com.fasterxml.jackson.databind.JsonSerializer;
 public final class WritableObjectId
 {
     public final ObjectIdGenerator<?> generator;
-    
-    public JsonSerializer<Object> serializer;
 
     public Object id;
+
+    protected boolean idWritten = false;
     
     public WritableObjectId(ObjectIdGenerator<?> generator) {
         this.generator = generator;
     }
+    
+    public boolean writeAsId(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w)
+        throws IOException, JsonGenerationException
+    {
+        if (id != null && (idWritten || w.alwaysAsId)) {
+            w.serializer.serialize(id, jgen, provider);
+            return true;
+        }
+        return false;
+    }
+    
+    public Object generateId(Object forPojo) {
+        return (id = generator.generateId(forPojo));
+    }
+
+    public void writeAsField(JsonGenerator jgen, SerializerProvider provider,
+            ObjectIdWriter w)
+        throws IOException, JsonGenerationException
+    {
+        SerializedString name = w.propertyName;
+        idWritten = true;
+        if (name != null) {
+            jgen.writeFieldName(name);
+            w.serializer.serialize(id, jgen, provider);
+        }
+    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java
index 2c4142342..feac112f6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java
@@ -7,8 +7,8 @@ import java.util.*;
 import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.annotation.ObjectIdGenerator;
 import com.fasterxml.jackson.annotation.ObjectIdGenerators;
+
 import com.fasterxml.jackson.core.*;
-import com.fasterxml.jackson.core.io.SerializedString;
 
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.introspect.Annotated;
@@ -504,30 +504,21 @@ public abstract class BeanSerializerBase
         throws IOException, JsonGenerationException
     {
         final ObjectIdWriter w = _objectIdWriter;
-        WritableObjectId oid = provider.findObjectId(bean, w.generator);
-        Object id = oid.id;
-        
-        if (id != null) { // have seen before; serialize just id
-            oid.serializer.serialize(id, jgen, provider);
+        WritableObjectId objectId = provider.findObjectId(bean, w.generator);
+        // If possible, write as id already
+        if (objectId.writeAsId(jgen, provider, w)) {
             return;
         }
-        // if not, bit more work:
-        oid.serializer = w.serializer;
-        oid.id = id = oid.generator.generateId(bean);
-        // possibly. Or maybe not:
-        if (w.alwaysAsId) { 
-            oid.serializer.serialize(id, jgen, provider);
+        // If not, need to inject the id:
+        Object id = objectId.generateId(bean);
+        if (w.alwaysAsId) {
+            w.serializer.serialize(id, jgen, provider);
             return;
         }
-        // If not, need to inject the id:
         if (startEndObject) {
             jgen.writeStartObject();
         }
-        SerializedString name = w.propertyName;
-        if (name != null) {
-            jgen.writeFieldName(name);
-            w.serializer.serialize(id, jgen, provider);
-        }
+        objectId.writeAsField(jgen, provider, w);
         if (_propertyFilterId != null) {
             serializeFieldsFiltered(bean, jgen, provider);
         } else {
@@ -544,31 +535,24 @@ public abstract class BeanSerializerBase
         throws IOException, JsonGenerationException
     {
         final ObjectIdWriter w = _objectIdWriter;
-        WritableObjectId oid = provider.findObjectId(bean, w.generator);
-        Object id = oid.id;
-        
-        if (id != null) { // have seen before; serialize just id
-            oid.serializer.serialize(id, jgen, provider);
+        WritableObjectId objectId = provider.findObjectId(bean, w.generator);
+        // If possible, write as id already
+        if (objectId.writeAsId(jgen, provider, w)) {
+            return;
+        }
+        // If not, need to inject the id:
+        Object id = objectId.generateId(bean);
+        if (w.alwaysAsId) {
+            w.serializer.serialize(id, jgen, provider);
             return;
         }
-        // if not, bit more work:
-        oid.serializer = w.serializer;
-        oid.id = id = oid.generator.generateId(bean);
-        
         String typeStr = (_typeId == null) ? null :_customTypeId(bean);
         if (typeStr == null) {
             typeSer.writeTypePrefixForObject(bean, jgen);
         } else {
             typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);
         }
-
-        // Very first thing: inject the id property
-        SerializedString name = w.propertyName;
-        if (name != null) {
-            jgen.writeFieldName(name);
-            w.serializer.serialize(id, jgen, provider);
-        }
-
+        objectId.writeAsField(jgen, provider, w);
         if (_propertyFilterId != null) {
             serializeFieldsFiltered(bean, jgen, provider);
         } else {
