diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 38bf108d7..8450266b3 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -5,3 +5,7 @@ Version numbers in brackets indicate release in which the problem was fixed
 (note: for older credits, see `CREDITS-2.x` instead)
 
 Tatu Saloranta, tatu.saloranta@iki.fi: author
+
+Alexander Koshman (akoshman@github)
+ * Requested #1600: Serializing locale with underscore, not standard hyphen	
+  [3.0.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 41e5c1c59..9182b7560 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -9,6 +9,8 @@ Versions: 3.x (for earlier see VERSION-2.x)
 
 #1058: Add a way to pass std and format-specific parser/generator flags during
   parser/generation construction
+#1600: Serializing locale with underscore, not standard hyphen
+ (requested by Alexander K)
 #1762: `StdDateFormat`: serialize time offset using colon
 #1772: Remove `MapperFeature. USE_STD_BEAN_NAMING`
 #1773: Remove `MapperFeature.AUTO_DETECT_xxx` features
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdJdkDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdJdkDeserializers.java
index 9bc300b2c..f4e77ef8d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdJdkDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdJdkDeserializers.java
@@ -15,14 +15,13 @@ public class StdJdkDeserializers
     private final static HashSet<String> _classNames = new HashSet<String>();
     static {
         // note: can skip primitive types; other ways to check them:
-        Class<?>[] types = new Class<?>[] {
-                UUID.class,
-                AtomicBoolean.class,
-                StackTraceElement.class,
-                ByteBuffer.class
-        };
-        for (Class<?> cls : types) { _classNames.add(cls.getName()); }
-        for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }
+        _classNames.add(UUID.class.getName());
+        _classNames.add(AtomicBoolean.class.getName());
+        _classNames.add(StackTraceElement.class.getName());
+        _classNames.add(ByteBuffer.class.getName());
+        for (Class<?> cls : FromStringDeserializer.types()) {
+            _classNames.add(cls.getName());
+        }
     }
 
     public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
index 7108cf6ee..4a4a892dc 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
@@ -52,9 +52,9 @@ public abstract class BasicSerializerFactory
     implements java.io.Serializable
 {
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Configuration, lookup tables/maps
-    /**********************************************************
+    /**********************************************************************
      */
 
     /**
@@ -63,17 +63,8 @@ public abstract class BasicSerializerFactory
      * use the class name, and keep things simple and efficient.
      */
     protected final static HashMap<String, JsonSerializer<?>> _concrete;
-    
-    /**
-     * Actually it may not make much sense to eagerly instantiate all
-     * kinds of serializers: so this Map actually contains class references,
-     * not instances
-     */
-    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy;
 
     static {
-        HashMap<String, Class<? extends JsonSerializer<?>>> concLazy
-            = new HashMap<String, Class<? extends JsonSerializer<?>>>();
         HashMap<String, JsonSerializer<?>> concrete
             = new HashMap<String, JsonSerializer<?>>();
 
@@ -81,7 +72,7 @@ public abstract class BasicSerializerFactory
         /* String and string-like types (note: date types explicitly
          * not included -- can use either textual or numeric serialization)
          */
-        concrete.put(String.class.getName(), new StringSerializer());
+        concrete.put(String.class.getName(), StringSerializer.instance);
         final ToStringSerializer sls = ToStringSerializer.instance;
         concrete.put(StringBuffer.class.getName(), sls);
         concrete.put(StringBuilder.class.getName(), sls);
@@ -95,37 +86,20 @@ public abstract class BasicSerializerFactory
 
         // Other numbers, more complicated
         concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
-        concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
+        concrete.put(BigDecimal.class.getName(), new NumberSerializer(BigDecimal.class));
 
         // Other discrete non-container types:
         // First, Date/Time zoo:
         concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
         concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
 
-        // And then other standard non-structured JDK types
-        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {
-            Object value = en.getValue();
-            if (value instanceof JsonSerializer<?>) {
-                concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
-            } else {
-                @SuppressWarnings("unchecked")
-                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;
-                concLazy.put(en.getKey().getName(), cls);
-            }
-        }
-
-        // Jackson-specific type(s)
-        // (Q: can this ever be sub-classed?)
-        concLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);
-
         _concrete = concrete;
-        _concreteLazy = concLazy;
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Configuration
-    /**********************************************************
+    /**********************************************************************
      */
     
     /**
@@ -315,17 +289,11 @@ public abstract class BasicSerializerFactory
             SerializationConfig config, BeanDescription beanDesc,
             boolean staticTyping)
     {
-        Class<?> raw = type.getRawClass();
-        String clsName = raw.getName();
-        JsonSerializer<?> ser = _concrete.get(clsName);
+        final Class<?> raw = type.getRawClass();
+        JsonSerializer<?> ser = StdJdkSerializers.find(raw);
         if (ser == null) {
-            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);
-            if (serClass != null) {
-                // 07-Jan-2017, tatu: Should never fail (since we control constructors),
-                //   but if it does will throw `IllegalArgumentException` with description,
-                //   which we could catch, re-title.
-                return ClassUtil.createInstance(serClass, false);
-            }
+            final String clsName = raw.getName();
+            ser = _concrete.get(clsName);
         }
         return ser;
     }
@@ -343,8 +311,6 @@ public abstract class BasicSerializerFactory
      *    based on that property
      *  </li>
      *</ul>
-     *
-     * @since 2.0
      */
     protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, 
             JavaType type, BeanDescription beanDesc)
@@ -447,10 +413,10 @@ public abstract class BasicSerializerFactory
         if (DoubleStream.class.isAssignableFrom(raw)) {
             return DoubleStreamSerializer.INSTANCE;
         }
-        // 17-Sep-2017, tatu: With 3.0, this JDK7 type may be added here too.
-        // NOTE: not concrete, can not just add via StdJdkSerializers.
+        // NOTE: not concrete, can not just add directly via StdJdkSerializers. Also, requires
+        // bit of trickery wrt class name for polymorphic...
         if (Path.class.isAssignableFrom(raw)) {
-            return new NioPathSerializer();
+            return StringLikeSerializer.find(Path.class);
         }
         // Then check for optional/external serializers 
         JsonSerializer<?> ser = OptionalHandlerFactory.instance.findSerializer(prov.getConfig(),
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java
deleted file mode 100644
index 801f71ab9..000000000
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.fasterxml.jackson.databind.ser.std;
-
-import java.io.IOException;
-
-import com.fasterxml.jackson.core.JsonGenerator;
-
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
-
-/**
- * Also: default bean access will not do much good with Class.class. But
- * we can just serialize the class name and that should be enough.
- */
-@SuppressWarnings("serial")
-public class ClassSerializer
-    extends StdScalarSerializer<Class<?>>
-{
-    public ClassSerializer() { super(Class.class, false); }
-
-    @Override
-    public void serialize(Class<?> value, JsonGenerator g, SerializerProvider provider) throws IOException
-    {
-        g.writeString(value.getName());
-    }
-
-    @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-        throws JsonMappingException
-    {
-        visitStringFormat(visitor, typeHint);
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java
deleted file mode 100644
index 11e298ce7..000000000
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.fasterxml.jackson.databind.ser.std;
-
-import java.io.File;
-import java.io.IOException;
-
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
-
-/**
- * For now, File objects get serialized by just outputting
- * absolute (but not canonical) name as String value
- */
-@SuppressWarnings("serial")
-public class FileSerializer
-    extends StdScalarSerializer<File>
-{
-    public FileSerializer() { super(File.class); }
-
-    @Override
-    public void serialize(File value, JsonGenerator g, SerializerProvider provider) throws IOException {
-        g.writeString(value.getAbsolutePath());
-    }
-
-    @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-        throws JsonMappingException
-    {
-        visitStringFormat(visitor, typeHint);
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NioPathSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NioPathSerializer.java
deleted file mode 100644
index b7c707cbf..000000000
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NioPathSerializer.java
+++ /dev/null
@@ -1,39 +0,0 @@
-
-package com.fasterxml.jackson.databind.ser.std;
-
-import java.io.IOException;
-import java.nio.file.Path;
-
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonToken;
-import com.fasterxml.jackson.core.type.WritableTypeId;
-
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
-
-public class NioPathSerializer extends StdScalarSerializer<Path>
-{
-    private static final long serialVersionUID = 1;
-
-    public NioPathSerializer() { super(Path.class); }
-
-    @Override
-    public void serialize(Path value, JsonGenerator gen, SerializerProvider serializers) throws IOException
-    {
-        // write the Path as a URI, always.
-        gen.writeString(value.toUri().toString());
-    }
-
-    // [databind#1688]: Not sure this is 100% ok, considering there are legitimately different
-    //  impls... but has to do
-    @Override
-    public void serializeWithType(Path value, JsonGenerator g,
-            SerializerProvider provider, TypeSerializer typeSer) throws IOException
-    {
-        // Better ensure we don't use specific sub-classes:
-        WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,
-                typeSer.typeId(value, Path.class, JsonToken.VALUE_STRING));
-        serialize(value, g, provider);
-        typeSer.writeTypeSuffix(g, typeIdDef);
-    }
-}
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java
index 58d6fd624..e84f1cd20 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java
@@ -8,6 +8,7 @@ import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;
+import com.fasterxml.jackson.databind.util.TokenBuffer;
 
 /**
  * Class that providers access to serializers user for non-structured JDK types that
@@ -18,48 +19,57 @@ import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;
 public class StdJdkSerializers
 {
     /**
-     * Method called by {@link BasicSerializerFactory} to access
-     * all serializers this class provides.
+     * Method called by {@link BasicSerializerFactory} to find one of serializers provided here.
      */
-    public static Collection<Map.Entry<Class<?>, Object>> all()
+    public static final JsonSerializer<?> find(Class<?> raw)
     {
-        HashMap<Class<?>,Object> sers = new HashMap<Class<?>,Object>();
-
-        // First things that 'toString()' can handle
-        sers.put(java.net.URL.class, new ToStringSerializer(java.net.URL.class));
-        sers.put(java.net.URI.class, new ToStringSerializer(java.net.URI.class));
-
-        sers.put(Currency.class, new ToStringSerializer(Currency.class));
-        sers.put(UUID.class, new UUIDSerializer());
-        sers.put(java.util.regex.Pattern.class, new ToStringSerializer(java.util.regex.Pattern.class));
-        sers.put(Locale.class, new ToStringSerializer(Locale.class));
-
-        // then atomic types (note: AtomicReference defined elsewhere)
-        sers.put(AtomicBoolean.class, AtomicBooleanSerializer.class);
-        sers.put(AtomicInteger.class, AtomicIntegerSerializer.class);
-        sers.put(AtomicLong.class, AtomicLongSerializer.class);
-
-        // then other types that need specialized serializers
-        sers.put(File.class, FileSerializer.class);
-        sers.put(Class.class, ClassSerializer.class);
-
+        JsonSerializer<?> ser = StringLikeSerializer.find(raw);
+        if (ser != null) {
+            return ser;
+        }
+        if (raw == UUID.class) {
+            return new UUIDSerializer();
+        }
+        if (raw == AtomicBoolean.class) {
+            return new AtomicBooleanSerializer();
+        }
+        if (raw == AtomicInteger.class) {
+            return new AtomicIntegerSerializer();
+        }
+        if (raw == AtomicLong.class) {
+            return new AtomicLongSerializer();
+        }
+        // Jackson-specific type(s)
+        // (Q: can this ever be sub-classed?)
+        if (raw == TokenBuffer.class) {
+            return new TokenBufferSerializer();
+        }
         // And then some stranger types... not 100% they are needed but:
-        sers.put(Void.class, NullSerializer.instance);
-        sers.put(Void.TYPE, NullSerializer.instance);
+        if ((raw == Void.class) || (raw == Void.TYPE)) { 
+            return NullSerializer.instance;
+        }
+        if (raw.getName().startsWith("java.sql."))  {
+            return _findSqlType(raw);
+        }
+        return null;
+    }
 
-        // 09-Jan-2015, tatu: As per [databind#1073], let's try to guard against possibility
-        //   of some environments missing `java.sql.` types
+    private static JsonSerializer<?> _findSqlType(Class<?> raw) {
         try {
             // note: timestamps are very similar to java.util.Date, thus serialized as such
-            sers.put(java.sql.Timestamp.class, DateSerializer.instance);
-    
-            // leave some of less commonly used ones as lazy, no point in proactive construction
-            sers.put(java.sql.Date.class, SqlDateSerializer.class);
-            sers.put(java.sql.Time.class, SqlTimeSerializer.class);
+            if (raw == java.sql.Timestamp.class) {
+                return DateSerializer.instance;
+            }
+            if (raw == java.sql.Date.class) {
+                return new SqlDateSerializer();
+            }
+            if (raw == java.sql.Time.class) {
+                return new SqlTimeSerializer();
+            }
         } catch (NoClassDefFoundError e) {
             // nothing much we can do here; could log, but probably not useful for now.
         }
-        return sers.entrySet();
+        return null;
     }
 
     /*
@@ -74,7 +84,7 @@ public class StdJdkSerializers
         public AtomicBooleanSerializer() { super(AtomicBoolean.class, false); }
     
         @Override
-        public void serialize(AtomicBoolean value, JsonGenerator gen, SerializerProvider provider) throws IOException, JsonGenerationException {
+        public void serialize(AtomicBoolean value, JsonGenerator gen, SerializerProvider provider) throws IOException {
             gen.writeBoolean(value.get());
         }
 
@@ -83,14 +93,14 @@ public class StdJdkSerializers
             visitor.expectBooleanFormat(typeHint);
         }
     }
-    
+
     public static class AtomicIntegerSerializer
         extends StdScalarSerializer<AtomicInteger>
     {
         public AtomicIntegerSerializer() { super(AtomicInteger.class, false); }
     
         @Override
-        public void serialize(AtomicInteger value, JsonGenerator gen, SerializerProvider provider) throws IOException, JsonGenerationException {
+        public void serialize(AtomicInteger value, JsonGenerator gen, SerializerProvider provider) throws IOException {
             gen.writeNumber(value.get());
         }
 
@@ -107,7 +117,7 @@ public class StdJdkSerializers
         public AtomicLongSerializer() { super(AtomicLong.class, false); }
     
         @Override
-        public void serialize(AtomicLong value, JsonGenerator gen, SerializerProvider provider) throws IOException, JsonGenerationException {
+        public void serialize(AtomicLong value, JsonGenerator gen, SerializerProvider provider) throws IOException {
             gen.writeNumber(value.get());
         }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringLikeSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringLikeSerializer.java
new file mode 100644
index 000000000..294054780
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringLikeSerializer.java
@@ -0,0 +1,134 @@
+package com.fasterxml.jackson.databind.ser.std;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URL;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.regex.Pattern;
+
+import com.fasterxml.jackson.core.*;
+import com.fasterxml.jackson.core.type.WritableTypeId;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
+
+/**
+ * "Combo" serializer used for JDK types that work almost like {@link ToStringSerializer}.
+ *
+ * @since 3.0
+ */
+@JacksonStdImpl
+public class StringLikeSerializer
+    extends StdSerializer<Object>
+{
+    private static final long serialVersionUID = 1L;
+
+    protected final static int TYPE_URL = 1;
+    protected final static int TYPE_URI = 2;
+    protected final static int TYPE_FILE = 3;
+    protected final static int TYPE_PATH = 4;
+
+    protected final static int TYPE_CLASS = 5;
+    
+    protected final static int TYPE_CURRENCY = 6;
+    protected final static int TYPE_LOCALE = 7;
+    protected final static int TYPE_PATTERN = 8;
+
+    private final static Map<Class<?>,Integer> _types = new HashMap<>();
+    static {
+        _types.put(URL.class, TYPE_URL);
+        _types.put(URI.class, TYPE_URI);
+        _types.put(File.class, TYPE_FILE);
+        _types.put(Path.class, TYPE_PATH);
+
+        _types.put(Class.class, TYPE_CLASS);
+
+        _types.put(Currency.class, TYPE_CURRENCY);
+        _types.put(Locale.class, TYPE_LOCALE);
+        _types.put(Pattern.class, TYPE_PATTERN);
+    }
+
+    private final int _type;
+
+    public StringLikeSerializer(Class<?> handledType, int type) {
+        super(handledType, false);
+        _type = type;
+    }
+
+    public static final JsonSerializer<?> find(Class<?> raw)
+    {
+        Integer I = _types.get(raw);
+        if (I == null) {
+            return null;
+        }
+        return new StringLikeSerializer(raw, I.intValue());
+    }
+    
+    @Override
+    public boolean isEmpty(SerializerProvider prov, Object value) {
+        return value.toString().isEmpty();
+    }
+
+    @Override
+    public void serialize(Object value, JsonGenerator g, SerializerProvider provider)
+        throws IOException
+    {
+        String str;
+
+        switch (_type) {
+        case TYPE_FILE:
+            str = ((File) value).getAbsolutePath();
+            break;
+        case TYPE_PATH:
+            str = ((Path)value).toUri().toString();
+            break;
+        case TYPE_CLASS:
+            str = ((Class<?>)value).getName();
+            break;
+        case TYPE_LOCALE: // [databind#1600]
+            {
+                Locale loc = (Locale) value;
+                if (loc == Locale.ROOT) {
+                    str = "";
+                } else {
+                    str = loc.toLanguageTag();
+                }
+            }
+            break;
+        default:
+            str = value.toString();
+            break;
+        }
+        g.writeString(str);
+    }
+
+    /**
+     * Default implementation will write type prefix, call regular serialization
+     * method (since assumption is that value itself does not need JSON
+     * Array or Object start/end markers), and then write type suffix.
+     * This should work for most cases; some sub-classes may want to
+     * change this behavior.
+     */
+    @Override
+    public void serializeWithType(Object value, JsonGenerator g, SerializerProvider provider,
+            TypeSerializer typeSer)
+        throws IOException
+    {
+        // 15-Feb-2018, tatu: Note! In some cases `handledType` is base type, and not necessarily
+        //    actual specific value type (f.ex. nio.Path)
+        WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,
+                typeSer.typeId(value, handledType(), JsonToken.VALUE_STRING));
+        serialize(value, g, provider);
+        typeSer.writeTypeSuffix(g, typeIdDef);
+    }
+
+    @Override
+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
+    {
+        visitStringFormat(visitor, typeHint);
+    }
+}
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java
index 55077975a..427698bf9 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java
@@ -19,13 +19,12 @@ import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
  */
 @JacksonStdImpl
 public final class StringSerializer
-// NOTE: generic parameter changed from String to Object in 2.6, to avoid
-//   use of bridge methods
-// In 2.9, removed use of intermediate type `NonTypedScalarSerializerBase`
     extends StdScalarSerializer<Object>
 {
     private static final long serialVersionUID = 1L;
 
+    public final static StringSerializer instance = new StringSerializer();
+    
     public StringSerializer() { super(String.class, false); }
 
     @Override
diff --git a/src/test/java/com/fasterxml/jackson/databind/ext/TestJava7Types.java b/src/test/java/com/fasterxml/jackson/databind/ext/TestJava7Types.java
index 81933bae4..a8befd6db 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestJava7Types.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJava7Types.java
@@ -6,9 +6,6 @@ import java.nio.file.Paths;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;
 
-/**
- * @since 2.7
- */
 public class TestJava7Types extends BaseMapTest
 {
     public void testPathRoundtrip() throws Exception
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/JDKTypeSerializationTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
index 80ba8c8ff..82005a526 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
@@ -79,10 +79,11 @@ public class JDKTypeSerializationTest
     public void testLocale() throws IOException
     {
         assertEquals(quote("en"), MAPPER.writeValueAsString(new Locale("en")));
-        assertEquals(quote("es_ES"), MAPPER.writeValueAsString(new Locale("es", "ES")));
-        assertEquals(quote("fi_FI_savo"), MAPPER.writeValueAsString(new Locale("FI", "fi", "savo")));
+        assertEquals(quote("es-ES"), MAPPER.writeValueAsString(new Locale("es", "ES")));
+        // 15-Feb-2017, tatu: wrt [databind#1600], can only assume this is expected...
+        assertEquals(quote("fi-FI-x-lvariant-savo"), MAPPER.writeValueAsString(new Locale("FI", "fi", "savo")));
 
-        assertEquals(quote("en_US"), MAPPER.writeValueAsString(Locale.US));
+        assertEquals(quote("en-US"), MAPPER.writeValueAsString(Locale.US));
 
         // [databind#1123]
         assertEquals(quote(""), MAPPER.writeValueAsString(Locale.ROOT));
