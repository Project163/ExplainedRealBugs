diff --git a/release-notes/VERSION b/release-notes/VERSION
index 01c96933b..374dee27b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -111,6 +111,8 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #5025: Add support for automatic detection of subtypes (like `@JsonSubTypes`)
   from Java 17 sealed types
  (contributed by Andy B
+#5034: Extend, improve set of `JsonNode.asXxx()` methods for non-number
+  types (Boolean, String)
 - Remove `MappingJsonFactory`
 - Add context parameter for `TypeSerializer` contextualization (`forProperty()`)
 - Default for `JsonNodeFeature.STRIP_TRAILING_BIGDECIMAL_ZEROES` changed to `false` for 3.0
diff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java
index 1303776c6..08323616d 100644
--- a/src/main/java/tools/jackson/databind/JsonNode.java
+++ b/src/main/java/tools/jackson/databind/JsonNode.java
@@ -584,27 +584,35 @@ public abstract class JsonNode
     }
 
     /**
-     * Method that will return a valid String representation of
-     * the contained value, if the node is a value node
-     * (method {@link #isValueNode} returns true),
-     * otherwise empty String.
+     * Method that will try to convert value of this node to a {@code String}.
+     * JSON Strings map naturally; other scalars map to their string representation
+     * (including Binary data as Base64 encoded String);
+     * JSON {@code null}s map to empty String.
+     * Other values (including structured types like Objects and Arrays, and "missing"
+     * value) will result in a {@link JsonNodeException} being thrown.
      *<p>
      * NOTE: this is NOT same as {@link #toString()} in that result is
-     * <p>NOT VALID ENCODED JSON</p> for all nodes (but is for some, like
+     * <p>NOT VALID ENCODED JSON</p> for all nodes (although is for some, like
      * {@code NumberNode}s and {@code BooleanNode}s).
+     *
+     * @return String representation of this node, if coercible; exception otherwise
+     *
+     * @throws JsonNodeException if node cannot be coerced to a {@code String}
      */
     public abstract String asString();
 
     /**
-     * Returns the text value of this node or the provided {@code defaultValue} if this node
-     * does not have a text value. Useful for nodes that are {@link MissingNode} or
-     * {@link tools.jackson.databind.node.NullNode}, ensuring a default value is returned instead of null or missing indicators.
-     *
-     * @param defaultValue The default value to return if this node's text value is absent.
-     * @return The text value of this node, or {@code defaultValue} if the text value is absent.
+     * Similar to {@link #asString()}, but instead of throwing an exception for
+     * non-coercible values, will return specified default value.
      */
     public abstract String asString(String defaultValue);
 
+    /**
+     * Similar to {@link #asString()}, but instead of throwing an exception for
+     * non-coercible values, will return {@code Optional.empty()}.
+     */
+    public abstract Optional<String> asStringOpt();
+
     /**
      * @deprecated Use {@link #asString()} instead.
      */
@@ -672,29 +680,31 @@ public abstract class JsonNode
     public abstract Optional<Boolean> booleanValueOpt();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>boolean</b>.
-     * JSON booleans map naturally; integer numbers other than 0 map to true, and
-     * 0 maps to false
+     * Method that will try to convert value of this node to a Java {@code boolean}.
+     * JSON Booleans map naturally; Integer numbers other than 0 map to true, and
+     * 0 maps to false; {@code null} maps to false
      * and Strings 'true' and 'false' map to corresponding values.
-     *<p>
-     * If representation cannot be converted to a boolean value (including structured types
-     * like Objects and Arrays),
-     * default value of <b>false</b> will be returned; no exceptions are thrown.
+     * Other values (including structured types like Objects and Arrays) will
+     * result in a {@link JsonNodeException} being thrown.
+     *
+     * @return Boolean value this node represents, if coercible; exception otherwise
+     *
+     * @throws JsonNodeException if node cannot be coerced to a Java {@code boolean}
      */
     public abstract boolean asBoolean();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>boolean</b>.
-     * JSON booleans map naturally; integer numbers other than 0 map to true, and
-     * 0 maps to false
-     * and Strings 'true' and 'false' map to corresponding values.
-     *<p>
-     * If representation cannot be converted to a boolean value (including structured types
-     * like Objects and Arrays),
-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.
+     * Similar to {@link #asBoolean()}, but instead of throwing an exception for
+     * non-coercible values, will return specified default value.
      */
     public abstract boolean asBoolean(boolean defaultValue);
 
+    /**
+     * Similar to {@link #asBoolean()}, but instead of throwing an exception for
+     * non-coercible values, will return {@code Optional.empty()}.
+     */
+    public abstract Optional<Boolean> asBooleanOpt();
+
     // // Scalar access: Numbers, generic
 
     /**
diff --git a/src/main/java/tools/jackson/databind/deser/jdk/ThreadGroupDeserializer.java b/src/main/java/tools/jackson/databind/deser/jdk/ThreadGroupDeserializer.java
index 4607a7441..1b9d5503c 100644
--- a/src/main/java/tools/jackson/databind/deser/jdk/ThreadGroupDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/jdk/ThreadGroupDeserializer.java
@@ -19,10 +19,7 @@ public class ThreadGroupDeserializer
 
     @Override
     public ThreadGroup convert(JsonNode root, DeserializationContext ctxt) {
-        String name = root.path("name").asString();
-        if (name == null) {
-            name = "";
-        }
+        String name = root.path("name").asString("");
         return new ThreadGroup(name);
     }
 }
diff --git a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
index a8792ef83..b14fe89bb 100644
--- a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
+++ b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
@@ -32,6 +32,9 @@ public abstract class BaseJsonNode
 {
     private static final long serialVersionUID = 3L;
 
+    protected final static Optional<Boolean> OPT_FALSE = Optional.of(false);
+    protected final static Optional<Boolean> OPT_TRUE = Optional.of(true);
+
     // Simplest way is by using a helper
     Object writeReplace() {
         return NodeSerialization.from(this);
@@ -199,7 +202,8 @@ public abstract class BaseJsonNode
 
     @Override
     public boolean booleanValue() {
-        return _reportCoercionFail("booleanValue()", Boolean.TYPE, "value type not boolean");
+        return _reportCoercionFail("booleanValue()", Boolean.TYPE,
+                "value type not boolean");
     }
 
     @Override
@@ -216,17 +220,36 @@ public abstract class BaseJsonNode
 
     @Override
     public boolean asBoolean() {
-        return asBoolean(false);
+        Boolean b = _asBoolean();
+        if (b == null) {
+            return _reportCoercionFail("asBoolean()", Boolean.TYPE,
+                    "value type not coercible to `boolean`");
+        }
+        return b;
     }
 
     @Override
     public boolean asBoolean(boolean defaultValue) {
-        return defaultValue;
+        Boolean b = _asBoolean();
+        if (b == null) {
+            return defaultValue;
+        }
+        return b;
+    }
+
+    @Override
+    public Optional<Boolean> asBooleanOpt() {
+        Boolean b = _asBoolean();
+        if (b == null) {
+            return Optional.empty();
+        }
+        return b.booleanValue() ? OPT_TRUE : OPT_FALSE;
     }
 
     @Override
     public String stringValue() {
-        return _reportCoercionFail("stringValue()", String.class, "value type not String");
+        return _reportCoercionFail("stringValue()", String.class,
+                "value type not String");
     }
 
     @Override
@@ -241,10 +264,28 @@ public abstract class BaseJsonNode
         return Optional.empty();
     }
 
+    @Override
+    public String asString() {
+        String str = _asString();
+        if (str == null) {
+            return _reportCoercionFail("asString()", String.class,
+                    "value type not coercible to `String`");
+        }
+        return str;
+    }
+
     @Override
     public String asString(String defaultValue) {
-        String str = asString();
-        return (str == null) ? defaultValue : str;
+        String str = _asString();
+        if (str == null) {
+            return defaultValue;
+        }
+        return str;
+    }
+
+    @Override
+    public Optional<String> asStringOpt() {
+        return Optional.ofNullable(_asString());
     }
 
     /*
@@ -264,7 +305,8 @@ public abstract class BaseJsonNode
     }
 
     // Also, force (re)definition
-    @Override public abstract int hashCode();
+    @Override
+    public abstract int hashCode();
 
     /*
     /**********************************************************************
@@ -417,6 +459,36 @@ public abstract class BaseJsonNode
         return null;
     }
 
+    /*
+    /**********************************************************************
+    /* asXxx() helper methods for sub-classes to implement
+    /**********************************************************************
+     */
+
+    /**
+     * Method sub-classes should override if they can produce {@code boolean}
+     * values via {@link #asBoolean()} -- if not, return {@code null} (in which
+     * case appropriate error will be thrown or default value returned).
+     *
+     * @return Coerced value if possible; otherwise {@code null} to indicate this
+     *     node cannot be coerced.
+     */
+    protected Boolean _asBoolean() {
+        return null;
+    }
+
+    /**
+     * Method sub-classes should override if they can produce {@code String}
+     * values via {@link #asString()} -- if not, return {@code null} (in which
+     * case appropriate error will be thrown or default value returned).
+     *
+     * @return Coerced value if possible; otherwise {@code null} to indicate this
+     *     node cannot be coerced.
+     */
+    protected String _asString() {
+        return null;
+    }
+
     /*
     /**********************************************************************
     /* JacksonSerializable
diff --git a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
index 96efa2d21..05958e85e 100644
--- a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
+++ b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
@@ -75,7 +75,17 @@ public class BigIntegerNode
     /* Overridden JsonNode methods, scalar access
     /**********************************************************************
      */
-    
+
+    @Override
+    protected Boolean _asBoolean() {
+        return !BigInteger.ZERO.equals(_value);
+    }
+
+    @Override
+    public String _asString() {
+        return _value.toString();
+    }
+
     @Override
     public Number numberValue() {
         return _value;
@@ -185,22 +195,6 @@ public class BigIntegerNode
         return Optional.of(new BigDecimal(_value));
     }
 
-    /*
-    /**********************************************************
-    /* General type coercions
-    /**********************************************************
-     */
-
-    @Override
-    public String asString() {
-        return _value.toString();
-    }
-
-    @Override
-    public boolean asBoolean(boolean defaultValue) {
-        return !BigInteger.ZERO.equals(_value);
-    }
-
     /*
     /**********************************************************
     /* Other overrides
diff --git a/src/main/java/tools/jackson/databind/node/BinaryNode.java b/src/main/java/tools/jackson/databind/node/BinaryNode.java
index c53e17ac8..ce8be58f4 100644
--- a/src/main/java/tools/jackson/databind/node/BinaryNode.java
+++ b/src/main/java/tools/jackson/databind/node/BinaryNode.java
@@ -107,7 +107,7 @@ public class BinaryNode
      * but will work correctly.
      */
     @Override
-    public String asString() {
+    protected String _asString() {
         return Base64Variants.getDefaultVariant().encode(_data, false);
     }
 
diff --git a/src/main/java/tools/jackson/databind/node/BooleanNode.java b/src/main/java/tools/jackson/databind/node/BooleanNode.java
index 31306a9a0..d7293bbe1 100644
--- a/src/main/java/tools/jackson/databind/node/BooleanNode.java
+++ b/src/main/java/tools/jackson/databind/node/BooleanNode.java
@@ -19,9 +19,6 @@ public class BooleanNode
 
     public final static BooleanNode TRUE = new BooleanNode(true);
     public final static BooleanNode FALSE = new BooleanNode(false);
-
-    private final static Optional<Boolean> OPT_FALSE = Optional.of(false);
-    private final static Optional<Boolean> OPT_TRUE = Optional.of(true);
     
     private final boolean _value;
 
@@ -72,31 +69,48 @@ public class BooleanNode
     /**********************************************************************
      */
 
+    // // // Override "asBoolean()" methods as minor optimization
+    
     @Override
-    public boolean booleanValue() {
+    public final boolean asBoolean() {
         return _value;
     }
 
     @Override
-    public boolean booleanValue(boolean defaultValue) {
+    public final boolean asBoolean(boolean defaultValue) {
         return _value;
     }
 
     @Override
-    public Optional<Boolean> booleanValueOpt() {
+    public Optional<Boolean> asBooleanOpt() {
         return _value ? OPT_TRUE : OPT_FALSE;
     }
+    
+    @Override
+    protected Boolean _asBoolean() {
+        return _value;
+    }
 
     @Override
-    public boolean asBoolean() {
+    public boolean booleanValue() {
         return _value;
     }
 
     @Override
-    public boolean asBoolean(boolean defaultValue) {
+    public boolean booleanValue(boolean defaultValue) {
         return _value;
     }
 
+    @Override
+    public Optional<Boolean> booleanValueOpt() {
+        return _value ? OPT_TRUE : OPT_FALSE;
+    }
+
+    @Override
+    protected String _asString() {
+        return _value ? "true" : "false";
+    }
+    
     @Override
     public int asInt(int defaultValue) {
         return _value ? 1 : 0;
@@ -110,11 +124,6 @@ public class BooleanNode
         return _value ? 1.0 : 0.0;
     }
 
-    @Override
-    public String asString() {
-        return _value ? "true" : "false";
-    }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, other
diff --git a/src/main/java/tools/jackson/databind/node/ContainerNode.java b/src/main/java/tools/jackson/databind/node/ContainerNode.java
index 979ac5c81..b7d490f4e 100644
--- a/src/main/java/tools/jackson/databind/node/ContainerNode.java
+++ b/src/main/java/tools/jackson/databind/node/ContainerNode.java
@@ -43,9 +43,6 @@ public abstract class ContainerNode<T extends ContainerNode<T>>
     @Override
     public abstract JsonToken asToken();
 
-    @Override
-    public String asString() { return ""; }
-
     /*
     /**********************************************************************
     /* Methods reset as abstract to force real implementation
diff --git a/src/main/java/tools/jackson/databind/node/DecimalNode.java b/src/main/java/tools/jackson/databind/node/DecimalNode.java
index 7407c69f9..520d979a1 100644
--- a/src/main/java/tools/jackson/databind/node/DecimalNode.java
+++ b/src/main/java/tools/jackson/databind/node/DecimalNode.java
@@ -83,6 +83,11 @@ public class DecimalNode
     /**********************************************************************
      */
 
+    @Override
+    public String _asString() {
+        return _value.toString();
+    }
+    
     @Override
     public Number numberValue() { return _value; }
 
@@ -204,11 +209,6 @@ public class DecimalNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(_value); }
 
-    @Override
-    public String asString() {
-        return _value.toString();
-    }
-
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
diff --git a/src/main/java/tools/jackson/databind/node/DoubleNode.java b/src/main/java/tools/jackson/databind/node/DoubleNode.java
index c12ab0b08..09622145d 100644
--- a/src/main/java/tools/jackson/databind/node/DoubleNode.java
+++ b/src/main/java/tools/jackson/databind/node/DoubleNode.java
@@ -74,6 +74,11 @@ public class DoubleNode
     /**********************************************************************
      */
 
+    @Override
+    protected String _asString() {
+        return String.valueOf(_value);
+    }
+    
     @Override
     public Number numberValue() {
         return Double.valueOf(_value);
@@ -181,11 +186,6 @@ public class DoubleNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
-    @Override
-    public String asString() {
-        return String.valueOf(_value);
-    }
-
     @Override
     public boolean isNaN() {
         return NumberOutput.notFinite(_value);
diff --git a/src/main/java/tools/jackson/databind/node/FloatNode.java b/src/main/java/tools/jackson/databind/node/FloatNode.java
index 3e16d5320..d2af6926c 100644
--- a/src/main/java/tools/jackson/databind/node/FloatNode.java
+++ b/src/main/java/tools/jackson/databind/node/FloatNode.java
@@ -67,6 +67,11 @@ public class FloatNode extends NumericNode
     /**********************************************************************
      */
 
+    @Override
+    protected String _asString() {
+        return String.valueOf(_value);
+    }
+
     @Override
     public Number numberValue() {
         return Float.valueOf(_value);
@@ -167,11 +172,6 @@ public class FloatNode extends NumericNode
 
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
-    
-    @Override
-    public String asString() {
-        return String.valueOf(_value);
-    }
 
     @Override
     public boolean isNaN() {
diff --git a/src/main/java/tools/jackson/databind/node/IntNode.java b/src/main/java/tools/jackson/databind/node/IntNode.java
index b51486b65..33940fc7d 100644
--- a/src/main/java/tools/jackson/databind/node/IntNode.java
+++ b/src/main/java/tools/jackson/databind/node/IntNode.java
@@ -79,6 +79,16 @@ public class IntNode
     /**********************************************************************
      */
 
+    @Override
+    protected Boolean _asBoolean() {
+        return (_value != 0);
+    }
+
+    @Override
+    protected String _asString() {
+        return String.valueOf(_value);
+    }
+    
     @Override
     public Number numberValue() {
         return Integer.valueOf(_value);
@@ -140,16 +150,6 @@ public class IntNode
     @Override
     public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
-    @Override
-    public String asString() {
-        return String.valueOf(_value);
-    }
-
-    @Override
-    public boolean asBoolean(boolean defaultValue) {
-        return _value != 0;
-    }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, other
@@ -163,6 +163,12 @@ public class IntNode
         g.writeNumber(_value);
     }
 
+    /*
+    /**********************************************************************
+    /* Overridden standard methods
+    /**********************************************************************
+     */
+    
     @Override
     public boolean equals(Object o)
     {
diff --git a/src/main/java/tools/jackson/databind/node/LongNode.java b/src/main/java/tools/jackson/databind/node/LongNode.java
index cc33d881f..669a46ca6 100644
--- a/src/main/java/tools/jackson/databind/node/LongNode.java
+++ b/src/main/java/tools/jackson/databind/node/LongNode.java
@@ -61,7 +61,17 @@ public class LongNode
     /* Overridden JsonNode methods, scalar access
     /**********************************************************************
      */
-    
+
+    @Override
+    protected Boolean _asBoolean() {
+        return (_value != 0L);
+    }
+
+    @Override
+    protected String _asString() {
+        return String.valueOf(_value);
+    }
+
     @Override
     public Number numberValue() {
         return Long.valueOf(_value);
@@ -130,15 +140,11 @@ public class LongNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
-    @Override
-    public String asString() {
-        return String.valueOf(_value);
-    }
-
-    @Override
-    public boolean asBoolean(boolean defaultValue) {
-        return _value != 0;
-    }
+    /*
+    /**********************************************************************
+    /* Overridden methods, other
+    /**********************************************************************
+     */
 
     @Override
     public final void serialize(JsonGenerator jg, SerializationContext provider)
@@ -146,7 +152,7 @@ public class LongNode
     {
         jg.writeNumber(_value);
     }
-
+    
     @Override
     public boolean equals(Object o)
     {
diff --git a/src/main/java/tools/jackson/databind/node/MissingNode.java b/src/main/java/tools/jackson/databind/node/MissingNode.java
index 3224fd3b1..722c6519e 100644
--- a/src/main/java/tools/jackson/databind/node/MissingNode.java
+++ b/src/main/java/tools/jackson/databind/node/MissingNode.java
@@ -56,10 +56,6 @@ public final class MissingNode
     protected String _valueDesc() {
         return "<missing>";
     }
-    
-    @Override public String asString() { return ""; }
-
-    @Override public String asString(String defaultValue) { return defaultValue; }
 
     // // Note: not a numeric node, hence default 'asXxx()' are fine:
 
diff --git a/src/main/java/tools/jackson/databind/node/NullNode.java b/src/main/java/tools/jackson/databind/node/NullNode.java
index 49d754b41..01efb194b 100644
--- a/src/main/java/tools/jackson/databind/node/NullNode.java
+++ b/src/main/java/tools/jackson/databind/node/NullNode.java
@@ -36,15 +36,26 @@ public class NullNode
     @Override
     public NullNode deepCopy() { return this; }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access
+    /**********************************************************************
+     */
+
     @Override
-    protected String _valueDesc() {
-        return "<null>";
+    protected Boolean _asBoolean() {
+        return Boolean.FALSE;
     }
-    
+
     @Override
-    public String asString(String defaultValue) { return defaultValue; }
+    protected String _asString() {
+        return "";
+    }
 
-    @Override public String asString() { return "null"; }
+    @Override
+    protected String _valueDesc() {
+        return "<null>";
+    }
 
     @SuppressWarnings("unchecked")
     @Override
diff --git a/src/main/java/tools/jackson/databind/node/NumericNode.java b/src/main/java/tools/jackson/databind/node/NumericNode.java
index 5d0ede77d..163731a1b 100644
--- a/src/main/java/tools/jackson/databind/node/NumericNode.java
+++ b/src/main/java/tools/jackson/databind/node/NumericNode.java
@@ -74,7 +74,7 @@ public abstract class NumericNode
      */
 
     @Override
-    public abstract String asString();
+    protected abstract String _asString();
 
     @Override
     public final int asInt() {
diff --git a/src/main/java/tools/jackson/databind/node/POJONode.java b/src/main/java/tools/jackson/databind/node/POJONode.java
index 73abc6c4f..5d56a687d 100644
--- a/src/main/java/tools/jackson/databind/node/POJONode.java
+++ b/src/main/java/tools/jackson/databind/node/POJONode.java
@@ -3,6 +3,7 @@ package tools.jackson.databind.node;
 import java.util.Objects;
 
 import tools.jackson.core.*;
+
 import tools.jackson.databind.JacksonSerializable;
 import tools.jackson.databind.SerializationContext;
 import tools.jackson.databind.util.ClassUtil;
@@ -43,20 +44,6 @@ public class POJONode
     @Override
     public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }
 
-    /**
-     * As it is possible that some implementations embed byte[] as POJONode
-     * (despite optimal being {@link BinaryNode}), let's add support for exposing
-     * binary data here too.
-     */
-    @Override
-    public byte[] binaryValue()
-    {
-        if (_value instanceof byte[]) {
-            return (byte[]) _value;
-        }
-        return super.binaryValue();
-    }
-
     /*
     /**********************************************************************
     /* General type coercions
@@ -64,20 +51,25 @@ public class POJONode
      */
 
     @Override
-    public String asString() { return (_value == null) ? "null" : _value.toString(); }
-
-    @Override
-    public String asString(String defaultValue) {
-        return (_value == null) ? defaultValue : _value.toString();
+    protected Boolean _asBoolean()
+    {
+        if (_value == null) {
+            return Boolean.FALSE;
+        }
+        if (_value instanceof Boolean B) {
+            return B;
+        }
+        return null;
     }
 
     @Override
-    public boolean asBoolean(boolean defaultValue)
-    {
-        if (_value instanceof Boolean) {
-            return ((Boolean) _value).booleanValue();
+    protected String _asString() {
+        if (_value instanceof String str) {
+             return str;
         }
-        return defaultValue;
+        // 21-Mar-2025, tatu: [databind#5034] Should we consider RawValue too?
+        //    (for now, won't)
+        return null;
     }
 
     @Override
@@ -107,6 +99,20 @@ public class POJONode
         return defaultValue;
     }
 
+    /**
+     * As it is possible that some implementations embed byte[] as POJONode
+     * (despite optimal being {@link BinaryNode}), let's add support for exposing
+     * binary data here too.
+     */
+    @Override
+    public byte[] binaryValue()
+    {
+        if (_value instanceof byte[]) {
+            return (byte[]) _value;
+        }
+        return super.binaryValue();
+    }
+
     /*
     /**********************************************************************
     /* Public API, serialization
diff --git a/src/main/java/tools/jackson/databind/node/ShortNode.java b/src/main/java/tools/jackson/databind/node/ShortNode.java
index 52e43504a..4164f94e5 100644
--- a/src/main/java/tools/jackson/databind/node/ShortNode.java
+++ b/src/main/java/tools/jackson/databind/node/ShortNode.java
@@ -62,6 +62,16 @@ public class ShortNode
     /**********************************************************************
      */
 
+    @Override
+    protected Boolean _asBoolean() {
+        return _value != 0;
+    }
+
+    @Override
+    protected String _asString() {
+        return String.valueOf(_value);
+    }
+
     @Override
     public Number numberValue() {
         return Short.valueOf(_value);
@@ -118,16 +128,12 @@ public class ShortNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
-    @Override
-    public String asString() {
-        return String.valueOf(_value);
-    }
-
-    @Override
-    public boolean asBoolean(boolean defaultValue) {
-        return _value != 0;
-    }
-
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, other
+    /**********************************************************************
+     */
+    
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
diff --git a/src/main/java/tools/jackson/databind/node/StringNode.java b/src/main/java/tools/jackson/databind/node/StringNode.java
index 74adebf03..660f67393 100644
--- a/src/main/java/tools/jackson/databind/node/StringNode.java
+++ b/src/main/java/tools/jackson/databind/node/StringNode.java
@@ -7,6 +7,7 @@ import tools.jackson.core.*;
 import tools.jackson.core.io.NumberInput;
 import tools.jackson.core.util.ByteArrayBuilder;
 import tools.jackson.databind.SerializationContext;
+import tools.jackson.databind.exc.JsonNodeException;
 
 /**
  * Value node that contains a String value.
@@ -70,6 +71,17 @@ public class StringNode
     /**********************************************************************
      */
 
+    @Override
+    public Boolean _asBoolean() {
+        if ("true".equals(_value)) {
+            return Boolean.TRUE;
+        }
+        if ("false".equals(_value)) {
+            return Boolean.FALSE;
+        }
+        return null;
+    }
+
     @Override
     public String stringValue() {
         return _value;
@@ -85,38 +97,13 @@ public class StringNode
         return Optional.of(_value);
     }
 
-    /**
-     * Method for accessing content String assuming they were
-     * base64 encoded; if so, content is decoded and resulting binary
-     * data is returned.
-     *
-     * @throws JacksonException if String contents are not valid Base64 encoded content
-     */
-    @SuppressWarnings("resource")
-    public byte[] getBinaryValue(Base64Variant b64variant) throws JacksonException
-    {
-        final String str = _value.trim();
-        // 04-Sep-2020, tatu: Let's limit the size of the initial block to 64k,
-        //    no point in trying to exactly match the size beyond certain point
-        // (plus it could even lead to unnecessarily high retention with block
-        // recycling)
-        final int initBlockSize = 4 + ((str.length() >> 2) * 3);
-        ByteArrayBuilder builder = new ByteArrayBuilder(Math.max(16,
-                Math.min(0x10000, initBlockSize)));
-        try {
-            b64variant.decode(str, builder);
-        } catch (IllegalArgumentException e) {
-            return _reportCoercionFail("binaryValue()", byte[].class,
-                    "value type not binary and Base64-decoding failed with: "+e.getMessage());
-        }
-        return builder.toByteArray();
-    }
-
     @Override
-    public byte[] binaryValue() throws JacksonException {
-        return getBinaryValue(Base64Variants.getDefaultVariant());
+    protected String _asString() {
+        return _value;
     }
 
+    // Directly override "asText()" variants as minor optimization
+
     @Override
     public String asString() {
         return _value;
@@ -127,18 +114,9 @@ public class StringNode
         return _value;
     }
 
-    // note: neither fast nor elegant, but these work for now:
-
     @Override
-    public boolean asBoolean(boolean defaultValue) {
-        String v = _value.trim();
-        if ("true".equals(v)) {
-            return true;
-        }
-        if ("false".equals(v)) {
-            return false;
-        }
-        return defaultValue;
+    public Optional<String> asStringOpt() {
+        return Optional.of(_value);
     }
 
     @Override
@@ -156,6 +134,38 @@ public class StringNode
         return NumberInput.parseAsDouble(_value, defaultValue, false);
     }
 
+    /**
+     * Method for accessing content String assuming they were
+     * base64 encoded; if so, content is decoded and resulting binary
+     * data is returned.
+     *
+     * @throws JsonNodeException if String contents are not valid Base64 encoded content
+     */
+    @SuppressWarnings("resource")
+    public byte[] getBinaryValue(Base64Variant b64variant) throws JacksonException
+    {
+        final String str = _value.trim();
+        // 04-Sep-2020, tatu: Let's limit the size of the initial block to 64k,
+        //    no point in trying to exactly match the size beyond certain point
+        // (plus it could even lead to unnecessarily high retention with block
+        // recycling)
+        final int initBlockSize = 4 + ((str.length() >> 2) * 3);
+        ByteArrayBuilder builder = new ByteArrayBuilder(Math.max(16,
+                Math.min(0x10000, initBlockSize)));
+        try {
+            b64variant.decode(str, builder);
+        } catch (IllegalArgumentException e) {
+            return _reportCoercionFail("binaryValue()", byte[].class,
+                    "value type not binary and Base64-decoding failed with: "+e.getMessage());
+        }
+        return builder.toByteArray();
+    }
+
+    @Override
+    public byte[] binaryValue() throws JacksonException {
+        return getBinaryValue(Base64Variants.getDefaultVariant());
+    }
+
     /*
     /**********************************************************************
     /* Serialization
diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
index d974c80d3..1a8fc01bb 100644
--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
@@ -192,7 +192,9 @@ public class ArrayNodeTest
         assertEquals(20, array.size());
         for (int i = 0; i < 20; i++) {
             if (i <= 18) {
-                assertNotEquals("Original Data", array.get(i).asString());
+                if (i != 1) { // in 3.0, RawValue not convertible to String
+                    assertNotEquals("Original Data", array.get(i).asString());
+                }
             } else {
                 assertEquals("Original Data", array.get(i).stringValue());
             }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java
index 8672f1c51..692fa574a 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java
@@ -15,7 +15,8 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.*;
 
 /**
- * Tests for [databind#4958], JsonNode.numberValue()
+ * Tests for [databind#4958], {@code JsonNode.booleanValue()}
+ * and [databind#5034], {@code JsonNode.asBoolean()}
  * over all node types.
  */
 public class JsonNodeBooleanValueTest
@@ -23,55 +24,154 @@ public class JsonNodeBooleanValueTest
 {
     private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
 
+    // // // booleanValue(), variants
+
     @Test
-    public void booleanValueSuccess()
+    public void booleanValueOkFromBoolean()
     {
-        assertEquals(true, NODES.booleanNode(true).booleanValue());
-        assertEquals(true, NODES.booleanNode(true).booleanValue(false));
-        assertEquals(true, NODES.booleanNode(true).booleanValueOpt().get());
-        assertEquals(false, NODES.booleanNode(false).booleanValue());
-        assertEquals(false, NODES.booleanNode(false).booleanValue(true));
-        assertEquals(false, NODES.booleanNode(false).booleanValueOpt().get());
+        _assertFalseFromBooleanValue(NODES.booleanNode(false));
+        _assertTrueFromBooleanValue(NODES.booleanNode(true));
     }
-
+    
     @Test
-    public void booleanValueFailFromNumbers()
+    public void booleanValueFailFromNumbersInt()
     {
-        _assertFailForNonBoolean(NODES.numberNode((byte) 1));
-        _assertFailForNonBoolean(NODES.numberNode((short) 2));
-        _assertFailForNonBoolean(NODES.numberNode(3));
-        _assertFailForNonBoolean(NODES.numberNode(4L));
-        _assertFailForNonBoolean(NODES.numberNode(BigInteger.valueOf(5)));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode((byte) 1));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode((short) 2));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(3));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(4L));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(BigInteger.valueOf(5)));
+    }
 
-        _assertFailForNonBoolean(NODES.numberNode(0.25f));
-        _assertFailForNonBoolean(NODES.numberNode(-2.125d));
-        _assertFailForNonBoolean(NODES.numberNode(new BigDecimal("0.1")));
+    @Test
+    public void booleanValueFailFromNumbersFloat()
+    {
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(0.25f));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(-2.125d));
+        _assertFailBooleanValueForNonBoolean(NODES.numberNode(new BigDecimal("0.1")));
     }
 
     @Test
     public void booleanValueFailFromNonNumberScalars()
     {
-        _assertFailForNonBoolean(NODES.binaryNode(new byte[3]));
-        _assertFailForNonBoolean(NODES.stringNode("123"));
-        _assertFailForNonBoolean(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailForNonBoolean(NODES.pojoNode(new AtomicInteger(1)));
+        _assertFailBooleanValueForNonBoolean(NODES.binaryNode(new byte[3]));
+        _assertFailBooleanValueForNonBoolean(NODES.stringNode("123"));
+        _assertFailBooleanValueForNonBoolean(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailBooleanValueForNonBoolean(NODES.pojoNode(new AtomicInteger(1)));
+    }
+
+    @Test
+    public void booleanValueFailFromStructural()
+    {
+        _assertFailBooleanValueForNonBoolean(NODES.arrayNode(3));
+        _assertFailBooleanValueForNonBoolean(NODES.objectNode());
+    }
+
+    @Test
+    public void booleanValueFailFromNonNumberMisc()
+    {
+        _assertFailBooleanValueForNonBoolean(NODES.nullNode());
+        _assertFailBooleanValueForNonBoolean(NODES.missingNode());
+    }
+
+    // // // asBoolean(), variants
+
+    @Test
+    public void asBooleanOkFromBoolean()
+    {
+        _assertFalseFromAsBoolean(NODES.booleanNode(false));
+        _assertTrueFromAsBoolean(NODES.booleanNode(true));
+    }
+
+    @Test
+    public void asBooleanOkFromNumbersInt()
+    {
+        _assertFalseFromAsBoolean(NODES.numberNode((byte) 0));
+        _assertTrueFromAsBoolean(NODES.numberNode((byte) 1));
+        _assertTrueFromAsBoolean(NODES.numberNode((byte) -1));
+        _assertFalseFromAsBoolean(NODES.numberNode((short) 0));
+        _assertTrueFromAsBoolean(NODES.numberNode((short) 1));
+        _assertTrueFromAsBoolean(NODES.numberNode((short) 2));
+        _assertFalseFromAsBoolean(NODES.numberNode(0));
+        _assertTrueFromAsBoolean(NODES.numberNode(1));
+        _assertTrueFromAsBoolean(NODES.numberNode(-15));
+        _assertFalseFromAsBoolean(NODES.numberNode(0L));
+        _assertTrueFromAsBoolean(NODES.numberNode(1L));
+        _assertTrueFromAsBoolean(NODES.numberNode(2L));
+        _assertFalseFromAsBoolean(NODES.numberNode(BigInteger.ZERO));
+        _assertTrueFromAsBoolean(NODES.numberNode(BigInteger.ONE));
+        _assertTrueFromAsBoolean(NODES.numberNode(BigInteger.TEN));
+    }
+
+    @Test
+    public void asBooleanFailFromNumbersFloat()
+    {
+        _assertFailAsBooleanForNonBoolean(NODES.numberNode(0.25f));
+        _assertFailAsBooleanForNonBoolean(NODES.numberNode(-2.125d));
+        _assertFailAsBooleanForNonBoolean(NODES.numberNode(new BigDecimal("0.1")));
     }
 
     @Test
-    public void numberValueFromStructural()
+    public void asBooleanFromNonNumberScalars()
+    {
+        _assertFailAsBooleanForNonBoolean(NODES.binaryNode(new byte[3]));
+
+        // 2 String values are ok; others not
+        _assertFalseFromAsBoolean(NODES.stringNode("false"));
+        _assertTrueFromAsBoolean(NODES.stringNode("true"));
+        _assertFailAsBooleanForNonBoolean(NODES.stringNode("123"));
+
+        _assertFailAsBooleanForNonBoolean(NODES.rawValueNode(new RawValue("true")));
+        // POJONode can also succeed but only from `Boolean`
+        _assertFailAsBooleanForNonBoolean(NODES.pojoNode(Long.valueOf(3)));
+    }
+    @Test
+    public void asBooleanFailFromStructural()
     {
-        _assertFailForNonBoolean(NODES.arrayNode(3));
-        _assertFailForNonBoolean(NODES.objectNode());
+        _assertFailAsBooleanForNonBoolean(NODES.arrayNode(3));
+        _assertFailAsBooleanForNonBoolean(NODES.objectNode());
     }
 
     @Test
-    public void numberValueFromNonNumberMisc()
+    public void asBooleanFromNonNumberMisc()
     {
-        _assertFailForNonBoolean(NODES.nullNode());
-        _assertFailForNonBoolean(NODES.missingNode());
+        // Null ok
+        _assertFalseFromAsBoolean(NODES.nullNode());
+        // And POJO node with Boolean:
+        _assertFalseFromAsBoolean(NODES.pojoNode(Boolean.FALSE));
+        _assertTrueFromAsBoolean(NODES.pojoNode(Boolean.TRUE));
+
+        // but missing not
+        _assertFailAsBooleanForNonBoolean(NODES.missingNode());
+    }
+
+    // // // Helper methods
+
+    private void _assertFalseFromBooleanValue(JsonNode n) {
+        assertEquals(false, n.booleanValue());
+        assertEquals(false, n.booleanValue(true));
+        assertEquals(false, n.booleanValueOpt().get());
+    }
+
+    private void _assertTrueFromBooleanValue(JsonNode n) {
+        assertEquals(true, n.booleanValue());
+        assertEquals(true, n.booleanValue(false));
+        assertEquals(true, n.booleanValueOpt().get());
+    }
+    
+    private void _assertFalseFromAsBoolean(JsonNode n) {
+        assertEquals(false, n.asBoolean());
+        assertEquals(false, n.asBoolean(true));
+        assertEquals(false, n.asBooleanOpt().get());
     }
 
-    private void _assertFailForNonBoolean(JsonNode node) {
+    private void _assertTrueFromAsBoolean(JsonNode n) {
+        assertEquals(true, n.asBoolean());
+        assertEquals(true, n.asBoolean(false));
+        assertEquals(true, n.asBooleanOpt().get());
+    }
+    
+    private void _assertFailBooleanValueForNonBoolean(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.booleanValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
@@ -82,7 +182,20 @@ public class JsonNodeBooleanValueTest
         // But also check defaulting
         assertFalse(node.booleanValue(false));
         assertTrue(node.booleanValue(true));
-
         assertFalse(node.booleanValueOpt().isPresent());
     }
+
+    private void _assertFailAsBooleanForNonBoolean(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asBoolean(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not coercible to `boolean`");
+
+        // But also check defaulting
+        assertFalse(node.asBoolean(false));
+        assertTrue(node.asBoolean(true));
+        assertFalse(node.asBooleanOpt().isPresent());
+    }
 }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
index 3d38b7045..a795ac4d3 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
@@ -138,6 +138,7 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
         assertEquals(1, BooleanNode.TRUE.asInt());
     }
 
+    // note: pre-[databind#5034]
     @Test
     public void testAsBoolean() throws Exception
     {
@@ -149,8 +150,6 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
         assertTrue(LongNode.valueOf(-34L).asBoolean());
         assertTrue(new StringNode("true").asBoolean());
         assertFalse(new StringNode("false").asBoolean());
-        assertFalse(new StringNode("barf").asBoolean());
-        assertTrue(new StringNode("barf").asBoolean(true));
 
         assertTrue(new POJONode(Boolean.TRUE).asBoolean());
     }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java
index 91c93e08b..24e04803a 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java
@@ -23,6 +23,8 @@ public class JsonNodeStringValueTest
 {
     private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
 
+    // // // stringValue() tests
+
     @Test
     public void stringValueSuccess()
     {
@@ -34,40 +36,91 @@ public class JsonNodeStringValueTest
     @Test
     public void stringValueFailFromNumbers()
     {
-        _assertFailForNonString(NODES.numberNode((byte) 1));
-        _assertFailForNonString(NODES.numberNode((short) 2));
-        _assertFailForNonString(NODES.numberNode(3));
-        _assertFailForNonString(NODES.numberNode(4L));
-        _assertFailForNonString(NODES.numberNode(BigInteger.valueOf(5)));
-
-        _assertFailForNonString(NODES.numberNode(0.25f));
-        _assertFailForNonString(NODES.numberNode(-2.125d));
-        _assertFailForNonString(NODES.numberNode(new BigDecimal("0.1")));
+        _assertStringValueFailForNonString(NODES.numberNode((byte) 1));
+        _assertStringValueFailForNonString(NODES.numberNode((short) 2));
+        _assertStringValueFailForNonString(NODES.numberNode(3));
+        _assertStringValueFailForNonString(NODES.numberNode(4L));
+        _assertStringValueFailForNonString(NODES.numberNode(BigInteger.valueOf(5)));
+
+        _assertStringValueFailForNonString(NODES.numberNode(0.25f));
+        _assertStringValueFailForNonString(NODES.numberNode(-2.125d));
+        _assertStringValueFailForNonString(NODES.numberNode(new BigDecimal("0.1")));
     }
 
     @Test
     public void stringValueFailFromNonNumberScalars()
     {
-        _assertFailForNonString(NODES.binaryNode(new byte[3]));
-        _assertFailForNonString(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailForNonString(NODES.pojoNode(new AtomicInteger(1)));
+        _assertStringValueFailForNonString(NODES.binaryNode(new byte[3]));
+        _assertStringValueFailForNonString(NODES.rawValueNode(new RawValue("abc")));
+        _assertStringValueFailForNonString(NODES.pojoNode(new AtomicInteger(1)));
+    }
+
+    @Test
+    public void stringValueFromStructural()
+    {
+        _assertStringValueFailForNonString(NODES.arrayNode(3));
+        _assertStringValueFailForNonString(NODES.objectNode());
+    }
+
+    @Test
+    public void stringValueFromNonNumberMisc()
+    {
+        _assertStringValueFailForNonString(NODES.nullNode());
+        _assertStringValueFailForNonString(NODES.missingNode());
+    }
+
+    // // // asString() tests
+
+    @Test
+    public void asStringSuccess()
+    {
+        _assertAsStringSuccess("abc", NODES.stringNode("abc"));
+    }
+
+    @Test
+    public void asStringFromNumbers()
+    {
+        _assertAsStringSuccess("1", NODES.numberNode((byte) 1));
+        _assertAsStringSuccess("2", NODES.numberNode((short) 2));
+        _assertAsStringSuccess("3", NODES.numberNode(3));
+        _assertAsStringSuccess("4", NODES.numberNode(4L));
+        _assertAsStringSuccess("10", NODES.numberNode(BigInteger.TEN));
+
+        _assertAsStringSuccess("0.25", NODES.numberNode(0.25f));
+        _assertAsStringSuccess("-2.125", NODES.numberNode(-2.125d));
+        _assertAsStringSuccess("0.1", NODES.numberNode(new BigDecimal("0.1")));
+    }
+
+    @Test
+    public void asStringForNonNumberScalars()
+    {
+        // Binary converted to Base64
+        _assertAsStringSuccess("AAA=", NODES.binaryNode(new byte[2]));
+        _assertAsStringSuccess("xyz", NODES.pojoNode("xyz"));
+        _assertAsStringFailForNonString(NODES.pojoNode(new AtomicInteger(1)));
+
+        // RawValue's won't convert
+        _assertAsStringFailForNonString(NODES.rawValueNode(new RawValue("abcd")));
     }
 
     @Test
-    public void numberValueFromStructural()
+    public void asStringFailForStructural()
     {
-        _assertFailForNonString(NODES.arrayNode(3));
-        _assertFailForNonString(NODES.objectNode());
+        _assertAsStringFailForNonString(NODES.arrayNode(3));
+        _assertAsStringFailForNonString(NODES.objectNode());
     }
 
     @Test
-    public void numberValueFromNonNumberMisc()
+    public void asStringFromNonNumberMisc()
     {
-        _assertFailForNonString(NODES.nullNode());
-        _assertFailForNonString(NODES.missingNode());
+        _assertAsStringSuccess("", NODES.nullNode());
+
+        _assertAsStringFailForNonString(NODES.missingNode());
     }
 
-    private void _assertFailForNonString(JsonNode node) {
+    // // // Helper methods:
+
+    private void _assertStringValueFailForNonString(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.stringValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
@@ -79,4 +132,25 @@ public class JsonNodeStringValueTest
         assertEquals("foo", node.stringValue("foo"));
         assertFalse(node.stringValueOpt().isPresent());
     }
+
+    private void _assertAsStringSuccess(String expected, JsonNode node) {
+        assertEquals(expected, node.asString());
+
+        // But also fallbacks
+        assertEquals(expected, node.asString("fallback"));
+        assertEquals(expected, node.asStringOpt().get());
+    }
+
+    private void _assertAsStringFailForNonString(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asString(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not coercible to `String`");
+
+        // But also check defaulting
+        assertEquals("foo", node.asString("foo"));
+        assertFalse(node.asStringOpt().isPresent());
+    }
 }
diff --git a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
index 5a43d72a4..cbdbe8362 100644
--- a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
@@ -18,7 +18,8 @@ public class MissingNodeTest extends NodeTestBase
         MissingNode n = MissingNode.getInstance();
         assertTrue(n.isMissingNode());
         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());
-        assertEquals("", n.asString());
+        // exception in 3.0:
+        //assertEquals("", n.asString());
         assertEquals("default", n.asString("default"));
         assertStandardEquals(n);
         // 10-Dec-2018, tatu: With 2.10, should serialize same as via ObjectMapper/ObjectWriter
diff --git a/src/test/java/tools/jackson/databind/node/NullNodeTest.java b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
index 80a46b319..69524a41d 100644
--- a/src/test/java/tools/jackson/databind/node/NullNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
@@ -46,9 +46,8 @@ public class NullNodeTest extends NodeTestBase
 
         // fallback accessors
 
-        // may be odd but...
-        assertEquals("null", n.asString());
-        assertEquals("fallback", n.asString("fallback"));
+        assertEquals("", n.asString());
+        assertEquals("", n.asString("fallback"));
 
         assertEquals(0, n.size());
         assertTrue(n.isEmpty());
@@ -63,7 +62,7 @@ public class NullNodeTest extends NodeTestBase
 
         assertNodeNumbersForNonNumeric(n);
 
-        assertEquals("null", n.asString());
+        assertEquals("", n.asString());
 
         assertNonContainerStreamMethods(n);
     }
@@ -77,7 +76,7 @@ public class NullNodeTest extends NodeTestBase
         assertTrue(n.isNull());
         assertFalse(n.isNumber());
         assertFalse(n.isString());
-        assertEquals("null", n.asString());
+        assertEquals("", n.asString()); // changed in 3.0
         assertEquals(n, NullNode.instance);
 
         n = objectMapper().readTree("null");
