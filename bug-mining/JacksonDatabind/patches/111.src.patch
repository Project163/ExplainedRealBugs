diff --git a/release-notes/VERSION b/release-notes/VERSION
index 297cae09e..bc1797f33 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -9,6 +9,8 @@ Project: jackson-databind
 #873: Add missing OSGi import
 #881: BeanDeserializerBase having issues with non-CreatorProperty properties.
  (reported by dharaburda@github)
+#884: ArrayIndexOutOfBoundException in 2.6.0
+ (reported by alterGauner@github)
 
 2.6.0 (19-Jul-2015)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java
index 2000eddb7..4b7401ca5 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java
@@ -67,11 +67,11 @@ public class BeanPropertyMap
         _size = props.size();
         
         // First: calculate size of primary hash area
-        final int size = findSize(_size);
-        _hashMask = size-1;
+        final int hashSize = findSize(_size);
+        _hashMask = hashSize-1;
 
         // and allocate enough to contain primary/secondary, expand for spillovers as need be
-        int alloc = (size + (size>>1)) * 2;
+        int alloc = (hashSize + (hashSize>>1)) * 2;
         Object[] hashed = new Object[alloc];
         int spillCount = 0;
 
@@ -88,10 +88,10 @@ public class BeanPropertyMap
             // primary slot not free?
             if (hashed[ix] != null) {
                 // secondary?
-                ix = (size + (slot >> 1)) << 1;
+                ix = (hashSize + (slot >> 1)) << 1;
                 if (hashed[ix] != null) {
                     // ok, spill over.
-                    ix = ((size + (size >> 1) ) << 1) + spillCount;
+                    ix = ((hashSize + (hashSize >> 1) ) << 1) + spillCount;
                     spillCount += 2;
                     if (ix >= hashed.length) {
                         hashed = Arrays.copyOf(hashed, hashed.length + 4);
@@ -140,8 +140,6 @@ System.err.printf("#%02d: %s\n", i>>1, (hashed[i] == null) ? "-" : hashed[i]);
      * passed as the argument.
      * Note that method does not modify this instance but constructs
      * and returns a new one.
-     * 
-     * @since 2.0
      */
     public BeanPropertyMap withProperty(SettableBeanProperty newProp)
     {
@@ -157,23 +155,33 @@ System.err.printf("#%02d: %s\n", i>>1, (hashed[i] == null) ? "-" : hashed[i]);
             }
         }
         // If not, append
-        int slot = _hashCode(key);
-        int hashSize = _hashMask+1;
-
+        final int slot = _hashCode(key);
+        final int hashSize = _hashMask+1;
+        int ix = (slot<<1);
+        
         // primary slot not free?
-        if (_hashArea[slot << 1] != null) {
+        if (_hashArea[ix] != null) {
             // secondary?
-            slot = hashSize + (slot >> 1);
-            if (_hashArea[slot << 1] != null) {
+            ix = (hashSize + (slot >> 1)) << 1;
+            if (_hashArea[ix] != null) {
                 // ok, spill over.
-                slot = hashSize + (hashSize >> 1) + _spillCount;
+                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;
                 _spillCount += 2;
-                if ((slot << 1) >= _hashArea.length) {
+                if (ix >= _hashArea.length) {
                     _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);
+                    // Uncomment for debugging only
+                    /*
+for (int i = 0; i < _hashArea.length; i += 2) {
+    if (_hashArea[i] != null) {
+        System.err.println("Property #"+(i/2)+" '"+_hashArea[i]+"'...");
+    }
+}
+System.err.println("And new propr #"+slot+" '"+key+"'");
+*/
+                
                 }
             }
         }
-        int ix = slot << 1;
         _hashArea[ix] = key;
         _hashArea[ix+1] = newProp;
 
@@ -491,10 +499,12 @@ System.err.printf("#%02d: %s\n", i>>1, (hashed[i] == null) ? "-" : hashed[i]);
     private final int _hashCode(String key) {
         // This method produces better hash, fewer collisions... yet for some
         // reason produces slightly worse performance. Very strange.
+
+        // 05-Aug-2015, tatu: ... still true?
+
         /*
         int h = key.hashCode();
-        h = h + (h >> 13);
-        return h & _hashMask;
+        return (h + (h >> 13)) & _hashMask;
         */
         return key.hashCode() & _hashMask;
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/misc/BeanPropertyMapTest.java b/src/test/java/com/fasterxml/jackson/databind/misc/BeanPropertyMapTest.java
new file mode 100644
index 000000000..eafa28677
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/misc/BeanPropertyMapTest.java
@@ -0,0 +1,38 @@
+package com.fasterxml.jackson.databind.misc;
+
+import java.util.*;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
+import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;
+import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;
+import com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+
+// for [databind#884]
+public class BeanPropertyMapTest extends BaseMapTest
+{
+    protected final static JavaType BOGUS_TYPE = TypeFactory.unknownType();
+    
+    @SuppressWarnings("serial")
+    static class MyObjectIdReader extends ObjectIdReader
+    {
+        public MyObjectIdReader(String name) {
+            super(BOGUS_TYPE, new PropertyName(name), null,
+                    null, null, null);
+        }
+    }
+
+    // Highly specialized test in which we get couple of hash collisions for
+    // small (16) hash map
+    public void testArrayOutOfBounds884() throws Exception
+    {
+        List<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>();
+        PropertyMetadata md = PropertyMetadata.STD_REQUIRED;
+        props.add(new ObjectIdValueProperty(new MyObjectIdReader("pk"), md));
+        props.add(new ObjectIdValueProperty(new MyObjectIdReader("firstName"), md));
+        BeanPropertyMap propMap = new BeanPropertyMap(false, props);
+        propMap = propMap.withProperty(new ObjectIdValueProperty(new MyObjectIdReader("@id"), md));
+        assertNotNull(propMap);
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java b/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java
index 04522f414..f8dd95efe 100644
--- a/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java
+++ b/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java
@@ -7,7 +7,6 @@ import com.fasterxml.jackson.annotation.*;
 
 import com.fasterxml.jackson.databind.*;
 
-// related to [JACKSON-847]
 public class TestObjectId extends BaseMapTest
 {
     @JsonPropertyOrder({"a", "b"})
diff --git a/src/test/java/com/fasterxml/jackson/failing/TestObjectIdReference836.java b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdReference836.java
new file mode 100644
index 000000000..bbe1e8b3c
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdReference836.java
@@ -0,0 +1,197 @@
+package com.fasterxml.jackson.failing;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.*;
+import com.fasterxml.jackson.databind.*;
+
+public class TestObjectIdReference836
+    extends BaseMapTest
+{
+    static class Player {
+        private int id;
+        private String name;
+
+        private List<Translation> translations = new ArrayList<Translation>();
+
+        public Player(int id, String name) {
+            this.id = id;
+            this.name = name;
+        }
+
+        public Player(){}
+
+        public int getId() {
+            return id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void addTranslation(Translation translation) {
+            this.translations.add(translation);
+        }
+    }
+
+    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")
+    static class Translation {
+
+        private Lang languageId;
+        private String translation;
+
+        public Translation(String translation, Lang languageId){
+            this.translation = translation;
+            this.languageId = languageId;
+        }
+
+        public Translation(){}
+
+//        @JsonSerialize(typing=JsonSerialize.Typing.STATIC)
+//        @JsonDeserialize(as=LanguageId.class)
+        public Lang getLanguageId() {
+            return languageId;
+        }
+
+        public String getTranslation() {
+            return translation;
+        }
+    }
+
+    @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="value")
+    static interface Lang{}
+
+    static class LanguageOk implements Lang
+    {
+        private int value;
+
+        private String kod;
+
+        public LanguageOk(int value, String kod){
+            this.value = value;
+            this.kod = kod;
+        }
+
+        public LanguageOk(){}
+
+        public int getValue(){
+            return this.value;
+        }
+
+        public String getKod(){
+            return this.kod;
+        }
+
+    }
+
+    static class LanguageId implements Lang {
+
+        private Key value;
+
+        private String kod;
+
+        public LanguageId(Key value, String kod){
+            this.value = value;
+            this.kod = kod;
+        }
+
+        public LanguageId(){}
+
+        public Key getValue(){
+            return this.value;
+        }
+
+        public String getKod(){
+            return this.kod;
+        }
+
+    }
+
+    static class Key {
+        public int val;
+
+        public Key(int val){
+            this.val = val;
+        }
+
+        public Key(){}
+
+        public int getVal(){
+            return this.val;
+        }
+    }
+
+    private final ObjectMapper mapper = new ObjectMapper();
+
+    public void testDeserializationOfReferenceOK() throws IOException
+    {
+        Player player = new Player(1, "Dino");
+
+        LanguageOk languageId = new LanguageOk(55, "kod");
+
+        Translation commonTranslation = new Translation("DinoT1", languageId);
+        Translation commonTranslation2 = new Translation("DinoT2", languageId);
+
+        player.addTranslation(commonTranslation);
+        player.addTranslation(commonTranslation);
+        player.addTranslation(commonTranslation2);
+
+        Player player2 = new Player(2, "Bojan");
+        player2.addTranslation(commonTranslation);
+        player2.addTranslation(commonTranslation2);
+
+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
+        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE);
+        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
+
+        String serialized = mapper.writeValueAsString(player);
+        String serialized2 = mapper.writeValueAsString(player2);
+
+        //System.out.println(serialized);
+        //System.out.println(serialized2);
+
+
+        Player p1 = mapper.readValue(serialized, Player.class);
+        Player p2 = mapper.readValue(serialized2, Player.class);
+
+        assertNotNull(p1);
+        assertNotNull(p2);
+    }
+
+    public void testDeserializationOfReference() throws IOException {
+
+        Player player = new Player(1, "Dino");
+
+        LanguageId languageId = new LanguageId(new Key(44), "kod");
+
+        Translation commonTranslation = new Translation("DinoT1", languageId);
+        Translation commonTranslation2 = new Translation("DinoT2", languageId);
+
+        player.addTranslation(commonTranslation);
+        player.addTranslation(commonTranslation);
+        player.addTranslation(commonTranslation2);
+
+        Player player2 = new Player(2, "Bojan");
+        player2.addTranslation(commonTranslation);
+        player2.addTranslation(commonTranslation2);
+
+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
+        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE);
+        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
+
+        String serialized = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(player);
+        String serialized2 = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(player2);
+
+        System.out.println("Player1 <- "+serialized);
+        Player p1 = mapper.readValue(serialized, Player.class);
+
+        System.out.println("Player2 <- "+serialized2);
+        Player p2 = mapper.readValue(serialized2, Player.class);
+
+        assertNotNull(p1);
+        assertNotNull(p2);
+    }
+
+}
\ No newline at end of file
