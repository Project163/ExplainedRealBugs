diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 26c052f0f..2690a6f7a 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -445,6 +445,10 @@ Tom Mack (tommack@github)
     the requested value type
    (2.7.4)
 
+Artur Jonkisz (ajonkisz@github)
+  * Reported #960: `@JsonCreator` not working on a factory with no arguments for ae enum type
+   (2.8.0)
+
 Ross Goldberg
   * Reported #1165, provided fix for: `CoreXMLDeserializers` does not handle
     time-only `XMLGregorianCalendar`s
diff --git a/release-notes/VERSION b/release-notes/VERSION
index ae57e6a1a..5fefec8f9 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -10,6 +10,8 @@ Project: jackson-databind
   `Mapper.configOverride(type).setIsIgnoredType(true)`
 #903: Add `JsonGenerator` reference to `SerializerProvider`
 #931: Add new method in `Deserializers.Base` to support `ReferenceType`
+#960: `@JsonCreator` not working on a factory with no arguments for ae enum type
+ (reported by Artur J)
 #990: Allow failing on `null` values for creator (add 
   `DeserializationFeature.FAIL_ON_NULL_CREATOR_PROPERTIES`)
  (contributed by mkokho@github)
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index e351bd92d..aa3133b8d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -1256,6 +1256,9 @@ public abstract class BasicDeserializerFactory
                             deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);
                             break;
                         }
+                    } else if (argCount == 0) { // [databind#960]
+                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);
+                        break;
                     }
                     throw new IllegalArgumentException("Unsuitable method ("+factory+") decorated with @JsonCreator (for Enum type "
                             +enumClass.getName()+")");
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java
index 0df713c1d..05b976a1b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java
@@ -1,19 +1,14 @@
 package com.fasterxml.jackson.databind.deser.std;
 
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
 
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
-import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
 import com.fasterxml.jackson.databind.deser.ValueInstantiator;
-import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;
-import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;
 import com.fasterxml.jackson.databind.exc.InvalidFormatException;
 import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
-import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 import com.fasterxml.jackson.databind.util.ClassUtil;
 import com.fasterxml.jackson.databind.util.CompactStringObjectMap;
 import com.fasterxml.jackson.databind.util.EnumResolver;
@@ -64,13 +59,12 @@ public class EnumDeserializer
             Class<?> enumClass, AnnotatedMethod factory) {
         return deserializerForCreator(config, enumClass, factory);
     }
-    
+
     /**
      * Factory method used when Enum instances are to be deserialized
      * using a creator (static factory method)
      * 
-     * @return Deserializer based on given factory method, if type was suitable;
-     *  null if type can not be used
+     * @return Deserializer based on given factory method
      *
      * @since 2.8
      */
@@ -78,16 +72,33 @@ public class EnumDeserializer
             Class<?> enumClass, AnnotatedMethod factory,
             ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps)
     {
-        // note: caller has verified there's just one arg; but we must verify its type
         if (config.canOverrideAccessModifiers()) {
             ClassUtil.checkAndFixAccess(factory.getMember(),
                     config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
         }
-        Class<?> paramClass = factory.getRawParameterType(0);
-        return new FactoryBasedDeserializer(enumClass, factory, paramClass,
+        return new FactoryBasedEnumDeserializer(enumClass, factory,
+                factory.getParameterType(0),
                 valueInstantiator, creatorProps);
     }
 
+    /**
+     * Factory method used when Enum instances are to be deserialized
+     * using a zero-/no-args factory method
+     * 
+     * @return Deserializer based on given no-args factory method
+     *
+     * @since 2.8
+     */
+    public static JsonDeserializer<?> deserializerForNoArgsCreator(DeserializationConfig config,
+            Class<?> enumClass, AnnotatedMethod factory)
+    {
+        if (config.canOverrideAccessModifiers()) {
+            ClassUtil.checkAndFixAccess(factory.getMember(),
+                    config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+        }
+        return new FactoryBasedEnumDeserializer(enumClass, factory);
+    }
+
     /*
     /**********************************************************
     /* Default JsonDeserializer implementation
@@ -234,166 +245,4 @@ public class EnumDeserializer
     /* Additional helper classes
     /**********************************************************
      */
-
-    /**
-     * Deserializer that uses a single-String static factory method
-     * for locating Enum values by String id.
-     */
-    protected static class FactoryBasedDeserializer
-        extends StdDeserializer<Object>
-        implements ContextualDeserializer
-    {
-        private static final long serialVersionUID = 1;
-
-        // Marker type; null if String expected; otherwise numeric wrapper
-        protected final Class<?> _inputType;
-        protected final AnnotatedMethod _factory;
-        protected final JsonDeserializer<?> _deser;
-        protected final ValueInstantiator _valueInstantiator;
-        protected final SettableBeanProperty[] _creatorProps;
-        
-        public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f, Class<?> inputType,
-                ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps)
-        {
-            super(cls);
-            _factory = f;
-            _inputType = inputType;
-            _deser = null;
-            _valueInstantiator = valueInstantiator;
-            _creatorProps = creatorProps;
-        }
-
-        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,
-                JsonDeserializer<?> deser) {
-            super(base._valueClass);
-            _inputType = base._inputType;
-            _factory = base._factory;
-            _valueInstantiator = base._valueInstantiator;
-            _creatorProps = base._creatorProps;
-
-            _deser = deser;
-        }
-
-        @Override
-        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
-                BeanProperty property)
-            throws JsonMappingException
-        {
-            if ((_deser == null) && (_inputType != String.class)) {
-                return new FactoryBasedDeserializer(this,
-                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));
-            }
-            return this;
-        }
-        
-        @Override
-        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
-        {
-            Object value = null;
-            if (_deser != null) {
-                value = _deser.deserialize(p, ctxt);
-            } else {
-                JsonToken curr = p.getCurrentToken();
-                //There can be a JSON object passed for deserializing an Enum,
-                //the below case handles it.
-                if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {
-                    value = p.getText();
-                } else if (p.isExpectedStartObjectToken()) {
-                    p.nextToken();
-                    
-                    if (_creatorProps != null) {
-                        PropertyBasedCreator propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, _creatorProps);
-                        return deserializeEnumUsingPropertyBased(p, ctxt, propertyBasedCreator);
-                    }
-                } else {
-                    value = p.getValueAsString();
-                }
-            }
-            try {
-                return _factory.callOnWith(_valueClass, value);
-            } catch (Exception e) {
-                Throwable t = ClassUtil.getRootCause(e);
-                if (t instanceof IOException) {
-                    throw (IOException) t;
-                }
-                throw ctxt.instantiationException(_valueClass, t);
-            }
-        }
-
-        @Override
-        public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
-            if (_deser == null) { // String never has type info
-                return deserialize(p, ctxt);
-            }
-            return typeDeserializer.deserializeTypedFromAny(p, ctxt);
-        }
-        
-        // Method to deserialize the Enum using property based methodology
-        protected Object deserializeEnumUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt,
-        		final PropertyBasedCreator creator) throws IOException
-        {
-            PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, null);
-        
-            JsonToken t = p.getCurrentToken();
-            for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
-                String propName = p.getCurrentName();
-                p.nextToken(); // to point to value
-        
-                SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
-                if (creatorProp != null) {
-                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
-                        p.nextToken(); // to move to next field name
-                    }
-                    continue;
-                }
-                if (buffer.readIdProperty(propName)) {
-                    continue;
-                }
-            }
-            return creator.build(ctxt, buffer);
-        }
-
-        // ************ Got the below methods from BeanDeserializer ********************//
-	
-        protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt,
-        		SettableBeanProperty prop) throws IOException {
-        	try {
-        		return prop.deserialize(p, ctxt);
-        	} catch (Exception e) {
-        		wrapAndThrow(e, _valueClass.getClass(), prop.getName(), ctxt);
-        		// never gets here, unless caller declines to throw an exception
-        		return null;
-        	}
-        }
-
-        public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)
-        		throws IOException
-        {
-            throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);
-        }
-
-        private Throwable throwOrReturnThrowable(Throwable t, DeserializationContext ctxt) throws IOException
-        {
-            while (t instanceof InvocationTargetException && t.getCause() != null) {
-                t = t.getCause();
-            }
-            // Errors to be passed as is
-            if (t instanceof Error) {
-                throw (Error) t;
-            }
-            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
-        	    // Ditto for IOExceptions; except we may want to wrap JSON
-        	    // exceptions
-        	    if (t instanceof IOException) {
-        	        if (!wrap || !(t instanceof JsonProcessingException)) {
-        	            throw (IOException) t;
-        	        }
-        	    } else if (!wrap) {
-        	        if (t instanceof RuntimeException) {
-        	            throw (RuntimeException) t;
-        	        }
-        	    }
-        	    return t;
-        }
-    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FactoryBasedEnumDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FactoryBasedEnumDeserializer.java
new file mode 100644
index 000000000..7d089c764
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FactoryBasedEnumDeserializer.java
@@ -0,0 +1,215 @@
+package com.fasterxml.jackson.databind.deser.std;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.BeanProperty;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
+import com.fasterxml.jackson.databind.deser.ValueInstantiator;
+import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;
+import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
+import com.fasterxml.jackson.databind.util.ClassUtil;
+
+/**
+ * Deserializer that uses a single-String static factory method
+ * for locating Enum values by String id.
+ * 
+ * @since 2.8 (as stand-alone class; was static inner class of {@link EnumDeserializer}
+ */
+class FactoryBasedEnumDeserializer
+    extends StdDeserializer<Object>
+    implements ContextualDeserializer
+{
+    private static final long serialVersionUID = 1;
+
+    // Marker type; null if String expected; otherwise numeric wrapper
+    protected final JavaType _inputType;
+    protected final boolean _hasArgs;
+    protected final AnnotatedMethod _factory;
+    protected final JsonDeserializer<?> _deser;
+    protected final ValueInstantiator _valueInstantiator;
+    protected final SettableBeanProperty[] _creatorProps;
+
+    /**
+     * Lazily instantiated property-based creator.
+     *
+     * @since 2.8
+     */
+    private transient PropertyBasedCreator _propCreator;
+    
+    public FactoryBasedEnumDeserializer(Class<?> cls, AnnotatedMethod f, JavaType paramType,
+            ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps)
+    {
+        super(cls);
+        _factory = f;
+        _hasArgs = true;
+        // We'll skip case of `String`, as well as no type (zero-args): 
+        _inputType = paramType.hasRawClass(String.class) ? null : paramType;
+        _deser = null;
+        _valueInstantiator = valueInstantiator;
+        _creatorProps = creatorProps;
+    }
+
+    /**
+     * @since 2.8
+     */
+    public FactoryBasedEnumDeserializer(Class<?> cls, AnnotatedMethod f)
+    {
+        super(cls);
+        _factory = f;
+        _hasArgs = false;
+        _inputType = null;
+        _deser = null;
+        _valueInstantiator = null;
+        _creatorProps = null;
+    }
+
+    protected FactoryBasedEnumDeserializer(FactoryBasedEnumDeserializer base,
+            JsonDeserializer<?> deser) {
+        super(base._valueClass);
+        _inputType = base._inputType;
+        _factory = base._factory;
+        _hasArgs = base._hasArgs;
+        _valueInstantiator = base._valueInstantiator;
+        _creatorProps = base._creatorProps;
+
+        _deser = deser;
+    }
+
+    @Override
+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
+            BeanProperty property)
+        throws JsonMappingException
+    {
+        if ((_deser == null) && (_inputType != null)) {
+            return new FactoryBasedEnumDeserializer(this,
+                    ctxt.findContextualValueDeserializer(_inputType, property));
+        }
+        return this;
+    }
+
+    @Override
+    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
+    {
+        Object value = null;
+        if (_deser != null) {
+            value = _deser.deserialize(p, ctxt);
+        } else if (_hasArgs) {
+            JsonToken curr = p.getCurrentToken();
+            //There can be a JSON object passed for deserializing an Enum,
+            //the below case handles it.
+            if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {
+                value = p.getText();
+            } else if ((_creatorProps != null) && p.isExpectedStartObjectToken()) {
+                if (_propCreator == null) {
+                    _propCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, _creatorProps);
+                }
+                p.nextToken();
+                return deserializeEnumUsingPropertyBased(p, ctxt, _propCreator);
+            } else {
+                value = p.getValueAsString();
+            }
+        } else { // zero-args; just skip whatever value there may be
+            p.skipChildren();
+            try {
+                return _factory.call();
+            } catch (Exception e) {
+                Throwable t = ClassUtil.throwRootCauseIfIOE(e);
+                ctxt.reportInstantiationException(_valueClass, t);
+            }
+        }
+        try {
+            return _factory.callOnWith(_valueClass, value);
+        } catch (Exception e) {
+            Throwable t = ClassUtil.throwRootCauseIfIOE(e);
+            return ctxt.reportInstantiationException(_valueClass, t);
+        }
+    }
+
+    @Override
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
+        if (_deser == null) { // String never has type info
+            return deserialize(p, ctxt);
+        }
+        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
+    }
+    
+    // Method to deserialize the Enum using property based methodology
+    protected Object deserializeEnumUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt,
+    		final PropertyBasedCreator creator) throws IOException
+    {
+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, null);
+    
+        JsonToken t = p.getCurrentToken();
+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
+            String propName = p.getCurrentName();
+            p.nextToken(); // to point to value
+    
+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
+            if (creatorProp != null) {
+                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
+                    p.nextToken(); // to move to next field name
+                }
+                continue;
+            }
+            if (buffer.readIdProperty(propName)) {
+                continue;
+            }
+        }
+        return creator.build(ctxt, buffer);
+    }
+
+    // ************ Got the below methods from BeanDeserializer ********************//
+
+    protected final Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt,
+    		SettableBeanProperty prop) throws IOException {
+    	try {
+    		return prop.deserialize(p, ctxt);
+    	} catch (Exception e) {
+    		wrapAndThrow(e, _valueClass.getClass(), prop.getName(), ctxt);
+    		// never gets here, unless caller declines to throw an exception
+    		return null;
+    	}
+    }
+
+    public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)
+    		throws IOException
+    {
+        throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);
+    }
+
+    private Throwable throwOrReturnThrowable(Throwable t, DeserializationContext ctxt) throws IOException
+    {
+        while (t instanceof InvocationTargetException && t.getCause() != null) {
+            t = t.getCause();
+        }
+        // Errors to be passed as is
+        if (t instanceof Error) {
+            throw (Error) t;
+        }
+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
+    	    // Ditto for IOExceptions; except we may want to wrap JSON
+    	    // exceptions
+    	    if (t instanceof IOException) {
+    	        if (!wrap || !(t instanceof JsonProcessingException)) {
+    	            throw (IOException) t;
+    	        }
+    	    } else if (!wrap) {
+    	        if (t instanceof RuntimeException) {
+    	            throw (RuntimeException) t;
+    	        }
+    	    }
+    	    return t;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java
index f18beb475..e5a0232f6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java
@@ -524,7 +524,22 @@ public final class ClassUtil
         }
         throw (Error) t;
     }
-    
+
+    /**
+     * Method that works like {@link #throwRootCause} if (and only if)
+     * root cause is an {@link IOException}; otherwise returns root cause
+     *
+     * @since 2.8
+     */
+    public static Throwable throwRootCauseIfIOE(Throwable t) throws IOException
+    {
+        t = getRootCause(t);
+        if (t instanceof IOException) {
+            throw (IOException) t;
+        }
+        return t;
+    }
+
     /**
      * Method that will wrap 't' as an {@link IllegalArgumentException} if it
      * is a checked exception; otherwise (runtime exception or error) throw as is
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/EnumDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/EnumDeserializationTest.java
index 11d81c3db..048a477bd 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/EnumDeserializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/EnumDeserializationTest.java
@@ -9,6 +9,7 @@ import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 
@@ -115,6 +116,59 @@ public class EnumDeserializationTest
         }
     }
 
+    // // 
+    
+    public enum AnEnum {
+        ZERO,
+        ONE
+    }
+
+    public static class AnEnumDeserializer extends FromStringDeserializer<AnEnum> {
+
+        public AnEnumDeserializer() {
+            super(AnEnum.class);
+        }
+
+        @Override
+        protected AnEnum _deserialize(String value, DeserializationContext ctxt) throws IOException {
+            try {
+                return AnEnum.valueOf(value);
+            } catch (IllegalArgumentException e) {
+                throw ctxt.weirdKeyException(AnEnum.class, value, "Undefined AnEnum code");
+            }
+        }
+    }
+
+    public static class AnEnumKeyDeserializer extends KeyDeserializer {
+
+        @Override
+        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
+            try {
+                return AnEnum.valueOf(key);
+            } catch (IllegalArgumentException e) {
+                throw ctxt.weirdKeyException(AnEnum.class, key, "Undefined AnEnum code");
+            }
+        }
+    }
+
+
+    @JsonDeserialize(using = AnEnumDeserializer.class, keyUsing = AnEnumKeyDeserializer.class)
+    public enum LanguageCodeMixin {
+    }
+
+    public static class EnumModule extends SimpleModule {
+        @Override
+        public void setupModule(SetupContext context) {
+            context.setMixInAnnotations(AnEnum.class, LanguageCodeMixin.class);
+        }
+
+        public static ObjectMapper setupObjectMapper(ObjectMapper mapper) {
+            final EnumModule module = new EnumModule();
+            mapper.registerModule(module);
+            return mapper;
+        }
+    }
+
     /*
     /**********************************************************
     /* Test methods
@@ -414,4 +468,16 @@ public class EnumDeserializationTest
         EnumWithDefaultAnnoAndConstructor myEnum = mapper.readValue("\"foo\"", EnumWithDefaultAnnoAndConstructor.class);
         assertNull("When using a constructor, the default value annotation shouldn't be used.", myEnum);
     }
+
+    public void testExceptionFromCustomEnumKeyDeserializer() {
+        ObjectMapper objectMapper = new ObjectMapper();
+        objectMapper.registerModule(new EnumModule());
+        try {
+            objectMapper.readValue("{\"TWO\": \"dumpling\"}",
+                    new TypeReference<Map<AnEnum, String>>() {});
+            fail("No exception");
+        } catch (IOException e) {
+            assertTrue(e.getMessage().contains("Undefined AnEnum"));
+        }
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java
deleted file mode 100644
index 6b8ea104b..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/******************************************************************************
- * * This data and information is proprietary to, and a valuable trade secret
- * * of, Basis Technology Corp.  It is given in confidence by Basis Technology
- * * and may only be used as permitted under the license agreement under which
- * * it has been distributed, and in no other way.
- * *
- * * Copyright (c) 2015 Basis Technology Corporation All rights reserved.
- * *
- * * The technical data and information provided herein are provided with
- * * `limited rights', and the computer software provided herein is provided
- * * with `restricted rights' as those terms are defined in DAR and ASPR
- * * 7-104.9(a).
- ******************************************************************************/
-
-package com.fasterxml.jackson.databind.deser;
-
-import java.io.IOException;
-import java.util.Map;
-
-import org.junit.Test;
-
-import com.fasterxml.jackson.core.type.TypeReference;
-import com.fasterxml.jackson.databind.BaseMapTest;
-import com.fasterxml.jackson.databind.DeserializationContext;
-import com.fasterxml.jackson.databind.KeyDeserializer;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
-import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-
-@SuppressWarnings("serial")
-public class ExceptionFromCustomEnumKeyDeserializerTest
-    extends BaseMapTest
-{
-    public enum AnEnum {
-        ZERO,
-        ONE
-    }
-
-    public static class AnEnumDeserializer extends FromStringDeserializer<AnEnum> {
-
-        public AnEnumDeserializer() {
-            super(AnEnum.class);
-        }
-
-        //CHECKSTYLE:OFF
-        @Override
-        protected AnEnum _deserialize(String value, DeserializationContext ctxt) throws IOException {
-            try {
-                return AnEnum.valueOf(value);
-            } catch (IllegalArgumentException e) {
-                throw ctxt.weirdKeyException(AnEnum.class, value, "Undefined AnEnum code");
-            }
-        }
-    }
-
-    public static class AnEnumKeyDeserializer extends KeyDeserializer {
-
-        @Override
-        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
-            try {
-                return AnEnum.valueOf(key);
-            } catch (IllegalArgumentException e) {
-                throw ctxt.weirdKeyException(AnEnum.class, key, "Undefined AnEnum code");
-            }
-        }
-    }
-
-
-    @JsonDeserialize(using = AnEnumDeserializer.class, keyUsing = AnEnumKeyDeserializer.class)
-    public enum LanguageCodeMixin {
-    }
-
-    public static class EnumModule extends SimpleModule {
-        @Override
-        public void setupModule(SetupContext context) {
-            context.setMixInAnnotations(AnEnum.class, LanguageCodeMixin.class);
-        }
-
-        public static ObjectMapper setupObjectMapper(ObjectMapper mapper) {
-            final EnumModule module = new EnumModule();
-            mapper.registerModule(module);
-            return mapper;
-        }
-    }
-
-    @Test
-    public void testLostMessage() {
-        ObjectMapper objectMapper = new ObjectMapper();
-        objectMapper.registerModule(new EnumModule());
-        try {
-            objectMapper.readValue("{\"TWO\": \"dumpling\"}", new TypeReference<Map<AnEnum, String>>() {});
-        } catch (IOException e) {
-            assertTrue(e.getMessage().contains("Undefined AnEnum"));
-            return;
-        }
-        fail("No exception");
-    }
-}
