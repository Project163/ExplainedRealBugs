diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 7cceef0a0..88d11b384 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -526,3 +526,6 @@ Chris Jester-Young (cky@github)
   * Contributed #1335: Unconditionally call `TypeIdResolver.getDescForKnownTypeIds`
    (2.8.2)
 
+Andrew Snare (asnare@github)
+  * Reported #1315: Binding numeric values can BigDecimal lose precision
+   (2.8.2)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 8b6671492..16de24e74 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -6,6 +6,10 @@ Project: jackson-databind
 
 2.8.2 (not yet released)
 
+#1315: Binding numeric values can BigDecimal lose precision
+ (reported by Andrew S)
+#1327: Class level `@JsonInclude(JsonInclude.Include.NON_EMPTY)` is ignored
+ (reported by elruwen@github)
 #1335: Unconditionally call `TypeIdResolver.getDescForKnownTypeIds`
  (contributed by Chris J-Y)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
index a2677652e..86599560b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
@@ -1,7 +1,6 @@
 package com.fasterxml.jackson.databind.deser.std;
 
 import java.io.IOException;
-import java.math.BigDecimal;
 
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
@@ -372,11 +371,14 @@ abstract class BaseNodeDeserializer<T extends JsonNode>
         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
             // 20-May-2016, tatu: As per [databind#1028], need to be careful
             //   (note: JDK 1.8 would have `Double.isFinite()`)
+            // 21-Aug-2016, tatu: Not optimal, really, because this may result in
+            //   value getting parsed twice. But has to do for now, to resolve
+            //  [databind#1315]
             double d = p.getDoubleValue();
             if (Double.isInfinite(d) || Double.isNaN(d)) {
                 return nodeFactory.numberNode(d);
             }
-            return nodeFactory.numberNode(BigDecimal.valueOf(d));
+            return nodeFactory.numberNode(p.getDecimalValue());
         }
         return nodeFactory.numberNode(p.getDoubleValue());
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/NotANumberConversionTest.java b/src/test/java/com/fasterxml/jackson/databind/node/NotANumberConversionTest.java
index 54a46369a..3fcb71dba 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/NotANumberConversionTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/NotANumberConversionTest.java
@@ -1,14 +1,18 @@
 package com.fasterxml.jackson.databind.node;
 
+import java.math.BigDecimal;
+
 import com.fasterxml.jackson.databind.*;
 
 public class NotANumberConversionTest extends BaseMapTest
 {
-    public void testBigDecimalWithNaN() throws Exception
+    private final ObjectMapper m = new ObjectMapper();
     {
-        ObjectMapper m = new ObjectMapper();
         m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);
+    }
 
+    public void testBigDecimalWithNaN() throws Exception
+    {
         JsonNode tree = m.valueToTree(new DoubleWrapper(Double.NaN));
         assertNotNull(tree);
         String json = m.writeValueAsString(tree);
@@ -24,4 +28,14 @@ public class NotANumberConversionTest extends BaseMapTest
         json = m.writeValueAsString(tree);
         assertNotNull(json);
     }
+
+    // for [databind#1315]: no accidental coercion to DoubleNode
+    public void testBigDecimalWithoutNaN() throws Exception
+    {
+        BigDecimal input = new BigDecimal(Double.MIN_VALUE).divide(new BigDecimal(10L));
+        JsonNode tree = m.readTree(input.toString());
+        assertTrue(tree.isBigDecimal());
+        BigDecimal output = tree.decimalValue();
+        assertEquals(input, output);
+    }
 }
