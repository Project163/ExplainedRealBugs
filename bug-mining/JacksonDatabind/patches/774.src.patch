diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x
index 5294a98a4..2cb1ab3ff 100644
--- a/release-notes/CREDITS-2.x
+++ b/release-notes/CREDITS-2.x
@@ -1880,3 +1880,8 @@ Gustavo Bazan (@gssbzn)
  * Reported #4908: Deserialization behavior change with @JsonCreator and
    @ConstructorProperties between 2.17 and 2.18
   (2.18.3)
+
+Zhen Lin Low (@zhenlin-pay2)
+ * Reported, fixed #4920: Creator properties are ignored on abstract types
+   when collecting bean properties, breaking AsExternalTypeDeserializer
+  (2.18.3)
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 745d14b2f..4cf84de6d 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -29,6 +29,9 @@ Project: jackson-databind
  (reported by Gustavo B)
 #4917: `BigDecimal` deserialization issue when using `@JsonCreator`
  (reported by @dbachdev)
+#4920: Creator properties are ignored on abstract types when collecting
+  bean properties, breaking AsExternalTypeDeserializer
+ (reported, fix contributed by Zhen L-L)
 #4922: Failing `@JsonMerge` with a custom Map
  (reported by @nlisker)
 #4932: Conversion of `MissingNode` throws `JsonProcessingException`
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
index 257d8110a..a6e26e0e1 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
@@ -511,9 +511,9 @@ ClassUtil.name(propName)));
             BeanDescription beanDesc, BeanDeserializerBuilder builder)
         throws JsonMappingException
     {
-        final boolean isConcrete = !beanDesc.getType().isAbstract();
-        final SettableBeanProperty[] creatorProps = isConcrete
-                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())
+        final ValueInstantiator valueInstantiator = builder.getValueInstantiator();
+        final SettableBeanProperty[] creatorProps = (valueInstantiator != null)
+                ? valueInstantiator.getFromObjectArguments(ctxt.getConfig())
                 : null;
         final boolean hasCreatorProps = (creatorProps != null);
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/creators/BeanDeserializerFactory4920Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/creators/BeanDeserializerFactory4920Test.java
new file mode 100644
index 000000000..f185be9bf
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/creators/BeanDeserializerFactory4920Test.java
@@ -0,0 +1,131 @@
+package com.fasterxml.jackson.databind.deser.creators;
+
+import java.io.IOException;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonTypeInfo;
+import com.fasterxml.jackson.databind.DatabindContext;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
+
+import static com.fasterxml.jackson.databind.testutil.DatabindTestUtil.newJsonMapper;
+
+/**
+ * Unit test for [databind#4920]: Creator properties are ignored on abstract types when
+ * collecting bean properties, breaking
+ * {@link com.fasterxml.jackson.databind.jsontype.impl.AsExternalTypeDeserializer}.
+ */
+public class BeanDeserializerFactory4920Test
+{
+    interface TypedData {
+        @JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "type", visible = true)
+        @JsonTypeIdResolver(ValueTypeIdResolver.class)
+        Value getValue();
+
+        String getType();
+
+        @JsonCreator
+        static TypedData immutableOf(@JsonProperty("value") Value value, @JsonProperty("type") String type) {
+            return new TypedData.Immutable(value, type);
+        }
+
+        final class Immutable implements TypedData {
+
+            private final Value value;
+            private final String type;
+
+            public Immutable(Value value, String type) {
+                this.value = value;
+                this.type = type;
+            }
+
+            @Override
+            public Value getValue() {
+                return value;
+            }
+
+            @Override
+            public String getType() {
+                return type;
+            }
+        }
+
+        final class ValueTypeIdResolver extends TypeIdResolverBase {
+            @Override
+            public String idFromValue(Object value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public String idFromValueAndType(Object value, Class<?> suggestedType) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public JsonTypeInfo.Id getMechanism() {
+                return JsonTypeInfo.Id.CUSTOM;
+            }
+
+            @Override
+            public JavaType typeFromId(DatabindContext context, String id) throws IOException {
+                Class<?> type;
+                try {
+                    type = Class.forName(id);
+                } catch (ClassNotFoundException e) {
+                    throw new IllegalArgumentException(e);
+                }
+
+                return context.constructType(type);
+            }
+        }
+    }
+
+    interface Value {
+    }
+
+    static final class StringValue implements Value {
+
+        private final String value;
+
+        public StringValue(String value) {
+            this.value = value;
+        }
+
+        public String getValue() {
+            return value;
+        }
+    }
+
+    static final class LongValue implements Value {
+
+        private final long value;
+
+        public LongValue(long value) {
+            this.value = value;
+        }
+
+        public long getValue() {
+            return value;
+        }
+    }
+
+    @Test
+    void testDeserializeAbstract() throws Exception {
+        ObjectMapper objectMapper = newJsonMapper();
+
+        //language=JSON
+        String json = "{ \"value\": \"1234567890\", \"type\": \"" + StringValue.class.getName() + "\" }";
+
+        TypedData actual = objectMapper.readValue(json, TypedData.class);
+
+        Assertions.assertNotNull(actual);
+        Assertions.assertInstanceOf(StringValue.class, actual.getValue());
+        Assertions.assertEquals("1234567890", ((StringValue) actual.getValue()).getValue());
+    }
+}
