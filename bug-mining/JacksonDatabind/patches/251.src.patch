diff --git a/release-notes/VERSION b/release-notes/VERSION
index 2d60984c1..f27c4c9d3 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -14,6 +14,8 @@ Project: jackson-databind
 #1439: NPE when using with filter id, serializing `java.util.Map` types
 #1441: Failure with custom Enum key deserializer, polymorphic types
  (reported by Nathanial O)
+#1445: Map key deserializerModifiers ignored
+ (reported by alfonsobonso@github)
 - Improvements to #1411 fix to ensure consistent `null` key handling
 
 2.8.4 (14-Oct-2016)
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index f661908b1..ade4b73f2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -1400,12 +1400,12 @@ public abstract class BasicDeserializerFactory
         // the only non-standard thing is this:
         if (deser == null) {
             if (type.isEnumType()) {
-                return _createEnumKeyDeserializer(ctxt, type);
+                deser = _createEnumKeyDeserializer(ctxt, type);
+            } else {
+                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);
             }
-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);
         }
-        
-        // and then new with 2.2: ability to post-process it too (Issue#120)
+        // and then post-processing
         if (deser != null) {
             if (_factoryConfig.hasDeserializerModifiers()) {
                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
@@ -1464,7 +1464,7 @@ public abstract class BasicDeserializerFactory
                         +enumClass.getName()+")");
             }
         }
-        // [JACKSON-749] Also, need to consider @JsonValue, if one found
+        // Also, need to consider @JsonValue, if one found
         return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);
     }
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java b/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
index fb6320143..f99e32094 100644
--- a/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java
@@ -13,6 +13,7 @@ import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.exc.InvalidFormatException;
 import com.fasterxml.jackson.databind.node.ObjectNode;
@@ -223,4 +224,58 @@ public class TestCustomEnumKeyDeserializer extends BaseMapTest
         assertEquals("Deserialized someMap.FOO should equal bar", "bar",
                 superType.someMap.get(SuperTypeEnum.FOO));
     }
+
+    // [databind#1445]
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public void testCustomEnumValueAndKeyViaModifier() throws IOException
+    {
+        SimpleModule module = new SimpleModule();
+        module.setDeserializerModifier(new BeanDeserializerModifier() {        
+            @Override
+            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,
+                    final JavaType type, BeanDescription beanDesc,
+                    final JsonDeserializer<?> deserializer) {
+                return new JsonDeserializer<Enum>() {
+                    @Override
+                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
+                        final String str = p.getValueAsString().toLowerCase();
+                        return KeyEnum.valueOf(rawClass, str);
+                    }
+                };
+            }
+
+            @Override
+            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,
+                    final JavaType type, KeyDeserializer deserializer)
+            {
+                if (!type.isEnumType()) {
+                    return deserializer;
+                }
+                return new KeyDeserializer() {
+                    @Override
+                    public Object deserializeKey(String key, DeserializationContext ctxt)
+                            throws IOException
+                    {
+                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
+                        return Enum.valueOf(rawClass, key.toLowerCase());
+                    }
+                };
+            }
+        });
+        ObjectMapper mapper = new ObjectMapper()
+                .registerModule(module);
+
+        // First, enum value as is
+        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),
+                KeyEnum.class);
+        assertSame(KeyEnum.replacements, key);
+
+        // and then as key
+        EnumMap<KeyEnum,String> map = mapper.readValue(
+                aposToQuotes("{'REPlaceMENTS':'foobar'}"),
+                new TypeReference<EnumMap<KeyEnum,String>>() { });
+        assertEquals(1, map.size());
+        assertSame(KeyEnum.replacements, map.keySet().iterator().next());
+    }
 }
