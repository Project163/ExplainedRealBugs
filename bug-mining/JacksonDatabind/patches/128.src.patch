diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 962a0bc0f..9ad539314 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -342,3 +342,7 @@ Jesse Wilson (swankjesse@github)
 Warren Bloomer (stormboy@github)
   * Reported #942: Handle null type id for polymorphic values that use external type id
    (2.6.3)
+
+Ievgen Pianov (pyanoveugen@github)
+  * Reported #989: Deserialization from "{}" to java.lang.Object causes "out of END_OBJECT token" error
+   (2.6.3)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index fd6254e7a..fe08c1325 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -8,6 +8,8 @@ Project: jackson-databind
 
 #984: JsonStreamContexts are not build the same way for write.. and convert methods
  (reported by Antibrumm@github)
+#989: Deserialization from "{}" to java.lang.Object causes "out of END_OBJECT token" error
+ (reported by Ievgen P)
 
 2.6.3 (12-Oct-2015)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
index 55c7434f6..c96221412 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
@@ -216,6 +216,9 @@ public class UntypedObjectDeserializer
         switch (p.getCurrentTokenId()) {
         case JsonTokenId.ID_START_OBJECT:
         case JsonTokenId.ID_FIELD_NAME:
+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
+            //    if caller has advanced to the first token of Object, but for empty Object
+        case JsonTokenId.ID_END_OBJECT:
             if (_mapDeserializer != null) {
                 return _mapDeserializer.deserialize(p, ctxt);
             }
@@ -269,7 +272,6 @@ public class UntypedObjectDeserializer
             return null;
 
 //        case JsonTokenId.ID_END_ARRAY: // invalid
-//        case JsonTokenId.ID_END_OBJECT: // invalid
         default:
         }
         throw ctxt.mappingException(Object.class);
@@ -314,7 +316,6 @@ public class UntypedObjectDeserializer
             if (_numberDeserializer != null) {
                 return _numberDeserializer.deserialize(p, ctxt);
             }
-            // For [JACKSON-72], see above
             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                 return p.getDecimalValue();
             }
@@ -400,12 +401,11 @@ public class UntypedObjectDeserializer
             }
             key1 = null;
         }
-
-        // minor optimization; let's handle 1 and 2 entry cases separately
         if (key1 == null) {
             // empty map might work; but caller may want to modify... so better just give small modifiable
             return new LinkedHashMap<String,Object>(2);
         }
+        // minor optimization; let's handle 1 and 2 entry cases separately
         // 24-Mar-2015, tatu: Ideally, could use one of 'nextXxx()' methods, but for
         //   that we'd need new method(s) in JsonDeserializer. So not quite yet.
         p.nextToken();
@@ -488,7 +488,7 @@ public class UntypedObjectDeserializer
             case JsonTokenId.ID_START_OBJECT:
                 {
                     JsonToken t = p.nextToken();
-                    if (t  == JsonToken.END_OBJECT) {
+                    if (t == JsonToken.END_OBJECT) {
                         return new LinkedHashMap<String,Object>(2);
                     }
                 }
@@ -533,8 +533,12 @@ public class UntypedObjectDeserializer
             case JsonTokenId.ID_NULL: // should not get this but...
                 return null;
 
+            case JsonTokenId.ID_END_OBJECT:
+                // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
+                //    if caller has advanced to the first token of Object, but for empty Object
+                return new LinkedHashMap<String,Object>(2);
+
             //case JsonTokenId.ID_END_ARRAY: // invalid
-            //case JsonTokenId.ID_END_OBJECT: // invalid
             default:
                 throw ctxt.mappingException(Object.class);
             }
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
index da6ceabd5..d5bb22556 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
@@ -3,6 +3,7 @@ package com.fasterxml.jackson.databind.deser;
 import java.io.*;
 import java.util.*;
 
+import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
@@ -90,12 +91,23 @@ public class TestUntypedDeserialization
             return map;
         }
     }
+
+    static class Untyped989 {
+        protected Object value;
+        
+        @JsonCreator // delegating
+        public Untyped989(Object v) {
+            value = v;
+        }
+    }
     
     /*
     /**********************************************************
     /* Test methods
     /**********************************************************
      */
+
+    private final ObjectMapper MAPPER = new ObjectMapper();
     
     @SuppressWarnings("unchecked")
     public void testSampleDoc() throws Exception
@@ -105,7 +117,7 @@ public class TestUntypedDeserialization
         /* To get "untyped" Mapping (to Maps, Lists, instead of beans etc),
          * we'll specify plain old Object.class as the target.
          */
-        Object root = new ObjectMapper().readValue(JSON, Object.class);
+        Object root = MAPPER.readValue(JSON, Object.class);
 
         assertType(root, Map.class);
         Map<?,?> rootMap = (Map<?,?>) root;
@@ -154,8 +166,7 @@ public class TestUntypedDeserialization
     public void testNestedUntypes() throws IOException
     {
         // 05-Apr-2014, tatu: Odd failures if using shared mapper; so work around:
-        final ObjectMapper mapper = new ObjectMapper();
-        Object root = mapper.readValue(aposToQuotes("{'a':3,'b':[1,2]}"),
+        Object root = MAPPER.readValue(aposToQuotes("{'a':3,'b':[1,2]}"),
                 Object.class);
         assertTrue(root instanceof Map<?,?>);
         Map<?,?> map = (Map<?,?>) root;
@@ -168,7 +179,7 @@ public class TestUntypedDeserialization
         assertEquals(Integer.valueOf(2), l.get(1));
     }
     
-    // [JACKSON-839]: allow 'upgrade' of big integers into Long, BigInteger
+    // Allow 'upgrade' of big integers into Long, BigInteger
     public void testObjectSerializeWithLong() throws IOException
     {
         final ObjectMapper mapper = new ObjectMapper();
@@ -239,4 +250,20 @@ public class TestUntypedDeserialization
         assertEquals(1, map.size());
         assertEquals("Ytrue", map.get("a"));
     }
+
+    public void testNestedUntyped989() throws IOException
+    {
+        Untyped989 pojo;
+        ObjectReader r = MAPPER.readerFor(Untyped989.class);
+
+        pojo = r.readValue("[]");
+        assertTrue(pojo.value instanceof List);
+        pojo = r.readValue("[{}]");
+        assertTrue(pojo.value instanceof List);
+        
+        pojo = r.readValue("{}");
+        assertTrue(pojo.value instanceof Map);
+        pojo = r.readValue("{\"a\":[]}");
+        assertTrue(pojo.value instanceof Map);
+    }
 }
