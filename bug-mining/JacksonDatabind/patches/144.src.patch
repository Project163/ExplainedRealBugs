diff --git a/backup/TypeSerializerWrapper.java b/backup/TypeSerializerWrapper.java
deleted file mode 100644
index b0ffb29ad..000000000
--- a/backup/TypeSerializerWrapper.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package com.fasterxml.jackson.databind.jsontype;
-
-import java.io.IOException;
-
-import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.BeanProperty;
-
-/**
- * Helper class used in cases where we caller has to override source
- * for type identifier, for example when serializing a value using
- * a delegate or surrogate value, in which case type id is to be based
- * on the original value, but serialization done using surrogate.
- * 
- * @since 2.2
- */
-public class TypeSerializerWrapper
-    extends TypeSerializer
-{
-    /**
-     * Actual TypeSerializer to use
-     */
-    protected final TypeSerializer _delegate;
-
-    protected final Object _value;
-    
-    public TypeSerializerWrapper(TypeSerializer delegate, Object value)
-    {
-        _delegate = delegate;
-        _value = value;
-    }
-    
-    /*
-    /**********************************************************
-    /* TypeSerializer implementation, metadata
-    /**********************************************************
-     */
-    
-    @Override
-    public TypeSerializer forProperty(BeanProperty prop) {
-        TypeSerializer d2 = _delegate.forProperty(prop);
-        if (d2 == _delegate) {
-            return this;
-        }
-        return new TypeSerializerWrapper(d2, _value);
-    }
-
-    @Override
-    public As getTypeInclusion() {
-        return _delegate.getTypeInclusion();
-    }
-
-    @Override
-    public String getPropertyName() {
-        return _delegate.getPropertyName();
-    }
-
-    @Override
-    public TypeIdResolver getTypeIdResolver() {
-        return _delegate.getTypeIdResolver();
-    }
-
-    /*
-    /**********************************************************
-    /* TypeSerializer implementation, actual write methods
-    /**********************************************************
-     */
-    
-    @Override
-    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypePrefixForScalar(_value, jgen);
-    }
-
-    @Override
-    public void writeTypePrefixForObject(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypePrefixForObject(_value, jgen);
-    }
-
-    @Override
-    public void writeTypePrefixForArray(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypePrefixForArray(_value, jgen);
-    }
-
-    @Override
-    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypeSuffixForScalar(_value, jgen);
-    }
-
-    @Override
-    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypeSuffixForObject(_value, jgen);
-    }
-
-    @Override
-    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)
-            throws IOException, JsonProcessingException {
-        _delegate.writeTypeSuffixForArray(_value, jgen);
-    }
-
-    @Override
-    public void writeCustomTypePrefixForScalar(Object value,
-            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {
-        _delegate.writeCustomTypePrefixForScalar(_value, jgen, typeId);
-    }
-
-    @Override
-    public void writeCustomTypePrefixForObject(Object value,
-            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {
-        _delegate.writeCustomTypePrefixForObject(_value, jgen, typeId);
-    }
-
-    @Override
-    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen,
-            String typeId) throws IOException, JsonProcessingException {
-        _delegate.writeCustomTypePrefixForArray(_value, jgen, typeId);
-    }
-
-    @Override
-    public void writeCustomTypeSuffixForScalar(Object value,
-            JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException {
-        _delegate.writeCustomTypeSuffixForScalar(_value, jgen, typeId);
-    }
-
-    @Override
-    public void writeCustomTypeSuffixForObject(Object value,
-            JsonGenerator jgen, String typeId) throws IOException,
-            JsonProcessingException {
-        _delegate.writeCustomTypeSuffixForObject(_value, jgen, typeId);
-    }
-
-    @Override
-    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen,
-            String typeId) throws IOException, JsonProcessingException {
-        _delegate.writeCustomTypeSuffixForArray(_value, jgen, typeId);
-    }
-}
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
index bf0b8a40b..7b13fbaaf 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
@@ -109,31 +109,42 @@ public class AbstractDeserializer
      */
     
     @Override
-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
             TypeDeserializer typeDeserializer)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         // Hmmh. One tricky question; for scalar, is it an Object Id, or "Natural" type?
         // for now, prefer Object Id:
         if (_objectIdReader != null) {
-            JsonToken t = jp.getCurrentToken();
-            // should be good enough check; we only care about Strings, integral numbers:
-            if (t != null && t.isScalarValue()) {
-                return _deserializeFromObjectId(jp, ctxt);
+            JsonToken t = p.getCurrentToken();
+            if (t != null) {
+                // Most commonly, a scalar (int id, uuid String, ...)
+                if (t.isScalarValue()) {
+                    return _deserializeFromObjectId(p, ctxt);
+                }
+                // but, with 2.5+, a simple Object-wrapped value also legal:
+                if (t == JsonToken.START_OBJECT) {
+                    t = p.nextToken();
+                }
+                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
+                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {
+                    return _deserializeFromObjectId(p, ctxt);
+                }
+            
             }
         }
         
         // First: support "natural" values (which are always serialized without type info!)
-        Object result = _deserializeIfNatural(jp, ctxt);
+        Object result = _deserializeIfNatural(p, ctxt);
         if (result != null) {
             return result;
         }
-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);
+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);
     }
 
     @Override
-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)
-            throws IOException, JsonProcessingException
+    public Object deserialize(JsonParser p, DeserializationContext ctxt)
+        throws IOException
     {
         // This method should never be called...
         throw ctxt.instantiationException(_baseType.getRawClass(),
@@ -146,28 +157,28 @@ public class AbstractDeserializer
     /**********************************************************
      */
     
-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException
+    protected Object _deserializeIfNatural(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        /* As per [JACKSON-417], there is a chance we might be "natural" types
+        /* There is a chance we might be "natural" types
          * (String, Boolean, Integer, Double), which do not include any type information...
          * Care must be taken to only return this if return type matches, however.
          * Finally, we may have to consider possibility of custom handlers for
          * these values: but for now this should work ok.
          */
-        switch (jp.getCurrentTokenId()) {
+        switch (p.getCurrentTokenId()) {
         case JsonTokenId.ID_STRING:
             if (_acceptString) {
-                return jp.getText();
+                return p.getText();
             }
             break;
         case JsonTokenId.ID_NUMBER_INT:
             if (_acceptInt) {
-                return jp.getIntValue();
+                return p.getIntValue();
             }
             break;
         case JsonTokenId.ID_NUMBER_FLOAT:
             if (_acceptDouble) {
-                return Double.valueOf(jp.getDoubleValue());
+                return Double.valueOf(p.getDoubleValue());
             }
             break;
         case JsonTokenId.ID_TRUE:
@@ -188,18 +199,16 @@ public class AbstractDeserializer
      * Method called in cases where it looks like we got an Object Id
      * to parse and use as a reference.
      */
-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException
+    protected Object _deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        Object id = _objectIdReader.readObjectReference(jp, ctxt);
+        Object id = _objectIdReader.readObjectReference(p, ctxt);
         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
         // do we have it resolved?
         Object pojo = roid.resolve();
         if (pojo == null) { // not yet; should wait...
-            throw new UnresolvedForwardReference(jp,
-                    "Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", jp.getCurrentLocation(), roid);
+            throw new UnresolvedForwardReference(p,
+                    "Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", p.getCurrentLocation(), roid);
         }
         return pojo;
     }
 }
-
-
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
index ad585cd5a..2c3260abb 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
@@ -982,7 +982,7 @@ public abstract class BeanDeserializerBase
                 if (t == JsonToken.START_OBJECT) {
                     t = p.nextToken();
                 }
-                if (t == JsonToken.FIELD_NAME && _objectIdReader.maySerializeAsObject()
+                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
                         && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {
                     return deserializeFromObjectId(p, ctxt);
                 }
@@ -1256,17 +1256,18 @@ public abstract class BeanDeserializerBase
         throw ctxt.mappingException(handledType());
     }
 
-    public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException
+    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)
+        throws IOException
     {
         // First things first: id Object Id is used, most likely that's it; specifically,
         // true for UUIDs when written as binary (with Smile, other binary formats)
         if (_objectIdReader != null) {
-            return deserializeFromObjectId(jp, ctxt);
+            return deserializeFromObjectId(p, ctxt);
         }
 
         // TODO: maybe add support for ValueInstantiator, embedded?
         
-        return jp.getEmbeddedObject();
+        return p.getEmbeddedObject();
     }
     
     /*
@@ -1276,7 +1277,7 @@ public abstract class BeanDeserializerBase
      */
 
     protected void injectValues(DeserializationContext ctxt, Object bean)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         for (ValueInjector injector : _injectables) {
             injector.inject(ctxt, bean);
@@ -1291,11 +1292,11 @@ public abstract class BeanDeserializerBase
     @SuppressWarnings("resource")
     protected Object handleUnknownProperties(DeserializationContext ctxt,
             Object bean, TokenBuffer unknownTokens)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         // First: add closing END_OBJECT as marker
         unknownTokens.writeEndObject();
-        
+
         // note: buffer does NOT have starting START_OBJECT
         JsonParser bufferParser = unknownTokens.asParser();
         while (bufferParser.nextToken() != JsonToken.END_OBJECT) {
@@ -1311,22 +1312,22 @@ public abstract class BeanDeserializerBase
      * Helper method called for an unknown property, when using "vanilla"
      * processing.
      */
-    protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt,
+    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,
             Object bean, String propName)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         if (_ignorableProps != null && _ignorableProps.contains(propName)) {
-            handleIgnoredProperty(jp, ctxt, bean, propName);
+            handleIgnoredProperty(p, ctxt, bean, propName);
         } else if (_anySetter != null) {
             try {
                // should we consider return type of any setter?
-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);
+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);
             } catch (Exception e) {
                 wrapAndThrow(e, bean, propName, ctxt);
             }
         } else {
             // Unknown: let's call handler method
-            handleUnknownProperty(jp, ctxt, bean, propName);         
+            handleUnknownProperty(p, ctxt, bean, propName);         
         }
     }
 
@@ -1335,20 +1336,20 @@ public abstract class BeanDeserializerBase
      * setter, any-setter or field, and thus can not be assigned.
      */
     @Override
-    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,
+    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,
             Object beanOrClass, String propName)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         if (_ignoreAllUnknown) {
-            jp.skipChildren();
+            p.skipChildren();
             return;
         }
         if (_ignorableProps != null && _ignorableProps.contains(propName)) {
-            handleIgnoredProperty(jp, ctxt, beanOrClass, propName);
+            handleIgnoredProperty(p, ctxt, beanOrClass, propName);
         }
         // Otherwise use default handling (call handler(s); if not
         // handled, throw exception or skip depending on settings)
-        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);
+        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);
     }
 
     /**
@@ -1357,14 +1358,14 @@ public abstract class BeanDeserializerBase
      * 
      * @since 2.3
      */
-    protected void handleIgnoredProperty(JsonParser jp, DeserializationContext ctxt,
+    protected void handleIgnoredProperty(JsonParser p, DeserializationContext ctxt,
             Object beanOrClass, String propName)
-        throws IOException, JsonProcessingException
+        throws IOException
     {
         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)) {
-            throw IgnoredPropertyException.from(jp, beanOrClass, propName, getKnownPropertyNames());
+            throw IgnoredPropertyException.from(p, beanOrClass, propName, getKnownPropertyNames());
         }
-        jp.skipChildren();
+        p.skipChildren();
     }
     
     /**
@@ -1374,14 +1375,14 @@ public abstract class BeanDeserializerBase
      * class; either way, we may have more specific deserializer to use
      * for handling it.
      *
-     * @param jp (optional) If not null, parser that has more properties to handle
+     * @param p (optional) If not null, parser that has more properties to handle
      *   (in addition to buffered properties); if null, all properties are passed
      *   in buffer
      */
     @SuppressWarnings("resource")
-    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          
+    protected Object handlePolymorphic(JsonParser p, DeserializationContext ctxt,                                          
             Object bean, TokenBuffer unknownTokens)
-        throws IOException, JsonProcessingException
+        throws IOException
     {  
         // First things first: maybe there is a more specific deserializer available?
         JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);
@@ -1394,8 +1395,8 @@ public abstract class BeanDeserializerBase
                 bean = subDeser.deserialize(p2, ctxt, bean);
             }
             // Original parser may also have some leftovers
-            if (jp != null) {
-                bean = subDeser.deserialize(jp, ctxt, bean);
+            if (p != null) {
+                bean = subDeser.deserialize(p, ctxt, bean);
             }
             return bean;
         }
@@ -1404,8 +1405,8 @@ public abstract class BeanDeserializerBase
             bean = handleUnknownProperties(ctxt, bean, unknownTokens);
         }
         // and/or things left to process via main parser?
-        if (jp != null) {
-            bean = deserialize(jp, ctxt, bean);
+        if (p != null) {
+            bean = deserialize(p, ctxt, bean);
         }
         return bean;
     }
@@ -1416,7 +1417,7 @@ public abstract class BeanDeserializerBase
      */
     protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,
             Object bean, TokenBuffer unknownTokens)
-        throws IOException, JsonProcessingException
+        throws IOException
     {  
         JsonDeserializer<Object> subDeser;
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java
deleted file mode 100644
index ea6b3b494..000000000
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java
+++ /dev/null
@@ -1,378 +0,0 @@
-package com.fasterxml.jackson.databind.ser.std;
-
-import java.io.IOException;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.*;
-
-import com.fasterxml.jackson.core.*;
-import com.fasterxml.jackson.databind.*;
-import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;
-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;
-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;
-import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
-import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.fasterxml.jackson.databind.node.ObjectNode;
-import com.fasterxml.jackson.databind.ser.ContainerSerializer;
-import com.fasterxml.jackson.databind.ser.ContextualSerializer;
-import com.fasterxml.jackson.databind.util.EnumValues;
-
-/**
- * Specialized serializer for {@link EnumMap}s. Somewhat tricky to
- * implement because actual Enum value type may not be available;
- * and if not, it can only be gotten from actual instance.
- * 
- * @deprecated Since 2.4.4; standard {@link MapSerializer} works better.
- *   (to be removed from 2.6)
- */
-@SuppressWarnings("serial")
-@JacksonStdImpl
-@Deprecated
-public class EnumMapSerializer
-    extends ContainerSerializer<EnumMap<? extends Enum<?>, ?>>
-    implements ContextualSerializer
-{
-    protected final boolean _staticTyping;
-
-    /**
-     * Property for which this serializer is being used, if any;
-     * null for root values.
-     */
-    protected final BeanProperty _property;
-    
-    /**
-     * If we know enumeration used as key, this will contain
-     * value set to use for serialization
-     */
-    protected final EnumValues _keyEnums;
-
-    protected final JavaType _valueType;
-    
-    /**
-     * Value serializer to use, if it can be statically determined
-     */
-    protected final JsonSerializer<Object> _valueSerializer;
-
-    /**
-     * Type serializer used for values, if any.
-     */
-    protected final TypeSerializer _valueTypeSerializer;
-
-    /*
-    /**********************************************************
-    /* Life-cycle
-    /**********************************************************
-     */
-
-    public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,
-            TypeSerializer vts, JsonSerializer<Object> valueSerializer)
-    {
-        super(EnumMap.class, false);
-        _property = null; // not yet known
-        _staticTyping = staticTyping || (valueType != null && valueType.isFinal());
-        _valueType = valueType;
-        _keyEnums = keyEnums;
-        _valueTypeSerializer = vts;
-        _valueSerializer = valueSerializer;
-    }
-
-    /**
-     * Constructor called when a contextual instance is created.
-     */
-    @SuppressWarnings("unchecked")
-    public EnumMapSerializer(EnumMapSerializer src, BeanProperty property,
-            JsonSerializer<?> ser)
-    {
-        super(src);
-        _property = property;
-        _staticTyping = src._staticTyping;
-        _valueType = src._valueType;
-        _keyEnums = src._keyEnums;
-        _valueTypeSerializer = src._valueTypeSerializer;
-        _valueSerializer = (JsonSerializer<Object>) ser;
-    }
-    
-    @Override
-    public EnumMapSerializer _withValueTypeSerializer(TypeSerializer vts) {
-        return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts,  _valueSerializer);
-    }
-
-    public EnumMapSerializer withValueSerializer(BeanProperty prop, JsonSerializer<?> ser) {
-        if (_property == prop && ser == _valueSerializer) {
-            return this;
-        }
-        return new EnumMapSerializer(this, prop, ser);
-    }
-
-    @Override
-    public JsonSerializer<?> createContextual(SerializerProvider provider,
-            BeanProperty property)
-        throws JsonMappingException
-    {
-        /* 29-Sep-2012, tatu: Actually, we need to do much more contextual
-         *    checking here since we finally know for sure the property,
-         *    and it may have overrides
-         */
-        JsonSerializer<?> ser = null;
-        // First: if we have a property, may have property-annotation overrides
-        if (property != null) {
-            AnnotatedMember m = property.getMember();
-            if (m != null) {
-                Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m);
-                if (serDef != null) {
-                    ser = provider.serializerInstance(m, serDef);
-                }
-            }
-        }
-        if (ser == null) {
-            ser = _valueSerializer;
-        }
-        // #124: May have a content converter
-        ser = findConvertingContentSerializer(provider, property, ser);
-        if (ser == null) {
-            if (_staticTyping) {
-                return withValueSerializer(property, provider.findValueSerializer(_valueType, property));
-            }
-        } else {
-            ser = provider.handleSecondaryContextualization(ser, property);
-        }
-        if (ser != _valueSerializer) {
-            return withValueSerializer(property, ser);
-        }
-        return this;
-    }
-    
-    /*
-    /**********************************************************
-    /* Accessors
-    /**********************************************************
-     */
-    
-    @Override
-    public JavaType getContentType() {
-        return _valueType;
-    }
-
-    @Override
-    public JsonSerializer<?> getContentSerializer() {
-        return _valueSerializer;
-    }
-    
-    @Override
-    public boolean isEmpty(SerializerProvider prov, EnumMap<? extends Enum<?>,?> value) {
-        return (value == null) || value.isEmpty();
-    }
-
-    @Override
-    public boolean hasSingleElement(EnumMap<? extends Enum<?>, ?> value) {
-        return value.size() == 1;
-    }
-    
-    /*
-    /**********************************************************
-    /* Serialization
-    /**********************************************************
-     */
-    
-    @Override
-    public void serialize(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider)
-        throws IOException, JsonGenerationException
-    {
-        jgen.writeStartObject();
-        if (!value.isEmpty()) {
-            serializeContents(value, jgen, provider);
-        }        
-        jgen.writeEndObject();
-    }
-
-    @Override
-    public void serializeWithType(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider,
-            TypeSerializer typeSer)
-        throws IOException, JsonGenerationException
-    {
-        typeSer.writeTypePrefixForObject(value, jgen);
-        if (!value.isEmpty()) {
-            serializeContents(value, jgen, provider);
-        }
-        typeSer.writeTypeSuffixForObject(value, jgen);
-    }
-    
-    protected void serializeContents(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider)
-        throws IOException, JsonGenerationException
-    {
-        if (_valueSerializer != null) {
-            serializeContentsUsing(value, jgen, provider, _valueSerializer);
-            return;
-        }
-        JsonSerializer<Object> prevSerializer = null;
-        Class<?> prevClass = null;
-        EnumValues keyEnums = _keyEnums;
-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);
-        final boolean useToString = provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
-        final TypeSerializer vts = _valueTypeSerializer;
-
-        for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {
-            final Object valueElem = entry.getValue();
-            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?
-                continue;
-            }
-            // First, serialize key
-            final Enum<?> key = entry.getKey();
-            if (useToString) {
-                jgen.writeFieldName(key.toString());
-            } else {
-                if (keyEnums == null) {
-                    /* 15-Oct-2009, tatu: This is clumsy, but still the simplest efficient
-                     * way to do it currently, as Serializers get cached. (it does assume we'll always use
-                     * default serializer tho -- so ideally code should be rewritten)
-                     */
-                    // ... and lovely two-step casting process too...
-                    StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(
-                            key.getDeclaringClass(), _property);
-                    keyEnums = ((EnumSerializer) ser).getEnumValues();
-                }
-                jgen.writeFieldName(keyEnums.serializedValueFor(key));
-            }
-            if (valueElem == null) {
-                provider.defaultSerializeNull(jgen);
-                continue;
-            }
-            Class<?> cc = valueElem.getClass();
-            JsonSerializer<Object> currSerializer;
-            if (cc == prevClass) {
-                currSerializer = prevSerializer;
-            } else {
-                currSerializer = provider.findValueSerializer(cc, _property);
-                prevSerializer = currSerializer;
-                prevClass = cc;
-            }
-            try {
-                if (vts == null) {
-                    currSerializer.serialize(valueElem, jgen, provider);
-                } else {
-                    currSerializer.serializeWithType(valueElem, jgen, provider, vts);
-                }
-            } catch (Exception e) {
-                // [JACKSON-55] Need to add reference information
-                wrapAndThrow(provider, e, value, entry.getKey().name());
-            }
-        }
-    }
-
-    protected void serializeContentsUsing(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider,
-            JsonSerializer<Object> valueSer)
-        throws IOException, JsonGenerationException
-    {
-        EnumValues keyEnums = _keyEnums;
-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);
-        final boolean useToString = provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
-        final TypeSerializer vts = _valueTypeSerializer;
-        
-        for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {
-            final Object valueElem = entry.getValue();
-            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?
-                continue;
-            }
-            Enum<?> key = entry.getKey();
-            if (useToString) {
-                jgen.writeFieldName(key.toString());
-            } else {
-                if (keyEnums == null) {
-                    // clumsy, but has to do for now:
-                    StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(),
-                            _property);
-                    keyEnums = ((EnumSerializer) ser).getEnumValues();
-                }
-                jgen.writeFieldName(keyEnums.serializedValueFor(key));
-            }
-            if (valueElem == null) {
-                provider.defaultSerializeNull(jgen);
-                continue;
-            }
-            try {
-                if (vts == null) {
-                    valueSer.serialize(valueElem, jgen, provider);
-                } else {
-                    valueSer.serializeWithType(valueElem, jgen, provider, vts);
-                }
-            } catch (Exception e) {
-                wrapAndThrow(provider, e, value, entry.getKey().name());
-            }
-        }
-    }
-    
-    @SuppressWarnings({ "unchecked" })
-    @Override
-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)
-        throws JsonMappingException
-    {
-        ObjectNode o = createSchemaNode("object", true);
-        if (typeHint instanceof ParameterizedType) {
-            Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();
-            if (typeArgs.length == 2) {
-                JavaType enumType = provider.constructType(typeArgs[0]);
-                JavaType valueType = provider.constructType(typeArgs[1]);
-                ObjectNode propsNode = JsonNodeFactory.instance.objectNode();
-                Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();
-                for (Enum<?> enumValue : enumClass.getEnumConstants()) {
-                    JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property);
-                    JsonNode schemaNode = (ser instanceof SchemaAware) ?
-                            ((SchemaAware) ser).getSchema(provider, null) :
-                            	com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();
-                    propsNode.set(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue), schemaNode);
-                }
-                o.set("properties", propsNode);
-            }
-        }
-        return o;
-    }
-
-    /**
-     * We consider possibility here that an EnumMap might actually just be serialized
-     * as something like a Record, given that number of keys is bound, just like
-     * with Objects/Records (and not unbounded like regular maps)
-     */
-    @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-        throws JsonMappingException
-    {
-        if (visitor == null) {
-            return;
-        }
-        JsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);
-        if (objectVisitor == null) {
-            return;
-        }
-        JavaType valueType = typeHint.containedType(1);
-        JsonSerializer<Object> ser = _valueSerializer;
-        if (ser == null && valueType != null) {
-            ser = visitor.getProvider().findValueSerializer(valueType, _property);
-        }
-        if (valueType == null) {
-            valueType = visitor.getProvider().constructType(Object.class);
-        }
-        EnumValues keyEnums = _keyEnums;
-        if (keyEnums == null) {
-            JavaType enumType = typeHint.containedType(0);
-             if (enumType == null) {
-                 throw new IllegalStateException("Can not resolve Enum type of EnumMap: "+typeHint);
-             }
-             JsonSerializer<?> enumSer = visitor.getProvider().findValueSerializer(enumType, _property);
-             if (!(enumSer instanceof EnumSerializer)) {
-                 throw new IllegalStateException("Can not resolve Enum type of EnumMap: "+typeHint);
-             }
-             keyEnums = ((EnumSerializer) enumSer).getEnumValues();
-        }
-        for (Map.Entry<?,SerializableString> entry : keyEnums.internalMap().entrySet()) {
-            String name = entry.getValue().getValue();
-            // should all have the same type, so:
-            if (ser == null) {
-                ser = visitor.getProvider().findValueSerializer(entry.getKey().getClass(), _property);
-            }
-            objectVisitor.property(name, (JsonFormatVisitable) ser, valueType);
-        }
-    }
-}
diff --git a/src/test/java/com/fasterxml/jackson/databind/deprecated/MiscDeprecatedTest.java b/src/test/java/com/fasterxml/jackson/databind/deprecated/MiscDeprecatedTest.java
deleted file mode 100644
index 3fe9d0ebe..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/deprecated/MiscDeprecatedTest.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.fasterxml.jackson.databind.deprecated;
-
-import com.fasterxml.jackson.databind.*;
-import com.fasterxml.jackson.databind.ser.std.EnumMapSerializer;
-import com.fasterxml.jackson.databind.util.EnumValues;
-
-@SuppressWarnings("deprecation")
-public class MiscDeprecatedTest extends BaseMapTest
-{
-    private final ObjectMapper MAPPER = objectMapper();
-
-    @SuppressWarnings("unchecked")
-    public void testOldEnumMapSerializer() throws Exception
-    {
-        /*
-        public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,
-                TypeSerializer vts, JsonSerializer<Object> valueSerializer)
-                */
-        // to be removed from 2.7 or so:
-        Class<?> enumClass = ABC.class;
-        EnumMapSerializer ser = new EnumMapSerializer(MAPPER.constructType(String.class), true,
-                EnumValues.construct(MAPPER.getSerializationConfig(), (Class<Enum<?>>) enumClass),
-                null, /* value serializer */ null);
-        
-        // ... and?
-        assertNotNull(ser);
-    }
-}
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java
index 6229f2c11..719c10983 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java
@@ -403,12 +403,14 @@ public class TestObjectNode
         ObjectNode object = MAPPER.createObjectNode();
 
         String json = MAPPER.writeValueAsString(object);
-        System.out.println("json: "+json);
+//        System.out.println("json: "+json);
 
         ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works
-        System.out.println("Deserialized to ObjectNode: "+de1);
+//        System.out.println("Deserialized to ObjectNode: "+de1);
+        assertNotNull(de1);
 
         MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception
-        System.out.println("Deserialized to MyValue: "+de2);
+//        System.out.println("Deserialized to MyValue: "+de2);
+        assertNotNull(de2);
     }
 }
