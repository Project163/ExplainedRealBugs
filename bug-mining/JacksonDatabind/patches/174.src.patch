diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
index ecb7e8c49..4f9cd74bd 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
@@ -155,9 +155,9 @@ public class StdDelegatingDeserializer<T>
      */
     
     @Override
-    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
+    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        Object delegateValue = _delegateDeserializer.deserialize(jp, ctxt);
+        Object delegateValue = _delegateDeserializer.deserialize(p, ctxt);
         if (delegateValue == null) {
             return null;
         }
@@ -165,14 +165,21 @@ public class StdDelegatingDeserializer<T>
     }
 
     @Override
-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
             TypeDeserializer typeDeserializer) throws IOException
     {
-        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
-         *    let's give it a chance?
+        /* 12-Apr-2016, tatu: As predicted, earlier handling does not work
+         *   (see [databind#1189] for details). There does not seem to be any compelling
+         *   way to combine polymorphic types, Converters, but the least sucky way
+         *   is probably to use Converter and ignore polymorphic type. Alternative
+         *   would be to try to change `TypeDeserializer` to accept `Converter` to
+         *   invoke... but that is more intrusive, yet not guaranteeing success.
          */
-        Object delegateValue = _delegateDeserializer.deserializeWithType(jp, ctxt,
-                typeDeserializer);
+        // method called up to 2.7.3:
+//        Object delegateValue = _delegateDeserializer.deserializeWithType(p, ctxt, typeDeserializer);
+
+        // method called since 2.7.4
+        Object delegateValue = _delegateDeserializer.deserialize(p, ctxt);
         if (delegateValue == null) {
             return null;
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
index 3821a68e8..37a86e1e2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
@@ -35,11 +35,9 @@ public abstract class TypeDeserializer
      * (as is the case for bean properties), or values contained
      * (for {@link java.util.Collection} or {@link java.util.Map}
      * valued properties).
-     * 
-     * @since 2.0
      */
     public abstract TypeDeserializer forProperty(BeanProperty prop);
-    
+
     /*
     /**********************************************************
     /* Introspection
@@ -72,7 +70,7 @@ public abstract class TypeDeserializer
      * resolved)
      */
     public abstract Class<?> getDefaultImpl();
-    
+
     /*
     /**********************************************************
     /* Type deserialization methods
@@ -88,7 +86,7 @@ public abstract class TypeDeserializer
      * call it with JSON data to deserializer (which does not contain
      * type information).
      */
-    public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException;
+    public abstract Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException;
 
     /**
      * Method called to let this type deserializer handle 
@@ -99,7 +97,7 @@ public abstract class TypeDeserializer
      * call it with JSON data to deserializer (which does not contain
      * type information).
      */
-    public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException;
+    public abstract Object deserializeTypedFromArray(JsonParser p, DeserializationContext ctxt) throws IOException;
 
     /**
      * Method called to let this type deserializer handle 
@@ -111,7 +109,7 @@ public abstract class TypeDeserializer
      * call it with JSON data to deserializer (which does not contain
      * type information).
      */
-    public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException;
+    public abstract Object deserializeTypedFromScalar(JsonParser p, DeserializationContext ctxt) throws IOException;
 
     /**
      * Method called to let this type deserializer handle 
@@ -122,7 +120,7 @@ public abstract class TypeDeserializer
      * using JSON node representation, or "untyped" Java object
      * (which may be Map, Collection, wrapper/primitive etc).
      */
-    public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException;
+    public abstract Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException;
 
     /*
     /**********************************************************
@@ -135,32 +133,33 @@ public abstract class TypeDeserializer
      * a "natural" value, and one that would be acceptable as the
      * result value (compatible with declared base type)
      */
-    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, JavaType baseType) throws IOException {
-        return deserializeIfNatural(jp, ctxt, baseType.getRawClass());
+    public static Object deserializeIfNatural(JsonParser p, DeserializationContext ctxt, JavaType baseType) throws IOException {
+        return deserializeIfNatural(p, ctxt, baseType.getRawClass());
     }
-    
+
     @SuppressWarnings("incomplete-switch")
-    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException
+    public static Object deserializeIfNatural(JsonParser p, DeserializationContext ctxt,
+            Class<?> base) throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
+        JsonToken t = p.getCurrentToken();
         if (t == null) {
             return null;
         }
         switch (t) {
         case VALUE_STRING:
             if (base.isAssignableFrom(String.class)) {
-                return jp.getText();
+                return p.getText();
             }
             break;
         case VALUE_NUMBER_INT:
             if (base.isAssignableFrom(Integer.class)) {
-                return jp.getIntValue();
+                return p.getIntValue();
             }
             break;
 
         case VALUE_NUMBER_FLOAT:
             if (base.isAssignableFrom(Double.class)) {
-                return Double.valueOf(jp.getDoubleValue());
+                return Double.valueOf(p.getDoubleValue());
             }
             break;
         case VALUE_TRUE:
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/Converter.java b/src/main/java/com/fasterxml/jackson/databind/util/Converter.java
index d41834cf0..df5dc6ac1 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/Converter.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/Converter.java
@@ -13,9 +13,10 @@ import com.fasterxml.jackson.databind.type.TypeFactory;
  *
  * @param <IN> Type of values converter takes
  * @param <OUT> Result type from conversion
- * 
+ *
  * @see com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer
- * 
+ * @see com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer
+ *
  * @since 2.1
  */
 public interface Converter<IN,OUT>
