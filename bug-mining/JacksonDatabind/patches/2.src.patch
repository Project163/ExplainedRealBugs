diff --git a/release-notes/VERSION b/release-notes/VERSION
index 2628a077c..af9d2e05b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -4,6 +4,8 @@ New minor version.
 
 Fixes:
 
+* [Issue#118]: JsonTypeInfo.as.EXTERNAL_PROPERTY not working correctly
+ with missing type id, scalar types
 * [Issue#144]: MissingNode.isValueNode() should return 'false'
  (reported by 'fge@github')
 * [Issue#146]: Creator properties were not being renamed as expected
@@ -26,6 +28,10 @@ New features:
 Other:
 
 * [Issue#126]: Update JDK baseline to 1.6
+* API under 'com.fasterxml.jackson.databind.jsonFormatVisitors' changed significantly
+  based on experiences with external JSON Schema generator.
+* Version information accessed via code-generated access class, instead of reading
+  VERSION.txt
 
 ------------------------------------------------------------------------
 === History: ===
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
index f6ec3f6e8..d95091db2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
@@ -6,6 +6,7 @@ import java.util.*;
 import com.fasterxml.jackson.core.*;
 
 import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 import com.fasterxml.jackson.databind.util.TokenBuffer;
@@ -130,16 +131,31 @@ public class ExternalTypeHandler
         for (int i = 0, len = _properties.length; i < len; ++i) {
             String typeId = _typeIds[i];
             if (typeId == null) {
+                TokenBuffer tokens = _tokens[i];
                 // let's allow missing both type and property (may already have been set, too)
-                if (_tokens[i] == null) {
+                // but not just one
+                if (tokens == null) {
                     continue;
                 }
-                // but not just one
-                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'
-                if (!_properties[i].hasDefaultType()) {
-                    throw ctxt.mappingException("Missing external type id property '"+_properties[i].getTypePropertyName()+"'");
+                /* [Issue#118]: Need to mind natural types, for which no type id
+                 *   will be included.
+                 */
+                JsonToken t = tokens.firstToken();
+                if (t != null && t.isScalarValue()) {
+                    JsonParser buffered = tokens.asParser(jp);
+                    buffered.nextToken();
+                    SettableBeanProperty extProp = _properties[i].getProperty();
+                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());
+                    if (result != null) {
+                        extProp.set(bean, result);
+                        continue;
+                    }
+                    // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'
+                    if (!_properties[i].hasDefaultType()) {
+                        throw ctxt.mappingException("Missing external type id property '"+_properties[i].getTypePropertyName()+"'");
+                    }
+                    typeId = _properties[i].getDefaultTypeId();
                 }
-                typeId = _properties[i].getDefaultTypeId();
             } else if (_tokens[i] == null) {
                 SettableBeanProperty prop = _properties[i].getProperty();
                 throw ctxt.mappingException("Missing property '"+prop.getName()+"' for external type id '"+_properties[i].getTypePropertyName());
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
index d0c95b90b..a2dbe80c7 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java
@@ -5,6 +5,7 @@ import java.io.IOException;
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.BeanProperty;
 import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.JsonDeserializer;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
 
@@ -131,5 +132,61 @@ public abstract class TypeDeserializer
             DeserializationContext ctxt)
         throws IOException, JsonProcessingException;
 
+    /*
+    /**********************************************************
+    /* Shared helper methods
+    /**********************************************************
+     */
+
+    /**
+     * Helper method used to check if given parser might be pointing to
+     * a "natural" value, and one that would be acceptable as the
+     * result value (compatible with declared base type)
+     */
+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,
+            JavaType baseType)
+        throws IOException, JsonProcessingException
+    {
+        return deserializeIfNatural(jp, ctxt, baseType.getRawClass());
+    }
+    
+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,
+            Class<?> base)
+        throws IOException, JsonProcessingException
+    {
+        JsonToken t = jp.getCurrentToken();
+        if (t == null) {
+            return null;
+        }
+        switch (t) {
+        case VALUE_STRING:
+            if (base.isAssignableFrom(String.class)) {
+                return jp.getText();
+            }
+            break;
+        case VALUE_NUMBER_INT:
+            if (base.isAssignableFrom(Integer.class)) {
+                return jp.getIntValue();
+            }
+            break;
+
+        case VALUE_NUMBER_FLOAT:
+            if (base.isAssignableFrom(Double.class)) {
+                return Double.valueOf(jp.getDoubleValue());
+            }
+            break;
+        case VALUE_TRUE:
+            if (base.isAssignableFrom(Boolean.class)) {
+                return Boolean.TRUE;
+            }
+            break;
+        case VALUE_FALSE:
+            if (base.isAssignableFrom(Boolean.class)) {
+                return Boolean.FALSE;
+            }
+            break;
+        }
+        return null;
+    }
 }
     
\ No newline at end of file
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
index 3bc804416..cab8d520e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
@@ -130,7 +130,7 @@ public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer
             return deser.deserialize(jp, ctxt);
         }
         // or, perhaps we just bumped into a "natural" value (boolean/int/double/String)?
-        Object result = _deserializeIfNatural(jp, ctxt);
+        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);
         if (result != null) {
             return result;
         }
@@ -162,43 +162,4 @@ public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer
     // These are fine from base class:
     //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)
     //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    
-
-    /**
-     * Helper method used to check if given parser might be pointing to
-     * a "natural" value, and one that would be acceptable as the
-     * result value (compatible with declared base type)
-     */
-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)
-        throws IOException, JsonProcessingException
-    {
-        switch (jp.getCurrentToken()) {
-        case VALUE_STRING:
-            if (_baseType.getRawClass().isAssignableFrom(String.class)) {
-                return jp.getText();
-            }
-            break;
-        case VALUE_NUMBER_INT:
-            if (_baseType.getRawClass().isAssignableFrom(Integer.class)) {
-                return jp.getIntValue();
-            }
-            break;
-
-        case VALUE_NUMBER_FLOAT:
-            if (_baseType.getRawClass().isAssignableFrom(Double.class)) {
-                return Double.valueOf(jp.getDoubleValue());
-            }
-            break;
-        case VALUE_TRUE:
-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {
-                return Boolean.TRUE;
-            }
-            break;
-        case VALUE_FALSE:
-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {
-                return Boolean.FALSE;
-            }
-            break;
-        }
-        return null;
-    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
index bd06b56fb..76b4ac504 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
@@ -125,12 +125,12 @@ public abstract class TypeDeserializerBase
     @Override
     public String toString()
     {
-    	StringBuilder sb = new StringBuilder();
-    	sb.append('[').append(getClass().getName());
-    	sb.append("; base-type:").append(_baseType);
-    	sb.append("; id-resolver: ").append(_idResolver);
-    	sb.append(']');
-    	return sb.toString();
+        StringBuilder sb = new StringBuilder();
+        sb.append('[').append(getClass().getName());
+        sb.append("; base-type:").append(_baseType);
+        sb.append("; id-resolver: ").append(_idResolver);
+    	    sb.append(']');
+    	    return sb.toString();
     }
     
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java
index 57cc90c78..0f431ed85 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java
@@ -107,6 +107,12 @@ public class TypeNameIdResolver
 //  @Override
     public String idFromValueAndType(Object value, Class<?> type)
     {
+        /* 18-Jan-2013, tatu: We may be called with null value occasionally
+         *   it seems; nothing much we can figure out that way.
+         */
+        if (value == null) {
+            return null;
+        }
         return idFromValue(value);
     }
     
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
index 428aa4ff2..97989c36e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
@@ -154,6 +154,19 @@ public class TokenBuffer
         return p;
     }
     
+    /*
+    /**********************************************************
+    /* Additional accessors
+    /**********************************************************
+     */
+
+    public JsonToken firstToken() {
+        if (_first != null) {
+            return _first.type(0);
+        }
+        return null;
+    }
+    
     /*
     /**********************************************************
     /* Other custom methods not needed for implementing interfaces
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java
index 4837ddd14..847d5c5db 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java
@@ -336,6 +336,10 @@ public class TestExternalId extends BaseMapTest
     }
 
     // For [Issue#96]: should allow use of default impl, if property missing
+    /* 18-Jan-2013, tatu: Unfortunately this collides with [Issue#118], and I don't
+     *   know what the best resolution is. For now at least 
+     */
+    /*
     public void testWithDefaultAndMissing() throws Exception
     {
         ExternalBeanWithDefault input = new ExternalBeanWithDefault(13);
@@ -351,6 +355,7 @@ public class TestExternalId extends BaseMapTest
         assertNotNull(defaulted.bean);
         assertSame(ValueBean.class, defaulted.bean.getClass());
     }
+    */
 
     // For [Issue#118]
     // Note: String works fine, since no type id will used; other scalar types have issues
@@ -366,6 +371,34 @@ public class TestExternalId extends BaseMapTest
         assertTrue(result.value instanceof java.util.Date);
     }
 
+    // For [Issue#118] using "natural" type(s)
+    public void testWithNaturalScalar118() throws Exception
+    {
+        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13));
+        String json = MAPPER.writeValueAsString(input);
+        assertNotNull(json);
+        // and back just to be sure:
+        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
+        assertNotNull(result.value);
+        assertTrue(result.value instanceof Integer);
+
+        // ditto with others types
+        input = new ExternalTypeWithNonPOJO(Boolean.TRUE);
+        json = MAPPER.writeValueAsString(input);
+        assertNotNull(json);
+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
+        assertNotNull(result.value);
+        assertTrue(result.value instanceof Boolean);
+
+        input = new ExternalTypeWithNonPOJO("foobar");
+        json = MAPPER.writeValueAsString(input);
+        assertNotNull(json);
+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);
+        assertNotNull(result.value);
+        assertTrue(result.value instanceof String);
+        assertEquals("foobar", result.value);
+    }
+    
     // For [Issue#119]
     public void testWithAsValue() throws Exception
     {
diff --git a/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java
new file mode 100644
index 000000000..af4f50618
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java
@@ -0,0 +1,76 @@
+package com.fasterxml.jackson.failing;
+
+import java.io.*;
+import java.util.*;
+
+import com.fasterxml.jackson.annotation.*;
+import com.fasterxml.jackson.databind.*;
+
+public class TestExternalTypeId extends BaseMapTest
+{
+    public void testTypes() throws IOException {
+    final ObjectMapper mapper = new ObjectMapper();
+    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+
+    final Point _date = new Point(new Date());
+    final Point _integer = new Point(12231321);
+    final Point _boolean = new Point(Boolean.TRUE);
+    final Point _long = new Point(1234L);
+
+    final Point _pojo = new Point(new Pojo(1));
+    final String s_date = mapper.writeValueAsString(_date);
+    final String s_integer = mapper.writeValueAsString(_integer);
+
+System.err.println("Int -> "+s_integer);   
+    
+    final String s_boolean = mapper.writeValueAsString(_boolean);
+    final String s_long = mapper.writeValueAsString(_long);
+    final String s_pojo = mapper.writeValueAsString(_pojo);
+
+    final Point d_date = mapper.readValue(s_date, Point.class);
+    final Point d_long = mapper.readValue(s_long, Point.class);
+    final Point d_pojo = mapper.readValue(s_pojo, Point.class);
+    final Point d_integer = mapper.readValue(s_integer, Point.class);
+    final Point d_boolean = mapper.readValue(s_boolean, Point.class);
+    }
+
+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,
+        getterVisibility = JsonAutoDetect.Visibility.NONE,
+        setterVisibility = JsonAutoDetect.Visibility.NONE)
+    private static class Point {
+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
+        property = "t",
+        visible = true,
+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
+        defaultImpl = String.class)
+        @JsonSubTypes({
+        @JsonSubTypes.Type(value = Date.class, name = "date"),
+        @JsonSubTypes.Type(value = Integer.class, name = "int"),
+        @JsonSubTypes.Type(value = Long.class, name = "long"),
+        @JsonSubTypes.Type(value = Boolean.class, name = "bool"),
+        @JsonSubTypes.Type(value = Pojo.class, name = "pojo"),
+        @JsonSubTypes.Type(value = String.class, name = "")
+        })
+        private final Object v;
+    
+        @JsonCreator
+        @SuppressWarnings("unused")
+        public Point(@JsonProperty("v") Object v) {
+            this.v = v;
+        }
+    
+        public Object getValue() {
+            return v;
+        }
+    }
+     
+
+    private static class Pojo {
+        public final int p;
+
+        @JsonCreator
+        private Pojo(@JsonProperty("p") int p) {
+            this.p = p;
+        }
+    }
+}
