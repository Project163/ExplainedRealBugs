diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x
index 90342fdda..03d8820b5 100644
--- a/release-notes/CREDITS-2.x
+++ b/release-notes/CREDITS-2.x
@@ -1145,12 +1145,15 @@ Daniel Hrabovcak (TheSpiritXIII@github)
   * Reported #2796: `TypeFactory.constructType()` does not take `TypeBindings` correctly
   (2.11.2)
 
-Daniel Wu (DanielYWoo@github)
-  * Reported #2840: `ObjectMapper.activateDefaultTypingAsProperty()` is not using
-  (2.11.3)
-
 Lari Hotari (lhotari@github)
-
   * Reported #2821: Json serialization fails or a specific case that contains generics and
    static methods with generic parameters (2.11.1 -> 2.11.2 regression)
   (2.11.3)
+
+Nils Christian Ehmke (nils-christian@github)
+  * Reported #2822: Using JsonValue and JsonFormat on one field does not work as expected
+  (2.11.3)
+
+Daniel Wu (DanielYWoo@github)
+  * Reported #2840: `ObjectMapper.activateDefaultTypingAsProperty()` is not using
+  (2.11.3)
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 13debc462..513d7ff60 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -10,6 +10,8 @@ Project: jackson-databind
 #2821: Json serialization fails or a specific case that contains generics and
   static methods with generic parameters (2.11.1 -> 2.11.2 regression)
  (reported by Lari H)
+#2822: Using JsonValue and JsonFormat on one field does not work as expected
+ (reported by Nils-Christian E)
 #2840: `ObjectMapper.activateDefaultTypingAsProperty()` is not using
   parameter `PolymorphicTypeValidator`
  (reported by Daniel W)
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
index 77fb8a17f..47b7013c2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
@@ -97,7 +97,7 @@ public class JsonValueSerializer
     private final static Class<Object> _notNullClass(Class<?> cls) {
         return (cls == null) ? Object.class : (Class<Object>) cls;
     }
-    
+
     public JsonValueSerializer withResolved(BeanProperty property,
             JsonSerializer<?> ser, boolean forceTypeInfo)
     {
@@ -125,9 +125,9 @@ public class JsonValueSerializer
     {
         JsonSerializer<?> ser = _valueSerializer;
         if (ser == null) {
-            /* Can only assign serializer statically if the declared type is final:
-             * if not, we don't really know the actual type until we get the instance.
-             */
+            // Can only assign serializer statically if the declared type is final:
+            // if not, we don't really know the actual type until we get the instance.
+
             // 10-Mar-2010, tatu: Except if static typing is to be used
             JavaType t = _accessor.getType();
             if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || t.isFinal()) {
@@ -145,6 +145,10 @@ public class JsonValueSerializer
                 boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser);
                 return withResolved(property, ser, forceTypeInformation);
             }
+            // [databind#2822]: better hold on to "property", regardless
+            if (property != _property) {
+                return withResolved(property, ser, _forceTypeInformation);
+            }
         } else {
             // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...
             ser = provider.handlePrimaryContextualization(ser, property);
@@ -152,7 +156,7 @@ public class JsonValueSerializer
         }
         return this;
     }
-    
+
     /*
     /**********************************************************
     /* Actual serialization
@@ -171,10 +175,10 @@ public class JsonValueSerializer
             JsonSerializer<Object> ser = _valueSerializer;
             if (ser == null) {
                 Class<?> c = value.getClass();
-                /* 10-Mar-2010, tatu: Ideally we would actually separate out type
-                 *   serializer from value serializer; but, alas, there's no access
-                 *   to serializer factory at this point... 
-                 */
+                // 10-Mar-2010, tatu: Ideally we would actually separate out type
+                //   serializer from value serializer; but, alas, there's no access
+                //   to serializer factory at this point...
+
                 // let's cache it, may be needed soon again
                 ser = prov.findTypedValueSerializer(c, true, _property);
             }
diff --git a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
index e64d53e2b..5295e999a 100644
--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
@@ -354,6 +354,11 @@ public abstract class BaseMapTest
         }
     }
 
+    // @since 2.11.3
+    protected static String a2q(String json) {
+        return json.replace("'", "\"");
+    }
+
     protected static String aposToQuotes(String json) {
         return json.replace("'", "\"");
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
index 95cf7feb1..fc95aa9f5 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
@@ -1,10 +1,13 @@
 package com.fasterxml.jackson.databind.ser;
 
 import java.io.IOException;
+import java.math.BigDecimal;
 import java.util.*;
 
 import com.fasterxml.jackson.annotation.*;
+
 import com.fasterxml.jackson.core.JsonGenerator;
+
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 import com.fasterxml.jackson.databind.module.SimpleModule;
@@ -192,6 +195,29 @@ public class JsonValueTest
             gen.writeNumber(42);
         }
     }
+
+    // [databind#2822]
+    @JsonPropertyOrder({ "description", "b" })
+    static class A2822 {
+        public final String description;
+
+        @JsonFormat(shape = JsonFormat.Shape.STRING)
+        public final B2822 b;
+
+        public A2822(final String description, final B2822 b ) {
+            this.description = description;
+            this.b = b;
+        }
+    }
+
+    static class B2822 {
+        @JsonValue
+        private final BigDecimal value;
+
+        public B2822(final BigDecimal value ) {
+            this.value = value;
+        }
+    }
     
     /*
     /*********************************************************
@@ -199,7 +225,7 @@ public class JsonValueTest
     /*********************************************************
      */
 
-    private final ObjectMapper MAPPER = new ObjectMapper();
+    private final ObjectMapper MAPPER = newJsonMapper();
     
     public void testSimpleMethodJsonValue() throws Exception
     {
@@ -295,4 +321,12 @@ public class JsonValueTest
             );
         assertEquals("42", mapper.writeValueAsString(INPUT));
     }
+
+    // [databind#2822]
+    public void testFormatWithJsonValue() throws Exception
+    {
+        final String json = MAPPER.writeValueAsString(new A2822("desc",
+                new B2822(BigDecimal.ONE)));
+        assertEquals(a2q("{'description':'desc','b':'1'}"), json);
+    }
 }
