diff --git a/release-notes/VERSION b/release-notes/VERSION
index 7e96533f9..a70f6f9cd 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -32,4 +32,5 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #1955: Change the way `Module`s configure, interact with `ObjectMapper`
 #1973: Remove support for "default [Map] key serializer" configuration from
   `SerializerProvider`
+#1994: Limit size of `SerializerCache`, auto-flush on exceeding
 - Remove `MappingJsonFactory`
diff --git a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
index b32c5b438..397d3ed2e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
@@ -255,9 +255,7 @@ public abstract class SerializerProvider
 
         // and others initialized to default empty state
         _serializerCache = new SerializerCache();
-
         _nullValueSerializer = src._nullValueSerializer;
-
         _stdNullValueSerializer = src._stdNullValueSerializer;
     }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
index 9d860adfc..3ef317046 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
@@ -4,6 +4,7 @@ import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
+
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.cfg.MapperConfig;
 import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;
@@ -20,14 +21,14 @@ import com.fasterxml.jackson.databind.util.Converter;
  * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).
  */
 public final class DeserializerCache
-    implements java.io.Serializable // since 2.1 -- needs to be careful tho
+    implements java.io.Serializable
 {
-    private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 3L;
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Caching
-    /**********************************************************
+    /**********************************************************************
      */
 
     /**
@@ -40,7 +41,7 @@ public final class DeserializerCache
      * (should very quickly converge to zero after startup), let's
      * define a relatively low concurrency setting.
      */
-    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers
+    private final transient ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers
         = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);
 
     /**
@@ -48,34 +49,33 @@ public final class DeserializerCache
      * completed deserializers, to resolve cyclic dependencies. This is the
      * map used for storing deserializers before they are fully complete.
      */
-    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers
+    private final transient HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers
         = new HashMap<JavaType, JsonDeserializer<Object>>(8);
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Life-cycle
-    /**********************************************************
+    /**********************************************************************
      */
 
     public DeserializerCache() { }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* JDK serialization handling
-    /**********************************************************
+    /**********************************************************************
      */
 
-    Object writeReplace() {
-        // instead of making this transient, just clear it:
-        _incompleteDeserializers.clear();
-        // TODO: clear out "cheap" cached deserializers?
-        return this;
+    // 11-Apr-2018, tatu: instead of clearing or such on write, keep everything transient,
+    //     recreate as empty. No point trying to revive cached instances
+    protected Object readResolve() {
+        return new DeserializerCache();
     }
-    
+
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Access to caching aspects
-    /**********************************************************
+    /**********************************************************************
      */
 
     /**
@@ -106,9 +106,9 @@ public final class DeserializerCache
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* General deserializer locating method
-    /**********************************************************
+    /**********************************************************************
      */
 
     /**
@@ -194,9 +194,9 @@ public final class DeserializerCache
 
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Helper methods that handle cache lookups
-    /**********************************************************
+    /**********************************************************************
      */
 
     protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)
@@ -301,9 +301,9 @@ public final class DeserializerCache
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Helper methods for actual construction of deserializers
-    /**********************************************************
+    /**********************************************************************
      */
     
     /**
@@ -532,9 +532,9 @@ public final class DeserializerCache
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Helper methods, other
-    /**********************************************************
+    /**********************************************************************
      */
 
     /**
@@ -579,9 +579,9 @@ public final class DeserializerCache
     }
 
     /*
-    /**********************************************************
-    /* Overridable error reporting methods
-    /**********************************************************
+    /**********************************************************************
+    /* Error reporting methods
+    /**********************************************************************
      */
 
     protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type)
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
index fa055004a..9dda54da6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
@@ -1,10 +1,10 @@
 package com.fasterxml.jackson.databind.ser;
 
-import java.util.*;
 import java.util.concurrent.atomic.AtomicReference;
 
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;
+import com.fasterxml.jackson.databind.util.SimpleLookupCache;
 import com.fasterxml.jackson.databind.util.TypeKey;
 
 /**
@@ -26,12 +26,19 @@ public final class SerializerCache
     private static final long serialVersionUID = 3L;
 
     /**
-     * Shared, modifiable map; all access needs to be through synchronized blocks.
+     * By default, allow caching of up to 4000 serializer entries (for possibly up to
+     * 1000 types; but depending access patterns may be as few as half of that).
+     */
+    public final static int DEFAULT_MAX_CACHED = 4000;
+
+    /**
+     * Shared, modifiable map; used if local read-only copy does not contain serializer
+     * caller expects.
      *<p>
      * NOTE: keys are of various types (see below for key types), in addition to
      * basic {@link JavaType} used for "untyped" serializers.
      */
-    private final transient HashMap<TypeKey, JsonSerializer<Object>> _sharedMap;
+    private final SimpleLookupCache<TypeKey, JsonSerializer<Object>> _sharedMap;
 
     /**
      * Most recent read-only instance, created from _sharedMap, if any.
@@ -39,13 +46,26 @@ public final class SerializerCache
     private final transient AtomicReference<ReadOnlyClassToSerializerMap> _readOnlyMap;
 
     public SerializerCache() {
-        _sharedMap = new HashMap<TypeKey, JsonSerializer<Object>>(64);
+        this(DEFAULT_MAX_CACHED);
+    }
+
+    /**
+     * @since 3.0
+     */
+    public SerializerCache(int maxCached) {
+        _sharedMap = new SimpleLookupCache<TypeKey, JsonSerializer<Object>>(maxCached>>2, maxCached);
         _readOnlyMap = new AtomicReference<ReadOnlyClassToSerializerMap>();
     }
 
-    // Since 3.0, needed to initialize cache properly
+    private SerializerCache(SerializerCache serialized) {
+        _sharedMap = serialized._sharedMap;
+        _readOnlyMap = new AtomicReference<ReadOnlyClassToSerializerMap>();
+    }
+    
+    // Since 3.0, needed to initialize cache properly: shared map would be ok but need to
+    // reconstruct AtomicReference
     protected Object readResolve() {
-        return new SerializerCache();
+        return new SerializerCache(this);
     }
 
     /**
@@ -78,7 +98,7 @@ public final class SerializerCache
     /**********************************************************************
      */
 
-    public synchronized int size() {
+    public int size() {
         return _sharedMap.size();
     }
 
@@ -88,30 +108,22 @@ public final class SerializerCache
      */
     public JsonSerializer<Object> untypedValueSerializer(Class<?> type)
     {
-        synchronized (this) {
-            return _sharedMap.get(new TypeKey(type, false));
-        }
+        return _sharedMap.get(new TypeKey(type, false));
     }
 
     public JsonSerializer<Object> untypedValueSerializer(JavaType type)
     {
-        synchronized (this) {
-            return _sharedMap.get(new TypeKey(type, false));
-        }
+        return _sharedMap.get(new TypeKey(type, false));
     }
 
     public JsonSerializer<Object> typedValueSerializer(JavaType type)
     {
-        synchronized (this) {
-            return _sharedMap.get(new TypeKey(type, true));
-        }
+        return _sharedMap.get(new TypeKey(type, true));
     }
 
     public JsonSerializer<Object> typedValueSerializer(Class<?> cls)
     {
-        synchronized (this) {
-            return _sharedMap.get(new TypeKey(cls, true));
-        }
+        return _sharedMap.get(new TypeKey(cls, true));
     }
 
     /*
@@ -127,24 +139,20 @@ public final class SerializerCache
      */
     public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser)
     {
-        synchronized (this) {
-            if (_sharedMap.put(new TypeKey(type, true), ser) == null) {
-                // let's invalidate the read-only copy, too, to get it updated
-                _readOnlyMap.set(null);
-            }
+        if (_sharedMap.put(new TypeKey(type, true), ser) == null) {
+            // let's invalidate the read-only copy, too, to get it updated
+            _readOnlyMap.set(null);
         }
     }
 
     public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser)
     {
-        synchronized (this) {
-            if (_sharedMap.put(new TypeKey(cls, true), ser) == null) {
-                // let's invalidate the read-only copy, too, to get it updated
-                _readOnlyMap.set(null);
-            }
+        if (_sharedMap.put(new TypeKey(cls, true), ser) == null) {
+            // let's invalidate the read-only copy, too, to get it updated
+            _readOnlyMap.set(null);
         }
     }
-    
+
     public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,
             SerializerProvider provider)
         throws JsonMappingException
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
index feacbce21..f6ee819c7 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
@@ -1,19 +1,14 @@
 package com.fasterxml.jackson.databind.ser.impl;
 
-import java.util.*;
-
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.util.SimpleLookupCache;
 import com.fasterxml.jackson.databind.util.TypeKey;
 
 /**
  * Optimized lookup table for accessing two types of serializers; typed
  * and non-typed. Only accessed from a single thread, so no synchronization
  * needed for accessors.
- *<p>
- * Note that before 2.6 this class was much smaller, and referred most
- * operations to separate <code>JsonSerializerMap</code>, but in 2.6
- * functions were combined.
  */
 public final class ReadOnlyClassToSerializerMap
 {
@@ -23,20 +18,18 @@ public final class ReadOnlyClassToSerializerMap
 
     private final int _mask;
 
-    public ReadOnlyClassToSerializerMap(Map<TypeKey,JsonSerializer<Object>> serializers)
+    protected ReadOnlyClassToSerializerMap(SimpleLookupCache<TypeKey, JsonSerializer<Object>> src)
     {
-        int size = findSize(serializers.size());
-        _size = size;
-        _mask = (size-1);
-        Bucket[] buckets = new Bucket[size];
-        for (Map.Entry<TypeKey,JsonSerializer<Object>> entry : serializers.entrySet()) {
-            TypeKey key = entry.getKey();
+        _size = findSize(src.size());;
+        _mask = (_size-1);
+        Bucket[] buckets = new Bucket[_size];
+        src.contents((key, value) -> {
             int index = key.hashCode() & _mask;
-            buckets[index] = new Bucket(buckets[index], key, entry.getValue());
-        }
+            buckets[index] = new Bucket(buckets[index], key, value);
+        });
         _buckets = buckets;
     }
-    
+
     private final static int findSize(int size)
     {
         // For small enough results (64 or less), we'll require <= 50% fill rate; otherwise 80%
@@ -51,14 +44,14 @@ public final class ReadOnlyClassToSerializerMap
     /**
      * Factory method for constructing an instance.
      */
-    public static ReadOnlyClassToSerializerMap from(HashMap<TypeKey, JsonSerializer<Object>> src) {
+    public static ReadOnlyClassToSerializerMap from(SimpleLookupCache<TypeKey, JsonSerializer<Object>> src) {
         return new ReadOnlyClassToSerializerMap(src);
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Public API
-    /**********************************************************
+    /**********************************************************************
      */
 
     public int size() { return _size; }
@@ -132,9 +125,9 @@ public final class ReadOnlyClassToSerializerMap
     }    
 
     /*
-    /**********************************************************
+    /**********************************************************************
     /* Helper classes
-    /**********************************************************
+    /**********************************************************************
      */
 
     private final static class Bucket
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/SimpleLookupCache.java b/src/main/java/com/fasterxml/jackson/databind/util/SimpleLookupCache.java
index 1e305a615..263819e89 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleLookupCache.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleLookupCache.java
@@ -1,14 +1,17 @@
 package com.fasterxml.jackson.databind.util;
 
-import java.io.*;
+import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiConsumer;
 
 /**
- * Helper for simple bounded maps used for reusing lookup values.
+ * Synchronized cache with bounded size: used for reusing lookup values
+ * and lazily instantiated reusable items.
  *<p>
  * Note that serialization behavior is such that contents are NOT serialized,
  * on assumption that all use cases are for caching where persistence
- * does not make sense. The only thing serialized is the cache size of Map.
+ * does not make sense. The only thing serialized is the initial and maximum
+ * size of the contents.
  *<p>
  * NOTE: this is <b>NOT</b> an LRU-based (in 2.x it was named <code>LRUMap</code>); reason
  * being that it is not possible to use JDK components that do LRU _AND_ perform
@@ -23,19 +26,43 @@ import java.util.concurrent.ConcurrentHashMap;
 public class SimpleLookupCache<K,V>
     implements java.io.Serializable
 {
-    private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 3L;
 
-    protected final transient int _maxEntries;
+    protected final int _initialEntries, _maxEntries;
 
     protected final transient ConcurrentHashMap<K,V> _map;
     
+    /*
+    /**********************************************************************
+    /* Life-cycle
+    /**********************************************************************
+     */
+
     public SimpleLookupCache(int initialEntries, int maxEntries)
     {
+        _initialEntries = initialEntries;
+        _maxEntries = maxEntries;
         // We'll use concurrency level of 4, seems reasonable
         _map = new ConcurrentHashMap<K,V>(initialEntries, 0.8f, 4);
-        _maxEntries = maxEntries;
     }
 
+    // for JDK serialization
+    protected Object readResolve() {
+        return new SimpleLookupCache<Object,Object>(_initialEntries, _maxEntries);
+    }
+
+    public void contents(BiConsumer<K,V> consumer) {
+        for (Map.Entry<K,V> entry : _map.entrySet()) {
+            consumer.accept(entry.getKey(), entry.getValue());
+        }
+    }
+
+    /*
+    /**********************************************************************
+    /* Public API
+    /**********************************************************************
+     */
+
     public V put(K key, V value) {
         if (_map.size() >= _maxEntries) {
             // double-locking, yes, but safe here; trying to avoid "clear storms"
@@ -66,28 +93,4 @@ public class SimpleLookupCache<K,V>
 
     public void clear() { _map.clear(); }
     public int size() { return _map.size(); }
-
-    /*
-    /**********************************************************
-    /* Serializable overrides
-    /**********************************************************
-     */
-
-    /**
-     * Ugly hack, to work through the requirement that _value is indeed final,
-     * and that JDK serialization won't call ctor(s) if Serializable is implemented.
-     */
-    protected transient int _jdkSerializeMaxEntries;
-
-    private void readObject(ObjectInputStream in) throws IOException {
-        _jdkSerializeMaxEntries = in.readInt();
-    }
-
-    private void writeObject(ObjectOutputStream out) throws IOException {
-        out.writeInt(_jdkSerializeMaxEntries);
-    }
-
-    protected Object readResolve() {
-        return new SimpleLookupCache<Object,Object>(_jdkSerializeMaxEntries, _jdkSerializeMaxEntries);
-    }
 }
