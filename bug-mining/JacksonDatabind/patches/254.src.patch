diff --git a/release-notes/VERSION b/release-notes/VERSION
index 202f01e7a..c1fd9e783 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -30,6 +30,7 @@ Project: jackson-databind
 #1399: Add support for `@JsonSetter(merge=OptBoolean.TRUE`) to allow "deep update"
 #1406: `ObjectMapper.readTree()` methods do not return `null` on end-of-input
  (reported by Fabrizio C)
+#1428: Allow `@JsonValue` on a field, not just getter
 #1434: Explicitly pass null on invoke calls with no arguments
  (contributed by Emiliano C)
 #1433: `ObjectMapper.convertValue()` with null does not consider null conversions
diff --git a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java
index b61ed8b79..f0945e070 100644
--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java
+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java
@@ -184,6 +184,9 @@ public abstract class BeanDescription
      * if any. If multiple ones are found,
      * an error is reported by throwing {@link IllegalArgumentException}
      */
+    public abstract AnnotatedMember findJsonValueAccessor();
+
+    @Deprecated // since 2.9
     public abstract AnnotatedMethod findJsonValueMethod();
 
     public abstract AnnotatedMethod findMethod(String name, Class<?>[] paramTypes);
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index abbc078e6..7ed41668a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -1,6 +1,5 @@
 package com.fasterxml.jackson.databind.deser;
 
-import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
@@ -1243,7 +1242,7 @@ public abstract class BasicDeserializerFactory
             // Need to consider @JsonValue if one found
             if (deser == null) {
                 deser = new EnumDeserializer(constructEnumResolver(enumClass,
-                        config, beanDesc.findJsonValueMethod()));
+                        config, beanDesc.findJsonValueAccessor()));
             }
         }
 
@@ -1432,7 +1431,7 @@ public abstract class BasicDeserializerFactory
                 return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);
             }
         }
-        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());
+        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());
         // May have @JsonCreator for static factory method:
         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {
             if (_hasCreatorAnnotation(ctxt, factory)) {
@@ -1863,14 +1862,15 @@ public abstract class BasicDeserializerFactory
     }
 
     protected EnumResolver constructEnumResolver(Class<?> enumClass,
-            DeserializationConfig config, AnnotatedMethod jsonValueMethod)
+            DeserializationConfig config, AnnotatedMember jsonValueAccessor)
     {
-        if (jsonValueMethod != null) {
-            Method accessor = jsonValueMethod.getAnnotated();
+        if (jsonValueAccessor != null) {
             if (config.canOverrideAccessModifiers()) {
-                ClassUtil.checkAndFixAccess(accessor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+                ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(),
+                        config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
             }
-            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor, config.getAnnotationIntrospector());
+            return EnumResolver.constructUnsafeUsingMethod(enumClass,
+                    jsonValueAccessor, config.getAnnotationIntrospector());
         }
         // 14-Mar-2016, tatu: We used to check `DeserializationFeature.READ_ENUMS_USING_TO_STRING`
         //   here, but that won't do: it must be dynamically changeable...
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
index 511ffcd1d..968e56a6e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
@@ -240,11 +240,18 @@ public class BasicBeanDescription extends BeanDescription
     }
 
     @Override
+    @Deprecated // since 2.9
     public AnnotatedMethod findJsonValueMethod() {
         return (_propCollector == null) ? null
                 : _propCollector.getJsonValueMethod();
     }
 
+    @Override // since 2.9
+    public AnnotatedMember findJsonValueAccessor() {
+        return (_propCollector == null) ? null
+                : _propCollector.getJsonValueAccessor();
+    }
+ 
     @Override
     public Set<String> getIgnoredPropertyNames() {
         Set<String> ign = (_propCollector == null) ? null
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
index c6b4449e0..d881df4d6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
@@ -90,8 +90,10 @@ public class POJOPropertiesCollector
 
     /**
      * Method(s) marked with 'JsonValue' annotation
+     *<p>
+     * NOTE: before 2.9, was `AnnotatedMethod`; with 2.9 allows fields too
      */
-    protected LinkedList<AnnotatedMethod> _jsonValueGetters;
+    protected LinkedList<AnnotatedMember> _jsonValueAccessors;
 
     /**
      * Lazily collected list of properties that can be implicitly
@@ -166,20 +168,32 @@ public class POJOPropertiesCollector
         }
         return _injectables;
     }
-    
-    public AnnotatedMethod getJsonValueMethod()
+
+    @Deprecated // since 2.9
+    public AnnotatedMethod getJsonValueMethod() {
+        AnnotatedMember m = getJsonValueAccessor();
+        if (m instanceof AnnotatedMethod) {
+            return (AnnotatedMethod) m;
+        }
+        return null;
+    }
+
+    /**
+     * @since 2.9
+     */
+    public AnnotatedMember getJsonValueAccessor()
     {
         if (!_collected) {
             collectAll();
         }
         // If @JsonValue defined, must have a single one
-        if (_jsonValueGetters != null) {
-            if (_jsonValueGetters.size() > 1) {
-                reportProblem("Multiple value properties defined ("+_jsonValueGetters.get(0)+" vs "
-                        +_jsonValueGetters.get(1)+")");
+        if (_jsonValueAccessors != null) {
+            if (_jsonValueAccessors.size() > 1) {
+                reportProblem("Multiple 'as-value' properties defined ("+_jsonValueAccessors.get(0)+" vs "
+                        +_jsonValueAccessors.get(1)+")");
             }
             // otherwise we won't greatly care
-            return _jsonValueGetters.get(0);
+            return _jsonValueAccessors.get(0);
         }
         return null;
     }
@@ -367,7 +381,29 @@ public class POJOPropertiesCollector
         final boolean transientAsIgnoral = _config.isEnabled(MapperFeature.PROPAGATE_TRANSIENT_MARKER);
         
         for (AnnotatedField f : _classDef.fields()) {
-            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);
+            String implName;
+            if (ai == null) {
+                implName = null;
+            } else {
+                implName = ai.findImplicitPropertyName(f);
+                // @JsonValue?
+                if (Boolean.TRUE.equals(ai.findAsValueAnnotation(f))) {
+                    if (_jsonValueAccessors == null) {
+                        _jsonValueAccessors = new LinkedList<>();
+                    }
+                    _jsonValueAccessors.add(f);
+                    continue;
+                }
+                // @JsonAnySetter?
+                // !!! 20-Nov-2016, tatu: This is wrong; needs to go via AnnotationIntrospector!
+                if (f.hasAnnotation(JsonAnySetter.class)) {
+                    if (_anySetterField == null) {
+                        _anySetterField = new LinkedList<AnnotatedMember>();
+                    }
+                    _anySetterField.add(f);
+                    continue;
+                }
+            }
             if (implName == null) {
                 implName = f.getName();
             }
@@ -417,18 +453,10 @@ public class POJOPropertiesCollector
              *  Also: if 'ignored' is set, need to included until a later point, to
              *  avoid losing ignoral information.
              */
-            if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) {
+            if (pruneFinalFields && (pn == null) && !ignored
+                    && Modifier.isFinal(f.getModifiers())) {
                 continue;
             }
-
-            //if field has annotation @JsonAnySetter
-            if(f.hasAnnotation(JsonAnySetter.class)) {
-            	if (_anySetterField == null) {
-            		_anySetterField = new LinkedList<AnnotatedMember>();
-            	}
-            	_anySetterField.add(f);
-            }
-            
             _property(props, implName).addField(f, pn, nameExplicit, visible, ignored);
         }
     }
@@ -550,11 +578,11 @@ public class POJOPropertiesCollector
                 return;
             }
             // @JsonValue?
-            if (ai.hasAsValueAnnotation(m)) {
-                if (_jsonValueGetters == null) {
-                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();
+            if (Boolean.TRUE.equals(ai.findAsValueAnnotation(m))) {
+                if (_jsonValueAccessors == null) {
+                    _jsonValueAccessors = new LinkedList<>();
                 }
-                _jsonValueGetters.add(m);
+                _jsonValueAccessors.add(m);
                 return;
             }
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
index d6b1ecfac..ac8205710 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
@@ -1,6 +1,5 @@
 package com.fasterxml.jackson.databind.ser;
 
-import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.InetAddress;
@@ -224,14 +223,14 @@ public abstract class BasicSerializerFactory
                 // As per [databind#47], also need to support @JsonValue
                 if (ser == null) {
                     beanDesc = config.introspect(keyType);
-                    AnnotatedMethod am = beanDesc.findJsonValueMethod();
+                    AnnotatedMember am = beanDesc.findJsonValueAccessor();
                     if (am != null) {
-                        final Class<?> rawType = am.getRawReturnType();
+                        final Class<?> rawType = am.getRawType();
                         JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,
                                 rawType, true);
-                        Method m = am.getAnnotated();
                         if (config.canOverrideAccessModifiers()) {
-                            ClassUtil.checkAndFixAccess(m, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+                            ClassUtil.checkAndFixAccess(am.getMember(),
+                                    config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                         }
                         ser = new JsonValueSerializer(am, delegate);
                     } else {
@@ -345,14 +344,14 @@ public abstract class BasicSerializerFactory
             return SerializableSerializer.instance;
         }
         // Second: @JsonValue for any type
-        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();
-        if (valueMethod != null) {
-            Method m = valueMethod.getAnnotated();
+        AnnotatedMember valueAccessor = beanDesc.findJsonValueAccessor();
+        if (valueAccessor != null) {
             if (prov.canOverrideAccessModifiers()) {
-                ClassUtil.checkAndFixAccess(m, prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
+                ClassUtil.checkAndFixAccess(valueAccessor.getMember(),
+                        prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
             }
-            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);
-            return new JsonValueSerializer(valueMethod, ser);
+            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueAccessor);
+            return new JsonValueSerializer(valueAccessor, ser);
         }
         // No well-known annotations...
         return null;
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
index 350ce8d98..0e939cc0b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
@@ -10,7 +10,7 @@ import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
-import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
 import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;
 import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
@@ -38,11 +38,11 @@ import com.fasterxml.jackson.databind.util.ClassUtil;
 public class JsonValueSerializer
     extends StdSerializer<Object>
     implements ContextualSerializer, JsonFormatVisitable, SchemaAware
-    {
+{
     /**
-     * @since 2.8 (was "plain" method before)
+     * @since 2.9
      */
-    protected final AnnotatedMethod _accessorMethod;
+    protected final AnnotatedMember _accessor;
 
     protected final JsonSerializer<Object> _valueSerializer;
 
@@ -72,10 +72,10 @@ public class JsonValueSerializer
      *    to information we need
      */
     @SuppressWarnings("unchecked")
-    public JsonValueSerializer(AnnotatedMethod valueMethod, JsonSerializer<?> ser)
+    public JsonValueSerializer(AnnotatedMember accessor, JsonSerializer<?> ser)
     {
-        super(valueMethod.getType());
-        _accessorMethod = valueMethod;
+        super(accessor.getType());
+        _accessor = accessor;
         _valueSerializer = (JsonSerializer<Object>) ser;
         _property = null;
         _forceTypeInformation = true; // gets reconsidered when we are contextualized
@@ -86,7 +86,7 @@ public class JsonValueSerializer
             JsonSerializer<?> ser, boolean forceTypeInfo)
     {
         super(_notNullClass(src.handledType()));
-        _accessorMethod = src._accessorMethod;
+        _accessor = src._accessor;
         _valueSerializer = (JsonSerializer<Object>) ser;
         _property = property;
         _forceTypeInformation = forceTypeInfo;
@@ -128,7 +128,7 @@ public class JsonValueSerializer
              * if not, we don't really know the actual type until we get the instance.
              */
             // 10-Mar-2010, tatu: Except if static typing is to be used
-            JavaType t = _accessorMethod.getType();
+            JavaType t = _accessor.getType();
             if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || t.isFinal()) {
                 // false -> no need to cache
                 /* 10-Mar-2010, tatu: Ideally we would actually separate out type
@@ -162,7 +162,7 @@ public class JsonValueSerializer
     public void serialize(Object bean, JsonGenerator gen, SerializerProvider prov) throws IOException
     {
         try {
-            Object value = _accessorMethod.getValue(bean);
+            Object value = _accessor.getValue(bean);
             if (value == null) {
                 prov.defaultSerializeNull(gen);
                 return;
@@ -179,7 +179,7 @@ public class JsonValueSerializer
             }
             ser.serialize(value, gen, prov);
         } catch (Exception e) {
-            wrapAndThrow(prov, e, bean, _accessorMethod.getName() + "()");
+            wrapAndThrow(prov, e, bean, _accessor.getName() + "()");
         }
     }
 
@@ -190,7 +190,7 @@ public class JsonValueSerializer
         // Regardless of other parts, first need to find value to serialize:
         Object value = null;
         try {
-            value = _accessorMethod.getValue(bean);
+            value = _accessor.getValue(bean);
             // and if we got null, can also just write it directly
             if (value == null) {
                 provider.defaultSerializeNull(gen);
@@ -217,7 +217,7 @@ public class JsonValueSerializer
             TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);
             ser.serializeWithType(value, gen, provider, rr);
         } catch (Exception e) {
-            wrapAndThrow(provider, e, bean, _accessorMethod.getName() + "()");
+            wrapAndThrow(provider, e, bean, _accessor.getName() + "()");
         }
     }
     
@@ -245,8 +245,8 @@ public class JsonValueSerializer
          *    
          *    Note that meaning of JsonValue, then, is very different for Enums. Sigh.
          */
-        final JavaType type = _accessorMethod.getType();
-        Class<?> declaring = _accessorMethod.getDeclaringClass();
+        final JavaType type = _accessor.getType();
+        Class<?> declaring = _accessor.getDeclaringClass();
         if ((declaring != null) && declaring.isEnum()) {
             if (_acceptJsonFormatVisitorForEnum(visitor, typeHint, declaring)) {
                 return;
@@ -285,14 +285,14 @@ public class JsonValueSerializer
                     // 21-Apr-2016, tatu: This is convoluted to the max, but essentially we
                     //   call `@JsonValue`-annotated accessor method on all Enum members,
                     //   so it all "works out". To some degree.
-                    enums.add(String.valueOf(_accessorMethod.callOn(en)));
+                    enums.add(String.valueOf(_accessor.getValue(en)));
                 } catch (Exception e) {
                     Throwable t = e;
                     while (t instanceof InvocationTargetException && t.getCause() != null) {
                         t = t.getCause();
                     }
                     ClassUtil.throwIfError(t);
-                    throw JsonMappingException.wrapWithPath(t, en, _accessorMethod.getName() + "()");
+                    throw JsonMappingException.wrapWithPath(t, en, _accessor.getName() + "()");
                 }
             }
             stringVisitor.enumTypes(enums);
@@ -324,7 +324,7 @@ public class JsonValueSerializer
 
     @Override
     public String toString() {
-        return "(@JsonValue serializer for method " + _accessorMethod.getDeclaringClass() + "#" + _accessorMethod.getName() + ")";
+        return "(@JsonValue serializer for method " + _accessor.getDeclaringClass() + "#" + _accessor.getName() + ")";
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java
index e92cc4d61..f95ea55f4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java
@@ -1,9 +1,9 @@
 package com.fasterxml.jackson.databind.util;
 
-import java.lang.reflect.Method;
 import java.util.*;
 
 import com.fasterxml.jackson.databind.AnnotationIntrospector;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
 
 /**
  * Helper class used to resolve String values (either JSON Object field
@@ -83,17 +83,10 @@ public class EnumResolver implements java.io.Serializable
     }
 
     /**
-     * @deprecated Since 2.8, use {@link #constructUsingMethod(Class, Method, AnnotationIntrospector)} instead
+     * @since 2.9
      */
-    @Deprecated
-    public static EnumResolver constructUsingMethod(Class<Enum<?>> enumCls, Method accessor) {
-        return constructUsingMethod(enumCls, accessor, null);
-    }
-
-    /**
-     * @since 2.8
-     */
-    public static EnumResolver constructUsingMethod(Class<Enum<?>> enumCls, Method accessor,
+    public static EnumResolver constructUsingMethod(Class<Enum<?>> enumCls,
+            AnnotatedMember accessor,
             AnnotationIntrospector ai)
     {
         Enum<?>[] enumValues = enumCls.getEnumConstants();
@@ -102,7 +95,7 @@ public class EnumResolver implements java.io.Serializable
         for (int i = enumValues.length; --i >= 0; ) {
             Enum<?> en = enumValues[i];
             try {
-                Object o = accessor.invoke(en, (Object[]) null);
+                Object o = accessor.getValue(en);
                 if (o != null) {
                     map.put(o.toString(), en);
                 }
@@ -128,15 +121,6 @@ public class EnumResolver implements java.io.Serializable
         return constructFor(enumCls, ai);
     }
 
-    /**
-     * @deprecated Since 2.8, use {@link #constructUnsafeUsingToString(Class, AnnotationIntrospector)} instead
-     */
-    @Deprecated
-    public static EnumResolver constructUnsafeUsingToString(Class<?> rawEnumCls)
-    {
-        return constructUnsafeUsingToString(rawEnumCls, null);
-    }
-
     /**
      * Method that needs to be used instead of {@link #constructUsingToString}
      * if static type of enum is not known.
@@ -152,22 +136,15 @@ public class EnumResolver implements java.io.Serializable
         return constructUsingToString(enumCls, ai);
     }
 
-    /**
-     * @deprecated Since 2.8, use {@link #constructUnsafeUsingMethod(Class, Method, AnnotationIntrospector)} instead.
-     */
-    @Deprecated
-    public static EnumResolver constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor) {
-        return constructUnsafeUsingMethod(rawEnumCls, accessor, null);
-    }
-
     /**
      * Method used when actual String serialization is indicated using @JsonValue
      * on a method.
      *
-     * @since 2.8
+     * @since 2.9
      */
     @SuppressWarnings({ "unchecked" })
-    public static EnumResolver constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor,
+    public static EnumResolver constructUnsafeUsingMethod(Class<?> rawEnumCls,
+            AnnotatedMember accessor,
             AnnotationIntrospector ai)
     {            
         // wrong as ever but:
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonValue.java b/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
similarity index 84%
rename from src/test/java/com/fasterxml/jackson/databind/ser/TestJsonValue.java
rename to src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
index cac35ca23..ec1adb5ce 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonValue.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/JsonValueTest.java
@@ -16,7 +16,7 @@ import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
  * annotation with bean serialization.
  */
 @SuppressWarnings("serial")
-public class TestJsonValue
+public class JsonValueTest
     extends BaseMapTest
 {
     static class ValueClass<T>
@@ -26,12 +26,16 @@ public class TestJsonValue
         public ValueClass(T v) { _value = v; }
 
         @JsonValue T value() { return _value; }
-
-        // shouldn't need this, but may be useful for troubleshooting:
-        @Override
-        public String toString() { return "???"; }
     }
 
+    static class FieldValueClass<T>
+    {
+        @JsonValue(true)
+        final T _value;
+
+        public FieldValueClass(T v) { _value = v; }
+    }
+    
     /**
      * Another test class to check that it is also possible to
      * force specific serializer to use with @JsonValue annotated
@@ -54,8 +58,7 @@ public class TestJsonValue
     {
         public ToStringValueClass2(String value) { super(value); }
 
-        /* Simple as well, but let's ensure that other getters won't matter...
-         */
+        // Simple as well, but let's ensure that other getters won't matter...
 
         @JsonProperty int getFoobar() { return 4; }
 
@@ -87,6 +90,15 @@ public class TestJsonValue
         }
     }
 
+    static class MapFieldBean
+    {
+        @JsonValue
+        Map<String,String> stuff = new HashMap<>();
+        {
+            stuff.put("b", "2");
+        }
+    }
+    
     static class MapAsNumber extends HashMap<String,String>
     {
         @JsonValue
@@ -99,6 +111,17 @@ public class TestJsonValue
         public int value() { return 13; }
     }
 
+    // Just to ensure it's possible to disable annotation (usually
+    // via mix-ins, but here directly)
+    @JsonPropertyOrder({ "x", "y" })
+    static class DisabledJsonValue {
+        @JsonValue(false)
+        public int x = 1;
+
+        @JsonValue(false)
+        public int getY() { return 2; }
+    }
+
     static class IntExtBean {
         public List<Internal> values = new ArrayList<Internal>();
         
@@ -178,12 +201,18 @@ public class TestJsonValue
 
     private final ObjectMapper MAPPER = new ObjectMapper();
     
-    public void testSimpleJsonValue() throws Exception
+    public void testSimpleMethodJsonValue() throws Exception
     {
         assertEquals("\"abc\"", MAPPER.writeValueAsString(new ValueClass<String>("abc")));
         assertEquals("null", MAPPER.writeValueAsString(new ValueClass<String>(null)));
     }
 
+    public void testSimpleFieldJsonValue() throws Exception
+    {
+        assertEquals("\"abc\"", MAPPER.writeValueAsString(new FieldValueClass<String>("abc")));
+        assertEquals("null", MAPPER.writeValueAsString(new FieldValueClass<String>(null)));
+    }
+
     public void testJsonValueWithUseSerializer() throws Exception
     {
         String result = serializeAsString(MAPPER, new ToStringValueClass<Integer>(Integer.valueOf(123)));
@@ -199,6 +228,12 @@ public class TestJsonValue
         assertEquals("\"xyz\"", result);
     }
 
+    public void testDisabling() throws Exception
+    {
+        assertEquals(aposToQuotes("{'x':1,'y':2}"),
+                MAPPER.writeValueAsString(new DisabledJsonValue()));
+    }
+
     public void testValueWithStaticType() throws Exception
     {
         // Ok; first, with dynamic type:
@@ -211,12 +246,15 @@ public class TestJsonValue
     }
 
     public void testMapWithJsonValue() throws Exception {
+        // First via method
         assertEquals("{\"a\":\"1\"}", MAPPER.writeValueAsString(new MapBean()));
+
+        // then field
+        assertEquals("{\"b\":\"2\"}", MAPPER.writeValueAsString(new MapFieldBean()));
     }
 
     public void testWithMap() throws Exception {
         assertEquals("42", MAPPER.writeValueAsString(new MapAsNumber()));
-
     }
 
     public void testWithList() throws Exception {
diff --git a/src/test/java/com/fasterxml/jackson/databind/util/EnumValuesTest.java b/src/test/java/com/fasterxml/jackson/databind/util/EnumValuesTest.java
index 8034ad2b5..ccc3ea263 100644
--- a/src/test/java/com/fasterxml/jackson/databind/util/EnumValuesTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/util/EnumValuesTest.java
@@ -50,10 +50,9 @@ public class EnumValuesTest extends BaseMapTest
         assertEquals(3, values.internalMap().size());
     }
 
-    @SuppressWarnings("deprecation")
     public void testEnumResolver()
     {
-        EnumResolver enumRes = EnumResolver.constructUnsafeUsingToString(ABC.class);
+        EnumResolver enumRes = EnumResolver.constructUnsafeUsingToString(ABC.class, null);
         assertEquals(ABC.B, enumRes.getEnum(1));
         assertNull(enumRes.getEnum(-1));
         assertNull(enumRes.getEnum(3));
