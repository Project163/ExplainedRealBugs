diff --git a/release-notes/VERSION b/release-notes/VERSION
index dbfcf5e02..1fbcbc96e 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -9,6 +9,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
 
 #5065: Change default for `DateTimeFeature.ONE_BASED_MONTHS` to `true` in 3.0
 #5066: Move date/time `SerializationFeature`s into `DateTimeFeature` (3.0)
+#5067: Move date/time `DeserializationFeature`s into `DateTimeFeature` (3.0)
 - Branch rename "master" -> "3.x" [JSTEP-12]
 
 3.0.0-rc3 (not yet released)
diff --git a/src/main/java/tools/jackson/databind/DeserializationFeature.java b/src/main/java/tools/jackson/databind/DeserializationFeature.java
index 42b38c753..83675f3a1 100644
--- a/src/main/java/tools/jackson/databind/DeserializationFeature.java
+++ b/src/main/java/tools/jackson/databind/DeserializationFeature.java
@@ -449,43 +449,6 @@ public enum DeserializationFeature implements ConfigFeature
      */
     READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE(false),
 
-    /**
-     * Feature that controls whether numeric timestamp values are expected
-     * to be written using nanosecond timestamps (enabled) or not (disabled),
-     * <b>if and only if</b> datatype supports such resolution.
-     * Only newer datatypes (such as Java8 Date/Time) support such resolution --
-     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --
-     * and this setting <b>has no effect</b> on such types.
-     *<p>
-     * If disabled, standard millisecond timestamps are assumed.
-     * This is the counterpart to {@link DateTimeFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.
-     *<p>
-     * Feature is enabled by default, to support most accurate time values possible.
-     */
-    READ_DATE_TIMESTAMPS_AS_NANOSECONDS(true),
-
-    /**
-     * Feature that specifies whether context provided {@link java.util.TimeZone}
-     * ({@link DeserializationContext#getTimeZone()} should be used to adjust Date/Time
-     * values on deserialization, even if value itself contains timezone information.
-     * If enabled, contextual <code>TimeZone</code> will essentially override any other
-     * TimeZone information; if disabled, it will only be used if value itself does not
-     * contain any TimeZone information.
-     *<p>
-     * Note that exact behavior depends on date/time types in question; and specifically
-     * JDK type of {@link java.util.Date} does NOT have in-built timezone information
-     * so this setting has no effect.
-     * Further, while {@link java.util.Calendar} does have this information basic
-     * JDK {@link java.text.SimpleDateFormat} is unable to retain parsed zone information,
-     * and as a result, {@link java.util.Calendar} will always get context timezone
-     * adjustment regardless of this setting.
-     *<p>
-     *<p>
-     * Taking above into account, this feature is supported only by extension modules for
-     * Joda and Java 8 date/time datatypes.
-     */
-    ADJUST_DATES_TO_CONTEXT_TIME_ZONE(true),
-
     /*
     /**********************************************************************
     /* Other
diff --git a/src/main/java/tools/jackson/databind/MapperFeature.java b/src/main/java/tools/jackson/databind/MapperFeature.java
index 79d1924fa..2dac6d374 100644
--- a/src/main/java/tools/jackson/databind/MapperFeature.java
+++ b/src/main/java/tools/jackson/databind/MapperFeature.java
@@ -28,13 +28,13 @@ public enum MapperFeature
 
     /**
      * Feature that determines whether otherwise regular "getter"
-     * methods (but only ones that handle Collections and Maps,
-     * not getters of other type)
-     * can be used for purpose of getting a reference to a Collection
-     * and Map to modify the property, without requiring a setter
-     * method.
-     * This is similar to how JAXB framework sets Collections and
-     * Maps: no setter is involved, just getter.
+     * methods (but only ones that handle {@link java.util.Collection}s
+     * and {@link java.util.Map}s, not getters of other types)
+     * can be used for purpose of getting a reference to
+     * {@code Collection} / {@code Map} valued properties,
+     * without requiring a setter method.
+     * This is similar to how JAXB framework sets {@code Collection}s
+     * and {@code Map}s: no setter is involved, just getter.
      *<p>
      * Note that such getters-as-setters methods have lower
      * precedence than setters, so they are only used if no
diff --git a/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java b/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java
index d757a524c..f53c563ca 100644
--- a/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java
+++ b/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java
@@ -1,6 +1,6 @@
 package tools.jackson.databind.cfg;
 
-import tools.jackson.databind.DeserializationFeature;
+import tools.jackson.databind.DeserializationContext;
 
 /**
  * Configurable on/off features to configure Date/Time handling.
@@ -12,6 +12,30 @@ import tools.jackson.databind.DeserializationFeature;
  */
 public enum DateTimeFeature implements DatatypeFeature
 {
+    /**
+     * Feature that specifies whether context provided {@link java.util.TimeZone}
+     * ({@link DeserializationContext#getTimeZone()} should be used to adjust Date/Time
+     * values on deserialization, even if value itself contains timezone information.
+     * If enabled, contextual <code>TimeZone</code> will essentially override any other
+     * TimeZone information; if disabled, it will only be used if value itself does not
+     * contain any TimeZone information.
+     *<p>
+     * Note that exact behavior depends on date/time types in question; and specifically
+     * JDK type of {@link java.util.Date} does NOT have in-built timezone information
+     * so this setting has no effect.
+     * Further, while {@link java.util.Calendar} does have this information basic
+     * JDK {@link java.text.SimpleDateFormat} is unable to retain parsed zone information,
+     * and as a result, {@link java.util.Calendar} will always get context timezone
+     * adjustment regardless of this setting.
+     *<p>
+     * Taking above into account, this feature is supported only by extension modules for
+     * Joda and Java 8 date/time datatypes.
+     *<p>
+     * Feature used to be one of {@link tools.jackson.databind.DeserializationFeature}s
+     * in Jackson 2.x but was moved here in 3.0.
+     */
+    ADJUST_DATES_TO_CONTEXT_TIME_ZONE(true),
+
     /**
      * Feature that controls whether stringified numbers (Strings that without
      * quotes would be legal JSON Numbers) may be interpreted as
@@ -51,6 +75,25 @@ public enum DateTimeFeature implements DatatypeFeature
      */
     ONE_BASED_MONTHS(true),
 
+    /**
+     * Feature that controls whether numeric timestamp values are expected
+     * to be written using nanosecond timestamps (enabled) or not (disabled),
+     * <b>if and only if</b> datatype supports such resolution.
+     * Only newer datatypes (such as Java8 Date/Time) support such resolution --
+     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --
+     * and this setting <b>has no effect</b> on such types.
+     *<p>
+     * If disabled, standard millisecond timestamps are assumed.
+     * This is the counterpart to {@link DateTimeFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.
+     *<p>
+     * Feature used to be one of {@link tools.jackson.databind.DeserializationFeature}s
+     * in Jackson 2.x but was moved here in 3.0.
+     *<p>
+     * Feature is enabled by default, to support most accurate time values possible (where
+     * available).
+     */
+    READ_DATE_TIMESTAMPS_AS_NANOSECONDS(true),
+
     /**
      * Feature that determines whether the {@link java.util.TimeZone} of the
      * {@link tools.jackson.databind.DeserializationContext} is used
@@ -113,7 +156,7 @@ public enum DateTimeFeature implements DatatypeFeature
      * and this setting <b>has no effect</b> on such types.
      *<p>
      * If disabled, standard millisecond timestamps are assumed.
-     * This is the counterpart to {@link DeserializationFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS}.
+     * This is the counterpart to {@link DateTimeFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS}.
      *<p>
      * Feature used to be one of {@link tools.jackson.databind.SerializationFeature}s
      * in Jackson 2.x but was moved here in 3.0.
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/JavaTimeInitializer.java b/src/main/java/tools/jackson/databind/ext/javatime/JavaTimeInitializer.java
index c1eebfefa..6d24f1448 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/JavaTimeInitializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/JavaTimeInitializer.java
@@ -53,7 +53,7 @@ import tools.jackson.databind.ser.std.ToStringSerializer;
  * <p>
  * Granularity of timestamps is controlled through the companion features
  * {@link DateTimeFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS} and
- * {@link DeserializationFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS}. For serialization, timestamps are
+ * {@link DateTimeFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS}. For serialization, timestamps are
  * written as fractional numbers (decimals), where the number is seconds and the decimal is fractional seconds, if
  * {@code WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS} is enabled (it is by default), with resolution as fine as nanoseconds depending on the
  * underlying JDK implementation. If {@code WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS} is disabled, timestamps are written as a whole number of
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/DurationDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/DurationDeserializer.java
index ec6e87975..f400244ea 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/DurationDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/DurationDeserializer.java
@@ -29,6 +29,7 @@ import tools.jackson.core.JsonTokenId;
 import tools.jackson.core.StreamReadCapability;
 import tools.jackson.core.io.NumberInput;
 import tools.jackson.databind.*;
+import tools.jackson.databind.cfg.DateTimeFeature;
 import tools.jackson.databind.ext.javatime.util.DecimalUtils;
 import tools.jackson.databind.ext.javatime.util.DurationUnitConverter;
 
@@ -43,7 +44,7 @@ public class DurationDeserializer extends JSR310DeserializerBase<Duration>
      * When defined (not {@code null}) integer values will be converted into duration
      * unit configured for the converter.
      * Using this converter will typically override the value specified in
-     * {@link DeserializationFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS} as it is
+     * {@link DateTimeFeature#READ_DATE_TIMESTAMPS_AS_NANOSECONDS} as it is
      * considered that the unit set in {@link JsonFormat#pattern()} has precedence
      * since it is more specific.
      *<p>
@@ -209,6 +210,6 @@ public class DurationDeserializer extends JSR310DeserializerBase<Duration>
 
     protected boolean shouldReadTimestampsAsNanoseconds(DeserializationContext context) {
         return (_readTimestampsAsNanosOverride != null) ? _readTimestampsAsNanosOverride :
-            context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+            context.isEnabled(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 }
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
index 2d5d96df1..cc1a6a294 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
@@ -287,12 +287,12 @@ public class InstantDeserializer<T extends Temporal>
 
     protected boolean shouldAdjustToContextTimezone(DeserializationContext context) {
         return (_adjustToContextTZOverride != null) ? _adjustToContextTZOverride :
-                context.isEnabled(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                context.isEnabled(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
     }
 
     protected boolean shouldReadTimestampsAsNanoseconds(DeserializationContext context) {
         return (_readTimestampsAsNanosOverride != null) ? _readTimestampsAsNanosOverride :
-            context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+            context.isEnabled(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 
     // Helper method to find Strings of form "all digits" and "digits-comma-digits"
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserializer.java
index f2162c4f3..30f7a221a 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserializer.java
@@ -163,7 +163,7 @@ public class LocalDateTimeDeserializer
 
     protected boolean shouldReadTimestampsAsNanoseconds(DeserializationContext context) {
         return (_readTimestampsAsNanosOverride != null) ? _readTimestampsAsNanosOverride :
-            context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+            context.isEnabled(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 
     protected LocalDateTime _fromString(JsonParser p, DeserializationContext ctxt,
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserializer.java
index 131a1ff56..ac0ccbc05 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserializer.java
@@ -29,6 +29,7 @@ import tools.jackson.core.JsonToken;
 import tools.jackson.databind.BeanProperty;
 import tools.jackson.databind.DeserializationContext;
 import tools.jackson.databind.DeserializationFeature;
+import tools.jackson.databind.cfg.DateTimeFeature;
 
 /**
  * Deserializer for Java 8 temporal {@link LocalTime}s.
@@ -167,7 +168,7 @@ public class LocalTimeDeserializer extends JSR310DateTimeDeserializerBase<LocalT
 
     protected boolean shouldReadTimestampsAsNanoseconds(DeserializationContext context) {
         return (_readTimestampsAsNanosOverride != null) ? _readTimestampsAsNanosOverride :
-            context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+            context.isEnabled(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 
     protected LocalTime _fromString(JsonParser p, DeserializationContext ctxt,
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserializer.java
index 436f633b5..bef40805a 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserializer.java
@@ -25,6 +25,7 @@ import java.util.Objects;
 import com.fasterxml.jackson.annotation.JsonFormat;
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
+import tools.jackson.databind.cfg.DateTimeFeature;
 
 /**
  * Deserializer for Java 8 temporal {@link OffsetTime}s.
@@ -172,7 +173,7 @@ public class OffsetTimeDeserializer extends JSR310DateTimeDeserializerBase<Offse
 
     protected boolean shouldReadTimestampsAsNanoseconds(DeserializationContext context) {
         return (_readTimestampsAsNanosOverride != null) ? _readTimestampsAsNanosOverride :
-            context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+            context.isEnabled(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 
     protected OffsetTime _fromString(JsonParser p, DeserializationContext ctxt,
diff --git a/src/test/java/tools/jackson/databind/deser/jdk/DateDeserializationTest.java b/src/test/java/tools/jackson/databind/deser/jdk/DateDeserializationTest.java
index 7b37675eb..188bf1f09 100644
--- a/src/test/java/tools/jackson/databind/deser/jdk/DateDeserializationTest.java
+++ b/src/test/java/tools/jackson/databind/deser/jdk/DateDeserializationTest.java
@@ -12,6 +12,7 @@ import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.annotation.OptBoolean;
 
 import tools.jackson.databind.*;
+import tools.jackson.databind.cfg.DateTimeFeature;
 import tools.jackson.databind.exc.InvalidFormatException;
 import tools.jackson.databind.exc.MismatchedInputException;
 
@@ -642,7 +643,7 @@ public class DateDeserializationTest
         final String tzId = "PST";
 
         // this is enabled by default:
-        assertTrue(MAPPER.isEnabled(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
+        assertTrue(MAPPER.isEnabled(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
         final ObjectReader r = MAPPER
                 .readerFor(Calendar.class)
                 .with(TimeZone.getTimeZone(tzId));
@@ -662,7 +663,7 @@ public class DateDeserializationTest
         assertEquals(11, cal.get(Calendar.HOUR_OF_DAY));
 
         // but if disabled, should use what's been sent in:
-        cal = r.without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+        cal = r.without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(q(inputStr));
 
         // 23-Jun-2017, tatu: Actually turns out to be hard if not impossible to do ...
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/TestFeatures.java b/src/test/java/tools/jackson/databind/ext/javatime/TestFeatures.java
index 4ebe5317e..84472fe29 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/TestFeatures.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/TestFeatures.java
@@ -18,7 +18,6 @@ package tools.jackson.databind.ext.javatime;
 
 import org.junit.jupiter.api.Test;
 
-import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.cfg.DateTimeFeature;
 
 import static org.junit.jupiter.api.Assertions.*;
@@ -35,14 +34,14 @@ public class TestFeatures
     @Test
     public void testReadDateTimestampsAsNanosecondsSettingEnabledByDefault()
     {
-        assertTrue(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS.enabledByDefault(),
+        assertTrue(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS.enabledByDefault(),
                 "Read date timestamps as nanoseconds setting should be enabled by default.");
     }
 
     @Test
     public void testAdjustDatesToContextTimeZoneSettingEnabledByDefault()
     {
-        assertTrue(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE.enabledByDefault(),
+        assertTrue(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE.enabledByDefault(),
                 "Adjust dates to context time zone setting should be enabled by default.");
     }
 }
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/DurationDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/DurationDeserTest.java
index d6a76f7e6..23f183bd7 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/DurationDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/DurationDeserTest.java
@@ -18,6 +18,7 @@ import tools.jackson.core.type.TypeReference;
 import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
+import tools.jackson.databind.cfg.DateTimeFeature;
 import tools.jackson.databind.exc.InvalidDefinitionException;
 import tools.jackson.databind.exc.MismatchedInputException;
 import tools.jackson.databind.ext.javatime.DateTimeTestBase;
@@ -58,11 +59,10 @@ public class DurationDeserTest extends DateTimeTestBase
         public WrapperWithReadTimestampsAsNanosEnabled(Duration v) { value = v; }
     }
 
-
     @Test
     public void testDeserializationAsFloat01() throws Exception
     {
-        Duration value = READER.with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("60.0");
         assertEquals(Duration.ofSeconds(60L, 0), value, "The value is not correct.");
     }
@@ -70,7 +70,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsFloat02() throws Exception
     {
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("60.0");
         assertEquals(Duration.ofSeconds(60L, 0), value, "The value is not correct.");
     }
@@ -78,7 +78,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsFloat03() throws Exception
     {
-        Duration value = READER.with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("13498.000008374");
         assertEquals(Duration.ofSeconds(13498L, 8374), value, "The value is not correct.");
     }
@@ -86,7 +86,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsFloat04() throws Exception
     {
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("13498.000008374");
         assertEquals(Duration.ofSeconds(13498L, 8374), value, "The value is not correct.");
     }
@@ -98,7 +98,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase01() throws Exception
     {
         String input = Long.MAX_VALUE + ".999999999";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                  .readValue(input);
         assertEquals(Long.MAX_VALUE, value.getSeconds());
         assertEquals(999999999, value.getNano());
@@ -111,7 +111,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase02() throws Exception
     {
         String input = Long.MIN_VALUE + ".0";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                  .readValue(input);
         assertEquals(Long.MIN_VALUE, value.getSeconds());
         assertEquals(0, value.getNano());
@@ -122,7 +122,7 @@ public class DurationDeserTest extends DateTimeTestBase
     {
         // Duration can't go this low
         assertThrows(ArithmeticException.class, () -> {
-            READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+            READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                     .readValue(Long.MIN_VALUE + ".1");
         });
     }
@@ -138,7 +138,7 @@ public class DurationDeserTest extends DateTimeTestBase
     {
         // Just beyond the upper-bound of Duration.
         String input = new BigInteger(Long.toString(Long.MAX_VALUE)).add(BigInteger.ONE) + ".0";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                  .readValue(input);
         assertEquals(Long.MIN_VALUE, value.getSeconds());  // We've turned a positive number into negative duration!
     }
@@ -148,7 +148,7 @@ public class DurationDeserTest extends DateTimeTestBase
     {
         // Just beyond the lower-bound of Duration.
         String input = new BigInteger(Long.toString(Long.MIN_VALUE)).subtract(BigInteger.ONE) + ".0";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                  .readValue(input);
         assertEquals(Long.MAX_VALUE, value.getSeconds());  // We've turned a negative number into positive duration!
     }
@@ -158,7 +158,7 @@ public class DurationDeserTest extends DateTimeTestBase
     {
         // Into the positive zone where everything becomes zero.
         String input = "1e64";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -168,7 +168,7 @@ public class DurationDeserTest extends DateTimeTestBase
     {
         // Into the negative zone where everything becomes zero.
         String input = "-1e64";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -182,7 +182,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase08() throws Exception
     {
         String input = "1e10000000";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                  .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -192,7 +192,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase09() throws Exception
     {
         String input = "-1e10000000";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -205,7 +205,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase10() throws Exception
     {
         String input = "1e-10000000";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -215,7 +215,7 @@ public class DurationDeserTest extends DateTimeTestBase
     public void testDeserializationAsFloatEdgeCase11() throws Exception
     {
         String input = "-1e-10000000";
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(input);
         assertEquals(0, value.getSeconds());
     }
@@ -223,7 +223,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsInt01() throws Exception
     {
-        Duration value = READER.with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("60");
         assertEquals(Duration.ofSeconds(60L, 0), value, "The value is not correct.");
     }
@@ -231,7 +231,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsInt02() throws Exception
     {
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("60000");
         assertEquals(Duration.ofSeconds(60L, 0), value, "The value is not correct.");
     }
@@ -239,7 +239,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsInt03() throws Exception
     {
-        Duration value = READER.with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("13498");
         assertEquals(Duration.ofSeconds(13498L, 0), value, "The value is not correct.");
     }
@@ -247,7 +247,7 @@ public class DurationDeserTest extends DateTimeTestBase
     @Test
     public void testDeserializationAsInt04() throws Exception
     {
-        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+        Duration value = READER.without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("13498000");
         assertEquals(Duration.ofSeconds(13498L, 0), value, "The value is not correct.");
     }
@@ -307,7 +307,7 @@ public class DurationDeserTest extends DateTimeTestBase
                 .addMixIn(TemporalAmount.class, MockObjectConfiguration.class)
                 .build();
         TemporalAmount value = mapper.readerFor(TemporalAmount.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(prefix + "13498.000008374]");
 
         assertTrue(value instanceof Duration, "The value should be a Duration.");
@@ -322,7 +322,7 @@ public class DurationDeserTest extends DateTimeTestBase
                 .addMixIn(TemporalAmount.class, MockObjectConfiguration.class)
                 .build();
         TemporalAmount value = mapper.readerFor(TemporalAmount.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(prefix + "13498]");
         assertTrue(value instanceof Duration, "The value should be a Duration.");
         assertEquals(Duration.ofSeconds(13498L), value, "The value is not correct.");
@@ -337,7 +337,7 @@ public class DurationDeserTest extends DateTimeTestBase
                 .build();
         TemporalAmount value = mapper
                 .readerFor(TemporalAmount.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(prefix + "13498837]");
         assertTrue(value instanceof Duration, "The value should be a Duration.");
         assertEquals(Duration.ofSeconds(13498L, 837000000), value, "The value is not correct.");
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
index 0017917ea..23a52da6a 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
@@ -11,18 +11,17 @@ import java.util.regex.Matcher;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 
-import tools.jackson.core.type.TypeReference;
-import tools.jackson.databind.exc.MismatchedInputException;
-import tools.jackson.databind.ext.javatime.DateTimeTestBase;
-import tools.jackson.databind.ext.javatime.MockObjectConfiguration;
-import tools.jackson.databind.ext.javatime.util.DecimalUtils;
-
 import com.fasterxml.jackson.annotation.JsonFormat;
 
-import tools.jackson.databind.DeserializationFeature;
+import tools.jackson.core.type.TypeReference;
+
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
 import tools.jackson.databind.cfg.DateTimeFeature;
+import tools.jackson.databind.exc.MismatchedInputException;
+import tools.jackson.databind.ext.javatime.DateTimeTestBase;
+import tools.jackson.databind.ext.javatime.MockObjectConfiguration;
+import tools.jackson.databind.ext.javatime.util.DecimalUtils;
 
 import static org.junit.jupiter.api.Assertions.*;
 import static tools.jackson.databind.ext.javatime.deser.InstantDeserializer.ISO8601_COLONLESS_OFFSET_REGEX;
@@ -233,7 +232,7 @@ public class InstantDeserTest extends DateTimeTestBase
     {
         Instant date = Instant.ofEpochSecond(0L);
         Instant value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertEquals(date, value);
     }
@@ -244,7 +243,7 @@ public class InstantDeserTest extends DateTimeTestBase
         final long ts = 123456789L;
         Instant date = Instant.ofEpochSecond(ts);
         Instant value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(String.valueOf(ts));
         assertEquals(date, value);
     }
@@ -256,7 +255,7 @@ public class InstantDeserTest extends DateTimeTestBase
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
 
         Instant value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.getEpochSecond()));
         assertEquals(date, value);
     }
@@ -285,7 +284,7 @@ public class InstantDeserTest extends DateTimeTestBase
     {
         Instant date = Instant.ofEpochSecond(0L);
         Instant value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertEquals(date, value);
     }
@@ -295,7 +294,7 @@ public class InstantDeserTest extends DateTimeTestBase
     {
         Instant date = Instant.ofEpochSecond(123456789L, 422000000);
         Instant value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789422");
         assertEquals(date, value);
     }
@@ -307,7 +306,7 @@ public class InstantDeserTest extends DateTimeTestBase
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
 
         Instant value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toEpochMilli()));
         assertEquals(date, value);
     }
@@ -381,7 +380,7 @@ public class InstantDeserTest extends DateTimeTestBase
     {
         Instant date = Instant.ofEpochSecond(123456789L, 0);
         ObjectMapper m = newMapperBuilder()
-                .enable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .enable(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = m.readValue(
@@ -396,7 +395,7 @@ public class InstantDeserTest extends DateTimeTestBase
     {
         Instant date = Instant.ofEpochSecond(123456789L, 422000000);
         ObjectMapper m = newMapperBuilder()
-                .disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .disable(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = m.readValue(
@@ -560,7 +559,7 @@ public class InstantDeserTest extends DateTimeTestBase
         ObjectMapper mapper = newMapperBuilder()
                 .configure(DateTimeFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
                 .configure(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS, false)
-                .configure(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
+                .configure(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
                 .build();
 
         Instant givenInstant = LocalDate.of(2016, 1, 1).atStartOfDay().atZone(ZoneOffset.UTC).toInstant();
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserTest.java
index 07509458f..12f9ab21d 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateTimeDeserTest.java
@@ -136,7 +136,7 @@ public class LocalDateTimeDeserTest
     public void testDeserializationAsTimestamp03Nanoseconds()
     {
         ObjectReader r = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
         LocalDateTime value = r.readValue("[2013,8,21,9,22,0,57]");
         LocalDateTime time = LocalDateTime.of(2013, Month.AUGUST, 21, 9, 22, 0, 57);
         assertEquals(time, value, "The value is not correct.");
@@ -146,7 +146,7 @@ public class LocalDateTimeDeserTest
     public void testDeserializationAsTimestamp03Milliseconds()
     {
         ObjectReader r = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
         LocalDateTime value = r.readValue("[2013,8,21,9,22,0,57]");
         LocalDateTime time = LocalDateTime.of(2013, Month.AUGUST, 21, 9, 22, 0, 57000000);
         assertEquals(time, value, "The value is not correct.");
@@ -156,7 +156,7 @@ public class LocalDateTimeDeserTest
     public void testDeserializationAsTimestamp04Nanoseconds()
     {
         ObjectReader r = MAPPER.readerFor(LocalDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
         LocalDateTime value = r.readValue("[2005,11,5,22,31,5,829837]");
         LocalDateTime time = LocalDateTime.of(2005, Month.NOVEMBER, 5, 22, 31, 5, 829837);
         assertEquals(time, value, "The value is not correct.");
@@ -166,7 +166,7 @@ public class LocalDateTimeDeserTest
     public void testDeserializationAsTimestamp04Milliseconds01()
     {
         ObjectReader r = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
         LocalDateTime value = r.readValue("[2005,11,5,22,31,5,829837]");
 
         LocalDateTime time = LocalDateTime.of(2005, Month.NOVEMBER, 5, 22, 31, 5, 829837);
@@ -177,7 +177,7 @@ public class LocalDateTimeDeserTest
     public void testDeserializationAsTimestamp04Milliseconds02()
     {
         ObjectReader r = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);
         LocalDateTime value = r.readValue("[2005,11,5,22,31,5,829]");
         LocalDateTime time = LocalDateTime.of(2005, Month.NOVEMBER, 5, 22, 31, 5, 829000000);
         assertEquals(time, value, "The value is not correct.");
@@ -425,7 +425,7 @@ public class LocalDateTimeDeserTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = m.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + LocalDateTime.class.getName() + "\",[2005,11,5,22,31,5,829837]]");
         assertTrue(value instanceof LocalDateTime, "The value should be a LocalDateTime.");
@@ -441,7 +441,7 @@ public class LocalDateTimeDeserTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = m.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + LocalDateTime.class.getName() + "\",[2005,11,5,22,31,5,422]]");
         assertTrue(value instanceof LocalDateTime, "The value should be a LocalDateTime.");
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserTest.java
index da8c80108..b41b80dc3 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalTimeDeserTest.java
@@ -31,6 +31,7 @@ import tools.jackson.core.type.TypeReference;
 import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
+import tools.jackson.databind.cfg.DateTimeFeature;
 import tools.jackson.databind.exc.InvalidFormatException;
 import tools.jackson.databind.exc.MismatchedInputException;
 import tools.jackson.databind.ext.javatime.DateTimeTestBase;
@@ -93,7 +94,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp03Nanoseconds() throws Exception
     {
         LocalTime value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[9,22,0,57]");
         assertEquals(LocalTime.of(9, 22, 0, 57), value, "The value is not correct.");
     }
@@ -102,7 +103,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp03Milliseconds() throws Exception
     {
         LocalTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[9,22,0,57]");
         assertEquals(LocalTime.of(9, 22, 0, 57000000), value, "The value is not correct.");
     }
@@ -111,7 +112,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp04Nanoseconds() throws Exception
     {
         LocalTime value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[22,31,5,829837]");
         assertEquals(LocalTime.of(22, 31, 5, 829837), value, "The value is not correct.");
     }
@@ -120,7 +121,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp04Milliseconds01() throws Exception
     {
         LocalTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[22,31,5,829837]");
         assertEquals(LocalTime.of(22, 31, 5, 829837), value, "The value is not correct.");
     }
@@ -129,7 +130,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp04Milliseconds02() throws Exception
     {
         LocalTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[22,31,5,829]");
         assertEquals(LocalTime.of(22, 31, 5, 829000000), value, "The value is not correct.");
     }
@@ -235,7 +236,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + LocalTime.class.getName() + "\",[22,31,5,829837]]");
 
         assertNotNull(value, "The value should not be null.");
@@ -252,7 +253,7 @@ public class LocalTimeDeserTest extends DateTimeTestBase
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + LocalTime.class.getName() + "\",[22,31,5,422]]");
         assertTrue(value instanceof LocalTime, "The value should be a LocalTime.");
         assertEquals(time, value, "The value is not correct.");
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetDateTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetDateTimeDeserTest.java
index dbc3a2e32..69e05bdc4 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetDateTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetDateTimeDeserTest.java
@@ -15,7 +15,7 @@ import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.annotation.JsonFormat.Feature;
 
 import tools.jackson.core.type.TypeReference;
-import tools.jackson.databind.DeserializationFeature;
+
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
 import tools.jackson.databind.cfg.DateTimeFeature;
@@ -141,7 +141,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
 
         assertIsEqual(date, value);
@@ -153,7 +153,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .with(TimeZone.getDefault())
                 .readValue("0");
 
@@ -166,7 +166,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
 
         assertIsEqual(date, value);
@@ -178,7 +178,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
 
         assertIsEqual(date, value);
@@ -190,7 +190,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 0), Z2);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789");
 
         assertIsEqual(date, value);
@@ -202,7 +202,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 0), Z2);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789");
 
         assertIsEqual(date, value);
@@ -214,7 +214,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 422000000), Z2);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789422");
 
         assertIsEqual(date, value);
@@ -226,7 +226,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 422000000), Z2);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789422");
 
         assertIsEqual(date, value);
@@ -239,7 +239,7 @@ public class OffsetDateTimeDeserTest
         OffsetDateTime date = OffsetDateTime.now(Z3);
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toEpochSecond()));
 
         assertIsEqual(date, value);
@@ -252,7 +252,7 @@ public class OffsetDateTimeDeserTest
         OffsetDateTime date = OffsetDateTime.now(Z3);
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toEpochSecond()));
 
         assertIsEqual(date, value);
@@ -265,7 +265,7 @@ public class OffsetDateTimeDeserTest
         OffsetDateTime date = OffsetDateTime.now(Z3);
         date = date.minus(date.getNano() - (date.get(ChronoField.MILLI_OF_SECOND) * 1_000_000L), ChronoUnit.NANOS);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toInstant().toEpochMilli()));
 
         assertIsEqual(date, value);
@@ -278,7 +278,7 @@ public class OffsetDateTimeDeserTest
         OffsetDateTime date = OffsetDateTime.now(Z3);
         date = date.minus(date.getNano() - (date.get(ChronoField.MILLI_OF_SECOND) * 1_000_000L), ChronoUnit.NANOS);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toInstant().toEpochMilli()));
 
         assertIsEqual(date, value);
@@ -354,7 +354,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneOffset.UTC, value.getOffset(), "The time zone is not correct.");
@@ -365,7 +365,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(getDefaultOffset(date), value.getOffset(), "The time zone is not correct.");
@@ -376,7 +376,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(getOffset(value, Z1), value.getOffset(), "The time zone is not correct.");
@@ -387,7 +387,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ObjectReader r = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
 
         String sDate = offsetWithoutColon(FORMATTER.format(date));
 
@@ -402,7 +402,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneOffset.UTC, value.getOffset(), "The time zone is not correct.");
@@ -413,7 +413,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(getDefaultOffset(date), value.getOffset(), "The time zone is not correct.");
@@ -424,7 +424,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
 
         assertIsEqual(date, value);
@@ -436,7 +436,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         ObjectReader r = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
 
         String sDate = offsetWithoutColon(FORMATTER.format(date));
 
@@ -451,7 +451,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.now(Z3);
         OffsetDateTime value = MAPPER.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneOffset.UTC, value.getOffset(), "The time zone is not correct.");
@@ -462,7 +462,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.now(Z3);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(getDefaultOffset(date), value.getOffset(), "The time zone is not correct.");
@@ -473,7 +473,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.now(Z3);
         OffsetDateTime value = MAPPER_DEFAULT_TZ.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(getOffset(value, Z3), value.getOffset(), "The time zone is not correct.");
@@ -485,7 +485,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.now(Z3);
         ObjectReader r = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
 
         String sDate = offsetWithoutColon(FORMATTER.format(date));
 
@@ -535,7 +535,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",123456789]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -551,7 +551,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",123456789]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -567,7 +567,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",123456789422]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -583,7 +583,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",123456789422]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -599,7 +599,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -615,7 +615,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
         assertTrue(value instanceof OffsetDateTime, "The value should be an OffsetDateTime.");
@@ -632,7 +632,7 @@ public class OffsetDateTimeDeserTest
             .addMixIn(Temporal.class, MockObjectConfiguration.class)
             .build();
         Temporal value = m.readerFor(Temporal.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + OffsetDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
 
@@ -665,7 +665,7 @@ public class OffsetDateTimeDeserTest
                 .without(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS)
                 .writeValueAsString(java.util.Date.from(givenInstant));
         OffsetDateTime actual = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(json);
         assertEquals(givenInstant.atOffset(ZoneOffset.UTC), actual);
     }
@@ -719,7 +719,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.MIN;
         ObjectMapper m = mapperBuilder()
-                .enable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .enable(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .defaultTimeZone(TimeZone.getTimeZone(Z1))
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
@@ -738,7 +738,7 @@ public class OffsetDateTimeDeserTest
     {
         OffsetDateTime date = OffsetDateTime.MAX;
         ObjectMapper m = mapperBuilder()
-                .enable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .enable(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .defaultTimeZone(TimeZone.getTimeZone(Z1))
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
@@ -763,7 +763,7 @@ public class OffsetDateTimeDeserTest
     @Test
     public void OffsetDateTime_with_offset_can_be_deserialized() throws Exception {
         ObjectReader r = MAPPER.readerFor(OffsetDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
 
         String base = "2015-07-24T12:23:34.184";
         for (String offset : Arrays.asList("+00", "-00")) {
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
index ea8cd44f2..9dd79631b 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
@@ -16,6 +16,7 @@ import tools.jackson.core.type.TypeReference;
 import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
+import tools.jackson.databind.cfg.DateTimeFeature;
 import tools.jackson.databind.exc.MismatchedInputException;
 import tools.jackson.databind.ext.javatime.DateTimeTestBase;
 import tools.jackson.databind.ext.javatime.MockObjectConfiguration;
@@ -68,7 +69,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     {
         OffsetTime time = OffsetTime.of(15, 43, 0, 0, ZoneOffset.of("+0300"));
         OffsetTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[15,43,\"+0300\"]");
 
         assertNotNull(value, "The value should not be null.");
@@ -90,7 +91,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     {
         OffsetTime time = OffsetTime.of(9, 22, 0, 57, ZoneOffset.of("-0630"));
         OffsetTime value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[9,22,0,57,\"-06:30\"]");
 
         assertNotNull(value, "The value should not be null.");
@@ -101,7 +102,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp03Milliseconds() throws Exception {
         OffsetTime time = OffsetTime.of(9, 22, 0, 57000000, ZoneOffset.of("-0630"));
         OffsetTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[9,22,0,57,\"-06:30\"]");
 
         assertNotNull(value, "The value should not be null.");
@@ -112,7 +113,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     public void testDeserializationAsTimestamp04Nanoseconds() throws Exception {
         OffsetTime time = OffsetTime.of(22, 31, 5, 829837, ZoneOffset.of("+1100"));
         OffsetTime value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[22,31,5,829837,\"+11:00\"]");
 
         assertNotNull(value, "The value should not be null.");
@@ -124,7 +125,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     {
         OffsetTime time = OffsetTime.of(22, 31, 5, 829837, ZoneOffset.of("+1100"));
         OffsetTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[22,31,5,829837,\"+11:00\"]");
         assertEquals(time, value, "The value is not correct.");
     }
@@ -134,7 +135,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
     {
         OffsetTime time = OffsetTime.of(22, 31, 5, 829000000, ZoneOffset.of("+1100"));
         OffsetTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .readValue("[22,31,5,829,\"+11:00\"]");
         assertEquals(time, value, "The value is not correct.");
     }
@@ -145,7 +146,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
         ObjectReader reader = newMapper().readerFor(WrapperWithReadTimestampsAsNanosEnabled.class);
         OffsetTime time = OffsetTime.of(9, 22, 0, 57, ZoneOffset.of("-0630"));
         WrapperWithReadTimestampsAsNanosEnabled actual = reader
-            .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+            .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
             .readValue(a2q("{'value':[9,22,0,57,'-06:30']}"));
 
         assertNotNull(actual, "The value should not be null.");
@@ -158,7 +159,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
         ObjectReader reader = newMapper().readerFor(WrapperWithReadTimestampsAsNanosDisabled.class);
         OffsetTime time = OffsetTime.of(9, 22, 0, 57000000, ZoneOffset.of("-0630"));
         WrapperWithReadTimestampsAsNanosDisabled actual = reader
-            .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+            .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
             .readValue(a2q("{'value':[9,22,0,57,'-06:30']}"));
 
         assertNotNull(actual, "The value should not be null.");
@@ -171,7 +172,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
         ObjectReader reader = newMapper().readerFor(WrapperWithReadTimestampsAsNanosDisabled.class);
         OffsetTime time = OffsetTime.of(9, 22, 0, 4257, ZoneOffset.of("-0630"));
         WrapperWithReadTimestampsAsNanosDisabled actual = reader
-            .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+            .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
             .readValue(a2q("{'value':[9,22,0,4257,'-06:30']}"));
 
         assertNotNull(actual, "The value should not be null.");
@@ -217,7 +218,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + OffsetTime.class.getName() + "\",[22,31,5,829837,\"+11:00\"]]");
         assertInstanceOf(OffsetTime.class, value, "The value should be a OffsetTime.");
@@ -233,7 +234,7 @@ public class OffsetTimeDeserTest extends DateTimeTestBase
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + OffsetTime.class.getName() + "\",[22,31,5,422,\"+11:00\"]]");
 
         assertNotNull(value, "The value should not be null.");
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/ZonedDateTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/ZonedDateTimeDeserTest.java
index a38124ddc..91bc9456a 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/ZonedDateTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/ZonedDateTimeDeserTest.java
@@ -118,7 +118,7 @@ public class ZonedDateTimeDeserTest extends DateTimeTestBase
         String inputString = "2021-02-01T19:49:04.0513486Z[UTC]";
 
         ZonedDateTime converted = newMapperBuilder()
-                .configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false)
+                .configure(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false)
                 .build()
                 .readerFor(ZonedDateTime.class).readValue(q(inputString));
 
@@ -277,7 +277,7 @@ public class ZonedDateTimeDeserTest extends DateTimeTestBase
     @Test
     public void ZonedDateTime_with_offset_can_be_deserialized() throws Exception {
         ObjectReader r = newMapper().readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
 
         String base = "2015-07-24T12:23:34.184";
         for (String offset : Arrays.asList("+00", "-00")) {
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/ser/ZonedDateTimeSerTest.java b/src/test/java/tools/jackson/databind/ext/javatime/ser/ZonedDateTimeSerTest.java
index 659a19a05..dffd0fd88 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/ser/ZonedDateTimeSerTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/ser/ZonedDateTimeSerTest.java
@@ -28,7 +28,6 @@ import org.junit.jupiter.api.Test;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
 
-import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
 import tools.jackson.databind.cfg.DateTimeFeature;
@@ -477,7 +476,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ZonedDateTime value = READER
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -488,7 +487,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ZonedDateTime value = newMapper(TimeZone.getDefault()).readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -499,7 +498,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ZonedDateTime value = READER
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -511,7 +510,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ZonedDateTime value = MAPPER_WITH_DEFAULT_TZ
                 .readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("0");
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -522,7 +521,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 0), Z2);
         ZonedDateTime value = MAPPER.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789");
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -533,7 +532,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 0), Z2);
         ZonedDateTime value = MAPPER_WITH_DEFAULT_TZ.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789");
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -544,7 +543,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 422000000), Z2);
         ZonedDateTime value = MAPPER.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789422");
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -556,7 +555,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 422000000), Z2);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("123456789422");
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -569,7 +568,7 @@ public class ZonedDateTimeSerTest
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
         ObjectMapper mapper = newMapper();
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toEpochSecond()));
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -582,7 +581,7 @@ public class ZonedDateTimeSerTest
         date = date.minus(date.getNano(), ChronoUnit.NANOS);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toEpochSecond()));
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -595,7 +594,7 @@ public class ZonedDateTimeSerTest
         date = date.minus(date.getNano() - (date.get(ChronoField.MILLI_OF_SECOND) * 1_000_000L), ChronoUnit.NANOS);
         ObjectMapper mapper = newMapper();
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toInstant().toEpochMilli()));
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -608,7 +607,7 @@ public class ZonedDateTimeSerTest
         date = date.minus(date.getNano() - (date.get(ChronoField.MILLI_OF_SECOND) * 1_000_000L), ChronoUnit.NANOS);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(Long.toString(date.toInstant().toEpochMilli()));
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -620,7 +619,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ObjectMapper mapper = newMapper();
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -632,7 +631,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), Z1);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -644,7 +643,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(0L), FIX_OFFSET);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(FIX_OFFSET, value.getZone(), "The time zone is not correct.");
@@ -663,7 +662,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         ZonedDateTime value = READER
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
 
         assertIsEqual(date, value);
@@ -676,7 +675,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), Z2);
         ZonedDateTime value = newMapper(TimeZone.getDefault())
                 .readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -688,7 +687,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.ofInstant(Instant.ofEpochSecond(123456789L, 183917322), FIX_OFFSET);
         ObjectMapper mapper = newMapper(TimeZone.getDefault());
         ZonedDateTime value = mapper.readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(FIX_OFFSET, value.getZone(), "The time zone is not correct.");
@@ -707,7 +706,7 @@ public class ZonedDateTimeSerTest
     {
         ZonedDateTime date = ZonedDateTime.now(Z3);
         ZonedDateTime value = READER
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(DEFAULT_TZ, value.getZone(), "The time zone is not correct.");
@@ -719,7 +718,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.now(Z3);
         ZonedDateTime value = newMapper(TimeZone.getDefault())
                 .readerFor(ZonedDateTime.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(ZoneId.systemDefault().normalized(), value.getZone(), "The time zone is not correct.");
@@ -731,7 +730,7 @@ public class ZonedDateTimeSerTest
         ZonedDateTime date = ZonedDateTime.now(FIX_OFFSET);
         ZonedDateTime value = newMapper(TimeZone.getDefault())
                 .readerFor(ZonedDateTime.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue('"' + FORMATTER.format(date) + '"');
         assertIsEqual(date, value);
         assertEquals(FIX_OFFSET, value.getZone(), "The time zone is not correct.");
@@ -783,7 +782,7 @@ public class ZonedDateTimeSerTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + ZonedDateTime.class.getName() + "\",123456789]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
         assertIsEqual(date, (ZonedDateTime) value);
@@ -798,7 +797,7 @@ public class ZonedDateTimeSerTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .with(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + ZonedDateTime.class.getName() + "\",123456789]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
         assertIsEqual(date, (ZonedDateTime) value);
@@ -814,7 +813,7 @@ public class ZonedDateTimeSerTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build();
         Temporal value = mapper.readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue("[\"" + ZonedDateTime.class.getName() + "\",123456789422]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
         assertIsEqual(date, (ZonedDateTime) value);
@@ -830,7 +829,7 @@ public class ZonedDateTimeSerTest
                 .build();
         Temporal value = mapper
                 .readerFor(Temporal.class)
-                .without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .without(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                 .readValue(
                 "[\"" + ZonedDateTime.class.getName() + "\",123456789422]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
@@ -847,7 +846,7 @@ public class ZonedDateTimeSerTest
                 .build();
         Temporal value = mapper
                 .readerFor(Temporal.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + ZonedDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
@@ -864,7 +863,7 @@ public class ZonedDateTimeSerTest
                 .build();
         Temporal value = mapper
                 .readerFor(Temporal.class)
-                .with(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .with(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + ZonedDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
@@ -880,7 +879,7 @@ public class ZonedDateTimeSerTest
                 .addMixIn(Temporal.class, MockObjectConfiguration.class)
                 .build()
                 .readerFor(Temporal.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(
                 "[\"" + ZonedDateTime.class.getName() + "\",\"" + FORMATTER.format(date) + "\"]");
         assertInstanceOf(ZonedDateTime.class, value, "The value should be an ZonedDateTime.");
@@ -897,7 +896,7 @@ public class ZonedDateTimeSerTest
         assertEquals(a2q("{'value':'1970_01_01 00:00:00(+0000)'}"), json);
 
         Wrapper result = MAPPER.readerFor(Wrapper.class)
-                .without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .without(DateTimeFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
                 .readValue(json);
         // looks like timezone gets converted (is that correct or not?); verify just offsets for now
         assertEquals(input.value.toInstant(), result.value.toInstant());
