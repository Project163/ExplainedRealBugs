diff --git a/release-notes/VERSION b/release-notes/VERSION
index d8539b70d..6213f0bfd 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -22,6 +22,7 @@ New minor version.
  (requested by thierryhenrio@github)
 #253: `DelegatingDeserializer` causes problems for Managed/BackReferences
  (reported by bfelaco@github)
+#257: Make `UntypedObjectDeserializer` support overides for `List`, `Map` etc
 #269: Add support for new `@JsonPropertyDescription` via `AnnotationIntrospector`
  as well as `BeanProperty.getMedata().getDescription()`
 #270: Add `SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID` to allow use of equality
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
index 975cfc922..ec8e7d405 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
@@ -160,12 +160,20 @@ public class UntypedObjectDeserializer
         throws IOException, JsonProcessingException
     {
         switch (jp.getCurrentToken()) {
+        case FIELD_NAME:
         case START_OBJECT:
+            if (_mapDeserializer != null) {
+                return _mapDeserializer.deserialize(jp, ctxt);
+            }
             return mapObject(jp, ctxt);
         case START_ARRAY:
+            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
+                return mapArrayToArray(jp, ctxt);
+            }
+            if (_listDeserializer != null) {
+                return _listDeserializer.deserialize(jp, ctxt);
+            }
             return mapArray(jp, ctxt);
-        case FIELD_NAME:
-            return mapObject(jp, ctxt);
         case VALUE_EMBEDDED_OBJECT:
             return jp.getEmbeddedObject();
         case VALUE_STRING:
@@ -175,6 +183,9 @@ public class UntypedObjectDeserializer
             return jp.getText();
 
         case VALUE_NUMBER_INT:
+            if (_numberDeserializer != null) {
+                return _numberDeserializer.deserialize(jp, ctxt);
+            }
             /* [JACKSON-100]: caller may want to get all integral values
              * returned as BigInteger, for consistency
              */
@@ -184,6 +195,9 @@ public class UntypedObjectDeserializer
             return jp.getNumberValue(); // should be optimal, whatever it is
 
         case VALUE_NUMBER_FLOAT:
+            if (_numberDeserializer != null) {
+                return _numberDeserializer.deserialize(jp, ctxt);
+            }
             /* [JACKSON-72]: need to allow overriding the behavior regarding
              *   which type to use
              */
@@ -233,6 +247,9 @@ public class UntypedObjectDeserializer
             return jp.getText();
 
         case VALUE_NUMBER_INT:
+            if (_numberDeserializer != null) {
+                return _numberDeserializer.deserialize(jp, ctxt);
+            }
             // For [JACKSON-100], see above:
             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {
                 return jp.getBigIntegerValue();
@@ -244,6 +261,9 @@ public class UntypedObjectDeserializer
             return jp.getNumberValue();
 
         case VALUE_NUMBER_FLOAT:
+            if (_numberDeserializer != null) {
+                return _numberDeserializer.deserialize(jp, ctxt);
+            }
             // For [JACKSON-72], see above
             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                 return jp.getDecimalValue();
@@ -276,9 +296,6 @@ public class UntypedObjectDeserializer
     protected Object mapArray(JsonParser jp, DeserializationContext ctxt)
         throws IOException, JsonProcessingException
     {
-        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
-            return mapArrayToArray(jp, ctxt);
-        }
         // Minor optimization to handle small lists (default size for ArrayList is 10)
         if (jp.nextToken()  == JsonToken.END_ARRAY) {
             return new ArrayList<Object>(4);
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
index e13decd54..e728a362e 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java
@@ -4,11 +4,14 @@ import java.io.*;
 import java.util.*;
 
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
+
 import com.fasterxml.jackson.core.*;
+
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 
@@ -51,6 +54,40 @@ public class TestUntypedDeserialization
             return value;
         }
     }
+
+    @SuppressWarnings("serial")
+    static class ListDeserializer extends StdDeserializer<List<Object>>
+    {
+        public ListDeserializer() { super(List.class); }
+
+        @Override
+        public List<Object> deserialize(JsonParser jp, DeserializationContext ctxt)
+            throws IOException
+        {
+            ArrayList<Object> list = new ArrayList<Object>();
+            while (jp.nextValue() != JsonToken.END_ARRAY) {
+                list.add("X"+jp.getText());
+            }
+            return list;
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static class MapDeserializer extends StdDeserializer<Map<String,Object>>
+    {
+        public MapDeserializer() { super(Map.class); }
+
+        @Override
+        public Map<String,Object> deserialize(JsonParser jp, DeserializationContext ctxt)
+            throws IOException
+        {
+            Map<String,Object> map = new LinkedHashMap<String,Object>();
+            while (jp.nextValue() != JsonToken.END_OBJECT) {
+                map.put(jp.getCurrentName(), "Y"+jp.getText());
+            }
+            return map;
+        }
+    }
     
     /*
     /**********************************************************
@@ -133,7 +170,7 @@ public class TestUntypedDeserialization
         assertEquals(Long.valueOf(VALUE), n);
     }
 
-    public void testUntypedWithCustomDesers() throws IOException
+    public void testUntypedWithCustomScalarDesers() throws IOException
     {
         SimpleModule m = new SimpleModule("test-module");
         m.addDeserializer(String.class, new UCStringDeserializer());
@@ -153,4 +190,36 @@ public class TestUntypedDeserialization
         assertTrue(value instanceof Number);
         assertEquals(Integer.valueOf(13), value);
     }
+
+    public void testUntypedWithListDeser() throws IOException
+    {
+        SimpleModule m = new SimpleModule("test-module");
+        m.addDeserializer(List.class, new ListDeserializer());
+        final ObjectMapper mapper = new ObjectMapper()
+            .registerModule(m);
+
+        // And then list...
+        Object ob = mapper.readValue("[1, 2, true]", Object.class);
+        assertTrue(ob instanceof List<?>);
+        List<?> l = (List<?>) ob;
+        assertEquals(3, l.size());
+        assertEquals("X1", l.get(0));
+        assertEquals("X2", l.get(1));
+        assertEquals("Xtrue", l.get(2));
+    }
+
+    public void testUntypedWithMapDeser() throws IOException
+    {
+        SimpleModule m = new SimpleModule("test-module");
+        m.addDeserializer(Map.class, new MapDeserializer());
+        final ObjectMapper mapper = new ObjectMapper()
+            .registerModule(m);
+
+        // And then list...
+        Object ob = mapper.readValue("{\"a\":true}", Object.class);
+        assertTrue(ob instanceof Map<?,?>);
+        Map<?,?> map = (Map<?,?>) ob;
+        assertEquals(1, map.size());
+        assertEquals("Ytrue", map.get("a"));
+    }
 }
