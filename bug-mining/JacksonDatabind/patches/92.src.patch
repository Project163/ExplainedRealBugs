diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5c366cf36..211a4a494 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -26,6 +26,8 @@ Project: jackson-databind
 #737: Add support for writing raw values in TokenBuffer
  (suggested by Guillaume S, gsmet@github)
 #740: Ensure proper `null` (as empty) handling for `AtomicReference`
+#741: Pass `DeserializationContext' argument for `JsonDeserializer` methods "getNullValue()"
+ and "getEmptyValue()"
 #743: Add `RawValue` helper type, for piping raw values through `TokenBuffer`
 #756: Disabling SerializationFeature.FAIL_ON_EMPTY_BEANS does not affect `canSerialize()`
  (reported by nickwongdev@github)
diff --git a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
index 66e7cd7b0..f56c53a34 100644
--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
@@ -182,10 +182,11 @@ public abstract class JsonDeserializer<T>
     public JsonDeserializer<?> replaceDelegatee(JsonDeserializer<?> delegatee) {
         throw new UnsupportedOperationException();
     }
-    
+
     /*
     /**********************************************************
-    /* Other accessors
+    /* Introspection methods for figuring out configuration/setup
+    /* of this deserializer instance and/or type it handles
     /**********************************************************
      */
 
@@ -202,34 +203,37 @@ public abstract class JsonDeserializer<T>
      * @since 2.3
      */
     public Class<?> handledType() { return null; }
-    
+
     /**
-     * Method that can be called to determine value to be used for
-     * representing null values (values deserialized when JSON token
-     * is {@link JsonToken#VALUE_NULL}). Usually this is simply
-     * Java null, but for some types (especially primitives) it may be
-     * necessary to use non-null values.
+     * Method called to see if deserializer instance is cachable and
+     * usable for other properties of same type (type for which instance
+     * was created).
      *<p>
-     * Note that deserializers are allowed to call this just once and
-     * then reuse returned value; that is, method is not guaranteed to
-     * be called once for each conversion.
+     * Note that cached instances are still resolved on per-property basis,
+     * if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
+     * cached instance is just as the base. This means that in most cases it is safe to
+     * cache instances; however, it only makes sense to cache instances
+     * if instantiation is expensive, or if instances are heavy-weight.
      *<p>
-     * Default implementation simply returns null.
+     * Default implementation returns false, to indicate that no caching
+     * is done.
      */
-    public T getNullValue() { return null; }
+    public boolean isCachable() { return false; }
 
     /**
-     * Method called to determine value to be used for "empty" values
-     * (most commonly when deserializing from empty JSON Strings).
-     * Usually this is same as {@link #getNullValue} (which in turn
-     * is usually simply Java null), but it can be overridden
-     * for types. Or, if type should never be converted from empty
-     * String, method can also throw an exception.
-     *<p>
-     * Default implementation simple calls {@link #getNullValue} and
-     * returns value.
+     * Accessor that can be used to determine if this deserializer uses
+     * another deserializer for actual deserialization, by delegating
+     * calls. If so, will return immediate delegate (which itself may
+     * delegate to further deserializers); otherwise will return null.
+     * 
+     * @return Deserializer this deserializer delegates calls to, if null;
+     *   null otherwise.
+     * 
+     * @since 2.1
      */
-    public T getEmptyValue() { return getNullValue(); }
+    public JsonDeserializer<?> getDelegatee() {
+        return null;
+    }
 
     /**
      * Method that will
@@ -246,23 +250,51 @@ public abstract class JsonDeserializer<T>
     public Collection<Object> getKnownPropertyNames() {
         return null;
     }
+
+    /*
+    /**********************************************************
+    /* Other accessors
+    /**********************************************************
+     */
     
     /**
-     * Method called to see if deserializer instance is cachable and
-     * usable for other properties of same type (type for which instance
-     * was created).
+     * Method that can be called to determine value to be used for
+     * representing null values (values deserialized when JSON token
+     * is {@link JsonToken#VALUE_NULL}). Usually this is simply
+     * Java null, but for some types (especially primitives) it may be
+     * necessary to use non-null values.
      *<p>
-     * Note that cached instances are still resolved on per-property basis,
-     * if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
-     * cached instance is just as the base. This means that in most cases it is safe to
-     * cache instances; however, it only makes sense to cache instances
-     * if instantiation is expensive, or if instances are heavy-weight.
+     * Note that deserializers are allowed to call this just once and
+     * then reuse returned value; that is, method is not guaranteed to
+     * be called once for each conversion.
      *<p>
-     * Default implementation returns false, to indicate that no caching
-     * is done.
+     * Default implementation simply returns null
+     * 
+     * @since 2.6 Added to replace earlier no-arguments variant
      */
-    public boolean isCachable() { return false; }
+    public T getNullValue(DeserializationContext ctxt) {
+        // Change the direction in 2.7
+        return getNullValue();
+    }
 
+    /**
+     * Method called to determine value to be used for "empty" values
+     * (most commonly when deserializing from empty JSON Strings).
+     * Usually this is same as {@link #getNullValue} (which in turn
+     * is usually simply Java null), but it can be overridden
+     * for types. Or, if type should never be converted from empty
+     * String, method can also throw an exception.
+     *<p>
+     * Default implementation simple calls {@link #getNullValue} and
+     * returns value.
+     * 
+     * @since 2.6 Added to replace earlier no-arguments variant
+     */
+    public T getEmptyValue(DeserializationContext ctxt) {
+        // Change the direction in 2.7
+        return getEmptyValue();
+    }
+    
     /**
      * Accessor that can be used to check whether this deserializer
      * is expecting to possibly get an Object Identifier value instead of full value
@@ -283,22 +315,6 @@ public abstract class JsonDeserializer<T>
      */
     public ObjectIdReader getObjectIdReader() { return null; }
 
-    /**
-     * Accessor that can be used to determine if this deserializer uses
-     * another deserializer for actual deserialization, by delegating
-     * calls. If so, will return immediate delegate (which itself may
-     * delegate to further deserializers); otherwise will return null.
-     * 
-     * @return Deserializer this deserializer delegates calls to, if null;
-     *   null otherwise.
-     * 
-     * @since 2.1
-     */
-    public JsonDeserializer<?> getDelegatee() {
-        return null;
-    }
-
-    
     /**
      * Method needed by {@link BeanDeserializerFactory} to properly link
      * managed- and back-reference pairs.
@@ -310,6 +326,24 @@ public abstract class JsonDeserializer<T>
         throw new IllegalArgumentException("Can not handle managed/back reference '"+refName
                 +"': type: value deserializer of type "+getClass().getName()+" does not support them");
     }
+
+    /*
+    /**********************************************************
+    /* Deprecated methods
+    /**********************************************************
+     */
+
+    /**
+     * @deprecated Since 2.6 Use overloaded variant that takes context argument
+     */
+    @Deprecated
+    public T getNullValue() { return null; }
+
+    /**
+     * @deprecated Since 2.6 Use overloaded variant that takes context argument
+     */
+    @Deprecated
+    public T getEmptyValue() { return getNullValue(); }
     
     /*
     /**********************************************************
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
index 7b93f8fe9..0fd3d5bb8 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
@@ -3335,7 +3335,7 @@ public class ObjectMapper
             JsonToken t = _initForReading(jp);
             if (t == JsonToken.VALUE_NULL) {
                 DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
-                result = _findRootDeserializer(ctxt, toValueType).getNullValue();
+                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                 result = null;
             } else { // pointing to event other than null
@@ -3585,7 +3585,7 @@ public class ObjectMapper
         if (t == JsonToken.VALUE_NULL) {
             // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:
             DeserializationContext ctxt = createDeserializationContext(jp, cfg);
-            result = _findRootDeserializer(ctxt, valueType).getNullValue();
+            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);
         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
             result = null;
         } else { // pointing to event other than null
@@ -3613,7 +3613,7 @@ public class ObjectMapper
                 // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:
                 DeserializationContext ctxt = createDeserializationContext(jp,
                         getDeserializationConfig());
-                result = _findRootDeserializer(ctxt, valueType).getNullValue();
+                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);
             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                 result = null;
             } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
index c92b5db08..836d21f61 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
@@ -1415,7 +1415,7 @@ public class ObjectReader
         if (t == JsonToken.VALUE_NULL) {
             if (valueToUpdate == null) {
                 DeserializationContext ctxt = createDeserializationContext(jp, _config);
-                result = _findRootDeserializer(ctxt, _valueType).getNullValue();
+                result = _findRootDeserializer(ctxt, _valueType).getNullValue(ctxt);
             } else {
                 result = valueToUpdate;
             }
@@ -1448,7 +1448,7 @@ public class ObjectReader
             if (t == JsonToken.VALUE_NULL) {
                 if (valueToUpdate == null) {
                     DeserializationContext ctxt = createDeserializationContext(jp, _config);
-                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();
+                    result = _findRootDeserializer(ctxt, _valueType).getNullValue(ctxt);
                 } else {
                     result = valueToUpdate;
                 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java
index 5eb265225..dd99c72f6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java
@@ -244,7 +244,10 @@ public abstract class SettableBeanProperty
             _nullProvider = null;
             _valueDeserializer = MISSING_VALUE_DESERIALIZER;
         } else {
-            Object nvl = deser.getNullValue();
+            /* 04-May-2015, tatu: Ugh. This is nasty... 
+             * !!! To be fixed ASAP
+             */
+            Object nvl = deser.getNullValue(null);
             _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl);
             _valueDeserializer = (JsonDeserializer<Object>) deser;
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java
index aa4e84912..16c8b7052 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java
@@ -99,7 +99,7 @@ public final class PropertyBasedCreator
             // [JACKSON-372]: primitive types need extra care
             // [JACKSON-774]: as do non-default nulls...
             JsonDeserializer<?> deser = prop.getValueDeserializer();
-            Object nullValue = (deser == null) ? null : deser.getNullValue();
+            Object nullValue = (deser == null) ? null : deser.getNullValue(ctxt);
             if ((nullValue == null) && prop.getType().isPrimitive()) {
                 nullValue = ClassUtil.defaultValue(prop.getType().getRawClass());
             }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java
index 55e23995c..28993ed75 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java
@@ -103,7 +103,7 @@ public class ArrayBlockingQueueDeserializer
                 Object value;
                 
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = valueDes.deserialize(jp, ctxt);
                 } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
index ffe35a46f..53b23ba96 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
@@ -42,13 +42,18 @@ public class AtomicReferenceDeserializer
     public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
         return new AtomicReferenceDeserializer(_referencedType, typeDeser, valueDeser);
     }
-    
-    // Added in 2.3
+
     @Override
-    public AtomicReference<?> getNullValue() {
+    public AtomicReference<?> getNullValue(DeserializationContext ctxt) {
         return new AtomicReference<Object>();
     }
 
+    @Deprecated // remove in 2.7
+    @Override
+    public AtomicReference<?> getNullValue() {
+        return new AtomicReference<Object>();
+    }
+    
     @Override
     public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
     {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
index 424b2decb..7c8be766a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
@@ -240,7 +240,7 @@ public class CollectionDeserializer
             try {
                 Object value;
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = valueDes.deserialize(p, ctxt);
                 } else {
@@ -295,7 +295,7 @@ public class CollectionDeserializer
 
         try {
             if (t == JsonToken.VALUE_NULL) {
-                value = valueDes.getNullValue();
+                value = valueDes.getNullValue(ctxt);
             } else if (typeDeser == null) {
                 value = valueDes.deserialize(p, ctxt);
             } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
index bdd7f724a..1067d22ce 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
@@ -8,7 +8,6 @@ import java.util.*;
 import com.fasterxml.jackson.annotation.JsonFormat;
 
 import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.core.JsonToken;
 
 import com.fasterxml.jackson.databind.BeanProperty;
@@ -142,15 +141,15 @@ public class DateDeserializers
         }
         
         @Override
-        protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)
-            throws IOException, JsonProcessingException
+        protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
+            throws IOException
         {
             if (_customFormat != null) {
-                JsonToken t = jp.getCurrentToken();
+                JsonToken t = p.getCurrentToken();
                 if (t == JsonToken.VALUE_STRING) {
-                    String str = jp.getText().trim();
+                    String str = p.getText().trim();
                     if (str.length() == 0) {
-                        return (Date) getEmptyValue();
+                        return (Date) getEmptyValue(ctxt);
                     }
                     synchronized (_customFormat) {
                         try {
@@ -163,17 +162,17 @@ public class DateDeserializers
                 }
                 // Issue#381
                 if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                    jp.nextToken();
-                    final Date parsed = _parseDate(jp, ctxt);
-                    t = jp.nextToken();
+                    p.nextToken();
+                    final Date parsed = _parseDate(p, ctxt);
+                    t = p.nextToken();
                     if (t != JsonToken.END_ARRAY) {
-                        throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                                 "Attempted to unwrap single value array for single 'java.util.Date' value but there was more than a single value in the array");
                     }            
                     return parsed;            
                 }
             }
-            return super._parseDate(jp, ctxt);
+            return super._parseDate(p, ctxt);
         }
     }
     
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java
index bb91ef11c..296795698 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java
@@ -141,11 +141,25 @@ public abstract class DelegatingDeserializer
     }
 
     @Override
+    public Object getNullValue(DeserializationContext ctxt) {
+        return _delegatee.getNullValue(ctxt);
+    }
+
+    @Override
+    public Object getEmptyValue(DeserializationContext ctxt) {
+        return _delegatee.getEmptyValue(ctxt);
+    }
+
+    @Override
+    @Deprecated // remove in 2.7
     public Object getNullValue() { return _delegatee.getNullValue(); }
 
+    // Remove in 2.7
     @Override
+    @Deprecated // remove in 2.7
     public Object getEmptyValue() { return _delegatee.getEmptyValue(); }
 
+    
     @Override
     public Collection<Object> getKnownPropertyNames() { return _delegatee.getKnownPropertyNames(); }
     
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
index 2e6ce5ff6..d4c5353a4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
@@ -158,7 +158,7 @@ public class EnumMapDeserializer
 
             try {
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value =  valueDes.deserialize(jp, ctxt);
                 } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
index 65af5fe53..2046f2d4d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
@@ -45,6 +45,12 @@ public class JsonNodeDeserializer
      */
 
     @Override
+    public JsonNode getNullValue(DeserializationContext ctxt) {
+        return NullNode.getInstance();
+    }
+
+    @Override
+    @Deprecated // since 2.6, remove from 2.7
     public JsonNode getNullValue() {
         return NullNode.getInstance();
     }
@@ -55,15 +61,15 @@ public class JsonNodeDeserializer
      * Overridden by typed sub-classes for more thorough checking
      */
     @Override
-    public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
+    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        switch (jp.getCurrentTokenId()) {
+        switch (p.getCurrentTokenId()) {
         case JsonTokenId.ID_START_OBJECT:
-            return deserializeObject(jp, ctxt, ctxt.getNodeFactory());
+            return deserializeObject(p, ctxt, ctxt.getNodeFactory());
         case JsonTokenId.ID_START_ARRAY:
-            return deserializeArray(jp, ctxt, ctxt.getNodeFactory());
+            return deserializeArray(p, ctxt, ctxt.getNodeFactory());
         default:
-            return deserializeAny(jp, ctxt, ctxt.getNodeFactory());
+            return deserializeAny(p, ctxt, ctxt.getNodeFactory());
         }
     }
 
@@ -161,19 +167,6 @@ abstract class BaseNodeDeserializer<T extends JsonNode>
         throw new JsonMappingException(msg, p.getTokenLocation());
     }
 
-    /**
-     * 
-     * @deprecated Since 2.3, use the overloaded variant
-     */
-    @Deprecated
-    protected void _handleDuplicateField(String fieldName, ObjectNode objectNode,
-                                         JsonNode oldValue, JsonNode newValue)
-        throws JsonProcessingException
-    {
-        // By default, we don't do anything
-        ;
-    }
-
     /**
      * Method called when there is a duplicate value for a field.
      * By default we don't care, and the last value is used.
@@ -197,8 +190,6 @@ abstract class BaseNodeDeserializer<T extends JsonNode>
         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {
             _reportProblem(p, "Duplicate field '"+fieldName+"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled");
         }
-        // Backwards-compatibility; call in case it's overloaded
-        _handleDuplicateField(fieldName, objectNode, oldValue, newValue);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
index 06afb221f..1aa372860 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
@@ -431,16 +431,12 @@ public class MapDeserializer
                 // Note: must handle null explicitly here; value deserializers won't
                 Object value;
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = valueDes.deserialize(p, ctxt);
                 } else {
                     value = valueDes.deserializeWithType(p, ctxt, typeDeser);
                 }
-                /* !!! 23-Dec-2008, tatu: should there be an option to verify
-                 *   that there are no duplicate field names? (and/or what
-                 *   to do, keep-first or keep-last)
-                 */
                 if (useObjectId) {
                     referringAccumulator.put(key, value);
                 } else {
@@ -494,7 +490,7 @@ public class MapDeserializer
                 // Note: must handle null explicitly here; value deserializers won't
                 Object value;
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = valueDes.deserialize(p, ctxt);
                 } else {
@@ -564,7 +560,7 @@ public class MapDeserializer
 
             try {
                 if (t == JsonToken.VALUE_NULL) {
-                    value = valueDes.getNullValue();
+                    value = valueDes.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = valueDes.deserialize(p, ctxt);
                 } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java
index e9c794941..5e03d522c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java
@@ -199,7 +199,7 @@ public class MapEntryDeserializer
         try {
             // Note: must handle null explicitly here; value deserializers won't
             if (t == JsonToken.VALUE_NULL) {
-                value = valueDes.getNullValue();
+                value = valueDes.getNullValue(ctxt);
             } else if (typeDeser == null) {
                 value = valueDes.deserialize(jp, ctxt);
             } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
index d7cc4bcfa..1dd96734a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
@@ -130,8 +130,14 @@ public class NumberDeserializers
             super(vc);
             _nullValue = nvl;
         }
-        
+
+        @Override
+        public final T getNullValue(DeserializationContext ctxt) {
+            return _nullValue;
+        }
+
         @Override
+        @Deprecated // remove in 2.7
         public final T getNullValue() {
             return _nullValue;
         }
@@ -252,7 +258,7 @@ public class NumberDeserializers
                 }
                 // actually, empty should become null?
                 if (text.length() == 0) {
-                    return (Character) getEmptyValue();
+                    return (Character) getEmptyValue(ctxt);
                 }               
                 break;
             case JsonTokenId.ID_START_ARRAY:
@@ -426,10 +432,10 @@ public class NumberDeserializers
                  */
                 String text = p.getText().trim();
                 if (text.length() == 0) {
-                    return getEmptyValue();
+                    return getEmptyValue(ctxt);
                 }
                 if (_hasTextualNull(text)) {
-                    return getNullValue();
+                    return getNullValue(ctxt);
                 }
                 if (_isPosInf(text)) {
                     return Double.POSITIVE_INFINITY;
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
index 0ff61260c..3da5c4633 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
@@ -151,7 +151,7 @@ public class ObjectArrayDeserializer
                 Object value;
                 
                 if (t == JsonToken.VALUE_NULL) {
-                    value = _elementDeserializer.getNullValue();
+                    value = _elementDeserializer.getNullValue(ctxt);
                 } else if (typeDeser == null) {
                     value = _elementDeserializer.deserialize(jp, ctxt);
                 } else {
@@ -235,7 +235,7 @@ public class ObjectArrayDeserializer
         Object value;
         
         if (t == JsonToken.VALUE_NULL) {
-            value = _elementDeserializer.getNullValue();
+            value = _elementDeserializer.getNullValue(ctxt);
         } else if (_elementTypeDeserializer == null) {
             value = _elementDeserializer.deserialize(jp, ctxt);
         } else {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
index fceac9fbc..76888bc7c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
@@ -161,10 +161,10 @@ public abstract class StdDeserializer<T>
         throw ctxt.mappingException(_valueClass, t);
     }
 
-    protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt)
+    protected final Boolean _parseBoolean(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
+        JsonToken t = p.getCurrentToken();
         if (t == JsonToken.VALUE_TRUE) {
             return Boolean.TRUE;
         }
@@ -174,17 +174,17 @@ public abstract class StdDeserializer<T>
         // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)
         if (t == JsonToken.VALUE_NUMBER_INT) {
             // 11-Jan-2012, tatus: May be outside of int...
-            if (jp.getNumberType() == NumberType.INT) {
-                return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE;
+            if (p.getNumberType() == NumberType.INT) {
+                return (p.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE;
             }
-            return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt));
+            return Boolean.valueOf(_parseBooleanFromNumber(p, ctxt));
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (Boolean) getNullValue();
+            return (Boolean) getNullValue(ctxt);
         }
         // And finally, let's allow Strings to be converted too
         if (t == JsonToken.VALUE_STRING) {
-            String text = jp.getText().trim();
+            String text = p.getText().trim();
             // [#422]: Allow aliases
             if ("true".equals(text) || "True".equals(text)) {
                 return Boolean.TRUE;
@@ -193,20 +193,20 @@ public abstract class StdDeserializer<T>
                 return Boolean.FALSE;
             }
             if (text.length() == 0) {
-                return (Boolean) getEmptyValue();
+                return (Boolean) getEmptyValue(ctxt);
             }
             if (_hasTextualNull(text)) {
-                return (Boolean) getNullValue();
+                return (Boolean) getNullValue(ctxt);
             }
             throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized");
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Boolean parsed = _parseBoolean(jp, ctxt);
-            t = jp.nextToken();
+            p.nextToken();
+            final Boolean parsed = _parseBoolean(p, ctxt);
+            t = p.nextToken();
             if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                         "Attempted to unwrap single value array for single 'Boolean' value but there was more than a single value in the array");
             }            
             return parsed;            
@@ -239,13 +239,13 @@ public abstract class StdDeserializer<T>
         if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
             String text = p.getText().trim();
             if (_hasTextualNull(text)) {
-                return (Byte) getNullValue();
+                return (Byte) getNullValue(ctxt);
             }
             int value;
             try {
                 int len = text.length();
                 if (len == 0) {
-                    return (Byte) getEmptyValue();
+                    return (Byte) getEmptyValue(ctxt);
                 }
                 value = NumberInput.parseInt(text);
             } catch (IllegalArgumentException iae) {
@@ -265,7 +265,7 @@ public abstract class StdDeserializer<T>
             return p.getByteValue();
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (Byte) getNullValue();
+            return (Byte) getNullValue(ctxt);
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
@@ -294,10 +294,10 @@ public abstract class StdDeserializer<T>
             try {
                 int len = text.length();
                 if (len == 0) {
-                    return (Short) getEmptyValue();
+                    return (Short) getEmptyValue(ctxt);
                 }
                 if (_hasTextualNull(text)) {
-                    return (Short) getNullValue();
+                    return (Short) getNullValue(ctxt);
                 }
                 value = NumberInput.parseInt(text);
             } catch (IllegalArgumentException iae) {
@@ -316,7 +316,7 @@ public abstract class StdDeserializer<T>
             return p.getShortValue();
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (Short) getNullValue();
+            return (Short) getNullValue(ctxt);
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
@@ -414,7 +414,7 @@ public abstract class StdDeserializer<T>
             try {
                 int len = text.length();
                 if (_hasTextualNull(text)) {
-                    return (Integer) getNullValue();
+                    return (Integer) getNullValue(ctxt);
                 }
                 if (len > 9) {
                     long l = Long.parseLong(text);
@@ -425,14 +425,14 @@ public abstract class StdDeserializer<T>
                     return Integer.valueOf((int) l);
                 }
                 if (len == 0) {
-                    return (Integer) getEmptyValue();
+                    return (Integer) getEmptyValue(ctxt);
                 }
                 return Integer.valueOf(NumberInput.parseInt(text));
             } catch (IllegalArgumentException iae) {
                 throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value");
             }
         case JsonTokenId.ID_NULL:
-            return (Integer) getNullValue();
+            return (Integer) getNullValue(ctxt);
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
                 p.nextToken();
@@ -465,17 +465,17 @@ public abstract class StdDeserializer<T>
             // !!! 05-Jan-2009, tatu: Should we try to limit value space, JDK is too lenient?
             String text = p.getText().trim();
             if (text.length() == 0) {
-                return (Long) getEmptyValue();
+                return (Long) getEmptyValue(ctxt);
             }
             if (_hasTextualNull(text)) {
-                return (Long) getNullValue();
+                return (Long) getNullValue(ctxt);
             }
             try {
                 return Long.valueOf(NumberInput.parseLong(text));
             } catch (IllegalArgumentException iae) { }
             throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value");
         case JsonTokenId.ID_NULL:
-            return (Long) getNullValue();
+            return (Long) getNullValue(ctxt);
         case JsonTokenId.ID_START_ARRAY:
             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
                 p.nextToken();
@@ -544,10 +544,10 @@ public abstract class StdDeserializer<T>
         if (t == JsonToken.VALUE_STRING) {
             String text = jp.getText().trim();
             if (text.length() == 0) {
-                return (Float) getEmptyValue();
+                return (Float) getEmptyValue(ctxt);
             }
             if (_hasTextualNull(text)) {
-                return (Float) getNullValue();
+                return (Float) getNullValue(ctxt);
             }
             switch (text.charAt(0)) {
             case 'I':
@@ -572,7 +572,7 @@ public abstract class StdDeserializer<T>
             throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value");
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (Float) getNullValue();
+            return (Float) getNullValue(ctxt);
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
@@ -651,10 +651,10 @@ public abstract class StdDeserializer<T>
         if (t == JsonToken.VALUE_STRING) {
             String text = jp.getText().trim();
             if (text.length() == 0) {
-                return (Double) getEmptyValue();
+                return (Double) getEmptyValue(ctxt);
             }
             if (_hasTextualNull(text)) {
-                return (Double) getNullValue();
+                return (Double) getNullValue(ctxt);
             }
             switch (text.charAt(0)) {
             case 'I':
@@ -679,7 +679,7 @@ public abstract class StdDeserializer<T>
             throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value");
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (Double) getNullValue();
+            return (Double) getNullValue(ctxt);
         }
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
             jp.nextToken();
@@ -758,7 +758,7 @@ public abstract class StdDeserializer<T>
             return new java.util.Date(jp.getLongValue());
         }
         if (t == JsonToken.VALUE_NULL) {
-            return (java.util.Date) getNullValue();
+            return (java.util.Date) getNullValue(ctxt);
         }
         if (t == JsonToken.VALUE_STRING) {
             String value = null;
@@ -766,10 +766,10 @@ public abstract class StdDeserializer<T>
                 // As per [JACKSON-203], take empty Strings to mean
                 value = jp.getText().trim();
                 if (value.length() == 0) {
-                    return (Date) getEmptyValue();
+                    return (Date) getEmptyValue(ctxt);
                 }
                 if (_hasTextualNull(value)) {
-                    return (java.util.Date) getNullValue();
+                    return (java.util.Date) getNullValue(ctxt);
                 }
                 return ctxt.parseDate(value);
             } catch (IllegalArgumentException iae) {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
index 3850b4288..b0ce95b78 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
@@ -106,7 +106,7 @@ public final class StringArrayDeserializer
                         break;
                     }
                     // Ok: no need to convert Strings, but must recognize nulls
-                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
+                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
                 } else {
                     value = deser.deserialize(jp, ctxt);
                 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
index 8b1267d23..32dfda43e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
@@ -213,7 +213,7 @@ public final class StringCollectionDeserializer
                     break;
                 }
                 // Ok: no need to convert Strings, but must recognize nulls
-                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
+                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
             } else {
                 value = deser.deserialize(jp, ctxt);
             }
@@ -246,7 +246,7 @@ public final class StringCollectionDeserializer
         String value;
         
         if (t == JsonToken.VALUE_NULL) {
-            value = (valueDes == null) ? null : valueDes.getNullValue();
+            value = (valueDes == null) ? null : valueDes.getNullValue(ctxt);
         } else {
             value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt);
         }
diff --git a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java
index 0117eef20..fec3b8390 100644
--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java
+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java
@@ -32,7 +32,7 @@ public class TestCreatorNullValue extends BaseMapTest
         }
 
         @Override
-        public Contained<?> getNullValue() {
+        public Contained<?> getNullValue(DeserializationContext ctxt) {
             return NULL_CONTAINED;
         }
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java b/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java
index b73e8c83a..fd5277c31 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java
@@ -20,7 +20,7 @@ public class TestNullHandling extends BaseMapTest
         }
 
         @Override
-        public String getNullValue() { return "funny"; }
+        public String getNullValue(DeserializationContext ctxt) { return "funny"; }
     }
 
     /*
