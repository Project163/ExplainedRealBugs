diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 6f58c770f..31dd35962 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -6,6 +6,9 @@ Project: jackson-databind
 
 2.12.3 (not yet released)
 
+#3108: `TypeFactory` cannot convert `Collection` sub-type without type parameters
+  to canonical form and back
+ (reported by lbilger@github)
 - Fix for [modules-java8#207]: prevent fail on secondary Java 8 date/time types
 
 2.12.2 (03-Mar-2021)
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
index 4f06bc788..4e4734e65 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
@@ -212,7 +212,9 @@ public class CollectionLikeType extends TypeBase
     protected String buildCanonicalName() {
         StringBuilder sb = new StringBuilder();
         sb.append(_class.getName());
-        if (_elementType != null) {
+        // 10-Apr-2021, tatu: [databind#3108] Ensure we have at least nominally
+        //   compatible type declaration (weak guarantee but better than nothing)
+        if ((_elementType != null) && _hasNTypeParameters(1)) {
             sb.append('<');
             sb.append(_elementType.toCanonical());
             sb.append('>');
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
index 3365e04c3..439fe989b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
@@ -189,7 +189,9 @@ public class MapLikeType extends TypeBase {
     protected String buildCanonicalName() {
         StringBuilder sb = new StringBuilder();
         sb.append(_class.getName());
-        if (_keyType != null) {
+        // 10-Apr-2021, tatu: [databind#3108] Ensure we have at least nominally
+        //   compatible type declaration (weak guarantee but better than nothing)
+        if ((_keyType != null) && _hasNTypeParameters(2)) {
             sb.append('<');
             sb.append(_keyType.toCanonical());
             sb.append(',');
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
index f9ac7a381..e8200237d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
@@ -164,9 +164,11 @@ public class ReferenceType extends SimpleType
     {
         StringBuilder sb = new StringBuilder();
         sb.append(_class.getName());
-        sb.append('<');
-        sb.append(_referencedType.toCanonical());
-        sb.append('>');
+        if ((_referencedType != null) && _hasNTypeParameters(1)) {
+            sb.append('<');
+            sb.append(_referencedType.toCanonical());
+            sb.append('>');
+        }
         return sb.toString();
     }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
index 9e97f75e7..e0bfd8bdd 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
@@ -219,7 +219,10 @@ public class SimpleType // note: until 2.6 was final
         sb.append(_class.getName());
 
         final int count = _bindings.size();
-        if (count > 0) {
+
+        // 10-Apr-2021, tatu: [databind#3108] Ensure we have at least nominally
+        //   compatible type declaration (weak guarantee but better than nothing)
+        if ((count > 0) && _hasNTypeParameters(count)) {
             sb.append('<');
             for (int i = 0; i < count; ++i) {
                 JavaType t = containedType(i);
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java
index a98d6ed0f..c8737da33 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java
@@ -1,6 +1,7 @@
 package com.fasterxml.jackson.databind.type;
 
 import java.io.IOException;
+import java.lang.reflect.TypeVariable;
 import java.util.*;
 
 import com.fasterxml.jackson.core.JsonGenerator;
@@ -254,4 +255,9 @@ public abstract class TypeBase
         }
         return TypeFactory.unknownType();
     }
+
+    protected boolean _hasNTypeParameters(int count) {
+        TypeVariable<?>[] params = _class.getTypeParameters();
+        return (params.length == count);
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory3108.java b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory3108.java
new file mode 100644
index 000000000..db89db854
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory3108.java
@@ -0,0 +1,53 @@
+package com.fasterxml.jackson.databind.type;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import com.fasterxml.jackson.databind.BaseMapTest;
+import com.fasterxml.jackson.databind.JavaType;
+
+// [databind#3108]: canonical type description for non-generic subtypes
+@SuppressWarnings("serial")
+public class TestTypeFactory3108
+    extends BaseMapTest
+{
+    static class StringList3108 extends ArrayList<String> {}
+
+    static class StringStringMap3108 extends HashMap<String, String> {}
+    
+    static class ParamType3108<T> {}
+
+    static class ConcreteType3108 extends ParamType3108<Integer> {}
+
+    // [databind#3108] with custom Collection
+    public void testCanonicalWithCustomCollection()
+    {
+        final TypeFactory tf = TypeFactory.defaultInstance();
+        JavaType stringListType = tf.constructType(StringList3108.class);
+        String canonical = stringListType.toCanonical();
+        JavaType type = tf.constructFromCanonical(canonical);
+        assertEquals(StringList3108.class, type.getRawClass());
+        assertTrue(type.isCollectionLikeType());
+    }
+
+    // [databind#3108] with custom Map
+    public void testCanonicalWithCustomMap()
+    {
+        final TypeFactory tf = TypeFactory.defaultInstance();
+        JavaType stringListType = tf.constructType(StringStringMap3108.class);
+        String canonical = stringListType.toCanonical();
+        JavaType type = tf.constructFromCanonical(canonical);
+        assertEquals(StringStringMap3108.class, type.getRawClass());
+        assertTrue(type.isMapLikeType());
+    }
+
+    // [databind#3108] with custom generic type
+    public void testCanonicalWithCustomGenericType()
+    {
+        final TypeFactory tf = TypeFactory.defaultInstance();
+        JavaType stringListType = tf.constructType(ConcreteType3108.class);
+        String canonical = stringListType.toCanonical();
+        JavaType type = tf.constructFromCanonical(canonical);
+        assertEquals(ConcreteType3108.class, type.getRawClass());
+    }
+}
