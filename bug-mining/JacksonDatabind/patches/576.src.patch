diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x
index 1676f352d..6b9c63374 100644
--- a/release-notes/CREDITS-2.x
+++ b/release-notes/CREDITS-2.x
@@ -1166,6 +1166,8 @@ Joshua Shannon (retrodaredevil@github)
 Daniel Hrabovcak (TheSpiritXIII@github)
   * Reported #2796: `TypeFactory.constructType()` does not take `TypeBindings` correctly
   (2.11.2)
+  * Reported #2900: Jackson does not support deserializing new Java 9 unmodifiable collections
+  (2.13.0)
 
 Lari Hotari (lhotari@github)
   * Reported #2821: Json serialization fails or a specific case that contains generics and
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 3af6670d1..f28012559 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -7,6 +7,8 @@ Project: jackson-databind
 2.13.0 (not yet released)
 
 #2828: Add `DatabindException` as intermediate subtype of `JsonMappingException`
+#2900: Jackson does not support deserializing new Java 9 unmodifiable collections
+ (reported by Daniel H)
 #3001: Add mechanism for setting default `ContextAttributes` for `ObjectMapper`
 #3002: Add `DeserializationContext.readTreeAsValue()` methods for more convenient
   conversions for deserializers to use
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
index 04e249ef3..65c231eec 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
@@ -35,54 +35,69 @@ public abstract class JavaUtilCollectionsDeserializers
 
     private final static String PREFIX_JAVA_UTIL_COLLECTIONS = "java.util.Collections$";
     private final static String PREFIX_JAVA_UTIL_ARRAYS = "java.util.Arrays$";
+    // for Java 11+ List.of(), Map.of() stuff
+    private final static String PREFIX_JAVA_UTIL_IMMUTABLE_COLL = "java.util.ImmutableCollections$";
 
     public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,
             JavaType type)
         throws JsonMappingException
     {
         final String clsName = type.getRawClass().getName();
+        if (!clsName.startsWith("java.util.")) {
+            return null;
+        }
 
         // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays`
         //    need a bit of help...
         String localName = _findUtilCollectionsTypeName(clsName);
-        if (localName == null) {
-            localName = _findUtilArrayTypeName(clsName);
-            if (localName != null) {
-                if (localName.endsWith("List")) {
-                    return new StdDelegatingDeserializer<Object>(
-                            converter(TYPE_AS_LIST, type, List.class));
+        if (localName != null) {
+            JavaUtilCollectionsConverter conv = null;
+            String name;
+    
+            if ((name = _findUnmodifiableTypeName(localName)) != null) {
+                if (name.endsWith("Set")) {
+                    conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);
+                } else if (name.endsWith("List")) {
+                    conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);
+                }
+            } else if ((name = _findSingletonTypeName(localName)) != null) {
+                if (name.endsWith("Set")) {
+                    conv = converter(TYPE_SINGLETON_SET, type, Set.class);
+                } else if (name.endsWith("List")) {
+                    conv = converter(TYPE_SINGLETON_LIST, type, List.class);
                 }
+            } else if ((name = _findSyncTypeName(localName)) != null) {
+                // [databind#3009]: synchronized, too
+                if (name.endsWith("Set")) {
+                    conv = converter(TYPE_SYNC_SET, type, Set.class);
+                } else if (name.endsWith("List")) {
+                    conv = converter(TYPE_SYNC_LIST, type, List.class);
+                } else if (name.endsWith("Collection")) {
+                    conv = converter(TYPE_SYNC_COLLECTION, type, Collection.class);
+                }
+            }
+    
+            return (conv == null) ? null : new StdDelegatingDeserializer<Object>(conv);
+        }
+        if ((localName = _findUtilArrayTypeName(clsName)) != null) {
+            // Typically ends with "List" but let's just look for it
+            if (localName.contains("List")) {
+                return new StdDelegatingDeserializer<Object>(
+                        converter(TYPE_UNMODIFIABLE_LIST, type, List.class));
             }
             return null;
         }
 
-        JavaUtilCollectionsConverter conv = null;
-        String name;
-
-        if ((name = _findUnmodifiableTypeName(localName)) != null) {
-            if (name.endsWith("Set")) {
-                conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);
-            } else if (name.endsWith("List")) {
-                conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);
-            }
-        } else if ((name = _findSingletonTypeName(localName)) != null) {
-            if (name.endsWith("Set")) {
-                conv = converter(TYPE_SINGLETON_SET, type, Set.class);
-            } else if (name.endsWith("List")) {
-                conv = converter(TYPE_SINGLETON_LIST, type, List.class);
-            }
-        } else if ((name = _findSyncTypeName(localName)) != null) {
-            // [databind#3009]: synchronized, too
-            if (name.endsWith("Set")) {
-                conv = converter(TYPE_SYNC_SET, type, Set.class);
-            } else if (name.endsWith("List")) {
-                conv = converter(TYPE_SYNC_LIST, type, List.class);
-            } else if (name.endsWith("Collection")) {
-                conv = converter(TYPE_SYNC_COLLECTION, type, Collection.class);
+        if ((localName = _findUtilCollectionsImmutableTypeName(clsName)) != null) {
+            // NOTE: names are "List12" and "ListN" but... let's just look for "List"
+            if (localName.contains("List")) {
+                return new StdDelegatingDeserializer<Object>(
+                        converter(TYPE_AS_LIST, type, List.class));
             }
+            return null;
         }
 
-        return (conv == null) ? null : new StdDelegatingDeserializer<Object>(conv);
+        return null;
     }
 
     public static JsonDeserializer<?> findForMap(DeserializationContext ctxt,
@@ -90,26 +105,29 @@ public abstract class JavaUtilCollectionsDeserializers
         throws JsonMappingException
     {
         final String clsName = type.getRawClass().getName();
-        final String localName = _findUtilCollectionsTypeName(clsName);
-        if (localName == null) {
-            return null;
-        }
-
+        String localName;
         JavaUtilCollectionsConverter conv = null;
-        String name;
 
-        if ((name = _findUnmodifiableTypeName(localName)) != null) {
-            if (name.endsWith("Map")) {
-                conv = converter(TYPE_UNMODIFIABLE_MAP, type, Map.class);
-            }
-        } else if ((name = _findSingletonTypeName(localName)) != null) {
-            if (name.endsWith("Map")) {
-                conv = converter(TYPE_SINGLETON_MAP, type, Map.class);
+        if ((localName = _findUtilCollectionsTypeName(clsName)) != null) {
+            String name;
+        
+            if ((name = _findUnmodifiableTypeName(localName)) != null) {
+                if (name.contains("Map")) {
+                    conv = converter(TYPE_UNMODIFIABLE_MAP, type, Map.class);
+                }
+            } else if ((name = _findSingletonTypeName(localName)) != null) {
+                if (name.contains("Map")) {
+                    conv = converter(TYPE_SINGLETON_MAP, type, Map.class);
+                }
+            } else if ((name = _findSyncTypeName(localName)) != null) {
+                // [databind#3009]: synchronized, too
+                if (name.contains("Map")) {
+                    conv = converter(TYPE_SYNC_MAP, type, Map.class);
+                }
             }
-        } else if ((name = _findSyncTypeName(localName)) != null) {
-            // [databind#3009]: synchronized, too
-            if (name.endsWith("Map")) {
-                conv = converter(TYPE_SYNC_MAP, type, Map.class);
+        } else if ((localName = _findUtilCollectionsImmutableTypeName(clsName)) != null) {
+            if (localName.contains("Map")) {
+                conv = converter(TYPE_UNMODIFIABLE_MAP, type, Map.class);
             }
         }
         return (conv == null) ? null : new StdDelegatingDeserializer<Object>(conv);
@@ -135,6 +153,13 @@ public abstract class JavaUtilCollectionsDeserializers
         return null;
     }
 
+    private static String _findUtilCollectionsImmutableTypeName(String clsName) {
+        if (clsName.startsWith(PREFIX_JAVA_UTIL_IMMUTABLE_COLL)) {
+            return clsName.substring(PREFIX_JAVA_UTIL_IMMUTABLE_COLL.length());
+        }
+        return null;
+    }
+
     private static String _findSingletonTypeName(String localName) {
         return localName.startsWith("Singleton") ? localName.substring(9): null;
     }
diff --git a/src/test-jdk14/java/com/fasterxml/jackson/databind/failing/Java9ListsTest.java b/src/test-jdk14/java/com/fasterxml/jackson/databind/failing/Java9ListsTest.java
index b07454310..e770b1fc7 100644
--- a/src/test-jdk14/java/com/fasterxml/jackson/databind/failing/Java9ListsTest.java
+++ b/src/test-jdk14/java/com/fasterxml/jackson/databind/failing/Java9ListsTest.java
@@ -2,6 +2,7 @@ package com.fasterxml.jackson.databind.failing;
 
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 import com.fasterxml.jackson.databind.BaseMapTest;
 import com.fasterxml.jackson.databind.ObjectMapper;
@@ -46,12 +47,41 @@ System.err.println(" final? "+type.isFinal());
          output = MAPPER.readValue(actualJson, List.class);
          assertEquals(2, output.size());
 
+         list = List.of("a", "b", "c");
+         actualJson = MAPPER.writeValueAsString(list);
+         output = MAPPER.readValue(actualJson, List.class);
+         assertEquals(3, output.size());
+         
          list = List.of();
          actualJson = MAPPER.writeValueAsString(list);
          output = MAPPER.readValue(actualJson, List.class);
          assertEquals(0, output.size());
     }
 
+    public void testJava9MapOf() throws Exception
+    {
+        Map<String,String> map = Map.of("key", "value");
+        String actualJson = MAPPER.writeValueAsString(map);
+        Map<?,?>  output = MAPPER.readValue(actualJson, Map.class);
+        assertEquals(1, output.size());
+
+        // and alternatives
+        map = Map.of("key", "value", "foo", "bar");
+        actualJson = MAPPER.writeValueAsString(map);
+        output = MAPPER.readValue(actualJson, Map.class);
+        assertEquals(2, output.size());
+
+        map = Map.of("key", "value", "foo", "bar", "last", "one");
+        actualJson = MAPPER.writeValueAsString(map);
+        output = MAPPER.readValue(actualJson, Map.class);
+        assertEquals(3, output.size());
+
+        map = Map.of();
+        actualJson = MAPPER.writeValueAsString(map);
+        output = MAPPER.readValue(actualJson, Map.class);
+        assertEquals(0, output.size());
+}
+
     public void testJava9ListWrapped() throws Exception
     {
          final List<String> list = Collections.unmodifiableList(List.of("a"));
