diff --git a/pom.xml b/pom.xml
index 4ebe4cd5a..4f8f282bf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>com.fasterxml.jackson</groupId>
     <artifactId>jackson-parent</artifactId>
-    <version>2.6.1</version>
+    <version>2.7.0-rc1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.fasterxml.jackson.core</groupId>
@@ -24,6 +24,14 @@
   </scm>
 
   <properties>
+    <!-- Sigh. Looks like we need this, for now (Jackson 2.6)
+        ... but COMPILE using Java7 JDK...
+        Why? Because it appears that otherwise we will get mysterious class load failures
+        from Mockito tests. Ugh.
+      -->
+    <javac.src.version>1.6</javac.src.version>
+    <javac.target.version>1.6</javac.target.version>
+
     <!-- Can not use default, since group id != Java package name here -->
     <osgi.export>com.fasterxml.jackson.databind.*;version=${project.version}</osgi.export>
     <!-- but imports should work fine with defaults -->
@@ -53,28 +61,22 @@
    <dependency>
       <groupId>org.powermock</groupId>
       <artifactId>powermock-module-junit4</artifactId>
-      <version>1.6.2</version>
+      <version>1.6.3</version>
       <scope>test</scope>
    </dependency>
    <dependency>
       <groupId>org.powermock</groupId>
       <artifactId>powermock-api-mockito</artifactId>
-      <version>1.6.2</version>
+      <version>1.6.3</version>
       <scope>test</scope>
    </dependency>
     <!-- For testing TestNoClassDefFoundDeserializer -->
     <dependency>
       <groupId>javax.measure</groupId>
       <artifactId>jsr-275</artifactId>
-      <version>0.9.2</version>
+      <version>1.0.0</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>18.0</version>
-        <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/release-notes/VERSION b/release-notes/VERSION
index f84c8bade..c9882ea73 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -12,6 +12,7 @@ Project: jackson-databind
 #933: Close some gaps to allow using the tryToResolveUnresolved flows
 #948: Support leap seconds, any number of millisecond digits for ISO-8601 Dates.
  (contributed by Jesse W)
+#957: Merge `datatype-jdk7` stuff in (java.nio.file.Path handling)
 
 2.6.3 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java
index ac2fa113e..7e880e3af 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java
@@ -3,6 +3,7 @@ package com.fasterxml.jackson.databind.ext;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.deser.Deserializers;
 import com.fasterxml.jackson.databind.ser.Serializers;
+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
 
 /**
  * Helper class used for isolating details of handling optional+external types
@@ -13,6 +14,8 @@ import com.fasterxml.jackson.databind.ser.Serializers;
  * certain cases. Since DOM classes are assumed to exist on all Java 1.6
  * environments (yes, even on Android/GAE), this part could be simplified by
  * slightly less dynamic lookups.
+ *<p>
+ * Also with 2.7 we are supporting JDK 1.7/Java 7 type(s).
  */
 public class OptionalHandlerFactory implements java.io.Serializable
 {
@@ -33,7 +36,9 @@ public class OptionalHandlerFactory implements java.io.Serializable
     private final static String SERIALIZER_FOR_DOM_NODE = "com.fasterxml.jackson.databind.ext.DOMSerializer";
     private final static String DESERIALIZER_FOR_DOM_DOCUMENT = "com.fasterxml.jackson.databind.ext.DOMDeserializer$DocumentDeserializer";
     private final static String DESERIALIZER_FOR_DOM_NODE = "com.fasterxml.jackson.databind.ext.DOMDeserializer$NodeDeserializer";
-    
+
+    private final static String DESERIALIZER_FOR_PATH = "com.fasterxml.jackson.databind.ext.PathDeserializer";
+
     // // Since 2.7, we will assume DOM classes are always found, both due to JDK 1.6 minimum
     // // and because Android (and presumably GAE) have these classes
 
@@ -47,11 +52,27 @@ public class OptionalHandlerFactory implements java.io.Serializable
             doc = org.w3c.dom.Document.class;
         } catch (Exception e) {
             // not optimal but will do
-            System.err.println("ERROR: could not load DOM Node and/or Document classes");
+            System.err.println("WARNING: could not load DOM Node and/or Document classes");
         }
         CLASS_DOM_NODE = node;
         CLASS_DOM_DOCUMENT = doc;
     }
+
+    // // But Java7 type(s) may or may not be; dynamic lookup should be fine, still
+    // // (note: also assume it comes from JDK so that ClassLoader issues with OSGi
+    // // can, I hope, be avoided?)
+    
+    private final static Class<?> CLASS_JAVA7_PATH;
+    static {
+        Class<?> cls = null;
+        try {
+            cls = Class.forName("java.nio.file.Path");
+        } catch (Exception e) {
+            // not optimal but will do
+            System.err.println("WARNING: could not load Java7 Path class");
+        }
+        CLASS_JAVA7_PATH = cls;
+    }
     
     public final static OptionalHandlerFactory instance = new OptionalHandlerFactory();
     
@@ -68,6 +89,9 @@ public class OptionalHandlerFactory implements java.io.Serializable
     {
         final Class<?> rawType = type.getRawClass();
 
+        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
+            return ToStringSerializer.instance;
+        }
         if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
             return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);
         }
@@ -92,6 +116,9 @@ public class OptionalHandlerFactory implements java.io.Serializable
     {
         final Class<?> rawType = type.getRawClass();
 
+        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
+            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_PATH);
+        }
         if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
             return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ext/PathDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/ext/PathDeserializer.java
new file mode 100644
index 000000000..7b910dbab
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/ext/PathDeserializer.java
@@ -0,0 +1,29 @@
+package com.fasterxml.jackson.databind.ext;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
+
+public class PathDeserializer extends StdScalarDeserializer<Path>
+{
+    private static final long serialVersionUID = 1;
+
+    public PathDeserializer() { super(Path.class); }
+    
+    @Override
+    public Path deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        JsonToken t= p.getCurrentToken();
+        if (t != null) {
+            if (t.isScalarValue()) {
+                return Paths.get(p.getValueAsString());
+            }
+            // 16-Oct-2015: should we perhaps allow JSON Arrays (of Strings) as well?
+        }
+        throw ctxt.mappingException(Path.class, t);
+    }
+}
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
index 723b65fae..dc0985d27 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
@@ -706,11 +706,11 @@ public class POJOPropertyBuilder
         }
     }
 
-    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)
+    private AnnotationMap _mergeAnnotations(int index,
+            Linked<? extends AnnotatedMember>... nodes)
     {
         AnnotationMap ann = _getAllAnnotations(nodes[index]);
-        ++index;
-        for (; index < nodes.length; ++index) {
+        while (++index < nodes.length) {
             if (nodes[index] != null) {
               return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));
             }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
index 46e725aa4..32a754266 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
@@ -49,58 +49,62 @@ public abstract class BasicSerializerFactory
      * about ClassLoader used to load them. Rather, we can just
      * use the class name, and keep things simple and efficient.
      */
-    protected final static HashMap<String, JsonSerializer<?>> _concrete =
-        new HashMap<String, JsonSerializer<?>>();
+    protected final static HashMap<String, JsonSerializer<?>> _concrete;
     
     /**
      * Actually it may not make much sense to eagerly instantiate all
      * kinds of serializers: so this Map actually contains class references,
      * not instances
      */
-    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =
-        new HashMap<String, Class<? extends JsonSerializer<?>>>();
+    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy;
     
     static {
+        HashMap<String, Class<? extends JsonSerializer<?>>> concLazy
+            = new HashMap<String, Class<? extends JsonSerializer<?>>>();
+        HashMap<String, JsonSerializer<?>> concrete
+            = new HashMap<String, JsonSerializer<?>>();
+
+        
         /* String and string-like types (note: date types explicitly
          * not included -- can use either textual or numeric serialization)
          */
-        _concrete.put(String.class.getName(), new StringSerializer());
+        concrete.put(String.class.getName(), new StringSerializer());
         final ToStringSerializer sls = ToStringSerializer.instance;
-        _concrete.put(StringBuffer.class.getName(), sls);
-        _concrete.put(StringBuilder.class.getName(), sls);
-        _concrete.put(Character.class.getName(), sls);
-        _concrete.put(Character.TYPE.getName(), sls);
+        concrete.put(StringBuffer.class.getName(), sls);
+        concrete.put(StringBuilder.class.getName(), sls);
+        concrete.put(Character.class.getName(), sls);
+        concrete.put(Character.TYPE.getName(), sls);
 
         // Primitives/wrappers for primitives (primitives needed for Beans)
-        NumberSerializers.addAll(_concrete);
-        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
-        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
+        NumberSerializers.addAll(concrete);
+        concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
+        concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
 
         // Other numbers, more complicated
-        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
-        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
+        concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
+        concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
 
         // Other discrete non-container types:
         // First, Date/Time zoo:
-        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
+        concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
         DateSerializer dateSer = DateSerializer.instance;
-        _concrete.put(java.util.Date.class.getName(), dateSer);
+        concrete.put(java.util.Date.class.getName(), dateSer);
         // note: timestamps are very similar to java.util.Date, thus serialized as such
-        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);
+        concrete.put(java.sql.Timestamp.class.getName(), dateSer);
         
         // leave some of less commonly used ones as lazy, no point in proactive construction
-        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);
-        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);
+        concLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);
+        concLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);
 
         // And then other standard non-structured JDK types
         for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {
             Object value = en.getValue();
             if (value instanceof JsonSerializer<?>) {
-                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
+                concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
             } else if (value instanceof Class<?>) {
                 @SuppressWarnings("unchecked")
                 Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;
-                _concreteLazy.put(en.getKey().getName(), cls);
+                concLazy.put(en.getKey().getName(), cls);
             } else { // should never happen, but:
                 throw new IllegalStateException("Internal error: unrecognized value of type "+en.getClass().getName());
             }
@@ -108,7 +112,10 @@ public abstract class BasicSerializerFactory
 
         // Jackson-specific type(s)
         // (Q: can this ever be sub-classed?)
-        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);
+        concLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);
+
+        _concrete = concrete;
+        _concreteLazy = concLazy;
     }
 
     /*
@@ -379,7 +386,7 @@ public abstract class BasicSerializerFactory
     {
         Class<?> raw = type.getRawClass();
         
-        // Then check for optional/external serializers [JACKSON-386]
+        // Then check for optional/external serializers 
         JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);
         if (ser != null) {
             return ser;
diff --git a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
index cb8c09f0e..d1a3e1588 100644
--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
@@ -76,7 +76,7 @@ public abstract class BaseMapTest
     {
         public List<T> list;
 
-        public ListWrapper(T... values) {
+        public ListWrapper(@SuppressWarnings("unchecked") T... values) {
             list = new ArrayList<T>();
             for (T value : values) {
                 list.add(value);
diff --git a/src/test/java/com/fasterxml/jackson/databind/ext/TestJDK16OnlyTypes.java b/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk16Types.java
similarity index 87%
rename from src/test/java/com/fasterxml/jackson/databind/ext/TestJDK16OnlyTypes.java
rename to src/test/java/com/fasterxml/jackson/databind/ext/TestJdk16Types.java
index d7197f4ff..2d1f6fcae 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestJDK16OnlyTypes.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk16Types.java
@@ -9,9 +9,9 @@ import com.fasterxml.jackson.databind.ObjectMapper;
  * Tests to ensure that we can handle 1.6-only types, even if
  * registrations are done without direct refs
  */
-public class TestJDK16OnlyTypes extends com.fasterxml.jackson.databind.BaseMapTest
+public class TestJdk16Types extends com.fasterxml.jackson.databind.BaseMapTest
 {
-    // for [Issue#216]
+    // for [databind#216]
     public void test16Types() throws Exception
     {
         final ObjectMapper mapper = new ObjectMapper();
diff --git a/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk7Types.java b/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk7Types.java
new file mode 100644
index 000000000..1b15f3347
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk7Types.java
@@ -0,0 +1,28 @@
+package com.fasterxml.jackson.databind.ext;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import com.fasterxml.jackson.databind.*;
+
+/**
+ * @since 2.7
+ */
+public class TestJdk7Types extends BaseMapTest
+{
+    public void testPathRoundtrip() throws Exception
+    {
+        ObjectMapper mapper = new ObjectMapper();
+    
+        // Start with serialization, actually
+        Path input = Paths.get("tmp", "foo.txt");
+
+        String json = mapper.writeValueAsString(input);
+        assertNotNull(json);
+        
+        Path p = mapper.readValue(json, Path.class);
+        assertNotNull(p);
+        
+        assertEquals(input.toUri(), p.toUri());
+    }
+}
