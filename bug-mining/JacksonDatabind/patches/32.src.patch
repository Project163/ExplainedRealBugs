diff --git a/release-notes/VERSION b/release-notes/VERSION
index 36c8ad850..58efe24f2 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -26,6 +26,8 @@ Version: 2.4.0 (xx-xxx-2014)
  (reported by turskip@github)
 #434: Ensure that DecimalNodes with mathematically equal values are equal
  (contributed by Francis G)
+#435: Performance bottleneck in TypeFactory._fromClass
+ (reported by sdonovanuk@github)
 
 ------------------------------------------------------------------------
 === History: ===
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
index 9759e44f7..ebeb67741 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
@@ -687,11 +687,7 @@ public final class TypeFactory
         
         // Barring that, we may have recently constructed an instance:
         ClassKey key = new ClassKey(clz);
-        JavaType result;
-        
-        synchronized (_typeCache) {
-            result = _typeCache.get(key);
-        }
+        JavaType result = _typeCache.get(key); // ok, cache object is synced
         if (result != null) {
             return result;
         }
@@ -706,15 +702,15 @@ public final class TypeFactory
         // First: do we have an array type?
         if (clz.isArray()) {
             result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);
-        /* Also: although enums can also be fully resolved, there's little
-         * point in doing so (T extends Enum<T>) etc.
-         */
+            /* Also: although enums can also be fully resolved, there's little
+             * point in doing so (T extends Enum<T>) etc.
+             */
         } else if (clz.isEnum()) {
             result = new SimpleType(clz);
-        /* Maps and Collections aren't quite as hot; problem is, due
-         * to type erasure we often do not know typing and can only assume
-         * base Object.
-         */
+            /* Maps and Collections aren't quite as hot; problem is, due
+             * to type erasure we often do not know typing and can only assume
+             * base Object.
+             */
         } else if (Map.class.isAssignableFrom(clz)) {
             result = _mapType(clz);
         } else if (Collection.class.isAssignableFrom(clz)) {
@@ -722,11 +718,7 @@ public final class TypeFactory
         } else {
             result = new SimpleType(clz);
         }
-        
-        synchronized (_typeCache) {
-            _typeCache.put(key, result);
-        }
-        
+        _typeCache.put(key, result); // cache object syncs
         return result;
     }
     
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java
index 64247c9bd..7e6eb27bb 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java
@@ -3,6 +3,8 @@ package com.fasterxml.jackson.databind.util;
 import java.io.*;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
  * Helper for simple bounded LRU maps used for reusing lookup values.
@@ -10,26 +12,75 @@ import java.util.Map;
  * Note that serialization behavior is such that contents are NOT serialized,
  * on assumption that all use cases are for caching where persistence
  * does not make sense. The only thing serialized is the cache size of Map.
+ *<p>
+ * NOTE: the only reason we extend {@link LinkedHashMap} instead of aggregating
+ * it is that this way we can override {@link #removeEldestEntry}.
+ * Access, however, MUST be done using single-element access methods (or matching
+ * <code>xxxAll()</code> methods that call them); access via iterators are not
+ * guaranteed to work.
+ *<p>
+ * NOTE: since version 2.4, uses {@link ReentrantReadWriteLock} to improve
+ * concurrent access.
  */
 public class LRUMap<K,V> extends LinkedHashMap<K,V>
     implements java.io.Serializable
 {
     private static final long serialVersionUID = 1L;
 
-    protected final int _maxEntries;
+    protected final transient Lock _readLock, _writeLock;
+    
+    protected final transient int _maxEntries;
     
     public LRUMap(int initialEntries, int maxEntries)
     {
         super(initialEntries, 0.8f, true);
         _maxEntries = maxEntries;
+        final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
+        _readLock = rwl.readLock();
+        _writeLock = rwl.writeLock();
     }
 
     @Override
-    protected boolean removeEldestEntry(Map.Entry<K,V> eldest)
-    {
+    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
         return size() > _maxEntries;
     }
 
+    /*
+    /**********************************************************
+    /* Overrides to support proper concurrency
+    /**********************************************************
+     */
+
+    @Override
+    public V get(Object key) {
+        _readLock.lock();
+        try {
+            return super.get(key);
+        } finally {
+            _readLock.unlock();
+        }
+    }
+
+    @Override
+    public V put(K key, V value) {
+        _writeLock.lock();
+        try {
+            return super.put(key, value);
+        } finally {
+            _writeLock.unlock();
+        }
+    }
+
+    @Override
+    public V remove(Object key) {
+        _writeLock.lock();
+        try {
+            return super.remove(key);
+        } finally {
+            _writeLock.unlock();
+        }
+    }
+    
     /*
     /**********************************************************
     /* Serializable overrides
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java
index 54c649b71..1901f9e32 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java
@@ -1,7 +1,6 @@
 package com.fasterxml.jackson.databind.util;
 
 import com.fasterxml.jackson.core.SerializableString;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.cfg.MapperConfig;
 import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
@@ -20,7 +19,9 @@ public class RootNameLookup implements java.io.Serializable
      */
     protected transient LRUMap<ClassKey,SerializableString> _rootNames;
 
-    public RootNameLookup() { }
+    public RootNameLookup() {
+        _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);
+   }
 
     public SerializableString findRootName(JavaType rootType, MapperConfig<?> config) {
         return findRootName(rootType.getRawClass(), config);
@@ -29,16 +30,9 @@ public class RootNameLookup implements java.io.Serializable
     public SerializableString findRootName(Class<?> rootType, MapperConfig<?> config)
     {
         ClassKey key = new ClassKey(rootType);
-
-        synchronized (this) {
-            if (_rootNames == null) {
-                _rootNames = new LRUMap<ClassKey,SerializableString>(20, 200);
-            } else {
-                SerializableString name = _rootNames.get(key);
-                if (name != null) {
-                    return name;
-                }
-            }
+        SerializableString name = _rootNames.get(key);
+        if (name != null) {
+            return name;
         }
         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);
         AnnotationIntrospector intr = config.getAnnotationIntrospector();
@@ -52,10 +46,22 @@ public class RootNameLookup implements java.io.Serializable
         } else {
             nameStr = pname.getSimpleName();
         }
-        SerializableString name = config.compileString(nameStr);
-        synchronized (this) {
-            _rootNames.put(key, name);
-        }
+        name = config.compileString(nameStr);
+        _rootNames.put(key, name);
         return name;
     }
+
+    /*
+    /**********************************************************
+    /* Serializable overrides
+    /**********************************************************
+     */
+
+    /**
+     * Need to override to reproduce cache object via constructor, instead
+     * of serialize/deserialize (since we do NOT want to retain cached data)
+     */
+    protected Object readResolve() {
+        return new RootNameLookup();
+    }
 }
