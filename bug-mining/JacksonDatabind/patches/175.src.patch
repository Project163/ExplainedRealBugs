diff --git a/release-notes/VERSION b/release-notes/VERSION
index 39420314e..1e60a8f26 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -13,8 +13,10 @@ Project: jackson-databind
  (suggested by Gregoire C, gcxRun@github)
 #1165: CoreXMLDeserializers does not handle time-only XMLGregorianCalendars
  (reported, contributed fix by Ross G)
+#1187: Refactor `AtomicReferenceDeserializer` into `ReferenceTypeDeserializer`
 
 2.7.4 (not yet released)
+
 #1178: `@JsonSerialize(contentAs=superType)` behavior disallowed in 2.7
 #1189: Converter called twice results in ClassCastException
  (reported by carrino@github)
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
index ef49f1e8f..6ea4a2b89 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
@@ -1,40 +1,22 @@
 package com.fasterxml.jackson.databind.deser.std;
 
-import java.io.IOException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import com.fasterxml.jackson.core.*;
-
 import com.fasterxml.jackson.databind.*;
-import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 
 public class AtomicReferenceDeserializer
-    extends StdDeserializer<AtomicReference<?>>
-    implements ContextualDeserializer
+    extends ReferenceTypeDeserializer<AtomicReference<Object>>
 {
     private static final long serialVersionUID = 1L;
 
-    /**
-     * Full type of property (or root value) for which this deserializer
-     * has been constructed and contextualized.
-     */
-    protected final JavaType _fullType;
-
-    protected final TypeDeserializer _valueTypeDeserializer;
-
-    protected final JsonDeserializer<?> _valueDeserializer;
-
     /*
     /**********************************************************
     /* Life-cycle
     /**********************************************************
      */
 
-    /**
-     * @param fullType Type matching this deserializer, including outer
-     *   <code>AtomicReference</code> (and not just referred type)
-     */
+    @Deprecated // since 2.8
     public AtomicReferenceDeserializer(JavaType fullType) {
         this(fullType, null, null);
     }
@@ -42,78 +24,27 @@ public class AtomicReferenceDeserializer
     public AtomicReferenceDeserializer(JavaType fullType,
             TypeDeserializer typeDeser, JsonDeserializer<?> deser)
     {
-        super(AtomicReference.class);
-        _fullType = fullType;
-        _valueDeserializer = deser;
-        _valueTypeDeserializer = typeDeser;
-    }
-
-    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
-        if ((valueDeser == _valueDeserializer) && (typeDeser == _valueTypeDeserializer)) {
-            return this;
-        }
-        return new AtomicReferenceDeserializer(_fullType, typeDeser, valueDeser);
-    }
-
-    @Override
-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
-    {
-        JsonDeserializer<?> deser = _valueDeserializer;
-        if (deser == null) {
-            deser = ctxt.findContextualValueDeserializer(_fullType.getReferencedType(), property);
-        } else { // otherwise directly assigned, probably not contextual yet:
-            deser = ctxt.handleSecondaryContextualization(deser, property, _fullType.getReferencedType());            
-        }
-        TypeDeserializer typeDeser = _valueTypeDeserializer;
-        if (typeDeser != null) {
-            typeDeser = typeDeser.forProperty(property);
-        }
-        return withResolved(typeDeser, deser);
+        super(fullType, typeDeser, deser);
     }
 
     /*
     /**********************************************************
-    /* Overridden accessors
+    /* Abstract method implementations
     /**********************************************************
      */
 
     @Override
-    public JavaType getValueType() { return _fullType; }
-    
-    @Override
-    public AtomicReference<?> getNullValue(DeserializationContext ctxt) {
-        return new AtomicReference<Object>();
+    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
+        return new AtomicReferenceDeserializer(_fullType, typeDeser, valueDeser);
     }
 
-    /*
-    /**********************************************************
-    /* Deserialization
-    /**********************************************************
-     */
-    
     @Override
-    public AtomicReference<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
-        Object contents = (_valueTypeDeserializer == null)
-                ? _valueDeserializer.deserialize(p, ctxt)
-                : _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
-        return new AtomicReference<Object>(contents);
+    public AtomicReference<Object> getNullValue(DeserializationContext ctxt) {
+        return new AtomicReference<Object>();
     }
 
     @Override
-    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
-            TypeDeserializer typeDeserializer) throws IOException
-    {
-        final JsonToken t = p.getCurrentToken();
-        if (t == JsonToken.VALUE_NULL) { // can this actually happen?
-            return getNullValue(ctxt);
-        }
-        // 22-Oct-2015, tatu: This handling is probably not needed (or is wrong), but
-        //   could be result of older (pre-2.7) Jackson trying to serialize natural types.
-        //  Because of this, let's allow for now, unless proven problematic
-        if ((t != null) && t.isScalarValue()) {
-            return deserialize(p, ctxt);
-        }
-        // andn this is what should really happen
-        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
+    public AtomicReference<Object> referenceValue(Object contents) {
+        return new AtomicReference<Object>(contents);
     }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/ReferenceTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/ReferenceTypeDeserializer.java
new file mode 100644
index 000000000..76c31466e
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ReferenceTypeDeserializer.java
@@ -0,0 +1,123 @@
+package com.fasterxml.jackson.databind.deser.std;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
+import com.fasterxml.jackson.databind.type.ReferenceType;
+
+/**
+ * Base deserializer implementation for properties {@link ReferenceType} values.
+ * Implements most of functionality, only leaving couple of abstract
+ * methods for sub-classes to implement
+ *
+ * @since 2.8
+ */
+public abstract class ReferenceTypeDeserializer<T>
+    extends StdDeserializer<T>
+    implements ContextualDeserializer
+{
+    private static final long serialVersionUID = 1L;
+    
+    /**
+     * Full type of property (or root value) for which this deserializer
+     * has been constructed and contextualized.
+     */
+    protected final JavaType _fullType;
+    
+    protected final TypeDeserializer _valueTypeDeserializer;
+    
+    protected final JsonDeserializer<?> _valueDeserializer;
+
+    /*
+    /**********************************************************
+    /* Life-cycle
+    /**********************************************************
+     */
+
+    public ReferenceTypeDeserializer(JavaType fullType,
+            TypeDeserializer typeDeser, JsonDeserializer<?> deser)
+    {
+        super(fullType);
+        _fullType = fullType;
+        _valueDeserializer = deser;
+        _valueTypeDeserializer = typeDeser;
+    }
+
+    @Override
+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
+    {
+        JsonDeserializer<?> deser = _valueDeserializer;
+        if (deser == null) {
+            deser = ctxt.findContextualValueDeserializer(_fullType.getReferencedType(), property);
+        } else { // otherwise directly assigned, probably not contextual yet:
+            deser = ctxt.handleSecondaryContextualization(deser, property, _fullType.getReferencedType());            
+        }
+        TypeDeserializer typeDeser = _valueTypeDeserializer;
+        if (typeDeser != null) {
+            typeDeser = typeDeser.forProperty(property);
+        }
+        if ((deser == _valueDeserializer) && (typeDeser == _valueTypeDeserializer)) {
+            return this;
+        }
+        return withResolved(typeDeser, deser);
+    }
+
+    /*
+    /**********************************************************
+    /* Abstract methods for sub-classes to implement
+    /**********************************************************
+     */
+
+    protected abstract ReferenceTypeDeserializer<T> withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser);
+
+    @Override
+    public abstract T getNullValue(DeserializationContext ctxt);
+
+    public abstract T referenceValue(Object contents);
+    
+    /*
+    /**********************************************************
+    /* Overridden accessors
+    /**********************************************************
+     */
+
+    @Override
+    public JavaType getValueType() { return _fullType; }
+
+    /*
+    /**********************************************************
+    /* Deserialization
+    /**********************************************************
+     */
+    
+    @Override
+    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        Object contents = (_valueTypeDeserializer == null)
+                ? _valueDeserializer.deserialize(p, ctxt)
+                : _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
+        return referenceValue(contents);
+    }
+
+    @Override
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
+            TypeDeserializer typeDeserializer) throws IOException
+    {
+        final JsonToken t = p.getCurrentToken();
+        if (t == JsonToken.VALUE_NULL) { // can this actually happen?
+            return getNullValue(ctxt);
+        }
+        // 22-Oct-2015, tatu: This handling is probably not needed (or is wrong), but
+        //   could be result of older (pre-2.7) Jackson trying to serialize natural types.
+        //  Because of this, let's allow for now, unless proven problematic
+        if ((t != null) && t.isScalarValue()) {
+            return deserialize(p, ctxt);
+        }
+        // andn this is what should really happen
+        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
+    }
+}
