diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index da23fb833..5c0f55ae2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -14,6 +14,7 @@ import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;
 import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;
 import com.fasterxml.jackson.databind.deser.impl.CreatorCandidate;
 import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;
+import com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers;
 import com.fasterxml.jackson.databind.deser.std.*;
 import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;
 import com.fasterxml.jackson.databind.introspect.*;
@@ -286,6 +287,19 @@ public abstract class BasicDeserializerFactory
         if (raw == JsonLocation.class) {
             return new JsonLocationInstantiator();
         }
+        // [databind#1868]: empty List/Set/Map
+        if (Collection.class.isAssignableFrom(raw)) {
+            if (Collections.EMPTY_SET.getClass() == raw) {
+                return new ConstantValueInstantiator(Collections.EMPTY_SET);
+            }
+            if (Collections.EMPTY_LIST.getClass() == raw) {
+                return new ConstantValueInstantiator(Collections.EMPTY_LIST);
+            }
+        } else if (Map.class.isAssignableFrom(raw)) {
+            if (Collections.EMPTY_MAP.getClass() == raw) {
+                return new ConstantValueInstantiator(Collections.EMPTY_MAP);
+            }
+        }
         return null;
     }
 
@@ -1180,6 +1194,11 @@ nonAnnotatedParamIndex, ctor);
                     if (type.hasRawClass(ArrayBlockingQueue.class)) {
                         return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);
                     }
+                    // 10-Jan-2017, tatu: `java.util.Collections` types need help:
+                    deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);
+                    if (deser != null) {
+                        return deser;
+                    }
                 }
                 // Can use more optimal deserializer if content type is String, so:
                 if (contentType.hasRawClass(String.class)) {
@@ -1319,6 +1338,12 @@ nonAnnotatedParamIndex, ctor);
                         }
                         deser = AbstractDeserializer.constructForNonPOJO(beanDesc);
                     }
+                } else {
+                    // 10-Jan-2017, tatu: `java.util.Collections` types need help:
+                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);
+                    if (deser != null) {
+                        return deser;
+                    }
                 }
                 if (deser == null) {
                     ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
index e0b992850..6dff75f82 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
@@ -104,9 +104,9 @@ public class BeanDeserializerFactory
         if (type.isThrowable()) {
             return buildThrowableDeserializer(ctxt, type, beanDesc);
         }
-        /* Or, for abstract types, may have alternate means for resolution
-         * (defaulting, materialization)
-         */
+        // Or, for abstract types, may have alternate means for resolution
+        // (defaulting, materialization)
+
         // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
         //    not something we could materialize anything for
         if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
new file mode 100644
index 000000000..c3ebb6d10
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
@@ -0,0 +1,176 @@
+package com.fasterxml.jackson.databind.deser.impl;
+
+import java.util.*;
+
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+import com.fasterxml.jackson.databind.util.Converter;
+
+/**
+ * Helper class used to contain logic for deserializing "special" containers
+ * from {@code java.util.Collections} and {@code java.util.Arrays}. This is needed
+ * because they do not have usable no-arguments constructor: however, are easy enough
+ * to deserialize using delegating deserializer.
+ *
+ * @since 2.9.4
+ */
+public abstract class JavaUtilCollectionsDeserializers
+{
+    private final static int TYPE_SINGLETON_SET = 1;
+    private final static int TYPE_SINGLETON_LIST = 2;
+    private final static int TYPE_SINGLETON_MAP = 3;
+
+    private final static int TYPE_UNMODIFIABLE_SET = 4;
+    private final static int TYPE_UNMODIFIABLE_LIST = 5;
+    private final static int TYPE_UNMODIFIABLE_MAP = 6;
+
+    public final static int TYPE_AS_LIST = 7;
+
+    // 10-Jan-2018, tatu: There are a few "well-known" special containers in JDK too:
+
+    private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass();
+
+    private final static Class<?> CLASS_SINGLETON_SET = Collections.singleton(Boolean.TRUE).getClass();
+    private final static Class<?> CLASS_SINGLETON_LIST = Collections.singletonList(Boolean.TRUE).getClass();
+    private final static Class<?> CLASS_SINGLETON_MAP = Collections.singletonMap("a", "b").getClass();
+
+    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,
+            JavaType type)
+        throws JsonMappingException
+    {
+        JavaUtilCollectionsConverter conv;
+
+        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...
+        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {
+            conv = converter(TYPE_AS_LIST, type);
+        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {
+            conv = converter(TYPE_SINGLETON_LIST, type);
+        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {
+            conv = converter(TYPE_SINGLETON_SET, type);
+        } else {
+            return null;
+        }
+        return new StdDelegatingDeserializer<Object>(conv);
+    }
+
+    public static JsonDeserializer<?> findForMap(DeserializationContext ctxt,
+            JavaType type)
+        throws JsonMappingException
+    {
+        JavaUtilCollectionsConverter conv;
+
+        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...
+        if (type.hasRawClass(CLASS_SINGLETON_MAP)) {
+            conv = converter(TYPE_SINGLETON_MAP, type);
+        } else {
+            return null;
+        }
+        return new StdDelegatingDeserializer<Object>(conv);
+    }
+    
+    static JavaUtilCollectionsConverter converter(int kind, JavaType concreteType)
+    {
+        JavaType inputType;
+
+        switch (kind) {
+        case TYPE_SINGLETON_SET:
+        case TYPE_UNMODIFIABLE_SET:
+            inputType = concreteType.findSuperType(Set.class);
+            break;
+
+        case TYPE_SINGLETON_MAP:
+        case TYPE_UNMODIFIABLE_MAP:
+            inputType = concreteType.findSuperType(Map.class);
+            break;
+
+        case TYPE_SINGLETON_LIST:
+        case TYPE_UNMODIFIABLE_LIST:
+        case TYPE_AS_LIST:
+        default:
+            inputType = concreteType.findSuperType(List.class);
+            break;
+        }
+        return new JavaUtilCollectionsConverter(kind, inputType);
+    }
+
+    /**
+     * Implementation used for converting from various generic container
+     * types ({@link java.util.Set}, {@link java.util.List}, {@link java.util.Map})
+     * into more specific implementations accessible via {@code java.util.Collections}.
+     */
+    private static class JavaUtilCollectionsConverter implements Converter<Object,Object>
+    {
+        private final JavaType _inputType;
+
+        private final int _kind;
+
+        private JavaUtilCollectionsConverter(int kind, JavaType inputType) {
+            _inputType = inputType;
+            _kind = kind;
+        }
+        
+        @Override
+        public Object convert(Object value) {
+            if (value == null) { // is this legal to get?
+                return null;
+            }
+            
+            switch (_kind) {
+            case TYPE_SINGLETON_SET:
+                {
+                    Set<?> set = (Set<?>) value;
+                    _checkSingleton(set.size());
+                    return Collections.singleton(set.iterator().next());
+                }
+            case TYPE_SINGLETON_LIST:
+                {
+                    List<?> list = (List<?>) value;
+                    _checkSingleton(list.size());
+                    return Collections.singletonList(list.get(0));
+                }
+            case TYPE_SINGLETON_MAP:
+                {
+                    Map<?,?> map = (Map<?,?>) value;
+                    _checkSingleton(map.size());
+                    Map.Entry<?,?> entry = map.entrySet().iterator().next();
+                    return Collections.singletonMap(entry.getKey(), entry.getValue());
+                }
+
+            case TYPE_UNMODIFIABLE_SET:
+                return Collections.unmodifiableSet((Set<?>) value);
+            case TYPE_UNMODIFIABLE_LIST:
+                return Collections.unmodifiableList((List<?>) value);
+            case TYPE_UNMODIFIABLE_MAP:
+                return Collections.unmodifiableMap((Map<?,?>) value);
+
+            case TYPE_AS_LIST:
+            default:
+                // Here we do not actually care about impl type, just return List as-is:
+                return value;
+            }
+        }
+
+        @Override
+        public JavaType getInputType(TypeFactory typeFactory) {
+            return _inputType;
+        }
+
+        @Override
+        public JavaType getOutputType(TypeFactory typeFactory) {
+            // we don't actually care, so:
+            return _inputType;
+        }
+
+        private void _checkSingleton(int size) {
+            if (size != 1) {
+                // not the best error ever but... has to do
+                throw new IllegalArgumentException("Can not deserialize Singleton container from "+size+" entries");
+            }
+        }
+    }
+    
+}
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
index 5e2e42789..0b7e0ed08 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java
@@ -121,7 +121,7 @@ public class StdDelegatingDeserializer<T>
     public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)
         throws JsonMappingException
     {
-        // First: if already got serializer to delegate to, contextualize it:
+        // First: if already got deserializer to delegate to, contextualize it:
         if (_delegateDeserializer != null) {
             JsonDeserializer<?> deser = ctxt.handleSecondaryContextualization(_delegateDeserializer,
                     property, _delegateType);
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java
index f882b52f2..934cdd39a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java
@@ -88,19 +88,9 @@ public class ClassNameIdResolver
                 Class<?> valueClass = Object.class;
                 // not optimal: but EnumMap is not a customizable type so this is sort of ok
                 str = typeFactory.constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();
-            } else {
-                // 17-Feb-2010, tatus: Another such case: result of Arrays.asList() is
-                // named like so in Sun JDK... Let's just plain old ArrayList in its place.
-                // ... also, other similar cases exist...
-                String suffix = str.substring(JAVA_UTIL_PKG.length());
-                if (isJavaUtilCollectionClass(suffix, "List")) {
-                    str = ArrayList.class.getName();
-                } else if (isJavaUtilCollectionClass(suffix, "Map")){
-                    str = HashMap.class.getName();
-                } else if (isJavaUtilCollectionClass(suffix, "Set")){
-                    str = HashSet.class.getName();
-                }
             }
+            // 10-Jan-2018, tatu: Up until 2.9.4 we used to have other conversions for `Collections.xxx()`
+            //    and `Arrays.asList(...)`; but it was changed to be handled on receiving end instead
         } else if (str.indexOf('$') >= 0) {
             /* Other special handling may be needed for inner classes,
              * The best way to handle would be to find 'hidden' constructor; pass parent
@@ -128,17 +118,4 @@ public class ClassNameIdResolver
     public String getDescForKnownTypeIds() {
         return "class name used as type id";
     }
-
-    private static boolean isJavaUtilCollectionClass(String clz, String type)
-    {
-        if (clz.startsWith("Collections$")) {
-            // 02-Jan-2017, tatu: As per [databind#1868], may need to leave Unmodifiable variants as is
-            return (clz.indexOf(type) > 0)
-                    && !clz.contains("Unmodifiable");
-        }
-        if (clz.startsWith("Arrays$")) {
-            return (clz.indexOf(type) > 0);
-        }
-        return false;
-    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/ConstantValueInstantiator.java b/src/main/java/com/fasterxml/jackson/databind/util/ConstantValueInstantiator.java
new file mode 100644
index 000000000..0f8abb7cb
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/util/ConstantValueInstantiator.java
@@ -0,0 +1,38 @@
+package com.fasterxml.jackson.databind.util;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.deser.ValueInstantiator;
+
+/**
+ * Trivial {@link ValueInstantiator} implementation that will simply return constant
+ * {@code Object} it is configured with. May be used as-is, or as base class to override
+ * simplistic behavior further.
+ *
+ * @since 2.9.4
+ */
+public class ConstantValueInstantiator extends ValueInstantiator
+{
+    protected final Object _value;
+
+    public ConstantValueInstantiator(Object value) {
+        _value = value;
+    }
+
+    @Override
+    public Class<?> getValueClass() {
+        return _value.getClass();
+    }
+
+    @Override // yes, since default ctor works
+    public boolean canInstantiate() { return true; }
+
+    @Override
+    public boolean canCreateUsingDefault() {  return true; }
+
+    @Override
+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException {
+        return _value;
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolverTest.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolverTest.java
deleted file mode 100644
index 3255aa569..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolverTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package com.fasterxml.jackson.databind.jsontype.impl;
-
-import static org.junit.Assert.assertEquals;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.powermock.core.classloader.annotations.PrepareForTest;
-import org.powermock.modules.junit4.PowerMockRunner;
-import com.fasterxml.jackson.databind.type.TypeFactory;
-
-import com.fasterxml.jackson.databind.JavaType;
-
-@RunWith(PowerMockRunner.class)
-@PrepareForTest(TypeFactory.class)
-public class ClassNameIdResolverTest
-{
-    @Mock
-    private JavaType javaType;
-    
-    @Mock
-    private TypeFactory typeFactory;
-
-    private ClassNameIdResolver classNameIdResolver;
-    
-    @Before
-    public void setup(){
-        this.classNameIdResolver = new ClassNameIdResolver(javaType, typeFactory);
-    }
-    
-    @Test
-    public void testShouldUseJavaUtilHashMapForSingletonMap(){
-        Map<String, String> singletonMap = Collections.singletonMap("ANY_KEY", "ANY_VALUE");
-        
-        String clazz = classNameIdResolver.idFromValue( singletonMap );
-        
-        assertEquals(clazz, "java.util.HashMap");
-    }
-    
-    @Test
-    public void testShouldUseJavaUtilHashSetForSingletonSet(){
-        Set<String> singletonSet = Collections.singleton("ANY_VALUE");
-        
-        String clazz = classNameIdResolver.idFromValue( singletonSet );
-        
-        assertEquals(clazz, "java.util.HashSet");
-    }
-    
-    @Test
-    public void testShouldUseJavaUtilArrayListForSingletonList(){
-        List<String> singletonList = Collections.singletonList("ANY_VALUE");
-        
-        String clazz = classNameIdResolver.idFromValue( singletonList );
-        
-        assertEquals(clazz, "java.util.ArrayList");
-    }
-    
-    @Test
-    public void testShouldUseJavaUtilArrayListForArraysAsList(){
-        List<String> utilList = Arrays.asList("ANY_VALUE");
-        
-        String clazz = classNameIdResolver.idFromValue( utilList );
-        
-        assertEquals(clazz, "java.util.ArrayList");
-    }
-}
diff --git a/src/test/java/com/fasterxml/jackson/failing/TestDefaultForUtilCollections1868.java b/src/test/java/com/fasterxml/jackson/failing/TestDefaultForUtilCollections1868.java
index 4dc9cd18f..cfd5ee2df 100644
--- a/src/test/java/com/fasterxml/jackson/failing/TestDefaultForUtilCollections1868.java
+++ b/src/test/java/com/fasterxml/jackson/failing/TestDefaultForUtilCollections1868.java
@@ -74,6 +74,22 @@ public class TestDefaultForUtilCollections1868 extends BaseMapTest
        _verifyMap(Collections.unmodifiableMap(input));
    }
 
+   /*
+   /**********************************************************
+   /* Unit tests, other
+   /**********************************************************
+    */
+
+   public void testArraysAsList() throws Exception
+   {
+       // Here there are no semantics to preserve, so simply check that
+       // contents remain the same
+       List<String> input = Arrays.asList("a", "bc", "def");
+       String json = DEFAULT_MAPPER.writeValueAsString(input);
+       List<?> result = DEFAULT_MAPPER.readValue(json, List.class);
+       assertEquals(input, result);
+   }
+
    /*
    /**********************************************************
    /* Helper methods
