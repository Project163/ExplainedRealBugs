diff --git a/release-notes/VERSION b/release-notes/VERSION
index dcb9cfef9..dc7b6b90e 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -1,15 +1,20 @@
 Project: jackson-databind
 Version: 2.4.1.2 (12-Jul-2014)
 
-Special one-off "micro patch" for:
-
-#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)
- (reported by fjtc@github)
+#506: Index is never set for Collection and Array in InvalidFormatException.Reference
+ (reported by Fabrice D, fabdouglas@github)
 
 ------------------------------------------------------------------------
 === History: ===
 ------------------------------------------------------------------------
 
+2.4.1.2 (12-Jul-2014)
+
+Special one-off "micro patch" for:
+
+#503: Concurrency issue inside com.fasterxml.jackson.databind.util.LRUMap.get(Object)
+ (reported by fjtc@github)
+
 2.4.1.1 (18-Jun-2014)
 
 Special one-off "micro patch" for:
diff --git a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
index 98d7bdfb4..42171a05e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
@@ -139,34 +139,16 @@ public class JsonMappingException
     /**********************************************************
      */
 
-    public JsonMappingException(String msg)
-    {
-        super(msg);
-    }
-
-    public JsonMappingException(String msg, Throwable rootCause)
-    {
-        super(msg, rootCause);
-    }
+    public JsonMappingException(String msg) { super(msg); }
+    public JsonMappingException(String msg, Throwable rootCause) { super(msg, rootCause); }
+    public JsonMappingException(String msg, JsonLocation loc) { super(msg, loc); }
+    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause) { super(msg, loc, rootCause); }
 
-    public JsonMappingException(String msg, JsonLocation loc)
-    {
-        super(msg, loc);
-    }
-
-    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause)
-    {
-        super(msg, loc, rootCause);
-    }
-
-    public static JsonMappingException from(JsonParser jp, String msg)
-    {
+    public static JsonMappingException from(JsonParser jp, String msg) {
         return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()));
     }
 
-    public static JsonMappingException from(JsonParser jp, String msg,
-            Throwable problem)
-    {
+    public static JsonMappingException from(JsonParser jp, String msg, Throwable problem) {
         return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()), problem);
     }
     
@@ -177,8 +159,7 @@ public class JsonMappingException
      * 
      * @since 2.1
      */
-    public static JsonMappingException fromUnexpectedIOE(IOException src)
-    {
+    public static JsonMappingException fromUnexpectedIOE(IOException src) {
         return new JsonMappingException("Unexpected IOException (of type "
                 +src.getClass().getName()+"): "+src.getMessage(), (JsonLocation)null, src);
     }
@@ -192,8 +173,7 @@ public class JsonMappingException
      * non-indexed object, such as a Map or POJO/bean.
      */
     public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,
-                                                    String refFieldName)
-    {
+            String refFieldName) {
         return wrapWithPath(src, new Reference(refFrom, refFieldName));
     }
 
@@ -205,9 +185,7 @@ public class JsonMappingException
      * This version of method is called when the reference is through an
      * index, which happens with arrays and Collections.
      */
-    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,
-                                                    int index)
-    {
+    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index) {
         return wrapWithPath(src, new Reference(refFrom, index));
     }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
index 06a7e4f3c..8d7ac27df 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
@@ -1407,17 +1407,15 @@ public abstract class BeanDeserializerBase
      *   {@link JsonMappingException} are to be passed as is
      *</ul>
      */
-    public void wrapAndThrow(Throwable t, Object bean, String fieldName,
-            DeserializationContext ctxt)
+    public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)
         throws IOException
     {
         // [JACKSON-55] Need to add reference information
         throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, fieldName);
     }
 
-    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)
-        throws IOException
-    {
+    @Deprecated // since 2.4, not used by core Jackson; only relevant for arrays/Collections
+    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt) throws IOException {
         // [JACKSON-55] Need to add reference information
         throw JsonMappingException.wrapWithPath(throwOrReturnThrowable(t, ctxt), bean, index);
     }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
index 4eb703574..c41f7634c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
@@ -245,6 +245,9 @@ public class CollectionDeserializer
                 }
                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);
                 reference.getRoid().appendReferring(ref);
+            } catch (Exception e) {
+                // note: pass Object.class, not Object[].class, as we need element type for error info
+                throw JsonMappingException.wrapWithPath(e, Object.class, result.size());
             }
         }
         return result;
@@ -277,13 +280,18 @@ public class CollectionDeserializer
         JsonToken t = jp.getCurrentToken();
 
         Object value;
-        
-        if (t == JsonToken.VALUE_NULL) {
-            value = valueDes.getNullValue();
-        } else if (typeDeser == null) {
-            value = valueDes.deserialize(jp, ctxt);
-        } else {
-            value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
+
+        try {
+            if (t == JsonToken.VALUE_NULL) {
+                value = valueDes.getNullValue();
+            } else if (typeDeser == null) {
+                value = valueDes.deserialize(jp, ctxt);
+            } else {
+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
+            }
+        } catch (Exception e) {
+            // note: pass Object.class, not Object[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, Object.class, result.size());
         }
         result.add(value);
         return result;
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java
index afa73763b..8fd72cf40 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java
@@ -4,7 +4,6 @@ import java.io.IOException;
 import java.util.*;
 
 import com.fasterxml.jackson.core.*;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
@@ -88,22 +87,27 @@ public class EnumSetDeserializer
         EnumSet result = constructSet();
         JsonToken t;
 
-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
-            /* What to do with nulls? Fail or ignore? Fail, for now
-             * (note: would fail if we passed it to EnumDeserializer, too,
-             * but in general nulls should never be passed to non-container
-             * deserializers)
-             */
-            if (t == JsonToken.VALUE_NULL) {
-                throw ctxt.mappingException(_enumClass);
-            }
-            Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);
-            /* 24-Mar-2012, tatu: As per [JACKSON-810], may actually get nulls;
-             *    but EnumSets don't allow nulls so need to skip.
-             */
-            if (value != null) { 
-                result.add(value);
+        try {
+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
+                /* What to do with nulls? Fail or ignore? Fail, for now
+                 * (note: would fail if we passed it to EnumDeserializer, too,
+                 * but in general nulls should never be passed to non-container
+                 * deserializers)
+                 */
+                if (t == JsonToken.VALUE_NULL) {
+                    throw ctxt.mappingException(_enumClass);
+                }
+                Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);
+                /* 24-Mar-2012, tatu: As per [JACKSON-810], may actually get nulls;
+                 *    but EnumSets don't allow nulls so need to skip.
+                 */
+                if (value != null) { 
+                    result.add(value);
+                }
             }
+        } catch (Exception e) {
+            // note: pass Object.class, not Object[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, Enum.class, result.size());
         }
         return result;
     }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
index ed5b26415..446c0ddd1 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java
@@ -4,7 +4,6 @@ import java.io.IOException;
 import java.lang.reflect.Array;
 
 import com.fasterxml.jackson.core.*;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
@@ -139,22 +138,27 @@ public class ObjectArrayDeserializer
         JsonToken t;
         final TypeDeserializer typeDeser = _elementTypeDeserializer;
 
-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
-            // Note: must handle null explicitly here; value deserializers won't
-            Object value;
-            
-            if (t == JsonToken.VALUE_NULL) {
-                value = _elementDeserializer.getNullValue();
-            } else if (typeDeser == null) {
-                value = _elementDeserializer.deserialize(jp, ctxt);
-            } else {
-                value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);
-            }
-            if (ix >= chunk.length) {
-                chunk = buffer.appendCompletedChunk(chunk);
-                ix = 0;
+        try {
+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
+                // Note: must handle null explicitly here; value deserializers won't
+                Object value;
+                
+                if (t == JsonToken.VALUE_NULL) {
+                    value = _elementDeserializer.getNullValue();
+                } else if (typeDeser == null) {
+                    value = _elementDeserializer.deserialize(jp, ctxt);
+                } else {
+                    value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);
+                }
+                if (ix >= chunk.length) {
+                    chunk = buffer.appendCompletedChunk(chunk);
+                    ix = 0;
+                }
+                chunk[ix++] = value;
             }
-            chunk[ix++] = value;
+        } catch (Exception e) {
+            // note: pass Object.class, not Object[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, Object.class, ix);
         }
 
         Object[] result;
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
index 5475ba564..be9bf4491 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
@@ -3,7 +3,6 @@ package com.fasterxml.jackson.databind.deser.std;
 import java.io.IOException;
 
 import com.fasterxml.jackson.core.*;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
@@ -53,25 +52,30 @@ public final class StringArrayDeserializer
 
         final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
         Object[] chunk = buffer.resetAndStart();
-        
+
         int ix = 0;
         JsonToken t;
-        
-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
-            // Ok: no need to convert Strings, but must recognize nulls
-            String value;
-            if (t == JsonToken.VALUE_STRING) {
-                value = jp.getText();
-            } else if (t == JsonToken.VALUE_NULL) {
-                value = null; // since we have established that '_elementDeserializer == null' earlier
-            } else {
-                value = _parseString(jp, ctxt);
-            }
-            if (ix >= chunk.length) {
-                chunk = buffer.appendCompletedChunk(chunk);
-                ix = 0;
+
+        try {
+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
+                // Ok: no need to convert Strings, but must recognize nulls
+                String value;
+                if (t == JsonToken.VALUE_STRING) {
+                    value = jp.getText();
+                } else if (t == JsonToken.VALUE_NULL) {
+                    value = null; // since we have established that '_elementDeserializer == null' earlier
+                } else {
+                    value = _parseString(jp, ctxt);
+                }
+                if (ix >= chunk.length) {
+                    chunk = buffer.appendCompletedChunk(chunk);
+                    ix = 0;
+                }
+                chunk[ix++] = value;
             }
-            chunk[ix++] = value;
+        } catch (Exception e) {
+            // note: pass String.class, not String[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, String.class, ix);
         }
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
         ctxt.returnObjectBuffer(buffer);
@@ -89,15 +93,20 @@ public final class StringArrayDeserializer
         
         int ix = 0;
         JsonToken t;
-        
-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
-            // Ok: no need to convert Strings, but must recognize nulls
-            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
-            if (ix >= chunk.length) {
-                chunk = buffer.appendCompletedChunk(chunk);
-                ix = 0;
+
+        try {
+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
+                // Ok: no need to convert Strings, but must recognize nulls
+                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
+                if (ix >= chunk.length) {
+                    chunk = buffer.appendCompletedChunk(chunk);
+                    ix = 0;
+                }
+                chunk[ix++] = value;
             }
-            chunk[ix++] = value;
+        } catch (Exception e) {
+            // note: pass String.class, not String[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, String.class, ix);
         }
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
         ctxt.returnObjectBuffer(buffer);
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
index 6baa3e3d7..fbbd3de7e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
@@ -169,16 +169,21 @@ public final class StringCollectionDeserializer
         }
         JsonToken t;
 
-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
-            String value;
-            if (t == JsonToken.VALUE_STRING) {
-                value = jp.getText();
-            } else if (t == JsonToken.VALUE_NULL) {
-                value = null;
-            } else {
-                value = _parseString(jp, ctxt);
+        try {
+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
+                String value;
+                if (t == JsonToken.VALUE_STRING) {
+                    value = jp.getText();
+                } else if (t == JsonToken.VALUE_NULL) {
+                    value = null;
+                } else {
+                    value = _parseString(jp, ctxt);
+                }
+                result.add(value);
             }
-            result.add(value);
+        } catch (Exception e) {
+            // note: pass String.class, not String[].class, as we need element type for error info
+            throw JsonMappingException.wrapWithPath(e, String.class, result.size());
         }
         return result;
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java
index 581332a0a..5075fbc7a 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java
@@ -47,6 +47,10 @@ public class TestCollectionDeserialization
     static class ListAsIterableX {
         public Iterable<XBean> nums;
     }
+
+    static class KeyListBean {
+        public List<Key> keys;
+    }
     
     /*
     /**********************************************************
@@ -196,4 +200,45 @@ public class TestCollectionDeserialization
         assertEquals(2, xb.x);
         assertFalse(it.hasNext());
     }
+
+    // for [Issue#506]
+    public void testArrayIndexForExceptions() throws Exception
+    {
+        final String OBJECTS_JSON = "[ \"KEY2\", false ]";
+        try {
+            MAPPER.readValue(OBJECTS_JSON, Key[].class);
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not deserialize");
+            List<JsonMappingException.Reference> refs = e.getPath();
+            assertEquals(1, refs.size());
+            assertEquals(1, refs.get(0).getIndex());
+        }
+
+        try {
+            MAPPER.readValue("[ \"xyz\", { } ]", String[].class);
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not deserialize");
+            List<JsonMappingException.Reference> refs = e.getPath();
+            assertEquals(1, refs.size());
+            assertEquals(1, refs.get(0).getIndex());
+        }
+
+        try {
+            MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class);
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not deserialize");
+            List<JsonMappingException.Reference> refs = e.getPath();
+            assertEquals(2, refs.size());
+            // Bean has no index, but has name:
+            assertEquals(-1, refs.get(0).getIndex());
+            assertEquals("keys", refs.get(0).getFieldName());
+
+            // and for List, reverse:
+            assertEquals(1, refs.get(1).getIndex());
+            assertNull(refs.get(1).getFieldName());
+        }
+    }
 }
