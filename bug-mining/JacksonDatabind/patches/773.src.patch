diff --git a/release-notes/VERSION b/release-notes/VERSION
index 75256bdeb..da5a07aea 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -100,6 +100,8 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #4956: Rename `JsonNode.isContainerNode()` as `isContainerNode()`
 #4958: Extend, improve set of number value accessors for `JsonNode`
   (`JsonNode.intValue()` etc) [JSTEP-3]
+#4991: Extend, improve set of non-number scalar value accessors for `JsonNode`
+  (`JsonNode.booleanValue()` etc) [JSTEP-3]
 #4992: Rename `JsonNodeFactory.textNode()` as `JsonNodeFactory.stringNode()` [JSTEP-3]
 #5004: Add `JsonMapper.builderWithJackson2Defaults()`
  (fixed by @pjfanning)
diff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java
index bc84dc4ab..1303776c6 100644
--- a/src/main/java/tools/jackson/databind/JsonNode.java
+++ b/src/main/java/tools/jackson/databind/JsonNode.java
@@ -541,18 +541,47 @@ public abstract class JsonNode
     // // Scalar access: Strings
 
     /**
-     * Method to use for accessing String values.
-     * Does <b>NOT</b> do any conversions for non-String value nodes;
-     * for non-String values (ones for which {@link #isString} returns
-     * false) null will be returned.
-     * For String values, null is never returned (but empty Strings may be)
+     * Method that will try to access value of this node as a Java {@code String}
+     * which works if (and only if) node contains JSON String value:
+     * if not, a {@link JsonNodeException} will be thrown.
+     *<p>
+     * NOTE: for more lenient conversions, use {@link #asString()}
      *<p>
      * NOTE: in Jackson 2.x, was {@code textValue()}.
      *
-     * @return String value this node contains, iff node is created from
-     *   a String value.
+     * @return {@code String} value this node represents (if JSON String)
+     *
+     * @throws JsonNodeException if node value is not a JSON String value
      */
-    public String stringValue() { return null; }
+    public abstract String stringValue();
+
+    /**
+     * Method similar to {@link #stringValue()}, but that will return specified
+     * {@code defaultValue} if this node does not contain a JSON String.
+     *
+     * @param defaultValue Value to return if this node does not contain a JSON String.
+     *
+     * @return Java {@code String} value this node represents (if JSON String);
+     *   {@code defaultValue} otherwise
+     */
+    public abstract String stringValue(String defaultValue);
+
+    /**
+     * Method similar to {@link #stringValue()}, but that will return
+     * {@code Optional.empty()} if this node does not contain a JSON String.
+     *
+     * @return {@code Optional<String>} value (if node represents JSON String);
+     *   {@code Optional.empty()} otherwise
+     */
+    public abstract Optional<String> stringValueOpt();
+
+    /**
+     * @deprecated Use {@link #asString()} instead.
+     */
+    @Deprecated // since 3.0
+    public final String textValue() {
+        return stringValue();
+    }
 
     /**
      * Method that will return a valid String representation of
@@ -595,29 +624,53 @@ public abstract class JsonNode
     // // Scalar access: Binary
 
     /**
-     * Method to use for accessing binary content of binary nodes (nodes
-     * for which {@link #isBinary} returns true); or for String Nodes
-     * (ones for which {@link #stringValue} returns non-null value),
-     * to read decoded base64 data.
-     * For other types of nodes, returns null.
+     * Method that will try to access value of this node as binary value (Java {@code byte[]})
+     * which works if (and only if) node contains binary value (for JSON, Base64-encoded
+     * String, for other formats native binary value): if not,
+     * a {@link JsonNodeException} will be thrown.
+     * To check if this method can be used, you may call {@link #isBinary()}.
+     *<p>
+     * @return Binary value this node represents (if node contains binary value)
      *
-     * @return Binary data this node contains, iff it is a binary
-     *   node; null otherwise
+     * @throws JsonNodeException if node does not contain a Binary value (a
      */
     public abstract byte[] binaryValue();
 
     // // Scalar access: Boolean
 
     /**
-     * Method to use for accessing JSON boolean values (value
-     * literals 'true' and 'false').
-     * For other types, always returns false.
+     * Method that will try to access value of this node as a Java {@code boolean}
+     * which works if (and only if) node contains JSON boolean value: if not,
+     * a {@link JsonNodeException} will be thrown.
+     *<p>
+     * NOTE: for more lenient conversions, use {@link #asBoolean()}
+     *
+     * @return {@code boolean} value this node represents (if JSON boolean)
      *
-     * @return Boolean value this node contains, if any; false for
-     *   non-boolean nodes.
+     * @throws JsonNodeException if node does not represent a JSON boolean value
      */
     public abstract boolean booleanValue();
 
+    /**
+     * Method similar to {@link #booleanValue()}, but that will return specified
+     * {@code defaultValue} if this node does not contain a JSON boolean.
+     *
+     * @param defaultValue Value to return if this node does not contain a JSON boolean.
+     *
+     * @return Java {@code boolean} value this node represents (if JSON boolean);
+     *   {@code defaultValue} otherwise
+     */
+    public abstract boolean booleanValue(boolean defaultValue);
+
+    /**
+     * Method similar to {@link #booleanValue()}, but that will return
+     * {@code Optional.empty()} if this node does not contain a JSON boolean.
+     *
+     * @return {@code Optional<Boolean>} value (if node represents JSON boolean);
+     *   {@code Optional.empty()} otherwise
+     */
+    public abstract Optional<Boolean> booleanValueOpt();
+
     /**
      * Method that will try to convert value of this node to a Java <b>boolean</b>.
      * JSON booleans map naturally; integer numbers other than 0 map to true, and
diff --git a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
index ad9754e6d..a8792ef83 100644
--- a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
+++ b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
@@ -193,12 +193,25 @@ public abstract class BaseJsonNode
 
     @Override
     public byte[] binaryValue() {
-        return null;
+        return _reportCoercionFail("binaryValue()", Boolean.TYPE,
+                "value type not binary (or convertible to binary via Base64-decoding)");
     }
 
     @Override
     public boolean booleanValue() {
-        return false;
+        return _reportCoercionFail("booleanValue()", Boolean.TYPE, "value type not boolean");
+    }
+
+    @Override
+    public boolean booleanValue(boolean defaultValue) {
+        // Overridden by BooleanNode, for other types return default
+        return defaultValue;
+    }
+
+    @Override
+    public Optional<Boolean> booleanValueOpt() {
+        // Overridden by BooleanNode, for other types return default
+        return Optional.empty();
     }
 
     @Override
@@ -211,6 +224,23 @@ public abstract class BaseJsonNode
         return defaultValue;
     }
 
+    @Override
+    public String stringValue() {
+        return _reportCoercionFail("stringValue()", String.class, "value type not String");
+    }
+
+    @Override
+    public String stringValue(String defaultValue) {
+        // Overridden by StringNode, for other types return default
+        return defaultValue;
+    }
+
+    @Override
+    public Optional<String> stringValueOpt() {
+        // Overridden by StringNode, for other types return default
+        return Optional.empty();
+    }
+
     @Override
     public String asString(String defaultValue) {
         String str = asString();
diff --git a/src/main/java/tools/jackson/databind/node/BinaryNode.java b/src/main/java/tools/jackson/databind/node/BinaryNode.java
index 2284425fc..c53e17ac8 100644
--- a/src/main/java/tools/jackson/databind/node/BinaryNode.java
+++ b/src/main/java/tools/jackson/databind/node/BinaryNode.java
@@ -87,7 +87,13 @@ public class BinaryNode
     protected String _valueDesc() {
         return "[...(" + _data.length + " bytes)]";
     }
-    
+
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access
+    /**********************************************************************
+     */
+
     /**
      *<p>
      * Note: caller is not to modify returned array in any way, since
@@ -105,6 +111,12 @@ public class BinaryNode
         return Base64Variants.getDefaultVariant().encode(_data, false);
     }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, other
+    /**********************************************************************
+     */
+
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
diff --git a/src/main/java/tools/jackson/databind/node/BooleanNode.java b/src/main/java/tools/jackson/databind/node/BooleanNode.java
index e06e18b37..31306a9a0 100644
--- a/src/main/java/tools/jackson/databind/node/BooleanNode.java
+++ b/src/main/java/tools/jackson/databind/node/BooleanNode.java
@@ -1,5 +1,7 @@
 package tools.jackson.databind.node;
 
+import java.util.Optional;
+
 import tools.jackson.core.*;
 import tools.jackson.databind.SerializationContext;
 
@@ -18,6 +20,9 @@ public class BooleanNode
     public final static BooleanNode TRUE = new BooleanNode(true);
     public final static BooleanNode FALSE = new BooleanNode(false);
 
+    private final static Optional<Boolean> OPT_FALSE = Optional.of(false);
+    private final static Optional<Boolean> OPT_TRUE = Optional.of(true);
+    
     private final boolean _value;
 
     /*
@@ -61,14 +66,25 @@ public class BooleanNode
     @Override
     public BooleanNode deepCopy() { return this; }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access
+    /**********************************************************************
+     */
+
     @Override
     public boolean booleanValue() {
         return _value;
     }
 
     @Override
-    public String asString() {
-        return _value ? "true" : "false";
+    public boolean booleanValue(boolean defaultValue) {
+        return _value;
+    }
+
+    @Override
+    public Optional<Boolean> booleanValueOpt() {
+        return _value ? OPT_TRUE : OPT_FALSE;
     }
 
     @Override
@@ -94,6 +110,17 @@ public class BooleanNode
         return _value ? 1.0 : 0.0;
     }
 
+    @Override
+    public String asString() {
+        return _value ? "true" : "false";
+    }
+
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, other
+    /**********************************************************************
+     */
+
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
             throws JacksonException {
diff --git a/src/main/java/tools/jackson/databind/node/IntNode.java b/src/main/java/tools/jackson/databind/node/IntNode.java
index 4e4cbe6b6..b51486b65 100644
--- a/src/main/java/tools/jackson/databind/node/IntNode.java
+++ b/src/main/java/tools/jackson/databind/node/IntNode.java
@@ -150,6 +150,12 @@ public class IntNode
         return _value != 0;
     }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, other
+    /**********************************************************************
+     */
+    
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
diff --git a/src/main/java/tools/jackson/databind/node/StringNode.java b/src/main/java/tools/jackson/databind/node/StringNode.java
index 4cd474e90..74adebf03 100644
--- a/src/main/java/tools/jackson/databind/node/StringNode.java
+++ b/src/main/java/tools/jackson/databind/node/StringNode.java
@@ -1,12 +1,12 @@
 package tools.jackson.databind.node;
 
 import java.util.Objects;
+import java.util.Optional;
 
 import tools.jackson.core.*;
 import tools.jackson.core.io.NumberInput;
 import tools.jackson.core.util.ByteArrayBuilder;
 import tools.jackson.databind.SerializationContext;
-import tools.jackson.databind.exc.InvalidFormatException;
 
 /**
  * Value node that contains a String value.
@@ -64,11 +64,27 @@ public class StringNode
     @Override
     public StringNode deepCopy() { return this; }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access
+    /**********************************************************************
+     */
+
     @Override
     public String stringValue() {
         return _value;
     }
 
+    @Override
+    public String stringValue(String defaultValue) {
+        return _value;
+    }
+
+    @Override
+    public Optional<String> stringValueOpt() {
+        return Optional.of(_value);
+    }
+
     /**
      * Method for accessing content String assuming they were
      * base64 encoded; if so, content is decoded and resulting binary
@@ -90,12 +106,8 @@ public class StringNode
         try {
             b64variant.decode(str, builder);
         } catch (IllegalArgumentException e) {
-            throw InvalidFormatException.from(
-                    null, /* Alas, no processor to pass */
-                    String.format(
-"Cannot access contents of `StringNode` as binary due to broken Base64 encoding: %s",
-e.getMessage()),
-                    str, byte[].class);
+            return _reportCoercionFail("binaryValue()", byte[].class,
+                    "value type not binary and Base64-decoding failed with: "+e.getMessage());
         }
         return builder.toByteArray();
     }
@@ -105,12 +117,6 @@ e.getMessage()),
         return getBinaryValue(Base64Variants.getDefaultVariant());
     }
 
-    /*
-    /**********************************************************************
-    /* General type coercions
-    /**********************************************************************
-     */
-
     @Override
     public String asString() {
         return _value;
@@ -118,21 +124,19 @@ e.getMessage()),
 
     @Override
     public String asString(String defaultValue) {
-        return (_value == null) ? defaultValue : _value;
+        return _value;
     }
 
     // note: neither fast nor elegant, but these work for now:
 
     @Override
     public boolean asBoolean(boolean defaultValue) {
-        if (_value != null) {
-            String v = _value.trim();
-            if ("true".equals(v)) {
-                return true;
-            }
-            if ("false".equals(v)) {
-                return false;
-            }
+        String v = _value.trim();
+        if ("true".equals(v)) {
+            return true;
+        }
+        if ("false".equals(v)) {
+            return false;
         }
         return defaultValue;
     }
diff --git a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
index af3337454..fc8b15c5d 100644
--- a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
+++ b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java
@@ -5,6 +5,7 @@ import java.nio.charset.StandardCharsets;
 import org.junit.jupiter.api.Test;
 
 import tools.jackson.databind.*;
+import tools.jackson.databind.exc.JsonNodeException;
 import tools.jackson.databind.exc.MismatchedInputException;
 
 import static org.junit.jupiter.api.Assertions.*;
@@ -51,8 +52,8 @@ public class Base64DecodingTest
         try {
             /*byte[] b =*/ nodeValue.binaryValue();
             fail("Should not pass");
-        } catch (MismatchedInputException e) {
-            verifyException(e, "Cannot access contents of `StringNode` as binary");
+        } catch (JsonNodeException e) {
+            verifyException(e, "method `binaryValue()` cannot convert value");
             verifyException(e, "Illegal character '!'");
         }
     }
diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
index e6430bb7b..d974c80d3 100644
--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
@@ -192,7 +192,7 @@ public class ArrayNodeTest
         assertEquals(20, array.size());
         for (int i = 0; i < 20; i++) {
             if (i <= 18) {
-                assertNotEquals("Original Data", array.get(i).stringValue());
+                assertNotEquals("Original Data", array.get(i).asString());
             } else {
                 assertEquals("Original Data", array.get(i).stringValue());
             }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java
new file mode 100644
index 000000000..8672f1c51
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java
@@ -0,0 +1,88 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.jupiter.api.Test;
+
+import tools.jackson.databind.JsonNode;
+import tools.jackson.databind.exc.JsonNodeException;
+import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.util.RawValue;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * Tests for [databind#4958], JsonNode.numberValue()
+ * over all node types.
+ */
+public class JsonNodeBooleanValueTest
+    extends DatabindTestUtil
+{
+    private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
+
+    @Test
+    public void booleanValueSuccess()
+    {
+        assertEquals(true, NODES.booleanNode(true).booleanValue());
+        assertEquals(true, NODES.booleanNode(true).booleanValue(false));
+        assertEquals(true, NODES.booleanNode(true).booleanValueOpt().get());
+        assertEquals(false, NODES.booleanNode(false).booleanValue());
+        assertEquals(false, NODES.booleanNode(false).booleanValue(true));
+        assertEquals(false, NODES.booleanNode(false).booleanValueOpt().get());
+    }
+
+    @Test
+    public void booleanValueFailFromNumbers()
+    {
+        _assertFailForNonBoolean(NODES.numberNode((byte) 1));
+        _assertFailForNonBoolean(NODES.numberNode((short) 2));
+        _assertFailForNonBoolean(NODES.numberNode(3));
+        _assertFailForNonBoolean(NODES.numberNode(4L));
+        _assertFailForNonBoolean(NODES.numberNode(BigInteger.valueOf(5)));
+
+        _assertFailForNonBoolean(NODES.numberNode(0.25f));
+        _assertFailForNonBoolean(NODES.numberNode(-2.125d));
+        _assertFailForNonBoolean(NODES.numberNode(new BigDecimal("0.1")));
+    }
+
+    @Test
+    public void booleanValueFailFromNonNumberScalars()
+    {
+        _assertFailForNonBoolean(NODES.binaryNode(new byte[3]));
+        _assertFailForNonBoolean(NODES.stringNode("123"));
+        _assertFailForNonBoolean(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailForNonBoolean(NODES.pojoNode(new AtomicInteger(1)));
+    }
+
+    @Test
+    public void numberValueFromStructural()
+    {
+        _assertFailForNonBoolean(NODES.arrayNode(3));
+        _assertFailForNonBoolean(NODES.objectNode());
+    }
+
+    @Test
+    public void numberValueFromNonNumberMisc()
+    {
+        _assertFailForNonBoolean(NODES.nullNode());
+        _assertFailForNonBoolean(NODES.missingNode());
+    }
+
+    private void _assertFailForNonBoolean(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.booleanValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not boolean");
+
+        // But also check defaulting
+        assertFalse(node.booleanValue(false));
+        assertTrue(node.booleanValue(true));
+
+        assertFalse(node.booleanValueOpt().isPresent());
+    }
+}
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java
new file mode 100644
index 000000000..91c93e08b
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java
@@ -0,0 +1,82 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.jupiter.api.Test;
+
+import tools.jackson.databind.JsonNode;
+import tools.jackson.databind.exc.JsonNodeException;
+import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.util.RawValue;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * Tests for [databind#4958], JsonNode.numberValue()
+ * over all node types.
+ */
+public class JsonNodeStringValueTest
+    extends DatabindTestUtil
+{
+    private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
+
+    @Test
+    public void stringValueSuccess()
+    {
+        assertEquals("abc", NODES.stringNode("abc").stringValue());
+        assertEquals("abc", NODES.stringNode("abc").stringValue("xyz"));
+        assertEquals("abc", NODES.stringNode("abc").stringValueOpt().get());
+    }
+
+    @Test
+    public void stringValueFailFromNumbers()
+    {
+        _assertFailForNonString(NODES.numberNode((byte) 1));
+        _assertFailForNonString(NODES.numberNode((short) 2));
+        _assertFailForNonString(NODES.numberNode(3));
+        _assertFailForNonString(NODES.numberNode(4L));
+        _assertFailForNonString(NODES.numberNode(BigInteger.valueOf(5)));
+
+        _assertFailForNonString(NODES.numberNode(0.25f));
+        _assertFailForNonString(NODES.numberNode(-2.125d));
+        _assertFailForNonString(NODES.numberNode(new BigDecimal("0.1")));
+    }
+
+    @Test
+    public void stringValueFailFromNonNumberScalars()
+    {
+        _assertFailForNonString(NODES.binaryNode(new byte[3]));
+        _assertFailForNonString(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailForNonString(NODES.pojoNode(new AtomicInteger(1)));
+    }
+
+    @Test
+    public void numberValueFromStructural()
+    {
+        _assertFailForNonString(NODES.arrayNode(3));
+        _assertFailForNonString(NODES.objectNode());
+    }
+
+    @Test
+    public void numberValueFromNonNumberMisc()
+    {
+        _assertFailForNonString(NODES.nullNode());
+        _assertFailForNonString(NODES.missingNode());
+    }
+
+    private void _assertFailForNonString(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.stringValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not String");
+
+        // But also check defaulting
+        assertEquals("foo", node.stringValue("foo"));
+        assertFalse(node.stringValueOpt().isPresent());
+    }
+}
diff --git a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
index d5b077c2a..5a43d72a4 100644
--- a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java
@@ -63,7 +63,6 @@ public class MissingNodeTest extends NodeTestBase
         assertEquals(0, onode.size());
         assertFalse(onode.isMissingNode()); // real node
         assertTrue(onode.asOptional().isPresent());
-        assertNull(onode.stringValue());
 
         // how about dereferencing?
         assertNull(onode.get(0));
diff --git a/src/test/java/tools/jackson/databind/node/NullNodeTest.java b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
index b44b405f9..80a46b319 100644
--- a/src/test/java/tools/jackson/databind/node/NullNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/NullNodeTest.java
@@ -45,7 +45,6 @@ public class NullNodeTest extends NodeTestBase
         assertFalse(n.canConvertToExactIntegral());
 
         // fallback accessors
-        assertFalse(n.booleanValue());
 
         // may be odd but...
         assertEquals("null", n.asString());
diff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
index 65ed403d6..15743f444 100644
--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
@@ -1,6 +1,5 @@
 package tools.jackson.databind.node;
 
-import java.io.IOException;
 import java.math.BigInteger;
 import java.util.*;
 
@@ -12,7 +11,7 @@ import tools.jackson.core.*;
 import tools.jackson.core.JsonParser.NumberType;
 import tools.jackson.core.exc.InputCoercionException;
 import tools.jackson.databind.*;
-import tools.jackson.databind.exc.InvalidFormatException;
+import tools.jackson.databind.exc.JsonNodeException;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 
 import static org.junit.jupiter.api.Assertions.*;
@@ -241,7 +240,8 @@ public class TreeTraversingParserTest
         assertToken(JsonToken.VALUE_STRING, p.nextToken());
         try {
             p.getBinaryValue();
-        } catch (InvalidFormatException e) {
+        } catch (JsonNodeException e) {
+            verifyException(e, "method `binaryValue()` cannot convert value");
             verifyException(e, "Illegal character");
         }
         p.close();
@@ -284,7 +284,7 @@ public class TreeTraversingParserTest
     // // // Numeric coercion checks, [databind#2189]
 
     @Test
-    public void testNumberOverflowInt() throws IOException
+    public void testNumberOverflowInt() throws Exception
     {
         final long tooBig = 1L + Integer.MAX_VALUE;
         try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse(ObjectReadContext.empty())) {
@@ -326,7 +326,7 @@ public class TreeTraversingParserTest
     }
 
     @Test
-    public void testNumberOverflowLong() throws IOException
+    public void testNumberOverflowLong() throws Exception
     {
         final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
         try (final JsonParser p = MAPPER.readTree("[ "+tooBig+" ]").traverse(ObjectReadContext.empty())) {
