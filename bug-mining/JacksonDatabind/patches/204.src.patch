diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 3e8ace67c..73dc7f1c6 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -149,6 +149,8 @@ Benson Margulies:
    (2.6.6)
   * Reported, fixed #1235: `java.nio.file.Path` support incomplete
    (2.8.0)
+  * Reported #1270: Generic type returned from type id resolver seems to be ignored
+   (2.8.0)
 
 Steve Sanbeg: (sanbeg@github)
   * Contributed #482: Make date parsing error behavior consistent with JDK
diff --git a/release-notes/VERSION b/release-notes/VERSION
index ff609bdf2..e1a9635b4 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -47,6 +47,8 @@ Project: jackson-databind
  (reported by, fix contributed by Benson M)
 #1261: JsonIdentityInfo broken deserialization involving forward references and/or cycles
  (reported by, fix contributed by Ari F)
+#1270: Generic type returned from type id resolver seems to be ignored
+ (reported by Benson M)
 
 2.7.5 (11-Jun-2016)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
index 7b851bb18..6ad5079e1 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
@@ -53,7 +53,7 @@ public class ExternalTypeHandler
      * containing POJO has similarly named property as the external type id;
      * otherwise {@link #handlePropertyValue} should be called instead.
      */
-    public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,
+    public boolean handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,
             String propName, Object bean)
         throws IOException
     {
@@ -66,12 +66,12 @@ public class ExternalTypeHandler
         if (!prop.hasTypePropertyName(propName)) {
             return false;
         }
-        String typeId = jp.getText();
+        String typeId = p.getText();
         // note: can NOT skip child values (should always be String anyway)
         boolean canDeserialize = (bean != null) && (_tokens[index] != null);
         // Minor optimization: deserialize properties as soon as we have all we need:
         if (canDeserialize) {
-            _deserializeAndSet(jp, ctxt, bean, index, typeId);
+            _deserializeAndSet(p, ctxt, bean, index, typeId);
             // clear stored data, to avoid deserializing+setting twice:
             _tokens[index] = null;
         } else {
@@ -173,7 +173,7 @@ public class ExternalTypeHandler
      * Variant called when creation of the POJO involves buffering of creator properties
      * as well as property-based creator.
      */
-    public Object complete(JsonParser jp, DeserializationContext ctxt,
+    public Object complete(JsonParser p, DeserializationContext ctxt,
             PropertyValueBuffer buffer, PropertyBasedCreator creator)
         throws IOException
     {
@@ -200,7 +200,7 @@ public class ExternalTypeHandler
                 ctxt.reportMappingException("Missing property '%s' for external type id '%s'",
                         prop.getName(), _properties[i].getTypePropertyName());
             }
-            values[i] = _deserialize(jp, ctxt, i, typeId);
+            values[i] = _deserialize(p, ctxt, i, typeId);
         }
         // second: fill in creator properties:
         for (int i = 0; i < len; ++i) {
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
index 770b71b2d..3fbd0a44b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
@@ -557,7 +557,7 @@ public class BasicBeanDescription extends BeanDescription
         if ("valueOf".equals(name)) {
             return true;
         }
-        // [Issue#208] Also accept "fromString()", if takes String or CharSequence
+        // [databind#208] Also accept "fromString()", if takes String or CharSequence
         if ("fromString".equals(name)) {
             if (1 == am.getParameterCount()) {
                 Class<?> cls = am.getRawParameterType(0);
@@ -569,6 +569,10 @@ public class BasicBeanDescription extends BeanDescription
         return false;
     }
 
+    /**
+     * @deprecated since 2.8
+     */
+    @Deprecated // since 2.8, not used at least since 2.7
     protected PropertyName _findCreatorPropertyName(AnnotatedParameter param)
     {
         PropertyName name = _annotationIntrospector.findNameForDeserialization(param);
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
index 98197be7c..cd9b15554 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
@@ -177,7 +177,13 @@ public abstract class TypeDeserializerBase
                      *   important for some reason?
                      *   Disabling the check will break 2 Enum-related tests.
                      */
-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
+                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full
+                    //   generic type with custom type resolvers. If so, should try to retain them.
+                    //  Whether this is sufficient to avoid problems remains to be seen, but for
+                    //  now it should improve things.
+                    if (!type.hasGenericTypes()) {
+                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());
+                    }
                 }
                 deser = ctxt.findContextualValueDeserializer(type, _property);
             }
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
index 8fa9bd77f..25ebfd571 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
@@ -5,7 +5,7 @@ import java.util.*;
 import com.fasterxml.jackson.annotation.*;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
-
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
 import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
@@ -102,7 +102,71 @@ public class TestCustomTypeIdResolver extends BaseMapTest
             return "xxx";
         }
     }
-    
+
+    // for [databind#1270]
+    static class Top1270 {
+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
+                include = JsonTypeInfo.As.PROPERTY,
+                property = "type")
+        @JsonTypeIdResolver(Resolver1270.class)
+        public Base1270<?> b;
+    }
+
+    static class Base1270<O extends Poly1Base> {
+        public O options;
+        public String val;
+    }
+
+    static abstract class Poly1Base { }
+
+    static class Poly1 extends Poly1Base {
+        public String val;
+    }
+
+    static class Resolver1270 implements TypeIdResolver {
+        public Resolver1270() { }
+
+        @Override
+        public void init(JavaType baseType) { }
+     
+        @Override
+        public String idFromValue(Object value) {
+            if (value.getClass() == Base1270.class) {
+                return "poly1";
+            }
+            return null;
+        }
+
+        @Override
+        public String idFromValueAndType(Object value, Class<?> suggestedType) {
+            return idFromValue(value);
+        }
+
+        @Override
+        public String idFromBaseType() {
+            return null;
+        }
+
+        @Override
+        public JavaType typeFromId(DatabindContext context, String id) {
+            if ("poly1".equals(id)) {
+                return context.getTypeFactory()
+                        .constructType(new TypeReference<Base1270<Poly1>>() { });
+            }
+            return null;
+        }
+
+        @Override
+        public String getDescForKnownTypeIds() {
+            return null;
+        }
+
+        @Override
+        public JsonTypeInfo.Id getMechanism() {
+            return JsonTypeInfo.Id.CUSTOM;
+        }
+    }
+
     /*
     /**********************************************************
     /* Unit tests
@@ -110,8 +174,7 @@ public class TestCustomTypeIdResolver extends BaseMapTest
      */
 
     private final ObjectMapper MAPPER = objectMapper();
-    
-    // for [JACKSON-359]
+
     public void testCustomTypeIdResolver() throws Exception
     {
         List<JavaType> types = new ArrayList<JavaType>();
@@ -143,4 +206,25 @@ public class TestCustomTypeIdResolver extends BaseMapTest
         
         assertEquals(12, ((ExtBeanImpl) out.value).y);
     }
+
+    // for [databind#1270]
+    public void testPolymorphicTypeViaCustom() throws Exception {
+        Base1270<Poly1> req = new Base1270<Poly1>();
+        Poly1 o = new Poly1();
+        o.val = "optionValue";
+        req.options = o;
+        req.val = "some value";
+        Top1270 top = new Top1270();
+        top.b = req;
+        String json = MAPPER.writeValueAsString(top);
+        JsonNode tree = MAPPER.readTree(json);
+        assertNotNull(tree.get("b"));
+        assertNotNull(tree.get("b").get("options"));
+        assertNotNull(tree.get("b").get("options").get("val"));
+
+        // Can we reverse the process? I have some doubts
+        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);
+        assertNotNull(itemRead);
+        assertNotNull(itemRead.b);
+    }
 }
