diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 63a76de2d..6f7eb0bad 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -25,6 +25,7 @@ Project: jackson-databind
  (reported by Deniz H)
 #3476: Implement `JsonNodeFeature.WRITE_NULL_PROPERTIES` to allow skipping
   JSON `null` values on writing
+#3497: Deserialization of Throwables with PropertyNamingStrategy does not work
 
 2.13.4 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index 9231bbf8f..e8ca72191 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -2125,7 +2125,7 @@ factory.toString()));
         if (deser != null) {
             return deser;
         }
-        return JdkDeserializers.find(rawType, clsName);
+        return JdkDeserializers.find(ctxt, rawType, clsName);
     }
 
     protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
index bad4d12bf..313c3a3f1 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
@@ -437,8 +437,14 @@ ClassUtil.name(propName)));
         }
         AnnotatedMethod am = beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS);
         if (am != null) { // should never be null
+            // [databind#3497]: must consider possible PropertyNamingStrategy
+            String name = "cause";
+            PropertyNamingStrategy pts = config.getPropertyNamingStrategy();
+            if (pts != null) {
+                name = pts.nameForSetterMethod(config, am, "cause");
+            }
             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,
-                    new PropertyName("cause"));
+                    new PropertyName(name));
             SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,
                     am.getParameterType(0));
             if (prop != null) {
@@ -447,16 +453,6 @@ ClassUtil.name(propName)));
                 builder.addOrReplaceProperty(prop, true);
             }
         }
-
-        // And also need to ignore "localizedMessage"
-        builder.addIgnorable("localizedMessage");
-        // Java 7 also added "getSuppressed", skip if we have such data:
-        builder.addIgnorable("suppressed");
-        // As well as "message": it will be passed via constructor,
-        // as there's no 'setMessage()' method
-        // 23-Jan-2018, tatu: ... although there MAY be Creator Property... which is problematic
-//        builder.addIgnorable("message");
-
         // update builder now that all information is in?
         if (_factoryConfig.hasDeserializerModifiers()) {
             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
@@ -468,7 +464,7 @@ ClassUtil.name(propName)));
         // At this point it ought to be a BeanDeserializer; if not, must assume
         // it's some other thing that can handle deserialization ok...
         if (deserializer instanceof BeanDeserializer) {
-            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);
+            deserializer = ThrowableDeserializer.construct(ctxt, (BeanDeserializer) deserializer);
         }
 
         // may have modifier(s) that wants to modify or replace serializer we just built:
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java
index 670a9a52d..8250befaf 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java
@@ -30,7 +30,22 @@ public class JdkDeserializers
         for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }
     }
 
+    /**
+     * @deprecated Since 2.14 use the variant that takes one more argument
+     */
+    @Deprecated // since 2.14
     public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
+        throws JsonMappingException
+    {
+        return find(null, rawType, clsName);
+    }
+
+    /**
+     * @since 2.14
+     */
+    public static JsonDeserializer<?> find(DeserializationContext ctxt,
+            Class<?> rawType, String clsName)
+        throws JsonMappingException
     {
         if (_classNames.contains(clsName)) {
             JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
@@ -41,7 +56,7 @@ public class JdkDeserializers
                 return new UUIDDeserializer();
             }
             if (rawType == StackTraceElement.class) {
-                return new StackTraceElementDeserializer();
+                return StackTraceElementDeserializer.construct(ctxt);
             }
             if (rawType == AtomicBoolean.class) {
                 return new AtomicBooleanDeserializer();
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java
index 55532feb9..e48f62eb6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StackTraceElementDeserializer.java
@@ -7,60 +7,54 @@ import com.fasterxml.jackson.core.JsonToken;
 
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
 
 public class StackTraceElementDeserializer
     extends StdScalarDeserializer<StackTraceElement>
 {
     private static final long serialVersionUID = 1L;
 
-    public StackTraceElementDeserializer() { super(StackTraceElement.class); }
+    protected final JsonDeserializer<?> _adapterDeserializer;
+
+    @Deprecated // since 2.14
+    public StackTraceElementDeserializer() {
+        this(null);
+    }
+
+    protected StackTraceElementDeserializer(JsonDeserializer<?> ad)
+    {
+        super(StackTraceElement.class);
+        _adapterDeserializer = ad;
+    }
+     
+    /**
+     * @since 2.14
+     */
+    public static JsonDeserializer<?> construct(DeserializationContext ctxt) throws JsonMappingException {
+        // 26-May-2022, tatu: for legacy use, need to do this:
+        if (ctxt == null) {
+            return new StackTraceElementDeserializer();
+        }
+        JsonDeserializer<?> adapterDeser = ctxt.findNonContextualValueDeserializer(ctxt.constructType(Adapter.class));
+        return new StackTraceElementDeserializer(adapterDeser);
+    }
 
     @Override
     public StackTraceElement deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         JsonToken t = p.currentToken();
-        // Must get an Object
-        if (t == JsonToken.START_OBJECT) {
-            String className = "", methodName = "", fileName = "";
-            // Java 9 adds couple more things
-            String moduleName = null, moduleVersion = null;
-            String classLoaderName = null;
-            int lineNumber = -1;
 
-            while ((t = p.nextValue()) != JsonToken.END_OBJECT) {
-                String propName = p.currentName();
-                // TODO: with Java 8, convert to switch
-                if ("className".equals(propName)) {
-                    className = p.getText();
-                } else if ("classLoaderName".equals(propName)) {
-                    classLoaderName = p.getText();
-                } else if ("fileName".equals(propName)) {
-                    fileName = p.getText();
-                } else if ("lineNumber".equals(propName)) {
-                    if (t.isNumeric()) {
-                        lineNumber = p.getIntValue();
-                    } else {
-                        lineNumber = _parseIntPrimitive(p, ctxt);
-                    }
-                } else if ("methodName".equals(propName)) {
-                    methodName = p.getText();
-                } else if ("nativeMethod".equals(propName)) {
-                    // no setter, not passed via constructor: ignore
-                } else if ("moduleName".equals(propName)) {
-                    moduleName = p.getText();
-                } else if ("moduleVersion".equals(propName)) {
-                    moduleVersion = p.getText();
-                } else if ("declaringClass".equals(propName)
-                        || "format".equals(propName)) {
-                    // 01-Nov-2017: [databind#1794] Not sure if we should but... let's prune it for now
-                    ;
-                } else {
-                    handleUnknownProperty(p, ctxt, _valueClass, propName);
-                }
-                p.skipChildren(); // just in case we might get structured values
+        // Must get an Object
+        if (t == JsonToken.START_OBJECT || t == JsonToken.FIELD_NAME) {
+            Adapter adapted;
+            // 26-May-2022, tatu: for legacy use, need to do this:
+            if (_adapterDeserializer == null) {
+                adapted = ctxt.readValue(p, Adapter.class);
+            } else {
+                adapted = (Adapter) _adapterDeserializer.deserialize(p, ctxt);
             }
-            return constructValue(ctxt, className, methodName, fileName, lineNumber,
-                    moduleName, moduleVersion, classLoaderName);
+            return constructValue(ctxt, adapted);
         } else if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
             p.nextToken();
             final StackTraceElement value = deserialize(p, ctxt);
@@ -72,6 +66,18 @@ public class StackTraceElementDeserializer
         return (StackTraceElement) ctxt.handleUnexpectedToken(_valueClass, p);
     }
 
+    /**
+     * @since 2.14
+     */
+    protected StackTraceElement constructValue(DeserializationContext ctxt,
+            Adapter adapted)
+    {
+        return constructValue(ctxt, adapted.className, adapted.methodName,
+                adapted.fileName, adapted.lineNumber,
+                adapted.moduleName, adapted.moduleVersion,
+                adapted.classLoaderName);
+    }
+
     @Deprecated // since 2.9
     protected StackTraceElement constructValue(DeserializationContext ctxt,
             String className, String methodName, String fileName, int lineNumber,
@@ -89,8 +95,24 @@ public class StackTraceElementDeserializer
             String className, String methodName, String fileName, int lineNumber,
             String moduleName, String moduleVersion, String classLoaderName)
     {
-        // 21-May-2016, tatu: With Java 9, need to use different constructor, probably
+        // 21-May-2016, tatu: With Java 9, could use different constructor, probably
         //   via different module, and throw exception here if extra args passed
         return new StackTraceElement(className, methodName, fileName, lineNumber);
     }
+
+    /**
+     * Intermediate class used both for convenience of binding and
+     * to support {@code PropertyNamingStrategy}.
+     *
+     * @since 2.14
+     */
+    public final static class Adapter {
+        // NOTE: some String fields must not be nulls
+        public String className = "", classLoaderName;
+        public String declaringClass, format;
+        public String fileName = "", methodName = "";
+        public int lineNumber = -1;
+        public String moduleName, moduleVersion;
+        public boolean nativeMethod;
+    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java
index ef66a83e7..5ca7b7d0a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java
@@ -1,6 +1,7 @@
 package com.fasterxml.jackson.databind.deser.std;
 
 import java.io.IOException;
+import java.util.Iterator;
 
 import com.fasterxml.jackson.core.*;
 
@@ -14,25 +15,43 @@ import com.fasterxml.jackson.databind.util.NameTransformer;
  * override some aspects like instance construction.
  */
 public class ThrowableDeserializer
-    extends BeanDeserializer
+    extends BeanDeserializer // not the greatest idea but...
 {
     private static final long serialVersionUID = 1L;
 
     protected final static String PROP_NAME_MESSAGE = "message";
     protected final static String PROP_NAME_SUPPRESSED = "suppressed";
 
+    protected final static String PROP_NAME_LOCALIZED_MESSAGE = "localizedMessage";
+
     /*
     /**********************************************************************
     /* Life-cycle
     /**********************************************************************
      */
 
+    @Deprecated // since 2.14
     public ThrowableDeserializer(BeanDeserializer baseDeserializer) {
         super(baseDeserializer);
         // need to disable this, since we do post-processing
         _vanillaProcessing = false;
     }
 
+    public static ThrowableDeserializer construct(DeserializationContext ctxt,
+            BeanDeserializer baseDeserializer)
+    {
+        // 27-May-2022, tatu: TODO -- handle actual renaming of fields to support
+        //    strategies like kebab- and snake-case where there are changes beyond
+        //    simple upper-/lower-casing
+        /*
+        PropertyNamingStrategy pts = ctxt.getConfig().getPropertyNamingStrategy();
+        if (pts != null) {
+        }
+        */
+        return new ThrowableDeserializer(baseDeserializer);
+    }
+    
+    
     /**
      * Alternative constructor used when creating "unwrapping" deserializers
      */
@@ -106,14 +125,16 @@ public class ThrowableDeserializer
             }
 
             // Maybe it's "message"?
-            if (PROP_NAME_MESSAGE.equals(propName)) {
+
+            // 26-May-2022, tatu: [databind#3497] To support property naming strategies,
+            //    should ideally mangle property names. But for now let's cheat; works
+            //    for case-changing although not for kebab/snake cases and "localizedMessage"
+            if (PROP_NAME_MESSAGE.equalsIgnoreCase(propName)) {
                 if (hasStringCreator) {
                     throwable = (Throwable) _valueInstantiator.createFromString(ctxt, p.getValueAsString());
                     continue;
                 }
-            } else if (PROP_NAME_SUPPRESSED.equals(propName)) { // or "suppressed"?
-                suppressed = ctxt.readValue(p, Throwable[].class);
-                continue;
+                // fall through
             }
 
             // Things marked as ignorable should not be passed to any setter
@@ -121,10 +142,19 @@ public class ThrowableDeserializer
                 p.skipChildren();
                 continue;
             }
+            if (PROP_NAME_SUPPRESSED.equalsIgnoreCase(propName)) { // or "suppressed"?
+                suppressed = ctxt.readValue(p, Throwable[].class);
+                continue;
+            }
+            if (PROP_NAME_LOCALIZED_MESSAGE.equalsIgnoreCase(propName)) {
+                p.skipChildren();
+                continue;
+            }
             if (_anySetter != null) {
                 _anySetter.deserializeAndSet(p, ctxt, throwable, propName);
                 continue;
             }
+
             // 23-Jan-2018, tatu: One concern would be `message`, but without any-setter or single-String-ctor
             //   (or explicit constructor). We could just ignore it but for now, let it fail
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/exc/ExceptionDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/exc/ExceptionDeserializationTest.java
index 035ce89dc..b575b4902 100644
--- a/src/test/java/com/fasterxml/jackson/databind/exc/ExceptionDeserializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/exc/ExceptionDeserializationTest.java
@@ -73,8 +73,13 @@ public class ExceptionDeserializationTest
         MyException result = MAPPER.readValue(json, MyException.class);
         assertEquals(MSG, result.getMessage());
         assertEquals(3, result.value);
-        assertEquals(1, result.stuff.size());
+
+        // 27-May-2022, tatu: With [databind#3497] we actually get 3, not 1
+        //    "extra" things exposed
+        assertEquals(3, result.stuff.size());
         assertEquals(result.getFoo(), result.stuff.get("foo"));
+        assertEquals("the message", result.stuff.get("localizedMessage"));
+        assertTrue(result.stuff.containsKey("suppressed"));
     }
 
     public void testWithNullMessage() throws IOException
@@ -245,4 +250,32 @@ public class ExceptionDeserializationTest
         assertNull(exc.getMessage());
         assertNull(exc.getLocalizedMessage());
     }
+
+    // [databind#3497]: round-trip with naming strategy
+    public void testRoundtripWithoutNamingStrategy() throws Exception
+    {
+        _testRoundtripWith(MAPPER);
+    }
+
+    public void testRoundtripWithNamingStrategy() throws Exception
+    {
+        final ObjectMapper renamingMapper = JsonMapper.builder()
+                .propertyNamingStrategy(PropertyNamingStrategies.UPPER_CAMEL_CASE)
+                .build();
+        _testRoundtripWith(renamingMapper);
+    }
+
+    private void _testRoundtripWith(ObjectMapper mapper) throws Exception
+    {
+        Exception root = new Exception("Root cause");
+        Exception leaf = new Exception("Leaf message", root);
+
+        final String json = mapper.writerWithDefaultPrettyPrinter()
+                .writeValueAsString(leaf);
+        Exception result = mapper.readValue(json, Exception.class);
+
+        assertEquals(leaf.getMessage(), result.getMessage());
+        assertNotNull(result.getCause());
+        assertEquals(root.getMessage(), result.getCause().getMessage());
+    }
 }
