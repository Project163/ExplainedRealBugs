diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 7a4312eac..cc23c36b2 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -614,3 +614,8 @@ Emiliano Clari√° (emilianogc@github)
 Ana Eliza Barbosa (AnaEliza@github)
   * Contributed #1520: Case insensitive enum deserialization feature.
    (2.9.0)
+
+Lyor Goldstein (lgoldstein@github)
+  * Reported #1544: `EnumMapDeserializer` assumes a pure `EnumMap` and does not support
+    derived classes
+   (2.9.0)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 7ffdac286..a61bdf3f2 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -55,6 +55,8 @@ Project: jackson-databind
 #1474: Replace use of `Class.newInstance()` (deprecated in Java 9) with call via Constructor
 #1520: Case insensitive enum deserialization feature.
  (contributed by Ana-Eliza B)
+#1544: EnumMapDeserializer assumes a pure EnumMap and does not support EnumMap derived classes
+ (reported by Lyor G)
 
 2.8.8 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
index 6c418fe61..20c30bcf9 100644
--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
@@ -302,7 +302,6 @@ public abstract class JsonDeserializer<T>
      *
      * @since 2.9
      */
-//    public abstract AccessPattern getEmptyAccessPattern();
     public AccessPattern getEmptyAccessPattern() {
         return AccessPattern.DYNAMIC;
     }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index eed5afa55..608cf5aae 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -237,22 +237,21 @@ public abstract class BasicDeserializerFactory
         final DeserializationConfig config = ctxt.getConfig();
 
         ValueInstantiator instantiator = null;
-        // [JACKSON-633] Check @JsonValueInstantiator before anything else
+        // Check @JsonValueInstantiator before anything else
         AnnotatedClass ac = beanDesc.getClassInfo();
         Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);
         if (instDef != null) {
             instantiator = _valueInstantiatorInstance(config, ac, instDef);
         }
         if (instantiator == null) {
-            /* Second: see if some of standard Jackson/JDK types might provide value
-             * instantiators.
-             */
+            // Second: see if some of standard Jackson/JDK types might provide value
+            // instantiators.
             instantiator = _findStdValueInstantiator(config, beanDesc);
             if (instantiator == null) {
                 instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);
             }
         }
-        
+
         // finally: anyone want to modify ValueInstantiator?
         if (_factoryConfig.hasValueInstantiators()) {
             for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {
@@ -1126,11 +1125,21 @@ public abstract class BasicDeserializerFactory
             // Value handling is identical for all, but EnumMap requires special handling for keys
             Class<?> mapClass = type.getRawClass();
             if (EnumMap.class.isAssignableFrom(mapClass)) {
+                ValueInstantiator inst;
+
+                // 06-Mar-2017, tatu: Should only need to check ValueInstantiator for
+                //    custom sub-classes, see [databind#1544]
+                if (mapClass == EnumMap.class) {
+                    inst = null;
+                } else {
+                    inst = findValueInstantiator(ctxt, beanDesc);
+                }
                 Class<?> kt = keyType.getRawClass();
                 if (kt == null || !kt.isEnum()) {
                     throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available");
                 }
-                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser, null);
+                deser = new EnumMapDeserializer(type, inst, null,
+                        contentDeser, contentTypeDeser, null);
             }
 
             // Otherwise, generic handler works ok.
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
index e9a86ccab..03a4c560a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java
@@ -7,7 +7,13 @@ import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.deser.NullValueProvider;
+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;
+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
+import com.fasterxml.jackson.databind.deser.ValueInstantiator;
+import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;
+import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
+import com.fasterxml.jackson.databind.util.ClassUtil;
 
 /**
  * Deserializer for {@link EnumMap} values.
@@ -18,7 +24,7 @@ import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 @SuppressWarnings({ "unchecked", "rawtypes" }) 
 public class EnumMapDeserializer
     extends ContainerDeserializerBase<EnumMap<?,?>>
-    implements ContextualDeserializer
+    implements ContextualDeserializer, ResolvableDeserializer
 {
     private static final long serialVersionUID = 1;
 
@@ -33,7 +39,28 @@ public class EnumMapDeserializer
      * is the type deserializer that can handle it
      */
     protected final TypeDeserializer _valueTypeDeserializer;
+
+    // // Instance construction settings:
     
+    /**
+     * @since 2.9
+     */
+    protected final ValueInstantiator _valueInstantiator;
+
+    /**
+     * Deserializer that is used iff delegate-based creator is
+     * to be used for deserializing from JSON Object.
+     */
+    protected JsonDeserializer<Object> _delegateDeserializer;
+
+    /**
+     * If the Map is to be instantiated using non-default constructor
+     * or factory method
+     * that takes one or more named properties as argument(s),
+     * this creator is used for instantiation.
+     */
+    protected PropertyBasedCreator _propertyBasedCreator;    
+
     /*
     /**********************************************************
     /* Life-cycle
@@ -43,8 +70,8 @@ public class EnumMapDeserializer
     /**
      * @since 2.9
      */
-    public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeser,
-            JsonDeserializer<?> valueDeser, TypeDeserializer vtd,
+    public EnumMapDeserializer(JavaType mapType, ValueInstantiator valueInst,
+            KeyDeserializer keyDeser, JsonDeserializer<?> valueDeser, TypeDeserializer vtd,
             NullValueProvider nuller)
     {
         super(mapType, nuller, null);
@@ -52,13 +79,32 @@ public class EnumMapDeserializer
         _keyDeserializer = keyDeser;
         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;
         _valueTypeDeserializer = vtd;
+        _valueInstantiator = valueInst;
+    }
+
+    /**
+     * @since 2.9
+     */
+    protected EnumMapDeserializer(EnumMapDeserializer base,
+            KeyDeserializer keyDeser, JsonDeserializer<?> valueDeser, TypeDeserializer vtd,
+            NullValueProvider nuller)
+    {
+        super(base, nuller, base._unwrapSingle);
+        _enumClass = base._enumClass;
+        _keyDeserializer = keyDeser;
+        _valueDeserializer = (JsonDeserializer<Object>) valueDeser;
+        _valueTypeDeserializer = vtd;
+
+        _valueInstantiator = base._valueInstantiator;
+        _delegateDeserializer = base._delegateDeserializer;
+        _propertyBasedCreator = base._propertyBasedCreator;
     }
 
     @Deprecated // since 2.9
     public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeser,
             JsonDeserializer<?> valueDeser, TypeDeserializer vtd)
     {
-        this(mapType, keyDeser, valueDeser, vtd, null);
+        this(mapType, null, keyDeser, valueDeser, vtd, null);
     }
     
     public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer,
@@ -69,10 +115,51 @@ public class EnumMapDeserializer
                 && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {
             return this;
         }
-        return new EnumMapDeserializer(_containerType, keyDeserializer,
-                valueDeserializer, _valueTypeDeserializer, nuller);
+        return new EnumMapDeserializer(this,
+                keyDeserializer, valueDeserializer, valueTypeDeser, nuller);
     }
+
+    /*
+    /**********************************************************
+    /* Validation, post-processing (ResolvableDeserializer)
+    /**********************************************************
+     */
     
+    @Override
+    public void resolve(DeserializationContext ctxt) throws JsonMappingException
+    {
+        // May need to resolve types for delegate- and/or property-based creators:
+        if (_valueInstantiator != null) {
+            if (_valueInstantiator.canCreateUsingDelegate()) {
+                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
+                if (delegateType == null) {
+                    ctxt.reportBadDefinition(_containerType, String.format(
+"Invalid delegate-creator definition for %s: value instantiator (%s) returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'",
+                            _containerType,
+                            _valueInstantiator.getClass().getName()));
+                }
+                /* Theoretically should be able to get CreatorProperty for delegate
+                 * parameter to pass; but things get tricky because DelegateCreator
+                 * may contain injectable values. So, for now, let's pass nothing.
+                 */
+                _delegateDeserializer = findDeserializer(ctxt, delegateType, null);
+            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {
+                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
+                if (delegateType == null) {
+                    ctxt.reportBadDefinition(_containerType, String.format(
+"Invalid delegate-creator definition for %s: value instantiator (%s) returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'",
+                            _containerType,
+                            _valueInstantiator.getClass().getName()));
+                }
+                _delegateDeserializer = findDeserializer(ctxt, delegateType, null);
+            } else if (_valueInstantiator.canCreateFromObjectWith()) {
+                SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());
+                _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps,
+                        ctxt.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES));
+            }
+        }
+    }
+
     /**
      * Method called to finalize setup of this deserializer,
      * when it is known for which property deserializer is needed for.
@@ -127,7 +214,7 @@ public class EnumMapDeserializer
     // Must override since we do not expose ValueInstantiator
     @Override // since 2.9
     public Object getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {
-        return constructMap();
+        return constructMap(ctxt);
     }
 
     /*
@@ -140,16 +227,40 @@ public class EnumMapDeserializer
     public EnumMap<?,?> deserialize(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
+        if (_propertyBasedCreator != null) {
+            return _deserializeUsingProperties(p, ctxt);
+        }
+        if (_delegateDeserializer != null) {
+            return (EnumMap<?,?>) _valueInstantiator.createUsingDelegate(ctxt,
+                    _delegateDeserializer.deserialize(p, ctxt));
+        }
         // Ok: must point to START_OBJECT
-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {
+        JsonToken t = p.getCurrentToken();
+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {
+            // (empty) String may be ok however; or single-String-arg ctor
+            if (t == JsonToken.VALUE_STRING) {
+                return (EnumMap<?,?>) _valueInstantiator.createFromString(ctxt, p.getText());
+            }
+            // slightly redundant (since String was passed above), but also handles empty array case:
             return _deserializeFromEmpty(p, ctxt);
         }
-        EnumMap result = constructMap();
+        EnumMap result = constructMap(ctxt);
+        return deserialize(p, ctxt, result);
+    }
+
+    @Override
+    public EnumMap<?,?> deserialize(JsonParser p, DeserializationContext ctxt,
+            EnumMap result)
+        throws IOException
+    {
+        // [databind#631]: Assign current value, to be accessible by custom deserializers
+        p.setCurrentValue(result);
+
         final JsonDeserializer<Object> valueDes = _valueDeserializer;
         final TypeDeserializer typeDeser = _valueTypeDeserializer;
+        String keyName;
 
-        while ((p.nextToken()) == JsonToken.FIELD_NAME) {
-            String keyName = p.getCurrentName(); // just for error message
+        while ((keyName = p.nextFieldName()) != null) {
             // but we need to let key deserializer handle it separately, nonetheless
             Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);
             if (key == null) {
@@ -158,9 +269,8 @@ public class EnumMapDeserializer
                             "value not one of declared Enum instance names for %s",
                             _containerType.getKeyType());
                 }
-                /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's
-                 *  just skip the entry then. But we must skip the value as well, if so.
-                 */
+                // 24-Mar-2012, tatu: Null won't work as a key anyway, so let's
+                //  just skip the entry then. But we must skip the value as well, if so.
                 p.nextToken();
                 p.skipChildren();
                 continue;
@@ -191,15 +301,103 @@ public class EnumMapDeserializer
     }
 
     @Override
-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
+            TypeDeserializer typeDeserializer)
         throws IOException
     {
         // In future could check current token... for now this should be enough:
-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);
+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);
     }
-    
-    protected EnumMap<?,?> constructMap() {
-        return new EnumMap(_enumClass);
+
+    protected EnumMap<?,?> constructMap(DeserializationContext ctxt) throws JsonMappingException {
+        if (_valueInstantiator == null) {
+            return new EnumMap(_enumClass);
+        }
+        try {
+            if (!_valueInstantiator.canCreateUsingDefault()) {
+                return (EnumMap<?,?>) ctxt.handleMissingInstantiator(handledType(),
+                        getValueInstantiator(), null,
+                        "no default constructor found");
+            }
+            return (EnumMap<?,?>) _valueInstantiator.createUsingDefault(ctxt);
+        } catch (IOException e) {
+            return ClassUtil.throwAsMappingException(ctxt, e);
+        }
     }
-}
 
+    public EnumMap<?,?> _deserializeUsingProperties(JsonParser p, DeserializationContext ctxt) throws IOException
+    {
+        final PropertyBasedCreator creator = _propertyBasedCreator;
+        // null -> no ObjectIdReader for EnumMaps
+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, null);
+
+        String keyName;
+        if (p.isExpectedStartObjectToken()) {
+            keyName = p.nextFieldName();
+        } else if (p.hasToken(JsonToken.FIELD_NAME)) {
+            keyName = p.getCurrentName();
+        } else {
+            keyName = null;
+        }
+
+        for (; keyName != null; keyName = p.nextFieldName()) {
+            JsonToken t = p.nextToken(); // to get to value
+            // creator property?
+            SettableBeanProperty prop = creator.findCreatorProperty(keyName);
+            if (prop != null) {
+                // Last property to set?
+                if (buffer.assignParameter(prop, prop.deserialize(p, ctxt))) {
+                    EnumMap<?,?> result;
+                    try {
+                        result = (EnumMap<?,?>)creator.build(ctxt, buffer);
+                    } catch (Exception e) {
+                        return wrapAndThrow(e, _containerType.getRawClass(), keyName);
+                    }
+                    return deserialize(p, ctxt, result);
+                }
+                continue;
+            }
+            // other property? needs buffering
+            // but we need to let key deserializer handle it separately, nonetheless
+            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);
+            if (key == null) {
+                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
+                    return (EnumMap<?,?>) ctxt.handleWeirdStringValue(_enumClass, keyName,
+                            "value not one of declared Enum instance names for %s",
+                            _containerType.getKeyType());
+                }
+                // 24-Mar-2012, tatu: Null won't work as a key anyway, so let's
+                //  just skip the entry then. But we must skip the value as well, if so.
+                p.nextToken();
+                p.skipChildren();
+                continue;
+            }
+            Object value; 
+
+            try {
+                if (t == JsonToken.VALUE_NULL) {
+                    if (_skipNullValues) {
+                        continue;
+                    }
+                    value = _nullProvider.getNullValue(ctxt);
+                } else if (_valueTypeDeserializer == null) {
+                    value = _valueDeserializer.deserialize(p, ctxt);
+                } else {
+                    value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
+                }
+            } catch (Exception e) {
+                wrapAndThrow(e, _containerType.getRawClass(), keyName);
+                return null;
+            }
+            buffer.bufferMapProperty(key, value);
+        }
+        // end of JSON object?
+        // if so, can just construct and leave...
+        try {
+            return (EnumMap<?,?>)creator.build(ctxt, buffer);
+        } catch (Exception e) {
+            wrapAndThrow(e, _containerType.getRawClass(), keyName);
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
index d4c612035..3580f85e4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
@@ -61,7 +61,7 @@ public class MapDeserializer
      * is the type deserializer that can handle it
      */
     protected final TypeDeserializer _valueTypeDeserializer;
-    
+
     // // Instance construction settings:
 
     protected final ValueInstantiator _valueInstantiator;
@@ -81,9 +81,9 @@ public class MapDeserializer
     protected PropertyBasedCreator _propertyBasedCreator;    
 
     protected final boolean _hasDefaultCreator;
-    
+
     // // Any properties to ignore if seen?
-    
+
     protected Set<String> _ignorableProperties;
 
     /*
@@ -356,11 +356,11 @@ public class MapDeserializer
         // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT
         JsonToken t = p.getCurrentToken();
         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {
-            // (empty) String may be ok however:
+            // (empty) String may be ok however; or single-String-arg ctor
             if (t == JsonToken.VALUE_STRING) {
                 return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, p.getText());
             }
-            // slightly redundant (since String was passed above), but
+            // slightly redundant (since String was passed above), but also handles empty array case:
             return _deserializeFromEmpty(p, ctxt);
         }
         final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);
@@ -378,7 +378,7 @@ public class MapDeserializer
             Map<Object,Object> result)
         throws IOException
     {
-        // [databind#631]: Assign current value, to be accessible by custom serializers
+        // [databind#631]: Assign current value, to be accessible by custom deserializers
         p.setCurrentValue(result);
         
         // Ok: must point to START_OBJECT or FIELD_NAME
@@ -430,7 +430,8 @@ public class MapDeserializer
         MapReferringAccumulator referringAccumulator = null;
         boolean useObjectId = valueDes.getObjectIdReader() != null;
         if (useObjectId) {
-            referringAccumulator = new MapReferringAccumulator(_containerType.getContentType().getRawClass(), result);
+            referringAccumulator = new MapReferringAccumulator(_containerType.getContentType().getRawClass(),
+                    result);
         }
 
         String keyStr;
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumDeserializationTest.java
index deca7339d..2a0bc19af 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumDeserializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumDeserializationTest.java
@@ -233,13 +233,6 @@ public class EnumDeserializationTest
         assertEquals(AnnotatedTestEnum.OK, e);
     }
 
-    public void testEnumMaps() throws Exception
-    {
-        EnumMap<TestEnum,String> value = MAPPER.readValue("{\"OK\":\"value\"}",
-                new TypeReference<EnumMap<TestEnum,String>>() { });
-        assertEquals("value", value.get(TestEnum.OK));
-    }
-
     public void testSubclassedEnums() throws Exception
     {
         EnumWithSubClass value = MAPPER.readValue("\"A\"", EnumWithSubClass.class);
@@ -255,16 +248,6 @@ public class EnumDeserializationTest
         assertEquals(LowerCaseEnum.C, value);
     }
 
-    public void testToStringEnumMaps() throws Exception
-    {
-        // can't reuse global one due to reconfig
-        ObjectMapper m = new ObjectMapper();
-        m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);
-        EnumMap<LowerCaseEnum,String> value = m.readValue("{\"a\":\"value\"}",
-                new TypeReference<EnumMap<LowerCaseEnum,String>>() { });
-        assertEquals("value", value.get(LowerCaseEnum.A));
-    }
-
     public void testNumbersToEnums() throws Exception
     {
         // by default numbers are fine:
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumMapDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumMapDeserializationTest.java
new file mode 100644
index 000000000..94f8bb4ef
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/EnumMapDeserializationTest.java
@@ -0,0 +1,118 @@
+package com.fasterxml.jackson.databind.deser.jdk;
+
+import java.util.EnumMap;
+import java.util.Map;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.*;
+
+@SuppressWarnings("serial")
+public class EnumMapDeserializationTest extends BaseMapTest
+{
+    enum TestEnum { JACKSON, RULES, OK; }
+
+    protected enum LowerCaseEnum {
+        A, B, C;
+        private LowerCaseEnum() { }
+        @Override
+        public String toString() { return name().toLowerCase(); }
+    }
+
+    static class MySimpleEnumMap extends EnumMap<TestEnum,String> { 
+        public MySimpleEnumMap() {
+            super(TestEnum.class);
+        }
+    }
+
+    static class FromStringEnumMap extends EnumMap<TestEnum,String> { 
+        @JsonCreator
+        public FromStringEnumMap(String value) {
+            super(TestEnum.class);
+            put(TestEnum.JACKSON, value);
+        }
+    }
+
+    static class FromDelegateEnumMap extends EnumMap<TestEnum,String> { 
+        @JsonCreator
+        public FromDelegateEnumMap(Map<Object,Object> stuff) {
+            super(TestEnum.class);
+            put(TestEnum.OK, String.valueOf(stuff));
+        }
+    }
+
+    static class FromPropertiesEnumMap extends EnumMap<TestEnum,String> { 
+        int a0, b0;
+
+        @JsonCreator
+        public FromPropertiesEnumMap(@JsonProperty("a") int a,
+                @JsonProperty("b") int b) {
+            super(TestEnum.class);
+            a0 = a;
+            b0 = b;
+        }
+    }
+
+    /*
+    /**********************************************************
+    /* Test methods
+    /**********************************************************
+     */
+
+    protected final ObjectMapper MAPPER = new ObjectMapper();
+
+    public void testEnumMaps() throws Exception
+    {
+        EnumMap<TestEnum,String> value = MAPPER.readValue("{\"OK\":\"value\"}",
+                new TypeReference<EnumMap<TestEnum,String>>() { });
+        assertEquals("value", value.get(TestEnum.OK));
+    }
+
+    public void testToStringEnumMaps() throws Exception
+    {
+        // can't reuse global one due to reconfig
+        ObjectReader r = MAPPER.reader()
+                .with(DeserializationFeature.READ_ENUMS_USING_TO_STRING);
+        EnumMap<LowerCaseEnum,String> value = r.forType(
+            new TypeReference<EnumMap<LowerCaseEnum,String>>() { })
+                .readValue("{\"a\":\"value\"}");
+        assertEquals("value", value.get(LowerCaseEnum.A));
+    }
+
+    public void testCustomEnumMapWithDefaultCtor() throws Exception
+    {
+        MySimpleEnumMap map = MAPPER.readValue(aposToQuotes("{'RULES':'waves'}"),
+                MySimpleEnumMap.class);   
+        assertEquals(1, map.size());
+        assertEquals("waves", map.get(TestEnum.RULES));
+    }
+
+    public void testCustomEnumMapFromString() throws Exception
+    {
+        FromStringEnumMap map = MAPPER.readValue(quote("kewl"), FromStringEnumMap.class);   
+        assertEquals(1, map.size());
+        assertEquals("kewl", map.get(TestEnum.JACKSON));
+    }
+
+    public void testCustomEnumMapWithDelegate() throws Exception
+    {
+        FromDelegateEnumMap map = MAPPER.readValue(aposToQuotes("{'foo':'bar'}"), FromDelegateEnumMap.class);   
+        assertEquals(1, map.size());
+        assertEquals("{foo=bar}", map.get(TestEnum.OK));
+    }
+
+    public void testCustomEnumMapFromProps() throws Exception
+    {
+        FromPropertiesEnumMap map = MAPPER.readValue(aposToQuotes(
+                "{'a':13,'RULES':'jackson','b':-731,'OK':'yes'}"),
+                FromPropertiesEnumMap.class);
+
+        assertEquals(13, map.a0);
+        assertEquals(-731, map.b0);
+
+        assertEquals("jackson", map.get(TestEnum.RULES));
+        assertEquals("yes", map.get(TestEnum.OK));
+        assertEquals(2, map.size());
+    }
+}
