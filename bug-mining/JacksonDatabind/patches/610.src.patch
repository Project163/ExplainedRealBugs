diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 1670fd713..c945e4821 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -66,6 +66,8 @@ Project: jackson-databind
 #3227: Content `null` handling not working for root values
  (reported by Jo√£o G)
  (fix contributed by proost@github)
+#3235: `USE_BASE_TYPE_AS_DEFAULT_IMPL` not working with `DefaultTypeResolverBuilder`
+ (reported, fix contributed by silas.u / sialais@github)
 #3238: Add PropertyNamingStrategies.UpperSnakeCaseStrategy (and UPPER_SNAKE_CASE constant)
  (requested by Kenneth J)
  (contributed by Tanvesh)
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
index 3f26a11ff..656c642e7 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
@@ -260,6 +260,13 @@ public class ObjectMapper
             _subtypeValidator = _requireNonNull(ptv, "Can not pass `null` PolymorphicTypeValidator");
         }
 
+        // @since 2.13
+        protected DefaultTypeResolverBuilder(DefaultTypeResolverBuilder base, Class<?> defaultImpl) {
+            super(base, defaultImpl);
+            _appliesFor = base._appliesFor;
+            _subtypeValidator = base._subtypeValidator;
+        }
+
         // 20-Jan-2020: as per [databind#2599] Objects.requireNonNull() from JDK7 not in all Android so
         private static <T> T _requireNonNull(T value, String msg) {
             // Replacement for: return Objects.requireNonNull(t, msg);
@@ -277,6 +284,15 @@ public class ObjectMapper
             return new DefaultTypeResolverBuilder(t, ptv);
         }
 
+        @Override // since 2.13
+        public DefaultTypeResolverBuilder withDefaultImpl(Class<?> defaultImpl) {
+            if (_defaultImpl == defaultImpl) {
+                return this;
+            }
+            ClassUtil.verifyMustOverride(DefaultTypeResolverBuilder.class, this, "withDefaultImpl");
+            return new DefaultTypeResolverBuilder(this, defaultImpl);
+        }
+
         @Override // since 2.10
         public PolymorphicTypeValidator subTypeValidator(MapperConfig<?> config) {
             return _subtypeValidator;
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index 2405d9d95..9231bbf8f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -1797,8 +1797,10 @@ factory.toString()));
         // (note: check for abstract type is not 100% mandatory, more of an optimization)
         if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {
             JavaType defaultType = mapAbstractType(config, baseType);
+            // 18-Sep-2021, tatu: We have a shared instance, MUST NOT call mutating method
+            //    but the new "mutant factory":
             if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {
-                b = b.defaultImpl(defaultType.getRawClass());
+                b = b.withDefaultImpl(defaultType.getRawClass());
             }
         }
         // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java
index 9faaec7d2..8317eef40 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java
@@ -97,7 +97,7 @@ public interface TypeResolverBuilder<T extends TypeResolverBuilder<T>>
      *   but not necessarily)
      */
     public T init(JsonTypeInfo.Id idType, TypeIdResolver res);
-    
+
     /*
     /**********************************************************
     /* Methods for configuring resolver to build 
@@ -136,7 +136,7 @@ public interface TypeResolverBuilder<T extends TypeResolverBuilder<T>>
     /**
      * Method for specifying default implementation to use if type id 
      * is either not available, or cannot be resolved.
-     * 
+     *
      * @return Resulting builder instance (usually this builder,
      *   but may be a newly constructed instance for immutable builders}
      */
@@ -152,4 +152,25 @@ public interface TypeResolverBuilder<T extends TypeResolverBuilder<T>>
      * @since 2.0
      */
     public T typeIdVisibility(boolean isVisible);
+
+    /*
+    /**********************************************************************
+    /* Mutant factories (2.13+)
+    /**********************************************************************
+     */
+
+    /**
+     * "Mutant factory" method for creating a new instance with different default
+     * implementation.
+     *
+     * @since 2.13
+     *
+     * @return Either this instance (if nothing changed) or a new instance with
+     *    different default implementation
+     */
+    public default T withDefaultImpl(Class<?> defaultImpl) {
+        // 18-Sep-2021, tatu: Not sure if this should be left failing, or use
+        //    possibly unsafe variant
+        return defaultImpl(defaultImpl);
+    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
index 6b57bdd0e..e87d25cbc 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
@@ -60,6 +60,23 @@ public class StdTypeResolverBuilder
         _typeProperty = propName;
     }
 
+    /**
+     * Copy-constructor
+     *
+     * @since 2.13
+     */
+    protected StdTypeResolverBuilder(StdTypeResolverBuilder base,
+            Class<?> defaultImpl)
+    {
+        _idType = base._idType;
+        _includeAs = base._includeAs;
+        _typeProperty = base._typeProperty;
+        _typeIdVisible = base._typeIdVisible;
+        _customIdResolver = base._customIdResolver;
+
+        _defaultImpl = defaultImpl;
+    }
+
     public static StdTypeResolverBuilder noTypeInfoBuilder() {
         return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);
     }
@@ -243,7 +260,18 @@ public class StdTypeResolverBuilder
         _typeIdVisible = isVisible;
         return this;
     }
-    
+
+    @Override
+    public StdTypeResolverBuilder withDefaultImpl(Class<?> defaultImpl) {
+        if (_defaultImpl == defaultImpl) {
+            return this;
+        }
+        ClassUtil.verifyMustOverride(StdTypeResolverBuilder.class, this, "withDefaultImpl");
+
+        // NOTE: MUST create new instance, NOT modify this instance
+        return new StdTypeResolverBuilder(this, defaultImpl);
+    }
+
     /*
     /**********************************************************
     /* Accessors
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestBaseTypeAsDefault.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestBaseTypeAsDefault.java
index 1d56afcd7..cf9d6e805 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestBaseTypeAsDefault.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestBaseTypeAsDefault.java
@@ -16,12 +16,10 @@ public class TestBaseTypeAsDefault extends BaseMapTest
     static class Child extends Parent {
     }
 
-
     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "@class", defaultImpl = ChildOfChild.class)
     static abstract class AbstractParentWithDefault {
     }
 
-
     static class ChildOfAbstract extends AbstractParentWithDefault {
     }
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultTypeAbstractMapping3235Test.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultTypeAbstractMapping3235Test.java
new file mode 100644
index 000000000..194b95055
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultTypeAbstractMapping3235Test.java
@@ -0,0 +1,60 @@
+package com.fasterxml.jackson.databind.jsontype.deftyping;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+import com.fasterxml.jackson.annotation.JsonTypeInfo;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+public class DefaultTypeAbstractMapping3235Test extends BaseMapTest
+{
+    // [databind#3235]
+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "@class")
+    static class Parent { }
+    static class Child extends Parent { }
+
+    static abstract class AbstractParentWithoutDefault {}
+
+    static class ChildOfParentWithoutDefault extends AbstractParentWithoutDefault {
+        public Map<String,String> mapField;
+        public Parent objectField;
+    }
+
+    // [databind#3235]
+    public void testForAbstractTypeMapping() throws Exception
+    {
+        // [databind#3235]
+        ObjectMapper mapper3235 = jsonMapperBuilder()
+                .enable(MapperFeature.USE_BASE_TYPE_AS_DEFAULT_IMPL)
+                .addModule(new SimpleModule()
+                        .addAbstractTypeMapping(AbstractParentWithoutDefault.class, ChildOfParentWithoutDefault.class)
+                        .addAbstractTypeMapping(Map.class, TreeMap.class)
+                        .addAbstractTypeMapping(List.class, LinkedList.class)
+                )
+                .registerSubtypes(TreeMap.class, LinkedList.class, ChildOfParentWithoutDefault.class)
+                .setDefaultTyping(
+                        new ObjectMapper.DefaultTypeResolverBuilder(
+                                ObjectMapper.DefaultTyping.NON_FINAL, LaissezFaireSubTypeValidator.instance
+                        ).init(JsonTypeInfo.Id.CLASS, null
+                        ).inclusion(JsonTypeInfo.As.PROPERTY)
+                )
+                .build();
+        String doc = a2q(
+                "{" +
+                "  'mapField': {" +
+                "    'a':'a'" +
+                "  }, " +
+                "  'objectField': {}" +
+                "}");
+        Object o = mapper3235.readValue(doc, AbstractParentWithoutDefault.class);
+        assertEquals(o.getClass(), ChildOfParentWithoutDefault.class);
+        ChildOfParentWithoutDefault ot = (ChildOfParentWithoutDefault) o;
+        assertEquals(ot.mapField.getClass(), TreeMap.class);
+        assertEquals(ot.objectField.getClass(), Parent.class);
+    }
+}
