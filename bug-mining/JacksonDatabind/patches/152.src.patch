diff --git a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
index 18e1e32a8..90df10366 100644
--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
@@ -1104,9 +1104,7 @@ public abstract class SerializerProvider
 
     protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException
     {
-        /* 07-Jan-2010, tatu: As per [JACKSON-456] better handle distinction between wrapper types,
-         *    primitives
-         */
+        // One special case: allow primitive/wrapper type coercion
         if (rootType.isPrimitive()) {
             Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());
             // If it's just difference between wrapper, primitive, let it slide
@@ -1163,10 +1161,10 @@ public abstract class SerializerProvider
     protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)
         throws JsonMappingException
     {
-        JavaType type = _config.constructType(rawType);
+        JavaType fullType = _config.constructType(rawType);
         JsonSerializer<Object> ser;
         try {
-            ser = _createUntypedSerializer(type);
+            ser = _createUntypedSerializer(fullType);
         } catch (IllegalArgumentException iae) {
             /* We better only expose checked exceptions, since those
              * are what caller is expected to handle
@@ -1175,7 +1173,8 @@ public abstract class SerializerProvider
         }
 
         if (ser != null) {
-            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
+            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key
+            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);
         }
         return ser;
     }
@@ -1194,6 +1193,7 @@ public abstract class SerializerProvider
         }
     
         if (ser != null) {
+            // 21-Dec-2015, tatu: Should we also cache using raw key?
             _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
         }
         return ser;
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
index 773a2a143..153a5334b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java
@@ -5,6 +5,7 @@ import java.util.concurrent.atomic.AtomicReference;
 
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;
+import com.fasterxml.jackson.databind.util.TypeKey;
 
 /**
  * Simple cache object that allows for doing 2-level lookups: first level is
@@ -29,8 +30,8 @@ public final class SerializerCache
      * NOTE: keys are of various types (see below for key types), in addition to
      * basic {@link JavaType} used for "untyped" serializers.
      */
-    private final HashMap<com.fasterxml.jackson.databind.util.TypeKey, JsonSerializer<Object>> _sharedMap
-        = new HashMap<com.fasterxml.jackson.databind.util.TypeKey, JsonSerializer<Object>>(64);
+    private final HashMap<TypeKey, JsonSerializer<Object>> _sharedMap
+        = new HashMap<TypeKey, JsonSerializer<Object>>(64);
 
     /**
      * Most recent read-only instance, created from _sharedMap, if any.
@@ -145,12 +146,10 @@ public final class SerializerCache
             if (_sharedMap.put(new TypeKey(type, false), ser) == null) {
                 _readOnlyMap.set(null);
             }
-            /* Finally: some serializers want to do post-processing, after
-             * getting registered (to handle cyclic deps).
-             */
-            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
-             *   in synchronized manner; this because while we do need to register
-             *   instance first, we also must keep lock until resolution is complete
+            // Need resolution to handle cyclic POJO type dependencies
+            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
+             *   this because while we do need to register instance first, we also must
+             *   keep lock until resolution is complete.
              */
             if (ser instanceof ResolvableSerializer) {
                 ((ResolvableSerializer) ser).resolve(provider);
@@ -166,12 +165,10 @@ public final class SerializerCache
             if (_sharedMap.put(new TypeKey(type, false), ser) == null) {
                 _readOnlyMap.set(null);
             }
-            /* Finally: some serializers want to do post-processing, after
-             * getting registered (to handle cyclic deps).
-             */
-            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
-             *   in synchronized manner; this because while we do need to register
-             *   instance first, we also must keep lock until resolution is complete
+            // Need resolution to handle cyclic POJO type dependencies
+            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
+             *   this because while we do need to register instance first, we also must
+             *   keep lock until resolution is complete.
              */
             if (ser instanceof ResolvableSerializer) {
                 ((ResolvableSerializer) ser).resolve(provider);
@@ -180,31 +177,33 @@ public final class SerializerCache
     }
 
     /**
-     * Method called by StdSerializerProvider#flushCachedSerializers() to
-     * clear all cached serializers
+     * Another alternative that will cover both access via raw type and matching
+     * fully resolved type, in one fell swoop.
+     *
+     * @since 2.7
      */
-    public synchronized void flush() {
-        _sharedMap.clear();
+    public void addAndResolveNonTypedSerializer(Class<?> rawType, JavaType fullType,
+            JsonSerializer<Object> ser,
+            SerializerProvider provider)
+        throws JsonMappingException
+    {
+        synchronized (this) {
+            Object ob1 = _sharedMap.put(new TypeKey(rawType, false), ser);
+            Object ob2 = _sharedMap.put(new TypeKey(fullType, false), ser);
+            if ((ob1 == null) || (ob2 == null)) {
+                _readOnlyMap.set(null);
+            }
+            if (ser instanceof ResolvableSerializer) {
+                ((ResolvableSerializer) ser).resolve(provider);
+            }
+        }
     }
 
-    /*
-    /**************************************************************
-    /* Helper class(es)
-    /**************************************************************
-     */
-
     /**
-     * @deprecated Since 2.6; replaced by {@link com.fasterxml.jackson.databind.util.TypeKey}
+     * Method called by StdSerializerProvider#flushCachedSerializers() to
+     * clear all cached serializers
      */
-    @Deprecated
-    public final static class TypeKey extends com.fasterxml.jackson.databind.util.TypeKey
-    {
-        public TypeKey(Class<?> key, boolean typed) {
-            super(key, typed);
-        }
-
-        public TypeKey(JavaType key, boolean typed) {
-            super(key, typed);
-        }
+    public synchronized void flush() {
+        _sharedMap.clear();
     }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
index 15b4266c6..feacbce21 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java
@@ -130,6 +130,7 @@ public final class ReadOnlyClassToSerializerMap
         }
         return null;
     }    
+
     /*
     /**********************************************************
     /* Helper classes
