diff --git a/release-notes/VERSION b/release-notes/VERSION
index 157887b6e..a6fa62d74 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -32,6 +32,7 @@ Project: jackson-databind
  (reported by wealdtech@github)
 #725: Auto-detect multi-argument constructor with implicit names if it is the only visible creator
 #727: Improve `ObjectWriter.forType()` to avoid forcing base type for container types
+#734: Add basic error-recovery for `ObjectReader.readValues()`
 #737: Add support for writing raw values in TokenBuffer
  (suggested by Guillaume S, gsmet@github)
 #740: Ensure proper `null` (as empty) handling for `AtomicReference`
diff --git a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
index a7591d709..c0e79c8c0 100644
--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
@@ -15,15 +15,69 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
 {
     protected final static MappingIterator<?> EMPTY_ITERATOR =
         new MappingIterator<Object>(null, null, null, null, false, null);
+
+    /*
+    /**********************************************************
+    /* State constants
+    /**********************************************************
+     */
+
+    /**
+     * State in which iterator is closed
+     */
+    protected final static int STATE_CLOSED = 0;
     
+    /**
+     * State in which value read failed
+     */
+    protected final static int STATE_NEED_RESYNC = 1;
+    
+    /**
+     * State in which no recovery is needed, but "hasNextValue()" needs
+     * to be called first
+     */
+    protected final static int STATE_MAY_HAVE_VALUE = 2;
+
+    /**
+     * State in which "hasNextValue()" has been succesfully called
+     * and deserializer can be called to fetch value
+     */
+    protected final static int STATE_HAS_VALUE = 3;
+
+    /*
+    /**********************************************************
+    /* Configuration
+    /**********************************************************
+     */
+
+    /**
+     * Type to bind individual elements to.
+     */
     protected final JavaType _type;
 
+    /**
+     * Context for deserialization, needed to pass through to deserializer
+     */
     protected final DeserializationContext _context;
-    
+
+    /**
+     * Deserializer for individual element values.
+     */
     protected final JsonDeserializer<T> _deserializer;
 
-    protected JsonParser _parser;
+    /**
+     * Underlying parser used for reading content to bind. Initialized
+     * as not <code>null</code> but set as <code>null</null> when
+     * iterator is closed, to denote closing.
+     */
+    protected final JsonParser _parser;
 
+    /**
+     * Context to resynchronize to, in case an exception is encountered
+     * but caller wants to try to read more elements.
+     */
+    protected final JsonStreamContext _seqContext;
+    
     /**
      * If not null, "value to update" instead of creating a new instance
      * for each call.
@@ -37,12 +91,23 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      */
     protected final boolean _closeParser;
 
+    /*
+    /**********************************************************
+    /* Parsing state
+    /**********************************************************
+     */
+    
     /**
-     * Flag that is set when we have determined what {@link #hasNextValue()}
-     * should value; reset when {@link #nextValue} is called
+     * State of the iterator
      */
-    protected boolean _hasNextChecked;
+    protected int _state;
 
+    /*
+    /**********************************************************
+    /* Construction
+    /**********************************************************
+     */
+    
     /**
      * @param managedParser Whether we "own" the {@link JsonParser} passed or not:
      *   if true, it was created by {@link ObjectReader} and code here needs to
@@ -50,12 +115,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      *   closed by iterator.
      */
     @SuppressWarnings("unchecked")
-    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,
+    protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,
             JsonDeserializer<?> deser,
             boolean managedParser, Object valueToUpdate)
     {
         _type = type;
-        _parser = jp;
+        _parser = p;
         _context = ctxt;
         _deserializer = (JsonDeserializer<T>) deser;
         _closeParser = managedParser;
@@ -75,8 +140,25 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
          * and if not, caller needs to hand us JsonParser instead, pointing to
          * the first token of the first element.
          */
-        if (managedParser && (jp != null) && jp.isExpectedStartArrayToken()) {
-            jp.clearCurrentToken();
+        if (p == null) { // can this occur?
+            _seqContext = null;
+            _state = STATE_CLOSED;
+        } else {
+            JsonStreamContext sctxt = p.getParsingContext();
+            if (managedParser && p.isExpectedStartArrayToken()) {
+                // If pointing to START_ARRAY, context should be that ARRAY
+                p.clearCurrentToken();
+            } else {
+                // regardless, recovery context should be whatever context we have now,
+                // with sole exception of pointing to a start marker, in which case it's
+                // the parent
+                JsonToken t = p.getCurrentToken();
+                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {
+                    sctxt = sctxt.getParent();
+                }
+            }
+            _seqContext = sctxt;
+            _state = STATE_MAY_HAVE_VALUE;
         }
     }
 
@@ -121,9 +203,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     }
     
     @Override
-    public void close() throws IOException{
-        if (_parser != null) {
-            _parser.close();
+    public void close() throws IOException {
+        if (_state != STATE_CLOSED) {
+            _state = STATE_CLOSED;
+            if (_parser != null) {
+                _parser.close();
+            }
         }
     }
 
@@ -133,55 +218,71 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**********************************************************
      */
 
+
+    /*
+     */
+    
     /**
      * Equivalent of {@link #next} but one that may throw checked
      * exceptions from Jackson due to invalid input.
      */
     public boolean hasNextValue() throws IOException
     {
-        if (_parser == null) {
+        switch (_state) {
+        case STATE_CLOSED:
             return false;
-        }
-        if (!_hasNextChecked) {
+        case STATE_NEED_RESYNC:
+            _resync();
+            // fall-through
+        case STATE_MAY_HAVE_VALUE:
             JsonToken t = _parser.getCurrentToken();
-            _hasNextChecked = true;
             if (t == null) { // un-initialized or cleared; find next
                 t = _parser.nextToken();
                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
                 if (t == null || t == JsonToken.END_ARRAY) {
-                    JsonParser jp = _parser;
-                    _parser = null;
-                    if (_closeParser) {
-                        jp.close();
+                    _state = STATE_CLOSED;
+                    if (_closeParser && (_parser != null)) {
+                        _parser.close();
                     }
                     return false;
                 }
             }
+            _state = STATE_HAS_VALUE;
+            return true;
+        case STATE_HAS_VALUE:
+            // fall through
         }
         return true;
     }
-    
+
     public T nextValue() throws IOException
     {
-        // caller should always call 'hasNext[Value]' first; but let's ensure:
-        if (!_hasNextChecked) {
+        switch (_state) {
+        case STATE_CLOSED:
+            return _throwNoSuchElement();
+        case STATE_NEED_RESYNC: // fall-through, will do re-sync
+        case STATE_MAY_HAVE_VALUE:
             if (!hasNextValue()) {
                 return _throwNoSuchElement();
             }
+            break;
+        case STATE_HAS_VALUE:
+            break;
         }
-        if (_parser == null) {
-            return _throwNoSuchElement();
-        }
-        _hasNextChecked = false;
 
+        int nextState = STATE_NEED_RESYNC;
         try {
+            T value;
             if (_updatedValue == null) {
-                return _deserializer.deserialize(_parser, _context);
+                value = _deserializer.deserialize(_parser, _context);
             } else{
                 _deserializer.deserialize(_parser, _context, _updatedValue);
-                return _updatedValue;
+                value = _updatedValue;
             }
+            nextState = STATE_MAY_HAVE_VALUE;
+            return value;
         } finally {
+            _state = nextState;
             /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
              *   matter what, to avoid infinite loop for certain failure cases.
              *   For 2.6 need to improve further.
@@ -278,6 +379,29 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**********************************************************
      */
 
+    protected void _resync() throws IOException
+    {
+        final JsonParser p = _parser;
+        // First, a quick check to see if we might have been lucky and no re-sync needed
+        if (p.getParsingContext() == _seqContext) {
+            return;
+        }
+
+        while (true) {
+            JsonToken t = p.nextToken();
+            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {
+                if (p.getParsingContext() == _seqContext) {
+                    p.clearCurrentToken();
+                    return;
+                }
+            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {
+                p.skipChildren();
+            } else if (t == null) {
+                return;
+            }
+        }
+    }
+
     protected <R> R _throwNoSuchElement() {
         throw new NoSuchElementException();
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java b/src/test/java/com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
index ab62cd91b..201e2940d 100644
--- a/src/test/java/com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ReadRecoveryTest.java
@@ -9,9 +9,9 @@ import com.fasterxml.jackson.databind.*;
 public class ReadRecoveryTest extends BaseMapTest
 {
     static class Bean {
-        public int a;
+        public int a, b;
 
-        @Override public String toString() { return "{Bean, a="+a+"}"; }
+        @Override public String toString() { return "{Bean, a="+a+", b="+b+"}"; }
     }
 
     /*
@@ -24,7 +24,7 @@ public class ReadRecoveryTest extends BaseMapTest
 
     public void testRootBeans() throws Exception
     {
-        final String JSON = aposToQuotes("{'a':3} {'b':5}");
+        final String JSON = aposToQuotes("{'a':3} {'x':5}");
         MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
         // First one should be fine
         assertTrue(it.hasNextValue());
@@ -35,15 +35,71 @@ public class ReadRecoveryTest extends BaseMapTest
             bean = it.nextValue();
             fail("Should not have succeeded");
         } catch (JsonMappingException e) {
-            verifyException(e, "Unrecognized field");
+            verifyException(e, "Unrecognized field \"x\"");
         }
-        // 24-Mar-2015, tatu: With 2.5, best we can do is to avoid infinite loop;
-        //    also, since the next token is END_OBJECT, will produce empty Object
-        assertTrue(it.hasNextValue());
+        // 21-May-2015, tatu: With [databind#734], recovery, we now know there's no more data!
+        assertFalse(it.hasNextValue());
+
+        it.close();
+    }
+
+    // for [databind#734]
+    // Simple test for verifying that basic recover works for a case of
+    // unknown structured value
+    public void testSimpleRootRecovery() throws Exception
+    {
+        final String JSON = aposToQuotes("{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} ");
+
+        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
+        Bean bean = it.nextValue();
+
+        assertNotNull(bean);
+        assertEquals(3, bean.a);
+
+        // second one problematic
+        try {
+            it.nextValue();
+        } catch (JsonMappingException e) {
+            verifyException(e, "Unrecognized field \"foo\"");
+        }
+
+        // but should recover nicely
         bean = it.nextValue();
-        assertEquals(0, bean.a);
-        // and we should be done now
+        assertNotNull(bean);
+        assertEquals(1, bean.a);
+        assertEquals(2, bean.b);
+
+        assertFalse(it.hasNextValue());
+        
+        it.close();
+    }
+
+    // Similar to "raw" root-level Object sequence, but in array
+    public void testSimpleArrayRecovery() throws Exception
+    {
+        final String JSON = aposToQuotes("[{'a':3},{'a':27,'foo':[1,2],'b':{'x':3}}  ,{'a':1,'b':2}  ]");
+
+        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);
+        Bean bean = it.nextValue();
+
+        assertNotNull(bean);
+        assertEquals(3, bean.a);
+
+        // second one problematic
+        try {
+            it.nextValue();
+        } catch (JsonMappingException e) {
+            verifyException(e, "Unrecognized field \"foo\"");
+        }
+
+        // but should recover nicely
+        bean = it.nextValue();
+        assertNotNull(bean);
+        assertEquals(1, bean.a);
+        assertEquals(2, bean.b);
+
         assertFalse(it.hasNextValue());
+        
         it.close();
     }
 }
