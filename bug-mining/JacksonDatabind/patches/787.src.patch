diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5fe8072d4..cde52a338 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -5,6 +5,11 @@ Versions: 3.x (for earlier see VERSION-2.x)
 === Releases ===
 ------------------------------------------------------------------------
 
+3.0.0-rc4 (not yet released)
+
+#5093: Change the way `BeanDescription` passed during serializer construction
+ to use `Supplier`
+
 3.0.0-rc3 (13-Apr-2025)
 
 #4603: Keep full stacktrace when re-throwing exception with
diff --git a/src/main/java/tools/jackson/databind/BeanDescription.java b/src/main/java/tools/jackson/databind/BeanDescription.java
index 84a5ba51e..ec7e5b709 100644
--- a/src/main/java/tools/jackson/databind/BeanDescription.java
+++ b/src/main/java/tools/jackson/databind/BeanDescription.java
@@ -298,4 +298,39 @@ public abstract class BeanDescription
      * global default settings.
      */
     public abstract Class<?>[] findDefaultViews();
+
+ 
+    /**
+     * Base implementation for lazily-constructed suppliers for {@link BeanDescription} instances.
+     */
+    public static abstract class Supplier implements java.util.function.Supplier<BeanDescription>
+    {
+        private final JavaType _type;
+
+        private transient BeanDescription _beanDesc;
+        
+        protected Supplier(JavaType type) {
+            _type = type;
+        }
+
+        public JavaType getType() { return _type; }
+
+        public Class<?> getBeanClass() { return _type.getRawClass(); }
+
+        public boolean isRecordType() { return _type.isRecordType(); }
+
+        public AnnotatedClass getClassInfo() {
+            return get().getClassInfo();
+        }
+
+        @Override
+        public BeanDescription get() {
+            if (_beanDesc == null) {
+                _beanDesc = _construct(_type);
+            }
+            return _beanDesc;
+        }
+
+        protected abstract BeanDescription _construct(JavaType forType);
+    }
 }
diff --git a/src/main/java/tools/jackson/databind/DatabindContext.java b/src/main/java/tools/jackson/databind/DatabindContext.java
index 7a79dfdcf..d61d7f502 100644
--- a/src/main/java/tools/jackson/databind/DatabindContext.java
+++ b/src/main/java/tools/jackson/databind/DatabindContext.java
@@ -312,6 +312,15 @@ public abstract class DatabindContext
      */
     public abstract BeanDescription introspectBeanDescription(JavaType type);
 
+    public BeanDescription.Supplier lazyIntrospectBeanDescription(JavaType type) {
+         return new BeanDescription.Supplier(type) {
+             @Override
+             public BeanDescription _construct(JavaType forType) {
+                 return introspectBeanDescription(forType);
+             }
+         };
+    }
+
     public AnnotatedClass introspectClassAnnotations(JavaType type) {
         return classIntrospector().introspectClassAnnotations(type);
     }
@@ -430,6 +439,12 @@ public abstract class DatabindContext
             String msg, Object... msgArgs)
         throws DatabindException;
 
+    public <T> T reportBadTypeDefinition(BeanDescription.Supplier beanDescRef,
+            String msg, Object... msgArgs)
+        throws DatabindException {
+        return reportBadTypeDefinition(beanDescRef.get(), msg, msgArgs);
+    }
+
     /*
     /**********************************************************************
     /* Helper methods
diff --git a/src/main/java/tools/jackson/databind/SerializationContext.java b/src/main/java/tools/jackson/databind/SerializationContext.java
index b8515aef6..d9f06043e 100644
--- a/src/main/java/tools/jackson/databind/SerializationContext.java
+++ b/src/main/java/tools/jackson/databind/SerializationContext.java
@@ -959,13 +959,13 @@ public abstract class SerializationContext
             JavaType fullType)
     {
         // Important: must introspect all annotations, not just class
-        BeanDescription beanDesc = introspectBeanDescription(fullType);
+        BeanDescription.Supplier beanDescRef = lazyIntrospectBeanDescription(fullType);
         ValueSerializer<Object> ser;
         try {
-            ser = _serializerFactory.createSerializer(this, fullType, beanDesc, null);
+            ser = _serializerFactory.createSerializer(this, fullType, beanDescRef, null);
         } catch (IllegalArgumentException iae) {
             // We better only expose checked exceptions, since those are what caller is expected to handle
-            reportBadTypeDefinition(beanDesc, ClassUtil.exceptionMessage(iae));
+            reportBadTypeDefinition(beanDescRef, ClassUtil.exceptionMessage(iae));
             ser = null; // never gets here
         }
         // Always cache -- and in this case both for raw and full type
@@ -976,10 +976,10 @@ public abstract class SerializationContext
     protected ValueSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)
     {
         // Important: must introspect all annotations, not just class
-        BeanDescription beanDesc = introspectBeanDescription(type);
+        BeanDescription.Supplier beanDescRef = lazyIntrospectBeanDescription(type);
         ValueSerializer<Object> ser;
         try {
-            ser = _serializerFactory.createSerializer(this, type, beanDesc, null);
+            ser = _serializerFactory.createSerializer(this, type, beanDescRef, null);
         } catch (IllegalArgumentException iae) {
             // We better only expose checked exceptions, since those are what caller is expected to handle
             throw _mappingProblem(iae, ClassUtil.exceptionMessage(iae));
@@ -996,10 +996,10 @@ public abstract class SerializationContext
     protected ValueSerializer<Object> _createAndCachePropertySerializer(Class<?> rawType,
             JavaType fullType, BeanProperty prop)
     {
-        BeanDescription beanDesc = introspectBeanDescription(fullType);
+        BeanDescription.Supplier beanDescRef = lazyIntrospectBeanDescription(fullType);
         ValueSerializer<Object> ser;
         try {
-            ser = _serializerFactory.createSerializer(this, fullType, beanDesc, null);
+            ser = _serializerFactory.createSerializer(this, fullType, beanDescRef, null);
         } catch (IllegalArgumentException iae) {
             throw _mappingProblem(iae, ClassUtil.exceptionMessage(iae));
         }
@@ -1008,7 +1008,7 @@ public abstract class SerializationContext
         if (prop == null) {
             return ser;
         }
-        return _checkShapeShifting(fullType, beanDesc, prop, ser);
+        return _checkShapeShifting(fullType, beanDescRef, prop, ser);
     }
 
     /**
@@ -1018,10 +1018,10 @@ public abstract class SerializationContext
     protected ValueSerializer<Object> _createAndCachePropertySerializer(JavaType type,
             BeanProperty prop)
     {
-        BeanDescription beanDesc = introspectBeanDescription(type);
+        BeanDescription.Supplier beanDescRef = lazyIntrospectBeanDescription(type);
         ValueSerializer<Object> ser;
         try {
-            ser = _serializerFactory.createSerializer(this, type, beanDesc, null);
+            ser = _serializerFactory.createSerializer(this, type, beanDescRef, null);
         } catch (IllegalArgumentException iae) {
             throw _mappingProblem(iae, ClassUtil.exceptionMessage(iae));
         }
@@ -1030,12 +1030,12 @@ public abstract class SerializationContext
         if (prop == null) {
             return ser;
         }
-        return _checkShapeShifting(type, beanDesc, prop, ser);
+        return _checkShapeShifting(type, beanDescRef, prop, ser);
     }
 
     @SuppressWarnings("unchecked")
-    private ValueSerializer<Object> _checkShapeShifting(JavaType type, BeanDescription beanDesc,
-            BeanProperty prop, ValueSerializer<?> ser)
+    private ValueSerializer<Object> _checkShapeShifting(JavaType type,
+            BeanDescription.Supplier beanDescRef, BeanProperty prop, ValueSerializer<?> ser)
     {
         JsonFormat.Value overrides = prop.findFormatOverrides(_config);
         if (overrides != null) {
@@ -1045,7 +1045,7 @@ public abstract class SerializationContext
                 ser = ser2;
             } else {
                 // But if not, we need to re-create it via factory
-                ser = _serializerFactory.createSerializer(this, type, beanDesc, overrides);
+                ser = _serializerFactory.createSerializer(this, type, beanDescRef, overrides);
             }
         }
         return (ValueSerializer<Object>) ser;
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/ser/JavaTimeSerializerModifier.java b/src/main/java/tools/jackson/databind/ext/javatime/ser/JavaTimeSerializerModifier.java
index 67105237c..5b1084063 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/ser/JavaTimeSerializerModifier.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/ser/JavaTimeSerializerModifier.java
@@ -12,7 +12,7 @@ public class JavaTimeSerializerModifier extends ValueSerializerModifier {
 
     @Override
     public ValueSerializer<?> modifyEnumSerializer(SerializationConfig config, JavaType valueType,
-            BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         if (valueType.hasRawClass(Month.class)) {
             return new OneBasedMonthSerializer(serializer);
         }
diff --git a/src/main/java/tools/jackson/databind/module/SimpleSerializers.java b/src/main/java/tools/jackson/databind/module/SimpleSerializers.java
index 5beb11a5d..d84029300 100644
--- a/src/main/java/tools/jackson/databind/module/SimpleSerializers.java
+++ b/src/main/java/tools/jackson/databind/module/SimpleSerializers.java
@@ -13,6 +13,7 @@ import tools.jackson.databind.type.CollectionLikeType;
 import tools.jackson.databind.type.CollectionType;
 import tools.jackson.databind.type.MapLikeType;
 import tools.jackson.databind.type.MapType;
+import tools.jackson.databind.type.ReferenceType;
 
 /**
  * Simple implementation {@link Serializers} which allows registration of
@@ -102,7 +103,7 @@ public class SimpleSerializers
 
     @Override
     public ValueSerializer<?> findSerializer(SerializationConfig config,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides)
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
     {
         Class<?> cls = type.getRawClass();
         ClassKey key = new ClassKey(cls);
@@ -163,39 +164,46 @@ public class SimpleSerializers
 
     @Override
     public ValueSerializer<?> findArraySerializer(SerializationConfig config,
-            ArrayType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            ArrayType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer) {
-        return findSerializer(config, type, beanDesc, formatOverrides);
+        return findSerializer(config, type, beanDescRef, formatOverrides);
     }
 
     @Override
     public ValueSerializer<?> findCollectionSerializer(SerializationConfig config,
-            CollectionType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            CollectionType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer) {
-        return findSerializer(config, type, beanDesc, formatOverrides);
+        return findSerializer(config, type, beanDescRef, formatOverrides);
     }
 
     @Override
     public ValueSerializer<?> findCollectionLikeSerializer(SerializationConfig config,
-            CollectionLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            CollectionLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer) {
-        return findSerializer(config, type, beanDesc, formatOverrides);
+        return findSerializer(config, type, beanDescRef, formatOverrides);
     }
 
     @Override
     public ValueSerializer<?> findMapSerializer(SerializationConfig config,
-            MapType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            MapType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             ValueSerializer<Object> keySerializer,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer) {
-        return findSerializer(config, type, beanDesc, formatOverrides);
+        return findSerializer(config, type, beanDescRef, formatOverrides);
     }
 
     @Override
     public ValueSerializer<?> findMapLikeSerializer(SerializationConfig config,
-            MapLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            MapLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             ValueSerializer<Object> keySerializer,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer) {
-        return findSerializer(config, type, beanDesc, formatOverrides);
+        return findSerializer(config, type, beanDescRef, formatOverrides);
+    }
+
+    @Override
+    public ValueSerializer<?> findReferenceSerializer(SerializationConfig config,
+            ReferenceType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
+            TypeSerializer contentTypeSerializer, ValueSerializer<Object> contentValueSerializer) {
+        return findSerializer(config, type, beanDescRef, formatOverrides);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
index d22f21579..39e36b326 100644
--- a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
@@ -184,14 +184,14 @@ public abstract class BasicSerializerFactory
     @SuppressWarnings("unchecked")
     public ValueSerializer<Object> createKeySerializer(SerializationContext ctxt, JavaType keyType)
     {
-        BeanDescription beanDesc = ctxt.introspectBeanDescription(keyType);
+        BeanDescription.Supplier beanDescRef = ctxt.lazyIntrospectBeanDescription(keyType);
         final SerializationConfig config = ctxt.getConfig();
         ValueSerializer<?> ser = null;
         // Minor optimization: to avoid constructing beanDesc, bail out if none registered
         if (_factoryConfig.hasKeySerializers()) {
             // Only thing we have here are module-provided key serializers:
             for (Serializers serializers : _factoryConfig.keySerializers()) {
-                ser = serializers.findSerializer(config, keyType, beanDesc, null);
+                ser = serializers.findSerializer(config, keyType, beanDescRef, null);
                 if (ser != null) {
                     break;
                 }
@@ -199,12 +199,13 @@ public abstract class BasicSerializerFactory
         }
         if (ser == null) {
             // [databind#2503]: Support `@Json[De]Serialize(keyUsing)` on key type too
-            ser = _findKeySerializer(ctxt, beanDesc.getClassInfo());
+            ser = _findKeySerializer(ctxt, beanDescRef.getClassInfo());
             if (ser == null) {
                 // If no explicit serializer, see if type is JDK one for which there is
                 // explicit deserializer: if so, can avoid further annotation lookups:
                 ser = JDKKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);
                 if (ser == null) {
+                    final BeanDescription beanDesc = beanDescRef.get();
                     // Check `@JsonKey` and `@JsonValue`, in this order
                     AnnotatedMember acc = beanDesc.findJsonKeyAccessor();
                     if (acc == null) {
@@ -231,7 +232,7 @@ public abstract class BasicSerializerFactory
         // [databind#120]: Allow post-processing
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser);
+                ser = mod.modifyKeySerializer(config, keyType, beanDescRef, ser);
             }
         }
         return (ValueSerializer<Object>) ser;
@@ -285,8 +286,8 @@ public abstract class BasicSerializerFactory
      * see if we know serializer to use for given type.
      */
     protected final ValueSerializer<?> findSerializerByLookup(JavaType type,
-            SerializationConfig config, BeanDescription beanDesc, JsonFormat.Value format,
-            boolean staticTyping)
+            SerializationConfig config, BeanDescription.Supplier beanDescRef,
+            JsonFormat.Value format, boolean staticTyping)
     {
         final Class<?> raw = type.getRawClass();
         ValueSerializer<?> ser = JDKMiscSerializers.find(raw);
@@ -312,7 +313,7 @@ public abstract class BasicSerializerFactory
      *</ul>
      */
     protected final ValueSerializer<?> findSerializerByAnnotations(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc)
+            JavaType type, BeanDescription.Supplier beanDescRef)
     {
         Class<?> raw = type.getRawClass();
         // First: serializable by Jackson-specific interface?
@@ -320,7 +321,7 @@ public abstract class BasicSerializerFactory
             return JacksonSerializableSerializer.instance;
         }
         // Second: @JsonValue for any type
-        AnnotatedMember valueAccessor = beanDesc.findJsonValueAccessor();
+        AnnotatedMember valueAccessor = beanDescRef.get().findJsonValueAccessor();
         if (valueAccessor != null) {
             if (ctxt.canOverrideAccessModifiers()) {
                 ClassUtil.checkAndFixAccess(valueAccessor.getMember(),
@@ -344,7 +345,7 @@ public abstract class BasicSerializerFactory
      * mostly concrete or abstract base classes.
      */
     protected final ValueSerializer<?> findSerializerByPrimaryType(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping)
     {
         if (type.isTypeOrSubTypeOf(Calendar.class)) {
@@ -370,7 +371,7 @@ public abstract class BasicSerializerFactory
         }
 
         if (type.isTypeOrSubTypeOf(Number.class)) {
-            JsonFormat.Value format = _calculateEffectiveFormat(beanDesc, Number.class, formatOverrides);
+            JsonFormat.Value format = _calculateEffectiveFormat(beanDescRef, Number.class, formatOverrides);
 
             // 21-May-2014, tatu: Couple of alternatives actually
             switch (format.getShape()) {
@@ -383,8 +384,8 @@ public abstract class BasicSerializerFactory
             return NumberSerializer.instance;
         }
         if (type.isEnumType()) {
-            return buildEnumSerializer(ctxt, type, beanDesc,
-                    _calculateEffectiveFormat(beanDesc, Enum.class, formatOverrides));
+            return buildEnumSerializer(ctxt, type, beanDescRef,
+                    _calculateEffectiveFormat(beanDescRef, Enum.class, formatOverrides));
         }
         Class<?> raw = type.getRawClass();
         if (Map.Entry.class.isAssignableFrom(raw)) {
@@ -393,8 +394,8 @@ public abstract class BasicSerializerFactory
             // 28-Apr-2015, tatu: TypeFactory does it all for us already so
             JavaType kt = mapEntryType.containedTypeOrUnknown(0);
             JavaType vt = mapEntryType.containedTypeOrUnknown(1);
-            return buildMapEntrySerializer(ctxt, type, beanDesc,
-                    _calculateEffectiveFormat(beanDesc, Map.Entry.class, formatOverrides),
+            return buildMapEntrySerializer(ctxt, type, beanDescRef,
+                    _calculateEffectiveFormat(beanDescRef, Map.Entry.class, formatOverrides),
                     staticTyping, kt, vt);
         }
         if (ByteBuffer.class.isAssignableFrom(raw)) {
@@ -444,17 +445,17 @@ public abstract class BasicSerializerFactory
      * function is usually something else. The reason for
      */
     protected final ValueSerializer<?> findSerializerByAddonType(SerializationContext ctxt,
-            JavaType javaType, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            JavaType javaType, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping)
     {
         final TypeFactory tf = ctxt.getTypeFactory();
         if (javaType.isTypeOrSubTypeOf(Iterator.class)) {
-            return buildIteratorSerializer(ctxt, javaType, beanDesc, formatOverrides,
+            return buildIteratorSerializer(ctxt, javaType, beanDescRef, formatOverrides,
                     staticTyping,
                     tf.findFirstTypeParameter(javaType, Iterator.class));
         }
         if (javaType.isTypeOrSubTypeOf(Iterable.class)) {
-            return buildIterableSerializer(ctxt, javaType, beanDesc, formatOverrides,
+            return buildIterableSerializer(ctxt, javaType, beanDescRef, formatOverrides,
                     staticTyping,
                     tf.findFirstTypeParameter(javaType, Iterable.class));
         }
@@ -518,7 +519,7 @@ public abstract class BasicSerializerFactory
      */
 
     protected ValueSerializer<?> buildContainerSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping)
     {
         // [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,
@@ -537,7 +538,7 @@ public abstract class BasicSerializerFactory
             staticTyping = false;
         }
         ValueSerializer<Object> elementValueSerializer = _findContentSerializer(ctxt,
-                beanDesc.getClassInfo());
+                beanDescRef.getClassInfo());
         final SerializationConfig config = ctxt.getConfig();
         if (type.isMapLikeType()) { // implements java.util.Map
             MapLikeType mlt = (MapLikeType) type;
@@ -546,10 +547,10 @@ public abstract class BasicSerializerFactory
              *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.
              *  But we do need to check class annotations.
              */
-            ValueSerializer<Object> keySerializer = _findKeySerializer(ctxt, beanDesc.getClassInfo());
+            ValueSerializer<Object> keySerializer = _findKeySerializer(ctxt, beanDescRef.getClassInfo());
             if (mlt instanceof MapType) {
                 return buildMapSerializer(ctxt, (MapType) mlt,
-                        beanDesc, formatOverrides, staticTyping,
+                        beanDescRef, formatOverrides, staticTyping,
                         keySerializer, elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
@@ -557,19 +558,19 @@ public abstract class BasicSerializerFactory
             MapLikeType mlType = (MapLikeType) type;
             for (Serializers serializers : customSerializers()) { // (1) Custom
                 ser = serializers.findMapLikeSerializer(config, mlType,
-                        beanDesc, formatOverrides,
+                        beanDescRef, formatOverrides,
                         keySerializer, elementTypeSerializer, elementValueSerializer);
                 if (ser != null) {
                     break;
                 }
             }
             if (ser == null) { // (2) Annotations-based ones:
-                ser = findSerializerByAnnotations(ctxt, type, beanDesc);
+                ser = findSerializerByAnnotations(ctxt, type, beanDescRef);
             }
             if (ser != null) {
                 if (_factoryConfig.hasSerializerModifiers()) {
                     for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);
+                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDescRef, ser);
                     }
                 }
             }
@@ -579,7 +580,7 @@ public abstract class BasicSerializerFactory
             CollectionLikeType clt = (CollectionLikeType) type;
             if (clt instanceof CollectionType) {
                 return buildCollectionSerializer(ctxt, (CollectionType) clt,
-                        beanDesc, formatOverrides, staticTyping,
+                        beanDescRef, formatOverrides, staticTyping,
                         elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
@@ -587,19 +588,19 @@ public abstract class BasicSerializerFactory
             CollectionLikeType clType = (CollectionLikeType) type;
             for (Serializers serializers : customSerializers()) { // (1) Custom
                 ser = serializers.findCollectionLikeSerializer(config, clType,
-                        beanDesc, formatOverrides,
+                        beanDescRef, formatOverrides,
                         elementTypeSerializer, elementValueSerializer);
                 if (ser != null) {
                     break;
                 }
             }
             if (ser == null) { // (2) Annotations-based ones:
-                ser = findSerializerByAnnotations(ctxt, type, beanDesc);
+                ser = findSerializerByAnnotations(ctxt, type, beanDescRef);
             }
             if (ser != null) {
                 if (_factoryConfig.hasSerializerModifiers()) {
                     for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);
+                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDescRef, ser);
                     }
                 }
             }
@@ -607,7 +608,7 @@ public abstract class BasicSerializerFactory
         }
         if (type.isArrayType()) {
             return buildArraySerializer(ctxt, (ArrayType) type,
-                    beanDesc, formatOverrides, staticTyping,
+                    beanDescRef, formatOverrides, staticTyping,
                     elementTypeSerializer, elementValueSerializer);
         }
         return null;
@@ -618,7 +619,7 @@ public abstract class BasicSerializerFactory
      * {@link java.util.List} types that support efficient by-index access
      */
     protected ValueSerializer<?> buildCollectionSerializer(SerializationContext ctxt,
-            CollectionType type, BeanDescription beanDesc,  JsonFormat.Value formatOverrides,
+            CollectionType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
@@ -629,16 +630,16 @@ public abstract class BasicSerializerFactory
         // 2. Annotations (@JsonValue, @JsonDeserialize)
         // 3. Defaults
         for (Serializers serializers : customSerializers()) { // (1) Custom
-            ser = serializers.findCollectionSerializer(config, type, beanDesc, formatOverrides,
+            ser = serializers.findCollectionSerializer(config, type, beanDescRef, formatOverrides,
                     elementTypeSerializer, elementValueSerializer);
             if (ser != null) {
                 break;
             }
         }
 
-        JsonFormat.Value format = _calculateEffectiveFormat(beanDesc, Collection.class, formatOverrides);
+        JsonFormat.Value format = _calculateEffectiveFormat(beanDescRef, Collection.class, formatOverrides);
         if (ser == null) {
-            ser = findSerializerByAnnotations(ctxt, type, beanDesc); // (2) Annotations
+            ser = findSerializerByAnnotations(ctxt, type, beanDescRef); // (2) Annotations
             if (ser == null) {
                 // We may also want to use serialize Collections "as beans", if (and only if)
                 // shape specified as "POJO"
@@ -682,7 +683,7 @@ public abstract class BasicSerializerFactory
         // [databind#120]: Allow post-processing
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);
+                ser = mod.modifyCollectionSerializer(config, type, beanDescRef, ser);
             }
         }
         return ser;
@@ -724,11 +725,11 @@ public abstract class BasicSerializerFactory
      * {@link java.util.Map} types.
      */
     protected ValueSerializer<?> buildMapSerializer(SerializationContext ctxt,
-            MapType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            MapType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping, ValueSerializer<Object> keySerializer,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
-        JsonFormat.Value format = _calculateEffectiveFormat(beanDesc, Map.class, formatOverrides);
+        JsonFormat.Value format = _calculateEffectiveFormat(beanDescRef, Map.class, formatOverrides);
 
         // [databind#467]: This is where we could allow serialization "as POJO": But! It's
         // nasty to undo, and does not apply on per-property basis. So, hardly optimal
@@ -744,37 +745,38 @@ public abstract class BasicSerializerFactory
 
         final SerializationConfig config = ctxt.getConfig();
         for (Serializers serializers : customSerializers()) { // (1) Custom
-            ser = serializers.findMapSerializer(config, type, beanDesc, formatOverrides,
+            ser = serializers.findMapSerializer(config, type, beanDescRef, formatOverrides,
                     keySerializer, elementTypeSerializer, elementValueSerializer);
             if (ser != null) { break; }
         }
         if (ser == null) {
-            ser = findSerializerByAnnotations(ctxt, type, beanDesc); // (2) Annotations
+            ser = findSerializerByAnnotations(ctxt, type, beanDescRef); // (2) Annotations
             if (ser == null) {
-                Object filterId = findFilterId(config, beanDesc);
+                Object filterId = findFilterId(config, beanDescRef);
                 // 01-May-2016, tatu: Which base type to use here gets tricky, since
                 //   most often it ought to be `Map` or `EnumMap`, but due to abstract
                 //   mapping it will more likely be concrete type like `HashMap`.
                 //   So, for time being, just pass `Map.class`
+                final AnnotatedClass classInfo = beanDescRef.getClassInfo();
                 JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,
-                        beanDesc.getClassInfo());
+                        classInfo);
                 Set<String> ignored = (ignorals == null) ? null
                         : ignorals.findIgnoredForSerialization();
                 JsonIncludeProperties.Value inclusions = config.getDefaultPropertyInclusions(Map.class,
-                        beanDesc.getClassInfo());
+                        classInfo);
                 Set<String> included = (inclusions == null) ? null
                         : inclusions.getIncluded();
                 MapSerializer mapSer = MapSerializer.construct(type,
                         staticTyping, elementTypeSerializer,
                         keySerializer, elementValueSerializer, filterId,
                         ignored, included);
-                ser = _checkMapContentInclusion(ctxt, beanDesc, mapSer);
+                ser = _checkMapContentInclusion(ctxt, beanDescRef, mapSer);
             }
         }
         // [databind#120]: Allow post-processing
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);
+                ser = mod.modifyMapSerializer(config, type, beanDescRef, ser);
             }
         }
         return ser;
@@ -785,10 +787,10 @@ public abstract class BasicSerializerFactory
      * and construct re-configured {@link MapSerializer} appropriately.
      */
     protected MapSerializer _checkMapContentInclusion(SerializationContext ctxt,
-            BeanDescription beanDesc, MapSerializer mapSer)
+            BeanDescription.Supplier beanDescRef, MapSerializer mapSer)
     {
         final JavaType contentType = mapSer.getContentType();
-        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDesc,
+        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDescRef,
                 contentType, Map.class);
 
         // Need to support global legacy setting, for now:
@@ -835,7 +837,7 @@ public abstract class BasicSerializerFactory
     }
 
     protected ValueSerializer<?> buildMapEntrySerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc,  JsonFormat.Value effectiveFormat,
+            JavaType type, BeanDescription.Supplier beanDescRef,  JsonFormat.Value effectiveFormat,
             boolean staticTyping,
             JavaType keyType, JavaType valueType)
     {
@@ -848,7 +850,7 @@ public abstract class BasicSerializerFactory
                 valueType, staticTyping, ctxt.findTypeSerializer(valueType), null);
 
         final JavaType contentType = ser.getContentType();
-        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDesc,
+        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDescRef,
                 contentType, Map.Entry.class);
 
         // Need to support global legacy setting, for now:
@@ -902,7 +904,7 @@ public abstract class BasicSerializerFactory
      * @param configType Raw base type under which `configOverride`, if any, needs to be defined
      */
     protected JsonInclude.Value _findInclusionWithContent(SerializationContext ctxt,
-            BeanDescription beanDesc,
+            BeanDescription.Supplier beanDescRef,
             JavaType contentType, Class<?> configType)
     {
         final SerializationConfig config = ctxt.getConfig();
@@ -912,7 +914,7 @@ public abstract class BasicSerializerFactory
         //  Start with Container-defaults, then use more-specific value override, if any.
 
         // Start by getting global setting, overridden by Map-type-override
-        JsonInclude.Value inclV = beanDesc.findPropertyInclusion(config.getDefaultPropertyInclusion());
+        JsonInclude.Value inclV = beanDescRef.get().findPropertyInclusion(config.getDefaultPropertyInclusion());
         inclV = config.getDefaultPropertyInclusion(configType, inclV);
 
         // and then merge content-type overrides, if any. But note that there's
@@ -944,7 +946,7 @@ public abstract class BasicSerializerFactory
      * <code>Object[]</code> (and subtypes, except for String).
      */
     protected ValueSerializer<?> buildArraySerializer(SerializationContext ctxt,
-            ArrayType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            ArrayType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             boolean staticTyping,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
@@ -956,7 +958,7 @@ public abstract class BasicSerializerFactory
         ValueSerializer<?> ser = null;
 
         for (Serializers serializers : customSerializers()) { // (1) Custom
-             ser = serializers.findArraySerializer(config, type, beanDesc, formatOverrides,
+             ser = serializers.findArraySerializer(config, type, beanDescRef, formatOverrides,
                      elementTypeSerializer, elementValueSerializer);
              if (ser != null) {
                  break;
@@ -982,7 +984,7 @@ public abstract class BasicSerializerFactory
          // [databind#120]: Allow post-processing
          if (_factoryConfig.hasSerializerModifiers()) {
              for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);
+                 ser = mod.modifyArraySerializer(config, type, beanDescRef, ser);
              }
          }
          return ser;
@@ -995,7 +997,7 @@ public abstract class BasicSerializerFactory
      */
 
     public ValueSerializer<?> findReferenceSerializer(SerializationContext ctxt,
-            ReferenceType refType, BeanDescription beanDesc, JsonFormat.Value format,
+            ReferenceType refType, BeanDescription.Supplier beanDesc, JsonFormat.Value format,
             boolean staticTyping)
     {
         JavaType contentType = refType.getContentType();
@@ -1036,11 +1038,11 @@ public abstract class BasicSerializerFactory
     }
 
     protected ValueSerializer<?> _buildReferenceSerializer(SerializationContext ctxt, Class<?> baseType,
-            ReferenceType refType, BeanDescription beanDesc, boolean staticTyping,
+            ReferenceType refType, BeanDescription.Supplier beanDescRef, boolean staticTyping,
             TypeSerializer contentTypeSerializer, ValueSerializer<Object> contentSerializer)
     {
         final JavaType contentType = refType.getReferencedType();
-        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDesc,
+        JsonInclude.Value inclV = _findInclusionWithContent(ctxt, beanDescRef,
                 contentType, baseType);
 
         // Need to support global legacy setting, for now:
@@ -1101,7 +1103,7 @@ public abstract class BasicSerializerFactory
      */
 
     protected ValueSerializer<?> buildIteratorSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            JavaType type, BeanDescription.Supplier beanDesc, JsonFormat.Value formatOverrides,
             boolean staticTyping,
             JavaType valueType)
     {
@@ -1110,8 +1112,8 @@ public abstract class BasicSerializerFactory
     }
 
     protected ValueSerializer<?> buildIterableSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value effectiveFormat,
-            boolean staticTyping,
+            JavaType type, BeanDescription.Supplier beanDescRef,
+            JsonFormat.Value effectiveFormat, boolean staticTyping,
             JavaType valueType)
     {
         return new IterableSerializer(valueType, staticTyping,
@@ -1119,7 +1121,7 @@ public abstract class BasicSerializerFactory
     }
 
     protected ValueSerializer<?> buildEnumSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value effectiveFormat)
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value effectiveFormat)
     {
         // As per [databind#24], may want to use alternate shape, serialize as JSON Object.
         // Challenge here is that EnumSerializer does not know how to produce
@@ -1127,6 +1129,7 @@ public abstract class BasicSerializerFactory
         // otherwise pass it to EnumSerializer.
         JsonFormat.Shape shape = effectiveFormat.getShape();
         if (shape == JsonFormat.Shape.POJO || shape == JsonFormat.Shape.OBJECT) {
+            final BeanDescription beanDesc = beanDescRef.get();
             // one special case: suppress serialization of "getDeclaringClass()"...
             ((BasicBeanDescription) beanDesc).removeProperty("declaringClass");
             // [databind#2787]: remove self-referencing enum fields introduced by annotation flattening of mixins
@@ -1139,10 +1142,11 @@ public abstract class BasicSerializerFactory
         @SuppressWarnings("unchecked")
         Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();
         final SerializationConfig config = ctxt.getConfig();
-        ValueSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, effectiveFormat);
+        ValueSerializer<?> ser = EnumSerializer.construct(enumClass, config,
+                beanDescRef.get(), effectiveFormat);
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);
+                ser = mod.modifyEnumSerializer(config, type, beanDescRef, ser);
             }
         }
         return ser;
@@ -1188,10 +1192,10 @@ public abstract class BasicSerializerFactory
      *
      * @since 3.0
      */
-    protected JsonFormat.Value _calculateEffectiveFormat(BeanDescription beanDesc,
+    protected JsonFormat.Value _calculateEffectiveFormat(BeanDescription.Supplier beanDescRef,
             Class<?> baseType, JsonFormat.Value formatOverrides)
     {
-        JsonFormat.Value fromType = beanDesc.findExpectedFormat(baseType);
+        JsonFormat.Value fromType = beanDescRef.get().findExpectedFormat(baseType);
         if (formatOverrides == null) {
             return fromType;
         }
@@ -1228,9 +1232,9 @@ public abstract class BasicSerializerFactory
      * Method called to find filter that is configured to be used with bean
      * serializer being built, if any.
      */
-    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {
+    protected Object findFilterId(SerializationConfig config, BeanDescription.Supplier beanDescRef) {
         return config.getAnnotationIntrospector().findFilterId(config,
-                (Annotated)beanDesc.getClassInfo());
+                (Annotated)beanDescRef.getClassInfo());
     }
 
     /**
@@ -1240,9 +1244,10 @@ public abstract class BasicSerializerFactory
      * (instead of dynamic runtime types).
      */
     protected boolean usesStaticTyping(SerializationConfig config,
-            BeanDescription beanDesc)
+            BeanDescription.Supplier beanDescRef)
     {
-        JsonSerialize.Typing t = config.getAnnotationIntrospector().findSerializationTyping(config, beanDesc.getClassInfo());
+        JsonSerialize.Typing t = config.getAnnotationIntrospector()
+                .findSerializationTyping(config, beanDescRef.getClassInfo());
         if (t != null) {
             switch (t) {
             case DYNAMIC:
diff --git a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
index ff519c8ac..7d8499580 100644
--- a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
@@ -129,10 +129,10 @@ public class BeanSerializerFactory
     @Override
     @SuppressWarnings("unchecked")
     public ValueSerializer<Object> createSerializer(SerializationContext ctxt, JavaType origType,
-            BeanDescription beanDesc, JsonFormat.Value formatOverrides)
+            BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
     {
         // Very first thing, let's check if there is explicit serializer annotation:
-        ValueSerializer<?> ser = findSerializerFromAnnotation(ctxt, beanDesc.getClassInfo());
+        ValueSerializer<?> ser = findSerializerFromAnnotation(ctxt, beanDescRef.getClassInfo());
         if (ser != null) {
             return (ValueSerializer<Object>) ser;
         }
@@ -146,9 +146,9 @@ public class BeanSerializerFactory
             type = origType;
         } else {
             try {
-                type = intr.refineSerializationType(config, beanDesc.getClassInfo(), origType);
+                type = intr.refineSerializationType(config, beanDescRef.getClassInfo(), origType);
             } catch (JacksonException e) {
-                return ctxt.reportBadTypeDefinition(beanDesc, e.getMessage());
+                return ctxt.reportBadTypeDefinition(beanDescRef, e.getMessage());
             }
         }
         if (type == origType) { // no changes, won't force static typing
@@ -156,32 +156,32 @@ public class BeanSerializerFactory
         } else { // changes; assume static typing; plus, need to re-introspect if class differs
             staticTyping = true;
             if (!type.hasRawClass(origType.getRawClass())) {
-                beanDesc = ctxt.introspectBeanDescription(type);
+                beanDescRef = ctxt.lazyIntrospectBeanDescription(type);
             }
         }
         // Slight detour: do we have a Converter to consider?
-        Converter<Object,Object> conv = beanDesc.findSerializationConverter();
+        Converter<Object,Object> conv = beanDescRef.get().findSerializationConverter();
         if (conv != null) { // yup, need converter
             JavaType delegateType = conv.getOutputType(ctxt.getTypeFactory());
 
             // One more twist, as per [databind#288]; probably need to get new BeanDesc
             if (!delegateType.hasRawClass(type.getRawClass())) {
-                beanDesc = ctxt.introspectBeanDescription(delegateType);
+                beanDescRef = ctxt.lazyIntrospectBeanDescription(delegateType);
                 // [#359]: explicitly check (again) for @JsonSerialize...
-                ser = findSerializerFromAnnotation(ctxt, beanDesc.getClassInfo());
+                ser = findSerializerFromAnnotation(ctxt, beanDescRef.getClassInfo());
             }
             // [databind#731]: Should skip if nominally java.lang.Object
             if ((ser == null) && !delegateType.isJavaLangObject()) {
-                ser = _createSerializer2(ctxt, beanDesc, delegateType, formatOverrides, true);
+                ser = _createSerializer2(ctxt, beanDescRef, delegateType, formatOverrides, true);
             }
             return new StdDelegatingSerializer(conv, delegateType, ser, null);
         }
         // No, regular serializer
-        return (ValueSerializer<Object>) _createSerializer2(ctxt, beanDesc, type, formatOverrides, staticTyping);
+        return (ValueSerializer<Object>) _createSerializer2(ctxt, beanDescRef, type, formatOverrides, staticTyping);
     }
 
     protected ValueSerializer<?> _createSerializer2(SerializationContext ctxt,
-            BeanDescription beanDesc, JavaType type, JsonFormat.Value formatOverrides,
+            BeanDescription.Supplier beanDescRef, JavaType type, JsonFormat.Value formatOverrides,
             boolean staticTyping)
     {
         ValueSerializer<?> ser = null;
@@ -191,21 +191,22 @@ public class BeanSerializerFactory
         // (note: called method checks for module-provided serializers)
         if (type.isContainerType()) {
             if (!staticTyping) {
-                staticTyping = usesStaticTyping(config, beanDesc);
+                staticTyping = usesStaticTyping(config, beanDescRef);
             }
             // 03-Aug-2012, tatu: As per [databind#40], may require POJO serializer...
-            ser =  buildContainerSerializer(ctxt, type, beanDesc, formatOverrides, staticTyping);
+            ser =  buildContainerSerializer(ctxt, type, beanDescRef, formatOverrides, staticTyping);
             // Will return right away, since called method does post-processing:
             if (ser != null) {
                 return ser;
             }
         } else {
             if (type.isReferenceType()) {
-                ser = findReferenceSerializer(ctxt, (ReferenceType) type, beanDesc, formatOverrides, staticTyping);
+                ser = findReferenceSerializer(ctxt, (ReferenceType) type, beanDescRef,
+                        formatOverrides, staticTyping);
             } else {
                 // Modules may provide serializers of POJO types:
                 for (Serializers serializers : customSerializers()) {
-                    ser = serializers.findSerializer(config, type, beanDesc, formatOverrides);
+                    ser = serializers.findSerializer(config, type, beanDescRef, formatOverrides);
                     if (ser != null) {
                         break;
                     }
@@ -214,7 +215,7 @@ public class BeanSerializerFactory
             // 25-Jun-2015, tatu: Then JacksonSerializable, @JsonValue etc. NOTE! Prior to 2.6,
             //    this call was BEFORE custom serializer lookup, which was wrong.
             if (ser == null) {
-                ser = findSerializerByAnnotations(ctxt, type, beanDesc);
+                ser = findSerializerByAnnotations(ctxt, type, beanDescRef);
             }
         }
 
@@ -222,17 +223,17 @@ public class BeanSerializerFactory
             // Otherwise, we will check "primary types"; both marker types that
             // indicate specific handling (JacksonSerializable), or main types that have
             // precedence over container types
-            ser = findSerializerByLookup(type, config, beanDesc, formatOverrides, staticTyping);
+            ser = findSerializerByLookup(type, config, beanDescRef, formatOverrides, staticTyping);
             if (ser == null) {
-                ser = findSerializerByPrimaryType(ctxt, type, beanDesc, formatOverrides, staticTyping);
+                ser = findSerializerByPrimaryType(ctxt, type, beanDescRef, formatOverrides, staticTyping);
                 if (ser == null) {
                     // And this is where this class comes in: if type is not a
                     // known "primary JDK type", perhaps it's a bean? We can still
                     // get a null, if we can't find a single suitable bean property.
-                    ser = constructBeanOrAddOnSerializer(ctxt, type, beanDesc, formatOverrides, staticTyping);
+                    ser = constructBeanOrAddOnSerializer(ctxt, type, beanDescRef, formatOverrides, staticTyping);
                     // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                     if (ser == null) {
-                        ser = ctxt.getUnknownTypeSerializer(beanDesc.getBeanClass());
+                        ser = ctxt.getUnknownTypeSerializer(beanDescRef.getBeanClass());
                     }
                 }
             }
@@ -240,7 +241,7 @@ public class BeanSerializerFactory
         // can not be null any more (always get at least "unknown" serializer)
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                ser = mod.modifySerializer(config, beanDesc, ser);
+                ser = mod.modifySerializer(config, beanDescRef, ser);
             }
         }
         return ser;
@@ -270,11 +271,11 @@ public class BeanSerializerFactory
      */
     @SuppressWarnings("unchecked")
     protected ValueSerializer<Object> constructBeanOrAddOnSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value format, boolean staticTyping)
+            JavaType type,BeanDescription.Supplier beanDescRef, JsonFormat.Value format, boolean staticTyping)
     {
         // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
         // 05-Jul-2012, tatu: ... but we should be able to just return "unknown type" serializer, right?
-        if (beanDesc.getBeanClass() == Object.class) {
+        if (beanDescRef.getBeanClass() == Object.class) {
             return ctxt.getUnknownTypeSerializer(Object.class);
 //            throw new IllegalArgumentException("Cannot create bean serializer for Object.class");
         }
@@ -286,7 +287,7 @@ public class BeanSerializerFactory
                 return null;
             }
         }
-        ValueSerializer<?> ser = _findUnsupportedTypeSerializer(ctxt, type, beanDesc);
+        ValueSerializer<?> ser = _findUnsupportedTypeSerializer(ctxt, type, beanDescRef);
         if (ser != null) {
             return (ValueSerializer<Object>) ser;
         }
@@ -302,23 +303,23 @@ public class BeanSerializerFactory
             return (ValueSerializer<Object>)(ValueSerializer<?>) MapEntryAsPOJOSerializer.create(ctxt, type);
         }
         final SerializationConfig config = ctxt.getConfig();
-        BeanSerializerBuilder builder = constructBeanSerializerBuilder(config, beanDesc);
+        BeanSerializerBuilder builder = constructBeanSerializerBuilder(config, beanDescRef);
 
         // First: any detectable (auto-detect, annotations) properties to serialize?
-        List<BeanPropertyWriter> props = findBeanProperties(ctxt, beanDesc, builder);
+        List<BeanPropertyWriter> props = findBeanProperties(ctxt, beanDescRef, builder);
         if (props == null) {
             props = new ArrayList<BeanPropertyWriter>();
         } else {
-            props = removeOverlappingTypeIds(ctxt, beanDesc, builder, props);
+            props = removeOverlappingTypeIds(ctxt, beanDescRef, builder, props);
         }
 
         // [databind#638]: Allow injection of "virtual" properties:
-        ctxt.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);
+        ctxt.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDescRef.getClassInfo(), props);
 
         // allow modification bean properties to serialize
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                props = mod.changeProperties(config, beanDesc, props);
+                props = mod.changeProperties(config, beanDescRef, props);
             }
         }
 
@@ -326,25 +327,25 @@ public class BeanSerializerFactory
 
         // 10-Dec-2021, tatu: [databind#3305] Some JDK types need special help
         //    (initially, `CharSequence` with its `isEmpty()` default impl)
-        props = filterUnwantedJDKProperties(config, beanDesc, props);
-        props = filterBeanProperties(config, beanDesc, props);
+        props = filterUnwantedJDKProperties(config, beanDescRef, props);
+        props = filterBeanProperties(config, beanDescRef, props);
 
         // Need to allow reordering of properties to serialize
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                props = mod.orderProperties(config, beanDesc, props);
+                props = mod.orderProperties(config, beanDescRef, props);
             }
         }
 
         // And if Object Id is needed, some preparation for that as well: better
         // do before view handling, mostly for the custom id case which needs
         // access to a property
-        builder.setObjectIdWriter(constructObjectIdHandler(ctxt, beanDesc, props));
+        builder.setObjectIdWriter(constructObjectIdHandler(ctxt, beanDescRef, props));
 
         builder.setProperties(props);
-        builder.setFilterId(findFilterId(config, beanDesc));
+        builder.setFilterId(findFilterId(config, beanDescRef));
 
-        AnnotatedMember anyGetter = beanDesc.findAnyGetter();
+        AnnotatedMember anyGetter = beanDescRef.get().findAnyGetter();
         if (anyGetter != null) {
             JavaType anyType = anyGetter.getType();
             // copied from BasicSerializerFactory.buildMapSerializer():
@@ -389,7 +390,9 @@ public class BeanSerializerFactory
                 // Otherwise just add it at the end, but won't be sorted...
                 // This is case where JsonAnyGetter is private/protected,
                 BeanPropertyDefinition anyGetterPropDef = SimpleBeanPropertyDefinition.construct(config, anyGetter, name);
-                BeanPropertyWriter anyPropWriter = _constructWriter(ctxt, anyGetterPropDef, new PropertyBuilder(config, beanDesc), staticTyping, anyGetter);
+                BeanPropertyWriter anyPropWriter = _constructWriter(ctxt,
+                        anyGetterPropDef, new PropertyBuilder(config, beanDescRef.get()),
+                        staticTyping, anyGetter);
                 props.add(new AnyGetterWriter(anyPropWriter, anyProp, anyGetter, anySer));
             }
         }
@@ -399,15 +402,15 @@ public class BeanSerializerFactory
         // Finally: let interested parties mess with the result bit more...
         if (_factoryConfig.hasSerializerModifiers()) {
             for (ValueSerializerModifier mod : _factoryConfig.serializerModifiers()) {
-                builder = mod.updateBuilder(config, beanDesc, builder);
+                builder = mod.updateBuilder(config, beanDescRef, builder);
             }
         }
 
         try {
             ser = builder.build();
         } catch (RuntimeException e) {
-            ctxt.reportBadTypeDefinition(beanDesc, "Failed to construct BeanSerializer for %s: (%s) %s",
-                    beanDesc.getType(), e.getClass().getName(), e.getMessage());
+            ctxt.reportBadTypeDefinition(beanDescRef, "Failed to construct BeanSerializer for %s: (%s) %s",
+                    beanDescRef.getType(), e.getClass().getName(), e.getMessage());
         }
         if (ser == null) {
             // 21-Aug-2020, tatu: Empty Records should be fine tho
@@ -418,12 +421,12 @@ public class BeanSerializerFactory
                 return builder.createDummy();
             }
             // [databind#2390]: Need to consider add-ons before fallback "empty" serializer
-            ser = (ValueSerializer<Object>) findSerializerByAddonType(ctxt, type, beanDesc, format, staticTyping);
+            ser = (ValueSerializer<Object>) findSerializerByAddonType(ctxt, type, beanDescRef, format, staticTyping);
             if (ser == null) {
                 // If we get this far, there were no properties found, so no regular BeanSerializer
                 // would be constructed. But, couple of exceptions.
                 // First: if there are known annotations, just create 'empty bean' serializer
-                if (beanDesc.hasKnownClassAnnotations()) {
+                if (beanDescRef.get().hasKnownClassAnnotations()) {
                     return builder.createDummy();
                 }
             }
@@ -432,9 +435,9 @@ public class BeanSerializerFactory
     }
 
     protected ObjectIdWriter constructObjectIdHandler(SerializationContext ctxt,
-            BeanDescription beanDesc, List<BeanPropertyWriter> props)
+            BeanDescription.Supplier beanDescRef, List<BeanPropertyWriter> props)
     {
-        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();
+        ObjectIdInfo objectIdInfo = beanDescRef.get().getObjectIdInfo();
         if (objectIdInfo == null) {
             return null;
         }
@@ -450,7 +453,7 @@ public class BeanSerializerFactory
                 if (i == len) {
                     throw new IllegalArgumentException(String.format(
 "Invalid Object Id definition for %s: cannot find property with name %s",
-ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
+ClassUtil.getTypeDescription(beanDescRef.getType()), ClassUtil.name(propName)));
                 }
                 BeanPropertyWriter prop = props.get(i);
                 if (propName.equals(prop.getName())) {
@@ -474,7 +477,7 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
         JavaType type = ctxt.constructType(implClass);
         // Could require type to be passed explicitly, but we should be able to find it too:
         JavaType idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];
-        gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);
+        gen = ctxt.objectIdGeneratorInstance(beanDescRef.getClassInfo(), objectIdInfo);
         return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,
                 objectIdInfo.getAlwaysAsId());
     }
@@ -491,14 +494,14 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
     }
 
     protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,
-            BeanDescription beanDesc)
+            BeanDescription.Supplier beanDescRef)
     {
-        return new PropertyBuilder(config, beanDesc);
+        return new PropertyBuilder(config, beanDescRef.get());
     }
 
     protected BeanSerializerBuilder constructBeanSerializerBuilder(SerializationConfig config,
-            BeanDescription beanDesc) {
-        return new BeanSerializerBuilder(config, beanDesc);
+            BeanDescription.Supplier beanDescRef) {
+        return new BeanSerializerBuilder(config, beanDescRef.get());
     }
 
     /*
@@ -525,17 +528,17 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
      * Can be overridden to implement custom detection schemes.
      */
     protected List<BeanPropertyWriter> findBeanProperties(SerializationContext ctxt,
-            BeanDescription beanDesc, BeanSerializerBuilder builder)
+            BeanDescription.Supplier beanDescRef, BeanSerializerBuilder builder)
     {
-        List<BeanPropertyDefinition> properties = beanDesc.findProperties();
+        List<BeanPropertyDefinition> properties = beanDescRef.get().findProperties();
         final SerializationConfig config = ctxt.getConfig();
 
         // ignore specified types
-        removeIgnorableTypes(ctxt, beanDesc, properties);
+        removeIgnorableTypes(ctxt, beanDescRef, properties);
 
         // and possibly remove ones without matching mutator...
         if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {
-            removeSetterlessGetters(config, beanDesc, properties);
+            removeSetterlessGetters(config, beanDescRef, properties);
         }
 
         // nothing? can't proceed (caller may or may not throw an exception)
@@ -543,8 +546,8 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
             return null;
         }
         // null is for value type serializer, which we don't have access to from here (ditto for bean prop)
-        boolean staticTyping = usesStaticTyping(config, beanDesc);
-        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);
+        boolean staticTyping = usesStaticTyping(config, beanDescRef);
+        PropertyBuilder pb = constructPropertyBuilder(config, beanDescRef);
 
         ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());
         for (BeanPropertyDefinition property : properties) {
@@ -581,20 +584,21 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
      * checks annotations class may have.
      */
     protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,
-            BeanDescription beanDesc, List<BeanPropertyWriter> props)
+            BeanDescription.Supplier beanDescRef, List<BeanPropertyWriter> props)
     {
+        final Class<?> beanClass = beanDescRef.getBeanClass();
+        final AnnotatedClass classInfo = beanDescRef.getClassInfo();
+        
         // 01-May-2016, tatu: Which base type to use here gets tricky, since
         //   it may often make most sense to use general type for overrides,
         //   but what we have here may be more specific impl type. But for now
         //   just use it as is.
-        JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(beanDesc.getBeanClass(),
-                beanDesc.getClassInfo());
+        JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(beanClass, classInfo);
         Set<String> ignored = null;
         if (ignorals != null) {
             ignored = ignorals.findIgnoredForSerialization();
         }
-        JsonIncludeProperties.Value inclusions = config.getDefaultPropertyInclusions(beanDesc.getBeanClass(),
-                beanDesc.getClassInfo());
+        JsonIncludeProperties.Value inclusions = config.getDefaultPropertyInclusions(beanClass, classInfo);
         Set<String> included = null;
         if (inclusions != null) {
             included = inclusions.getIncluded();
@@ -616,14 +620,12 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
      *<p>
      * See issue <a href="https://github.com/FasterXML/jackson-databind/issues/3305">
      * databind-3305</a> for details.
-     *
-     * @since 2.13.1
      */
     protected List<BeanPropertyWriter> filterUnwantedJDKProperties(SerializationConfig config,
-            BeanDescription beanDesc, List<BeanPropertyWriter> props)
+            BeanDescription.Supplier beanDescRef, List<BeanPropertyWriter> props)
     {
         // First, only consider something that implements `CharSequence`
-        if (beanDesc.getType().isTypeOrSubTypeOf(CharSequence.class)) {
+        if (beanDescRef.getType().isTypeOrSubTypeOf(CharSequence.class)) {
             // And only has a single property from "isEmpty()" default method
             if (props.size() == 1) {
                 BeanPropertyWriter prop = props.get(0);
@@ -686,7 +688,8 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
      * annotation but can be supplied by module-provided introspectors too.
      * Starting with 2.8 there are also "Config overrides" to consider.
      */
-    protected void removeIgnorableTypes(SerializationContext ctxt, BeanDescription beanDesc,
+    protected void removeIgnorableTypes(SerializationContext ctxt,
+            BeanDescription.Supplier beanDescRef,
             List<BeanPropertyDefinition> properties)
     {
         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
@@ -727,7 +730,8 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
     /**
      * Helper method that will remove all properties that do not have a mutator.
      */
-    protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc,
+    protected void removeSetterlessGetters(SerializationConfig config,
+            BeanDescription.Supplier beanDescRef,
             List<BeanPropertyDefinition> properties)
     {
         // one caveat: only remove implicit properties;
@@ -740,7 +744,7 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
      * Added to resolve [databind#222]
      */
     protected List<BeanPropertyWriter> removeOverlappingTypeIds(SerializationContext ctxt,
-            BeanDescription beanDesc, BeanSerializerBuilder builder,
+            BeanDescription.Supplier beanDescRef, BeanSerializerBuilder builder,
             List<BeanPropertyWriter> props)
     {
         for (int i = 0, end = props.size(); i < end; ++i) {
@@ -804,7 +808,7 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
     }
 
     protected ValueSerializer<?> _findUnsupportedTypeSerializer(SerializationContext ctxt,
-            JavaType type, BeanDescription beanDesc)
+            JavaType type, BeanDescription.Supplier beanDescRef)
     {
         // 05-May-2020, tatu: Should we check for possible Shape override to "POJO"?
         //   (to let users force 'serialize-as-POJO'?
@@ -821,8 +825,6 @@ ClassUtil.getTypeDescription(beanDesc.getType()), ClassUtil.name(propName)));
 
     /* Helper method used for preventing attempts to serialize various Jackson
      * processor things which are not generally serializable.
-     *
-     * @since 2.13
      */
     protected boolean _isUnserializableJacksonType(SerializationContext ctxt,
             JavaType type)
diff --git a/src/main/java/tools/jackson/databind/ser/SerializerFactory.java b/src/main/java/tools/jackson/databind/ser/SerializerFactory.java
index f986c943d..4e9b07d4b 100644
--- a/src/main/java/tools/jackson/databind/ser/SerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/SerializerFactory.java
@@ -28,7 +28,7 @@ public abstract class SerializerFactory
      * @since 3.0 (last argument added)
      */
     public abstract ValueSerializer<Object> createSerializer(SerializationContext ctxt,
-            JavaType baseType, BeanDescription beanDesc, JsonFormat.Value formatOverride);
+            JavaType baseType, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverride);
 
     /**
      * Method called to create serializer to use for serializing JSON property names (which must
@@ -100,7 +100,7 @@ public abstract class SerializerFactory
     @Deprecated // since 3.0
     public ValueSerializer<Object> createSerializer(SerializationContext ctxt, JavaType baseType)
     {
-        BeanDescription beanDesc = ctxt.introspectBeanDescription(baseType);
-        return createSerializer(ctxt, baseType, beanDesc, null);
+        return createSerializer(ctxt, baseType,
+                ctxt.lazyIntrospectBeanDescription(baseType), null);
     }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/Serializers.java b/src/main/java/tools/jackson/databind/ser/Serializers.java
index 25aa6c902..49256368f 100644
--- a/src/main/java/tools/jackson/databind/ser/Serializers.java
+++ b/src/main/java/tools/jackson/databind/ser/Serializers.java
@@ -23,7 +23,7 @@ public interface Serializers
      *
      * @param type Fully resolved type of instances to serialize
      * @param config Serialization configuration in use
-     * @param beanDesc Additional information about type
+     * @param beanDescRef Accessor to additional information about type
      * @param formatOverrides (nullable) Optional format overrides (usually from property definition),
      *     to change definitions that {@code beanDesc} may have (and which are NOT included). Usually
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
@@ -32,22 +32,7 @@ public interface Serializers
      *    does not recognize or support type
      */
     default ValueSerializer<?> findSerializer(SerializationConfig config,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides)
-    {
-        return null;
-    }
-
-    /**
-     * Method called by serialization framework first time a serializer is needed for
-     * given {@link ReferenceType}
-     *
-     * @param formatOverrides (nullable) Optional format overrides (usually from property definition),
-     *     to change definitions that {@code beanDesc} may have (and which are NOT included). Usually
-     *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
-     */
-    default ValueSerializer<?> findReferenceSerializer(SerializationConfig config,
-            ReferenceType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
-            TypeSerializer contentTypeSerializer, ValueSerializer<Object> contentValueSerializer)
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
     {
         return null;
     }
@@ -62,8 +47,8 @@ public interface Serializers
      *     to change definitions that {@code beanDesc} may have (and which are NOT included). Usually
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
      */
-    default ValueSerializer<?> findArraySerializer(SerializationConfig config, ArrayType type,
-            BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+    default ValueSerializer<?> findArraySerializer(SerializationConfig config,
+            ArrayType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
         return null;
@@ -80,7 +65,7 @@ public interface Serializers
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
      */
     default ValueSerializer<?> findCollectionSerializer(SerializationConfig config,
-            CollectionType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            CollectionType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
         return null;
@@ -98,7 +83,7 @@ public interface Serializers
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
      */
     default ValueSerializer<?> findCollectionLikeSerializer(SerializationConfig config,
-            CollectionLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            CollectionLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
         return null;
@@ -115,7 +100,7 @@ public interface Serializers
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
      */
     default ValueSerializer<?> findMapSerializer(SerializationConfig config,
-            MapType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            MapType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             ValueSerializer<Object> keySerializer,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
@@ -134,13 +119,28 @@ public interface Serializers
      *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
      */
     default ValueSerializer<?> findMapLikeSerializer(SerializationConfig config,
-            MapLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+            MapLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
             ValueSerializer<Object> keySerializer,
             TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
     {
         return null;
     }
 
+    /**
+     * Method called by serialization framework first time a serializer is needed for
+     * given {@link ReferenceType}
+     *
+     * @param formatOverrides (nullable) Optional format overrides (usually from property definition),
+     *     to change definitions that {@code beanDesc} may have (and which are NOT included). Usually
+     *     combined calling {@code Serializers.Base#calculateEffectiveFormat}.
+     */
+    default ValueSerializer<?> findReferenceSerializer(SerializationConfig config,
+            ReferenceType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
+            TypeSerializer contentTypeSerializer, ValueSerializer<Object> contentValueSerializer)
+    {
+        return null;
+    }
+
     /**
      * Method called in case that a given type or property is declared to use shape
      * {@code JsonFormat.Shape.POJO} and is expected to be serialized "as POJO", that is,
@@ -151,7 +151,7 @@ public interface Serializers
      * @since 3.0
      */
     default ValueSerializer<?> findExplicitPOJOSerializer(SerializationConfig config,
-            JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides)
+            JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
     {
         return null;
     }
@@ -165,21 +165,21 @@ public interface Serializers
     {
         @Override
         public ValueSerializer<?> findSerializer(SerializationConfig config,
-                JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides)
+                JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
         {
             return null;
         }
 
         @Override
         public ValueSerializer<?> findReferenceSerializer(SerializationConfig config,
-                ReferenceType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                ReferenceType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 TypeSerializer contentTypeSerializer, ValueSerializer<Object> contentValueSerializer) {
             return null;
         }
 
         @Override
         public ValueSerializer<?> findArraySerializer(SerializationConfig config,
-                ArrayType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                ArrayType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
         {
             return null;
@@ -187,7 +187,7 @@ public interface Serializers
 
         @Override
         public ValueSerializer<?> findCollectionSerializer(SerializationConfig config,
-                CollectionType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                CollectionType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
         {
             return null;
@@ -195,7 +195,7 @@ public interface Serializers
 
         @Override
         public ValueSerializer<?> findCollectionLikeSerializer(SerializationConfig config,
-                CollectionLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                CollectionLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
         {
             return null;
@@ -203,7 +203,7 @@ public interface Serializers
 
         @Override
         public ValueSerializer<?> findMapSerializer(SerializationConfig config,
-                MapType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                MapType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 ValueSerializer<Object> keySerializer,
                 TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
         {
@@ -212,7 +212,7 @@ public interface Serializers
 
         @Override
         public ValueSerializer<?> findMapLikeSerializer(SerializationConfig config,
-                MapLikeType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides,
+                MapLikeType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides,
                 ValueSerializer<Object> keySerializer,
                 TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
         {
@@ -221,7 +221,7 @@ public interface Serializers
 
         @Override
         public ValueSerializer<?> findExplicitPOJOSerializer(SerializationConfig config,
-                JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides)
+                JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides)
         {
             return null;
         }
@@ -238,10 +238,10 @@ public interface Serializers
          * possible per-property overrides (in this order of precedence from lowest
          * to highest).
          */
-        protected JsonFormat.Value calculateEffectiveFormat(BeanDescription beanDesc,
+        protected JsonFormat.Value calculateEffectiveFormat(BeanDescription.Supplier beanDescRef,
                 Class<?> baseType, JsonFormat.Value formatOverrides)
         {
-            JsonFormat.Value fromType = beanDesc.findExpectedFormat(baseType);
+            JsonFormat.Value fromType = beanDescRef.get().findExpectedFormat(baseType);
             if (formatOverrides == null) {
                 return fromType;
             }
diff --git a/src/main/java/tools/jackson/databind/ser/ValueSerializerModifier.java b/src/main/java/tools/jackson/databind/ser/ValueSerializerModifier.java
index 86e3830e0..81be53ebb 100644
--- a/src/main/java/tools/jackson/databind/ser/ValueSerializerModifier.java
+++ b/src/main/java/tools/jackson/databind/ser/ValueSerializerModifier.java
@@ -56,7 +56,7 @@ public abstract class ValueSerializerModifier
      * modifiers.
      */
     public List<BeanPropertyWriter> changeProperties(SerializationConfig config,
-            BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
+            BeanDescription.Supplier beanDesc, List<BeanPropertyWriter> beanProperties) {
         return beanProperties;
     }
 
@@ -71,7 +71,7 @@ public abstract class ValueSerializerModifier
      * modifiers.
      */
     public List<BeanPropertyWriter> orderProperties(SerializationConfig config,
-            BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {
+            BeanDescription.Supplier beanDesc, List<BeanPropertyWriter> beanProperties) {
         return beanProperties;
     }
 
@@ -85,7 +85,7 @@ public abstract class ValueSerializerModifier
      * some modifications.
      */
     public BeanSerializerBuilder updateBuilder(SerializationConfig config,
-            BeanDescription beanDesc, BeanSerializerBuilder builder) {
+            BeanDescription.Supplier beanDesc, BeanSerializerBuilder builder) {
         return builder;
     }
 
@@ -102,7 +102,7 @@ public abstract class ValueSerializerModifier
      * methods; mostly for JDK types like {@link java.util.Iterator} and such.
      */
     public ValueSerializer<?> modifySerializer(SerializationConfig config,
-            BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
@@ -128,32 +128,32 @@ public abstract class ValueSerializerModifier
      *   in, or an instance method constructed.
      */
     public ValueSerializer<?> modifyArraySerializer(SerializationConfig config,
-            ArrayType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            ArrayType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
     public ValueSerializer<?> modifyCollectionSerializer(SerializationConfig config,
-            CollectionType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            CollectionType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
     public ValueSerializer<?> modifyCollectionLikeSerializer(SerializationConfig config,
-            CollectionLikeType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            CollectionLikeType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
     public ValueSerializer<?> modifyMapSerializer(SerializationConfig config,
-            MapType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            MapType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
     public ValueSerializer<?> modifyMapLikeSerializer(SerializationConfig config,
-            MapLikeType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            MapLikeType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
     public ValueSerializer<?> modifyEnumSerializer(SerializationConfig config,
-            JavaType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            JavaType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 
@@ -173,7 +173,7 @@ public abstract class ValueSerializerModifier
      *   in, or an instance method constructed.
      */
     public ValueSerializer<?> modifyKeySerializer(SerializationConfig config,
-            JavaType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+            JavaType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
         return serializer;
     }
 }
diff --git a/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java b/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
index f8206c382..576e32805 100644
--- a/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
+++ b/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
@@ -38,12 +38,12 @@ public class MapConversion4878Test extends DatabindTestUtil
     static class Serializers4878 extends SimpleSerializers {
         @Override
         public ValueSerializer<?> findSerializer(SerializationConfig config,
-                JavaType type, BeanDescription beanDesc, JsonFormat.Value formatOverrides) {
+                JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides) {
             Class<?> rawClass = type.getRawClass();
             if (MapWrapper4878.class.isAssignableFrom(rawClass)) {
                 return new StdDelegatingSerializer(new WrapperConverter4878());
             }
-            return super.findSerializer(config, type, beanDesc, formatOverrides);
+            return super.findSerializer(config, type, beanDescRef, formatOverrides);
         }
     }
 
diff --git a/src/test/java/tools/jackson/databind/jsontype/JsonTypeInfoCustomResolver2811Test.java b/src/test/java/tools/jackson/databind/jsontype/JsonTypeInfoCustomResolver2811Test.java
index a1a9d3856..e27ad5312 100644
--- a/src/test/java/tools/jackson/databind/jsontype/JsonTypeInfoCustomResolver2811Test.java
+++ b/src/test/java/tools/jackson/databind/jsontype/JsonTypeInfoCustomResolver2811Test.java
@@ -13,7 +13,7 @@ import static org.junit.jupiter.api.Assertions.*;
 
 public class JsonTypeInfoCustomResolver2811Test extends DatabindTestUtil
 {
-    interface Vehicle { }
+    public interface Vehicle { }
 
     static class Car implements Vehicle {
         public int wheels;
diff --git a/src/test/java/tools/jackson/databind/module/TestTypeModifiers.java b/src/test/java/tools/jackson/databind/module/TestTypeModifiers.java
index 2ab760c81..ba90993a0 100644
--- a/src/test/java/tools/jackson/databind/module/TestTypeModifiers.java
+++ b/src/test/java/tools/jackson/databind/module/TestTypeModifiers.java
@@ -34,7 +34,7 @@ public class TestTypeModifiers extends DatabindTestUtil
             context.addSerializers(new Serializers.Base() {
                 @Override
                 public ValueSerializer<?> findMapLikeSerializer(SerializationConfig config,
-                        MapLikeType type, BeanDescription beanDesc, JsonFormat.Value format,
+                        MapLikeType type, BeanDescription.Supplier beanDesc, JsonFormat.Value format,
                         ValueSerializer<Object> keySerializer,
                         TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
                 {
@@ -46,7 +46,7 @@ public class TestTypeModifiers extends DatabindTestUtil
 
                 @Override
                 public ValueSerializer<?> findCollectionLikeSerializer(SerializationConfig config,
-                        CollectionLikeType type, BeanDescription beanDesc, JsonFormat.Value format,
+                        CollectionLikeType type, BeanDescription.Supplier beanDesc, JsonFormat.Value format,
                         TypeSerializer elementTypeSerializer, ValueSerializer<Object> elementValueSerializer)
                 {
                     if (CollectionMarker.class.isAssignableFrom(type.getRawClass())) {
diff --git a/src/test/java/tools/jackson/databind/records/RecordJsonSerDeser188Test.java b/src/test/java/tools/jackson/databind/records/RecordJsonSerDeser188Test.java
index 0b32fc1ae..9fd5310f1 100644
--- a/src/test/java/tools/jackson/databind/records/RecordJsonSerDeser188Test.java
+++ b/src/test/java/tools/jackson/databind/records/RecordJsonSerDeser188Test.java
@@ -43,11 +43,8 @@ public class RecordJsonSerDeser188Test
         }
     }
 
-    @SuppressWarnings("serial")
     static class PrefixStringDeserializer extends StdScalarDeserializer<String>
     {
-        private static final long serialVersionUID = 1L;
-
         protected PrefixStringDeserializer() {
             super(String.class);
         }
diff --git a/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java b/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
index 9eeb0dcb0..abc5f376c 100644
--- a/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
+++ b/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
@@ -385,8 +385,8 @@ public class CustomSerializersTest extends DatabindTestUtil
     public void testIssue4575() throws Exception {
         SimpleModule module = new SimpleModule().setSerializerModifier(new ValueSerializerModifier() {
                     @Override
-                    public ValueSerializer<?> modifySerializer(
-                        SerializationConfig config, BeanDescription beanDesc, ValueSerializer<?> serializer
+                    public ValueSerializer<?> modifySerializer(SerializationConfig config,
+                            BeanDescription.Supplier beanDescRef, ValueSerializer<?> serializer
                     ) {
                         return new NullSerializer4575(config.getTypeFactory(), serializer, null);
                     }
diff --git a/src/test/java/tools/jackson/databind/ser/EnumAsMapKeyTest.java b/src/test/java/tools/jackson/databind/ser/EnumAsMapKeyTest.java
index a6ea969ac..218ae4995 100644
--- a/src/test/java/tools/jackson/databind/ser/EnumAsMapKeyTest.java
+++ b/src/test/java/tools/jackson/databind/ser/EnumAsMapKeyTest.java
@@ -66,7 +66,7 @@ public class EnumAsMapKeyTest extends DatabindTestUtil
         }
     }
 
-    enum Foo661 {
+    public enum Foo661 {
         FOO;
         public static class Serializer extends ValueSerializer<Foo661> {
             @Override
diff --git a/src/test/java/tools/jackson/databind/ser/ValueSerializerModifier1612Test.java b/src/test/java/tools/jackson/databind/ser/ValueSerializerModifier1612Test.java
index cf8a1c247..6f88a30a9 100644
--- a/src/test/java/tools/jackson/databind/ser/ValueSerializerModifier1612Test.java
+++ b/src/test/java/tools/jackson/databind/ser/ValueSerializerModifier1612Test.java
@@ -32,7 +32,8 @@ public class ValueSerializerModifier1612Test extends DatabindTestUtil
         private static final long serialVersionUID = 1L;
 
         @Override
-        public BeanSerializerBuilder updateBuilder(SerializationConfig config, BeanDescription beanDesc,
+        public BeanSerializerBuilder updateBuilder(SerializationConfig config,
+                BeanDescription.Supplier beanDescRef,
                 BeanSerializerBuilder builder) {
             List<BeanPropertyWriter> filtered = new ArrayList<BeanPropertyWriter>(2);
             List<BeanPropertyWriter> properties = builder.getProperties();
diff --git a/src/test/java/tools/jackson/databind/ser/ValueSerializerModifierTest.java b/src/test/java/tools/jackson/databind/ser/ValueSerializerModifierTest.java
index 10732b19b..f44ceb6fe 100644
--- a/src/test/java/tools/jackson/databind/ser/ValueSerializerModifierTest.java
+++ b/src/test/java/tools/jackson/databind/ser/ValueSerializerModifierTest.java
@@ -59,7 +59,8 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
         public RemovingModifier(String remove) { _removedProperty = remove; }
 
         @Override
-        public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc,
+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,
+                BeanDescription.Supplier beanDesc,
                 List<BeanPropertyWriter> beanProperties)
         {
             Iterator<BeanPropertyWriter> it = beanProperties.iterator();
@@ -76,7 +77,8 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class ReorderingModifier extends ValueSerializerModifier
     {
         @Override
-        public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)
+        public List<BeanPropertyWriter> orderProperties(SerializationConfig config,
+                BeanDescription.Supplier beanDesc, List<BeanPropertyWriter> beanProperties)
         {
             TreeMap<String,BeanPropertyWriter> props = new TreeMap<String,BeanPropertyWriter>();
             for (BeanPropertyWriter bpw : beanProperties) {
@@ -93,8 +95,8 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
         public ReplacingModifier(ValueSerializer<?> s) { _serializer = s; }
 
         @Override
-        public ValueSerializer<?> modifySerializer(SerializationConfig config, BeanDescription beanDesc,
-                ValueSerializer<?> serializer) {
+        public ValueSerializer<?> modifySerializer(SerializationConfig config,
+                BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return _serializer;
         }
     }
@@ -109,7 +111,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
 
         @Override
         public BeanSerializerBuilder updateBuilder(SerializationConfig config,
-                BeanDescription beanDesc, BeanSerializerBuilder builder) {
+                BeanDescription.Supplier beanDesc, BeanSerializerBuilder builder) {
             return new BogusSerializerBuilder(builder, _serializer);
         }
     }
@@ -155,7 +157,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     {
         @Override
         public List<BeanPropertyWriter> changeProperties(SerializationConfig config,
-                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)
+                BeanDescription.Supplier beanDesc, List<BeanPropertyWriter> beanProperties)
         {
             JavaType strType = config.constructType(String.class);
             // we need a valid BeanPropertyDefinition; this will do (just need name to match)
@@ -179,14 +181,14 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     {
         @Override
         public List<BeanPropertyWriter> changeProperties(SerializationConfig config,
-                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)
+                BeanDescription.Supplier beanDesc, List<BeanPropertyWriter> beanProperties)
         {
             return beanProperties;
         }
 
         @Override
         public ValueSerializer<?> modifySerializer(SerializationConfig config,
-                BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new BogusBeanSerializer(42);
         }
     }
@@ -195,7 +197,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class ArraySerializerModifier extends ValueSerializerModifier {
         @Override
         public ValueSerializer<?> modifyArraySerializer(SerializationConfig config,
-                ArrayType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                ArrayType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new StdSerializer<Object>(Object.class) {
                 @Override public void serialize(Object value, JsonGenerator g, SerializationContext provider) {
                     g.writeNumber(123);
@@ -207,7 +209,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class CollectionSerializerModifier extends ValueSerializerModifier {
         @Override
         public ValueSerializer<?> modifyCollectionSerializer(SerializationConfig config,
-                CollectionType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                CollectionType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new StdSerializer<Object>(Object.class) {
                 @Override public void serialize(Object value, JsonGenerator g, SerializationContext provider) {
                     g.writeNumber(123);
@@ -219,7 +221,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class MapSerializerModifier extends ValueSerializerModifier {
         @Override
         public ValueSerializer<?> modifyMapSerializer(SerializationConfig config,
-                MapType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                MapType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new StdSerializer<Object>(Object.class) {
                 @Override public void serialize(Object value, JsonGenerator g, SerializationContext provider) {
                     g.writeNumber(123);
@@ -231,7 +233,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class EnumSerializerModifier extends ValueSerializerModifier {
         @Override
         public ValueSerializer<?> modifyEnumSerializer(SerializationConfig config,
-                JavaType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                JavaType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new StdSerializer<Object>(Object.class) {
                 @Override public void serialize(Object value, JsonGenerator g, SerializationContext provider) {
                     g.writeNumber(123);
@@ -243,7 +245,7 @@ public class ValueSerializerModifierTest extends DatabindTestUtil
     static class KeySerializerModifier extends ValueSerializerModifier {
         @Override
         public ValueSerializer<?> modifyKeySerializer(SerializationConfig config,
-                JavaType valueType, BeanDescription beanDesc, ValueSerializer<?> serializer) {
+                JavaType valueType, BeanDescription.Supplier beanDesc, ValueSerializer<?> serializer) {
             return new StdSerializer<Object>(Object.class) {
                 @Override public void serialize(Object value, JsonGenerator g, SerializationContext provider) {
                     g.writeName("foo");
