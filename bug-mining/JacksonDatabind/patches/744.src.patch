diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x
index 1b60c96cb..164dd8536 100644
--- a/release-notes/CREDITS-2.x
+++ b/release-notes/CREDITS-2.x
@@ -1851,5 +1851,10 @@ Bernd Ahlers (@bernd)
   (2.18.2)
 
 Mike Minicki (@martel)
- * Reported #4788: `EnumFeature.WRITE_ENUMS_TO_LOWERCASE` overrides `@JsonProperty` values
+ * Reported #4788: `EnumFeature.WRITE_ENUMS_TO_LOWERCASE` overrides `@JsonProperty` valu
   (2.18.2)
+
+Jonathan Mesny (@jmesny)
+ * Reported #4810: Deserialization using `@JsonCreator` with renamed property failing (since 2.18)
+  (2.18.2)
+
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 3590e8591..f1052c01c 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -25,6 +25,8 @@ Project: jackson-databind
  (reported by @bsa01)
  (fix by Joo-Hyuk K)
 #4807: Improve `FactoryBasedEnumDeserializer` to work better with XML module
+#4810: Deserialization using `@JsonCreator` with renamed property failing (since 2.18)
+ (reported by Jonathan M)
 
 2.18.1 (28-Oct-2024)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
index c6f9322db..a6e562be7 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
@@ -916,11 +916,23 @@ ctor.creator()));
         if (ctor.paramCount() == 1) {
             // One more possibility: implicit name that maps to implied
             // property with at least one visible accessor
-            String implName = ctor.implicitNameSimple(0);
-            if (implName != null) {
-                POJOPropertyBuilder prop = props.get(implName);
-                if ((prop != null) && prop.anyVisible() && !prop.anyIgnorals()) {
-                    return true;
+            PropertyName paramName = ctor.implicitName(0);
+            if (paramName != null) {
+                POJOPropertyBuilder prop = props.get(paramName.getSimpleName());
+                if (prop != null) {
+                    if (prop.anyVisible() && !prop.anyIgnorals()) {
+                        return true;
+                    }
+                } else {
+                    // 26-Nov-2024, tatu: [databind#4810] Implicit name not always
+                    //   enough; may need to link to explicit name override
+                    for (POJOPropertyBuilder pb : props.values()) {
+                        if (pb.anyVisible()
+                                && !pb.anyIgnorals()
+                                && pb.hasExplicitName(paramName)) {
+                            return true;
+                        }
+                    }
                 }
             }
             // Second: injectable also suffices
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
index 5cf537169..da735a32b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
@@ -135,9 +135,7 @@ public class POJOPropertyBuilder
         } else if (other._ctorParameters != null) {
             return 1;
         }
-        /* otherwise sort by external name (including sorting of
-         * ctor parameters)
-         */
+        // otherwise sort by external name (including sorting of ctor parameters)
         return getName().compareTo(other.getName());
     }
 
@@ -1220,10 +1218,36 @@ public class POJOPropertyBuilder
         renamed = _findExplicitNames(_getters, renamed);
         renamed = _findExplicitNames(_setters, renamed);
         renamed = _findExplicitNames(_ctorParameters, renamed);
-        if (renamed == null) {
-            return Collections.emptySet();
+        return (renamed == null) ? Collections.emptySet() : renamed;
+    }
+
+    /**
+     * Method find out if this property has specified explicit name: this
+     * is generally needed for properties that have not yet been renamed
+     * (Creator-detection).
+     *
+     * @param name Name to check against
+     *
+     * @return True if this property has specified explicit name
+     *
+     * @since 2.18.2
+     */
+    public boolean hasExplicitName(PropertyName name) {
+        return _hasExplicitName(_fields, name)
+                || _hasExplicitName(_getters, name)
+                || _hasExplicitName(_setters, name)
+                || _hasExplicitName(_ctorParameters, name);
+    }
+
+    private boolean _hasExplicitName(Linked<? extends AnnotatedMember> node,
+            PropertyName nameToMatch)
+    {
+        for (; node != null; node = node.next) {
+            if (node.isNameExplicit && nameToMatch.equals(node.name)) {
+                return true;
+            }
         }
-        return renamed;
+        return false;
     }
 
     /**
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/creators/CreatorWithRenamedParamTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/creators/CreatorWithRenamedParamTest.java
index c5c744cc5..af8c94239 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/creators/CreatorWithRenamedParamTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/creators/CreatorWithRenamedParamTest.java
@@ -7,8 +7,10 @@ import com.fasterxml.jackson.annotation.JsonProperty;
 
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
+import com.fasterxml.jackson.databind.json.JsonMapper;
 import com.fasterxml.jackson.databind.testutil.DatabindTestUtil;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
 public class CreatorWithRenamedParamTest
@@ -42,23 +44,58 @@ public class CreatorWithRenamedParamTest
         }
     }
 
-    private final ObjectMapper MAPPER = jsonMapperBuilder()
-            .disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)
-            .annotationIntrospector(new ImplicitNameIntrospector())
-            .build();
+    // [databind#4810]
+    static class DataClass4810 {
+        private String x;
+
+        private DataClass4810(String x) {
+            this.x = x;
+        }
+        
+        @JsonProperty("bar")
+        public String getFoo() {
+            return x;
+        }
+
+        // NOTE: mode-less, should be properly detected as properties-based
+        @JsonCreator
+        public static DataClass4810 create(@ImplicitName("bar") String bar) {
+            return new DataClass4810(bar);
+        }
+    }
 
     // [databind#4545]
     @Test
-    public void testCreatorWithRename4545() throws Exception
+    public void creatorWithRename4545() throws Exception
     {
+        final ObjectMapper mapper4545 = jsonMapperBuilder()
+                .disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)
+                .annotationIntrospector(new ImplicitNameIntrospector())
+                .build();
         String jsonPayload = a2q("{ 'key1': 'val1', 'key2': 'val2'}");
 
         try {
-            MAPPER.readValue(jsonPayload, Payload4545.class);
+            mapper4545.readValue(jsonPayload, Payload4545.class);
             fail("Should not pass");
         } catch (UnrecognizedPropertyException e) {
             verifyException(e, "Unrecognized");
             verifyException(e, "key1");
         }
     }
+
+    // [databind#4810]
+    @Test
+    void shouldSupportPropertyRenaming4810() throws Exception {
+        ObjectMapper mapper = JsonMapper.builder()
+                .annotationIntrospector(new ImplicitNameIntrospector())
+                .build();
+
+        JsonNode serializationResult = mapper.valueToTree(DataClass4810.create("42"));
+
+        assertEquals(a2q("{'bar':'42'}"), serializationResult.toString());
+
+        DataClass4810 deserializationResult = mapper.treeToValue(serializationResult, DataClass4810.class);
+
+        assertEquals("42", deserializationResult.getFoo());
+    }
 }
