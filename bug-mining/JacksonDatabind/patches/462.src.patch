diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 0a55cc46a..75be8bde5 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -6,6 +6,8 @@ Project: jackson-databind
 
 2.10.0-final (not yet released)
 
+#1093: Default typing does not work with `writerFor(Object.class)`
+ (reported by hoomanv@github)
 #2129: Add `SerializationFeature.WRITE_ENUM_KEYS_USING_INDEX`, separate from value setting
  (suggested by renzihui@github)
 #2133: Improve `DeserializationProblemHandler.handleUnexpectedToken()` to allow handling of
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java
index d056f7764..831834e0f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java
@@ -104,12 +104,14 @@ public class ObjectWriter
         _generatorSettings = (pp == null) ? GeneratorSettings.empty
                 : new GeneratorSettings(pp, null, null, null);
 
-        // 29-Apr-2014, tatu: There is no "untyped serializer", so:
-        if (rootType == null || rootType.hasRawClass(Object.class)) {
+        if (rootType == null) {
             _prefetch = Prefetch.empty;
-        } else {
-            rootType = rootType.withStaticTyping();
+        } else if (rootType.hasRawClass(Object.class)) {
+            // 15-Sep-2019, tatu: There is no "untyped serializer", but...
+            //     as per [databind#1093] we do need `TypeSerializer`
             _prefetch = Prefetch.empty.forRootType(this, rootType);
+        } else {
+            _prefetch = Prefetch.empty.forRootType(this, rootType.withStaticTyping());
         }
     }
 
@@ -202,11 +204,9 @@ public class ObjectWriter
     }
 
     /*
-    /**********************************************************
-    /* Methods sub-classes MUST override, used for constructing
-    /* writer instances, (re)configuring parser instances.
-    /* Added in 2.5
-    /**********************************************************
+    /**********************************************************************
+    /* Internal factory methods, for convenience
+    /**********************************************************************
      */
 
     /**
@@ -411,9 +411,6 @@ public class ObjectWriter
      * @since 2.5
      */
     public ObjectWriter forType(Class<?> rootType) {
-        if (rootType == Object.class) {
-            return forType((JavaType) null);
-        }
         return forType(_config.constructType(rootType));
     }
 
@@ -1360,19 +1357,35 @@ public class ObjectWriter
         }
 
         public Prefetch forRootType(ObjectWriter parent, JavaType newType) {
-            // First: if nominal type not defined, or trivial (java.lang.Object),
-            // not thing much to do
-            boolean noType = (newType == null) || newType.isJavaLangObject();
-
-            if (noType) {
+            // First: if nominal type not defined not thing much to do
+            if (newType == null) {
                 if ((rootType == null) || (valueSerializer == null)) {
                     return this;
                 }
-                return new Prefetch(null, null, typeSerializer);
+                return new Prefetch(null, null, null);
             }
+
+            // Second: if no change, nothing to do either
             if (newType.equals(rootType)) {
                 return this;
             }
+
+            // But one more trick: `java.lang.Object` has no serialized, but may
+            // have `TypeSerializer` to use
+            if (newType.isJavaLangObject()) {
+                DefaultSerializerProvider prov = parent._serializerProvider();
+                TypeSerializer typeSer;
+
+                try {
+                    typeSer = prov.findTypeSerializer(newType);
+                } catch (JsonMappingException e) {
+                    // Unlike with value serializer pre-fetch, let's not allow exception
+                    // for TypeSerializer be swallowed
+                    throw new RuntimeJsonMappingException(e);
+                }
+                return new Prefetch(null, null, typeSer);
+            }
+
             if (parent.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {
                 DefaultSerializerProvider prov = parent._serializerProvider();
                 // 17-Dec-2014, tatu: Need to be bit careful here; TypeSerializers are NOT cached,
@@ -1387,7 +1400,7 @@ public class ObjectWriter
                                 ((TypeWrappedSerializer) ser).typeSerializer());
                     }
                     return new Prefetch(newType, ser, null);
-                } catch (JsonProcessingException e) {
+                } catch (JsonMappingException e) {
                     // need to swallow?
                     ;
                 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultWithBaseType1093Test.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultWithBaseType1093Test.java
new file mode 100644
index 000000000..bee9701a9
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/DefaultWithBaseType1093Test.java
@@ -0,0 +1,50 @@
+package com.fasterxml.jackson.databind.jsontype.deftyping;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import com.fasterxml.jackson.databind.testutil.NoCheckSubTypeValidator;
+
+// Tests to verify functionality to pass "base type" for serializing
+// polymorphic types (ones where output contains Type Id to allow later
+// deserialization deserialization), separate from fully forcing
+// actual type of value being serialized.
+public class DefaultWithBaseType1093Test extends BaseMapTest
+{
+    // [databind#1093]
+    static class Point1093 {
+        public int x, y;
+
+        protected Point1093() { }
+        public Point1093(int _x, int _y) {
+            x = _x;
+            y = _y;
+        }
+    }
+
+    // [databind#1093]
+    public void testWithDefaultTyping() throws Exception
+    {
+        ObjectMapper m = JsonMapper.builder()
+                .activateDefaultTyping(NoCheckSubTypeValidator.instance,
+                        ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT)
+                .build();
+
+        final Point1093 input = new Point1093(28, 12);
+
+        _testWithDefaultTyping(input, m.readerFor(Object.class),
+                m.writer().forType(Object.class));
+        _testWithDefaultTyping(input, m.readerFor(Object.class),
+                m.writerFor(Object.class));
+    }
+
+    private void _testWithDefaultTyping(Point1093 input, ObjectReader r,
+            ObjectWriter w) throws Exception
+    {
+        String json = w.writeValueAsString(input);
+        
+        Point1093 result = (Point1093) r.readValue(json);
+
+        assertEquals(input.x, result.x);
+        assertEquals(input.y, result.y);
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/TestDefaultForObject.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/TestDefaultForObject.java
index 2054db7ba..e9be622b2 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/TestDefaultForObject.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/deftyping/TestDefaultForObject.java
@@ -148,10 +148,6 @@ public class TestDefaultForObject
             // let's use whatever is currently thrown exception... may change tho
             verifyException(e, "cannot construct");
         }
-        m = JsonMapper.builder()
-                .activateDefaultTyping(NoCheckSubTypeValidator.instance)
-                .build();
-        
         // and then that we will succeed with default type info
         m = JsonMapper.builder()
                 .activateDefaultTyping(NoCheckSubTypeValidator.instance,
