diff --git a/release-notes/VERSION b/release-notes/VERSION
index 86051acdc..e409e8a05 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -11,7 +11,9 @@ Project: jackson-databind
 #1768: Improve `TypeFactory.constructFromCanonical()` to work with
   `java.lang.reflect.Type.getTypeName()` format
 #1804: `ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`
- (reported byb henryptung@github)
+ (reported by henryptung@github)
+#1807: Jackson-databind caches plain map deserializer and use it even map has `@JsonDeserializer`
+ (reported by lexas2509@github)
 
 2.8.10 (24-Aug-2017)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
index bdb214414..ded6b68fd 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
@@ -204,7 +204,7 @@ public final class DeserializerCache
         if (type == null) {
             throw new IllegalArgumentException("Null JavaType passed");
         }
-        if (_hasCustomValueHandler(type)) {
+        if (_hasCustomHandlers(type)) {
             return null;
         }
         return _cachedDeserializers.get(type);
@@ -274,7 +274,7 @@ public final class DeserializerCache
          * (but can be re-defined for sub-classes by using @JsonCachable!)
          */
         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers
-        boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable();
+        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();
 
         /* we will temporarily hold on to all created deserializers (to
          * handle cyclic references, and possibly reuse non-cached
@@ -531,13 +531,23 @@ public final class DeserializerCache
      * Helper method used to prevent both caching and cache lookups for structured
      * types that have custom value handlers
      *
-     * @since 2.4.6
+     * @since 2.8.11
      */
-    private boolean _hasCustomValueHandler(JavaType t) {
+    private boolean _hasCustomHandlers(JavaType t) {
         if (t.isContainerType()) {
+            // First: value types may have both value and type handlers
             JavaType ct = t.getContentType();
             if (ct != null) {
-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);
+                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {
+                    return true;
+                }
+            }
+            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)
+            if (t.isMapLikeType()) {
+                JavaType kt = t.getKeyType();
+                if (kt.getValueHandler() != null) {
+                    return true;
+                }
             }
         }
         return false;
@@ -568,9 +578,7 @@ public final class DeserializerCache
     protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type)
         throws JsonMappingException
     {
-        /* Let's try to figure out the reason, to give better error
-         * messages
-         */
+        // Let's try to figure out the reason, to give better error messages
         Class<?> rawClass = type.getRawClass();
         if (!ClassUtil.isConcrete(rawClass)) {
             ctxt.reportMappingException("Can not find a Value deserializer for abstract type %s", type);
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/MapDeserializerCachingTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/MapDeserializerCachingTest.java
new file mode 100644
index 000000000..f2eca0a93
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/MapDeserializerCachingTest.java
@@ -0,0 +1,52 @@
+package com.fasterxml.jackson.databind.deser.jdk;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.TreeMap;
+
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+
+// for [databind#1807]
+public class MapDeserializerCachingTest extends BaseMapTest
+{
+    public static class NonAnnotatedMapHolderClass {
+        public Map<String, String> data = new TreeMap<String, String>();
+    }
+
+    public static class MapHolder {
+        @JsonDeserialize(keyUsing = MyKeyDeserializer.class)
+        public Map<String, String> data = new TreeMap<String, String>();
+    }
+
+    public static class MyKeyDeserializer extends KeyDeserializer {
+        @Override
+        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
+            return key + " (CUSTOM)";
+        }
+    }
+
+    /*
+    /**********************************************************
+    /* Test methods
+    /**********************************************************
+     */
+
+    public void testCachedSerialize() throws IOException {
+        ObjectMapper mapper = new ObjectMapper();
+        String json = aposToQuotes("{'data':{'1st':'onedata','2nd':'twodata'}}");
+
+        // Do deserialization with non-annotated map property
+        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);
+        assertTrue(ignored.data.containsKey("1st"));
+        assertTrue(ignored.data.containsKey("2nd"));
+
+//mapper = new ObjectMapper();
+        
+        MapHolder model2 = mapper.readValue(json, MapHolder.class);
+        if (!model2.data.containsKey("1st (CUSTOM)")
+            || !model2.data.containsKey("2nd (CUSTOM)")) {
+            fail("Not using custom key deserializer for input: "+json+"; resulted in: "+model2.data);
+        }
+    }
+}
