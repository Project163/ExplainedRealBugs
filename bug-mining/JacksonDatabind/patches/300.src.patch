diff --git a/release-notes/VERSION b/release-notes/VERSION
index e9e4aafbd..6b48d0250 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -92,6 +92,7 @@ Project: jackson-databind
 #1653: Convenience overload(s) for ObjectMapper#registerSubtypes
 #1655: `@JsonAnyGetter` uses different `bean` parameter in `SimpleBeanPropertyFilter`
  (reported by georgeflugq@github)
+#1678: Rewrite `StdDateFormat` ISO-8601 deserialization functionality
 
 2.8.9.1 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java
index 833ef6e7a..e61f12ac2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java
@@ -19,7 +19,7 @@ public class ISO8601DateFormat extends DateFormat
 {
     private static final long serialVersionUID = 1L;
 
-    // those classes are to try to allow a consistent behavior for hascode/equals and other methods
+    // those classes are to try to allow a consistent behavior for hashcode/equals and other methods
     private static Calendar CALENDAR = new GregorianCalendar();
     private static NumberFormat NUMBER_FORMAT = new DecimalFormat();
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
index b6f30c5db..5c2b4bbb7 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
@@ -133,7 +133,6 @@ public class ISO8601Utils
         } else {
             formatted.append('Z');
         }
-
         return formatted.toString();
     }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
index 0137eb14d..bbcbeb134 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
@@ -6,6 +6,8 @@ import java.text.ParseException;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import com.fasterxml.jackson.core.io.NumberInput;
 
@@ -19,41 +21,47 @@ import com.fasterxml.jackson.core.io.NumberInput;
 public class StdDateFormat
     extends DateFormat
 {
-    /* TODO !!! 24-Nov-2009, tatu: Should rewrite this class:
-     * JDK date parsing is awfully brittle, and ISO-8601 is quite
-     * permissive. The two don't mix, need to write a better one.
+    /* 24-Jun-2017, tatu: Finally rewrote deserialization to use basic Regex
+     *   instead of SimpleDateFormat; partly for better concurrency, partly
+     *   for easier enforcing of specific rules. Heavy lifting done by Calendar,
+     *   anyway.
      */
-    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still
-    //   not really robust. But still in use.
+
+    protected final static String PATTERN_PLAIN_STR = "\\d\\d\\d\\d[-]\\d\\d[-]\\d\\d";
+
+    protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR);
+
+    protected final static Pattern PATTERN_ISO8601;
+    static {
+        Pattern p = null;
+        try {
+            p = Pattern.compile(PATTERN_PLAIN_STR
+                    +"[T]\\d\\d[:]\\d\\d(?:[:]\\d\\d)?" // hours, minutes, optional seconds
+                    +"(\\.\\d+)?" // optional second fractions
+                    +"(Z|[+-]\\d\\d(?:[:]?\\d\\d)?)?" // optional timeoffset/Z
+            );
+        } catch (Throwable t) {
+            throw new RuntimeException(t);
+        }
+        PATTERN_ISO8601 = p;
+    }
 
     /**
      * Defines a commonly used date format that conforms
      * to ISO-8601 date formatting standard, when it includes basic undecorated
-     * timezone definition
+     * timezone definition.
      */
     public final static String DATE_FORMAT_STR_ISO8601 = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";
 
     /**
-     * Same as 'regular' 8601, but handles 'Z' as an alias for "+0000"
-     * (or "UTC")
-     */
-    protected final static String DATE_FORMAT_STR_ISO8601_Z = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'";
-
-    /**
-     * Same as 'regular' 8601 except misses timezone altogether
-     *
-     * @since 2.8.10
-     */
-    protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = "yyyy-MM-dd'T'HH:mm:ss.SSS";
-
-    /**
-     * ISO-8601 with just the Date part, no time
+     * ISO-8601 with just the Date part, no time: needed for error messages
      */
     protected final static String DATE_FORMAT_STR_PLAIN = "yyyy-MM-dd";
 
     /**
      * This constant defines the date format specified by
-     * RFC 1123 / RFC 822.
+     * RFC 1123 / RFC 822. Used for parsing via `SimpleDateFormat` as well as
+     * error messages.
      */
     protected final static String DATE_FORMAT_STR_RFC1123 = "EEE, dd MMM yyyy HH:mm:ss zzz";
 
@@ -62,8 +70,7 @@ public class StdDateFormat
      */
     protected final static String[] ALL_FORMATS = new String[] {
         DATE_FORMAT_STR_ISO8601,
-        DATE_FORMAT_STR_ISO8601_Z,
-        DATE_FORMAT_STR_ISO8601_NO_TZ,
+        "yyyy-MM-dd'T'HH:mm:ss.SSS", // ISO-8601 but no timezone
         DATE_FORMAT_STR_RFC1123,
         DATE_FORMAT_STR_PLAIN
     };
@@ -72,20 +79,16 @@ public class StdDateFormat
      * By default we use UTC for everything, with Jackson 2.7 and later
      * (2.6 and earlier relied on GMT)
      */
-    private final static TimeZone DEFAULT_TIMEZONE;
+    protected final static TimeZone DEFAULT_TIMEZONE;
     static {
         DEFAULT_TIMEZONE = TimeZone.getTimeZone("UTC"); // since 2.7
     }
 
-    private final static Locale DEFAULT_LOCALE = Locale.US;
+    protected final static Locale DEFAULT_LOCALE = Locale.US;
 
     protected final static DateFormat DATE_FORMAT_RFC1123;
 
     protected final static DateFormat DATE_FORMAT_ISO8601;
-    protected final static DateFormat DATE_FORMAT_ISO8601_Z;
-    protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10
-
-    protected final static DateFormat DATE_FORMAT_PLAIN;
 
     /* Let's construct "blueprint" date format instances: can not be used
      * as is, due to thread-safety issues, but can be used for constructing
@@ -100,12 +103,6 @@ public class StdDateFormat
         DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);
         DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);
         DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);
-        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);
-        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);
-        DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE);
-        DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);
-        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);
-        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);
     }
     
     /**
@@ -131,11 +128,8 @@ public class StdDateFormat
      */
     protected Boolean _lenient;
     
-    protected transient DateFormat _formatRFC1123;
-    protected transient DateFormat _formatISO8601;
-    protected transient DateFormat _formatISO8601_z;
-    protected transient DateFormat _formatISO8601_noTz; // 2.8.10
-    protected transient DateFormat _formatPlain;
+    private transient DateFormat _formatRFC1123;
+    private transient DateFormat _formatISO8601;
 
     /*
     /**********************************************************
@@ -196,9 +190,8 @@ public class StdDateFormat
 
     @Override
     public StdDateFormat clone() {
-        /* Although there is that much state to share, we do need to
-         * orchestrate a bit, mostly since timezones may be changed
-         */
+        // Although there is that much state to share, we do need to
+        // orchestrate a bit, mostly since timezones may be changed
         return new StdDateFormat(_timezone, _locale, _lenient);
     }
 
@@ -288,36 +281,10 @@ public class StdDateFormat
     {
         dateStr = dateStr.trim();
         ParsePosition pos = new ParsePosition(0);
-
-        Date dt;
-
-        if (looksLikeISO8601(dateStr)) { // also includes "plain"
-            dt = parseAsISO8601(dateStr, pos, true);
-        } else {
-            // Also consider "stringified" simple time stamp
-            int i = dateStr.length();
-            while (--i >= 0) {
-                char ch = dateStr.charAt(i);
-                if (ch < '0' || ch > '9') {
-                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
-                    if (i > 0 || ch != '-') {
-                        break;
-                    }
-                }
-            }
-            if ((i < 0)
-                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
-                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
-                dt = new Date(Long.parseLong(dateStr));
-            } else {
-                // Otherwise, fall back to using RFC 1123
-                dt = parseAsRFC1123(dateStr, pos);
-            }
-        }
+        Date dt = _parseDate(dateStr, pos);
         if (dt != null) {
             return dt;
         }
-
         StringBuilder sb = new StringBuilder();
         for (String f : ALL_FORMATS) {
             if (sb.length() > 0) {
@@ -333,15 +300,22 @@ public class StdDateFormat
                            dateStr, sb.toString()), pos.getErrorIndex());
     }
 
+    // 24-Jun-2017, tatu: I don't think this ever gets called. So could... just not implement?
     @Override
     public Date parse(String dateStr, ParsePosition pos)
+    {
+        try {
+            return _parseDate(dateStr, pos);
+        } catch (ParseException e) {
+            // may look weird but this is what `DateFormat` suggest to do...
+        }
+        return null;
+    }
+
+    protected Date _parseDate(String dateStr, ParsePosition pos) throws ParseException
     {
         if (looksLikeISO8601(dateStr)) { // also includes "plain"
-            try {
-                return parseAsISO8601(dateStr, pos, false);
-            } catch (ParseException e) { // will NOT be thrown due to false but is declared...
-                return null;
-            }
+            return parseAsISO8601(dateStr, pos);
         }
         // Also consider "stringified" simple time stamp
         int i = dateStr.length();
@@ -354,13 +328,12 @@ public class StdDateFormat
                 }
             }
         }
-        if (i < 0) { // all digits
+        if ((i < 0)
             // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
-            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {
-                return new Date(Long.parseLong(dateStr));
-            }
+                && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
+            return _parseDateFromLong(dateStr, pos);
         }
-        // Otherwise, fall back to using RFC 1123
+        // Otherwise, fall back to using RFC 1123. NOTE: call will NOT throw, just returns `null`
         return parseAsRFC1123(dateStr, pos);
     }
 
@@ -378,6 +351,7 @@ public class StdDateFormat
             _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,
                     _timezone, _locale, _lenient);
         }
+        // 24-Jun-2017, tatu: is this actually safe thing to do without clone() or sync?
         return _formatISO8601.format(date, toAppendTo, fieldPosition);
     }
 
@@ -389,8 +363,8 @@ public class StdDateFormat
 
     @Override
     public String toString() {
-        return String.format("DateFormat %s: (timezone: %s, locale: %s)",
-                getClass().getName(), _timezone, _locale);
+        return String.format("DateFormat %s: (timezone: %s, locale: %s, lenient: %s)",
+                getClass().getName(), _timezone, _locale, _lenient);
     }
 
     public String toPattern() { // same as SimpleDateFormat
@@ -419,153 +393,167 @@ public class StdDateFormat
 
     /*
     /**********************************************************
-    /* Helper methods
+    /* Helper methods, parsing
     /**********************************************************
      */
 
-    protected static <T> boolean _equals(T value1, T value2) {
-        if (value1 == value2) {
-            return true;
-        }
-        return (value1 != null) && value1.equals(value2);
-    }
-
     /**
-     * Overridable helper method used to figure out which of supported
-     * formats is the likeliest match.
+     * Helper method used to figure out if input looks like valid
+     * ISO-8601 string.
      */
     protected boolean looksLikeISO8601(String dateStr)
     {
-        if (dateStr.length() >= 5
+        if (dateStr.length() >= 7 // really need 10, but...
             && Character.isDigit(dateStr.charAt(0))
             && Character.isDigit(dateStr.charAt(3))
             && dateStr.charAt(4) == '-'
+            && Character.isDigit(dateStr.charAt(5))
             ) {
             return true;
         }
         return false;
     }
 
-    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)
-            throws ParseException
+    private Date _parseDateFromLong(String longStr, ParsePosition pos) throws ParseException
     {
-        /* 21-May-2009, tatu: DateFormat has very strict handling of
-         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
-         */
+        long ts;
+        try {
+            ts = NumberInput.parseLong(longStr);
+        } catch (NumberFormatException e) {
+            throw new ParseException(String.format(
+                    "Timestamp value %s out of 64-bit value range", longStr),
+                    pos.getErrorIndex());
+        }
+        return new Date(ts);
+    }
 
-        /* First: do we have "zulu" format ('Z' == "UTC")? If yes, that's
-         * quite simple because we already set date format timezone to be
-         * UTC, and hence can just strip out 'Z' altogether
-         */
-        int len = dateStr.length();
-        char c = dateStr.charAt(len-1);
-        DateFormat df;
-        String formatStr;
+    protected Date parseAsISO8601(String dateStr, ParsePosition pos)
+        throws ParseException
+    {
+        try {
+            return _parseAsISO8601(dateStr, pos);
+        } catch (IllegalArgumentException e) {
+            throw new ParseException(String.format("Can not parse date \"%s\", problem: %s",
+                    dateStr, e.getMessage()),
+                    pos.getErrorIndex());
+        }
+    }
 
-        // Need to support "plain" date...
-        if (len <= 10 && Character.isDigit(c)) {
-            df = _formatPlain;
-            formatStr = DATE_FORMAT_STR_PLAIN;
-            if (df == null) {
-                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,
-                        _timezone, _locale, _lenient);
-            }
-        } else if (c == 'Z') {
-            df = _formatISO8601_z;
-            formatStr = DATE_FORMAT_STR_ISO8601_Z;
-            if (df == null) {
-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
-                //    must use UTC, not whatever is configured as default timezone
-                //    (because we know `Z` identifier is used)
-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
-                        DEFAULT_TIMEZONE, _locale, _lenient);
-            }
-            // may be missing milliseconds... if so, add
-            if (dateStr.charAt(len-4) == ':') {
-                StringBuilder sb = new StringBuilder(dateStr);
-                sb.insert(len-1, ".000");
-                dateStr = sb.toString();
+    protected Date _parseAsISO8601(String dateStr, ParsePosition pos)
+        throws IllegalArgumentException, ParseException
+    {
+        final int totalLen = dateStr.length();
+        // actually, one short-cut: if we end with "Z", must be UTC
+        TimeZone tz = DEFAULT_TIMEZONE;
+        if ((_timezone != null) && ('Z' != dateStr.charAt(totalLen-1))) {
+            tz = _timezone;
+        }
+        Calendar cal = Calendar.getInstance(tz, _locale);
+        if (_lenient != null) {
+            cal.setLenient(_lenient.booleanValue());
+        }
+        String formatStr;
+        if (totalLen <= 10) {
+            Matcher m = PATTERN_PLAIN.matcher(dateStr);
+            if (m.matches()) {
+                int year = _parse4D(dateStr, 0);
+                int month = _parse2D(dateStr, 5)-1;
+                int day = _parse2D(dateStr, 8);
+
+                cal.set(year, month, day, 0, 0, 0);
+                cal.set(Calendar.MILLISECOND, 0);
+                return cal.getTime();
             }
+            formatStr = DATE_FORMAT_STR_PLAIN;
         } else {
-            // Let's see if we have timezone indicator or not...
-            if (hasTimeZone(dateStr)) {
-                c = dateStr.charAt(len-3);
-                if (c == ':') { // remove optional colon
-                    // remove colon
-                    StringBuilder sb = new StringBuilder(dateStr);
-                    sb.delete(len-3, len-2);
-                    dateStr = sb.toString();
-                } else if (c == '+' || c == '-') { // missing minutes
-                    // let's just append '00'
-                    dateStr += "00";
-                }
-                // Milliseconds partial or missing; and even seconds are optional
-                len = dateStr.length();
-                // remove 'T', '+'/'-' and 4-digit timezone-offset
-                int timeLen = len - dateStr.lastIndexOf('T') - 6;
-                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss
-                    int offset = len - 5; // insertion offset, before tz-offset
-                    StringBuilder sb = new StringBuilder(dateStr);
-                    switch (timeLen) {
-                    case 11:
-                        sb.insert(offset, '0'); break;
-                    case 10:
-                        sb.insert(offset, "00"); break;
-                    case 9: // is this legal? (just second fraction marker)
-                        sb.insert(offset, "000"); break;
-                    case 8:
-                        sb.insert(offset, ".000"); break;
-                    case 7: // not legal to have single-digit second
-                        break;
-                    case 6: // probably not legal, but let's allow
-                        sb.insert(offset, "00.000");
-                    case 5: // is legal to omit seconds
-                        sb.insert(offset, ":00.000");
+            Matcher m = PATTERN_ISO8601.matcher(dateStr);
+            if (m.matches()) {
+                // Important! START with optional timezone; otherwise
+                // Calendar will implode.
+                
+                int start = m.start(2);
+                int end = m.end(2);
+                int len = end-start;
+                if (len > 1) { // 0 -> none, 1 -> 'Z'
+                    // NOTE: first char is sign; then 2 digits, then optional colon, optional 2 digits
+                    int offsetSecs = _parse2D(dateStr, start+1) * 3600;
+                    if (len >= 5) {
+                        offsetSecs += _parse2D(dateStr, end-2);
                     }
-                    dateStr = sb.toString();
+                    if (dateStr.charAt(start) == '-') {
+                        offsetSecs *= -1000;
+                    } else {
+                        offsetSecs *= 1000;
+                    }
+                    cal.set(Calendar.ZONE_OFFSET, offsetSecs);
+                    // 23-Jun-2017, tatu: Not sure why, but this appears to be needed too:
+                    cal.set(Calendar.DST_OFFSET, 0);
                 }
-                df = _formatISO8601;
-                formatStr = DATE_FORMAT_STR_ISO8601;
-                if (_formatISO8601 == null) {
-                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,
-                            _timezone, _locale, _lenient);
+                
+                int year = _parse4D(dateStr, 0);
+                int month = _parse2D(dateStr, 5)-1;
+                int day = _parse2D(dateStr, 8);
+
+                // So: 10 chars for date, then `T`, so starts at 11
+                int hour = _parse2D(dateStr, 11);
+                int minute = _parse2D(dateStr, 14);
+
+                // Seconds are actually optional... so
+                int seconds;
+                if ((totalLen > 16) && dateStr.charAt(16) == ':') {
+                    seconds = _parse2D(dateStr, 17);
+                } else {
+                    seconds = 0;
                 }
-            } else {
-                // If not, plain date, no timezone
-                int timeLen = len - dateStr.lastIndexOf('T') - 1;
-                // And possible also millisecond part if missing
-                if (timeLen < 12) { // missing, or partial
-                    StringBuilder sb = new StringBuilder(dateStr);
-                    switch (timeLen) {
-                    case 11: sb.append('0');
-                    case 10: sb.append('0');
-                    case 9: sb.append('0');
+                cal.set(year, month, day, hour, minute, seconds);
+
+                // Optional milliseconds
+                start = m.start(1) + 1;
+                end = m.end(1);
+                int msecs = 0;
+                if (start >= end) { // no fractional
+                    cal.set(Calendar.MILLISECOND, 0);
+                } else {
+                    // first char is '.', but rest....
+                    msecs = 0;
+                    switch (end-start) {
+                    case 3:
+                        msecs += (dateStr.charAt(start+2) - '0');
+                    case 2:
+                        msecs += 10 * (dateStr.charAt(start+1) - '0');
+                    case 1:
+                        msecs += 100 * (dateStr.charAt(start) - '0');
                         break;
                     default:
-                        sb.append(".000");
+                        throw new ParseException(String.format(
+"Can not parse date \"%s\": invalid fractional seconds '%s'; can use at most 3 digits",
+                                       dateStr, m.group(1).substring(1)
+                                       ),
+                                pos.getErrorIndex());
                     }
-                    dateStr = sb.toString();
-                }
-                df = _formatISO8601_noTz;
-                formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;
-                if (df == null) {
-                    // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
-                    //    must use UTC, not whatever is configured as default timezone
-                    //    (because we know `Z` identifier is used)
-                    df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr,
-                            _timezone, _locale, _lenient);
+                    cal.set(Calendar.MILLISECOND, msecs);
                 }
+                return cal.getTime();
             }
+            formatStr = DATE_FORMAT_STR_ISO8601;
         }
-        Date dt = df.parse(dateStr, pos);
-        // 22-Dec-2015, tatu: With non-lenient, may get null
-        if (dt == null) {
-            throw new ParseException
-            (String.format("Can not parse date \"%s\": while it seems to fit format '%s', parsing fails (leniency? %s)",
-                           dateStr, formatStr, _lenient),
-               pos.getErrorIndex());
-        }
-        return dt;
+
+        throw new ParseException
+        (String.format("Can not parse date \"%s\": while it seems to fit format '%s', parsing fails (leniency? %s)",
+                       dateStr, formatStr, _lenient),
+           pos.getErrorIndex());
+    }
+
+    private static int _parse4D(String str, int index) {
+        return (1000 * (str.charAt(index) - '0'))
+                + (100 * (str.charAt(index+1) - '0'))
+                + (10 * (str.charAt(index+2) - '0'))
+                + (str.charAt(index+3) - '0');
+    }
+
+    private static int _parse2D(String str, int index) {
+        return (10 * (str.charAt(index) - '0'))
+                + (str.charAt(index+1) - '0');
     }
 
     protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
@@ -577,20 +565,11 @@ public class StdDateFormat
         return _formatRFC1123.parse(dateStr, pos);
     }
 
-    private final static boolean hasTimeZone(String str)
-    {
-        // Only accept "+hh", "+hhmm" and "+hh:mm" (and with minus), so
-        int len = str.length();
-        if (len >= 6) {
-            char c = str.charAt(len-6);
-            if (c == '+' || c == '-') return true;
-            c = str.charAt(len-5);
-            if (c == '+' || c == '-') return true;
-            c = str.charAt(len-3);
-            if (c == '+' || c == '-') return true;
-        }
-        return false;
-    }
+    /*
+    /**********************************************************
+    /* Helper methods, other
+    /**********************************************************
+     */
 
     private final static DateFormat _cloneFormat(DateFormat df, String format,
             TimeZone tz, Locale loc, Boolean lenient)
@@ -613,10 +592,12 @@ public class StdDateFormat
     protected void _clearFormats() {
         _formatRFC1123 = null;
         _formatISO8601 = null;
-        _formatISO8601_z = null;
-        _formatISO8601_noTz = null;
+    }
 
-        _formatPlain = null;
+    protected static <T> boolean _equals(T value1, T value2) {
+        if (value1 == value2) {
+            return true;
+        }
+        return (value1 != null) && value1.equals(value2);
     }
 }
-
diff --git a/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java b/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java
deleted file mode 100644
index c65be64f3..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package com.fasterxml.jackson.databind;
-
-import java.text.ParseException;
-import java.util.*;
-
-import com.fasterxml.jackson.databind.util.StdDateFormat;
-
-public class TestStdDateFormat
-    extends BaseMapTest
-{
-    public void testFactories() {
-        TimeZone tz = TimeZone.getTimeZone("GMT");
-        Locale loc = Locale.US;
-        assertNotNull(StdDateFormat.getISO8601Format(tz, loc));
-        assertNotNull(StdDateFormat.getRFC1123Format(tz, loc));
-    }
-
-    // [databind#803]
-    public void testLenientDefaults() throws Exception
-    {
-        StdDateFormat f = StdDateFormat.instance;
-
-        // default should be lenient
-        assertTrue(f.isLenient());
-
-        StdDateFormat f2 = f.clone();
-        assertTrue(f2.isLenient());
-
-        f2.setLenient(false);
-        assertFalse(f2.isLenient());
-
-        f2.setLenient(true);
-        assertTrue(f2.isLenient());
-
-        // and for testing, finally, leave as non-lenient
-        f2.setLenient(false);
-        assertFalse(f2.isLenient());
-        StdDateFormat f3 = f2.clone();
-        assertFalse(f3.isLenient());
-    }
-
-    public void testLenientParsing() throws Exception
-    {
-        StdDateFormat f = StdDateFormat.instance.clone();
-        f.setLenient(false);
-
-        // first, legal dates are... legal
-        Date dt = f.parse("2015-11-30");
-        assertNotNull(dt);
-
-        // but as importantly, when not lenient, do not allow
-        try {
-            f.parse("2015-11-32");
-            fail("Should not pass");
-        } catch (ParseException e) {
-            verifyException(e, "can not parse date");
-        }
-
-        // ... yet, with lenient, do allow
-        f.setLenient(true);
-        dt = f.parse("2015-11-32");
-        assertNotNull(dt);
-    }
-    
-    public void testInvalid() {
-        StdDateFormat std = new StdDateFormat();
-        try {
-            std.parse("foobar");
-        } catch (java.text.ParseException e) {
-            verifyException(e, "Can not parse");
-        }
-    }
-}
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateAdjustment204Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateAdjustment204Test.java
deleted file mode 100644
index c112d94be..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateAdjustment204Test.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.fasterxml.jackson.databind.deser.jdk;
-
-import java.util.Calendar;
-import java.util.TimeZone;
-
-import com.fasterxml.jackson.databind.*;
-
-public class DateAdjustment204Test extends BaseMapTest
-{
-    /*
-    /**********************************************************
-    /* Unit tests
-    /**********************************************************
-     */
-
-    private final ObjectMapper MAPPER = new ObjectMapper();
-
-    // for [databind#204]
-    public void testContextTimezone() throws Exception
-    {
-        String inputStr = "1997-07-16T19:20:30.45+0100";
-
-        // this is enabled by default:
-        assertTrue(MAPPER.isEnabled(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
-        final ObjectReader r =  MAPPER
-                .readerFor(Calendar.class)
-                .with(TimeZone.getTimeZone("PST"));
-
-        // by default use contextual timezone:
-        Calendar cal = r.readValue(quote(inputStr));
-        TimeZone tz = cal.getTimeZone();
-        assertEquals("PST", tz.getID());
-
-        assertEquals(1997, cal.get(Calendar.YEAR));
-        assertEquals(Calendar.JULY, cal.get(Calendar.MONTH));
-        assertEquals(16, cal.get(Calendar.DAY_OF_MONTH));
-
-        // Translated from original into PST differs:
-        assertEquals(11, cal.get(Calendar.HOUR_OF_DAY));
-        assertEquals(20, cal.get(Calendar.MINUTE));
-        assertEquals(30, cal.get(Calendar.SECOND));
-
-        // but if disabled, should use what's been sent in:
-        cal = r.without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
-                .readValue(quote(inputStr));
-
-        
-        // !!! TODO: would not yet pass
-/*
-        System.err.println("CAL/2 == "+cal);
-
-        System.err.println("tz == "+cal.getTimeZone());
-        */
-
-    }
-
-}
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTZTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTZTest.java
index 60a30b02e..9f05e94f3 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTZTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTZTest.java
@@ -103,17 +103,16 @@ public class DateDeserializationTZTest
 
         // Interpreted as if there was no timezone, therefore producing a date with the TZ set on the mapper
         // FIXME it is probably better to refuse these cases instead of silently creating dates in local tz...
-        verify( MAPPER, "2000-01-02T03:04:05.678+",        judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:05.678+1",       judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-            // FIXME this should probably give GMT+1
-        verify( MAPPER, "2000-01-02T03:04:05.678+001",     judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:05.678+00:",     judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:05.678+00:001",  judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:05.678+001:001", judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
-
-        // Considering the above forms have been accepted, it is strange the following are refused...
-        failure( MAPPER, "2000-01-02T03:04:05.678+1:");      // FIXME
-        failure( MAPPER, "2000-01-02T03:04:05.678+00:1");    // FIXME
+        failure( MAPPER, "2000-01-02T03:04:05.678+"); //        judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:05.678+1"); //       judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+
+        failure( MAPPER, "2000-01-02T03:04:05.678+001"); //   judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:05.678+00:"); //     judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:05.678+00:001"); //  judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:05.678+001:001"); // judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
+
+        failure( MAPPER, "2000-01-02T03:04:05.678+1:");
+        failure( MAPPER, "2000-01-02T03:04:05.678+00:1");
     }
 
     /**
@@ -122,34 +121,36 @@ public class DateDeserializationTZTest
     public void testDateUtilISO8601_DateTimeMillis() throws Exception 
     {    
         // WITH timezone (from 4 to 0 digits)
-        failure(MAPPER, "2000-01-02T03:04:05.6789+01:00");
         verify( MAPPER, "2000-01-02T03:04:05.678+01:00", judate(2000, 1, 2,   3, 4, 5, 678, "GMT+1"));
         verify( MAPPER, "2000-01-02T03:04:05.67+01:00",  judate(2000, 1, 2,   3, 4, 5, 670, "GMT+1"));
         verify( MAPPER, "2000-01-02T03:04:05.6+01:00",   judate(2000, 1, 2,   3, 4, 5, 600, "GMT+1"));
         verify( MAPPER, "2000-01-02T03:04:05+01:00",     judate(2000, 1, 2,   3, 4, 5, 000, "GMT+1"));
 
+
+//        failure(MAPPER, "2000-01-02T03:04:05.6789+01:00");
+//        failure( MAPPER, "2000-01-02T03:04:05.6789Z"); // , judate(2000, 1, 2,   3, 4, 11, 789, "UTC"));
         
         // WITH timezone Z (from 4 to 0 digits)
-        verify( MAPPER, "2000-01-02T03:04:05.6789Z", judate(2000, 1, 2,   3, 4, 11, 789, "UTC"));
             // FIXME the .6789 millis are interpreted as 6789 millisecondes or 6.789 seconds!
         verify( MAPPER, "2000-01-02T03:04:05.678Z", judate(2000, 1, 2,   3, 4, 5, 678, "UTC"));
-        verify( MAPPER, "2000-01-02T03:04:05.67Z",  judate(2000, 1, 2,   3, 4, 5,  67, "UTC"));
+        verify( MAPPER, "2000-01-02T03:04:05.67Z",  judate(2000, 1, 2,   3, 4, 5, 670, "UTC"));
            // FIXME should be 670 millis instead of 67
-        verify( MAPPER, "2000-01-02T03:04:05.6Z",   judate(2000, 1, 2,   3, 4, 5,   6, "UTC"));
+        verify( MAPPER, "2000-01-02T03:04:05.6Z",   judate(2000, 1, 2,   3, 4, 5, 600, "UTC"));
            // FIXME should be 600 millis instead of 6
         verify( MAPPER, "2000-01-02T03:04:05Z",     judate(2000, 1, 2,   3, 4, 5,   0, "UTC"));
         
 
         // WITHOUT timezone (from 4 to 0 digits)
-        verify(MAPPER, "2000-01-02T03:04:05.6789",       judate(2000, 1, 2,   3, 4, 11, 789, LOCAL_TZ));
             // FIXME: the .6789 millis are interpreted as 6789 millisecondes or 6.789 seconds!
         
         verify( MAPPER, "2000-01-02T03:04:05.678",       judate(2000, 1, 2,   3, 4,  5, 678, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:05.67",        judate(2000, 1, 2,   3, 5, 12, 000, LOCAL_TZ));
+        verify( MAPPER, "2000-01-02T03:04:05.67",        judate(2000, 1, 2,   3, 4,  5, 670, LOCAL_TZ));
             // FIXME: the .67 millis are interpreted as 67 seconds.
         
         verify( MAPPER, "2000-01-02T03:04:05.6",         judate(2000, 1, 2,   3, 4,  5, 600, LOCAL_TZ));
         verify( MAPPER, "2000-01-02T03:04:05",           judate(2000, 1, 2,   3, 4,  5, 000, LOCAL_TZ));
+
+//        failure(MAPPER, "2000-01-02T03:04:05.6789"); //       judate(2000, 1, 2,   3, 4, 11, 789, LOCAL_TZ));
         
         
         // ---------------------------------------------------------------------------------------------
@@ -172,9 +173,9 @@ public class DateDeserializationTZTest
         // ---------------------------------------------------------------------------------------------
         
         // millis part with only a dot (.) and no digits
-        verify( MAPPER, "2000-01-02T03:04:05.+01:00",    judate(2000, 1, 2,   3, 4, 5, 000, "GMT+1"));
-        verify( MAPPER, "2000-01-02T03:04:05.",          judate(2000, 1, 2,   3, 4, 5, 000, LOCAL_TZ));
-        failure(MAPPER, "2000-01-02T03:04:05.Z");	     // FIXME this one fails, but not the others...
+        failure( MAPPER, "2000-01-02T03:04:05.+01:00"); //    judate(2000, 1, 2,   3, 4, 5, 000, "GMT+1"));
+        failure( MAPPER, "2000-01-02T03:04:05.");       //   judate(2000, 1, 2,   3, 4, 5, 000, LOCAL_TZ));
+        failure(MAPPER, "2000-01-02T03:04:05.Z");	      // FIXME this one fails, but not the others...
     }
 
 
@@ -195,9 +196,9 @@ public class DateDeserializationTZTest
         failure(MAPPER, "2000-01-02T");
         failure(MAPPER, "2000-01-02T03");
         failure(MAPPER, "2000-01-02T03:");
-        failure(MAPPER, "2000-01-02T03:04");
+        verify(MAPPER, "2000-01-02T03:04", judate(2000, 1, 2,  3, 4, 0, 0, LOCAL_TZ));
         failure(MAPPER, "2000-01-02T03:04:");
-
+        
         // Although hours, minutes and seconds are mandatory, they can sometimes be omitted 
         // if a TZ is specified... !!??
         failure(MAPPER, "2000-01-02T+01:00");
@@ -209,7 +210,8 @@ public class DateDeserializationTZTest
         failure(MAPPER, "2000-01-02TZ");
         failure(MAPPER, "2000-01-02T03Z");
         failure(MAPPER, "2000-01-02T03:Z");
-        failure(MAPPER, "2000-01-02T03:04Z");
+        verify(MAPPER, "2000-01-02T03:04Z", judate(2000, 1, 2,  3, 4, 0, 0, "UTC"));
+
         failure(MAPPER, "2000-01-02T03:04:Z");
 
         
@@ -231,8 +233,8 @@ public class DateDeserializationTZTest
         // Behavior should be the SAME whatever the timezone and/or the millis.
         
         // seconds (no TZ)
-        verify( MAPPER, "2000-01-02T03:04:5",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:04:5.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:5"); //           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:04:5.000"); //       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
         failure(MAPPER, "2000-01-02T03:04:005");
         
         // seconds (+01:00)
@@ -242,13 +244,13 @@ public class DateDeserializationTZTest
         
         // seconds (Z)
         failure(MAPPER, "2000-01-02T03:04:5Z");
-        verify( MAPPER, "2000-01-02T03:04:5.000Z",      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T03:04:5.000Z"); //      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
         failure(MAPPER, "2000-01-02T03:04:005Z");
         
 
         // minutes (no TZ)
-        verify( MAPPER, "2000-01-02T03:4:05",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T03:4:05.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:4:05"); //           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T03:4:05.000"); //      judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
         failure(MAPPER, "2000-01-02T03:004:05");
         
         // minutes (+01:00)
@@ -257,14 +259,13 @@ public class DateDeserializationTZTest
         failure(MAPPER, "2000-01-02T03:004:05+01:00");
         
         // minutes (Z)
-        verify( MAPPER, "2000-01-02T03:4:05Z",          judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
-        verify( MAPPER, "2000-01-02T03:4:05.000Z",      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
-        verify( MAPPER, "2000-01-02T03:004:05Z",        judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
-
+        failure( MAPPER, "2000-01-02T03:4:05Z"); //          judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T03:4:05.000Z"); //      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T03:004:05Z"); //       judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
 
         // hour (no TZ)
-        verify( MAPPER, "2000-01-02T3:04:05",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
-        verify( MAPPER, "2000-01-02T3:04:05.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T3:04:05"); //           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
+        failure( MAPPER, "2000-01-02T3:04:05.000"); //       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
         failure(MAPPER, "2000-01-02T003:04:05");
 
         // hour (+01:00)
@@ -273,12 +274,11 @@ public class DateDeserializationTZTest
         failure(MAPPER, "2000-01-02T003:04:05+01:00");
 
         // hour (Z)
-        verify( MAPPER, "2000-01-02T3:04:05Z",         judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
-        verify( MAPPER, "2000-01-02T3:04:05.000Z",     judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
-        verify( MAPPER, "2000-01-02T003:04:05Z",       judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T3:04:05Z"); //         judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T3:04:05.000Z"); //     judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
+        failure( MAPPER, "2000-01-02T003:04:05Z"); //       judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
     }
 
-
     /**
      * Date-only representations (no Time part)
      * 
@@ -302,18 +302,18 @@ public class DateDeserializationTZTest
         // ---------------------------------------------------------------------------------------------
 
         // day
-        verify(  MAPPER, "2000-01-2",      judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
+        failure(  MAPPER, "2000-01-2"); //      judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
         failure( MAPPER, "2000-01-002");
         
         // month
-        verify(  MAPPER, "2000-1-02",      judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
+        failure(  MAPPER, "2000-1-02"); //     judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
         failure( MAPPER, "2000-001-02");
         
         // year
         failure( MAPPER, "20000-01-02");
         failure( MAPPER, "200-01-02"  );
         failure( MAPPER, "20-01-02"   );
-        verify(  MAPPER, "2-01-02",        judate(2, 1, 2,   0, 0, 0, 0, LOCAL_TZ));    // FIXME Why accept 1 digit and refuse they other cases??
+        failure(  MAPPER, "2-01-02"); // judate(2, 1, 2,   0, 0, 0, 0, LOCAL_TZ));    // FIXME Why accept 1 digit and refuse they other cases??
     }
 
     /**
@@ -559,6 +559,7 @@ public class DateDeserializationTZTest
         catch(Exception e) {
             // Is it the expected exception ?
             if (!exceptionType.isAssignableFrom(e.getClass()) ) {
+e.printStackTrace();
                 fail("Wrong exception thrown when reading "+input+", actual: "+e.getClass().getName() + "("+e.getMessage()+"), expected: "+exceptionType.getName());
             }
         }
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTest.java
index 78dbe2658..1697804ad 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateDeserializationTest.java
@@ -231,6 +231,8 @@ public class DateDeserializationTest
     {
         String inputStr;
         Date inputDate;
+
+        // 23-Jun-2017, tatu: Shouldn't this be UTC?
         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
 
         inputStr = "1997-07-16T19:20+01:00";
@@ -404,7 +406,10 @@ public class DateDeserializationTest
         result = MAPPER.readValue(quote(dateStr), Calendar.class);
 
         // note: representation may differ (wrt timezone etc), but underlying value must remain the same:
-        assertEquals(l, result.getTimeInMillis());
+        if (l != result.getTimeInMillis()) {
+            fail(String.format("Expected timestamp %d, got %d, for '%s'",
+                    l, result.getTimeInMillis(), dateStr));
+        }
     }
 
     public void testCustom() throws Exception
@@ -563,7 +568,55 @@ public class DateDeserializationTest
         // Underlying timestamps should be the same
         assertEquals(dateUTC.getTime(), dateGMT1.getTime());
     }
+
+    /*
+    /**********************************************************
+    /* Context timezone use (or not)
+    /**********************************************************
+     */
     
+    // for [databind#204]
+    public void testContextTimezone() throws Exception
+    {
+        String inputStr = "1997-07-16T19:20:30.45+0100";
+        final String tzId = "PST";
+
+        // this is enabled by default:
+        assertTrue(MAPPER.isEnabled(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
+        final ObjectReader r = MAPPER
+                .readerFor(Calendar.class)
+                .with(TimeZone.getTimeZone(tzId));
+
+        // by default use contextual timezone:
+        Calendar cal = r.readValue(quote(inputStr));
+        TimeZone tz = cal.getTimeZone();
+        assertEquals(tzId, tz.getID());
+
+        assertEquals(1997, cal.get(Calendar.YEAR));
+        assertEquals(Calendar.JULY, cal.get(Calendar.MONTH));
+        assertEquals(16, cal.get(Calendar.DAY_OF_MONTH));
+
+        // Translated from original into PST differs:
+        assertEquals(20, cal.get(Calendar.MINUTE));
+        assertEquals(30, cal.get(Calendar.SECOND));
+        assertEquals(11, cal.get(Calendar.HOUR_OF_DAY));
+
+        // but if disabled, should use what's been sent in:
+        cal = r.without(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE)
+                .readValue(quote(inputStr));
+
+        // 23-Jun-2017, tatu: Actually turns out to be hard if not impossible to do ...
+        //    problem being SimpleDateFormat does not really retain timezone offset.
+        //    But if we match fields... we perhaps could use it?
+        
+        // !!! TODO: would not yet pass
+/*
+        System.err.println("CAL/2 == "+cal);
+
+        System.err.println("tz == "+cal.getTimeZone());
+        */
+    }
+
     /*
     /**********************************************************
     /* Test(s) for array unwrapping
diff --git a/src/test/java/com/fasterxml/jackson/databind/util/TestStdDateFormat.java b/src/test/java/com/fasterxml/jackson/databind/util/TestStdDateFormat.java
new file mode 100644
index 000000000..7a2fb99bd
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestStdDateFormat.java
@@ -0,0 +1,141 @@
+package com.fasterxml.jackson.databind.util;
+
+import java.text.ParseException;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.fasterxml.jackson.databind.BaseMapTest;
+import com.fasterxml.jackson.databind.util.StdDateFormat;
+
+public class TestStdDateFormat
+    extends BaseMapTest
+{
+    public void testFactories() {
+        TimeZone tz = TimeZone.getTimeZone("GMT");
+        Locale loc = Locale.US;
+        assertNotNull(StdDateFormat.getISO8601Format(tz, loc));
+        assertNotNull(StdDateFormat.getRFC1123Format(tz, loc));
+    }
+
+    // [databind#803]
+    public void testLenientDefaults() throws Exception
+    {
+        StdDateFormat f = StdDateFormat.instance;
+
+        // default should be lenient
+        assertTrue(f.isLenient());
+
+        StdDateFormat f2 = f.clone();
+        assertTrue(f2.isLenient());
+
+        f2.setLenient(false);
+        assertFalse(f2.isLenient());
+
+        f2.setLenient(true);
+        assertTrue(f2.isLenient());
+
+        // and for testing, finally, leave as non-lenient
+        f2.setLenient(false);
+        assertFalse(f2.isLenient());
+        StdDateFormat f3 = f2.clone();
+        assertFalse(f3.isLenient());
+    }
+
+    public void testISO8601RegexpDateOnly() throws Exception
+    {
+        Pattern p = StdDateFormat.PATTERN_PLAIN;
+        Matcher m = p.matcher("1997-07-16");
+        assertTrue(m.matches());
+        // no matching groups...
+    }
+
+    public void testISO8601RegexpFull() throws Exception
+    {
+        /*
+        String PATTERN_PLAIN_STR = "\\d\\d\\d\\d[-]\\d\\d[-]\\d\\d";
+        Pattern PATTERN_ISO8601 = Pattern.compile(PATTERN_PLAIN_STR
+                +"[T]\\d\\d[:]\\d\\d(?:[:]\\d\\d)?" // hours, minutes, optional seconds
+                +"(\\.\\d+)?" // optional second fractions
+                +"(Z|[+-]\\d\\d(?:[:]?\\d\\d)?)?" // optional timeoffset/Z
+                );
+        final Pattern p = PATTERN_ISO8601;
+        */
+        final Pattern p = StdDateFormat.PATTERN_ISO8601;
+        Matcher m;
+
+        // First simple full representation (except no millisecs)
+        m = p.matcher("1997-07-16T19:20:00+01:00");
+        assertTrue(m.matches());
+        assertEquals(2, m.groupCount());
+        assertNull(m.group(1)); // no match (why not empty String)
+        assertEquals("+01:00", m.group(2));
+
+        // Then with 'Z' instead
+        m = p.matcher("1997-07-16T19:20:00Z");
+        assertTrue(m.matches());
+        assertNull(m.group(1));
+        assertEquals("Z", m.group(2));
+
+        // Then drop seconds too
+        m = p.matcher("1997-07-16T19:20+01:00");
+        assertTrue(m.matches());
+        assertNull(m.group(1));
+        assertEquals("+01:00", m.group(2));
+
+        // Full with milliseconds:
+        m = p.matcher("1997-07-16T19:20:00.2+03:00");
+        assertTrue(m.matches());
+        assertEquals(2, m.groupCount());
+        assertEquals(".2", m.group(1));
+        assertEquals("+03:00", m.group(2));
+        
+        m = p.matcher("1972-12-28T00:00:00.01-0300");
+        assertTrue(m.matches());
+        assertEquals(".01", m.group(1));
+        assertEquals("-0300", m.group(2));
+
+        m = p.matcher("1972-12-28T00:00:00.400+00");
+        assertTrue(m.matches());
+        assertEquals(".400", m.group(1));
+        assertEquals("+00", m.group(2));
+
+        // and then drop time offset AND seconds
+        m = p.matcher("1972-12-28T04:15");
+        assertTrue(m.matches());
+        assertNull(m.group(1));
+        assertNull(m.group(2));
+    }
+
+    public void testLenientParsing() throws Exception
+    {
+        StdDateFormat f = StdDateFormat.instance.clone();
+        f.setLenient(false);
+
+        // first, legal dates are... legal
+        Date dt = f.parse("2015-11-30");
+        assertNotNull(dt);
+
+        // but as importantly, when not lenient, do not allow
+        try {
+            f.parse("2015-11-32");
+            fail("Should not pass");
+        } catch (ParseException e) {
+            verifyException(e, "can not parse date");
+        }
+
+        // ... yet, with lenient, do allow
+        f.setLenient(true);
+        dt = f.parse("2015-11-32");
+        assertNotNull(dt);
+    }
+    
+    public void testInvalid() {
+        StdDateFormat std = new StdDateFormat();
+        try {
+            std.parse("foobar");
+        } catch (java.text.ParseException e) {
+            verifyException(e, "Can not parse");
+        }
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/failing/Core384Test.java b/src/test/java/com/fasterxml/jackson/failing/Core384Test.java
new file mode 100644
index 000000000..045168219
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/failing/Core384Test.java
@@ -0,0 +1,198 @@
+package com.fasterxml.jackson.failing;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
+import static org.hamcrest.CoreMatchers.instanceOf;
+
+import static org.junit.Assert.assertThat;
+
+import com.fasterxml.jackson.databind.*;
+
+public class Core384Test extends BaseMapTest
+{
+    public void testHierarchy() throws IOException {
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.enableDefaultTyping();
+
+        Fleet fleet = initVehicle();
+
+for (Vehicle v : fleet.vehicles) {
+    System.out.println("Vehicle, type: "+v.getClass());
+}
+        String serializedFleet = mapper
+                .writerWithDefaultPrettyPrinter()
+                .writeValueAsString(fleet);
+
+System.out.println(serializedFleet);
+
+        Fleet deserializedFleet = mapper.readValue(serializedFleet, Fleet.class);
+
+        assertThat(deserializedFleet.getVehicles().get(0), instanceOf(Car.class));
+        assertThat(deserializedFleet.getVehicles().get(1), instanceOf(Truck.class));
+
+        assertEquals(fleet, deserializedFleet);
+    }
+
+    private Fleet initVehicle() {
+        Car car = new Car("Mercedes-Benz", "S500", 5, 250.0);
+        Truck truck = new Truck("Isuzu", "NQR", 7500.0);
+
+        List<Vehicle> vehicles = new ArrayList<>();
+        vehicles.add(car);
+        vehicles.add(truck);
+
+        Fleet serializedFleet = new Fleet();
+        serializedFleet.setVehicles(vehicles);
+        return serializedFleet;
+    }
+
+    static class Fleet {
+        private List<Vehicle> vehicles;
+
+        public List<Vehicle> getVehicles() {
+            return vehicles;
+        }
+
+        public void setVehicles(List<Vehicle> vehicles) {
+            this.vehicles = vehicles;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            Fleet fleet = (Fleet) o;
+            return Objects.equals(vehicles, fleet.vehicles);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(vehicles);
+        }
+    }
+
+    static abstract class Vehicle {
+        private String make;
+        private String model;
+
+        protected Vehicle(String make, String model) {
+            this.make = make;
+            this.model = model;
+        }
+
+        public Vehicle() {
+        }
+
+        public String getMake() {
+            return make;
+        }
+
+        public void setMake(String make) {
+            this.make = make;
+        }
+
+        public String getModel() {
+            return model;
+        }
+
+        public void setModel(String model) {
+            this.model = model;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Vehicle)) return false;
+            Vehicle vehicle = (Vehicle) o;
+            return Objects.equals(make, vehicle.make) &&
+                    Objects.equals(model, vehicle.model);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(make, model);
+        }
+    }
+
+    class Car extends Vehicle {
+        private int seatingCapacity;
+        private double topSpeed;
+
+        public Car(String make, String model, int seatingCapacity, double topSpeed) {
+            super(make, model);
+            this.seatingCapacity = seatingCapacity;
+            this.topSpeed = topSpeed;
+        }
+
+        public Car() {
+        }
+
+        public int getSeatingCapacity() {
+            return seatingCapacity;
+        }
+
+        public void setSeatingCapacity(int seatingCapacity) {
+            this.seatingCapacity = seatingCapacity;
+        }
+
+        public double getTopSpeed() {
+            return topSpeed;
+        }
+
+        public void setTopSpeed(double topSpeed) {
+            this.topSpeed = topSpeed;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            if (!super.equals(o)) return false;
+            Car car = (Car) o;
+            return seatingCapacity == car.seatingCapacity &&
+                    Double.compare(car.topSpeed, topSpeed) == 0;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), seatingCapacity, topSpeed);
+        }
+    }
+
+    class Truck extends Vehicle {
+        private double payloadCapacity;
+
+        public Truck(String make, String model, double payloadCapacity) {
+            super(make, model);
+            this.payloadCapacity = payloadCapacity;
+        }
+
+        public Truck() {
+        }
+
+        public double getPayloadCapacity() {
+            return payloadCapacity;
+        }
+
+        public void setPayloadCapacity(double payloadCapacity) {
+            this.payloadCapacity = payloadCapacity;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            if (!super.equals(o)) return false;
+            Truck truck = (Truck) o;
+            return Double.compare(truck.payloadCapacity, payloadCapacity) == 0;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), payloadCapacity);
+        }
+    }
+}
