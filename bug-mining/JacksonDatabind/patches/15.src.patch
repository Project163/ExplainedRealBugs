diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
index 6ff4dbac9..a2fcfa8f2 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java
@@ -28,7 +28,7 @@ public class AbstractDeserializer
     protected final ObjectIdReader _objectIdReader;
 
     protected final Map<String, SettableBeanProperty> _backRefProperties;
-    
+
     // support for "native" types, which require special care:
     
     protected final boolean _acceptString;
@@ -49,6 +49,29 @@ public class AbstractDeserializer
         _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);
     }
 
+    protected AbstractDeserializer(BeanDescription beanDesc)
+    {
+        _baseType = beanDesc.getType();
+        _objectIdReader = null;
+        _backRefProperties = null;
+        Class<?> cls = _baseType.getRawClass();
+        _acceptString = cls.isAssignableFrom(String.class);
+        _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class);
+        _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class);
+        _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);
+    }
+    
+    /**
+     * Factory method used when constructing instances for non-POJO types, like
+     * {@link java.util.Map}s.
+     * 
+     * @since 2.3
+     */
+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)
+    {
+        return new AbstractDeserializer(beanDesc);
+    }
+    
     /*
     /**********************************************************
     /* Public accessors
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
index 9f9428c87..6ee2fbdc3 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
@@ -813,25 +813,32 @@ public abstract class BasicDeserializerFactory
             if (type.isInterface() || type.isAbstract()) {
                 CollectionType implType = _mapAbstractCollectionType(type, config);
                 if (implType == null) {
-                    throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type "+type);
-                }
-                type = implType;
-                // But if so, also need to re-check creators...
-                beanDesc = config.introspectForCreation(type);
-            }
-            ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
-            if (!inst.canCreateUsingDefault()) {
-                // [Issue#161]: No default constructor for ArrayBlockingQueue...
-                if (type.getRawClass() == ArrayBlockingQueue.class) {
-                    return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);
+                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled
+                    if (type.getTypeHandler() == null) {
+                        throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type "+type);
+                    }
+                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);
+                } else {
+                    type = implType;
+                    // But if so, also need to re-check creators...
+                    beanDesc = config.introspectForCreation(type);
                 }
             }
-            // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:
-            if (contentType.getRawClass() == String.class) {
-                // no value type deserializer because Strings are one of natural/native types:
-                deser = new StringCollectionDeserializer(type, contentDeser, inst);
-            } else {
-                deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);
+            if (deser == null) {
+                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
+                if (!inst.canCreateUsingDefault()) {
+                    // [Issue#161]: No default constructor for ArrayBlockingQueue...
+                    if (type.getRawClass() == ArrayBlockingQueue.class) {
+                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);
+                    }
+                }
+                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:
+                if (contentType.getRawClass() == String.class) {
+                    // no value type deserializer because Strings are one of natural/native types:
+                    deser = new StringCollectionDeserializer(type, contentDeser, inst);
+                } else {
+                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);
+                }
             }
         }
         // and then new with 2.2: ability to post-process it too (Issue#120)
@@ -940,7 +947,7 @@ public abstract class BasicDeserializerFactory
         if (contentTypeDeser == null) {
             contentTypeDeser = findTypeDeserializer(config, contentType);
         }
-
+        
         // 23-Nov-2010, tatu: Custom deserializer?
         JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,
                 keyDes, contentTypeDeser, contentDeser);
@@ -971,18 +978,25 @@ public abstract class BasicDeserializerFactory
                 if (type.isInterface() || type.isAbstract()) {
                     @SuppressWarnings("rawtypes")
                     Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());
-                    if (fallback == null) {
-                        throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type "+type);
+                    if (fallback != null) {
+                        mapClass = fallback;
+                        type = (MapType) config.constructSpecializedType(type, mapClass);
+                        // But if so, also need to re-check creators...
+                        beanDesc = config.introspectForCreation(type);
+                    } else {
+                        // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled
+                        if (type.getTypeHandler() == null) {
+                            throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type "+type);
+                        }
+                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);
                     }
-                    mapClass = fallback;
-                    type = (MapType) config.constructSpecializedType(type, mapClass);
-                    // But if so, also need to re-check creators...
-                    beanDesc = config.introspectForCreation(type);
                 }
-                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
-                MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);
-                md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));
-                deser = md;
+                if (deser == null) {
+                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
+                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);
+                    md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));
+                    deser = md;
+                }
             }
         }
         // and then new with 2.2: ability to post-process it too (Issue#120)
@@ -1559,10 +1573,10 @@ public abstract class BasicDeserializerFactory
             // probably only occurs if 'property' is null anyway
             valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);
         }
-    	if (valueTypeDeser != null) {
+        if (valueTypeDeser != null) {
             type = type.withTypeHandler(valueTypeDeser);
-    	}
-    	return type;
+        }
+        return type;
     }
     
     protected EnumResolver<?> constructEnumResolver(Class<?> enumClass,
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java
new file mode 100644
index 000000000..854b1145c
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java
@@ -0,0 +1,80 @@
+package com.fasterxml.jackson.databind.jsontype;
+
+import java.util.*;
+
+import com.fasterxml.jackson.annotation.*;
+import com.fasterxml.jackson.databind.*;
+
+/**
+ * For [Issue#292]
+ */
+@SuppressWarnings("serial")
+public class TestAbstractContainers extends BaseMapTest
+{
+    // Polymorphic abstract Map type, wrapper
+    
+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property="type")
+    @JsonSubTypes({ 
+        @JsonSubTypes.Type(value = MapWrapper.class, name = "wrapper"),
+    })
+    static class MapWrapper {
+        public  IDataValueMap map = new DataValueMap();     // This does NOT work
+    }
+
+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property="_type_")
+    @JsonSubTypes({ 
+        @JsonSubTypes.Type(value = DataValueMap.class,  name = "DataValueMap")
+    })
+    public interface IDataValueMap extends Map<String, String> { }
+
+    static class DataValueMap extends HashMap<String, String> implements IDataValueMap { }
+
+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property="type")
+    @JsonSubTypes({ 
+        @JsonSubTypes.Type(value = ListWrapper.class, name = "wrapper"),
+    })
+    static class ListWrapper {
+        public IDataValueList list = new DataValueList();     // This does NOT work
+    }
+
+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property="type")
+    @JsonSubTypes({ 
+        @JsonSubTypes.Type(value = DataValueList.class,  name = "list")
+    })
+    public interface IDataValueList extends List<String> { }
+
+    static class DataValueList extends LinkedList<String> implements IDataValueList { }
+   
+    /*
+    /**********************************************************
+    /* Test methods
+    /**********************************************************
+     */
+
+    public void testAbstractLists() throws Exception
+    {
+        ObjectMapper mapper = new ObjectMapper();
+        ListWrapper w = new ListWrapper();
+        w.list.add("x");
+
+        String json = mapper.writeValueAsString(w);
+        Object o = mapper.readValue(json, ListWrapper.class);
+        assertEquals(ListWrapper.class, o.getClass());
+        ListWrapper out = (ListWrapper) o;
+        assertEquals(1, out.list.size());
+        assertEquals("x", out.list.get(0));
+   }
+    
+    public void testAbstractMaps() throws Exception
+    {
+        ObjectMapper mapper = new ObjectMapper();
+        MapWrapper w = new MapWrapper();
+        w.map.put("key1", "name1");
+
+        String json = mapper.writeValueAsString(w);
+        Object o = mapper.readValue(json, MapWrapper.class);
+        assertEquals(MapWrapper.class, o.getClass());
+        MapWrapper out = (MapWrapper) o;
+        assertEquals(1, out.map.size());
+   }
+}
