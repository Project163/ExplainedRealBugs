diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5fefec8f9..4d291ccf5 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -28,6 +28,7 @@ Project: jackson-databind
  (suggested by Matt V, mveitas@github)
 #1187: Refactor `AtomicReferenceDeserializer` into `ReferenceTypeDeserializer`
 #1204: Add a convenience accessor `JavaType.hasContentType()` (true for container or reference type)
+#1206: Add "anchor type" member for `ReferenceType`
 #1211: Change `JsonValueSerializer` to get `AnnotatedMethod`, not "raw" method
 #1217: `@JsonIgnoreProperties` on Pojo fields not working for deserialization
  (reported by Lokesh K)
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
index 76deae2d7..39547340b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
@@ -16,38 +16,59 @@ public class ReferenceType extends SimpleType
 
     protected final JavaType _referencedType;
 
+    /**
+     * Essential type used for type ids, for example if type id is needed for
+     * referencing type with polymorphic handling. Typically initialized when
+     * a {@link SimpleType} is upgraded into reference type, but NOT changed
+     * if being sub-classed.
+     *
+     * @since 2.8
+     */
+    protected final JavaType _anchorType;
+    
     protected ReferenceType(Class<?> cls, TypeBindings bindings,
             JavaType superClass, JavaType[] superInts, JavaType refType,
+            JavaType anchorType,
             Object valueHandler, Object typeHandler, boolean asStatic)
     {
         super(cls, bindings, superClass, superInts, refType.hashCode(),
                 valueHandler, typeHandler, asStatic);
         _referencedType = refType;
+        _anchorType = (anchorType == null) ? this : anchorType;
     }
 
     /**
+     * Constructor used when upgrading into this type (via {@link #upgradeFrom},
+     * the usual way for {@link ReferenceType}s to come into existence.
+     * Sets up what is considered the "base" reference type
+     *
      * @since 2.7
      */
     protected ReferenceType(TypeBase base, JavaType refType)
     {
         super(base);
         _referencedType = refType;
+        // we'll establish this as the anchor type
+        _anchorType = this;
     }
 
     /**
      * Factory method that can be used to "upgrade" a basic type into collection-like
      * one; usually done via {@link TypeModifier}
+     * 
+     * @param baseType Resolved non-reference type (usually {@link SimpleType}) that is being upgraded
+     * @param refdType Referenced type; usually the first and only type parameter, but not necessarily
      *
      * @since 2.7
      */
-    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refType) {
-        if (refType == null) {
+    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType) {
+        if (refdType == null) {
             throw new IllegalArgumentException("Missing referencedType");
         }
         // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
         //    will cross that bridge if and when need be
         if (baseType instanceof TypeBase) {
-            return new ReferenceType((TypeBase) baseType, refType);
+            return new ReferenceType((TypeBase) baseType, refdType);
         }
         throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
     }
@@ -59,14 +80,14 @@ public class ReferenceType extends SimpleType
             JavaType superClass, JavaType[] superInts, JavaType refType)
     {
         return new ReferenceType(cls, bindings, superClass, superInts,
-                refType, null, null, false);
+                refType, null, null, null, false);
     }
 
     @Deprecated // since 2.7
     public static ReferenceType construct(Class<?> cls, JavaType refType) {
         return new ReferenceType(cls, TypeBindings.emptyBindings(),
                 // !!! TODO: missing supertypes
-                null, null, refType, null, null, false);
+                null, null, null, refType, null, null, false);
     }
 
     @Override
@@ -75,7 +96,7 @@ public class ReferenceType extends SimpleType
             return this;
         }
         return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
-                contentType, _valueHandler, _typeHandler, _asStatic);
+                contentType, _anchorType, _valueHandler, _typeHandler, _asStatic);
     }
 
     @Override
@@ -84,8 +105,8 @@ public class ReferenceType extends SimpleType
         if (h == _typeHandler) {
             return this;
         }
-        return new ReferenceType(_class, _bindings,
-                _superClass, _superInterfaces, _referencedType, _valueHandler, h, _asStatic);
+        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
+                _referencedType, _anchorType, _valueHandler, h, _asStatic);
     }
 
     @Override
@@ -94,8 +115,8 @@ public class ReferenceType extends SimpleType
         if (h == _referencedType.<Object>getTypeHandler()) {
             return this;
         }
-        return new ReferenceType(_class, _bindings,
-                _superClass, _superInterfaces, _referencedType.withTypeHandler(h),
+        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
+                _referencedType.withTypeHandler(h), _anchorType,
                 _valueHandler, _typeHandler, _asStatic);
     }
 
@@ -105,7 +126,8 @@ public class ReferenceType extends SimpleType
             return this;
         }
         return new ReferenceType(_class, _bindings,
-                _superClass, _superInterfaces, _referencedType, h, _typeHandler,_asStatic);
+                _superClass, _superInterfaces, _referencedType, _anchorType,
+                h, _typeHandler,_asStatic);
     }
 
     @Override
@@ -115,7 +137,7 @@ public class ReferenceType extends SimpleType
         }
         JavaType refdType = _referencedType.withValueHandler(h);
         return new ReferenceType(_class, _bindings,
-                _superClass, _superInterfaces, refdType,
+                _superClass, _superInterfaces, refdType, _anchorType,
                 _valueHandler, _typeHandler, _asStatic);
     }
 
@@ -124,8 +146,8 @@ public class ReferenceType extends SimpleType
         if (_asStatic) {
             return this;
         }
-        return new ReferenceType(_class, _bindings,
-                _superClass, _superInterfaces, _referencedType.withStaticTyping(),
+        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
+                _referencedType.withStaticTyping(), _anchorType,
                  _valueHandler, _typeHandler, true);
     }
 
@@ -133,7 +155,7 @@ public class ReferenceType extends SimpleType
     public JavaType refine(Class<?> rawType, TypeBindings bindings,
             JavaType superClass, JavaType[] superInterfaces) {
         return new ReferenceType(rawType, _bindings,
-                superClass, superInterfaces, _referencedType,
+                superClass, superInterfaces, _referencedType, _anchorType,
                 _valueHandler, _typeHandler, _asStatic);
     }
 
@@ -159,7 +181,7 @@ public class ReferenceType extends SimpleType
     {
         // Should we check that there is a sub-class relationship?
         return new ReferenceType(subclass, _bindings,
-                _superClass, _superInterfaces, _referencedType,
+                _superClass, _superInterfaces, _referencedType, _anchorType,
                 _valueHandler, _typeHandler, _asStatic);
     }
 
@@ -198,7 +220,25 @@ public class ReferenceType extends SimpleType
         sb.append(">;");
         return sb;
     }
-    
+
+    /*
+    /**********************************************************
+    /* Extended API
+    /**********************************************************
+     */
+
+    public JavaType getAnchorType() {
+        return _anchorType;
+    }
+
+    /**
+     * Convenience accessor that allows checking whether this is the anchor type
+     * itself; if not, it must be one of supertypes that is also a {@link ReferenceType}
+     */
+    public boolean isAnchorType() {
+        return (_anchorType == this);
+    }
+
     /*
     /**********************************************************
     /* Standard methods
diff --git a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
index ba1fe879a..a49844786 100644
--- a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
@@ -36,6 +36,9 @@ public class TestJavaType
         public Map<String,String> getMap();
     }
 
+    @SuppressWarnings("serial")
+    static class AtomicStringReference extends AtomicReference<String> { }
+    
     /*
     /**********************************************************
     /* Test methods
@@ -171,4 +174,14 @@ public class TestJavaType
         t  = tf.constructType(m.getGenericReturnType());
         assertEquals("Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;", t.getGenericSignature());
     }
+
+    public void testAnchorTypeForRefTypes1206() throws Exception
+    {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        JavaType t  = tf.constructType(AtomicStringReference.class);
+        assertTrue(t.isReferenceType());
+        ReferenceType rt = (ReferenceType) t;
+        assertFalse(rt.isAnchorType());
+        assertEquals(AtomicReference.class, rt.getAnchorType().getRawClass());
+    }
 }
