diff --git a/release-notes/VERSION b/release-notes/VERSION
index bc774fcad..01f468dfe 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -22,6 +22,8 @@ Version: 2.4.0 (xx-xxx-2014)
 #407: Properly use null handlers for value types when serializer Collection
  and array types
  (contributed by Will P)
+#428: `PropertyNamingStrategy` will rename even explicit name from `@JsonProperty`)
+ (reported by turskip@github)
 
 ------------------------------------------------------------------------
 === History: ===
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
index 0e434f262..d2e866a4f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
@@ -395,8 +395,11 @@ public class POJOPropertiesCollector
                 PropertyName pn = ai.findNameForDeserialization(f);
                 explName = (pn == null) ? null : pn.getSimpleName();
             }
+            boolean nameExplicit = (explName != null);
+            
             if ("".equals(explName)) { // empty String meaning "use default name", here just means "same as field name"
                 explName = implName;
+                nameExplicit= false;
             }
             // having explicit name means that field is visible; otherwise need to check the rules
             boolean visible = (explName != null);
@@ -413,7 +416,7 @@ public class POJOPropertiesCollector
             if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) {
                 continue;
             }
-            _property(implName).addField(f, explName, true, visible, ignored);
+            _property(implName).addField(f, explName, nameExplicit, visible, ignored);
         }
     }
 
@@ -519,7 +522,10 @@ public class POJOPropertiesCollector
 
         PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);
         String explName = (pn == null) ? null : pn.getSimpleName();
-        if (explName == null) { // no explicit name; must follow naming convention
+        
+        boolean nameExplicit = (explName != null);
+
+        if (!nameExplicit) { // no explicit name; must follow naming convention
             implName = BeanUtil.okNameForRegularGetter(m, m.getName());
             if (implName == null) { // if not, must skip
                 implName = BeanUtil.okNameForIsGetter(m, m.getName());
@@ -538,12 +544,13 @@ public class POJOPropertiesCollector
                 implName = m.getName();
             }
             if (explName.length() == 0) {
+                nameExplicit = false;
                 explName = implName;
             }
             visible = true;
         }
         boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);
-        _property(implName).addGetter(m, explName, true, visible, ignore);
+        _property(implName).addGetter(m, explName, nameExplicit, visible, ignore);
     }
 
     protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)
@@ -552,7 +559,8 @@ public class POJOPropertiesCollector
         boolean visible;
         PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);
         String explName = (pn == null) ? null : pn.getSimpleName();
-        if (explName == null) { // no explicit name; must follow naming convention
+        boolean nameExplicit = (explName != null);
+        if (!nameExplicit) { // no explicit name; must follow naming convention
             implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);
             if (implName == null) { // if not, must skip
             	return;
@@ -567,11 +575,12 @@ public class POJOPropertiesCollector
             }
             if (explName.length() == 0) { 
                 explName = implName;
+                nameExplicit = false;
             }
             visible = true;
         }
         boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);
-        _property(implName).addSetter(m, explName, true, visible, ignore);
+        _property(implName).addSetter(m, explName, nameExplicit, visible, ignore);
     }
     
     protected void _addInjectables()
@@ -714,24 +723,28 @@ public class POJOPropertiesCollector
         for (POJOPropertyBuilder prop : props) {
             PropertyName fullName = prop.getFullName();
             String rename = null;
-            if (_forSerialization) {
-                if (prop.hasGetter()) {
-                    rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
-                } else if (prop.hasField()) {
-                    rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
-                }
-            } else {
-                if (prop.hasSetter()) {
-                    rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());
-                } else if (prop.hasConstructorParameter()) {
-                    rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());
-                } else if (prop.hasField()) {
-                    rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
-                } else if (prop.hasGetter()) {
-                    /* Plus, when getter-as-setter is used, need to convert that too..
-                     * (should we verify that's enabled? For now, assume it's ok always)
-                     */
-                    rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
+            // As per [#428](https://github.com/FasterXML/jackson-databind/issues/428) need
+            // to skip renaming if property has explicitly defined name
+            if (!prop.isExplicitlyNamed()) {
+                if (_forSerialization) {
+                    if (prop.hasGetter()) {
+                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
+                    } else if (prop.hasField()) {
+                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
+                    }
+                } else {
+                    if (prop.hasSetter()) {
+                        rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());
+                    } else if (prop.hasConstructorParameter()) {
+                        rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());
+                    } else if (prop.hasField()) {
+                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
+                    } else if (prop.hasGetter()) {
+                        /* Plus, when getter-as-setter is used, need to convert that too..
+                         * (should we verify that's enabled? For now, assume it's ok always)
+                         */
+                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
+                    }
                 }
             }
             final String simpleName;
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
index a9ccb201c..f837458a4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
@@ -513,14 +513,6 @@ public class POJOPropertyBuilder
         _ctorParameters = _removeIgnored(_ctorParameters);
     }
 
-    /**
-     * @deprecated Since 2.2, use variant that takes boolean argument
-     */
-    @Deprecated
-    public void removeNonVisible() {
-        removeNonVisible(false);
-    }
-    
     public void removeNonVisible(boolean force)
     {
         /* 21-Aug-2011, tatu: This is tricky part -- if and when allow
