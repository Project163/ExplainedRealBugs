diff --git a/release-notes/VERSION b/release-notes/VERSION
index f759db655..a27c4687b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -62,6 +62,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #3046: Rename `JsonSerializable` as `JacksonSerializable`
 #3047: Rename `Bean[De]SerializerModifier` as `Value[De]SerializerModifier`
 #3070: Change default for `SerializationFeature.FAIL_ON_EMPTY_BEANS` to `false`
+#3522: Support serializing `ByteArrayOutputStream` as "simple" Binary value
 #3536: Create new exception type `JsonNodeException` for use by `JsonNode`-related problems
 #3542: Rename "com.fasterxml.jackson" -> "tools.jackson"
 #3561: Add `DeserializationContext` as an argument for `SettableBeanProperty.set(...)`
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/ByteArraySerializer.java b/src/main/java/tools/jackson/databind/ser/jdk/ByteArraySerializer.java
index 42d4507ff..7e918aaa6 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/ByteArraySerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/ByteArraySerializer.java
@@ -4,11 +4,10 @@ import tools.jackson.core.JacksonException;
 import tools.jackson.core.JsonGenerator;
 import tools.jackson.core.JsonToken;
 import tools.jackson.core.type.WritableTypeId;
+
 import tools.jackson.databind.JavaType;
 import tools.jackson.databind.SerializationContext;
 import tools.jackson.databind.annotation.JacksonStdImpl;
-import tools.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
-import tools.jackson.databind.jsonFormatVisitors.JsonFormatTypes;
 import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import tools.jackson.databind.jsontype.TypeSerializer;
 import tools.jackson.databind.ser.std.StdSerializer;
@@ -66,15 +65,6 @@ public class ByteArraySerializer extends StdSerializer<byte[]>
     @Override
     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
     {
-        // 14-Mar-2016, tatu: while logically (and within JVM) binary, gets encoded as Base64 String,
-        // let's try to indicate it is array of Bytes... difficult, thanks to JSON Schema's
-        // lackluster listing of types
-        //
-        // TODO: for 2.8, make work either as String/base64, or array of numbers,
-        //   with a qualifier that can be used to determine it's byte[]
-        JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
-        if (v2 != null) {
-            v2.itemsFormat(JsonFormatTypes.INTEGER);
-        }
+        acceptJsonFormatVisitorForBinary(visitor, typeHint);
     }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/ByteBufferSerializer.java b/src/main/java/tools/jackson/databind/ser/jdk/ByteBufferSerializer.java
index 7bc722b65..5e7b79435 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/ByteBufferSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/ByteBufferSerializer.java
@@ -4,8 +4,6 @@ import java.nio.ByteBuffer;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
-import tools.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
-import tools.jackson.databind.jsonFormatVisitors.JsonFormatTypes;
 import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import tools.jackson.databind.ser.std.StdScalarSerializer;
 import tools.jackson.databind.util.ByteBufferBackedInputStream;
@@ -33,12 +31,7 @@ public class ByteBufferSerializer extends StdScalarSerializer<ByteBuffer>
     }
 
     @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-    {
-        // 31-Mar-2017, tatu: Use same type as `ByteArraySerializer`: not optimal but has to do
-        JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
-        if (v2 != null) {
-            v2.itemsFormat(JsonFormatTypes.INTEGER);
-        }
+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {
+        acceptJsonFormatVisitorForBinary(visitor, typeHint);
     }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/JDKMiscSerializers.java b/src/main/java/tools/jackson/databind/ser/jdk/JDKMiscSerializers.java
index f06ef3c91..265aa7cf2 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/JDKMiscSerializers.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/JDKMiscSerializers.java
@@ -1,5 +1,6 @@
 package tools.jackson.databind.ser.jdk;
 
+import java.io.ByteArrayOutputStream;
 import java.util.*;
 import java.util.concurrent.atomic.*;
 
@@ -50,6 +51,9 @@ public class JDKMiscSerializers
         if ((raw == Void.class) || (raw == Void.TYPE)) {
             return NullSerializer.instance;
         }
+        if (ByteArrayOutputStream.class.isAssignableFrom(raw)) {
+            return new ByteArrayOutputStreamSerializer();
+        }
         return null;
     }
 
@@ -108,4 +112,31 @@ public class JDKMiscSerializers
             visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);
         }
     }
+
+    /*
+    /**********************************************************************
+    /* Serializers, other
+    /**********************************************************************
+     */
+
+    /**
+     * @since 3.0
+     */
+    public static class ByteArrayOutputStreamSerializer
+        extends StdScalarSerializer<ByteArrayOutputStream>
+    {
+        public ByteArrayOutputStreamSerializer() { super(ByteArrayOutputStream.class, false); }
+
+        @Override
+        public void serialize(ByteArrayOutputStream value, JsonGenerator gen,
+                SerializationContext ctxt) throws JacksonException {
+            gen.writeBinary(value.toByteArray());
+        }
+
+        @Override
+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
+        {
+            acceptJsonFormatVisitorForBinary(visitor, typeHint);
+        }
+    }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
index b72bd3604..a531e8a30 100644
--- a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
@@ -106,6 +106,25 @@ public abstract class StdSerializer<T>
         visitor.expectAnyFormat(typeHint);
     }
 
+    /**
+     * Helper method for handling Binary values: typically serialized as Base64-encoded
+     * data (in textual formats) or native binary (binary formats).
+     */
+    protected void acceptJsonFormatVisitorForBinary(JsonFormatVisitorWrapper visitor, JavaType typeHint)
+    {
+        // 14-Mar-2016, tatu: while logically (and within JVM) binary, gets often encoded
+        // as Base64 String, let's try to indicate it is array of Bytes... difficult,
+        // thanks to JSON Schema's lackluster set of types available
+        //
+        // TODO: make work either as String/base64, or array of numbers,
+        //   with a qualifier that can be used to determine it's byte[]
+
+        JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
+        if (v2 != null) {
+            v2.itemsFormat(JsonFormatTypes.INTEGER);
+        }
+    }
+
     /*
     /**********************************************************************
     /* Helper methods for JSON Schema generation
diff --git a/src/test/java/tools/jackson/databind/ser/jdk/JDKTypeSerializationTest.java b/src/test/java/tools/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
index b7937209e..4b602d7d6 100644
--- a/src/test/java/tools/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
+++ b/src/test/java/tools/jackson/databind/ser/jdk/JDKTypeSerializationTest.java
@@ -258,4 +258,15 @@ public class JDKTypeSerializationTest
         assertNotNull(cl);
         assertEquals(0, cl.size());
     }
+
+    // [databind#3522]: ByteArrayOutputStream 
+    @Test
+    public void testByteArrayOutputStreamSerialization() throws Exception
+    {
+        byte[] bytes = new byte[] { 1, 11, 111 };
+        final String exp = MAPPER.writeValueAsString(bytes);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        baos.write(bytes);
+        assertEquals(exp, MAPPER.writeValueAsString(baos));
+    }
 }
diff --git a/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java b/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java
index 821559dba..0b048029a 100644
--- a/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java
+++ b/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java
@@ -433,10 +433,4 @@ public class JavaUtilDateSerializationTest
         String result = w.writeValueAsString(date);
         assertTrue(expected.contains(result), "unexpected result: " + result);
     }
-
-    private String zoneOffset(String raw) {
-        // Add colon or not -- difference between 2.10 and earlier, 2.11 and later
-        return raw.substring(0, 2) + ":" + raw.substring(2); // 2.11 and later
-//        return raw; // 2.10 and earlier
-    }
 }
