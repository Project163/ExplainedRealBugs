diff --git a/release-notes/VERSION b/release-notes/VERSION
index 6a3ac893f..d5a0eb21e 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -16,6 +16,8 @@ Project: jackson-databind
  (contributed by Sergio M)
 #941: Deserialization from "{}" to ObjectNode field causes "out of END_OBJECT token" error
  (reported by Sadayuki F)
+#943: Incorrect serialization of enum map key
+ (reported by Benson M)
 #944: Failure to use custom deserializer for key deserializer
  (contributed by Benson M)
 #949: Report the offending substring when number parsing fails
diff --git a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
index 4e5631530..d82a0b4c3 100644
--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
@@ -751,8 +751,7 @@ public abstract class SerializerProvider
      * Note that the serializer itself can be called with instances
      * of any Java object, but not nulls.
      */
-    public JsonSerializer<Object> findKeySerializer(JavaType keyType,
-            BeanProperty property)
+    public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property)
         throws JsonMappingException
     {
         JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, _keySerializer);
@@ -760,6 +759,15 @@ public abstract class SerializerProvider
         return _handleContextualResolvable(ser, property);
     }
 
+    /**
+     * @since 2.7
+     */
+    public JsonSerializer<Object> findKeySerializer(Class<?> rawKeyType, BeanProperty property)
+        throws JsonMappingException
+    {
+        return findKeySerializer(_config.constructType(rawKeyType), property);
+    }
+
     /*
     /********************************************************
     /* Accessors for specialized serializers
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java
index acaa17809..d50b0428c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java
@@ -838,13 +838,13 @@ public class BeanPropertyWriter extends PropertyWriter
         }
         _depositSchemaProperty(propertiesNode, schemaNode);
     }
-    
+
     /*
     /**********************************************************
     /* Helper methods
     /**********************************************************
      */
-    
+
     protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,
             Class<?> type, SerializerProvider provider) throws JsonMappingException
     {
@@ -861,7 +861,7 @@ public class BeanPropertyWriter extends PropertyWriter
         }
         return result.serializer;
     }
-    
+
     /**
      * Method that can be used to access value of the property this
      * Object describes, from given bean instance.
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java
index 712beb388..9e4c7d55e 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java
@@ -72,7 +72,7 @@ public abstract class SerializerFactory
      * be output as <code>JsonToken.FIELD_NAME</code>) for Map that has specified declared
      * key type, and is for specified property (or, if property is null, as root value)
      * 
-     * @param baseType Declared type for Map keys
+     * @param type Declared type for Map keys
      * @param defaultImpl Default key serializer implementation to use, if no custom ones
      *    are found (may be null)
      * 
@@ -80,6 +80,6 @@ public abstract class SerializerFactory
      *   serializer is to be used)
      */
     public abstract JsonSerializer<Object> createKeySerializer(SerializationConfig config,
-            JavaType baseType, JsonSerializer<Object> defaultImpl)
+            JavaType type, JsonSerializer<Object> defaultImpl)
         throws JsonMappingException;
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java
index 2038b9980..b44ad4b0d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java
@@ -129,6 +129,22 @@ public abstract class PropertySerializerMap
         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));
     }
 
+    /**
+     * Method called if initial lookup fails, when looking for a key
+     * serializer (possible attached indirectly to a property)
+     * Will both find serializer
+     * and construct new map instance if warranted, and return both.
+     * 
+     * @since 2.7
+     */
+    public final SerializerAndMapResult findAndAddKeySerializer(Class<?> type,
+            SerializerProvider provider, BeanProperty property)
+        throws JsonMappingException
+    {
+        JsonSerializer<Object> serializer = provider.findKeySerializer(type, property);
+        return new SerializerAndMapResult(serializer, newWith(type, serializer));
+    }
+    
     /**
      * Method that can be used to 'register' a serializer that caller has resolved
      * without help of this map.
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
index 8c8bf0660..49d42eeed 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
@@ -6,6 +6,7 @@ import java.util.Date;
 
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;
 
 @SuppressWarnings("serial")
 public class StdKeySerializers
@@ -30,28 +31,31 @@ public class StdKeySerializers
         //    can not be used, since caller has not yet checked for that annotation
         //    This is why Enum types are not handled here quite yet
 
-        if (rawKeyType != null) {
-            if (rawKeyType == String.class) {
-                return DEFAULT_STRING_SERIALIZER;
-            }
-            if (rawKeyType == Object.class || rawKeyType.isPrimitive()
-                    || Number.class.isAssignableFrom(rawKeyType)) {
-                return DEFAULT_KEY_SERIALIZER;
-            }
-            if (rawKeyType == Class.class) {
-                return new Default(Default.TYPE_CLASS, rawKeyType);
-            }
-            if (Date.class.isAssignableFrom(rawKeyType)) {
-                return new Default(Default.TYPE_DATE, rawKeyType);
-            }
-            if (Calendar.class.isAssignableFrom(rawKeyType)) {
-                return new Default(Default.TYPE_CALENDAR, rawKeyType);
-            }
-            // other JDK types we know convert properly with 'toString()'?
-            if (rawKeyType == java.util.UUID.class) {
-                return new Default(Default.TYPE_TO_STRING, rawKeyType);
-            }
+        // [databind#943: Use a dynamic key serializer if we are not given actual
+        // type declaration
+        if ((rawKeyType == null) || (rawKeyType == Object.class)) {
+            // !!! TODO
+            return new Dynamic();
+        }
 
+        if (rawKeyType == String.class) {
+            return DEFAULT_STRING_SERIALIZER;
+        }
+        if (rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) {
+            return DEFAULT_KEY_SERIALIZER;
+        }
+        if (rawKeyType == Class.class) {
+            return new Default(Default.TYPE_CLASS, rawKeyType);
+        }
+        if (Date.class.isAssignableFrom(rawKeyType)) {
+            return new Default(Default.TYPE_DATE, rawKeyType);
+        }
+        if (Calendar.class.isAssignableFrom(rawKeyType)) {
+            return new Default(Default.TYPE_CALENDAR, rawKeyType);
+        }
+        // other JDK types we know convert properly with 'toString()'?
+        if (rawKeyType == java.util.UUID.class) {
+            return new Default(Default.TYPE_TO_STRING, rawKeyType);
         }
         return useDefault ? DEFAULT_KEY_SERIALIZER : null;
     }
@@ -94,6 +98,14 @@ public class StdKeySerializers
     /**********************************************************
      */
 
+    /**
+     * This is a "chameleon" style multi-type key serializer for simple
+     * standard JDK types.
+     *<p>
+     * TODO: Should (but does not yet) support re-configuring format used for
+     * {@link java.util.Date} and {@link java.util.Calendar} key serializers,
+     * as well as alternative configuration of Enum key serializers.
+     */
     public static class Default extends StdSerializer<Object> {
         final static int TYPE_DATE = 1;
         final static int TYPE_CALENDAR = 2;
@@ -134,6 +146,55 @@ public class StdKeySerializers
         }
     }
 
+    /**
+     * Key serializer used when key type is not known statically, and actual key
+     * serializer needs to be dynamically located.
+     */
+    public static class Dynamic extends StdSerializer<Object>
+    {
+        // Important: MUST be transient, to allow serialization of key serializer itself
+        protected transient PropertySerializerMap _dynamicSerializers;
+        
+        public Dynamic() {
+            super(String.class, false);
+            _dynamicSerializers = PropertySerializerMap.emptyForProperties();
+        }
+
+        Object readResolve() {
+            // Since it's transient, and since JDK serialization by-passes ctor, need this:
+            _dynamicSerializers = PropertySerializerMap.emptyForProperties();
+            return this;
+        }
+
+        @Override
+        public void serialize(Object value, JsonGenerator g, SerializerProvider provider)
+                throws IOException {
+            Class<?> cls = value.getClass();
+            PropertySerializerMap m = _dynamicSerializers;
+            JsonSerializer<Object> ser = m.serializerFor(cls);
+            if (ser == null) {
+                ser = _findAndAddDynamic(m, cls, provider);
+            }
+            ser.serialize(value, g, provider);
+        }
+
+        protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,
+                Class<?> type, SerializerProvider provider) throws JsonMappingException
+        {
+            PropertySerializerMap.SerializerAndMapResult result =
+                    // null -> for now we won't keep ref or pass BeanProperty; could change
+                    map.findAndAddKeySerializer(type, provider, null);
+            // did we get a new map of serializers? If so, start using it
+            if (map != result.map) {
+                _dynamicSerializers = result.map;
+            }
+            return result.serializer;
+        }
+    }
+
+    /**
+     * Simple and fast key serializer when keys are Strings.
+     */
     public static class StringKeySerializer extends StdSerializer<Object>
     {
         public StringKeySerializer() { super(String.class, false); }
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java
index bc652592a..5a4b1a57e 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java
@@ -188,6 +188,6 @@ public class TestKeySerializers extends BaseMapTest
         stuff.put(AbcLC.B, Integer.valueOf(3));
         stuff.put(new UCString("foo"), Integer.valueOf(4));
         String json = MAPPER.writeValueAsString(stuff);
-        assertEquals("{'b':3,'FOO':4}", aposToQuotes(json));
+        assertEquals(aposToQuotes("{'b':3,'FOO':4}"), json);
     }
 }
