diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 6cf05385d..05d965280 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -8,6 +8,9 @@ Project: jackson-databind
 
 #1565: Deserialization failure with Polymorphism using JsonTypeInfo `defaultImpl`,
   subtype as target
+#1964: Failed to specialize `Map` type during serialization where key type
+  incompatibility overidden via "raw" types
+ (reported by ptirador@github)
 #1998: Removing "type" attribute with Mixin not taken in account if
   using ObjectMapper.copy()
  (reported by SBKila@github)
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
index c1e38bf39..ba56b4691 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
@@ -455,6 +455,15 @@ public final class TypeFactory
             JavaType exp = expectedTypes.get(i);
             JavaType act = actualTypes.get(i);
             if (!_verifyAndResolvePlaceholders(exp, act)) {
+                // 19-Apr-2018, tatu: Hack for [databind#1964] -- allow type demotion
+                //    for `java.util.Map` key type if (and only if) target type is
+                //    `java.lang.Object`
+                if (i == 0) {
+                    if (sourceType.hasRawClass(Map.class)
+                            && act.hasRawClass(Object.class)) {
+                        continue;
+                    }
+                }
                 return String.format("Type parameter #%d/%d differs; can not specialize %s with %s",
                         (i+1), len, exp.toCanonical(), act.toCanonical());
             }
diff --git a/src/test/java/com/fasterxml/jackson/databind/mixins/MapperMixinsCopy1998Test.java b/src/test/java/com/fasterxml/jackson/databind/mixins/MapperMixinsCopy1998Test.java
index c6dae916f..32897e659 100644
--- a/src/test/java/com/fasterxml/jackson/databind/mixins/MapperMixinsCopy1998Test.java
+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/MapperMixinsCopy1998Test.java
@@ -108,7 +108,6 @@ public class MapperMixinsCopy1998Test extends BaseMapTest
                 .setConfig(myObjectMapper.getSerializationConfig().withView(MyModelView.class));
 
         String result = getString(myModelInstance, myObjectMapper);
-System.out.println("result: "+result);
         assertEquals(EXPECTED, result);
 
     }
diff --git a/src/test/java/com/fasterxml/jackson/failing/SubTypeResolution1964Test.java b/src/test/java/com/fasterxml/jackson/failing/SubTypeResolution1964Test.java
index f6d9bc957..d5bad8d2f 100644
--- a/src/test/java/com/fasterxml/jackson/failing/SubTypeResolution1964Test.java
+++ b/src/test/java/com/fasterxml/jackson/failing/SubTypeResolution1964Test.java
@@ -4,21 +4,31 @@ import java.util.*;
 
 import com.fasterxml.jackson.databind.*;
 
+/**
+ * Test for [databind#1964], wherein slightly incompatible type hierarchy,
+ * where `Map` key is downcast from `String` to `Object` (via use of "raw"
+ * types to force compiler to ignore incompatibility) causes exception
+ * during serialization. Although ideally code would not force round peg
+ * through square hole, it makes sense to add specific exception to allow
+ * such downcast just for Map key types (for now at least).
+ */
 @SuppressWarnings("serial")
 public class SubTypeResolution1964Test extends BaseMapTest
 {
     static class AccessModel {
-        private Map<Object, Collection<String>> repositoryPrivileges;
-        
+        private Map<String, Collection<String>> repositoryPrivileges;
+
         public AccessModel() {
             repositoryPrivileges = new HashMap<>();
         }
-        
-        public Map<Object, Collection<String>> getRepositoryPrivileges() {
+
+        // 19-Apr-2018, tatu; this would prevent issues
+//        @JsonSerialize(typing = JsonSerialize.Typing.STATIC)
+        public Map<String, Collection<String>> getRepositoryPrivileges() {
             return repositoryPrivileges;
         }
-        
-        public void setRepositoryPrivileges(Map<Object, Collection<String>> repositoryPrivileges) {
+
+        public void setRepositoryPrivileges(Map<String, Collection<String>> repositoryPrivileges) {
             this.repositoryPrivileges = repositoryPrivileges;
         }
     }
@@ -27,7 +37,10 @@ public class SubTypeResolution1964Test extends BaseMapTest
 
     public void testTypeCompatibility1964() throws Exception
     {
-        Map<Object, Collection<String>> repoPrivilegesMap = new CustomMap<>();
+        // Important! Must use raw type since assignment requires effectively
+        // casting due incompatible type parameters.
+        @SuppressWarnings("unchecked")
+        Map<String, Collection<String>> repoPrivilegesMap = new CustomMap();
         String key = "/storages/storage0/releases";
         Collection<String> values = new HashSet<>();
         values.add("ARTIFACTS_RESOLVE");
@@ -38,6 +51,7 @@ public class SubTypeResolution1964Test extends BaseMapTest
 
         ObjectMapper mapper = new ObjectMapper();
         String jsonStr = mapper.writeValueAsString(accessModel);
+        // ... could/should verify more, perhaps, but for now let it be.
         assertNotNull(jsonStr);
     }
 }
