diff --git a/release-notes/VERSION b/release-notes/VERSION
index 97930c743..2cf4af929 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -8,6 +8,8 @@ Project: jackson-databind
 
 #1088: NPE possibility in SimpleMixinResolver
  (reported by Laird N)
+#1108: Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error
+ (reported by jefferyyuan@github)
 
 2.6.5 (19-Jan-2016)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java
index 196a1c5b5..04535951d 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java
@@ -28,26 +28,35 @@ public class NullifyingDeserializer
      */
     
     @Override
-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)
-        throws IOException, JsonProcessingException
+    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        jp.skipChildren();
+        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit
+        //    special unfortunately
+        if (p.hasToken(JsonToken.FIELD_NAME)) {
+            while (true) {
+                JsonToken t = p.nextToken();
+                if ((t == null) || (t == JsonToken.END_OBJECT)) {
+                    break;
+                }
+                p.skipChildren();
+            }
+        } else {
+            p.skipChildren();
+        }
         return null;
     }
 
     @Override
-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
-            TypeDeserializer typeDeserializer)
-        throws IOException, JsonProcessingException
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
+            TypeDeserializer typeDeserializer) throws IOException
     {
         // Not sure if we need to bother but:
 
-        JsonToken t = jp.getCurrentToken();
-        switch (t) {
-        case START_ARRAY:
-        case START_OBJECT:
-        case FIELD_NAME:
-            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);
+        switch (p.getCurrentTokenId()) {
+        case JsonTokenId.ID_START_ARRAY:
+        case JsonTokenId.ID_START_OBJECT:
+        case JsonTokenId.ID_FIELD_NAME:
+            return typeDeserializer.deserializeTypedFromAny(p, ctxt);
         default:
             return null;
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
index ef865d1ab..c15ee0090 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
@@ -185,7 +185,7 @@ public abstract class TypeDeserializerBase
 
     protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException
     {
-        /* 06-Feb-2013, tatu: As per [Issue#148], consider default implementation value of
+        /* 06-Feb-2013, tatu: As per [databind#148], consider default implementation value of
          *   {@link java.lang.Void} to mean "serialize as null"; as well as DeserializationFeature
          *   to do swift mapping to null
          */
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java
index 28d3d7d62..afa044a72 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java
@@ -105,6 +105,24 @@ public class TestPolymorphicWithDefaultImpl extends BaseMapTest
         public int a;
     }
 
+    static class CallRecord {
+        public float version;
+        public String application;
+        public Item item;
+        public Item item2;
+        public CallRecord() {}
+    }
+
+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)
+    @JsonSubTypes({@JsonSubTypes.Type(value = Event.class, name = "event")})
+    @JsonIgnoreProperties(ignoreUnknown=true)
+    public interface Item { }
+
+    static class Event implements Item {
+        public String location;
+        public Event() {}
+    }
+
     /*
     /**********************************************************
     /* Unit tests, deserialization
@@ -193,7 +211,25 @@ public class TestPolymorphicWithDefaultImpl extends BaseMapTest
         assertEquals(ImplFor656.class, value.getClass());
         assertEquals(3, ((ImplFor656) value).a);
     }
-    
+
+    public void testUnknownTypeIDRecovery() throws Exception
+    {
+        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(
+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);
+        String json = aposToQuotes("{'version':0.0,'application':'123',"
+                +"'item':{'type':'xevent','location':'location1'},"
+                +"'item2':{'type':'event','location':'location1'}}");
+        // can't read item2 - which is valid
+        CallRecord r = reader.readValue(json);
+        assertNull(r.item);
+        assertNotNull(r.item2);
+
+        json = aposToQuotes("{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}");
+        CallRecord r3 = reader.readValue(json);
+        assertNull(r3.item);
+        assertEquals("123", r3.application);
+    }
+
     /*
     /**********************************************************
     /* Unit tests, serialization
