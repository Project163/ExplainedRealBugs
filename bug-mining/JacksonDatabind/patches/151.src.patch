diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
index cd13eb69c..5c1342ad4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
@@ -57,20 +57,20 @@ public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer
      */
     @Override
     @SuppressWarnings("resource")
-    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
+    public Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         // 02-Aug-2013, tatu: May need to use native type ids
-        if (jp.canReadTypeId()) {
-            Object typeId = jp.getTypeId();
+        if (p.canReadTypeId()) {
+            Object typeId = p.getTypeId();
             if (typeId != null) {
-                return _deserializeWithNativeTypeId(jp, ctxt, typeId);
+                return _deserializeWithNativeTypeId(p, ctxt, typeId);
             }
         }
         
         // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME
-        JsonToken t = jp.getCurrentToken();
+        JsonToken t = p.getCurrentToken();
         if (t == JsonToken.START_OBJECT) {
-            t = jp.nextToken();
+            t = p.nextToken();
         } else if (t == JsonToken.START_ARRAY) {
             /* This is most likely due to the fact that not all Java types are
              * serialized as JSON Objects; so if "as-property" inclusion is requested,
@@ -79,90 +79,90 @@ public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer
              * But this can also be due to some custom handling: so, if "defaultImpl"
              * is defined, it will be asked to handle this case.
              */
-            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
+            return _deserializeTypedUsingDefaultImpl(p, ctxt, null);
         } else if (t != JsonToken.FIELD_NAME) {
-            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
+            return _deserializeTypedUsingDefaultImpl(p, ctxt, null);
         }
         // Ok, let's try to find the property. But first, need token buffer...
         TokenBuffer tb = null;
 
-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {
-            String name = jp.getCurrentName();
-            jp.nextToken(); // to point to the value
-            if (_typePropertyName.equals(name)) { // gotcha!
-                return _deserializeTypedForId(jp, ctxt, tb);
+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
+            String name = p.getCurrentName();
+            p.nextToken(); // to point to the value
+            if (name.equals(_typePropertyName)) { // gotcha!
+                return _deserializeTypedForId(p, ctxt, tb);
             }
             if (tb == null) {
-                tb = new TokenBuffer(jp, ctxt);
+                tb = new TokenBuffer(p, ctxt);
             }
             tb.writeFieldName(name);
-            tb.copyCurrentStructure(jp);
+            tb.copyCurrentStructure(p);
         }
-        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);
+        return _deserializeTypedUsingDefaultImpl(p, ctxt, tb);
     }
 
     @SuppressWarnings("resource")
-    protected Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
+    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
     {
-        String typeId = jp.getText();
+        String typeId = p.getText();
         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
         if (_typeIdVisible) { // need to merge id back in JSON input?
             if (tb == null) {
-                tb = new TokenBuffer(jp, ctxt);
+                tb = new TokenBuffer(p, ctxt);
             }
-            tb.writeFieldName(jp.getCurrentName());
+            tb.writeFieldName(p.getCurrentName());
             tb.writeString(typeId);
         }
         if (tb != null) { // need to put back skipped properties?
-            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);
+            p = JsonParserSequence.createFlattened(tb.asParser(p), p);
         }
         // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:
-        jp.nextToken(); // to skip past String value
+        p.nextToken(); // to skip past String value
         // deserializer should take care of closing END_OBJECT as well
-        return deser.deserialize(jp, ctxt);
+        return deser.deserialize(p, ctxt);
     }
     
     // off-lined to keep main method lean and mean...
     @SuppressWarnings("resource")
-    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
+    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
     {
         // As per [JACKSON-614], may have default implementation to use
         JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);
         if (deser != null) {
             if (tb != null) {
                 tb.writeEndObject();
-                jp = tb.asParser(jp);
+                p = tb.asParser(p);
                 // must move to point to the first token:
-                jp.nextToken();
+                p.nextToken();
             }
-            return deser.deserialize(jp, ctxt);
+            return deser.deserialize(p, ctxt);
         }
         // or, perhaps we just bumped into a "natural" value (boolean/int/double/String)?
-        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);
+        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);
         if (result != null) {
             return result;
         }
         // or, something for which "as-property" won't work, changed into "wrapper-array" type:
-        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
-            return super.deserializeTypedFromAny(jp, ctxt);
+        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
+            return super.deserializeTypedFromAny(p, ctxt);
         }
-        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,
+        throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
                 "missing property '"+_typePropertyName+"' that is to contain type id  (for class "+baseTypeName()+")");
     }
 
-    /* As per [JACKSON-352], also need to re-route "unknown" version. Need to think
+    /* Aalso need to re-route "unknown" version. Need to think
      * this through bit more in future, but for now this does address issue and has
      * no negative side effects (at least within existing unit test suite).
      */
     @Override
-    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {
-        /* [JACKSON-387]: Sometimes, however, we get an array wrapper; specifically
-         *   when an array or list has been serialized with type information.
+    public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {
+        /* Sometimes, however, we get an array wrapper; specifically
+         * when an array or list has been serialized with type information.
          */
-        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
-            return super.deserializeTypedFromArray(jp, ctxt);
+        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
+            return super.deserializeTypedFromArray(p, ctxt);
         }
-        return deserializeTypedFromObject(jp, ctxt);
+        return deserializeTypedFromObject(p, ctxt);
     }    
     
     // These are fine from base class:
diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
index 198fdcdeb..57952007f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
@@ -71,7 +71,8 @@ public abstract class TypeDeserializerBase
     {
         _baseType = baseType;
         _idResolver = idRes;
-        _typePropertyName = typePropertyName;
+        // 22-Dec-2015, tatu: as per [databind#1055], avoid NPE
+        _typePropertyName = (typePropertyName == null) ? "" : typePropertyName;
         _typeIdVisible = typeIdVisible;
         // defaults are fine, although concurrency of 4 bit more frugal than 16:
         _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);
diff --git a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java
index 1422cedf1..c92ba3bce 100644
--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java
+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java
@@ -45,7 +45,7 @@ public class TestHandlerInstantiation extends BaseMapTest
     static class MyMap extends HashMap<String,String> { }
 
     @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_ARRAY)
-    @JsonTypeIdResolver(CustomIdResolver.class)
+    @JsonTypeIdResolver(TestCustomIdResolver.class)
     static class TypeIdBean {
         public int x;
         
@@ -111,13 +111,13 @@ public class TestHandlerInstantiation extends BaseMapTest
     }
     
     // copied from "TestCustomTypeIdResolver"
-    static class CustomIdResolver extends TypeIdResolverBase
+    static class TestCustomIdResolver extends TypeIdResolverBase
     {
         static List<JavaType> initTypes;
 
         final String _id;
         
-        public CustomIdResolver(String idForBean) {
+        public TestCustomIdResolver(String idForBean) {
             _id = idForBean;
         }
 
@@ -211,8 +211,8 @@ public class TestHandlerInstantiation extends BaseMapTest
         public TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,
                 Annotated annotated, Class<?> resolverClass)
         {
-            if (resolverClass == CustomIdResolver.class) {
-                return new CustomIdResolver("!!!");
+            if (resolverClass == TestCustomIdResolver.class) {
+                return new TestCustomIdResolver("!!!");
             }
             return null;
         }
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
index 0e8de5690..8fa9bd77f 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java
@@ -30,7 +30,7 @@ public class TestCustomTypeIdResolver extends BaseMapTest
         public ExtBean value;
     }
 
-    static class CustomResolver extends CustomResolverBase {
+    static class CustomResolver extends TestCustomResolverBase {
         // yes, static: just for test purposes, not real use
         static List<JavaType> initTypes;
 
@@ -55,18 +55,18 @@ public class TestCustomTypeIdResolver extends BaseMapTest
         public ExtBeanImpl(int y) { this.y = y; }
     }
     
-    static class ExtResolver extends CustomResolverBase {
+    static class ExtResolver extends TestCustomResolverBase {
         public ExtResolver() {
             super(ExtBean.class, ExtBeanImpl.class);
         }
     }
 
-    static class CustomResolverBase extends TypeIdResolverBase
+    static class TestCustomResolverBase extends TypeIdResolverBase
     {
         protected final Class<?> superType;
         protected final Class<?> subType;
 
-        public CustomResolverBase(Class<?> baseType, Class<?> implType) {
+        public TestCustomResolverBase(Class<?> baseType, Class<?> implType) {
             superType = baseType;
             subType = implType;
         }
