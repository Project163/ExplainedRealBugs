diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 2af59f610..b28f2fdcd 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -577,3 +577,7 @@ Jan Lolling (jlolling@github)
 Michael R Fairhurst (MichaelRFairhurst@github)
   * Reported #1035: `@JsonAnySetter` assumes key of `String`, does not consider declared type.
    (2.9.0)
+
+Fabrizio Cucci (fabriziocucci@github)
+  * Reported #1406: `ObjectMapper.readTree()` methods do not return `null` on end-of-input
+   (2.9.0)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index fe571cf0d..b7b9d8d16 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -26,6 +26,8 @@ Project: jackson-databind
 #1371: Add `MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES` to allow
  disabling use of `@CreatorProperties` as explicit `@JsonCreator` equivalent
 #1399: Add support for `@JsonSetter(merge=OptBoolean.TRUE`) to allow "deep update"
+#1406: `ObjectMapper.readTree()` methods do not return `null` on end-of-input
+ (reported by Fabrizio C)
 
 2.8.5 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
index 4fb144fe5..f6b4cf7d6 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
@@ -2352,11 +2352,9 @@ public class ObjectMapper
      * @throws JsonParseException if underlying input contains invalid content
      *    of type {@link JsonParser} supports (JSON for default case)
      */
-    public JsonNode readTree(InputStream in)
-        throws IOException, JsonProcessingException
+    public JsonNode readTree(InputStream in) throws IOException
     {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+        return _readTreeAndClose(_jsonFactory.createParser(in));
     }
 
     /**
@@ -2382,11 +2380,8 @@ public class ObjectMapper
      *   as a non-null {@link JsonNode} (one that returns <code>true</code>
      *   for {@link JsonNode#isNull()}
      */
-    public JsonNode readTree(Reader r)
-        throws IOException, JsonProcessingException
-    {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+    public JsonNode readTree(Reader r) throws IOException {
+        return _readTreeAndClose(_jsonFactory.createParser(r));
     }
 
     /**
@@ -2412,11 +2407,8 @@ public class ObjectMapper
      * @throws JsonParseException if underlying input contains invalid content
      *    of type {@link JsonParser} supports (JSON for default case)
      */
-    public JsonNode readTree(String content)
-        throws IOException, JsonProcessingException
-    {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+    public JsonNode readTree(String content) throws IOException {
+        return _readTreeAndClose(_jsonFactory.createParser(content));
     }
 
     /**
@@ -2435,11 +2427,8 @@ public class ObjectMapper
      * @throws JsonParseException if underlying input contains invalid content
      *    of type {@link JsonParser} supports (JSON for default case)
      */
-    public JsonNode readTree(byte[] content)
-        throws IOException, JsonProcessingException
-    {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+    public JsonNode readTree(byte[] content) throws IOException {
+        return _readTreeAndClose(_jsonFactory.createParser(content));
     }
     
     /**
@@ -2465,8 +2454,7 @@ public class ObjectMapper
     public JsonNode readTree(File file)
         throws IOException, JsonProcessingException
     {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+        return _readTreeAndClose(_jsonFactory.createParser(file));
     }
 
     /**
@@ -2489,11 +2477,8 @@ public class ObjectMapper
      * @throws JsonParseException if underlying input contains invalid content
      *    of type {@link JsonParser} supports (JSON for default case)
      */
-    public JsonNode readTree(URL source)
-        throws IOException, JsonProcessingException
-    {
-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);
-        return (n == null) ? NullNode.instance : n;
+    public JsonNode readTree(URL source) throws IOException {
+        return _readTreeAndClose(_jsonFactory.createParser(source));
     }
 
     /*
@@ -3837,12 +3822,50 @@ public class ObjectMapper
                 }
                 ctxt.checkUnresolvedObjectId();
             }
-            // Need to consume the token too
-            p.clearCurrentToken();
             return result;
         }
     }
 
+    /**
+     * Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>
+     * reading.
+     *
+     * @since 2.9
+     */
+    protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException
+    {
+        try (JsonParser p = p0) {
+            final JavaType valueType = JSON_NODE_TYPE;
+
+            // 27-Oct-2016, tatu: Need to inline `_initForReading()` due to
+            //   special requirements by tree reading (no fail on eof)
+            
+            _deserializationConfig.initialize(p); // since 2.5
+            JsonToken t = p.getCurrentToken();
+            if (t == null) {
+                t = p.nextToken();
+                if (t == null) { // [databind#1406]: expose end-of-input as `null`
+                    return null;
+                }
+            }
+            if (t == JsonToken.VALUE_NULL) {
+                return _deserializationConfig.getNodeFactory().nullNode();
+            }
+            DeserializationConfig cfg = getDeserializationConfig();
+            DeserializationContext ctxt = createDeserializationContext(p, cfg);
+            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);
+            Object result;
+            if (cfg.useRootWrapping()) {
+                result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);
+            } else {
+                result = deser.deserialize(p, ctxt);
+            }
+            // No ObjectIds so can ignore
+//            ctxt.checkUnresolvedObjectId();
+            return (JsonNode) result;
+        }
+    }
+
     /**
      * Method called to ensure that given parser is ready for reading
      * content for data binding.
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
index 949a5855f..835157d22 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
@@ -16,7 +16,6 @@ import com.fasterxml.jackson.databind.deser.DataFormatReaders;
 import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;
 import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.fasterxml.jackson.databind.node.NullNode;
 import com.fasterxml.jackson.databind.node.TreeTraversingParser;
 import com.fasterxml.jackson.databind.type.SimpleType;
 import com.fasterxml.jackson.databind.type.TypeFactory;
@@ -32,6 +31,12 @@ import com.fasterxml.jackson.databind.type.TypeFactory;
  * Instances are initially constructed by {@link ObjectMapper} and can be
  * reused, shared, cached; both because of thread-safety and because
  * instances are relatively light-weight.
+ *<p>
+ * NOTE: this class is NOT meant as sub-classable (with Jackson 2.8 and
+ * above) by users. It is left as non-final mostly to allow frameworks
+ * that require bytecode generation for proxying and similar use cases,
+ * but there is no expecation that functionality should be extended
+ * by sub-classing.
  */
 public class ObjectReader
     extends ObjectCodec
@@ -333,8 +338,7 @@ public class ObjectReader
 
     /*
     /**********************************************************
-    /* Methods sub-classes may choose to override, if customized
-    /* initialization is needed.
+    /* Methods for initializing parser instance to use
     /**********************************************************
      */
 
@@ -1160,7 +1164,7 @@ public class ObjectReader
     }
      
     @Override
-    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {
+    public void writeTree(JsonGenerator g, TreeNode rootNode) {
         throw new UnsupportedOperationException();
     }
     
@@ -1323,8 +1327,7 @@ public class ObjectReader
      * it will just be ignored; result is always a newly constructed
      * {@link JsonNode} instance.
      */
-    public JsonNode readTree(InputStream in)
-        throws IOException, JsonProcessingException
+    public JsonNode readTree(InputStream in) throws IOException
     {
         if (_dataFormatReaders != null) {
             return _detectBindAndCloseAsTree(in);
@@ -1341,8 +1344,7 @@ public class ObjectReader
      * it will just be ignored; result is always a newly constructed
      * {@link JsonNode} instance.
      */
-    public JsonNode readTree(Reader r)
-        throws IOException, JsonProcessingException
+    public JsonNode readTree(Reader r) throws IOException
     {
         if (_dataFormatReaders != null) {
             _reportUndetectableSource(r);
@@ -1359,8 +1361,7 @@ public class ObjectReader
      * it will just be ignored; result is always a newly constructed
      * {@link JsonNode} instance.
      */
-    public JsonNode readTree(String json)
-        throws IOException, JsonProcessingException
+    public JsonNode readTree(String json) throws IOException
     {
         if (_dataFormatReaders != null) {
             _reportUndetectableSource(json);
@@ -1635,32 +1636,43 @@ public class ObjectReader
         }
     }
 
-    protected JsonNode _bindAndCloseAsTree(JsonParser p0) throws IOException {
+    protected final JsonNode _bindAndCloseAsTree(JsonParser p0) throws IOException {
         try (JsonParser p = p0) {
             return _bindAsTree(p);
         }
     }
     
-    protected JsonNode _bindAsTree(JsonParser p) throws IOException
+    protected final JsonNode _bindAsTree(JsonParser p) throws IOException
     {
-        JsonNode result;
+        // 27-Oct-2016, tatu: Need to inline `_initForReading()` due to
+        //   special requirements by tree reading (no fail on eof)
+        
+        _config.initialize(p);
+        if (_schema != null) {
+            p.setSchema(_schema);
+        }
+
+        JsonToken t = p.getCurrentToken();
+        if (t == null) {
+            t = p.nextToken();
+            if (t == null) { // [databind#1406]: expose end-of-input as `null`
+                return null;
+            }
+        }
         DeserializationContext ctxt = createDeserializationContext(p);
-        JsonToken t = _initForReading(ctxt, p);
-        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
-            result = NullNode.instance;
+        if (t == JsonToken.VALUE_NULL) {
+            return ctxt.getNodeFactory().nullNode();
+        }
+        JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);
+        Object result;
+        if (_unwrapRoot) {
+            result = _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);
         } else {
-            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);
-            if (_unwrapRoot) {
-                result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);
-            } else {
-                result = (JsonNode) deser.deserialize(p, ctxt);
-            }
+            result = deser.deserialize(p, ctxt);
         }
-        // Need to consume the token too
-        p.clearCurrentToken();
-        return result;
+        return (JsonNode) result;
     }
-    
+
     /**
      * @since 2.1
      */
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java b/src/test/java/com/fasterxml/jackson/databind/node/ArrayNodeTest.java
similarity index 65%
rename from src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java
rename to src/test/java/com/fasterxml/jackson/databind/node/ArrayNodeTest.java
index 1f7963a02..f030e0b79 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/ArrayNodeTest.java
@@ -16,7 +16,7 @@ import com.fasterxml.jackson.databind.node.TreeTraversingParser;
 /**
  * Additional tests for {@link ArrayNode} container class.
  */
-public class TestArrayNode
+public class ArrayNodeTest
     extends BaseMapTest
 {
     public void testBasics() throws IOException
@@ -94,6 +94,20 @@ public class TestArrayNode
         jg.close();
     }
 
+    public void testArrayViaMapper() throws Exception
+    {
+        final String JSON = "[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]";
+
+        JsonNode n = objectMapper().readTree(JSON);
+        assertNotNull(n);
+        assertTrue(n.isArray());
+        ArrayNode an = (ArrayNode) n;
+        assertEquals(1, an.size());
+        ArrayNode an2 = (ArrayNode) n.get(0);
+        assertTrue(an2.isArray());
+        assertEquals(4, an2.size());
+    }
+    
     public void testAdds()
     {
         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);
@@ -167,4 +181,74 @@ public class TestArrayNode
         assertEquals(JsonParser.NumberType.INT, p.getNumberType());
         p.close();
     }
+
+    public void testArrayNodeEquality()
+    {
+        ArrayNode n1 = new ArrayNode(null);
+        ArrayNode n2 = new ArrayNode(null);
+
+        assertTrue(n1.equals(n2));
+        assertTrue(n2.equals(n1));
+
+        n1.add(TextNode.valueOf("Test"));
+
+        assertFalse(n1.equals(n2));
+        assertFalse(n2.equals(n1));
+
+        n2.add(TextNode.valueOf("Test"));
+
+        assertTrue(n1.equals(n2));
+        assertTrue(n2.equals(n1));
+    }
+
+    public void testSimpleArray() throws Exception
+    {
+        ArrayNode result = objectMapper().createArrayNode();
+
+        assertTrue(result.isArray());
+        assertType(result, ArrayNode.class);
+
+        assertFalse(result.isObject());
+        assertFalse(result.isNumber());
+        assertFalse(result.isNull());
+        assertFalse(result.isTextual());
+
+        // and let's add stuff...
+        result.add(false);
+        result.insertNull(0);
+
+        // should be equal to itself no matter what
+        assertEquals(result, result);
+        assertFalse(result.equals(null)); // but not to null
+
+        // plus see that we can access stuff
+        assertEquals(NullNode.instance, result.path(0));
+        assertEquals(NullNode.instance, result.get(0));
+        assertEquals(BooleanNode.FALSE, result.path(1));
+        assertEquals(BooleanNode.FALSE, result.get(1));
+        assertEquals(2, result.size());
+
+        assertNull(result.get(-1));
+        assertNull(result.get(2));
+        JsonNode missing = result.path(2);
+        assertTrue(missing.isMissingNode());
+        assertTrue(result.path(-100).isMissingNode());
+
+        // then construct and compare
+        ArrayNode array2 = objectMapper().createArrayNode();
+        array2.addNull();
+        array2.add(false);
+        assertEquals(result, array2);
+
+        // plus remove entries
+        JsonNode rm1 = array2.remove(0);
+        assertEquals(NullNode.instance, rm1);
+        assertEquals(1, array2.size());
+        assertEquals(BooleanNode.FALSE, array2.get(0));
+        assertFalse(result.equals(array2));
+
+        JsonNode rm2 = array2.remove(0);
+        assertEquals(BooleanNode.FALSE, rm2);
+        assertEquals(0, array2.size());
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java b/src/test/java/com/fasterxml/jackson/databind/node/NumberNodesTest.java
similarity index 76%
rename from src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java
rename to src/test/java/com/fasterxml/jackson/databind/node/NumberNodesTest.java
index f5b71c4ec..5f3b4cfbf 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/NumberNodesTest.java
@@ -12,8 +12,10 @@ import com.fasterxml.jackson.databind.*;
  * Basic tests for {@link JsonNode} implementations that
  * contain numeric values.
  */
-public class TestNumberNodes extends NodeTestBase
+public class NumberNodesTest extends NodeTestBase
 {
+    private final ObjectMapper MAPPER = objectMapper();
+    
     public void testShort()
     {
         ShortNode n = ShortNode.valueOf((short) 1);
@@ -37,8 +39,33 @@ public class TestNumberNodes extends NodeTestBase
         assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToLong());
         assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToLong());
     }
-    
-	public void testInt()
+
+    public void testIntViaMapper() throws Exception
+    {
+        int value = -90184;
+        JsonNode result = MAPPER.readTree(String.valueOf(value));
+        assertTrue(result.isNumber());
+        assertTrue(result.isIntegralNumber());
+        assertTrue(result.isInt());
+        assertType(result, IntNode.class);
+        assertFalse(result.isLong());
+        assertFalse(result.isFloatingPointNumber());
+        assertFalse(result.isDouble());
+        assertFalse(result.isNull());
+        assertFalse(result.isTextual());
+        assertFalse(result.isMissingNode());
+
+        assertEquals(value, result.numberValue().intValue());
+        assertEquals(value, result.intValue());
+        assertEquals(String.valueOf(value), result.asText());
+        assertEquals((double) value, result.doubleValue());
+        assertEquals((long) value, result.longValue());
+
+        // also, equality should work ok
+        assertEquals(result, IntNode.valueOf(value));
+    }
+
+    public void testInt()
     {
         IntNode n = IntNode.valueOf(1);
         assertStandardEquals(n);
@@ -62,6 +89,7 @@ public class TestNumberNodes extends NodeTestBase
         assertTrue(IntNode.valueOf(0).canConvertToLong());
         assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToLong());
         assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToLong());
+
     }
 
     public void testLong()
@@ -92,6 +120,31 @@ public class TestNumberNodes extends NodeTestBase
         assertTrue(LongNode.valueOf(Long.MIN_VALUE).canConvertToLong());
     }
 
+    public void testLongViaMapper() throws Exception
+    {
+        // need to use something being 32-bit value space
+        long value = 12345678L << 32;
+        JsonNode result = MAPPER.readTree(String.valueOf(value));
+        assertTrue(result.isNumber());
+        assertTrue(result.isIntegralNumber());
+        assertTrue(result.isLong());
+        assertType(result, LongNode.class);
+        assertFalse(result.isInt());
+        assertFalse(result.isFloatingPointNumber());
+        assertFalse(result.isDouble());
+        assertFalse(result.isNull());
+        assertFalse(result.isTextual());
+        assertFalse(result.isMissingNode());
+
+        assertEquals(value, result.numberValue().longValue());
+        assertEquals(value, result.longValue());
+        assertEquals(String.valueOf(value), result.asText());
+        assertEquals((double) value, result.doubleValue());
+
+        // also, equality should work ok
+        assertEquals(result, LongNode.valueOf(value));
+    }
+
     public void testDouble() throws Exception
     {
         DoubleNode n = DoubleNode.valueOf(0.25);
@@ -105,7 +158,6 @@ public class TestNumberNodes extends NodeTestBase
         assertEquals(BigInteger.ZERO, n.bigIntegerValue());
         assertEquals("0.25", n.asText());
 
-        // 1.6:
         assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);
 
         assertTrue(DoubleNode.valueOf(0).canConvertToInt());
@@ -125,6 +177,31 @@ public class TestNumberNodes extends NodeTestBase
         assertEquals("-0.0", String.valueOf(n.doubleValue()));
     }
 
+    public void testDoubleViaMapper() throws Exception
+    {
+        double value = 3.04;
+        JsonNode result = MAPPER.readTree(String.valueOf(value));
+        assertTrue(result.isNumber());
+        assertFalse(result.isNull());
+        assertType(result, DoubleNode.class);
+        assertTrue(result.isFloatingPointNumber());
+        assertTrue(result.isDouble());
+        assertFalse(result.isInt());
+        assertFalse(result.isLong());
+        assertFalse(result.isIntegralNumber());
+        assertFalse(result.isTextual());
+        assertFalse(result.isMissingNode());
+
+        assertEquals(value, result.doubleValue());
+        assertEquals(value, result.numberValue().doubleValue());
+        assertEquals((int) value, result.intValue());
+        assertEquals((long) value, result.longValue());
+        assertEquals(String.valueOf(value), result.asText());
+
+        // also, equality should work ok
+        assertEquals(result, DoubleNode.valueOf(value));
+    }
+
     // @since 2.2
     public void testFloat()
     {
@@ -173,6 +250,7 @@ public class TestNumberNodes extends NodeTestBase
         assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.numberType());
         assertTrue(n.isNumber());
         assertFalse(n.isIntegralNumber());
+        assertFalse(n.isArray());
         assertTrue(n.isBigDecimal());
         assertEquals(BigDecimal.ONE, n.numberValue());
         assertEquals(1, n.intValue());
@@ -180,7 +258,6 @@ public class TestNumberNodes extends NodeTestBase
         assertEquals(BigDecimal.ONE, n.decimalValue());
         assertEquals("1", n.asText());
 
-        // 1.6:
         assertNodeNumbers(n, 1, 1.0);
 
         assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToInt());
@@ -192,8 +269,31 @@ public class TestNumberNodes extends NodeTestBase
         assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToLong());
         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MAX_VALUE)).canConvertToLong());
         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MIN_VALUE)).canConvertToLong());
-    }
 
+        // no "natural" way to get it, must construct
+        BigDecimal value = new BigDecimal("0.1");
+        JsonNode result = DecimalNode.valueOf(value);
+
+        assertFalse(result.isObject());
+        assertTrue(result.isNumber());
+        assertFalse(result.isIntegralNumber());
+        assertFalse(result.isLong());
+        assertType(result, DecimalNode.class);
+        assertFalse(result.isInt());
+        assertTrue(result.isFloatingPointNumber());
+        assertTrue(result.isBigDecimal());
+        assertFalse(result.isDouble());
+        assertFalse(result.isNull());
+        assertFalse(result.isTextual());
+        assertFalse(result.isMissingNode());
+
+        assertEquals(value, result.numberValue());
+        assertEquals(value.toString(), result.asText());
+
+        // also, equality should work ok
+        assertEquals(result, DecimalNode.valueOf(value));
+    }
+    
     public void testDecimalNodeEqualsHashCode()
     {
         /*
@@ -284,7 +384,6 @@ public class TestNumberNodes extends NodeTestBase
         assertEquals("100", mapper.writeValueAsString(tree));
     }
 
-    // Related to [Issue#333]
     public void testCanonicalNumbers() throws Exception
     {
         JsonNodeFactory f = new JsonNodeFactory();
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java
index 0dbb91fec..c5ce89326 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java
@@ -44,7 +44,7 @@ public class TestJsonNode extends NodeTestBase
         assertFalse(TextNode.valueOf("false").asBoolean(false));
     }
 
-    public void testBoolean()
+    public void testBoolean() throws Exception
     {
         BooleanNode f = BooleanNode.getFalse();
         assertNotNull(f);
@@ -67,12 +67,24 @@ public class TestJsonNode extends NodeTestBase
         assertEquals("true", t.asText());
         assertEquals(JsonToken.VALUE_TRUE, t.asToken());
 
-        // 1.6:
         assertNodeNumbers(f, 0, 0.0);
         assertNodeNumbers(t, 1, 1.0);
+    
+        JsonNode result = objectMapper().readTree("true\n");
+        assertFalse(result.isNull());
+        assertFalse(result.isNumber());
+        assertFalse(result.isTextual());
+        assertTrue(result.isBoolean());
+        assertType(result, BooleanNode.class);
+        assertTrue(result.booleanValue());
+        assertEquals("true", result.asText());
+        assertFalse(result.isMissingNode());
+
+        // also, equality should work ok
+        assertEquals(result, BooleanNode.valueOf(true));
+        assertEquals(result, BooleanNode.getTrue());
     }
 
-
     public void testBinary() throws Exception
     {
         assertNull(BinaryNode.valueOf(null));
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java b/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java
index c09d619e8..45f0bac7d 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java
@@ -1,6 +1,10 @@
 package com.fasterxml.jackson.databind.node;
 
+import java.io.StringReader;
+import java.util.Iterator;
+
 import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.JsonNode;
 
 public class TestMissingNode extends NodeTestBase
 {
@@ -9,17 +13,12 @@ public class TestMissingNode extends NodeTestBase
         MissingNode n = MissingNode.getInstance();
         assertTrue(n.isMissingNode());
         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());
-        // as per [JACKSON-775]
         assertEquals("", n.asText());
         assertStandardEquals(n);
         assertEquals("", n.toString());
 
-        /* As of 2.0, MissingNode is considered non-numeric, meaning
-         * that default values are served.
-         */
         assertNodeNumbersForNonNumeric(n);
 
-        // [JACKSON-823]
         assertTrue(n.asBoolean(true));
         assertEquals(4, n.asInt(4));
         assertEquals(5L, n.asLong(5));
@@ -27,4 +26,69 @@ public class TestMissingNode extends NodeTestBase
 
         assertEquals("foo", n.asText("foo"));
     }
+
+    /**
+     * Let's also verify behavior of "MissingNode" -- one needs to be able
+     * to traverse such bogus nodes with appropriate methods.
+     */
+    @SuppressWarnings("unused")
+    public void testMissingViaMapper() throws Exception
+    {
+        String JSON = "[ { }, [ ] ]";
+        JsonNode result = objectMapper().readTree(new StringReader(JSON));
+
+        assertTrue(result.isContainerNode());
+        assertTrue(result.isArray());
+        assertEquals(2, result.size());
+
+        int count = 0;
+        for (JsonNode node : result) {
+            ++count;
+        }
+        assertEquals(2, count);
+
+        Iterator<JsonNode> it = result.iterator();
+
+        JsonNode onode = it.next();
+        assertTrue(onode.isContainerNode());
+        assertTrue(onode.isObject());
+        assertEquals(0, onode.size());
+        assertFalse(onode.isMissingNode()); // real node
+        assertNull(onode.textValue());
+
+        // how about dereferencing?
+        assertNull(onode.get(0));
+        JsonNode dummyNode = onode.path(0);
+        assertNotNull(dummyNode);
+        assertTrue(dummyNode.isMissingNode());
+        assertNull(dummyNode.get(3));
+        assertNull(dummyNode.get("whatever"));
+        JsonNode dummyNode2 = dummyNode.path(98);
+        assertNotNull(dummyNode2);
+        assertTrue(dummyNode2.isMissingNode());
+        JsonNode dummyNode3 = dummyNode.path("field");
+        assertNotNull(dummyNode3);
+        assertTrue(dummyNode3.isMissingNode());
+
+        // and same for the array node
+
+        JsonNode anode = it.next();
+        assertTrue(anode.isContainerNode());
+        assertTrue(anode.isArray());
+        assertFalse(anode.isMissingNode()); // real node
+        assertEquals(0, anode.size());
+
+        assertNull(anode.get(0));
+        dummyNode = anode.path(0);
+        assertNotNull(dummyNode);
+        assertTrue(dummyNode.isMissingNode());
+        assertNull(dummyNode.get(0));
+        assertNull(dummyNode.get("myfield"));
+        dummyNode2 = dummyNode.path(98);
+        assertNotNull(dummyNode2);
+        assertTrue(dummyNode2.isMissingNode());
+        dummyNode3 = dummyNode.path("f");
+        assertNotNull(dummyNode3);
+        assertTrue(dummyNode3.isMissingNode());
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java b/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java
index c807b03b9..cc9539692 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNullNode.java
@@ -3,8 +3,18 @@ package com.fasterxml.jackson.databind.node;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
+import com.fasterxml.jackson.databind.JsonNode;
+
 public class TestNullNode extends NodeTestBase
 {
+    final static class CovarianceBean {
+        ObjectNode _object;
+        ArrayNode _array;
+
+        public void setObject(ObjectNode n) { _object = n; }
+        public void setArray(ArrayNode n) { _array = n; }
+    }
+
     public void testBasicsWithNullNode() throws Exception
     {
         // Let's use something that doesn't add much beyond JsonNode base
@@ -42,4 +52,39 @@ public class TestNullNode extends NodeTestBase
         // 2.4
         assertEquals("foo", n.asText("foo"));
     }
+
+    public void testNullHandling() throws Exception
+    {
+        // First, a stand-alone null
+        JsonNode n = objectReader().readTree("null");
+        assertNotNull(n);
+        assertTrue(n.isNull());
+        assertFalse(n.isNumber());
+        assertFalse(n.isTextual());
+        assertEquals("null", n.asText());
+        assertEquals(n, NullNode.instance);
+
+        n = objectMapper().readTree("null");
+        assertNotNull(n);
+        assertTrue(n.isNull());
+        
+        // Then object property
+        ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}");
+        assertEquals(1, root.size());
+        n = root.get("x");
+        assertNotNull(n);
+        assertTrue(n.isNull());
+    }
+
+    public void testNullHandlingCovariance() throws Exception
+    {
+        String JSON = "{\"object\" : null, \"array\" : null }";
+        CovarianceBean bean = objectMapper().readValue(JSON, CovarianceBean.class);
+
+        ObjectNode on = bean._object;
+        assertNull(on);
+
+        ArrayNode an = bean._array;
+        assertNull(an);
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java
index 0c88cdc15..5bf8d8543 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java
@@ -3,7 +3,6 @@ package com.fasterxml.jackson.databind.node;
 import com.fasterxml.jackson.databind.BaseMapTest;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import java.io.IOException;
 
 /**
  * This unit test suite tries to verify that JsonNode-based trees
@@ -26,44 +25,6 @@ public class TestTreeDeserialization
     /**********************************************************
      */
 
-    /**
-     * This test checks that is possible to mix "regular" Java objects
-     * and JsonNode.
-     */
-    public void testMixed() throws IOException
-    {
-        ObjectMapper om = new ObjectMapper();
-        String JSON = "{\"node\" : { \"a\" : 3 }, \"x\" : 9 }";
-        Bean bean = om.readValue(JSON, Bean.class);
-
-        assertEquals(9, bean._x);
-        JsonNode n = bean._node;
-        assertNotNull(n);
-        assertEquals(1, n.size());
-        ObjectNode on = (ObjectNode) n;
-        assertEquals(3, on.get("a").intValue());
-    }
-
-    /// Verifying [JACKSON-143]
-    public void testArrayNodeEquality()
-    {
-        ArrayNode n1 = new ArrayNode(null);
-        ArrayNode n2 = new ArrayNode(null);
-
-        assertTrue(n1.equals(n2));
-        assertTrue(n2.equals(n1));
-
-        n1.add(TextNode.valueOf("Test"));
-
-        assertFalse(n1.equals(n2));
-        assertFalse(n2.equals(n1));
-
-        n2.add(TextNode.valueOf("Test"));
-
-        assertTrue(n1.equals(n2));
-        assertTrue(n2.equals(n1));
-    }
-
     public void testObjectNodeEquality()
     {
         ObjectNode n1 = new ObjectNode(null);
@@ -96,44 +57,4 @@ public class TestTreeDeserialization
         String value = out.path("field").asText();
         assertNotNull(value);
     }
-
-    // Issue#186
-    public void testNullHandling() throws Exception
-    {
-        // First, a stand-alone null
-        JsonNode n = objectReader().readTree("null");
-        assertNotNull(n);
-        assertTrue(n.isNull());
-
-        n = objectMapper().readTree("null");
-        assertNotNull(n);
-        assertTrue(n.isNull());
-        
-        // Then object property
-        ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}");
-        assertEquals(1, root.size());
-        n = root.get("x");
-        assertNotNull(n);
-        assertTrue(n.isNull());
-    }
-
-    final static class CovarianceBean {
-        ObjectNode _object;
-        ArrayNode _array;
-
-        public void setObject(ObjectNode n) { _object = n; }
-        public void setArray(ArrayNode n) { _array = n; }
-    }
-
-    public void testNullHandlingCovariance() throws Exception
-    {
-        String JSON = "{\"object\" : null, \"array\" : null }";
-        CovarianceBean bean = objectMapper().readValue(JSON, CovarianceBean.class);
-
-        ObjectNode on = bean._object;
-        assertNull(on);
-
-        ArrayNode an = bean._array;
-        assertNull(an);
-    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperDeserializer.java b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperDeserializer.java
deleted file mode 100644
index 37410aacb..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperDeserializer.java
+++ /dev/null
@@ -1,425 +0,0 @@
-package com.fasterxml.jackson.databind.node;
-
-import java.io.*;
-import java.math.BigDecimal;
-import java.util.*;
-
-import com.fasterxml.jackson.core.*;
-import com.fasterxml.jackson.databind.*;
-
-/**
- * This unit test suite tries to verify that ObjectMapper
- * can properly parse JSON and bind contents into appropriate
- * JsonNode instances.
- */
-public class TestTreeMapperDeserializer extends BaseMapTest
-{
-	public void testSimple()
-        throws Exception
-    {
-        final String JSON = SAMPLE_DOC_JSON_SPEC;
-
-        for (int type = 0; type < 2; ++type) {
-            JsonNode result;
-
-            if (type == 0) {
-                result = objectMapper().readTree(new StringReader(JSON));
-            } else {
-                result = objectMapper().readTree(JSON);
-            }
-
-            assertType(result, ObjectNode.class);
-            assertEquals(1, result.size());
-            assertTrue(result.isObject());
-            
-            ObjectNode main = (ObjectNode) result;
-            assertEquals("Image", main.fieldNames().next());
-            JsonNode ob = main.elements().next();
-            assertType(ob, ObjectNode.class);
-            ObjectNode imageMap = (ObjectNode) ob;
-            
-            assertEquals(5, imageMap.size());
-            ob = imageMap.get("Width");
-            assertTrue(ob.isIntegralNumber());
-            assertFalse(ob.isFloatingPointNumber());
-            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.intValue());
-            ob = imageMap.get("Height");
-            assertTrue(ob.isIntegralNumber());
-            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());
-            
-            ob = imageMap.get("Title");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());
-            
-            ob = imageMap.get("Thumbnail");
-            assertType(ob, ObjectNode.class);
-            ObjectNode tn = (ObjectNode) ob;
-            ob = tn.get("Url");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());
-            ob = tn.get("Height");
-            assertTrue(ob.isIntegralNumber());
-            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());
-            ob = tn.get("Width");
-            assertTrue(ob.isTextual());
-            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());
-            
-            ob = imageMap.get("IDs");
-            assertTrue(ob.isArray());
-            ArrayNode idList = (ArrayNode) ob;
-            assertEquals(4, idList.size());
-            assertEquals(4, calcLength(idList.elements()));
-            assertEquals(4, calcLength(idList.iterator()));
-            {
-                int[] values = new int[] {
-                    SAMPLE_SPEC_VALUE_TN_ID1,
-                    SAMPLE_SPEC_VALUE_TN_ID2,
-                    SAMPLE_SPEC_VALUE_TN_ID3,
-                    SAMPLE_SPEC_VALUE_TN_ID4
-                };
-                for (int i = 0; i < values.length; ++i) {
-                    assertEquals(values[i], idList.get(i).intValue());
-                }
-                int i = 0;
-                for (JsonNode n : idList) {
-                    assertEquals(values[i], n.intValue());
-                    ++i;
-                }
-            }
-        }
-    }
-
-    public void testBoolean()
-        throws Exception
-    {
-        JsonNode result = objectMapper().readTree("true\n");
-        assertFalse(result.isNull());
-        assertFalse(result.isNumber());
-        assertFalse(result.isTextual());
-        assertTrue(result.isBoolean());
-        assertType(result, BooleanNode.class);
-        assertTrue(result.booleanValue());
-        assertEquals("true", result.asText());
-        assertFalse(result.isMissingNode());
-
-        // also, equality should work ok
-        assertEquals(result, BooleanNode.valueOf(true));
-        assertEquals(result, BooleanNode.getTrue());
-    }
-
-    public void testDouble()
-        throws Exception
-    {
-        double value = 3.04;
-        JsonNode result = objectMapper().readTree(String.valueOf(value));
-        assertTrue(result.isNumber());
-        assertFalse(result.isNull());
-        assertType(result, DoubleNode.class);
-        assertTrue(result.isFloatingPointNumber());
-        assertTrue(result.isDouble());
-        assertFalse(result.isInt());
-        assertFalse(result.isLong());
-        assertFalse(result.isIntegralNumber());
-        assertFalse(result.isTextual());
-        assertFalse(result.isMissingNode());
-
-        assertEquals(value, result.doubleValue());
-        assertEquals(value, result.numberValue().doubleValue());
-        assertEquals((int) value, result.intValue());
-        assertEquals((long) value, result.longValue());
-        assertEquals(String.valueOf(value), result.asText());
-
-        // also, equality should work ok
-        assertEquals(result, DoubleNode.valueOf(value));
-    }
-
-    public void testInt()
-        throws Exception
-    {
-        int value = -90184;
-        JsonNode result = objectMapper().readTree(String.valueOf(value));
-        assertTrue(result.isNumber());
-        assertTrue(result.isIntegralNumber());
-        assertTrue(result.isInt());
-        assertType(result, IntNode.class);
-        assertFalse(result.isLong());
-        assertFalse(result.isFloatingPointNumber());
-        assertFalse(result.isDouble());
-        assertFalse(result.isNull());
-        assertFalse(result.isTextual());
-        assertFalse(result.isMissingNode());
-
-        assertEquals(value, result.numberValue().intValue());
-        assertEquals(value, result.intValue());
-        assertEquals(String.valueOf(value), result.asText());
-        assertEquals((double) value, result.doubleValue());
-        assertEquals((long) value, result.longValue());
-
-        // also, equality should work ok
-        assertEquals(result, IntNode.valueOf(value));
-    }
-
-    public void testLong() throws Exception
-    {
-        // need to use something being 32-bit value space
-        long value = 12345678L << 32;
-        JsonNode result = objectMapper().readTree(String.valueOf(value));
-        assertTrue(result.isNumber());
-        assertTrue(result.isIntegralNumber());
-        assertTrue(result.isLong());
-        assertType(result, LongNode.class);
-        assertFalse(result.isInt());
-        assertFalse(result.isFloatingPointNumber());
-        assertFalse(result.isDouble());
-        assertFalse(result.isNull());
-        assertFalse(result.isTextual());
-        assertFalse(result.isMissingNode());
-
-        assertEquals(value, result.numberValue().longValue());
-        assertEquals(value, result.longValue());
-        assertEquals(String.valueOf(value), result.asText());
-        assertEquals((double) value, result.doubleValue());
-
-        // also, equality should work ok
-        assertEquals(result, LongNode.valueOf(value));
-    }
-
-    public void testNull() throws Exception
-    {
-        JsonNode result = objectMapper().readTree("   null ");
-        // should not get java null, but NullNode...
-        assertNotNull(result);
-        assertTrue(result.isNull());
-        assertFalse(result.isNumber());
-        assertFalse(result.isTextual());
-        assertEquals("null", result.asText());
-
-        // also, equality should work ok
-        assertEquals(result, NullNode.instance);
-    }
-
-    public void testDecimalNode()
-        throws Exception
-    {
-        // no "natural" way to get it, must construct
-        BigDecimal value = new BigDecimal("0.1");
-        JsonNode result = DecimalNode.valueOf(value);
-
-        assertFalse(result.isArray());
-        assertFalse(result.isObject());
-        assertTrue(result.isNumber());
-        assertFalse(result.isIntegralNumber());
-        assertFalse(result.isLong());
-        assertType(result, DecimalNode.class);
-        assertFalse(result.isInt());
-        assertTrue(result.isFloatingPointNumber());
-        assertTrue(result.isBigDecimal());
-        assertFalse(result.isDouble());
-        assertFalse(result.isNull());
-        assertFalse(result.isTextual());
-        assertFalse(result.isMissingNode());
-
-        assertEquals(value, result.numberValue());
-        assertEquals(value.toString(), result.asText());
-
-        // also, equality should work ok
-        assertEquals(result, DecimalNode.valueOf(value));
-    }
-
-    public void testSimpleArray() throws Exception
-    {
-        ArrayNode result = objectMapper().createArrayNode();
-
-        assertTrue(result.isArray());
-        assertType(result, ArrayNode.class);
-
-        assertFalse(result.isObject());
-        assertFalse(result.isNumber());
-        assertFalse(result.isNull());
-        assertFalse(result.isTextual());
-
-        // and let's add stuff...
-        result.add(false);
-        result.insertNull(0);
-
-        // should be equal to itself no matter what
-        assertEquals(result, result);
-        assertFalse(result.equals(null)); // but not to null
-
-        // plus see that we can access stuff
-        assertEquals(NullNode.instance, result.path(0));
-        assertEquals(NullNode.instance, result.get(0));
-        assertEquals(BooleanNode.FALSE, result.path(1));
-        assertEquals(BooleanNode.FALSE, result.get(1));
-        assertEquals(2, result.size());
-
-        assertNull(result.get(-1));
-        assertNull(result.get(2));
-        JsonNode missing = result.path(2);
-        assertTrue(missing.isMissingNode());
-        assertTrue(result.path(-100).isMissingNode());
-
-        // then construct and compare
-        ArrayNode array2 = objectMapper().createArrayNode();
-        array2.addNull();
-        array2.add(false);
-        assertEquals(result, array2);
-
-        // plus remove entries
-        JsonNode rm1 = array2.remove(0);
-        assertEquals(NullNode.instance, rm1);
-        assertEquals(1, array2.size());
-        assertEquals(BooleanNode.FALSE, array2.get(0));
-        assertFalse(result.equals(array2));
-
-        JsonNode rm2 = array2.remove(0);
-        assertEquals(BooleanNode.FALSE, rm2);
-        assertEquals(0, array2.size());
-    }
-
-    /**
-     * Type mappers should be able to gracefully deal with end of
-     * input.
-     */
-    public void testEOF() throws Exception
-    {
-        String JSON =
-            "{ \"key\": [ { \"a\" : { \"name\": \"foo\",  \"type\": 1\n"
-            +"},  \"type\": 3, \"url\": \"http://www.google.com\" } ],\n"
-            +"\"name\": \"xyz\", \"type\": 1, \"url\" : null }\n  "
-            ;
-        JsonFactory jf = new JsonFactory();
-        JsonParser jp = jf.createParser(new StringReader(JSON));
-        JsonNode result = objectMapper().readTree(jp);
-
-        assertTrue(result.isObject());
-        assertEquals(4, result.size());
-
-        assertNull(objectMapper().readTree(jp));
-        jp.close();
-    }
-
-    public void testMultiple() throws Exception
-    {
-        String JSON = "12  \"string\" [ 1, 2, 3 ]";
-        JsonFactory jf = new JsonFactory();
-        JsonParser jp = jf.createParser(new StringReader(JSON));
-        final ObjectMapper mapper = objectMapper();
-        JsonNode result = mapper.readTree(jp);
-
-        assertTrue(result.isIntegralNumber());
-        assertTrue(result.isInt());
-        assertFalse(result.isTextual());
-        assertEquals(12, result.intValue());
-
-        result = mapper.readTree(jp);
-        assertTrue(result.isTextual());
-        assertFalse(result.isIntegralNumber());
-        assertFalse(result.isInt());
-        assertEquals("string", result.textValue());
-
-        result = mapper.readTree(jp);
-        assertTrue(result.isArray());
-        assertEquals(3, result.size());
-
-        assertNull(mapper.readTree(jp));
-        jp.close();
-    }
-
-    /**
-     * Let's also verify behavior of "MissingNode" -- one needs to be able
-     * to traverse such bogus nodes with appropriate methods.
-     */
-    @SuppressWarnings("unused")
-    public void testMissingNode()
-        throws Exception
-    {
-        String JSON = "[ { }, [ ] ]";
-        JsonNode result = objectMapper().readTree(new StringReader(JSON));
-
-        assertTrue(result.isContainerNode());
-        assertTrue(result.isArray());
-        assertEquals(2, result.size());
-
-        int count = 0;
-        for (JsonNode node : result) {
-            ++count;
-        }
-        assertEquals(2, count);
-
-        Iterator<JsonNode> it = result.iterator();
-
-        JsonNode onode = it.next();
-        assertTrue(onode.isContainerNode());
-        assertTrue(onode.isObject());
-        assertEquals(0, onode.size());
-        assertFalse(onode.isMissingNode()); // real node
-        assertNull(onode.textValue());
-
-        // how about dereferencing?
-        assertNull(onode.get(0));
-        JsonNode dummyNode = onode.path(0);
-        assertNotNull(dummyNode);
-        assertTrue(dummyNode.isMissingNode());
-        assertNull(dummyNode.get(3));
-        assertNull(dummyNode.get("whatever"));
-        JsonNode dummyNode2 = dummyNode.path(98);
-        assertNotNull(dummyNode2);
-        assertTrue(dummyNode2.isMissingNode());
-        JsonNode dummyNode3 = dummyNode.path("field");
-        assertNotNull(dummyNode3);
-        assertTrue(dummyNode3.isMissingNode());
-
-        // and same for the array node
-
-        JsonNode anode = it.next();
-        assertTrue(anode.isContainerNode());
-        assertTrue(anode.isArray());
-        assertFalse(anode.isMissingNode()); // real node
-        assertEquals(0, anode.size());
-
-        assertNull(anode.get(0));
-        dummyNode = anode.path(0);
-        assertNotNull(dummyNode);
-        assertTrue(dummyNode.isMissingNode());
-        assertNull(dummyNode.get(0));
-        assertNull(dummyNode.get("myfield"));
-        dummyNode2 = dummyNode.path(98);
-        assertNotNull(dummyNode2);
-        assertTrue(dummyNode2.isMissingNode());
-        dummyNode3 = dummyNode.path("f");
-        assertNotNull(dummyNode3);
-        assertTrue(dummyNode3.isMissingNode());
-    }
-
-    public void testArray() throws Exception
-    {
-        final String JSON = "[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]";
-
-        JsonNode n = objectMapper().readTree(JSON);
-        assertNotNull(n);
-        assertTrue(n.isArray());
-        ArrayNode an = (ArrayNode) n;
-        assertEquals(1, an.size());
-        ArrayNode an2 = (ArrayNode) n.get(0);
-        assertTrue(an2.isArray());
-        assertEquals(4, an2.size());
-    }
-    
-    /*
-    /**********************************************
-    /* Helper methods
-    /**********************************************
-     */
-
-    private int calcLength(Iterator<JsonNode> it)
-    {
-        int count = 0;
-        while (it.hasNext()) {
-            it.next();
-            ++count;
-        }
-        return count;
-    }
-}
-
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeWithType.java b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeWithType.java
index 959133eb6..83956272e 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeWithType.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeWithType.java
@@ -20,7 +20,7 @@ public class TestTreeWithType extends BaseMapTest
         }
     }
 
-    // [Issue#353]
+    // [databind#353]
     public class SavedCookie {
         public String name, value;
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TreeReadViaMapperTest.java b/src/test/java/com/fasterxml/jackson/databind/node/TreeReadViaMapperTest.java
new file mode 100644
index 000000000..dbeed46e1
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TreeReadViaMapperTest.java
@@ -0,0 +1,192 @@
+package com.fasterxml.jackson.databind.node;
+
+import java.io.*;
+import java.util.*;
+
+import com.fasterxml.jackson.core.*;
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.node.TestTreeDeserialization.Bean;
+
+/**
+ * This unit test suite tries to verify that ObjectMapper
+ * can properly parse JSON and bind contents into appropriate
+ * JsonNode instances.
+ */
+public class TreeReadViaMapperTest extends BaseMapTest
+{
+    public void testSimple() throws Exception
+    {
+        final String JSON = SAMPLE_DOC_JSON_SPEC;
+
+        for (int type = 0; type < 2; ++type) {
+            JsonNode result;
+
+            if (type == 0) {
+                result = objectMapper().readTree(new StringReader(JSON));
+            } else {
+                result = objectMapper().readTree(JSON);
+            }
+
+            assertType(result, ObjectNode.class);
+            assertEquals(1, result.size());
+            assertTrue(result.isObject());
+            
+            ObjectNode main = (ObjectNode) result;
+            assertEquals("Image", main.fieldNames().next());
+            JsonNode ob = main.elements().next();
+            assertType(ob, ObjectNode.class);
+            ObjectNode imageMap = (ObjectNode) ob;
+            
+            assertEquals(5, imageMap.size());
+            ob = imageMap.get("Width");
+            assertTrue(ob.isIntegralNumber());
+            assertFalse(ob.isFloatingPointNumber());
+            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.intValue());
+            ob = imageMap.get("Height");
+            assertTrue(ob.isIntegralNumber());
+            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());
+            
+            ob = imageMap.get("Title");
+            assertTrue(ob.isTextual());
+            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());
+            
+            ob = imageMap.get("Thumbnail");
+            assertType(ob, ObjectNode.class);
+            ObjectNode tn = (ObjectNode) ob;
+            ob = tn.get("Url");
+            assertTrue(ob.isTextual());
+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());
+            ob = tn.get("Height");
+            assertTrue(ob.isIntegralNumber());
+            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());
+            ob = tn.get("Width");
+            assertTrue(ob.isTextual());
+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());
+            
+            ob = imageMap.get("IDs");
+            assertTrue(ob.isArray());
+            ArrayNode idList = (ArrayNode) ob;
+            assertEquals(4, idList.size());
+            assertEquals(4, calcLength(idList.elements()));
+            assertEquals(4, calcLength(idList.iterator()));
+            {
+                int[] values = new int[] {
+                    SAMPLE_SPEC_VALUE_TN_ID1,
+                    SAMPLE_SPEC_VALUE_TN_ID2,
+                    SAMPLE_SPEC_VALUE_TN_ID3,
+                    SAMPLE_SPEC_VALUE_TN_ID4
+                };
+                for (int i = 0; i < values.length; ++i) {
+                    assertEquals(values[i], idList.get(i).intValue());
+                }
+                int i = 0;
+                for (JsonNode n : idList) {
+                    assertEquals(values[i], n.intValue());
+                    ++i;
+                }
+            }
+        }
+    }
+
+    public void testMixed() throws IOException
+    {
+        ObjectMapper om = new ObjectMapper();
+        String JSON = "{\"node\" : { \"a\" : 3 }, \"x\" : 9 }";
+        Bean bean = om.readValue(JSON, Bean.class);
+
+        assertEquals(9, bean._x);
+        JsonNode n = bean._node;
+        assertNotNull(n);
+        assertEquals(1, n.size());
+        ObjectNode on = (ObjectNode) n;
+        assertEquals(3, on.get("a").intValue());
+    }
+
+    /**
+     * Type mappers should be able to gracefully deal with end of
+     * input.
+     */
+    public void testEOF() throws Exception
+    {
+        String JSON =
+            "{ \"key\": [ { \"a\" : { \"name\": \"foo\",  \"type\": 1\n"
+            +"},  \"type\": 3, \"url\": \"http://www.google.com\" } ],\n"
+            +"\"name\": \"xyz\", \"type\": 1, \"url\" : null }\n  "
+            ;
+        JsonFactory jf = new JsonFactory();
+        JsonParser p = jf.createParser(new StringReader(JSON));
+        JsonNode result = objectMapper().readTree(p);
+
+        assertTrue(result.isObject());
+        assertEquals(4, result.size());
+
+        assertNull(objectMapper().readTree(p));
+        p.close();
+    }
+
+    public void testMultiple() throws Exception
+    {
+        String JSON = "12  \"string\" [ 1, 2, 3 ]";
+        JsonFactory jf = new JsonFactory();
+        JsonParser p = jf.createParser(new StringReader(JSON));
+        final ObjectMapper mapper = objectMapper();
+        JsonNode result = mapper.readTree(p);
+
+        assertTrue(result.isIntegralNumber());
+        assertTrue(result.isInt());
+        assertFalse(result.isTextual());
+        assertEquals(12, result.intValue());
+
+        result = mapper.readTree(p);
+        assertTrue(result.isTextual());
+        assertFalse(result.isIntegralNumber());
+        assertFalse(result.isInt());
+        assertEquals("string", result.textValue());
+
+        result = mapper.readTree(p);
+        assertTrue(result.isArray());
+        assertEquals(3, result.size());
+
+        assertNull(mapper.readTree(p));
+        p.close();
+    }
+
+    // [databind#1406]
+    public void testNullFromEOFViaMapper() throws Exception
+    {
+        final ObjectMapper mapper = objectMapper();
+
+        assertNull(mapper.readTree(new StringReader("")));
+        assertNull(mapper.readTree(new ByteArrayInputStream(new byte[0])));
+    }
+
+    // [databind#1406]
+    public void testNullFromEOFViaObjectReader() throws Exception
+    {
+        final ObjectMapper mapper = objectMapper();
+
+        assertNull(mapper.readTree(new StringReader("")));
+        assertNull(mapper.readTree(new ByteArrayInputStream(new byte[0])));
+        assertNull(mapper.readerFor(JsonNode.class)
+                .readTree(new StringReader("")));
+        assertNull(mapper.readerFor(JsonNode.class)
+                .readTree(new ByteArrayInputStream(new byte[0])));
+    }
+
+    /*
+    /**********************************************
+    /* Helper methods
+    /**********************************************
+     */
+
+    private int calcLength(Iterator<JsonNode> it)
+    {
+        int count = 0;
+        while (it.hasNext()) {
+            it.next();
+            ++count;
+        }
+        return count;
+    }
+}
+
