diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 082482d6b..029090496 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -439,3 +439,8 @@ Yoann Rodi√®re (fenrhil@github)
 Mark Woon (markwoon@github)
   * Reported #1178: `@JsonSerialize(contentAs=superType)` behavior disallowed in 2.7
    (2.7.4)
+
+Tom Mack (tommack@github)
+  * Reported #1208: treeToValue doesn't handle POJONodes that contain exactly
+    the requested value type
+   (2.7.4)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5a2b5b3ef..1c29dcc33 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -19,6 +19,8 @@ Project: jackson-databind
 #1197: `SNAKE_CASE` doesn't work when using Lombok's `@AllArgsConstructor`
 #1198: Problem with `@JsonTypeInfo.As.EXTERNAL_PROPERTY`, `defaultImpl`, missing type id, NPE
 #1203: `@JsonTypeInfo` does not work correctly for ReferenceTypes like `AtomicReference`
+#1208: treeToValue doesn't handle POJONodes that contain exactly the requested value type
+  (reported by Tom M)
 - Improve handling of custom content (de)serializers for `AtomicReference`
 
 2.7.3 (16-Mar-2016)
diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
index 1cc6850bb..5535266f4 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
@@ -2529,11 +2529,21 @@ public class ObjectMapper
         throws JsonProcessingException
     {
         try {
-            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode
+            // Simple cast when we just want to cast to, say, ObjectNode
             // ... one caveat; while everything is Object.class, let's not take shortcut
             if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
                 return (T) n;
             }
+            // 20-Apr-2016, tatu: Another thing: for VALUE_EMBEDDED_OBJECT, assume similar
+            //    short-cut coercion
+            if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
+                if (n instanceof POJONode) {
+                    Object ob = ((POJONode) n).getPojo();
+                    if ((ob == null) || valueType.isInstance(ob)) {
+                        return (T) ob;
+                    }
+                }
+            }
             return readValue(treeAsTokens(n), valueType);
         } catch (JsonProcessingException e) {
             throw e;
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
index 4ae84aead..aface1133 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
@@ -212,9 +212,9 @@ public class DateDeserializers
         }
         
         @Override
-        public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
+        public Calendar deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
-            Date d = _parseDate(jp, ctxt);
+            Date d = _parseDate(p, ctxt);
             if (d == null) {
                 return null;
             }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
index 89a8bf159..784898574 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
@@ -762,12 +762,12 @@ public abstract class StdDeserializer<T>
         throw ctxt.mappingException(_valueClass, t);
     }
 
-    protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)
+    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
+        JsonToken t = p.getCurrentToken();
         if (t == JsonToken.VALUE_NUMBER_INT) {
-            return new java.util.Date(jp.getLongValue());
+            return new java.util.Date(p.getLongValue());
         }
         if (t == JsonToken.VALUE_NULL) {
             return (java.util.Date) getNullValue(ctxt);
@@ -776,7 +776,7 @@ public abstract class StdDeserializer<T>
             String value = null;
             try {
                 // As per [JACKSON-203], take empty Strings to mean
-                value = jp.getText().trim();
+                value = p.getText().trim();
                 if (value.length() == 0) {
                     return (Date) getEmptyValue(ctxt);
                 }
@@ -789,16 +789,18 @@ public abstract class StdDeserializer<T>
                         "not a valid representation (error: "+iae.getMessage()+")");
             }
         }
-        // Issue#381
-        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Date parsed = _parseDate(jp, ctxt);
-            t = jp.nextToken();
-            if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
-                        "Attempted to unwrap single value array for single 'java.util.Date' value but there was more than a single value in the array");
-            }            
-            return parsed;            
+        // [databind#381]
+        if (t == JsonToken.START_ARRAY) {
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                p.nextToken();
+                final Date parsed = _parseDate(p, ctxt);
+                t = p.nextToken();
+                if (t != JsonToken.END_ARRAY) {
+                    throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
+                            "Attempted to unwrap single value array for single 'java.util.Date' value but there was more than a single value in the array");
+                }            
+                return parsed;
+            }
         }
         throw ctxt.mappingException(_valueClass, t);
     }
diff --git a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java
index c5a5d830e..df81fdbc9 100644
--- a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java
+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java
@@ -26,8 +26,7 @@ public class POJONode
      */
 
     @Override
-    public JsonNodeType getNodeType()
-    {
+    public JsonNodeType getNodeType() {
         return JsonNodeType.POJO;
     }
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java
index 21efe4826..b17dda304 100644
--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java
+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java
@@ -31,14 +31,11 @@ public class TestConversions extends BaseMapTest
         public Leaf() { }
         public Leaf(int v) { value = v; }
     }
-    
-    // MixIn for [JACKSON-554]
+
     @JsonDeserialize(using = LeafDeserializer.class)
-    public static class LeafMixIn
-    {
-    }
+    public static class LeafMixIn { }
 
-    // for [Issue#467]
+    // for [databind#467]
     @JsonSerialize(using=Issue467Serializer.class)
     static class Issue467Bean  {
         public int i;
@@ -121,7 +118,6 @@ public class TestConversions extends BaseMapTest
         }
     }
 
-    // Test for [JACKSON-554]
     public void testTreeToValue() throws Exception
     {
         String JSON = "{\"leaf\":{\"value\":13}}";
@@ -134,7 +130,17 @@ public class TestConversions extends BaseMapTest
         assertEquals(13, r1.leaf.value);
     }
 
-    // Test for [JACKSON-631]
+    // [databind#1208]: should coerce POJOs at least at root level
+    public void testTreeToValueWithPOJO() throws Exception
+    {
+        Calendar c = Calendar.getInstance();
+        c.setTime(new java.util.Date(0));
+        ValueNode pojoNode = MAPPER.getNodeFactory().pojoNode(c);        
+        Calendar result = MAPPER.treeToValue(pojoNode, Calendar.class);
+        assertNotNull(result);
+        assertEquals(result.getTimeInMillis(), c.getTimeInMillis());
+    }
+
     public void testBase64Text() throws Exception
     {
         // let's actually iterate over sets of encoding modes, lengths
@@ -202,7 +208,7 @@ public class TestConversions extends BaseMapTest
         assertEquals(3, data.length);
     }
 
-    // [Issue#232]
+    // [databind#232]
     public void testBigDecimalAsPlainStringTreeConversion() throws Exception
     {
         ObjectMapper mapper = new ObjectMapper();
@@ -239,7 +245,7 @@ public class TestConversions extends BaseMapTest
         }    
     }
 
-    // [#433]
+    // [databind#433]
     public void testBeanToTree() throws Exception
     {
         final CustomSerializedPojo pojo = new CustomSerializedPojo();
@@ -248,7 +254,7 @@ public class TestConversions extends BaseMapTest
         assertEquals(JsonNodeType.OBJECT, node.getNodeType());
     }
 
-    // [#467]
+    // [databind#467]
     public void testConversionOfPojos() throws Exception
     {
         final Issue467Bean input = new Issue467Bean(13);
@@ -264,7 +270,7 @@ public class TestConversions extends BaseMapTest
         assertEquals(EXP, MAPPER.writeValueAsString(tree));
     }
 
-    // [#467]
+    // [databind#467]
     public void testConversionOfTrees() throws Exception
     {
         final Issue467Tree input = new Issue467Tree();
