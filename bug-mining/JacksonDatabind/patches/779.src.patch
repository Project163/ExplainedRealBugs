diff --git a/release-notes/VERSION b/release-notes/VERSION
index 374dee27b..50cd3bcf0 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -5,6 +5,15 @@ Versions: 3.x (for earlier see VERSION-2.x)
 === Releases ===
 ------------------------------------------------------------------------
 
+3.0.0-rc2 (not yet released)
+
+#5003: Extend, improve set of `JsonNode.asXxx()` methods for number types
+#5025: Add support for automatic detection of subtypes (like `@JsonSubTypes`)
+  from Java 17 sealed types
+ (contributed by Andy B
+#5034: Extend, improve set of `JsonNode.asXxx()` methods for non-number
+  types (Boolean, String)
+
 3.0.0-rc1 (07-Mar-2025)
 
 #493: Change `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` default to `false`
@@ -108,11 +117,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #4992: Rename `JsonNodeFactory.textNode()` as `JsonNodeFactory.stringNode()` [JSTEP-3]
 #5004: Add `JsonMapper.builderWithJackson2Defaults()`
  (fixed by @pjfanning)
-#5025: Add support for automatic detection of subtypes (like `@JsonSubTypes`)
-  from Java 17 sealed types
- (contributed by Andy B
-#5034: Extend, improve set of `JsonNode.asXxx()` methods for non-number
-  types (Boolean, String)
 - Remove `MappingJsonFactory`
 - Add context parameter for `TypeSerializer` contextualization (`forProperty()`)
 - Default for `JsonNodeFeature.STRIP_TRAILING_BIGDECIMAL_ZEROES` changed to `false` for 3.0
diff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java
index 08323616d..b2f2f9850 100644
--- a/src/main/java/tools/jackson/databind/JsonNode.java
+++ b/src/main/java/tools/jackson/databind/JsonNode.java
@@ -785,29 +785,49 @@ public abstract class JsonNode
     public abstract OptionalInt intValueOpt();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>int</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0 (false)
-     * and 1 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
-     *<p>
-     * If representation cannot be converted to an int (including structured types
-     * like Objects and Arrays),
-     * default value of <b>0</b> will be returned; no exceptions are thrown.
+     * Method similar to {@link #intValue()} but in addition to coercing Number
+     * values (same as {@link #intValue()}), will also try to coerce a
+     * couple of additional types (or cases):
+     * <ul>
+     *  <li>JSON Floating-point numbers with fractions (ones without fractions
+     *    are ok for {@link #intValue()}) will be truncated to {@code int}
+     *    (if (and only if) they fit in {@code int} range).
+     *   </li>
+     *  <li>JSON Strings that represent JSON Numbers ("stringified" numbers)
+     *   </li>
+     *  <li>JSON Null (converted to {@code 0}))
+     *   </li>
+     *  <li>POJO nodes that contain Number values
+     *   </li>
+     * </ul>
+     *
+     * @return {@code int} value this node represents, if possible to accurately represent
+     *
+     * @throws JsonNodeException if node value cannot be converted to {@code int}
      */
     public abstract int asInt();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>int</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0 (false)
-     * and 1 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
-     *<p>
-     * If representation cannot be converted to an int (including structured types
-     * like Objects and Arrays),
-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.
+     * Method similar to {@link #intValue()}, but that will return specified
+     * {@code defaultValue} if this node cannot be converted to {@code int}.
+     *
+     * @param defaultValue Value to return if this node cannot be converted to {@code int}
+     *
+     * @return {@code int} value this node represents, if possible to accurately represent;
+     *   {@code defaultValue} otherwise
      */
     public abstract int asInt(int defaultValue);
 
+    /**
+     * Method similar to {@link #asInt()}, but that will return
+     * ({@code OptionalInt.empty()}) if this node cannot
+     * be coerced to {@code int}.
+     *
+     * @return {@link OptionalInt} value this node represents,
+     * if possible to accurately represent; {@code OptionalInt.empty()} otherwise
+     */
+    public abstract OptionalInt asIntOpt();
+
     // // Scalar access: Numbers, Java long
 
     /**
@@ -833,11 +853,11 @@ public abstract class JsonNode
 
     /**
      * Method similar to {@link #longValue()}, but that will return specified
-     * {@code defaultValue} if this node cannot be converted to Java {@code long}.
+     * {@code defaultValue} if this node cannot be converted to {@code long}.
      *
-     * @param defaultValue Value to return if this node cannot be converted to Java {@code long}
+     * @param defaultValue Value to return if this node cannot be converted to {@code long}
      *
-     * @return Java {@code long} value this node represents, if possible to accurately represent;
+     * @return {@code long} value this node represents, if possible to accurately represent;
      *   {@code defaultValue} otherwise
      */
     public abstract long longValue(long defaultValue);
@@ -853,29 +873,50 @@ public abstract class JsonNode
     public abstract OptionalLong longValueOpt();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>long</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0 (false)
-     * and 1 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
-     *<p>
-     * If representation cannot be converted to a long (including structured types
-     * like Objects and Arrays),
-     * default value of <b>0</b> will be returned; no exceptions are thrown.
+     * Method similar to {@link #longValue()} but in addition to coercing Number
+     * values (same as {@link #longValue()}), will also try to coerce a
+     * couple of additional types (or cases):
+     * <ul>
+     *  <li>JSON Floating-point numbers with fractions (ones without fractions
+     *    are ok for {@link #longValue()}) will be truncated to {@code long}
+     *    (if (and only if) they fit in {@code long} range).
+     *   </li>
+     *  <li>JSON Strings that represent JSON Numbers ("stringified" numbers)
+     *   </li>
+     *  <li>JSON Null (converted to {@code 0}))
+     *   </li>
+     *  <li>POJO nodes that contain Number values
+     *   </li>
+     * </ul>
+     *
+     * @return {@code long} value this node represents, if possible to accurately represent
+     *
+     * @throws JsonNodeException if node value cannot be converted to {@code long}
      */
     public abstract long asLong();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>long</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0 (false)
-     * and 1 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
-     *<p>
-     * If representation cannot be converted to a long (including structured types
-     * like Objects and Arrays),
-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.
+     * Method similar to {@link #asLong()}, but that will return specified
+     * {@code defaultValue} if this node cannot be coerced to {@code long}
+     * (instead of throwing an exception).
+     *
+     * @param defaultValue Value to return if this node cannot be coerced to {@code long}
+     *
+     * @return {@code long} value this node represents, if possible to accurately represent;
+     *   {@code defaultValue} otherwise
      */
     public abstract long asLong(long defaultValue);
 
+    /**
+     * Method similar to {@link #asLong()}, but that will return
+     * ({@code OptionalLong.empty()}) if this node cannot
+     * be coerced to {@code long}.
+     *
+     * @return {@link OptionalLong} value this node represents (or can be coerced to),
+     *    {@code OptionalLong.empty()} otherwise
+     */
+    public abstract OptionalLong asLongOpt();
+
     // // Scalar access: Numbers, Java BigInteger
 
     /**
@@ -897,6 +938,70 @@ public abstract class JsonNode
      */
     public abstract BigInteger bigIntegerValue();
 
+    /**
+     * Method similar to {@link #bigIntegerValue()}, but that will return specified
+     * {@code defaultValue} if this node cannot be converted to Java {@code BigInteger}.
+     *
+     * @param defaultValue Value to return if this node cannot be converted to Java {@code BigInteger}
+     *
+     * @return Java {@code BigInteger} value this node represents, if possible to accurately represent;
+     *   {@code defaultValue} otherwise
+     */
+    public abstract BigInteger bigIntegerValue(BigInteger defaultValue);
+
+    /**
+     * Method similar to {@link #bigIntegerValue()}, but that will return empty
+     * ({@code Optional.empty()}) if this node cannot
+     * be converted to Java {@code BigInteger}.
+     *
+     * @return Java {@code BigInteger} value this node represents, as {@code Optional<BigInteger>},
+     * if possible to accurately represent; {@code Optional.empty()} otherwise
+     */
+    public abstract Optional<BigInteger> bigIntegerValueOpt();
+
+    /**
+     * Method similar to {@link #bigIntegerValue()} but in addition to coercing Number
+     * values (same as {@link #bigIntegerValue()}), will also try to coerce a
+     * couple of additional types (or cases):
+     * <ul>
+     *  <li>JSON Floating-point numbers with fractions (ones without fractions
+     *    are ok for {@link #bigIntegerValue()}) will be <b>truncated</b> to integer value
+     *    (like with {@link BigDecimal#toBigInteger()}))
+     *   </li>
+     *  <li>JSON Strings that represent JSON Numbers ("stringified" numbers)
+     *   </li>
+     *  <li>JSON Null (converted to {@code 0}))
+     *   </li>
+     *  <li>POJO nodes that contain Number values
+     *   </li>
+     *  </ul>
+     *
+     * @return {@link BigInteger} value this node represents, if possible to accurately convert;
+     *   {@code defaultValue} otherwise
+     */
+    public abstract BigInteger asBigInteger();
+
+    /**
+     * Method similar to {@link #asBigInteger()}, but that will return specified
+     * {@code defaultValue} if this node cannot be converted to {@link BigInteger}.
+     *
+     * @param defaultValue Value to return if this node cannot be converted to {@link BigInteger}
+     *
+     * @return {@link BigInteger} value this node represents, if possible to accurately convert;
+     *   {@code defaultValue} otherwise
+     */
+    public abstract BigInteger asBigInteger(BigInteger defaultValue);
+
+    /**
+     * Method similar to {@link #bigIntegerValue()}, but that will return empty
+     * ({@code Optional.empty()}) if this node cannot
+     * be converted to Java {@code BigInteger}.
+     *
+     * @return {@link BigInteger} value this node represents, as {@code Optional<BigInteger>},
+     * if possible to accurately represent; {@code Optional.empty()} otherwise.
+     */
+    public abstract Optional<BigInteger> asBigIntegerOpt();
+
     // // Scalar access: Numbers, Java float
 
     /**
@@ -921,7 +1026,7 @@ public abstract class JsonNode
     // // Scalar access: Numbers, Java double
 
     /**
-     * Method that will try to access value of this node as a Java {@code double}:
+     * Method that will try to access value of this node as a {@code double}:
      * but if node value cannot be expressed <b>exactly</b> as a {@code double},
      * a {@link JsonNodeException} will be thrown.
      * Access works for following cases:
@@ -936,17 +1041,17 @@ public abstract class JsonNode
      *
      * @return {@code Double} value this node represents, if possible to accurately represent
      *
-     * @throws JsonNodeException if node value cannot be converted to Java {@code double}
+     * @throws JsonNodeException if node value cannot be converted to {@code double}
      */
     public abstract double doubleValue();
 
     /**
      * Method similar to {@link #doubleValue()}, but that will return specified
-     * {@code defaultValue} if this node cannot be converted to Java {@code double}.
+     * {@code defaultValue} if this node cannot be converted to {@code double}.
      *
-     * @param defaultValue Value to return if this node cannot be converted to Java {@code double}
+     * @param defaultValue Value to return if this node cannot be converted to {@code double}
      *
-     * @return Java {@code double} value this node represents, if possible to accurately represent;
+     * @return {@code double} value this node represents, if possible to accurately represent;
      *   {@code defaultValue} otherwise
      */
     public abstract double doubleValue(double defaultValue);
@@ -960,31 +1065,45 @@ public abstract class JsonNode
      * if possible to accurately represent; {@code OptionalDouble.empty()} otherwise
      */
     public abstract OptionalDouble doubleValueOpt();
-    
+
     /**
-     * Method that will try to convert value of this node to a Java <b>double</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)
-     * and 1.0 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
+     * Method similar to {@link #doubleValue()} but in addition to coercing Number
+     * values will also try coerce couple of additional types:
+     * <ul>
+     *  <li>JSON String that represents JSON Numbers ("stringified" numbers)
+     *   </li>
+     *  <li>JSON Null (converted to {@code 0.0d})
+     *   </li>
+     *  <li>POJO nodes that contain Number values
+     *   </li>
+     * </ul>
      *<p>
-     * If representation cannot be converted to an int (including structured types
-     * like Objects and Arrays),
-     * default value of <b>0.0</b> will be returned; no exceptions are thrown.
+     *
+     * @return {@code double} value this node represents, if possible to accurately represent
+     *
+     * @throws JsonNodeException if node value cannot be converted to {@code double}
      */
     public abstract double asDouble();
 
     /**
-     * Method that will try to convert value of this node to a Java <b>double</b>.
-     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)
-     * and 1.0 (true), and Strings are parsed using default Java language integer
-     * parsing rules.
-     *<p>
-     * If representation cannot be converted to an int (including structured types
-     * like Objects and Arrays),
-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.
+     * Method similar to {@link #asDouble()}, but that will return {@code defaultValue}
+     * if this node cannot be coerced to {@code double}.
+     *
+     * @return {@code double} value this node represents,
+     * if possible to accurately represent; {@code defaultValue} otherwise
      */
     public abstract double asDouble(double defaultValue);
 
+    /**
+     * Method similar to {@link #asDouble()}, but that will return
+     * ({@code OptionalDouble.empty()}) if this node cannot
+     * be coerced to {@code double}.
+     *
+     * @return {@link OptionalDouble} value this node represents,
+     * if possible to accurately represent; {@code OptionalDouble.empty()} otherwise
+     */
+    public abstract OptionalDouble asDoubleOpt();
+
     // // Scalar access: Numbers, Java BigDecimal
 
     /**
@@ -1024,10 +1143,50 @@ public abstract class JsonNode
      */
     public abstract Optional<BigDecimal> decimalValueOpt();
 
+    /**
+     * Method that will try to access value of this node as a {@link BigDecimal}:
+     * but if node value cannot be expressed <b>exactly</b> as a {@code BigDecimal},
+     * a {@link JsonNodeException} will be thrown.
+     * Access works for following cases:
+     * <ul>
+     *  <li>JSON Floating-point values (but not "NaN" or "Infinity")
+     *    </li>
+     *  <li>JSON Integer values
+     *   </li>
+     *  <li>JSON String that represents JSON Numbers ("stringified" numbers)
+     *   </li>
+     *  <li>JSON Null (converted to {@link BigDecimal#ZERO}))
+     *   </li>
+     *  <li>POJO nodes that contain Number values
+     *   </li>
+     * </ul>
+     *<p>
+     *
+     * @return {@link BigDecimal} value this node represents, if possible to accurately represent
+     *
+     * @throws JsonNodeException if node value cannot be converted to {@code BigDecimal}
+     */
     public abstract BigDecimal asDecimal();
-    
+
+    /**
+     * Method similar to {@link #asDecimal()}, but that will return {@code defaultValue}
+     * if this node cannot be coerced to Java {@code BigDecimal}.
+     *
+     * @return {@code BigDecimal} value this node represents,
+     * if possible to accurately represent; {@code defaultValue} otherwise
+     */
     public abstract BigDecimal asDecimal(BigDecimal defaultValue);
 
+    /**
+     * Method similar to {@link #asDecimal()}, but that will return empty
+     * {@link Optional} ({@code Optional.empty()}) if this node cannot
+     * be coerced to {@code BigDecimal}.
+     *
+     * @return Java {@code BigDecimal} value this node represents, as {@code Optional<BigDecimal>},
+     * if possible to accurately represent; {@code Optional.empty()} otherwise
+     */
+    public abstract Optional<BigDecimal> asDecimalOpt();
+
     /*
     /**********************************************************************
     /* Public API, extended traversal with "required()"
diff --git a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
index b14fe89bb..9dea2cc8d 100644
--- a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
+++ b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java
@@ -89,14 +89,21 @@ public abstract class BaseJsonNode
 
     @Override
     public int asInt() {
-        return asInt(0);
+        return _reportCoercionFail("asInt()", Integer.TYPE, "value type not numeric");
     }
 
     @Override
     public int asInt(int defaultValue) {
+        // Overridden by NumericNode, for other types return default
         return defaultValue;
     }
 
+    @Override
+    public OptionalInt asIntOpt() {
+        // Overridden by NumericNode, for other types return default
+        return OptionalInt.empty();
+    }
+
     @Override
     public long longValue() {
         return _reportCoercionFail("longValue()", Long.TYPE, "value type not numeric");
@@ -116,19 +123,55 @@ public abstract class BaseJsonNode
 
     @Override
     public long asLong() {
-        return asLong(0L);
+        return _reportCoercionFail("asLong()", Long.TYPE, "value type not numeric");
     }
 
     @Override
     public long asLong(long defaultValue) {
+        // Overridden by NumericNode, for other types return default
         return defaultValue;
     }
 
+    @Override
+    public OptionalLong asLongOpt() {
+        // Overridden by NumericNode, for other types return default
+        return OptionalLong.empty();
+    }
+
     @Override
     public BigInteger bigIntegerValue() {
         return _reportCoercionFail("bigIntegerValue()", BigInteger.class, "value type not numeric");
     }
 
+    @Override
+    public BigInteger bigIntegerValue(BigInteger defaultValue) {
+        // Overridden by NumericNode, for other types return default
+        return defaultValue;
+    }
+
+    @Override
+    public Optional<BigInteger> bigIntegerValueOpt() {
+        // Overridden by NumericNode, for other types return default
+        return Optional.empty();
+    }
+
+    @Override
+    public BigInteger asBigInteger() {
+        return _reportCoercionFail("asBigInteger()", BigInteger.class, "value type not numeric");
+    }
+
+    @Override
+    public BigInteger asBigInteger(BigInteger defaultValue) {
+        // Overridden by NumericNode, for other types return default
+        return defaultValue;
+    }
+
+    @Override
+    public Optional<BigInteger> asBigIntegerOpt() {
+        // Overridden by NumericNode, for other types return default
+        return Optional.empty();
+    }
+
     @Override
     public float floatValue() {
         return _reportCoercionFail("floatValue()", Float.TYPE, "value type not numeric");
@@ -153,14 +196,21 @@ public abstract class BaseJsonNode
 
     @Override
     public double asDouble() {
-        return asDouble(0.0);
+        return _reportCoercionFail("asDouble()", Double.TYPE, "value type not numeric");
     }
 
     @Override
     public double asDouble(double defaultValue) {
+        // Overridden by NumericNode, for other types return default
         return defaultValue;
     }
-    
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        // Overridden by NumericNode, for other types return default
+        return OptionalDouble.empty();
+    }
+
     @Override
     public BigDecimal decimalValue() {
         return _reportCoercionFail("decimalValue()", BigDecimal.class, "value type not numeric");
@@ -174,18 +224,26 @@ public abstract class BaseJsonNode
 
     @Override
     public Optional<BigDecimal> decimalValueOpt() {
+        // Overridden by NumericNode, for other types return default
         return Optional.empty();
     }
 
     @Override
     public BigDecimal asDecimal() {
-        return asDecimal(BigDecimal.ZERO);
+        return _reportCoercionFail("asDecimal()", BigDecimal.class,
+                "value type not coercible to `BigDecimal`");
     }
-    
+
     @Override
     public BigDecimal asDecimal(BigDecimal defaultValue) {
-        // !!! TODO
-        return decimalValue(defaultValue);
+        // Overridden by NumericNode, for other types return default
+        return defaultValue;
+    }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        // Overridden by NumericNode, for other types return default
+        return Optional.empty();
     }
 
     /*
@@ -586,6 +644,26 @@ public abstract class BaseJsonNode
                 "value has fractional part");
     }
 
+    protected int _reportIntCoercionNaNFail(String method) {
+        return _reportCoercionFail(method, Integer.TYPE,
+                "value non-Finite ('NaN')");
+    }
+
+    protected long _reportLongCoercionNaNFail(String method) {
+        return _reportCoercionFail(method, Long.TYPE,
+                "value non-Finite ('NaN')");
+    }
+
+    protected BigInteger _reportBigIntegerCoercionNaNFail(String method) {
+        return _reportCoercionFail(method, BigInteger.class,
+                "value non-Finite ('NaN')");
+    }
+    
+    protected BigDecimal _reportBigDecimalCoercionNaNFail(String method) {
+        return _reportCoercionFail(method, BigDecimal.class,
+                "value non-Finite ('NaN')");
+    }
+
     /**
      * Helper method that throws {@link JsonNodeException} as a result of
      * this node being of wrong type
diff --git a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
index 05958e85e..e44ea081f 100644
--- a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
+++ b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java
@@ -15,7 +15,7 @@ import tools.jackson.databind.SerializationContext;
  * Numeric node that contains simple 64-bit integer values.
  */
 public class BigIntegerNode
-    extends NumericNode
+    extends NumericIntNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -45,31 +45,12 @@ public class BigIntegerNode
     /**********************************************************************
      */
 
-    @Override
-    public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }
-
     @Override
     public JsonParser.NumberType numberType() { return JsonParser.NumberType.BIG_INTEGER; }
 
     @Override
     public boolean isBigInteger() { return true; }
 
-    @Override
-    public boolean isIntegralNumber() { return true; }
-
-    @Override
-    public boolean isNaN() { return false; }
-
-    @Override public boolean canConvertToInt() {
-        return (_value.compareTo(MIN_INTEGER) >= 0)
-                && (_value.compareTo(MAX_INTEGER) <= 0);
-    }
-
-    @Override public boolean canConvertToLong() {
-        return (_value.compareTo(MIN_LONG) >= 0)
-                && (_value.compareTo(MAX_LONG) <= 0);
-    }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, scalar access
@@ -91,20 +72,9 @@ public class BigIntegerNode
         return _value;
     }
 
-    @Override
-    public short shortValue() {
-        if (canConvertToInt()) {
-            int v = _value.intValue();
-            if (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE) {
-                return (short) v;
-            }
-        }
-        return _reportShortCoercionRangeFail("shortValue()");
-    }
-
     @Override
     public int intValue() {
-        if (canConvertToInt()) {
+        if (_inIntRange()) {
             return _value.intValue();
         }
         return _reportIntCoercionRangeFail("intValue()");
@@ -112,12 +82,30 @@ public class BigIntegerNode
 
     @Override
     public int intValue(int defaultValue) {
-        return canConvertToInt() ? _value.intValue() : defaultValue;
+        return _inIntRange() ? _value.intValue() : defaultValue;
     }
 
     @Override
     public OptionalInt intValueOpt() {
-        return canConvertToInt() ? OptionalInt.of(_value.intValue()) : OptionalInt.empty();
+        return _inIntRange() ? OptionalInt.of(_value.intValue()) : OptionalInt.empty();
+    }
+    
+    @Override
+    public int asInt() {
+        if (_inIntRange()) {
+            return _value.intValue();
+        }
+        return _reportIntCoercionRangeFail("asInt()");
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        return _inIntRange() ? _value.intValue() : defaultValue;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        return _inIntRange() ? OptionalInt.of(_value.intValue()) : OptionalInt.empty();
     }
     
     @Override
@@ -130,23 +118,48 @@ public class BigIntegerNode
 
     @Override
     public long longValue(long defaultValue) {
+        return (canConvertToLong()) ? _value.longValue() : defaultValue;
+    }
+
+    @Override
+    public OptionalLong longValueOpt() {
+        return canConvertToLong() ? OptionalLong.of(_value.longValue()) : OptionalLong.empty();
+    }
+
+    @Override
+    public long asLong() {
         if (canConvertToLong()) {
             return _value.longValue();
         }
-        return defaultValue;
+        return _reportLongCoercionRangeFail("asLong()");
     }
 
     @Override
-    public OptionalLong longValueOpt() {
+    public long asLong(long defaultValue) {
+        return (canConvertToLong()) ? _value.longValue() : defaultValue;
+    }
+
+    @Override
+    public OptionalLong asLongOpt() {
         return canConvertToLong() ? OptionalLong.of(_value.longValue()) : OptionalLong.empty();
     }
 
     @Override
     public BigInteger bigIntegerValue() { return _value; }
 
+    @Override
+    public BigInteger bigIntegerValue(BigInteger defaultValue) { return _value; }
+
+    @Override
+    public Optional<BigInteger> bigIntegerValueOpt() { return Optional.of(_value); }
+
+    
+    // // // BigInteger differs a bit from other Integral types as there's
+    // // // range overflow possibility
+
     @Override
     public float floatValue() {
-        float f = _value.floatValue();
+        float f = _asFloatValueUnchecked();
         if (Float.isFinite(f)) {
             return f;
         }
@@ -155,7 +168,7 @@ public class BigIntegerNode
 
     @Override
     public double doubleValue() {
-        double d = _value.doubleValue();
+        double d = _asDoubleValueUnchecked();
         if (Double.isFinite(d)) {
             return d;
         }
@@ -164,16 +177,37 @@ public class BigIntegerNode
 
     @Override
     public double doubleValue(double defaultValue) {
-        double d = _value.doubleValue();
+        double d = _asDoubleValueUnchecked();
+        return (Double.isFinite(d)) ? d : defaultValue;
+    }
+
+    @Override
+    public OptionalDouble doubleValueOpt() {
+        double d = _asDoubleValueUnchecked();
+        if (Double.isFinite(d)) {
+            return OptionalDouble.of(_value.doubleValue());
+        }
+        return OptionalDouble.empty();
+    }
+
+    @Override
+    public double asDouble() {
+        double d = _asDoubleValueUnchecked();
         if (Double.isFinite(d)) {
             return d;
         }
-        return defaultValue;
+        return _reportDoubleCoercionRangeFail("asDouble()");
     }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        double d = _value.doubleValue();
+    public double asDouble(double defaultValue) {
+        double d = _asDoubleValueUnchecked();
+        return (Double.isFinite(d)) ? d : defaultValue;
+    }
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        double d = _asDoubleValueUnchecked();
         if (Double.isFinite(d)) {
             return OptionalDouble.of(_value.doubleValue());
         }
@@ -196,9 +230,51 @@ public class BigIntegerNode
     }
 
     /*
-    /**********************************************************
+    /**********************************************************************
+    /* Abstract methods impls for NumericIntNode
+    /**********************************************************************
+     */
+
+    @Override
+    protected int _asIntValueUnchecked() {
+        return _value.intValue();
+    }
+
+    @Override
+    protected float _asFloatValueUnchecked() {
+        return _value.floatValue();
+    }
+
+    @Override
+    protected double _asDoubleValueUnchecked() {
+        return _value.doubleValue();
+    }
+
+    @Override
+    protected boolean _inShortRange() {
+        if (_inIntRange()) {
+            int v = _value.intValue();
+            return (v >= Short.MIN_VALUE && v <= Short.MAX_VALUE);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean _inIntRange() {
+        return (_value.compareTo(MIN_INTEGER) >= 0)
+                && (_value.compareTo(MAX_INTEGER) <= 0);
+    }
+
+    @Override
+    protected boolean _inLongRange() {
+        return (_value.compareTo(MIN_LONG) >= 0)
+                && (_value.compareTo(MAX_LONG) <= 0);
+    }
+
+    /*
+    /**********************************************************************
     /* Other overrides
-    /**********************************************************
+    /**********************************************************************
      */
     
     @Override
@@ -224,10 +300,4 @@ public class BigIntegerNode
     public int hashCode() {
         return Objects.hashCode(_value);
     }
-
-    /*
-    /**********************************************************
-    /* Other overrides
-    /**********************************************************
-     */
 }
diff --git a/src/main/java/tools/jackson/databind/node/BooleanNode.java b/src/main/java/tools/jackson/databind/node/BooleanNode.java
index d7293bbe1..e21c0f64d 100644
--- a/src/main/java/tools/jackson/databind/node/BooleanNode.java
+++ b/src/main/java/tools/jackson/databind/node/BooleanNode.java
@@ -110,19 +110,11 @@ public class BooleanNode
     protected String _asString() {
         return _value ? "true" : "false";
     }
-    
-    @Override
-    public int asInt(int defaultValue) {
-        return _value ? 1 : 0;
-    }
+
     @Override
     public long asLong(long defaultValue) {
         return _value ? 1L : 0L;
     }
-    @Override
-    public double asDouble(double defaultValue) {
-        return _value ? 1.0 : 0.0;
-    }
 
     /*
     /**********************************************************************
diff --git a/src/main/java/tools/jackson/databind/node/DecimalNode.java b/src/main/java/tools/jackson/databind/node/DecimalNode.java
index 520d979a1..ea92a96a6 100644
--- a/src/main/java/tools/jackson/databind/node/DecimalNode.java
+++ b/src/main/java/tools/jackson/databind/node/DecimalNode.java
@@ -5,18 +5,16 @@ import java.math.BigInteger;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalDouble;
-import java.util.OptionalInt;
-import java.util.OptionalLong;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
 
 /**
  * Numeric node that contains values that do not fit in simple
- * integer (int, long) or floating point (double) values.
+ * floating point (double) values.
  */
 public class DecimalNode
-    extends NumericNode
+    extends NumericFPNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -50,36 +48,18 @@ public class DecimalNode
     /**********************************************************************
      */
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }
-    
     @Override
     public JsonParser.NumberType numberType() { return JsonParser.NumberType.BIG_DECIMAL; }
 
     @Override
     public boolean isBigDecimal() { return true; }
 
-    @Override
-    public boolean isFloatingPointNumber() { return true; }
-
     @Override
     public boolean isNaN() { return false; }
-    
-    @Override public boolean canConvertToInt() {
-        return _inIntRange() && canConvertToExactIntegral();
-    }
-
-    @Override public boolean canConvertToLong() {
-        return _inLongRange() && canConvertToExactIntegral();
-    }
-
-    @Override // since 2.12
-    public boolean canConvertToExactIntegral() {
-        return !_hasFractionalPart();
-    }
 
     /*
     /**********************************************************************
-    /* Overridden JsonNode methods, scalar access
+    /* Overridden JsonNode methods, scalar access, non-numeric
     /**********************************************************************
      */
 
@@ -87,103 +67,64 @@ public class DecimalNode
     public String _asString() {
         return _value.toString();
     }
-    
-    @Override
-    public Number numberValue() { return _value; }
-
-    @Override
-    public short shortValue() {
-        if (!_inShortRange()) {
-            return _reportShortCoercionRangeFail("shortValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportShortCoercionFractionFail("shortValue()");
-        }
-        return _value.shortValue();
-    }
 
-    @Override
-    public int intValue() {
-        if (!_inIntRange()) {
-            return _reportIntCoercionRangeFail("intValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportIntCoercionFractionFail("intValue()");
-        }
-        return _value.intValue();
-    }
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access, numeric
+    /**********************************************************************
+     */
 
     @Override
-    public int intValue(int defaultValue) {
-        if (!_inIntRange() || _hasFractionalPart()) {
-             return defaultValue;
-        }
-        return _value.intValue();
-    }
+    public Number numberValue() { return _value; }
 
-    @Override
-    public OptionalInt intValueOpt() {
-        if (!_inIntRange() || _hasFractionalPart()) {
-            return OptionalInt.empty();
-       }
-       return OptionalInt.of(_value.intValue());
-    }
 
     @Override
-    public long longValue() {
-        if (!_inLongRange()) {
-            return _reportLongCoercionRangeFail("longValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportLongCoercionFractionFail("longValue()");
-        }
-        return _value.longValue();
-    }
-
-    @Override
-    public long longValue(long defaultValue) {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return defaultValue;
+    public float floatValue() {
+        float f = _value.floatValue();
+        if (Float.isFinite(f)) {
+            return f;
         }
-        return _value.longValue();
+        return _reportFloatCoercionRangeFail("floatValue()");
     }
 
     @Override
-    public OptionalLong longValueOpt() {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return OptionalLong.empty();
+    public double doubleValue() {
+        double d = _value.doubleValue();
+        if (Double.isFinite(d)) {
+            return d;
         }
-        return OptionalLong.of(_value.longValue());
+        return _reportDoubleCoercionRangeFail("doubleValue()");
     }
 
     @Override
-    public BigInteger bigIntegerValue() {
-        if (_hasFractionalPart()) {
-            _reportBigIntegerCoercionFractionFail("bigIntegerValue()");
+    public double doubleValue(double defaultValue) {
+        double d = _value.doubleValue();
+        if (Double.isFinite(d)) {
+            return d;
         }
-        return _value.toBigInteger();
+        return defaultValue;
     }
 
     @Override
-    public float floatValue() {
-        float f = _value.floatValue();
-        if (Float.isFinite(f)) {
-            return f;
+    public OptionalDouble doubleValueOpt() {
+        double d = _value.doubleValue();
+        if (Double.isFinite(d)) {
+            return OptionalDouble.of(_value.doubleValue());
         }
-        return _reportFloatCoercionRangeFail("floatValue()");
+        return OptionalDouble.empty();
     }
 
     @Override
-    public double doubleValue() {
+    public double asDouble() {
         double d = _value.doubleValue();
         if (Double.isFinite(d)) {
             return d;
         }
-        return _reportDoubleCoercionRangeFail("doubleValue()");
+        return _reportDoubleCoercionRangeFail("asDouble()");
     }
 
     @Override
-    public double doubleValue(double defaultValue) {
+    public double asDouble(double defaultValue) {
         double d = _value.doubleValue();
         if (Double.isFinite(d)) {
             return d;
@@ -192,7 +133,7 @@ public class DecimalNode
     }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
+    public OptionalDouble asDoubleOpt() {
         double d = _value.doubleValue();
         if (Double.isFinite(d)) {
             return OptionalDouble.of(_value.doubleValue());
@@ -200,6 +141,8 @@ public class DecimalNode
         return OptionalDouble.empty();
     }
 
+    // Overridden versions from NumericFPNode (for minor performance gain)
+    
     @Override
     public BigDecimal decimalValue() { return _value; }
 
@@ -209,6 +152,74 @@ public class DecimalNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(_value); }
 
+    @Override
+    public BigDecimal asDecimal() { return _value;  }
+    
+    @Override
+    public BigDecimal asDecimal(BigDecimal defaultValue) { return _value;  }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() { return Optional.of(_value); }
+
+    /*
+    /**********************************************************************
+    /* NumericFPNode abstract method impls
+    /**********************************************************************
+     */
+
+    @Override
+    protected short _asShortValueUnchecked() {
+        return _value.shortValue();
+    }
+
+    @Override
+    protected int _asIntValueUnchecked() {
+        return _value.intValue();
+    }
+    
+    @Override
+    protected long _asLongValueUnchecked() {
+        return _value.longValue();
+    }
+
+    @Override
+    protected BigInteger _asBigIntegerValueUnchecked() {
+        return _value.toBigInteger();
+    }
+
+    @Override
+    protected BigDecimal _asDecimalValueUnchecked() {
+        return _value;
+    }
+
+    @Override
+    protected boolean _hasFractionalPart() {
+        return (_value.signum() != 0)
+               && (_value.scale() > 0)
+               && (_value.stripTrailingZeros().scale() > 0);
+    }
+    
+    @Override
+    protected boolean _inShortRange() {
+        return (_value.compareTo(MIN_SHORT) >= 0) && (_value.compareTo(MAX_SHORT) <= 0);
+    }
+
+    @Override
+    protected boolean _inIntRange() {
+        return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0);
+    }
+
+    @Override
+    protected boolean _inLongRange() {
+        return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0);
+    }
+
+    /*
+    /**********************************************************************
+    /* Other overrides
+    /**********************************************************************
+     */
+
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
@@ -232,22 +243,4 @@ public class DecimalNode
     public int hashCode() {
         return _value.hashCode();
     }
-
-    private boolean _hasFractionalPart() {
-        return (_value.signum() != 0)
-               && (_value.scale() > 0)
-               && (_value.stripTrailingZeros().scale() > 0);
-    }
-    
-    private boolean _inShortRange() {
-        return (_value.compareTo(MIN_SHORT) >= 0) && (_value.compareTo(MAX_SHORT) <= 0);
-    }
-
-    private boolean _inIntRange() {
-        return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0);
-    }
-
-    private boolean _inLongRange() {
-        return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0);
-    }
 }
diff --git a/src/main/java/tools/jackson/databind/node/DoubleNode.java b/src/main/java/tools/jackson/databind/node/DoubleNode.java
index 09622145d..3804f6166 100644
--- a/src/main/java/tools/jackson/databind/node/DoubleNode.java
+++ b/src/main/java/tools/jackson/databind/node/DoubleNode.java
@@ -2,10 +2,7 @@ package tools.jackson.databind.node;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.Optional;
 import java.util.OptionalDouble;
-import java.util.OptionalInt;
-import java.util.OptionalLong;
 
 import tools.jackson.core.*;
 import tools.jackson.core.io.NumberOutput;
@@ -16,7 +13,7 @@ import tools.jackson.databind.SerializationContext;
  * floating point values simple 32-bit integer values.
  */
 public class DoubleNode
-    extends NumericNode
+    extends NumericFPNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -32,17 +29,6 @@ public class DoubleNode
 
     public static DoubleNode valueOf(double v) { return new DoubleNode(v); }
 
-    /*
-    /**********************************************************************
-    /* BaseJsonNode extended API
-    /**********************************************************************
-     */
-
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }
-
-    @Override
-    public JsonParser.NumberType numberType() { return JsonParser.NumberType.DOUBLE; }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, simple properties
@@ -50,27 +36,19 @@ public class DoubleNode
      */
 
     @Override
-    public boolean isFloatingPointNumber() { return true; }
+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.DOUBLE; }
 
     @Override
     public boolean isDouble() { return true; }
 
-    @Override public boolean canConvertToInt() {
-        return canConvertToExactIntegral() && _inIntRange();
-    }
-
-    @Override public boolean canConvertToLong() {
-        return canConvertToExactIntegral() && _inLongRange();
-    }
-
     @Override
-    public boolean canConvertToExactIntegral() {
-        return !isNaN() && !_hasFractionalPart();
+    public boolean isNaN() {
+        return NumberOutput.notFinite(_value);
     }
 
     /*
     /**********************************************************************
-    /* Overridden JsonNode methods, scalar access
+    /* Overridden JsonNode methods, scalar access, non-numeric
     /**********************************************************************
      */
 
@@ -79,121 +57,115 @@ public class DoubleNode
         return String.valueOf(_value);
     }
     
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access, numeric
+    /**********************************************************************
+     */
+
     @Override
     public Number numberValue() {
         return Double.valueOf(_value);
     }
 
     @Override
-    public short shortValue() {
-        if (!_inShortRange()) {
-            return _reportShortCoercionRangeFail("shortValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportShortCoercionFractionFail("shortValue()");
+    public float floatValue() {
+        float f = (float) _value;
+        if (Float.isFinite(f)) {
+            return f;
         }
-        return (short) _value;
+        return _reportFloatCoercionRangeFail("floatValue()");
     }
 
     @Override
-    public int intValue() {
-        if (!_inIntRange()) {
-            return _reportIntCoercionRangeFail("intValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportIntCoercionFractionFail("intValue()");
-        }
-        return (int) _value;
+    public double doubleValue() {
+        return _value;
     }
 
     @Override
-    public int intValue(int defaultValue) {
-        if (!_inIntRange() || _hasFractionalPart()) {
-             return defaultValue;
-        }
-        return (int) _value;
+    public double doubleValue(double defaultValue) {
+        return _value;
     }
 
     @Override
-    public OptionalInt intValueOpt() {
-        if (!_inIntRange() || _hasFractionalPart()) {
-            return OptionalInt.empty();
-       }
-       return OptionalInt.of((int) _value);
+    public OptionalDouble doubleValueOpt() {
+        return OptionalDouble.of(_value);
     }
 
     @Override
-    public long longValue() {
-        if (!_inLongRange()) {
-            return _reportLongCoercionRangeFail("longValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportLongCoercionFractionFail("longValue()");
-        }
-        return (long) _value;
+    public double asDouble() {
+        return _value;
     }
 
     @Override
-    public long longValue(long defaultValue) {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return defaultValue;
-       }
-        return (long) _value;
+    public double asDouble(double defaultValue) {
+        return _value;
     }
 
     @Override
-    public OptionalLong longValueOpt() {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return OptionalLong.empty();
-       }
-       return OptionalLong.of((long) _value);
+    public OptionalDouble asDoubleOpt() {
+        return OptionalDouble.of(_value);
     }
 
+    /*
+    /**********************************************************************
+    /* NumericFPNode abstract method impls
+    /**********************************************************************
+     */
+
     @Override
-    public BigInteger bigIntegerValue() {
-        if (_hasFractionalPart()) {
-            _reportBigIntegerCoercionFractionFail("bigIntegerValue()");
-        }
-        return decimalValue().toBigInteger();
+    protected short _asShortValueUnchecked() {
+        return (short) _value;
     }
 
     @Override
-    public float floatValue() {
-        float f = (float) _value;
-        if (Float.isFinite(f)) {
-            return f;
-        }
-        return _reportFloatCoercionRangeFail("floatValue()");
+    protected int _asIntValueUnchecked() {
+        return (int) _value;
     }
-
+    
     @Override
-    public double doubleValue() { return _value; }
+    protected long _asLongValueUnchecked() {
+        return (long) _value;
+    }
 
     @Override
-    public double doubleValue(double defaultValue) { return _value; }
+    protected BigInteger _asBigIntegerValueUnchecked() {
+        return BigDecimal.valueOf(_value).toBigInteger();
+    }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        return OptionalDouble.of(_value);
+    protected BigDecimal _asDecimalValueUnchecked() {
+        return BigDecimal.valueOf(_value);
     }
-
+    
     @Override
-    public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }
+    protected boolean _hasFractionalPart() { return _value != Math.rint(_value); }
 
     @Override
-    public BigDecimal decimalValue(BigDecimal defaultValue) { return decimalValue(); }
+    protected boolean _inShortRange() {
+        return !isNaN() && (_value >= Short.MIN_VALUE) && (_value <= Short.MAX_VALUE);
+    }
 
     @Override
-    public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
+    protected boolean _inIntRange() {
+        return !isNaN() && (_value >= Integer.MIN_VALUE) && (_value <= Integer.MAX_VALUE);
+    }
 
     @Override
-    public boolean isNaN() {
-        return NumberOutput.notFinite(_value);
+    protected boolean _inLongRange() {
+        return !isNaN() && (_value >= Long.MIN_VALUE) && (_value <= Long.MAX_VALUE);
     }
 
+    /*
+    /**********************************************************************
+    /* Overrides, other
+    /**********************************************************************
+     */
+
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
-            throws JacksonException {
+        throws JacksonException
+    {
         g.writeNumber(_value);
     }
 
@@ -218,18 +190,4 @@ public class DoubleNode
         long l = Double.doubleToLongBits(_value);
         return ((int) l) ^ (int) (l >> 32);
     }
-
-    private boolean _hasFractionalPart() { return _value != Math.rint(_value); }
-
-    private boolean _inShortRange() {
-        return !isNaN() && (_value >= Short.MIN_VALUE) && (_value <= Short.MAX_VALUE);
-    }
-
-    private boolean _inIntRange() {
-        return !isNaN() &&(_value >= Integer.MIN_VALUE) && (_value <= Integer.MAX_VALUE);
-    }
-
-    private boolean _inLongRange() {
-        return !isNaN() && (_value >= Long.MIN_VALUE) && (_value <= Long.MAX_VALUE);
-    }
 }
diff --git a/src/main/java/tools/jackson/databind/node/FloatNode.java b/src/main/java/tools/jackson/databind/node/FloatNode.java
index d2af6926c..b8c0609b1 100644
--- a/src/main/java/tools/jackson/databind/node/FloatNode.java
+++ b/src/main/java/tools/jackson/databind/node/FloatNode.java
@@ -2,10 +2,7 @@ package tools.jackson.databind.node;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.Optional;
 import java.util.OptionalDouble;
-import java.util.OptionalInt;
-import java.util.OptionalLong;
 
 import tools.jackson.core.*;
 import tools.jackson.core.io.NumberOutput;
@@ -15,7 +12,8 @@ import tools.jackson.databind.SerializationContext;
  * {@code JsonNode} implementation for efficiently containing 32-bit
  * `float` values.
  */
-public class FloatNode extends NumericNode
+public class FloatNode
+    extends NumericFPNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -37,28 +35,15 @@ public class FloatNode extends NumericNode
     /**********************************************************************
      */
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }
-
     @Override
     public JsonParser.NumberType numberType() { return JsonParser.NumberType.FLOAT; }
 
-    @Override
-    public boolean isFloatingPointNumber() { return true; }
-
     @Override
     public boolean isFloat() { return true; }
 
-    @Override public boolean canConvertToInt() {
-        return canConvertToExactIntegral() && _inIntRange();
-    }
-
-    @Override public boolean canConvertToLong() {
-        return canConvertToExactIntegral() && _inLongRange();
-    }
-
     @Override
-    public boolean canConvertToExactIntegral() {
-        return !isNaN() && !_hasFractionalPart();
+    public boolean isNaN() {
+        return NumberOutput.notFinite(_value);
     }
 
     /*
@@ -78,106 +63,95 @@ public class FloatNode extends NumericNode
     }
 
     @Override
-    public short shortValue() {
-        if (!_inShortRange()) {
-            _reportShortCoercionRangeFail("shortValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportShortCoercionFractionFail("shortValue()");
-        }
-        return (short) _value;
+    public float floatValue() {
+        return _value;
     }
 
     @Override
-    public int intValue() {
-        if (!_inIntRange()) {
-            _reportIntCoercionRangeFail("intValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportIntCoercionFractionFail("intValue()");
-        }
-        return (int) _value;
+    public double doubleValue() {
+        return _value;
     }
 
     @Override
-    public int intValue(int defaultValue) {
-        if (!_inIntRange() || _hasFractionalPart()) {
-             return defaultValue;
-        }
-        return (int) _value;
+    public double doubleValue(double defaultValue) {
+        return _value;
     }
 
     @Override
-    public OptionalInt intValueOpt() {
-        if (!_inIntRange() || _hasFractionalPart()) {
-            return OptionalInt.empty();
-       }
-       return OptionalInt.of((int) _value);
+    public OptionalDouble doubleValueOpt() {
+        return OptionalDouble.of(_value);
     }
 
     @Override
-    public long longValue() {
-        if (!_inLongRange()) {
-            _reportLongCoercionRangeFail("longValue()");
-        }
-        if (_hasFractionalPart()) {
-            _reportLongCoercionFractionFail("longValue()");
-        }
-        return (long) _value;
+    public double asDouble() {
+        return _value;
     }
 
     @Override
-    public long longValue(long defaultValue) {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return defaultValue;
-       }
-        return (long) _value;
+    public double asDouble(double defaultValue) {
+        return _value;
     }
 
     @Override
-    public OptionalLong longValueOpt() {
-        if (!_inLongRange() || _hasFractionalPart()) {
-            return OptionalLong.empty();
-       }
-       return OptionalLong.of((long) _value);
+    public OptionalDouble asDoubleOpt() {
+        return OptionalDouble.of(_value);
     }
 
+    /*
+    /**********************************************************************
+    /* NumericFPNode abstract method impls
+    /**********************************************************************
+     */
+
     @Override
-    public BigInteger bigIntegerValue() {
-        if (_hasFractionalPart()) {
-            _reportBigIntegerCoercionFractionFail("bigIntegerValue()");
-        }
-        return decimalValue().toBigInteger();
+    protected short _asShortValueUnchecked() {
+        return (short) _value;
     }
 
     @Override
-    public float floatValue() { return _value; }
-
+    protected int _asIntValueUnchecked() {
+        return (int) _value;
+    }
+    
     @Override
-    public double doubleValue() { return _value; }
+    protected long _asLongValueUnchecked() {
+        return (long) _value;
+    }
 
     @Override
-    public double doubleValue(double defaultValue) { return _value; }
+    protected BigInteger _asBigIntegerValueUnchecked() {
+        return BigDecimal.valueOf(_value).toBigInteger();
+    }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        return OptionalDouble.of(_value);
+    protected BigDecimal _asDecimalValueUnchecked() {
+        return BigDecimal.valueOf(_value);
     }
 
     @Override
-    public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }
+    protected boolean _hasFractionalPart() { return _value != Math.round(_value); }
 
     @Override
-    public BigDecimal decimalValue(BigDecimal defaultValue) { return decimalValue(); }
+    protected boolean _inShortRange() {
+        return !isNaN() && (_value >= Short.MIN_VALUE) && (_value <= Short.MAX_VALUE);
+    }
 
     @Override
-    public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
+    protected boolean _inIntRange() {
+        return !isNaN() && (_value >= Integer.MIN_VALUE) && (_value <= Integer.MAX_VALUE);
+    }
 
     @Override
-    public boolean isNaN() {
-        return NumberOutput.notFinite(_value);
+    protected boolean _inLongRange() {
+        return !isNaN() && (_value >= Long.MIN_VALUE) && (_value <= Long.MAX_VALUE);
     }
 
+    /*
+    /**********************************************************************
+    /* Overrides, other
+    /**********************************************************************
+     */
+    
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
             throws JacksonException {
@@ -202,18 +176,4 @@ public class FloatNode extends NumericNode
     public int hashCode() {
         return Float.floatToIntBits(_value);
     }
-
-    private boolean _hasFractionalPart() { return _value != Math.round(_value); }
-
-    private boolean _inShortRange() {
-        return !isNaN() && (_value >= Short.MIN_VALUE) && (_value <= Short.MAX_VALUE);
-    }
-
-    private boolean _inIntRange() {
-        return !isNaN() && (_value >= Integer.MIN_VALUE) && (_value <= Integer.MAX_VALUE);
-    }
-
-    private boolean _inLongRange() {
-        return !isNaN() && (_value >= Long.MIN_VALUE) && (_value <= Long.MAX_VALUE);
-    }
 }
diff --git a/src/main/java/tools/jackson/databind/node/IntNode.java b/src/main/java/tools/jackson/databind/node/IntNode.java
index 33940fc7d..bdad93867 100644
--- a/src/main/java/tools/jackson/databind/node/IntNode.java
+++ b/src/main/java/tools/jackson/databind/node/IntNode.java
@@ -3,7 +3,6 @@ package tools.jackson.databind.node;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Optional;
-import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
 
@@ -14,7 +13,7 @@ import tools.jackson.databind.SerializationContext;
  * Numeric node that contains simple 32-bit integer values.
  */
 public class IntNode
-    extends NumericNode
+    extends NumericIntNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -56,23 +55,12 @@ public class IntNode
     /**********************************************************************
      */
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }
-
     @Override
     public JsonParser.NumberType numberType() { return JsonParser.NumberType.INT; }
 
-    @Override
-    public boolean isIntegralNumber() { return true; }
-
     @Override
     public boolean isInt() { return true; }
 
-    @Override
-    public boolean isNaN() { return false; }
-    
-    @Override public boolean canConvertToInt() { return true; }
-    @Override public boolean canConvertToLong() { return true; }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, scalar access
@@ -94,14 +82,6 @@ public class IntNode
         return Integer.valueOf(_value);
     }
 
-    @Override
-    public short shortValue() {
-        if (_value >= Short.MIN_VALUE && _value <= Short.MAX_VALUE) {
-            return (short) _value;
-        }
-        return _reportShortCoercionRangeFail("shortValue()");
-    }
-
     @Override
     public int intValue() { return _value; }
 
@@ -113,6 +93,22 @@ public class IntNode
         return OptionalInt.of(_value);
     }
 
+    @Override
+    public int asInt() {
+        return _value;
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        return _value;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        return OptionalInt.of(_value);
+
+    }
+
     @Override
     public long longValue() { return _value; }
 
@@ -125,17 +121,27 @@ public class IntNode
     }
 
     @Override
-    public float floatValue() { return (float) _value; }
+    public long asLong() { return _value; }
 
     @Override
-    public double doubleValue() { return (double) _value; }
+    public long asLong(long defaultValue) { return _value; }
 
     @Override
-    public double doubleValue(double defaultValue) { return _value; }
+    public OptionalLong asLongOpt() {
+        return OptionalLong.of(_value);
+    }
+    
+    @Override
+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        return OptionalDouble.of(_value);
+    public BigInteger bigIntegerValue(BigInteger defaultValue) {
+        return BigInteger.valueOf(_value);
+    }
+
+    @Override
+    public Optional<BigInteger> bigIntegerValueOpt() {
+        return Optional.of(BigInteger.valueOf(_value));
     }
 
     @Override
@@ -147,8 +153,39 @@ public class IntNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
+    /*
+    /**********************************************************************
+    /* Abstract methods impls for NumericIntNode
+    /**********************************************************************
+     */
+
     @Override
-    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
+    protected int _asIntValueUnchecked() {
+        return _value;
+    }
+
+    @Override
+    protected float _asFloatValueUnchecked() {
+        return (float) _value;
+    }
+
+    @Override
+    protected double _asDoubleValueUnchecked() {
+        return (double) _value;
+    }
+
+    @Override
+    protected boolean _inShortRange() {
+        return (_value >= Short.MIN_VALUE && _value <= Short.MAX_VALUE);
+    }
+
+    @Override
+    protected boolean _inIntRange() {
+        return true;
+    }
+
+    @Override
+    protected boolean _inLongRange() { return true; }
 
     /*
     /**********************************************************************
@@ -163,12 +200,6 @@ public class IntNode
         g.writeNumber(_value);
     }
 
-    /*
-    /**********************************************************************
-    /* Overridden standard methods
-    /**********************************************************************
-     */
-    
     @Override
     public boolean equals(Object o)
     {
diff --git a/src/main/java/tools/jackson/databind/node/LongNode.java b/src/main/java/tools/jackson/databind/node/LongNode.java
index 669a46ca6..052375494 100644
--- a/src/main/java/tools/jackson/databind/node/LongNode.java
+++ b/src/main/java/tools/jackson/databind/node/LongNode.java
@@ -3,7 +3,6 @@ package tools.jackson.databind.node;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Optional;
-import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
 
@@ -14,7 +13,7 @@ import tools.jackson.databind.SerializationContext;
  * Numeric node that contains simple 64-bit integer values.
  */
 public class LongNode
-    extends NumericNode
+    extends NumericIntNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -36,26 +35,12 @@ public class LongNode
     /**********************************************************************
      */
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }
-
     @Override
     public JsonParser.NumberType numberType() { return JsonParser.NumberType.LONG; }
-    @Override
-    public boolean isIntegralNumber() { return true; }
 
     @Override
     public boolean isLong() { return true; }
 
-    @Override
-    public boolean isNaN() { return false; }
-
-    @Override
-    public boolean canConvertToInt() {
-        return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE);
-    }
-
-    @Override public boolean canConvertToLong() { return true; }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, scalar access
@@ -77,17 +62,9 @@ public class LongNode
         return Long.valueOf(_value);
     }
 
-    @Override
-    public short shortValue() {
-        if (_value >= Short.MIN_VALUE && _value <= Short.MAX_VALUE) {
-            return (short) _value;
-        }
-        return _reportShortCoercionRangeFail("shortValue()");
-    }
-
     @Override
     public int intValue() {
-        if (canConvertToInt()) {
+        if (_inIntRange()) {
             return (int) _value;
         }
         return _reportIntCoercionRangeFail("intValue()");
@@ -95,12 +72,30 @@ public class LongNode
 
     @Override
     public int intValue(int defaultValue) {
-        return canConvertToInt() ? (int) _value : defaultValue;
+        return _inIntRange() ? (int) _value : defaultValue;
     }
 
     @Override
     public OptionalInt intValueOpt() {
-        return canConvertToInt() ? OptionalInt.of((int) _value) : OptionalInt.empty();
+        return _inIntRange() ? OptionalInt.of((int) _value) : OptionalInt.empty();
+    }
+
+    @Override
+    public int asInt() {
+        if (_inIntRange()) {
+            return (int) _value;
+        }
+        return _reportIntCoercionRangeFail("asInt()");
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        return _inIntRange() ? (int) _value : defaultValue;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        return _inIntRange() ? OptionalInt.of((int) _value) : OptionalInt.empty();
     }
 
     @Override
@@ -115,20 +110,27 @@ public class LongNode
     }
 
     @Override
-    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
+    public long asLong() { return _value; }
+
+    @Override
+    public long asLong(long defaultValue) { return _value; }
 
     @Override
-    public float floatValue() { return _value; }
+    public OptionalLong asLongOpt() {
+        return OptionalLong.of(_value);
+    }
 
     @Override
-    public double doubleValue() { return _value; }
+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public double doubleValue(double defaultValue) { return _value; }
+    public BigInteger bigIntegerValue(BigInteger defaultValue) {
+        return BigInteger.valueOf(_value);
+    }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        return OptionalDouble.of(_value);
+    public Optional<BigInteger> bigIntegerValueOpt() {
+        return Optional.of(BigInteger.valueOf(_value));
     }
 
     @Override
@@ -140,6 +142,40 @@ public class LongNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
+    /*
+    /**********************************************************************
+    /* Abstract methods impls for NumericIntNode
+    /**********************************************************************
+     */
+
+    @Override
+    protected int _asIntValueUnchecked() {
+        return (int) _value;
+    }
+
+    @Override
+    protected float _asFloatValueUnchecked() {
+        return (float) _value;
+    }
+
+    @Override
+    protected double _asDoubleValueUnchecked() {
+        return (double) _value;
+    }
+
+    @Override
+    protected boolean _inShortRange() {
+        return (_value >= Short.MIN_VALUE && _value <= Short.MAX_VALUE);
+    }
+
+    @Override
+    protected boolean _inIntRange() {
+        return (_value >= Integer.MIN_VALUE) && (_value <= Integer.MAX_VALUE);
+    }
+
+    @Override
+    protected boolean _inLongRange() { return true; }
+    
     /*
     /**********************************************************************
     /* Overridden methods, other
diff --git a/src/main/java/tools/jackson/databind/node/NullNode.java b/src/main/java/tools/jackson/databind/node/NullNode.java
index 01efb194b..0c9fc04a8 100644
--- a/src/main/java/tools/jackson/databind/node/NullNode.java
+++ b/src/main/java/tools/jackson/databind/node/NullNode.java
@@ -1,5 +1,12 @@
 package tools.jackson.databind.node;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+
 import tools.jackson.core.*;
 import tools.jackson.databind.JsonNode;
 import tools.jackson.databind.SerializationContext;
@@ -38,7 +45,7 @@ public class NullNode
 
     /*
     /**********************************************************************
-    /* Overridden JsonNode methods, scalar access
+    /* Overridden JsonNode methods, scalar access, non-numeric
     /**********************************************************************
      */
 
@@ -52,18 +59,92 @@ public class NullNode
         return "";
     }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access, numeric
+    /**********************************************************************
+     */
+
+    // `intValue()` (etc) fine as defaults (fail); but need to override `asInt()`
+
     @Override
-    protected String _valueDesc() {
-        return "<null>";
+    public int asInt() {
+        return 0;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
-    public JsonNode requireNonNull() {
-        return _reportRequiredViolation("requireNonNull() called on `NullNode`");
+    public int asInt(int defaultValue) {
+        return 0;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        return OptionalInt.of(0);
+    }
+
+    // `longValue()` (etc) fine as defaults (fail); but need to override `asLong()`
+
+    @Override
+    public long asLong() { return 0L; }
+
+    @Override
+    public long asLong(long defaultValue) { return 0L; }
+
+    @Override
+    public OptionalLong asLongOpt() {
+        return OptionalLong.of(0L);
+    }
+
+    // `bigIntegerValue()` (etc) fine as defaults (fail); but need to override `asBigInteger()`
+
+    @Override
+    public BigInteger asBigInteger() {
+        return BigInteger.ZERO;
+    }
+
+    @Override
+    public BigInteger asBigInteger(BigInteger defaultValue) {
+        return asBigInteger();
+    }
+
+    @Override
+    public Optional<BigInteger> asBigIntegerOpt() {
+        return Optional.of(asBigInteger());
     }
 
-    // as with MissingNode, not considered number node; hence defaults are returned if provided
+    // `doubleValue()` (etc) fine as defaults (fail); but need to override `asDouble()`
+
+    @Override
+    public double asDouble() {
+        return 0.0d;
+    }
+
+    @Override
+    public double asDouble(double defaultValue) {
+        return asDouble();
+    }
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        return OptionalDouble.of(asDouble());
+    }
+    
+    // `decimalValue()` (etc) fine as defaults (fail); but need to override `asDecimal()`
+
+    @Override
+    public BigDecimal asDecimal() {
+        return BigDecimal.ZERO;
+    }
+
+    @Override
+    public BigDecimal asDecimal(BigDecimal defaultValue) {
+        return asDecimal();
+    }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        return Optional.of(asDecimal());
+    }
 
     /*
     public int asInt(int defaultValue);
@@ -72,6 +153,23 @@ public class NullNode
     public boolean asBoolean(boolean defaultValue);
     */
 
+    /*
+    /**********************************************************************
+    /* Overridden methods, other
+    /**********************************************************************
+     */
+
+    @Override
+    protected String _valueDesc() {
+        return "<null>";
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public JsonNode requireNonNull() {
+        return _reportRequiredViolation("requireNonNull() called on `NullNode`");
+    }
+    
     @Override
     public final void serialize(JsonGenerator g, SerializationContext provider)
         throws JacksonException
diff --git a/src/main/java/tools/jackson/databind/node/NumericFPNode.java b/src/main/java/tools/jackson/databind/node/NumericFPNode.java
new file mode 100644
index 000000000..ac2346e73
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/node/NumericFPNode.java
@@ -0,0 +1,333 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Optional;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+
+import tools.jackson.core.JsonToken;
+
+/**
+ * Intermediate node class used for numeric nodes that contain
+ * floating-point values: provides partial implementation of common
+ * methods.
+ */
+public abstract class NumericFPNode extends NumericNode
+{
+    private static final long serialVersionUID = 3L;
+
+    /*
+    /**********************************************************************
+    /* Partial implementation of basic metadata/type accessors
+    /**********************************************************************
+     */
+    
+    @Override
+    public final JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }
+
+    @Override
+    public final boolean isFloatingPointNumber() { return true; }
+
+    @Override
+    public final boolean canConvertToInt() {
+        return canConvertToExactIntegral() && _inIntRange();
+    }
+
+    @Override
+    public final boolean canConvertToLong() {
+        return canConvertToExactIntegral() && _inLongRange();
+    }
+
+    @Override
+    public final boolean canConvertToExactIntegral() {
+        return !isNaN() && !_hasFractionalPart();
+    }
+
+    /*
+    /**********************************************************************
+    /* Partial implementation of numeric accessors
+    /**********************************************************************
+     */
+
+    // // // Integer value accessors
+
+    @Override
+    public final short shortValue() {
+        if (!_inShortRange()) {
+            return _reportShortCoercionRangeFail("shortValue()");
+        }
+        if (_hasFractionalPart()) {
+            _reportShortCoercionFractionFail("shortValue()");
+        }
+        return _asShortValueUnchecked();
+    }
+
+    @Override
+    public final int intValue() {
+        if (!_inIntRange()) {
+            if (isNaN()) {
+                _reportIntCoercionNaNFail("intValue()");
+            }
+            return _reportIntCoercionRangeFail("intValue()");
+        }
+        if (_hasFractionalPart()) {
+            _reportIntCoercionFractionFail("intValue()");
+        }
+        return _asIntValueUnchecked();
+    }
+
+    @Override
+    public final int intValue(int defaultValue) {
+        if (!_inIntRange() || _hasFractionalPart()) {
+             return defaultValue;
+        }
+        return _asIntValueUnchecked();
+    }
+
+    @Override
+    public final OptionalInt intValueOpt() {
+        if (!_inIntRange() || _hasFractionalPart()) {
+            return OptionalInt.empty();
+       }
+       return OptionalInt.of(_asIntValueUnchecked());
+    }
+
+    @Override
+    public int asInt() {
+        if (!_inIntRange()) {
+            if (isNaN()) {
+                _reportIntCoercionNaNFail("asInt()");
+            }
+            return _reportIntCoercionRangeFail("asInt()");
+        }
+        return _asIntValueUnchecked();
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        if (!_inIntRange()) {
+            return defaultValue;
+        }
+        return _asIntValueUnchecked();
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        if (!_inIntRange()) {
+            return OptionalInt.empty();
+        }
+        return OptionalInt.of(_asIntValueUnchecked());
+    }
+
+    @Override
+    public final long longValue() {
+        if (!_inLongRange()) {
+            if (isNaN()) {
+                _reportLongCoercionNaNFail("longValue()");
+            }
+            return _reportLongCoercionRangeFail("longValue()");
+        }
+        if (_hasFractionalPart()) {
+            _reportLongCoercionFractionFail("longValue()");
+        }
+        return _asLongValueUnchecked();
+    }
+
+    @Override
+    public final long longValue(long defaultValue) {
+        if (!_inLongRange() || _hasFractionalPart()) {
+            return defaultValue;
+        }
+        return _asLongValueUnchecked();
+    }
+
+    @Override
+    public final OptionalLong longValueOpt() {
+        if (!_inLongRange() || _hasFractionalPart()) {
+            return OptionalLong.empty();
+        }
+        return OptionalLong.of(_asLongValueUnchecked());
+    }
+
+    @Override
+    public final long asLong() {
+        if (!_inLongRange()) {
+            if (isNaN()) {
+                _reportLongCoercionNaNFail("asLong()");
+            }
+            return _reportLongCoercionRangeFail("asLong()");
+        }
+        return _asLongValueUnchecked();
+    }
+
+    @Override
+    public final long asLong(long defaultValue) {
+        if (!_inLongRange()) {
+            return defaultValue;
+        }
+        return _asLongValueUnchecked();
+    }
+
+    @Override
+    public final OptionalLong asLongOpt() {
+        if (!_inLongRange()) {
+            return OptionalLong.empty();
+        }
+        return OptionalLong.of(_asLongValueUnchecked());
+    }
+
+    @Override
+    public final BigInteger bigIntegerValue() {
+        if (isNaN()) {
+            _reportBigIntegerCoercionNaNFail("bigIntegerValue()");
+        }
+        if (_hasFractionalPart()) {
+            _reportBigIntegerCoercionFractionFail("bigIntegerValue()");
+        }
+        return _asBigIntegerValueUnchecked();
+    }
+
+    @Override
+    public final BigInteger bigIntegerValue(BigInteger defaultValue) {
+        if (isNaN() || _hasFractionalPart()) {
+            return defaultValue;
+        }
+        return _asBigIntegerValueUnchecked();
+    }
+
+    @Override
+    public final Optional<BigInteger> bigIntegerValueOpt() {
+        if (isNaN() || _hasFractionalPart()) {
+            return Optional.empty();
+        }
+        return Optional.of(_asBigIntegerValueUnchecked());
+    }
+
+    @Override
+    public final BigInteger asBigInteger() {
+        if (isNaN()) {
+            _reportBigIntegerCoercionNaNFail("asBigInteger()");
+        }
+        return _asBigIntegerValueUnchecked();
+    }
+
+    @Override
+    public final BigInteger asBigInteger(BigInteger defaultValue) {
+        if (isNaN()) {
+            return defaultValue;
+        }
+        return _asBigIntegerValueUnchecked();
+    }
+
+    @Override
+    public final Optional<BigInteger> asBigIntegerOpt() {
+        if (isNaN()) {
+            return Optional.empty();
+        }
+        return Optional.of(_asBigIntegerValueUnchecked());
+    }
+
+    // // // FP value accessors
+    
+    @Override
+    public BigDecimal decimalValue() {
+        if (isNaN()) {
+            _reportBigDecimalCoercionNaNFail("decimalValue()");
+        }
+        return _asDecimalValueUnchecked();
+    }
+
+    @Override
+    public BigDecimal decimalValue(BigDecimal defaultValue) {
+        if (isNaN()) {
+            return defaultValue;
+        }
+        return _asDecimalValueUnchecked();
+    }
+
+    @Override
+    public Optional<BigDecimal> decimalValueOpt() {
+        if (isNaN()) {
+            return Optional.empty();
+        }
+        return Optional.of(_asDecimalValueUnchecked());
+    }
+
+    @Override
+    public BigDecimal asDecimal() {
+        if (isNaN()) {
+            _reportBigDecimalCoercionNaNFail("asDecimal()");
+        }
+        return _asDecimalValueUnchecked();
+    }
+    
+    @Override
+    public BigDecimal asDecimal(BigDecimal defaultValue) {
+        if (isNaN()) {
+            return defaultValue;
+        }
+        return _asDecimalValueUnchecked();
+    }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        if (isNaN()) {
+            return Optional.empty();
+        }
+        return Optional.of(_asDecimalValueUnchecked());
+    }
+
+    /*
+    /**********************************************************************
+    /* Abstract methods for sub-classes to implement
+    /**********************************************************************
+     */
+
+    /**
+     * Method for sub-classes to implement; returns the underlying
+     * value as a {@code short} without any checks (wrt NaN or value range),
+     * so caller must ensure validity prior to calling
+     */
+    protected abstract short _asShortValueUnchecked();
+    
+    /**
+     * Method for sub-classes to implement; returns the underlying
+     * value as a {@code int} without any checks (wrt NaN or value range),
+     * so caller must ensure validity prior to calling
+     */
+    protected abstract int _asIntValueUnchecked();
+
+    /**
+     * Method for sub-classes to implement; returns the underlying
+     * value as a {@code long} without any checks (wrt NaN or value range),
+     * so caller must ensure validity prior to calling
+     */
+    protected abstract long _asLongValueUnchecked();
+
+    /**
+     * Method for sub-classes to implement; returns the underlying
+     * value as a {@link BigInteger} without any checks (wrt NaN), so caller
+     * must ensure validity prior to calling
+     */
+    protected abstract BigInteger _asBigIntegerValueUnchecked();
+
+    // NOTE: we do not need these ones (not enough commonality):
+    //protected abstract float _asFloatValueUnchecked();
+    //protected abstract double _asDoubleValueUnchecked();
+
+    /**
+     * Method for sub-classes to implement; returns the underlying
+     * value as a {@link BigDecimal} without any checks (wrt NaN), so caller
+     * must ensure validity prior to calling
+     */
+    protected abstract BigDecimal _asDecimalValueUnchecked();
+
+    protected abstract boolean _hasFractionalPart();
+
+    protected abstract boolean _inShortRange();
+
+    protected abstract boolean _inIntRange();
+
+    protected abstract boolean _inLongRange();
+}
diff --git a/src/main/java/tools/jackson/databind/node/NumericIntNode.java b/src/main/java/tools/jackson/databind/node/NumericIntNode.java
new file mode 100644
index 000000000..36eb3375f
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/node/NumericIntNode.java
@@ -0,0 +1,166 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Optional;
+import java.util.OptionalDouble;
+
+import tools.jackson.core.JsonToken;
+
+/**
+ * Intermediate node class used for numeric nodes that contain
+ * integral values: provides partial implementation of common
+ * methods.
+ */
+public abstract class NumericIntNode extends NumericNode
+{
+    private static final long serialVersionUID = 3L;
+
+    /*
+    /**********************************************************************
+    /* Partial implementation of basic metadata/type accessors
+    /**********************************************************************
+     */
+    
+    @Override
+    public final JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }
+
+    @Override
+    public final boolean isIntegralNumber() { return true; }
+
+    @Override
+    public final boolean isNaN() { return false; }
+
+    @Override final
+    public boolean canConvertToInt() {
+        return _inIntRange();
+    }
+
+    @Override final
+    public boolean canConvertToLong() {
+        return _inLongRange();
+    }
+
+    /*
+    /**********************************************************************
+    /* Partial implementation of numeric accessors
+    /**********************************************************************
+     */
+
+    @Override
+    public short shortValue() {
+        if (_inShortRange()) {
+            return (short) _asIntValueUnchecked();
+        }
+        return _reportShortCoercionRangeFail("shortValue()");
+    }
+
+    // Sub-classes need to define this; but with that can implement other 5 methods
+
+    @Override
+    public abstract BigInteger bigIntegerValue();
+
+    @Override
+    public BigInteger bigIntegerValue(BigInteger defaultValue) {
+        return bigIntegerValue();
+    }
+
+    @Override
+    public Optional<BigInteger> bigIntegerValueOpt() {
+        return Optional.of(bigIntegerValue());
+    }
+
+    @Override
+    public BigInteger asBigInteger() {
+        return bigIntegerValue();
+    }
+
+    @Override
+    public BigInteger asBigInteger(BigInteger defaultValue) {
+        return bigIntegerValue();
+    }
+
+    @Override
+    public Optional<BigInteger> asBigIntegerOpt() {
+        return bigIntegerValueOpt();
+    }
+
+    // Float is simple
+
+    @Override
+    public float floatValue() {
+        return _asFloatValueUnchecked();
+    }
+
+    // Double handling straight-forward for all Integral types except BigInteger
+    // (which needs range checks and overrides these implementations)
+
+    @Override
+    public double doubleValue() {
+        return _asDoubleValueUnchecked();
+    }
+
+    @Override
+    public double doubleValue(double defaultValue) {
+        return _asDoubleValueUnchecked();
+    }
+
+    @Override
+    public OptionalDouble doubleValueOpt() {
+        return OptionalDouble.of(_asDoubleValueUnchecked());
+    }
+
+    @Override
+    public double asDouble() {
+        return _asDoubleValueUnchecked();
+    }
+
+    @Override
+    public double asDouble(double defaultValue) {
+        return _asDoubleValueUnchecked();
+    }
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        return OptionalDouble.of(_asDoubleValueUnchecked());
+    }
+
+    // Sub-classes need to define this; but with that can implement other 5 methods
+    //
+    // public BigDecimal decimalValue()
+
+    @Override
+    public BigDecimal decimalValue(BigDecimal defaultValue) { return decimalValue(); }
+
+    @Override
+    public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
+
+    @Override
+    public BigDecimal asDecimal() { return decimalValue(); }
+    
+    @Override
+    public BigDecimal asDecimal(BigDecimal defaultValue) { return decimalValue(); }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        return decimalValueOpt();
+    }
+
+    /*
+    /**********************************************************************
+    /* Abstract methods for sub-classes
+    /**********************************************************************
+     */
+
+    protected abstract int _asIntValueUnchecked();
+    
+    protected abstract float _asFloatValueUnchecked();
+
+    protected abstract double _asDoubleValueUnchecked();
+
+    protected abstract boolean _inShortRange();
+
+    protected abstract boolean _inIntRange();
+
+    protected abstract boolean _inLongRange();
+}
diff --git a/src/main/java/tools/jackson/databind/node/NumericNode.java b/src/main/java/tools/jackson/databind/node/NumericNode.java
index 163731a1b..ef01df0c0 100644
--- a/src/main/java/tools/jackson/databind/node/NumericNode.java
+++ b/src/main/java/tools/jackson/databind/node/NumericNode.java
@@ -46,23 +46,39 @@ public abstract class NumericNode
     @Override public abstract int intValue();
     @Override public abstract int intValue(int defaultValue);
     @Override public abstract OptionalInt intValueOpt();
+    @Override public abstract int asInt();
+    @Override public abstract int asInt(int defaultValue);
+    @Override public abstract OptionalInt asIntOpt();
 
     @Override public abstract long longValue();
     @Override public abstract long longValue(long defaultValue);
     @Override public abstract OptionalLong longValueOpt();
+    @Override public abstract long asLong();
+    @Override public abstract long asLong(long defaultValue);
+    @Override public abstract OptionalLong asLongOpt();
 
     @Override public abstract BigInteger bigIntegerValue();
+    @Override public abstract BigInteger bigIntegerValue(BigInteger defaultValue);
+    @Override public abstract Optional<BigInteger> bigIntegerValueOpt();
+    @Override public abstract BigInteger asBigInteger();
+    @Override public abstract BigInteger asBigInteger(BigInteger defaultValue);
+    @Override public abstract Optional<BigInteger> asBigIntegerOpt();
 
     @Override public abstract float floatValue();
 
     @Override public abstract double doubleValue();
     @Override public abstract double doubleValue(double defaultValue);
     @Override public abstract OptionalDouble doubleValueOpt();
+    @Override public abstract double asDouble();
+    @Override public abstract double asDouble(double defaultValue);
+    @Override public abstract OptionalDouble asDoubleOpt();
 
     @Override public abstract BigDecimal decimalValue();
-
     @Override public abstract BigDecimal decimalValue(BigDecimal defaultValue);
     @Override public abstract Optional<BigDecimal> decimalValueOpt();
+    @Override public abstract BigDecimal asDecimal();
+    @Override public abstract BigDecimal asDecimal(BigDecimal defaultValue);
+    @Override public abstract Optional<BigDecimal> asDecimalOpt();
 
     @Override public abstract boolean canConvertToInt();
     @Override public abstract boolean canConvertToLong();
@@ -76,36 +92,6 @@ public abstract class NumericNode
     @Override
     protected abstract String _asString();
 
-    @Override
-    public final int asInt() {
-        return intValue();
-    }
-
-    @Override
-    public final int asInt(int defaultValue) {
-        return intValue();
-    }
-
-    @Override
-    public final long asLong() {
-        return longValue();
-    }
-
-    @Override
-    public final long asLong(long defaultValue) {
-        return longValue();
-    }
-
-    @Override
-    public final double asDouble() {
-        return doubleValue();
-    }
-
-    @Override
-    public final double asDouble(double defaultValue) {
-        return doubleValue();
-    }
-
     /*
     /**********************************************************************
     /* Other
@@ -116,8 +102,6 @@ public abstract class NumericNode
      * Convenience method for checking whether this node is a
      * {@link FloatNode} or {@link DoubleNode} that contains
      * "not-a-number" (NaN) value.
-     *
-     * @since 2.9
      */
     public abstract boolean isNaN();
 }
diff --git a/src/main/java/tools/jackson/databind/node/POJONode.java b/src/main/java/tools/jackson/databind/node/POJONode.java
index 5d56a687d..64a512c3e 100644
--- a/src/main/java/tools/jackson/databind/node/POJONode.java
+++ b/src/main/java/tools/jackson/databind/node/POJONode.java
@@ -1,6 +1,12 @@
 package tools.jackson.databind.node;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Objects;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 
 import tools.jackson.core.*;
 
@@ -39,14 +45,14 @@ public class POJONode
     }
 
     @Override
-    public boolean isEmbeddedValue() { return true; }
+    public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }
 
     @Override
-    public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }
+    public boolean isEmbeddedValue() { return true; }
 
     /*
     /**********************************************************************
-    /* General type coercions
+    /* Overridden JsonNode methods, scalar access, non-numeric
     /**********************************************************************
      */
 
@@ -72,47 +78,224 @@ public class POJONode
         return null;
     }
 
+    /**
+     * As it is possible that some implementations embed byte[] as POJONode
+     * (despite optimal being {@link BinaryNode}), let's add support for exposing
+     * binary data here too.
+     */
     @Override
-    public int asInt(int defaultValue)
+    public byte[] binaryValue()
     {
-        if (_value instanceof Number) {
-            return ((Number) _value).intValue();
+        if (_value instanceof byte[]) {
+            return (byte[]) _value;
         }
-        return defaultValue;
+        return super.binaryValue();
+    }
+
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access, numeric
+    /**********************************************************************
+     */
+    
+    // `intValue()` (etc) fine as defaults (fail); but need to override `asInt()`
+
+    @Override
+    public int asInt() {
+        Integer I = _extractAsInteger();
+        return (I == null) ? super.asInt() : I;
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        Integer I = _extractAsInteger();
+        return (I == null) ? defaultValue : I;
     }
 
     @Override
-    public long asLong(long defaultValue)
+    public OptionalInt asIntOpt() {
+        Integer I = _extractAsInteger();
+        return (I == null) ? OptionalInt.empty() : OptionalInt.of(I);
+    }
+
+    // `longValue()` (etc) fine as defaults (fail); but need to override `asLong()`
+
+    @Override
+    public long asLong() {
+        Long L = _extractAsLong();
+        return (L == null) ? super.asLong() : L;
+    }
+
+    @Override
+    public long asLong(long defaultValue) {
+        Long L = _extractAsLong();
+        return (L == null) ? defaultValue : L;
+    }
+
+    @Override
+    public OptionalLong asLongOpt() {
+        Long L = _extractAsLong();
+        return (L == null) ? OptionalLong.empty() : OptionalLong.of(L);
+    }
+
+    // `bigIntegerValue()` (etc) fine as defaults (fail); but need to override `asBigInteger()`
+
+    @Override
+    public BigInteger asBigInteger() {
+        BigInteger big = _extractAsBigInteger();
+        return (big == null) ? super.asBigInteger() : big;
+    }
+
+    @Override
+    public BigInteger asBigInteger(BigInteger defaultValue) {
+        BigInteger big = _extractAsBigInteger();
+        return (big == null) ? defaultValue : big;
+    }
+
+    @Override
+    public Optional<BigInteger> asBigIntegerOpt() {
+        BigInteger big = _extractAsBigInteger();
+        return (big == null) ? Optional.empty() : Optional.of(big);
+    }
+
+    // `doubleValue()` (etc) fine as defaults (fail); but need to override `asDouble()`
+
+    @Override
+    public double asDouble()
     {
-        if (_value instanceof Number) {
-            return ((Number) _value).longValue();
-        }
-        return defaultValue;
+        Double d = _extractAsDouble();
+        return (d == null) ? super.asDouble() : d;
     }
 
     @Override
     public double asDouble(double defaultValue)
     {
-        if (_value instanceof Number) {
-            return ((Number) _value).doubleValue();
+        Double d = _extractAsDouble();
+        return (d == null) ? defaultValue : d;
+    }
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        Double d = _extractAsDouble();
+        return (d == null) ? OptionalDouble.empty() : OptionalDouble.of(d);
+    }
+
+    // `decimalValue()` (etc) fine as defaults (fail); but need to override `asDecimal()`
+
+    @Override
+    public BigDecimal asDecimal() {
+        BigDecimal dec = _extractAsBigDecimal();
+        if (dec == null) {
+            return super.asDecimal();
         }
-        return defaultValue;
+        return dec;
     }
 
-    /**
-     * As it is possible that some implementations embed byte[] as POJONode
-     * (despite optimal being {@link BinaryNode}), let's add support for exposing
-     * binary data here too.
-     */
     @Override
-    public byte[] binaryValue()
-    {
-        if (_value instanceof byte[]) {
-            return (byte[]) _value;
+    public BigDecimal asDecimal(BigDecimal defaultValue) {
+        BigDecimal dec = _extractAsBigDecimal();
+        if (dec == null) {
+            return defaultValue;
         }
-        return super.binaryValue();
+        return dec;
+    }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        BigDecimal dec = _extractAsBigDecimal();
+        return (dec == null) ? Optional.empty() : Optional.of(dec);
     }
 
+    // Consider only Integral numbers
+    protected Integer _extractAsInteger() {
+        // First, `null` same as `NullNode`
+        if (_value == null) {
+            return 0;
+        }
+        // Next, coercions from integral Numbers
+        if (_value instanceof Number N) {
+            // !!! TODO: range checks
+            if (N instanceof Long || N instanceof Integer || N instanceof Short || N instanceof Byte
+                    || N instanceof BigInteger) {
+                return N.intValue();
+            }
+        }
+        return null;
+    }
+
+    // Consider only Integral numbers
+    protected Long _extractAsLong() {
+        // First, `null` same as `NullNode`
+        if (_value == null) {
+            return 0L;
+        }
+        // Next, coercions from integral Numbers
+        if (_value instanceof Number N) {
+            // !!! TODO: range checks
+            if (N instanceof Long || N instanceof Integer || N instanceof Short || N instanceof Byte
+                    || N instanceof BigInteger) {
+                return N.longValue();
+            }
+        }
+        return null;
+    }
+
+    // Consider only Integral numbers
+    protected BigInteger _extractAsBigInteger() {
+        // First, `null` same as `NullNode`
+        if (_value == null) {
+            return BigInteger.ZERO;
+        }
+        // Next, coercions from Numbers
+        if (_value instanceof BigInteger big) {
+            return big;
+        }
+        if (_value instanceof Number N) {
+            if (N instanceof Long || N instanceof Integer || N instanceof Short || N instanceof Byte) {
+                return BigInteger.valueOf(N.longValue());
+            }
+        }
+        return null;
+    }
+
+    protected Double _extractAsDouble() {
+        if (_value instanceof Number N) {
+            if (_value instanceof Double D) {
+                return D;
+            }
+            // 24-Mar-2025, tatu: Should probably check for NaN from overflow
+            //    from "too big" `BigDecimal` or `BigInteger`. But will do for now
+            return N.doubleValue();
+        }
+        return null;
+    }
+    
+    protected BigDecimal _extractAsBigDecimal() {
+        // First, `null` same as `NullNode`
+        if (_value == null) {
+            return BigDecimal.ZERO;
+        }
+        // Next, coercions from Numbers
+        if (_value instanceof BigDecimal dec) {
+            return dec;
+        }
+        if (_value instanceof BigInteger I) {
+            return new BigDecimal(I);
+        }
+        if (_value instanceof Number N) {
+            if (N instanceof Long || N instanceof Integer || N instanceof Short || N instanceof Byte) {
+                return BigDecimal.valueOf(N.longValue());
+            }
+            // Use doubleValue() as a last resort for Float & Double
+            try {
+                return BigDecimal.valueOf(N.doubleValue());
+            } catch (IllegalArgumentException e) {
+                // got an NaN
+            }
+        }
+        return null;
+    }
+    
     /*
     /**********************************************************************
     /* Public API, serialization
diff --git a/src/main/java/tools/jackson/databind/node/ShortNode.java b/src/main/java/tools/jackson/databind/node/ShortNode.java
index 4164f94e5..9569751b7 100644
--- a/src/main/java/tools/jackson/databind/node/ShortNode.java
+++ b/src/main/java/tools/jackson/databind/node/ShortNode.java
@@ -3,7 +3,6 @@ package tools.jackson.databind.node;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Optional;
-import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
 
@@ -14,7 +13,7 @@ import tools.jackson.databind.SerializationContext;
  * Numeric node that contains simple 16-bit integer values.
  */
 public class ShortNode
-    extends NumericNode
+    extends NumericIntNode
 {
     private static final long serialVersionUID = 3L;
 
@@ -36,26 +35,15 @@ public class ShortNode
     /**********************************************************************
      */
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }
-
     @Override
     public JsonParser.NumberType numberType() {
         // No SHORT enum so
         return JsonParser.NumberType.INT;
     }
-
-    @Override
-    public boolean isIntegralNumber() { return true; }
-
-    @Override
-    public boolean isNaN() { return false; }
     
     @Override
     public boolean isShort() { return true; }
 
-    @Override public boolean canConvertToInt() { return true; }
-    @Override public boolean canConvertToLong() { return true; }
-
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, scalar access
@@ -77,6 +65,7 @@ public class ShortNode
         return Short.valueOf(_value);
     }
 
+    // Overridden as minor performance optimization
     @Override
     public short shortValue() { return _value; }
 
@@ -91,6 +80,22 @@ public class ShortNode
         return OptionalInt.of(_value);
     }
 
+    @Override
+    public int asInt() {
+        return _value;
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        return _value;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        return OptionalInt.of(_value);
+
+    }
+
     @Override
     public long longValue() { return _value; }
 
@@ -103,20 +108,27 @@ public class ShortNode
     }
 
     @Override
-    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
+    public long asLong() { return _value; }
 
     @Override
-    public float floatValue() { return _value; }
+    public long asLong(long defaultValue) { return _value; }
 
     @Override
-    public double doubleValue() { return _value; }
+    public OptionalLong asLongOpt() {
+        return OptionalLong.of(_value);
+    }
 
     @Override
-    public double doubleValue(double defaultValue) { return _value; }
+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }
 
     @Override
-    public OptionalDouble doubleValueOpt() {
-        return OptionalDouble.of(_value);
+    public BigInteger bigIntegerValue(BigInteger defaultValue) {
+        return BigInteger.valueOf(_value);
+    }
+
+    @Override
+    public Optional<BigInteger> bigIntegerValueOpt() {
+        return Optional.of(BigInteger.valueOf(_value));
     }
 
     @Override
@@ -128,6 +140,36 @@ public class ShortNode
     @Override
     public Optional<BigDecimal> decimalValueOpt() { return Optional.of(decimalValue()); }
 
+    /*
+    /**********************************************************************
+    /* Abstract methods impls for NumericIntNode
+    /**********************************************************************
+     */
+
+    @Override
+    protected int _asIntValueUnchecked() {
+        return _value;
+    }
+
+    @Override
+    protected float _asFloatValueUnchecked() {
+        return (float) _value;
+    }
+
+    @Override
+    protected double _asDoubleValueUnchecked() {
+        return (double) _value;
+    }
+
+    @Override
+    protected boolean _inShortRange() { return true; }
+
+    @Override
+    protected boolean _inIntRange() { return true; }
+
+    @Override
+    protected boolean _inLongRange() { return true; }
+    
     /*
     /**********************************************************************
     /* Overridden JsonNode methods, other
diff --git a/src/main/java/tools/jackson/databind/node/StringNode.java b/src/main/java/tools/jackson/databind/node/StringNode.java
index 660f67393..a0549d9ff 100644
--- a/src/main/java/tools/jackson/databind/node/StringNode.java
+++ b/src/main/java/tools/jackson/databind/node/StringNode.java
@@ -1,7 +1,12 @@
 package tools.jackson.databind.node;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 
 import tools.jackson.core.*;
 import tools.jackson.core.io.NumberInput;
@@ -51,7 +56,8 @@ public class StringNode
         return JsonNodeType.STRING;
     }
 
-    @Override public JsonToken asToken() { return JsonToken.VALUE_STRING; }
+    @Override
+    public JsonToken asToken() { return JsonToken.VALUE_STRING; }
 
     @Override
     protected String _valueDesc() {
@@ -67,7 +73,7 @@ public class StringNode
 
     /*
     /**********************************************************************
-    /* Overridden JsonNode methods, scalar access
+    /* Overridden JsonNode methods, scalar access, non-numeric
     /**********************************************************************
      */
 
@@ -119,21 +125,6 @@ public class StringNode
         return Optional.of(_value);
     }
 
-    @Override
-    public int asInt(int defaultValue) {
-        return NumberInput.parseAsInt(_value, defaultValue);
-    }
-
-    @Override
-    public long asLong(long defaultValue) {
-        return NumberInput.parseAsLong(_value, defaultValue);
-    }
-
-    @Override
-    public double asDouble(double defaultValue) {
-        return NumberInput.parseAsDouble(_value, defaultValue, false);
-    }
-
     /**
      * Method for accessing content String assuming they were
      * base64 encoded; if so, content is decoded and resulting binary
@@ -166,6 +157,186 @@ public class StringNode
         return getBinaryValue(Base64Variants.getDefaultVariant());
     }
 
+    /*
+    /**********************************************************************
+    /* Overridden JsonNode methods, scalar access, numeric
+    /**********************************************************************
+     */
+
+    @Override
+    public int asInt() {
+        Integer I = _tryParseAsInteger();
+        if (I == null) {
+            return _reportCoercionFail("asInt()", Integer.TYPE,
+                    "value not a valid String representation of `int`");
+        }
+        return I.intValue();
+    }
+
+    @Override
+    public int asInt(int defaultValue) {
+        Integer I = _tryParseAsInteger();
+        return (I == null) ? defaultValue : I;
+    }
+
+    @Override
+    public OptionalInt asIntOpt() {
+        Integer I = _tryParseAsInteger();
+        return (I == null) ? OptionalInt.empty() : OptionalInt.of(I);
+    }
+    
+    @Override
+    public long asLong() {
+        Long L = _tryParseAsLong();
+        if (L == null) {
+            return _reportCoercionFail("asLong()", Long.TYPE,
+                    "value not a valid String representation of `long`");
+        }
+        return L.longValue();
+    }
+
+    @Override
+    public long asLong(long defaultValue) {
+        Long L = _tryParseAsLong();
+        return (L == null) ? defaultValue : L;
+    }
+
+    @Override
+    public OptionalLong asLongOpt() {
+        Long L = _tryParseAsLong();
+        return (L == null) ? OptionalLong.empty() : OptionalLong.of(L);
+    }
+
+    // `bigIntegerValue()` (etc) fine as defaults (fail); but need to override `asBigInteger()`
+
+    @Override
+    public BigInteger asBigInteger() {
+        BigInteger big = _tryParseAsBigInteger();
+        if (big == null) {
+            return _reportCoercionFail("asBigInteger()", BigInteger.class,
+                    "value not a valid String representation of `BigInteger`");
+        }
+        return big;
+    }
+
+    @Override
+    public BigInteger asBigInteger(BigInteger defaultValue) {
+        BigInteger big = _tryParseAsBigInteger();
+        return (big == null) ? defaultValue : big;
+    }
+
+    @Override
+    public Optional<BigInteger> asBigIntegerOpt() {
+        BigInteger big = _tryParseAsBigInteger();
+        return (big == null) ? Optional.empty() : Optional.of(big);
+    }
+
+    // `doubleValue()` (etc) fine as defaults (fail); but need to override `asDouble()`
+
+    @Override
+    public double asDouble()
+    {
+        Double d = _tryParseAsDouble();
+        if (d == null) {
+            return _reportCoercionFail("asDouble()", Double.TYPE,
+                    "value not a valid String representation of `double`");
+        }
+        return (d == null) ? super.asDouble() : d;
+    }
+
+    @Override
+    public double asDouble(double defaultValue)
+    {
+        Double d = _tryParseAsDouble();
+        return (d == null) ? defaultValue : d;
+    }
+
+    @Override
+    public OptionalDouble asDoubleOpt() {
+        Double d = _tryParseAsDouble();
+        return (d == null) ? OptionalDouble.empty() : OptionalDouble.of(d);
+    }
+    
+    // `decimalValue()` (etc) fine as defaults (fail); but need to override `asDecimal()`
+
+    @Override
+    public BigDecimal asDecimal() {
+        BigDecimal dec = _tryParseAsBigDecimal();
+        if (dec == null) {
+            return _reportCoercionFail("asDecimal()", BigDecimal.class,
+                    "value not a valid String representation of `BigDecimal`");
+        }
+        return dec;
+    }
+
+    @Override
+    public BigDecimal asDecimal(BigDecimal defaultValue) {
+        BigDecimal dec = _tryParseAsBigDecimal();
+        return (dec == null) ? defaultValue : dec;
+    }
+
+    @Override
+    public Optional<BigDecimal> asDecimalOpt() {
+        BigDecimal dec = _tryParseAsBigDecimal();
+        return (dec == null) ? Optional.empty() : Optional.of(dec);
+    }
+
+    protected Integer _tryParseAsInteger() {
+        if (NumberInput.looksLikeValidNumber(_value)) {
+            try {
+                // NumberInput does not have a good match so..
+                return Integer.parseInt(_value);
+            } catch (NumberFormatException e) {
+                ;
+            }
+        }
+        return null;
+    }
+
+    protected Long _tryParseAsLong() {
+        if (NumberInput.looksLikeValidNumber(_value)) {
+            try {
+                return NumberInput.parseLong(_value);
+            } catch (NumberFormatException e) {
+                ;
+            }
+        }
+        return null;
+    }
+
+    protected BigInteger _tryParseAsBigInteger() {
+        if (NumberInput.looksLikeValidNumber(_value)) {
+            try {
+                return NumberInput.parseBigInteger(_value, true);
+            } catch (NumberFormatException e) {
+                ;
+            }
+        }
+        return null;
+    }
+
+    protected Double _tryParseAsDouble() {
+        if (NumberInput.looksLikeValidNumber(_value)) {
+            try {
+                return NumberInput.parseDouble(_value, true);
+            } catch (NumberFormatException e) {
+                ;
+            }
+        }
+        return null;
+    }
+
+    protected BigDecimal _tryParseAsBigDecimal() {
+        if (NumberInput.looksLikeValidNumber(_value)) {
+            try {
+                return NumberInput.parseBigDecimal(_value, true);
+            } catch (NumberFormatException e) {
+                ;
+            }
+        }
+        return null;
+    }
+    
     /*
     /**********************************************************************
     /* Serialization
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
index 36aad186c..c72c22169 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBasicTest.java
@@ -50,8 +50,9 @@ public class JsonNodeBasicTest extends NodeTestBase
         assertEquals("true", t.asString());
         assertEquals(JsonToken.VALUE_TRUE, t.asToken());
 
-        assertNodeNumbers(f, 0, 0.0);
-        assertNodeNumbers(t, 1, 1.0);
+        // Booleans cannot be coerced to numbers in 3.0
+        //assertNodeNumbers(f, 0, 0.0);
+        //assertNodeNumbers(t, 1, 1.0);
 
         JsonNode result = objectMapper().readTree("true\n");
         assertFalse(result.isNull());
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java
new file mode 100644
index 000000000..38742462b
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java
@@ -0,0 +1,270 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.junit.jupiter.api.Test;
+
+import tools.jackson.databind.JsonNode;
+import tools.jackson.databind.exc.JsonNodeException;
+import tools.jackson.databind.util.RawValue;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * Tests for [databind#5003], JsonNode.bigIntegerValue() (and related) parts
+ * over all types.
+ */
+public class JsonNodeBigIntegerValueTest
+    extends NodeTestBase
+{
+    private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
+
+    // // // bigIntegerValue() tests
+
+    @Test
+    public void bigIntegerValueFromNumberIntOk()
+    {
+        // Integer types, byte/short/int/long/BigInteger
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode((byte) 1));
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode((short) 1));
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode(1));
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode(1L));
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode(BigInteger.ONE));
+    }
+
+    @Test
+    public void bigIntegerValueFromNumberFPOk()
+    {
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode(1.0f));
+        _assertBigIntegerValue(bigInt(100_000), NODES.numberNode(100_000.0f));
+        _assertBigIntegerValue(bigInt(-100_000), NODES.numberNode(-100_000.0f));
+        
+        _assertBigIntegerValue(BigInteger.ONE, NODES.numberNode(1.0d));
+        _assertBigIntegerValue(bigInt(100_000_000), NODES.numberNode(100_000_000.0d));
+        _assertBigIntegerValue(bigInt(-100_000_000), NODES.numberNode(-100_000_000.0d));
+    
+        _assertBigIntegerValue(BigInteger.ONE,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertBigIntegerValue(bigInt(Long.MIN_VALUE),
+                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")));
+        _assertBigIntegerValue(bigInt(Long.MAX_VALUE),
+                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")));
+    }
+
+    // NOTE: BigInteger has unlimited range so cannot fail for Under-/Overflow (hence no tests)
+    // ... but there are NaNs:
+
+    @Test
+    public void bigIntegerValueFromNumberFPFailForNaN()
+    {
+        _assertFailBigIntegerForNaN(NODES.numberNode(Float.NaN));
+        _assertFailBigIntegerForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+        _assertFailBigIntegerForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
+        _assertFailBigIntegerForNaN(NODES.numberNode(Double.NaN));
+        _assertFailBigIntegerForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+        _assertFailBigIntegerForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
+    }
+    
+    @Test
+    public void bigIntegerValueFromNumberFPFailFraction()
+    {
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(100.5f));
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(-0.25f));
+
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(100.5d));
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(-0.25d));
+        
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
+        _assertFailBigIntegerValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+    }
+
+    @Test
+    public void bigIntegerValueFromNonNumberScalarFail()
+    {
+        _assertFailBigIntegerForNonNumber(NODES.booleanNode(true));
+        _assertFailBigIntegerForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertFailBigIntegerForNonNumber(NODES.stringNode("123"));
+        _assertFailBigIntegerForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailBigIntegerForNonNumber(NODES.pojoNode(Boolean.TRUE));
+    }
+
+    @Test
+    public void bigIntegerValueFromStructuralFail()
+    {
+        _assertFailBigIntegerForNonNumber(NODES.arrayNode(3));
+        _assertFailBigIntegerForNonNumber(NODES.objectNode());
+    }
+
+    @Test
+    public void bigIntegerValueFromMiscOtherFail()
+    {
+        _assertFailBigIntegerForNonNumber(NODES.nullNode());
+        _assertFailBigIntegerForNonNumber(NODES.missingNode());
+    }
+
+    // // // asBigInteger()
+
+    // // // BigInteger + bigIntegerValue()
+
+    @Test
+    public void asBigIntegerFromNumberIntOk()
+    {
+        // Integer types, byte/short/int/long/BigInteger
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode((byte) 1));
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode((short) 1));
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode(1));
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode(1L));
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode(BigInteger.ONE));
+    }
+
+    // NOTE: BigInteger has unlimited range so cannot fail for Under-/Overflow (hence no tests)
+
+    @Test
+    public void asBigIntegerFromNumberFPOk()
+    {
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode(1.0f));
+        _assertAsBigInteger(bigInt(100_000), NODES.numberNode(100_000.0f));
+        _assertAsBigInteger(bigInt(-100_000), NODES.numberNode(-100_000.0f));
+        
+        _assertAsBigInteger(BigInteger.ONE, NODES.numberNode(1.0d));
+        _assertAsBigInteger(bigInt(100_000_000), NODES.numberNode(100_000_000.0d));
+        _assertAsBigInteger(bigInt(-100_000_000), NODES.numberNode(-100_000_000.0d));
+    
+        _assertAsBigInteger(BigInteger.ONE,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertAsBigInteger(bigInt(Long.MIN_VALUE),
+                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")));
+        _assertAsBigInteger(bigInt(Long.MAX_VALUE),
+                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")));
+    }
+
+    // NOTE: unlike with "bigIntegerValue()", fractions ok: will be rounded
+    @Test
+    public void asBigIntegerFromNumberFPFraction()
+    {
+        final BigInteger B100 = bigInt(100);
+        final BigInteger B_MINUS_1 = bigInt(-1);
+        
+        _assertAsBigInteger(B100, NODES.numberNode(100.75f));
+        _assertAsBigInteger(B_MINUS_1, NODES.numberNode(-1.25f));
+
+        _assertAsBigInteger(B100, NODES.numberNode(100.75d));
+        _assertAsBigInteger(B_MINUS_1, NODES.numberNode(-1.25d));
+        
+        _assertAsBigInteger(B100, NODES.numberNode(BigDecimal.valueOf(100.75d)));
+        _assertAsBigInteger(B_MINUS_1, NODES.numberNode(BigDecimal.valueOf(-1.25d)));
+    }
+
+    @Test
+    public void asBigIntegerFromNonNumberScalar()
+    {
+        // First failing cases
+        _assertAsBigIntegerFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertAsBigIntegerFailForNonNumber(NODES.booleanNode(true));
+        _assertAsBigIntegerFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertAsBigIntegerFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
+        _assertAsBigIntegerFailForNonNumber(NODES.stringNode("E000"),
+                "not valid String representation of `BigInteger`");
+
+        // Then passing
+        _assertAsBigInteger(BigInteger.TEN, NODES.pojoNode(BigInteger.TEN));
+        _assertAsBigInteger(BigInteger.TEN, NODES.pojoNode(Integer.valueOf(10)));
+        _assertAsBigInteger(BigInteger.TEN, NODES.pojoNode(Long.valueOf(10)));
+
+        _assertAsBigInteger(BigInteger.TEN, NODES.stringNode("10"));
+        _assertAsBigInteger(BigInteger.valueOf(-99), NODES.stringNode("-99"));
+    }
+
+    @Test
+    public void asBigIntegerFromStructuralFail()
+    {
+        _assertAsBigIntegerFailForNonNumber(NODES.arrayNode(3));
+        _assertAsBigIntegerFailForNonNumber(NODES.objectNode());
+    }
+
+    @Test
+    public void asBigIntegerFromMiscOther()
+    {
+        // NullNode becomes 0, not fail
+        _assertAsBigInteger(BigInteger.ZERO, NODES.nullNode());
+
+        // But MissingNode still fails
+        _assertAsBigIntegerFailForNonNumber(NODES.missingNode());
+    }
+    
+    // // // Shared helper methods
+
+    private void _assertBigIntegerValue(BigInteger expected, JsonNode node) {
+        assertEquals(expected, node.bigIntegerValue());
+
+        // and then defaulting
+        assertEquals(expected, node.bigIntegerValue(BigInteger.valueOf(9999999L)));
+        assertEquals(expected, node.bigIntegerValueOpt().get());
+    }
+
+    private void _assertFailBigIntegerValueForFraction(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.bigIntegerValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("to `java.math.BigInteger`: value has fractional part");
+
+        // Verify default value handling
+        assertEquals(BigInteger.ONE, node.bigIntegerValue(BigInteger.ONE));
+        assertFalse(node.bigIntegerValueOpt().isPresent());
+
+    }
+
+    private void _assertFailBigIntegerForNonNumber(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.bigIntegerValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not numeric");
+
+        // Verify default value handling
+        assertEquals(BigInteger.ONE, node.bigIntegerValue(BigInteger.ONE));
+        assertFalse(node.bigIntegerValueOpt().isPresent());
+    }
+
+    private void _assertFailBigIntegerForNaN(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.bigIntegerValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value non-Finite ('NaN')");
+
+        // Verify default value handling
+        assertEquals(BigInteger.ONE, node.bigIntegerValue(BigInteger.ONE));
+        assertFalse(node.bigIntegerValueOpt().isPresent());
+    }
+
+    private void _assertAsBigInteger(BigInteger expected, JsonNode node) {
+        assertEquals(expected, node.asBigInteger());
+
+        // and then defaulting
+        assertEquals(expected, node.asBigInteger(BigInteger.valueOf(9999999L)));
+        assertEquals(expected, node.asBigIntegerOpt().get());
+    }
+
+    private void _assertAsBigIntegerFailForNonNumber(JsonNode node) {
+        _assertAsBigIntegerFailForNonNumber(node, "value type not numeric");
+    }
+
+    private void _assertAsBigIntegerFailForNonNumber(JsonNode node, String extraMsg) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asBigInteger(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value");
+
+        // Verify default value handling
+        assertEquals(BigInteger.ONE, node.asBigInteger(BigInteger.ONE));
+        assertFalse(node.asBigIntegerOpt().isPresent());
+    }
+}
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
index a795ac4d3..c7db52c34 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java
@@ -42,6 +42,19 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
     @JsonDeserialize(using = LeafDeserializer.class)
     public static class LeafMixIn { }
 
+    // Deserializer to trigger the problem described in [JACKSON-554]
+    static class LeafDeserializer extends ValueDeserializer<Leaf>
+    {
+        @Override
+        public Leaf deserialize(JsonParser p, DeserializationContext ctxt)
+        {
+            JsonNode tree = ctxt.readTree(p);
+            Leaf leaf = new Leaf();
+            leaf.value = tree.get("value").intValue();
+            return leaf;
+        }
+    }
+
     // for [databind#467]
     @JsonSerialize(using=Issue467Serializer.class)
     static class Issue467Bean  {
@@ -127,17 +140,6 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
 
     private final ObjectMapper MAPPER = objectMapper();
 
-    @Test
-    public void testAsInt() throws Exception
-    {
-        assertEquals(9, IntNode.valueOf(9).asInt());
-        assertEquals(7, LongNode.valueOf(7L).asInt());
-        assertEquals(13, new StringNode("13").asInt());
-        assertEquals(0, new StringNode("foobar").asInt());
-        assertEquals(27, new StringNode("foobar").asInt(27));
-        assertEquals(1, BooleanNode.TRUE.asInt());
-    }
-
     // note: pre-[databind#5034]
     @Test
     public void testAsBoolean() throws Exception
@@ -154,19 +156,6 @@ public class JsonNodeConversionsTest extends DatabindTestUtil
         assertTrue(new POJONode(Boolean.TRUE).asBoolean());
     }
 
-    // Deserializer to trigger the problem described in [JACKSON-554]
-    public static class LeafDeserializer extends ValueDeserializer<Leaf>
-    {
-        @Override
-        public Leaf deserialize(JsonParser p, DeserializationContext ctxt)
-        {
-            JsonNode tree = ctxt.readTree(p);
-            Leaf leaf = new Leaf();
-            leaf.value = tree.get("value").intValue();
-            return leaf;
-        }
-    }
-
     @Test
     public void testTreeToValue() throws Exception
     {
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java
index b656f843d..8f3e2f985 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java
@@ -25,147 +25,280 @@ public class JsonNodeDecimalValueTest
     private final BigDecimal BD_ONE = BigDecimal.ONE;
     private final BigDecimal BD_ONE_O = new BigDecimal("1.0");
 
-    private final Optional<BigDecimal> BD_ONE_OPT = Optional.of(BD_ONE);
-
     private final BigDecimal BD_DEFAULT = bigDec(12.125);
+
+    // // // decimalValue() tests
     
-    // // // decimalValue() + Numbers/Integers
+    // decimalValue() + Numbers/Integers
 
     @Test
     public void decimalValueFromNumberIntOk()
     {
-        // Then other integer types
-        assertEquals(BD_ONE, NODES.numberNode((byte) 1).decimalValue());
-        assertEquals(BD_ONE, NODES.numberNode((byte) 1).decimalValue(BD_DEFAULT));
-        assertEquals(BD_ONE_OPT, NODES.numberNode((byte) 1).decimalValueOpt());
-        assertEquals(bigDec(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE).decimalValue());
-        assertEquals(bigDec(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE).decimalValueOpt().get());
-        assertEquals(bigDec(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE).decimalValue());
-        assertEquals(bigDec(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE).decimalValueOpt().get());
-
-        assertEquals(BD_ONE, NODES.numberNode((short) 1).decimalValue());
-        assertEquals(BD_ONE, NODES.numberNode((short) 1).decimalValue(BD_DEFAULT));
-        assertEquals(BD_ONE_OPT, NODES.numberNode((short) 1).decimalValueOpt());
-        assertEquals(bigDec(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE).decimalValue());
-        assertEquals(bigDec(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE).decimalValueOpt().get());
-        assertEquals(bigDec(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE).decimalValue());
-        assertEquals(bigDec(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE).decimalValueOpt().get());
-
-        assertEquals(BD_ONE, NODES.numberNode(1).decimalValue());
-        assertEquals(BD_ONE, NODES.numberNode(1).decimalValue(BD_DEFAULT));
-        assertEquals(BD_ONE_OPT, NODES.numberNode(1).decimalValueOpt());
-        assertEquals(bigDec(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE).decimalValue());
-        assertEquals(bigDec(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE).decimalValueOpt().get());
-        assertEquals(bigDec(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE).decimalValue());
-        assertEquals(bigDec(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE).decimalValueOpt().get());
-        
-        assertEquals(BD_ONE, NODES.numberNode(1L).decimalValue());
-        assertEquals(BD_ONE, NODES.numberNode(1L).decimalValue(BD_DEFAULT));
-        assertEquals(BD_ONE_OPT, NODES.numberNode(1L).decimalValueOpt());
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE).decimalValue());
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE).decimalValueOpt().get());
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE).decimalValue());
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE).decimalValueOpt().get());
-
-        assertEquals(BD_ONE, NODES.numberNode(BigInteger.valueOf(1)).decimalValue());
-        assertEquals(BD_ONE, NODES.numberNode(BigInteger.valueOf(1)).decimalValue(BD_DEFAULT));
-        assertEquals(BD_ONE_OPT, NODES.numberNode(BigInteger.valueOf(1)).decimalValueOpt());
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).decimalValue());
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Long.MIN_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).decimalValueOpt().get());
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).decimalValue());
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec(Long.MAX_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).decimalValueOpt().get());
+        _assertDecimalValue(BD_ONE, NODES.numberNode((byte) 1));
+        _assertDecimalValue(bigDec(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE));
+        _assertDecimalValue(bigDec(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertDecimalValue(BD_ONE, NODES.numberNode((short) 1));
+        _assertDecimalValue(bigDec(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE));
+        _assertDecimalValue(bigDec(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE));
+
+        _assertDecimalValue(BD_ONE, NODES.numberNode(1));
+        _assertDecimalValue(bigDec(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE));
+        _assertDecimalValue(bigDec(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE));
+
+        _assertDecimalValue(BD_ONE, NODES.numberNode(1L));
+        _assertDecimalValue(bigDec(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE));
+        _assertDecimalValue(bigDec(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE));
+
+        _assertDecimalValue(BD_ONE, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertDecimalValue(bigDec(Long.MIN_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertDecimalValue(bigDec(Long.MAX_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
     }
 
     // Cannot fail for Over/Underflow from Integer values
     //@Test public void failBigDecimalValueFromNumberIntRange() { }
 
-    // // // decimalValue() + Numbers/FPs
+    // decimalValue() + Numbers/FPs
 
     @Test
     public void decimalValueFromNumberFPOk()
     {
-        assertEquals(BD_ONE_O, NODES.numberNode(1.0f).decimalValue());
-        assertEquals(BD_ONE_O, NODES.numberNode(1.0f).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec("100000.0"), NODES.numberNode(100_000.0f).decimalValue());
-        assertEquals(bigDec("100000.0"), NODES.numberNode(100_000.0f).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec("-100000.0"), NODES.numberNode(-100_000.0f).decimalValue());
-        assertEquals(bigDec("-100000.0"), NODES.numberNode(-100_000.0f).decimalValue(BD_DEFAULT));
+        _assertDecimalValue(BD_ONE_O, NODES.numberNode(1.0f));
 
-        assertEquals(BD_ONE_O, NODES.numberNode(1.0d).decimalValue());
-        assertEquals(BD_ONE_O, NODES.numberNode(1.0d).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec("100000.0"), NODES.numberNode(100_000.0d).decimalValue());
-        assertEquals(bigDec("100000.0"), NODES.numberNode(100_000.0d).decimalValue(BD_DEFAULT));
-        assertEquals(bigDec("-100000.0"), NODES.numberNode(-100_000.0d).decimalValue());
-        assertEquals(bigDec("-100000.0"), NODES.numberNode(-100_000.0d).decimalValue(BD_DEFAULT));
+        _assertDecimalValue(BD_ONE_O, NODES.numberNode(1.0f));
+        _assertDecimalValue(bigDec("100000.0"), NODES.numberNode(100_000.0f));
+        _assertDecimalValue(bigDec("-100000.0"), NODES.numberNode(-100_000.0f));
 
-        assertEquals(new BigDecimal("100.001"),
-                NODES.numberNode(new BigDecimal("100.001")).decimalValue());
+        _assertDecimalValue(BD_ONE_O, NODES.numberNode(1.0d));
+        _assertDecimalValue(bigDec("100000.0"), NODES.numberNode(100_000.0d));
+        _assertDecimalValue(bigDec("-100000.0"), NODES.numberNode(-100_000.0d));
+
+        _assertDecimalValue(new BigDecimal("100.001"),
+                NODES.numberNode(new BigDecimal("100.001")));
     }
 
     // Cannot fail for Over/Underflow from FP values either
     //@Test public void failBigDecimalFromNumberFPRange() { }
 
-    // // // decimalValue() + non-Numeric types
+    // But can fail for NaN
+
+    @Test
+    public void decimalValueFromNumberFPFail()
+    {
+        _assertFailDecimalValueForNaN(NODES.numberNode(Float.NaN));
+        _assertFailDecimalValueForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
+        _assertFailDecimalValueForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+
+        _assertFailDecimalValueForNaN(NODES.numberNode(Double.NaN));
+        _assertFailDecimalValueForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
+        _assertFailDecimalValueForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+    }
+
+    // decimalValue() + non-Numeric types
 
     @Test
     public void failBigDecimalFromNonNumberScalar()
     {
-        _assertFailBigDecimalForNonNumber(NODES.booleanNode(true));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.booleanNode(true));
-        _assertFailBigDecimalForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.binaryNode(new byte[3]));
-        _assertFailBigDecimalForNonNumber(NODES.stringNode("123"));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.stringNode("123"));
-        _assertFailBigDecimalForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailBigDecimalForNonNumber(NODES.pojoNode(Boolean.TRUE));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.pojoNode(Boolean.TRUE));
+        _assertFailDecimalValueForNonNumber(NODES.booleanNode(true));
+        _assertFailDecimalValueForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertFailDecimalValueForNonNumber(NODES.stringNode("123"));
+        _assertFailDecimalValueForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailDecimalValueForNonNumber(NODES.pojoNode(Boolean.TRUE));
+    }
+
+    @Test
+    public void failBigDecimalValueFromMiscOther()
+    {
+        _assertFailDecimalValueForNonNumber(NODES.nullNode());
+        _assertFailDecimalValueForNonNumber(NODES.missingNode());
     }
 
     @Test
     public void failBigDecimalValueFromStructural()
     {
-        _assertFailBigDecimalForNonNumber(NODES.arrayNode(3));
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.arrayNode(3));
-        _assertFailBigDecimalForNonNumber(NODES.objectNode());
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.objectNode());
+        _assertFailDecimalValueForNonNumber(NODES.arrayNode(3));
+        _assertFailDecimalValueForNonNumber(NODES.objectNode());
+    }
+
+    // // // asDecimal() tests
+
+    @Test
+    public void asDecimalFromNumberIntOk()
+    {
+        _assertAsDecimal(BD_ONE, NODES.numberNode((byte) 1));
+        _assertAsDecimal(bigDec(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE));
+        _assertAsDecimal(bigDec(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertAsDecimal(BD_ONE, NODES.numberNode((short) 1));
+        _assertAsDecimal(bigDec(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE));
+        _assertAsDecimal(bigDec(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE));
+
+        _assertAsDecimal(BD_ONE, NODES.numberNode(1));
+        _assertAsDecimal(bigDec(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE));
+        _assertAsDecimal(bigDec(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE));
+
+        _assertAsDecimal(BD_ONE, NODES.numberNode(1L));
+        _assertAsDecimal(bigDec(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE));
+        _assertAsDecimal(bigDec(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE));
+
+        _assertAsDecimal(BD_ONE, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertAsDecimal(bigDec(Long.MIN_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertAsDecimal(bigDec(Long.MAX_VALUE), NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
+    }
+
+    @Test
+    public void asDecimalFromNumberFPOk()
+    {
+        _assertAsDecimal(BD_ONE_O, NODES.numberNode(1.0f));
+
+        _assertAsDecimal(BD_ONE_O, NODES.numberNode(1.0f));
+        _assertAsDecimal(bigDec("100000.0"), NODES.numberNode(100_000.0f));
+        _assertAsDecimal(bigDec("-100000.0"), NODES.numberNode(-100_000.0f));
+
+        _assertAsDecimal(BD_ONE_O, NODES.numberNode(1.0d));
+        _assertAsDecimal(bigDec("100000.0"), NODES.numberNode(100_000.0d));
+        _assertAsDecimal(bigDec("-100000.0"), NODES.numberNode(-100_000.0d));
+
+        _assertAsDecimal(new BigDecimal("100.001"),
+                NODES.numberNode(new BigDecimal("100.001")));
     }
 
+    // Cannot fail for Over/Underflow from FP values either
+
+    // But can fail for NaN
+
     @Test
-    public void failDoubleValueFromMiscOther()
+    public void asDecimalFromNumberFPFail()
     {
-        _assertFailBigDecimalForNonNumber(NODES.nullNode());
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.nullNode());
-        _assertFailBigDecimalForNonNumber(NODES.missingNode());
-        _assertDefaultBigDecimalForOtherwiseFailing(NODES.missingNode());
+        _assertFailAsDecimalForNaN(NODES.numberNode(Float.NaN));
+        _assertFailAsDecimalForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
+        _assertFailAsDecimalForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+
+        _assertFailAsDecimalForNaN(NODES.numberNode(Double.NaN));
+        _assertFailAsDecimalForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
+        _assertFailAsDecimalForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
     }
 
+    // asDecimal() + non-Numeric types
+
+    @Test
+    public void asDecimalFromNonNumberScalar()
+    {
+        // Regular failing cases
+        _assertFailAsDecimalForNonNumber(NODES.booleanNode(true));
+        _assertFailAsDecimalForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertFailAsDecimalForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailAsDecimalForNonNumber(NODES.pojoNode(Boolean.TRUE));
+
+        // Special failing cases:
+        _assertFailAsDecimal(NODES.stringNode("abc"),
+                "value not a valid String representation of `BigDecimal`");
+
+
+        // Passing cases
+        _assertAsDecimal(BigDecimal.valueOf(2), NODES.stringNode("2"));
+        _assertAsDecimal(BigDecimal.TEN, NODES.pojoNode(10));
+    }
+
+    @Test
+    public void asDecimalFailFromStructural()
+    {
+        _assertFailAsDecimalForNonNumber(NODES.arrayNode(3));
+        _assertFailAsDecimalForNonNumber(NODES.objectNode());
+    }
+
+    @Test
+    public void asDecimalFromMiscOther()
+    {
+        // "null" becomes "0.0"
+        _assertAsDecimal(BigDecimal.ZERO, NODES.nullNode());
+
+        // but "missing" still fails
+        _assertFailAsDecimalForNonNumber(NODES.missingNode());
+    }
+    
     // // // Shared helper methods
 
-    private void _assertFailBigDecimalForNonNumber(JsonNode node) {
+    private void _assertDecimalValue(BigDecimal expected, JsonNode fromNode)
+    {
+        // main accessor
+        assertEquals(expected, fromNode.decimalValue());
+
+        // but also defaulting
+        assertEquals(expected, fromNode.decimalValue(BD_DEFAULT));
+        assertEquals(expected, fromNode.decimalValueOpt().get());
+    }
+
+    private void _assertAsDecimal(BigDecimal expected, JsonNode fromNode)
+    {
+        // main accessor
+        assertEquals(expected, fromNode.asDecimal());
+
+        // but also defaulting
+        assertEquals(expected, fromNode.asDecimal(BD_DEFAULT));
+        assertEquals(expected, fromNode.asDecimalOpt().get());
+    }
+
+    private void _assertFailDecimalValueForNonNumber(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.decimalValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("decimalValue()")
             .contains("cannot convert value")
             .contains("value type not numeric");
+
+        // Verify default value handling
+        assertEquals(BD_DEFAULT, node.decimalValue(BD_DEFAULT));
+        assertEquals(Optional.empty(), node.decimalValueOpt());
     }
 
-    private void _assertDefaultBigDecimalForOtherwiseFailing(JsonNode node) {
+    private void _assertFailDecimalValueForNaN(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.decimalValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("decimalValue()")
+            .contains("cannot convert value")
+            .contains("value non-Finite ('NaN')");
+
+        // Verify default value handling
         assertEquals(BD_DEFAULT, node.decimalValue(BD_DEFAULT));
         assertEquals(Optional.empty(), node.decimalValueOpt());
     }
 
+    private void _assertFailAsDecimalForNonNumber(JsonNode node) {
+        _assertFailAsDecimal(node, "value type not coercible to `BigDecimal`");
+    }
+
+    private void _assertFailAsDecimal(JsonNode node, String extraFailMsg) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asDecimal(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("asDecimal()")
+            .contains("cannot convert value")
+            .contains(extraFailMsg);
+
+        // Verify default value handling
+        assertEquals(BD_DEFAULT, node.asDecimal(BD_DEFAULT));
+        assertEquals(Optional.empty(), node.asDecimalOpt());
+    }
+
+    private void _assertFailAsDecimalForNaN(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asDecimal(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+        .contains("asDecimal()")
+            .contains("cannot convert value")
+            .contains("value non-Finite ('NaN')");
+
+        // Verify default value handling
+        assertEquals(BD_DEFAULT, node.asDecimal(BD_DEFAULT));
+        assertEquals(Optional.empty(), node.asDecimalOpt());
+    }
+    
     protected static Optional<BigDecimal> bigDecOpt(BigDecimal bigDec) {
         return Optional.of(bigDec);
     }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java
index b66c4e204..b50f630ef 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java
@@ -22,63 +22,34 @@ public class JsonNodeDoubleValueTest
 {
     private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
 
-    // // // doubleValue() + Numbers/Integers
+    // // // doubleValue()
+    
+    // from Integers
 
     @Test
     public void doubleValueFromNumberIntOk()
     {
         final double ONE_D = (double) 1;
+
+        _assertDoubleValue(ONE_D, NODES.numberNode((byte) 1));
+        _assertDoubleValue((double)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertDoubleValue((double)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertDoubleValue(ONE_D, NODES.numberNode((short) 1));
+        _assertDoubleValue((double)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertDoubleValue((double)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
+
+        _assertDoubleValue(ONE_D, NODES.numberNode(1));
+        _assertDoubleValue((double) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertDoubleValue((double) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
         
-        // Then other integer types
-        assertEquals(ONE_D, NODES.numberNode((byte) 1).doubleValue());
-        assertEquals(ONE_D, NODES.numberNode((byte) 1).doubleValue(99));
-        assertEquals(ONE_D, NODES.numberNode((byte) 1).doubleValueOpt().getAsDouble());
-        assertEquals((double)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).doubleValue());
-        assertEquals((double)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).doubleValue(99));
-        assertEquals((double)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).doubleValueOpt().getAsDouble());
-        assertEquals((double)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).doubleValue());
-        assertEquals((double)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).doubleValue(99));
-        assertEquals((double)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).doubleValueOpt().getAsDouble());
-
-        assertEquals(ONE_D, NODES.numberNode((short) 1).doubleValue());
-        assertEquals(ONE_D, NODES.numberNode((short) 1).doubleValue(99));
-        assertEquals(ONE_D, NODES.numberNode((short) 1).doubleValueOpt().getAsDouble());
-        assertEquals((double)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).doubleValue());
-        assertEquals((double)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).doubleValue(99));
-        assertEquals((double)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).doubleValueOpt().getAsDouble());
-        assertEquals((double)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).doubleValue());
-        assertEquals((double)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).doubleValue(99));
-        assertEquals((double)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).doubleValueOpt().getAsDouble());
-
-        assertEquals(ONE_D, NODES.numberNode(1).doubleValue());
-        assertEquals(ONE_D, NODES.numberNode(1).doubleValue(99));
-        assertEquals(ONE_D, NODES.numberNode(1).doubleValueOpt().getAsDouble());
-        assertEquals((double) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).doubleValue());
-        assertEquals((double) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).doubleValue(99));
-        assertEquals((double) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).doubleValueOpt().getAsDouble());
-        assertEquals((double) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).doubleValue());
-        assertEquals((double) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).doubleValue(99));
-        assertEquals((double) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).doubleValueOpt().getAsDouble());
-        
-        assertEquals(ONE_D, NODES.numberNode(1L).doubleValue());
-        assertEquals(ONE_D, NODES.numberNode(1L).doubleValue(99));
-        assertEquals(ONE_D, NODES.numberNode(1L).doubleValueOpt().getAsDouble());
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(Long.MIN_VALUE).doubleValue());
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(Long.MIN_VALUE).doubleValue(99));
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(Long.MIN_VALUE).doubleValueOpt().getAsDouble());
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(Long.MAX_VALUE).doubleValue());
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(Long.MAX_VALUE).doubleValue(99));
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(Long.MAX_VALUE).doubleValueOpt().getAsDouble());
-
-        assertEquals(ONE_D, NODES.numberNode(BigInteger.valueOf(1)).doubleValue());
-        assertEquals(ONE_D, NODES.numberNode(BigInteger.valueOf(1)).doubleValue(99));
-        assertEquals(ONE_D, NODES.numberNode(BigInteger.valueOf(1)).doubleValueOpt().getAsDouble());
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).doubleValue());
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).doubleValue(99));
-        assertEquals((double) Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).doubleValueOpt().getAsDouble());
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).doubleValue());
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).doubleValue(99));
-        assertEquals((double) Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).doubleValueOpt().getAsDouble());
+        _assertDoubleValue(ONE_D, NODES.numberNode(1L));
+        _assertDoubleValue((double) Long.MIN_VALUE, NODES.numberNode(Long.MIN_VALUE));
+        _assertDoubleValue((double) Long.MAX_VALUE, NODES.numberNode(Long.MAX_VALUE));
+
+        _assertDoubleValue(ONE_D, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertDoubleValue((double) Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertDoubleValue((double) Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
     }
 
     @Test
@@ -88,44 +59,30 @@ public class JsonNodeDoubleValueTest
 
         final BigInteger tooBig = BigInteger.TEN.pow(310);      
         final BigInteger tooSmall = tooBig.negate();
-        
-        _assertFailDoubleForValueRange(NODES.numberNode(tooBig));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.numberNode(tooBig));
-        _assertFailDoubleForValueRange(NODES.numberNode(tooSmall));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.numberNode(tooSmall));
+
+        _assertDoubleValueFailForValueRange(NODES.numberNode(tooBig));
+        _assertDoubleValueFailForValueRange(NODES.numberNode(tooSmall));
     }
 
-    // // // doubleValue() + Numbers/FPs
+    // From FPs
 
     @Test
     public void doubleValueFromNumberFPOk()
     {
-        assertEquals(1.0, NODES.numberNode(1.0f).doubleValue());
-        assertEquals(1.0, NODES.numberNode(1.0f).doubleValue(99));
-        assertEquals(100_000.0, NODES.numberNode(100_000.0f).doubleValue());
-        assertEquals(100_000.0, NODES.numberNode(100_000.0f).doubleValue(99));
-        assertEquals(-100_000.0, NODES.numberNode(-100_000.0f).doubleValue());
-        assertEquals(-100_000.0, NODES.numberNode(-100_000.0f).doubleValue(99));
-
-        assertEquals(1.0, NODES.numberNode(1.0d).doubleValue());
-        assertEquals(1.0, NODES.numberNode(1.0d).doubleValue(99));
-        assertEquals(100_000.0, NODES.numberNode(100_000.0d).doubleValue());
-        assertEquals(100_000.0, NODES.numberNode(100_000.0d).doubleValue(99));
-        assertEquals(-100_000.0, NODES.numberNode(-100_000.0d).doubleValue());
-        assertEquals(-100_000.0, NODES.numberNode(-100_000.0d).doubleValue(99));
-
-        assertEquals(1.0,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).doubleValue());
-        assertEquals(1.0,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).doubleValue(99));
-        assertEquals((double) Long.MIN_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Long.MIN_VALUE)).doubleValue());
-        assertEquals((double) Long.MIN_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Long.MIN_VALUE)).doubleValue(99));
-        assertEquals((double) Long.MAX_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Long.MAX_VALUE)).doubleValue());
-        assertEquals((double) Long.MAX_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Long.MAX_VALUE)).doubleValue(99));
+        _assertDoubleValue(1.0, NODES.numberNode(1.0f));
+        _assertDoubleValue(100_000.0, NODES.numberNode(100_000.0f));
+        _assertDoubleValue(-100_000.0, NODES.numberNode(-100_000.0f));
+
+        _assertDoubleValue(1.0, NODES.numberNode(1.0d));
+        _assertDoubleValue(100_000.0, NODES.numberNode(100_000.0d));
+        _assertDoubleValue(-100_000.0, NODES.numberNode(-100_000.0d));
+
+        _assertDoubleValue(1.0,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertDoubleValue((double) Long.MIN_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Long.MIN_VALUE)));
+        _assertDoubleValue((double) Long.MAX_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Long.MAX_VALUE)));
     }
 
     @Test
@@ -137,72 +94,219 @@ public class JsonNodeDoubleValueTest
                 .add(BigDecimal.valueOf(0.125));
         final BigDecimal tooSmall = tooBig.negate();
 
-        _assertFailDoubleForValueRange(NODES.numberNode(tooBig));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.numberNode(tooBig));
-        _assertFailDoubleForValueRange(NODES.numberNode(tooSmall));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.numberNode(tooSmall));
+        _assertDoubleValueFailForValueRange(NODES.numberNode(tooBig));
+        _assertDoubleValueFailForValueRange(NODES.numberNode(tooSmall));
     }
 
-    // // // doubleValue() + non-Numeric types
+    // from non-Numeric types
 
     @Test
     public void failDoubleValueFromNonNumberScalar()
     {
-        _assertFailDoubleForNonNumber(NODES.booleanNode(true));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.booleanNode(true));
-        _assertFailDoubleForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.binaryNode(new byte[3]));
-        _assertFailDoubleForNonNumber(NODES.stringNode("123"));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.stringNode("123"));
-        _assertFailDoubleForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailDoubleForNonNumber(NODES.pojoNode(Boolean.TRUE));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.pojoNode(Boolean.TRUE));
+        _assertDoubleValueFailForNonNumber(NODES.booleanNode(true));
+        _assertDoubleValueFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertDoubleValueFailForNonNumber(NODES.stringNode("123"));
+        _assertDoubleValueFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertDoubleValueFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
     }
 
     @Test
     public void failDoubleValueFromStructural()
     {
-        _assertFailDoubleForNonNumber(NODES.arrayNode(3));
-        _assertDefaultDoubleForOtherwiseFailing(NODES.arrayNode(3));
-        _assertFailDoubleForNonNumber(NODES.objectNode());
-        _assertDefaultDoubleForOtherwiseFailing(NODES.objectNode());
+        _assertDoubleValueFailForNonNumber(NODES.arrayNode(3));
+        _assertDoubleValueFailForNonNumber(NODES.objectNode());
     }
 
     @Test
     public void failDoubleValueFromMiscOther()
     {
-        _assertFailDoubleForNonNumber(NODES.nullNode());
-        _assertDefaultDoubleForOtherwiseFailing(NODES.nullNode());
-        _assertFailDoubleForNonNumber(NODES.missingNode());
-        _assertDefaultDoubleForOtherwiseFailing(NODES.missingNode());
+        _assertDoubleValueFailForNonNumber(NODES.nullNode());
+        _assertDoubleValueFailForNonNumber(NODES.missingNode());
+    }
+
+    // // // asDouble()
+    
+    // from Integers
+
+    @Test
+    public void asDoubleFromNumberIntOk()
+    {
+        final double ONE_D = (double) 1;
+
+        _assertAsDouble(ONE_D, NODES.numberNode((byte) 1));
+        _assertAsDouble((double)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertAsDouble((double)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertAsDouble(ONE_D, NODES.numberNode((short) 1));
+        _assertAsDouble((double)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertAsDouble((double)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
+
+        _assertAsDouble(ONE_D, NODES.numberNode(1));
+        _assertAsDouble((double) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertAsDouble((double) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
+        
+        _assertAsDouble(ONE_D, NODES.numberNode(1L));
+        _assertAsDouble((double) Long.MIN_VALUE, NODES.numberNode(Long.MIN_VALUE));
+        _assertAsDouble((double) Long.MAX_VALUE, NODES.numberNode(Long.MAX_VALUE));
+
+        _assertAsDouble(ONE_D, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertAsDouble((double) Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertAsDouble((double) Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
+    }
+
+    @Test
+    public void asDoubleFailFromNumberIntRange() {
+        // Can only fail for underflow/overflow: and that only for / BigInteger
+        // (neither Integer nor Long is outside of range of even Float).
+
+        final BigInteger tooBig = BigInteger.TEN.pow(310);      
+        final BigInteger tooSmall = tooBig.negate();
+
+        _assertAsDoubleFailForValueRange(NODES.numberNode(tooBig));
+        _assertAsDoubleFailForValueRange(NODES.numberNode(tooSmall));
+    }
+
+    // Numbers/FPs
+
+    @Test
+    public void asDoubleFromNumberFPOk()
+    {
+        _assertAsDouble(1.0, NODES.numberNode(1.0f));
+        _assertAsDouble(100_000.0, NODES.numberNode(100_000.0f));
+        _assertAsDouble(-100_000.0, NODES.numberNode(-100_000.0f));
+
+        _assertAsDouble(1.0, NODES.numberNode(1.0d));
+        _assertAsDouble(100_000.0, NODES.numberNode(100_000.0d));
+        _assertAsDouble(-100_000.0, NODES.numberNode(-100_000.0d));
+
+        _assertAsDouble(1.0,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertAsDouble((double) Long.MIN_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Long.MIN_VALUE)));
+        _assertAsDouble((double) Long.MAX_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Long.MAX_VALUE)));
+    }
+
+    @Test
+    public void asDoubleFromNumberFPRangeFail()
+    {
+        // Can only fail from BigDecimal (similar to ints vs BigInteger)
+
+        final BigDecimal tooBig = new BigDecimal(BigInteger.TEN.pow(310))
+                .add(BigDecimal.valueOf(0.125));
+        final BigDecimal tooSmall = tooBig.negate();
+
+        _assertAsDoubleFailForValueRange(NODES.numberNode(tooBig));
+        _assertAsDoubleFailForValueRange(NODES.numberNode(tooSmall));
+    }
+
+    // from non-Numeric types
+
+    @Test
+    public void asDoubleFromNonNumberScalar()
+    {
+        // First, failing cases:
+
+        _assertAsDoubleFailForNonNumber(NODES.booleanNode(true));
+        _assertAsDoubleFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertAsDoubleFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertAsDoubleFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
+        _assertAsDoubleFailForNonNumber(NODES.stringNode("abc"),
+                "not a valid String representation of `double`");
+
+        // Then passing ones:
+        _assertAsDouble(2.5d, NODES.pojoNode(2.5d));
+        _assertAsDouble(0.5d, NODES.stringNode("0.5"));
+    }
+
+    @Test
+    public void asDoubleFromStructuralFail()
+    {
+        _assertAsDoubleFailForNonNumber(NODES.arrayNode(3));
+        _assertAsDoubleFailForNonNumber(NODES.objectNode());
+    }
+
+    @Test
+    public void asDoubleFromMiscOther()
+    {
+        // Null node converts to 0.0d; missing fails
+        _assertAsDouble((double) 0, NODES.nullNode());
+
+        _assertAsDoubleFailForNonNumber(NODES.missingNode());
     }
 
     // // // Shared helper methods
 
-    private void _assertFailDoubleForValueRange(JsonNode node) {
+    private void _assertDoubleValue(double expected, JsonNode node) {
+        assertEquals(expected, node.doubleValue());
+
+        // and defaults
+        assertEquals(expected, node.doubleValue(-9999.5));
+        assertEquals(expected, node.doubleValueOpt().getAsDouble());
+    }
+
+    private void _assertDoubleValueFailForValueRange(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.doubleValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
             .contains("cannot convert value")
             .contains("value not in 64-bit `double` range");
+
+        assertEquals(-2.25d, node.doubleValue(-2.25d));
+        assertEquals(OptionalDouble.empty(), node.doubleValueOpt());
     }
 
-    private void _assertFailDoubleForNonNumber(JsonNode node) {
+    private void _assertDoubleValueFailForNonNumber(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.doubleValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
             .contains("cannot convert value")
             .contains("value type not numeric");
-    }
 
-    private void _assertDefaultDoubleForOtherwiseFailing(JsonNode node) {
-        assertEquals(-2.25d, node.doubleValue(-2.25d));
+        assertEquals(1.5d, node.doubleValue(1.5d));
         assertEquals(OptionalDouble.empty(), node.doubleValueOpt());
     }
 
+    private void _assertAsDouble(double expected, JsonNode node) {
+        assertEquals(expected, node.asDouble());
+
+        // and defaults
+        assertEquals(expected, node.asDouble(-9999.5));
+        assertEquals(expected, node.asDoubleOpt().getAsDouble());
+    }
+
+    private void _assertAsDoubleFailForValueRange(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asDouble(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("asDouble()")
+            .contains("cannot convert value")
+            .contains("value not in 64-bit `double` range");
+
+        assertEquals(-2.25d, node.asDouble(-2.25d));
+        assertEquals(OptionalDouble.empty(), node.asDoubleOpt());
+    }
+
+    private void _assertAsDoubleFailForNonNumber(JsonNode node) {
+        _assertAsDoubleFailForNonNumber(node, "value type not numeric");
+    }
+
+    private void _assertAsDoubleFailForNonNumber(JsonNode node, String extraMatch) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asDouble(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("asDouble()")
+            .contains("cannot convert value")
+            .contains(extraMatch);
+
+        assertEquals(1.5d, node.asDouble(1.5d));
+        assertEquals(OptionalDouble.empty(), node.asDoubleOpt());
+    }
+
     // Just for manual verification
     /*
     public static void main(String[] args) {
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java
index 37fb75731..70de8afa4 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java
@@ -31,87 +31,26 @@ public class JsonNodeIntValueTest
     public void intValueFromNumberIntOk()
     {
         // First safe from `int`
-        assertEquals(1, NODES.numberNode(1).intValue());
-        assertEquals(1, NODES.numberNode(1).intValue(99));
-        assertEquals(1, NODES.numberNode(1).intValueOpt().getAsInt());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).intValue());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).intValue(99));
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).intValueOpt().getAsInt());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).intValue());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).intValue(99));
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).intValueOpt().getAsInt());
+        _assertIntValue(1, NODES.numberNode(1));
+        _assertIntValue(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertIntValue(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
 
         // Then other integer types
-        assertEquals(1, NODES.numberNode((byte) 1).intValue());
-        assertEquals(1, NODES.numberNode((byte) 1).intValue(99));
-        assertEquals(1, NODES.numberNode((byte) 1).intValue(99));
-        assertEquals((int)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).intValue());
-        assertEquals((int)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).intValue(99));
-        assertEquals((int)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).intValueOpt().getAsInt());
-        assertEquals((int)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).intValue());
-        assertEquals((int)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).intValue(99));
-        assertEquals((int)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).intValueOpt().getAsInt());
-
-        assertEquals(1, NODES.numberNode((short) 1).intValue());
-        assertEquals(1, NODES.numberNode((short) 1).intValue(99));
-        assertEquals(1, NODES.numberNode((short) 1).intValueOpt().getAsInt());
-        assertEquals((int)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).intValue());
-        assertEquals((int)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).intValue(99));
-        assertEquals((int)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).intValueOpt().getAsInt());
-        assertEquals((int)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).intValue());
-        assertEquals((int)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).intValue(99));
-        assertEquals((int)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).intValueOpt().getAsInt());
-
-        assertEquals(1, NODES.numberNode(1L).intValue());
-        assertEquals(1, NODES.numberNode(1L).intValue(99));
-        assertEquals(1, NODES.numberNode(1L).intValueOpt().getAsInt());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode((long) Integer.MIN_VALUE).intValue());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode((long) Integer.MIN_VALUE).intValue(99));
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode((long) Integer.MIN_VALUE).intValueOpt().getAsInt());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode((long) Integer.MAX_VALUE).intValue());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode((long) Integer.MAX_VALUE).intValue(99));
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode((long) Integer.MAX_VALUE).intValueOpt().getAsInt());
-
-        assertEquals(1, NODES.numberNode(BigInteger.valueOf(1)).intValue());
-        assertEquals(1, NODES.numberNode(BigInteger.valueOf(1)).intValue(99));
-        assertEquals(1, NODES.numberNode(BigInteger.valueOf(1)).intValueOpt().getAsInt());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MIN_VALUE)).intValue());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MIN_VALUE)).intValue(99));
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MIN_VALUE)).intValueOpt().getAsInt());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MAX_VALUE)).intValue());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MAX_VALUE)).intValue(99));
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MAX_VALUE)).intValueOpt().getAsInt());
-    }
-
-    @Test
-    public void shortValueFromNumberIntOk()
-    {
-        final short SHORT_1 = (short) 1;
-        final short MIN_SHORT = Short.MIN_VALUE;
-        final short MAX_SHORT = Short.MAX_VALUE;
-        
-        // First safe from `short`
-        assertEquals(SHORT_1, NODES.numberNode((short) 1).shortValue());
-        assertEquals((int)Short.MIN_VALUE, NODES.numberNode(MIN_SHORT).shortValue());
-        assertEquals((int)Short.MAX_VALUE, NODES.numberNode(MAX_SHORT).shortValue());
-
-        // Then other integer types
-
-        assertEquals(SHORT_1, NODES.numberNode((byte) 1).shortValue());
-        assertEquals((short) Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).shortValue());
-        assertEquals((short) Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).shortValue());
+        _assertIntValue(1, NODES.numberNode((byte) 1));
+        _assertIntValue((int)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertIntValue((int)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
 
-        assertEquals(SHORT_1, NODES.numberNode(1).shortValue());
-        assertEquals(MIN_SHORT, NODES.numberNode((int) MIN_SHORT).shortValue());
-        assertEquals(MAX_SHORT, NODES.numberNode((int) MAX_SHORT).shortValue());
+        _assertIntValue(1, NODES.numberNode((short) 1));
+        _assertIntValue((int)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertIntValue((int)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
 
-        assertEquals(SHORT_1, NODES.numberNode(1L).shortValue());
-        assertEquals(MIN_SHORT, NODES.numberNode((long) MIN_SHORT).shortValue());
-        assertEquals(MAX_SHORT, NODES.numberNode((long) MAX_SHORT).shortValue());
+        _assertIntValue(1, NODES.numberNode(1L));
+        _assertIntValue(Integer.MIN_VALUE, NODES.numberNode((long) Integer.MIN_VALUE));
+        _assertIntValue(Integer.MAX_VALUE, NODES.numberNode((long) Integer.MAX_VALUE));
 
-        assertEquals(SHORT_1, NODES.numberNode(BigInteger.valueOf(1)).shortValue());
-        assertEquals(MIN_SHORT, NODES.numberNode(BigInteger.valueOf(MIN_SHORT)).shortValue());
-        assertEquals(MAX_SHORT, NODES.numberNode(BigInteger.valueOf(MAX_SHORT)).shortValue());
+        _assertIntValue(1, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertIntValue(Integer.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MIN_VALUE)));
+        _assertIntValue(Integer.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MAX_VALUE)));
     }
 
     @Test
@@ -120,267 +59,374 @@ public class JsonNodeIntValueTest
         final long underflow = -1L + Integer.MIN_VALUE;
         final long overflow = +1L + Integer.MAX_VALUE;
 
-        _assertFailIntForValueRange(NODES.numberNode(underflow));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(underflow));
-        _assertFailIntForValueRange(NODES.numberNode(overflow));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(overflow));
+        _assertIntValueFailForValueRange(NODES.numberNode(underflow));
+        _assertIntValueFailForValueRange(NODES.numberNode(overflow));
 
-        _assertFailIntForValueRange(NODES.numberNode(BigInteger.valueOf(underflow)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigInteger.valueOf(underflow)));
-        _assertFailIntForValueRange(NODES.numberNode(BigInteger.valueOf(overflow)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigInteger.valueOf(overflow)));
+        _assertIntValueFailForValueRange(NODES.numberNode(BigInteger.valueOf(underflow)));
+        _assertIntValueFailForValueRange(NODES.numberNode(BigInteger.valueOf(overflow)));
+    }
+    
+    // // // intValue() + Numbers/FPs
+
+    @Test
+    public void intValueFromNumberFPOk()
+    {
+        _assertIntValue(1, NODES.numberNode(1.0f));
+        _assertIntValue(100_000, NODES.numberNode(100_000.0f));
+        _assertIntValue(-100_000, NODES.numberNode(-100_000.0f));
+
+        _assertIntValue(1, NODES.numberNode(1.0d));
+        _assertIntValue(100_000, NODES.numberNode(100_000.0d));
+        _assertIntValue(-100_000, NODES.numberNode(-100_000.0d));
+        _assertIntValue(Integer.MIN_VALUE, NODES.numberNode((double) Integer.MIN_VALUE));
+        _assertIntValue(Integer.MAX_VALUE, NODES.numberNode((double) Integer.MAX_VALUE));
+
+        _assertIntValue(1,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertIntValue(Integer.MIN_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Integer.MIN_VALUE)));
+        _assertIntValue(Integer.MAX_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Integer.MAX_VALUE)));
     }
 
     @Test
-    public void shortValueFromNumberIntFailRange() {
+    public void intValueFromNumberFPFailRange()
+    {
         // Can only fail for underflow/overflow: and that only for Long / BigInteger
-        final int underflow = -1 + Short.MIN_VALUE;
-        final int overflow = +1 + Short.MAX_VALUE;
+        final long underflow = Integer.MIN_VALUE - 1L;
+        final long overflow =  Integer.MAX_VALUE + 1L;
+
+        _assertIntValueFailForValueRange(NODES.numberNode((double)underflow));
+        _assertIntValueFailForValueRange(NODES.numberNode((double)overflow));
 
-        _assertFailShortForValueRange(NODES.numberNode(underflow));
-        _assertFailShortForValueRange(NODES.numberNode(overflow));
+        // Float is too inexact for using same test as Double, so:
+
+        _assertIntValueFailForValueRange(NODES.numberNode(-Float.MAX_VALUE));
+        _assertIntValueFailForValueRange(NODES.numberNode(Float.MAX_VALUE));
 
-        _assertFailShortForValueRange(NODES.numberNode(BigInteger.valueOf(underflow)));
-        _assertFailShortForValueRange(NODES.numberNode(BigInteger.valueOf(overflow)));
+        _assertIntValueFailForValueRange(NODES.numberNode(BigDecimal.valueOf(underflow)));
+        _assertIntValueFailForValueRange(NODES.numberNode(BigDecimal.valueOf(overflow)));
     }
     
-    // // // intValue() + Numbers/FPs
+    @Test
+    public void intValueFromNumberFPFailFraction()
+    {
+        _assertIntValueFailForFraction(NODES.numberNode(100.5f));
+        _assertIntValueFailForFraction(NODES.numberNode(-0.25f));
+
+        _assertIntValueFailForFraction(NODES.numberNode(100.5d));
+        _assertIntValueFailForFraction(NODES.numberNode(-0.25d));
+        
+        _assertIntValueFailForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
+        _assertIntValueFailForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+    }
 
     @Test
-    public void intValueFromNumberFPOk()
+    public void intValueFromNumberFPFailNaN()
+    {
+        _assertIntValueFailForNaN(NODES.numberNode(Float.NaN));
+        _assertIntValueFailForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+        _assertIntValueFailForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
+
+        _assertIntValueFailForNaN(NODES.numberNode(Double.NaN));
+        _assertIntValueFailForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+        _assertIntValueFailForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
+    }
+    
+    // // // intValue() + non-Numeric types
+
+    @Test
+    public void intValueFromNonNumberScalarFail()
     {
-        assertEquals(1, NODES.numberNode(1.0f).intValue());
-        assertEquals(1, NODES.numberNode(1.0f).intValue(99));
-        assertEquals(100_000, NODES.numberNode(100_000.0f).intValue());
-        assertEquals(100_000, NODES.numberNode(100_000.0f).intValue(99));
-        assertEquals(-100_000, NODES.numberNode(-100_000.0f).intValue());
-        assertEquals(-100_000, NODES.numberNode(-100_000.0f).intValue(99));
-
-        assertEquals(1, NODES.numberNode(1.0d).intValue());
-        assertEquals(1, NODES.numberNode(1.0d).intValue(99));
-        assertEquals(100_000, NODES.numberNode(100_000.0d).intValue());
-        assertEquals(100_000, NODES.numberNode(100_000.0d).intValue(99));
-        assertEquals(-100_000, NODES.numberNode(-100_000.0d).intValue());
-        assertEquals(-100_000, NODES.numberNode(-100_000.0d).intValue(99));
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode((double) Integer.MIN_VALUE).intValue());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode((double) Integer.MIN_VALUE).intValue(99));
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode((double) Integer.MAX_VALUE).intValue());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode((double) Integer.MAX_VALUE).intValue(99));
-
-        assertEquals(1,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).intValue());
-        assertEquals(1,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).intValue(99));
-        assertEquals(Integer.MIN_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Integer.MIN_VALUE)).intValue());
-        assertEquals(Integer.MIN_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Integer.MIN_VALUE)).intValue(99));
-        assertEquals(Integer.MAX_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Integer.MAX_VALUE)).intValue());
-        assertEquals(Integer.MAX_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Integer.MAX_VALUE)).intValue(99));
+        _assertIntValueFailForNonNumber(NODES.booleanNode(true));
+        _assertIntValueFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertIntValueFailForNonNumber(NODES.stringNode("123"));
+        _assertIntValueFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertIntValueFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
     }
 
     @Test
-    public void shortValueFromNumberFPOk()
+    public void intValueFromStructuralFail()
     {
-        assertEquals(1, NODES.numberNode(1.0f).shortValue());
-        assertEquals(10_000, NODES.numberNode(10_000.0f).shortValue());
-        assertEquals(-10_000, NODES.numberNode(-10_000.0f).shortValue());
-
-        assertEquals(1, NODES.numberNode(1.0d).shortValue());
-        assertEquals(10_000, NODES.numberNode(10_000.0d).shortValue());
-        assertEquals(-10_000, NODES.numberNode(-10_000.0d).shortValue());
-        assertEquals(Short.MIN_VALUE, NODES.numberNode((double) Short.MIN_VALUE).shortValue());
-        assertEquals(Short.MAX_VALUE, NODES.numberNode((double) Short.MAX_VALUE).shortValue());
-
-        assertEquals(1,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).shortValue());
-        assertEquals(Short.MIN_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Short.MIN_VALUE)).shortValue());
-        assertEquals(Short.MAX_VALUE,
-                NODES.numberNode(BigDecimal.valueOf((double) Short.MAX_VALUE)).shortValue());
+        _assertIntValueFailForNonNumber(NODES.arrayNode(3));
+        _assertIntValueFailForNonNumber(NODES.objectNode());
     }
 
     @Test
-    public void intValueFromNumberFPFailRange()
+    public void intValueFromMiscOtherFail()
     {
-        // Can only fail for underflow/overflow: and that only for Long / BigInteger
-        final long underflow = Integer.MIN_VALUE - 1L;
-        final long overflow =  Integer.MAX_VALUE + 1L;
+        _assertIntValueFailForNonNumber(NODES.nullNode());
+        _assertIntValueFailForNonNumber(NODES.missingNode());
+    }
 
-        _assertFailIntForValueRange(NODES.numberNode((double)underflow));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode((double)underflow));
-        _assertFailIntForValueRange(NODES.numberNode((double)overflow));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode((double)overflow));
+    // // // asInt()
+    
+    // Numbers/Integers
 
-        // Float is too inexact for using same test as Double, so:
+    @Test
+    public void asIntFromNumberIntOk()
+    {
+        // First safe from `int`
+        _assertAsInt(1, NODES.numberNode(1));
+        _assertAsInt(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertAsInt(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
+
+        // Then other integer types
+        _assertAsInt(1, NODES.numberNode((byte) 1));
+        _assertAsInt((int)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertAsInt((int)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertAsInt(1, NODES.numberNode((short) 1));
+        _assertAsInt((int)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertAsInt((int)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
 
-        _assertFailIntForValueRange(NODES.numberNode(-Float.MAX_VALUE));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(-Float.MAX_VALUE));
-        _assertFailIntForValueRange(NODES.numberNode(Float.MAX_VALUE));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(Float.MAX_VALUE));
+        _assertAsInt(1, NODES.numberNode(1L));
+        _assertAsInt(Integer.MIN_VALUE, NODES.numberNode((long) Integer.MIN_VALUE));
+        _assertAsInt(Integer.MAX_VALUE, NODES.numberNode((long) Integer.MAX_VALUE));
 
-        _assertFailIntForValueRange(NODES.numberNode(BigDecimal.valueOf(underflow)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(underflow)));
-        _assertFailIntForValueRange(NODES.numberNode(BigDecimal.valueOf(overflow)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(overflow)));
+        _assertAsInt(1, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertAsInt(Integer.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MIN_VALUE)));
+        _assertAsInt(Integer.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Integer.MAX_VALUE)));
     }
 
     @Test
-    public void shortValueFromNumberFPFailRange()
+    public void asIntFromNumberIntFailRange() {
+        // Can only fail for underflow/overflow: and that only for Long / BigInteger
+        final long underflow = -1L + Integer.MIN_VALUE;
+        final long overflow = +1L + Integer.MAX_VALUE;
+
+        _assertAsIntFailForValueRange(NODES.numberNode(underflow));
+        _assertAsIntFailForValueRange(NODES.numberNode(overflow));
+
+        _assertAsIntFailForValueRange(NODES.numberNode(BigInteger.valueOf(underflow)));
+        _assertAsIntFailForValueRange(NODES.numberNode(BigInteger.valueOf(overflow)));
+    }
+    
+    //  Numbers/FPs
+
+    @Test
+    public void asIntFromNumberFPOk()
+    {
+        _assertAsInt(1, NODES.numberNode(1.0f));
+        _assertAsInt(100_000, NODES.numberNode(100_000.0f));
+        _assertAsInt(-100_000, NODES.numberNode(-100_000.0f));
+
+        _assertAsInt(1, NODES.numberNode(1.0d));
+        _assertAsInt(100_000, NODES.numberNode(100_000.0d));
+        _assertAsInt(-100_000, NODES.numberNode(-100_000.0d));
+        _assertAsInt(Integer.MIN_VALUE, NODES.numberNode((double) Integer.MIN_VALUE));
+        _assertAsInt(Integer.MAX_VALUE, NODES.numberNode((double) Integer.MAX_VALUE));
+
+        _assertAsInt(1,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertAsInt(Integer.MIN_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Integer.MIN_VALUE)));
+        _assertAsInt(Integer.MAX_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Integer.MAX_VALUE)));
+    }
+
+    @Test
+    public void asIntFromNumberFPFailRange()
     {
         // Can only fail for underflow/overflow: and that only for Long / BigInteger
-        final long underflow = Short.MIN_VALUE - 1L;
-        final long overflow =  Short.MAX_VALUE + 1L;
+        final long underflow = Integer.MIN_VALUE - 1L;
+        final long overflow =  Integer.MAX_VALUE + 1L;
 
-        _assertFailShortForValueRange(NODES.numberNode((double)underflow));
-        _assertFailShortForValueRange(NODES.numberNode((double)overflow));
+        _assertAsIntFailForValueRange(NODES.numberNode((double)underflow));
+        _assertAsIntFailForValueRange(NODES.numberNode((double)overflow));
 
         // Float is too inexact for using same test as Double, so:
 
-        _assertFailShortForValueRange(NODES.numberNode(-Float.MAX_VALUE));
-        _assertFailShortForValueRange(NODES.numberNode(Float.MAX_VALUE));
+        _assertAsIntFailForValueRange(NODES.numberNode(-Float.MAX_VALUE));
+        _assertAsIntFailForValueRange(NODES.numberNode(Float.MAX_VALUE));
 
-        _assertFailShortForValueRange(NODES.numberNode(BigDecimal.valueOf(underflow)));
-        _assertFailShortForValueRange(NODES.numberNode(BigDecimal.valueOf(overflow)));
+        _assertAsIntFailForValueRange(NODES.numberNode(BigDecimal.valueOf(underflow)));
+        _assertAsIntFailForValueRange(NODES.numberNode(BigDecimal.valueOf(overflow)));
     }
     
     @Test
-    public void intValueFromNumberFPFailFraction()
+    public void asIntFromNumberFPWithFraction()
     {
-        _assertFailIntValueForFraction(NODES.numberNode(100.5f));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(100.5f));
-        _assertFailIntValueForFraction(NODES.numberNode(-0.25f));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(-0.25f));
-
-        _assertFailIntValueForFraction(NODES.numberNode(100.5d));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(100.5d));
-        _assertFailIntValueForFraction(NODES.numberNode(-0.25d));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(-0.25d));
+        _assertAsInt(100, NODES.numberNode(100.75f));
+        _assertAsInt(-1, NODES.numberNode(-1.25f));
+
+        _assertAsInt(100, NODES.numberNode(100.75d));
+        _assertAsInt(-1, NODES.numberNode(-1.25d));
         
-        _assertFailIntValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertFailIntValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
-        _assertDefaultIntForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+        _assertAsInt(100, NODES.numberNode(BigDecimal.valueOf(100.75d)));
+        _assertAsInt(-1, NODES.numberNode(BigDecimal.valueOf(-1.25d)));
     }
 
     @Test
-    public void shortValueFromNumberFPFailFraction()
+    public void asIntFromNumberFPFailNaN()
     {
-        _assertFailShortValueForFraction(NODES.numberNode(100.5f));
-        _assertFailShortValueForFraction(NODES.numberNode(-0.25f));
+        _assertAsIntFailForNaN(NODES.numberNode(Float.NaN));
+        _assertAsIntFailForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+        _assertAsIntFailForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
 
-        _assertFailShortValueForFraction(NODES.numberNode(100.5d));
-        _assertFailShortValueForFraction(NODES.numberNode(-0.25d));
-        
-        _assertFailShortValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertFailShortValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+        _assertAsIntFailForNaN(NODES.numberNode(Double.NaN));
+        _assertAsIntFailForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+        _assertAsIntFailForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
     }
-
-    // // // intValue() + non-Numeric types
+    
+    // non-Numeric types
 
     @Test
-    public void intValueFromNonNumberScalarFail()
+    public void asIntFromNonNumberScalar()
     {
-        _assertFailIntForNonNumber(NODES.booleanNode(true));
-        _assertDefaultIntForOtherwiseFailing(NODES.booleanNode(true));
-        _assertFailIntForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertDefaultIntForOtherwiseFailing(NODES.binaryNode(new byte[3]));
-        _assertFailIntForNonNumber(NODES.stringNode("123"));
-        _assertDefaultIntForOtherwiseFailing(NODES.stringNode("123"));
-        _assertFailIntForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertDefaultIntForOtherwiseFailing(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailIntForNonNumber(NODES.pojoNode(Boolean.TRUE));
-        _assertDefaultIntForOtherwiseFailing(NODES.pojoNode(Boolean.TRUE));
-    }
+        // Some fail:
+        _assertAsIntFailForNonNumber(NODES.booleanNode(true));
+        _assertAsIntFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertAsIntFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertAsIntFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
 
-    @Test
-    public void shortValueFromNonNumberScalarFail()
-    {
-        _assertFailShortForNonNumber(NODES.booleanNode(true));
-        _assertFailShortForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertFailShortForNonNumber(NODES.stringNode("123"));
-        _assertFailShortForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailShortForNonNumber(NODES.pojoNode(Boolean.TRUE));
+        _assertAsIntFailForNonNumber(NODES.stringNode("abc"),
+                "value not a valid String representation of `int`");
+
+        // Some pass:
+
+        _assertAsInt(456, NODES.pojoNode(456));
+        _assertAsInt(123, NODES.stringNode("123"));
     }
 
     @Test
-    public void intValueFromStructuralFail()
+    public void asIntFromStructuralFail()
     {
-        _assertFailIntForNonNumber(NODES.arrayNode(3));
-        _assertDefaultIntForOtherwiseFailing(NODES.arrayNode(3));
-        _assertFailIntForNonNumber(NODES.objectNode());
-        _assertDefaultIntForOtherwiseFailing(NODES.objectNode());
+        _assertAsIntFailForNonNumber(NODES.arrayNode(3));
+        _assertAsIntFailForNonNumber(NODES.objectNode());
     }
 
     @Test
-    public void intValueFromMiscOtherFail()
+    public void asIntFromMiscOther()
     {
-        _assertFailIntForNonNumber(NODES.nullNode());
-        _assertDefaultIntForOtherwiseFailing(NODES.nullNode());
-        _assertFailIntForNonNumber(NODES.missingNode());
-        _assertDefaultIntForOtherwiseFailing(NODES.missingNode());
+        // NullNode -> 0 but "missing" still fails
+        _assertAsInt(0, NODES.nullNode());
+
+        _assertAsIntFailForNonNumber(NODES.missingNode());
     }
+    
+    // // // Shared helper methods: intValue()
 
-    // // // Shared helper methods
+    private void _assertIntValue(int expected, JsonNode node) {
+        assertEquals(expected, node.intValue());
 
-    private void _assertFailIntForValueRange(JsonNode node) {
+        // and defaulting
+
+        assertEquals(expected, node.intValue(999_999));
+        assertEquals(expected, node.intValueOpt().getAsInt());
+    }
+
+    private void _assertIntValueFailForValueRange(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.intValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("intValue()")
             .contains("cannot convert value")
             .contains("value not in 32-bit `int` range");
+
+        // assert defaulting
+        assertEquals(99, node.intValue(99));
+        assertEquals(OptionalInt.empty(), node.intValueOpt());
     }
 
-    private void _assertFailShortForValueRange(JsonNode node) {
+    private void _assertIntValueFailForFraction(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.shortValue(),
+                () ->  node.intValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("intValue()")
             .contains("cannot convert value")
-            .contains("value not in 16-bit `short` range");
+            .contains("to `int`: value has fractional part");
+
+        // assert defaulting
+        assertEquals(99, node.intValue(99));
+        assertEquals(OptionalInt.empty(), node.intValueOpt());
     }
 
-    private void _assertFailIntValueForFraction(JsonNode node) {
+    private void _assertIntValueFailForNonNumber(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.intValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("intValue()")
             .contains("cannot convert value")
-            .contains("to `int`: value has fractional part");
+            .contains("value type not numeric");
+
+        // assert defaulting
+        assertEquals(99, node.intValue(99));
+        assertEquals(OptionalInt.empty(), node.intValueOpt());
     }
 
-    private void _assertFailShortValueForFraction(JsonNode node) {
+    private void _assertIntValueFailForNaN(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.shortValue(),
+                () ->  node.intValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("intValue()")
             .contains("cannot convert value")
-            .contains("to `short`: value has fractional part");
+            .contains("value non-Finite");
+
+        // Verify default value handling
+        assertEquals(1, node.intValue(1));
+        assertFalse(node.intValueOpt().isPresent());
     }
 
-    private void _assertFailIntForNonNumber(JsonNode node) {
+    // // // Shared helper methods: asInt()
+
+    private void _assertAsInt(int expected, JsonNode node) {
+        assertEquals(expected, node.asInt());
+
+        // and defaulting
+
+        assertEquals(expected, node.asInt(999_999));
+        assertEquals(expected, node.asIntOpt().getAsInt());
+    }
+
+    private void _assertAsIntFailForValueRange(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.intValue(),
+                () ->  node.asInt(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("asInt()")
             .contains("cannot convert value")
-            .contains("value type not numeric");
+            .contains("value not in 32-bit `int` range");
+
+        // assert defaulting
+        assertEquals(99, node.asInt(99));
+        assertEquals(OptionalInt.empty(), node.asIntOpt());
+    }
+
+    private void _assertAsIntFailForNonNumber(JsonNode node) {
+        _assertAsIntFailForNonNumber(node, "value type not numeric");
     }
 
-    private void _assertFailShortForNonNumber(JsonNode node) {
+    private void _assertAsIntFailForNonNumber(JsonNode node, String extraFailMsg) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.shortValue(),
+                () ->  node.asInt(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("asInt()")
             .contains("cannot convert value")
-            .contains("value type not numeric");
+            .contains(extraFailMsg);
+
+        // assert defaulting
+        assertEquals(99, node.asInt(99));
+        assertEquals(OptionalInt.empty(), node.asIntOpt());
     }
 
-    private void _assertDefaultIntForOtherwiseFailing(JsonNode node) {
-        assertEquals(99, node.intValue(99));
-        assertEquals(OptionalInt.empty(), node.intValueOpt());
+    private void _assertAsIntFailForNaN(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asInt(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+        .contains("asInt()")
+            .contains("cannot convert value")
+            .contains("value non-Finite");
+
+        // Verify default value handling
+        assertEquals(1, node.asInt(1));
+        assertFalse(node.asIntOpt().isPresent());
     }
+
 }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java
index ae652e3c1..0ceb30849 100644
--- a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java
@@ -2,7 +2,6 @@ package tools.jackson.databind.node;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.OptionalLong;
 
 import org.junit.jupiter.api.Test;
 
@@ -16,167 +15,71 @@ import static org.junit.jupiter.api.Assertions.*;
 /**
  * Tests for [databind#4958], JsonNode.longValue() (and related) parts
  * over all types.
- *<p>
- * Also contains tests for {@code JsonNode.bigIntegerValue()}.
  */
 public class JsonNodeLongValueTest
     extends NodeTestBase
 {
     private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
 
-    // // // longValue() + Numbers/Integers
+    // longValue() + Numbers/Integers
 
     @Test
     public void longValueFromNumberIntOk()
     {
         // First safe from `long`
-        assertEquals(1L, NODES.numberNode(1L).longValue());
-        assertEquals(1L, NODES.numberNode(1L).longValue(99L));
-        assertEquals(1L, NODES.numberNode(1L).longValueOpt().getAsLong());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValue());
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValue(99L));
-        assertEquals(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValueOpt().getAsLong());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValue());
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValue(99L));
-        assertEquals(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValueOpt().getAsLong());
+        _assertLongValue(1L, NODES.numberNode(1L));
+        _assertLongValue(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertLongValue(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
 
         // Then other integer types, byte/short/int
-        assertEquals(1L, NODES.numberNode((byte) 1).longValue());
-        assertEquals(1L, NODES.numberNode((byte) 1).longValue(99L));
-        assertEquals(1L, NODES.numberNode((byte) 1).longValue(99L));
-        assertEquals((long)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).longValue());
-        assertEquals((long)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).longValue(99L));
-        assertEquals((long)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).longValueOpt().getAsLong());
-        assertEquals((long)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).longValue());
-        assertEquals((long)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).longValue(99L));
-        assertEquals((long)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).longValueOpt().getAsLong());
-
-        assertEquals(1L, NODES.numberNode((short) 1).longValue());
-        assertEquals(1L, NODES.numberNode((short) 1).longValue(99));
-        assertEquals(1L, NODES.numberNode((short) 1).longValueOpt().getAsLong());
-        assertEquals((long)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).longValue());
-        assertEquals((long)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).longValue(99L));
-        assertEquals((long)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE).longValueOpt().getAsLong());
-        assertEquals((long)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).longValue());
-        assertEquals((long)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).longValue(99L));
-        assertEquals((long)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE).longValueOpt().getAsLong());
-
-        assertEquals(1L, NODES.numberNode(1).longValue());
-        assertEquals(1L, NODES.numberNode(1).longValue(99));
-        assertEquals(1L, NODES.numberNode(1).longValueOpt().getAsLong());
-        assertEquals((long) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValue());
-        assertEquals((long) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValue(99));
-        assertEquals((long) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE).longValueOpt().getAsLong());
-        assertEquals((long) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValue());
-        assertEquals((long) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValue(99));
-        assertEquals((long) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE).longValueOpt().getAsLong());
-
-        assertEquals(1L, NODES.numberNode(BigInteger.valueOf(1)).longValue());
-        assertEquals(1L, NODES.numberNode(BigInteger.valueOf(1)).longValue(99L));
-        assertEquals(1L, NODES.numberNode(BigInteger.valueOf(1)).longValueOpt().getAsLong());
-        assertEquals(Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).longValue());
-        assertEquals(Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).longValue(99));
-        assertEquals(Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)).longValueOpt().getAsLong());
-        assertEquals(Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).longValue());
-        assertEquals(Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).longValue(99));
-        assertEquals(Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)).longValueOpt().getAsLong());
-    }
+        _assertLongValue(1L, NODES.numberNode((byte) 1));
+        _assertLongValue((long)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertLongValue((long)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
 
-    @Test
-    public void bigIntegerValueFromNumberIntOk()
-    {
-        // Integer types, byte/short/int/long/BigInteger
-        assertEquals(BigInteger.ONE, NODES.numberNode((byte) 1).bigIntegerValue());
-        assertEquals(bigInt(Byte.MIN_VALUE), NODES.numberNode(Byte.MIN_VALUE).bigIntegerValue());
-        assertEquals(bigInt(Byte.MAX_VALUE), NODES.numberNode(Byte.MAX_VALUE).bigIntegerValue());
-
-        assertEquals(BigInteger.ONE, NODES.numberNode((short) 1).bigIntegerValue());
-        assertEquals(bigInt(Short.MIN_VALUE), NODES.numberNode(Short.MIN_VALUE).bigIntegerValue());
-        assertEquals(bigInt(Short.MAX_VALUE), NODES.numberNode(Short.MAX_VALUE).bigIntegerValue());
-
-        assertEquals(BigInteger.ONE, NODES.numberNode(1).bigIntegerValue());
-        assertEquals(bigInt(Integer.MIN_VALUE), NODES.numberNode(Integer.MIN_VALUE).bigIntegerValue());
-        assertEquals(bigInt(Integer.MAX_VALUE), NODES.numberNode(Integer.MAX_VALUE).bigIntegerValue());
-
-        assertEquals(BigInteger.ONE, NODES.numberNode(1L).bigIntegerValue());
-        assertEquals(bigInt(Long.MIN_VALUE), NODES.numberNode(Long.MIN_VALUE).bigIntegerValue());
-        assertEquals(bigInt(Long.MAX_VALUE), NODES.numberNode(Long.MAX_VALUE).bigIntegerValue());
-
-        assertEquals(BigInteger.ONE, NODES.numberNode(BigInteger.ONE).bigIntegerValue());
-        assertEquals(BigInteger.valueOf(Long.MIN_VALUE),
-                NODES.numberNode(Long.MIN_VALUE).bigIntegerValue());
-        assertEquals(BigInteger.valueOf(Long.MAX_VALUE),
-                NODES.numberNode(Long.MAX_VALUE).bigIntegerValue());
+        _assertLongValue(1L, NODES.numberNode((short) 1));
+        _assertLongValue((long)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertLongValue((long)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
+
+        _assertLongValue(1L, NODES.numberNode(1));
+        _assertLongValue((long) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertLongValue((long) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
+
+        _assertLongValue(1L, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertLongValue(Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertLongValue(Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
     }
-    
+
     @Test
     public void longValueFromNumberIntFailRange() {
         // Can only fail for underflow/overflow: and that only for Long / BigInteger
         final BigInteger underflow = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE);
         final BigInteger overflow = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
-
-        _assertFailLongForValueRange(NODES.numberNode(underflow));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(underflow));
-        _assertFailLongForValueRange(NODES.numberNode(overflow));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(overflow));
+    
+        _assertLongValueFailForValueRange(NODES.numberNode(underflow));
+        _assertLongValueFailForValueRange(NODES.numberNode(overflow));
     }
 
-    // NOTE: conversion from JSON Integer cannot fail for BigInteger wrt range, hence no tests
-    
-    // // // longValue() + Numbers/FPs
+    // longValue() + Numbers/FPs
 
     @Test
     public void longValueFromNumberFPOk()
     {
-        assertEquals(1, NODES.numberNode(1.0f).longValue());
-        assertEquals(1, NODES.numberNode(1.0f).longValue(99));
-        assertEquals(100_000, NODES.numberNode(100_000.0f).longValue());
-        assertEquals(100_000, NODES.numberNode(100_000.0f).longValue(99));
-        assertEquals(-100_000, NODES.numberNode(-100_000.0f).longValue());
-        assertEquals(-100_000, NODES.numberNode(-100_000.0f).longValue(99));
-
-        assertEquals(1, NODES.numberNode(1.0d).longValue());
-        assertEquals(1, NODES.numberNode(1.0d).longValue(99));
-        assertEquals(100_000, NODES.numberNode(100_000.0d).longValue());
-        assertEquals(100_000, NODES.numberNode(100_000.0d).longValue(99));
-        assertEquals(-100_000, NODES.numberNode(-100_000.0d).longValue());
-        assertEquals(-100_000, NODES.numberNode(-100_000.0d).longValue(99));
-        assertEquals(Long.MIN_VALUE, NODES.numberNode((double) Long.MIN_VALUE).longValue());
-        assertEquals(Long.MIN_VALUE, NODES.numberNode((double) Long.MIN_VALUE).longValue(99));
-        assertEquals(Long.MAX_VALUE, NODES.numberNode((double) Long.MAX_VALUE).longValue());
-        assertEquals(Long.MAX_VALUE, NODES.numberNode((double) Long.MAX_VALUE).longValue(99));
-
-        assertEquals(1,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).longValue());
-        assertEquals(1,
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).longValue(99));
-        assertEquals(Long.MIN_VALUE,
-                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")).longValue());
-        assertEquals(Long.MIN_VALUE,
-                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")).longValue(99));
-        assertEquals(Long.MAX_VALUE,
-                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")).longValue());
-        assertEquals(Long.MAX_VALUE,
-                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")).longValue(99));
-    }
-
-    @Test
-    public void bigIntegerValueFromNumberFPOk()
-    {
-        assertEquals(BigInteger.ONE, NODES.numberNode(1.0f).bigIntegerValue());
-        assertEquals(bigInt(100_000), NODES.numberNode(100_000.0f).bigIntegerValue());
-        assertEquals(bigInt(-100_000), NODES.numberNode(-100_000.0f).bigIntegerValue());
-
-        assertEquals(bigInt(1), NODES.numberNode(1.0d).bigIntegerValue());
-        assertEquals(bigInt(100_000_000), NODES.numberNode(100_000_000.0d).bigIntegerValue());
-        assertEquals(bigInt(-100_000_000), NODES.numberNode(-100_000_000.0d).bigIntegerValue());
-
-        assertEquals(bigInt(1),
-                NODES.numberNode(BigDecimal.valueOf(1.0d)).bigIntegerValue());
-        assertEquals(bigInt(Long.MIN_VALUE),
-                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")).bigIntegerValue());
-        assertEquals(bigInt(Long.MAX_VALUE),
-                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")).bigIntegerValue());
+        _assertLongValue(1, NODES.numberNode(1.0f));
+        _assertLongValue(100_000, NODES.numberNode(100_000.0f));
+        _assertLongValue(-100_000, NODES.numberNode(-100_000.0f));
+
+        _assertLongValue(1, NODES.numberNode(1.0d));
+        _assertLongValue(100_000, NODES.numberNode(100_000.0d));
+        _assertLongValue(-100_000, NODES.numberNode(-100_000.0d));
+        _assertLongValue(Long.MIN_VALUE, NODES.numberNode((double) Long.MIN_VALUE));
+        _assertLongValue(Long.MAX_VALUE, NODES.numberNode((double) Long.MAX_VALUE));
+
+        _assertLongValue(1,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertLongValue(Long.MIN_VALUE,
+                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")));
+        _assertLongValue(Long.MAX_VALUE,
+                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")));
     }
 
     @Test
@@ -187,169 +90,336 @@ public class JsonNodeLongValueTest
         final double underflow_d = -Double.MAX_VALUE;
         final double overflow_d = Double.MAX_VALUE;
 
-        _assertFailLongForValueRange(NODES.numberNode(underflow_d));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(underflow_d));
-        _assertFailLongForValueRange(NODES.numberNode(overflow_d));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(overflow_d));
+        _assertLongValueFailForValueRange(NODES.numberNode(underflow_d));
+        _assertLongValueFailForValueRange(NODES.numberNode(overflow_d));
 
-        _assertFailLongForValueRange(NODES.numberNode(-Float.MAX_VALUE));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(-Float.MAX_VALUE));
-        _assertFailLongForValueRange(NODES.numberNode(Float.MAX_VALUE));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(Float.MAX_VALUE));
+        _assertLongValueFailForValueRange(NODES.numberNode(-Float.MAX_VALUE));
+        _assertLongValueFailForValueRange(NODES.numberNode(Float.MAX_VALUE));
 
         // But for BigDecimal can do exact check
         
         final BigDecimal underflow_big = BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE);
         final BigDecimal overflow_big = BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE);
 
-        _assertFailLongForValueRange(NODES.numberNode(underflow_big));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(underflow_big));
-        _assertFailLongForValueRange(NODES.numberNode(overflow_big));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(overflow_big));
+        _assertLongValueFailForValueRange(NODES.numberNode(underflow_big));
+        _assertLongValueFailForValueRange(NODES.numberNode(overflow_big));
     }
 
-    // NOTE: BigInteger has unlimited range so cannot fail for Under-/Overflow (hence no tests)
-
     @Test
     public void longValueFromNumberFPFailFraction()
     {
-        _assertFailLongValueForFraction(NODES.numberNode(100.5f));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(100.5f));
-        _assertFailLongValueForFraction(NODES.numberNode(-0.25f));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(-0.25f));
-
-        _assertFailLongValueForFraction(NODES.numberNode(100.5d));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(100.5d));
-        _assertFailLongValueForFraction(NODES.numberNode(-0.25d));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(-0.25d));
-        
-        _assertFailLongValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertFailLongValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
-        _assertDefaultLongForOtherwiseFailing(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+        _assertLongValueFailForFraction(NODES.numberNode(100.5f));
+        _assertLongValueFailForFraction(NODES.numberNode(-0.25f));
+
+        _assertLongValueFailForFraction(NODES.numberNode(100.5d));
+        _assertLongValueFailForFraction(NODES.numberNode(-0.25d));
+
+        _assertLongValueFailForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
+        _assertLongValueFailForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
     }
 
     @Test
-    public void bigIntegerValueFromNumberFPFailFraction()
+    public void longValueFromNumberFPFailNaN()
     {
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(100.5f));
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(-0.25f));
+        _assertLongValueFailForNaN(NODES.numberNode(Float.NaN));
+        _assertLongValueFailForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+        _assertLongValueFailForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
 
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(100.5d));
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(-0.25d));
-        
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
-        _assertFailBigIntegerValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+        _assertLongValueFailForNaN(NODES.numberNode(Double.NaN));
+        _assertLongValueFailForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+        _assertLongValueFailForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
     }
 
-    // // // longValue() + non-Numeric types
+    // longValue() + non-Numeric types
 
     @Test
     public void longValueFromNonNumberScalarFail()
     {
-        _assertFailLongForNonNumber(NODES.booleanNode(true));
-        _assertDefaultLongForOtherwiseFailing(NODES.booleanNode(true));
-        _assertFailLongForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertDefaultLongForOtherwiseFailing(NODES.binaryNode(new byte[3]));
-        _assertFailLongForNonNumber(NODES.stringNode("123"));
-        _assertDefaultLongForOtherwiseFailing(NODES.stringNode("123"));
-        _assertFailLongForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertDefaultLongForOtherwiseFailing(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailLongForNonNumber(NODES.pojoNode(Boolean.TRUE));
-        _assertDefaultLongForOtherwiseFailing(NODES.pojoNode(Boolean.TRUE));
+        _assertLongValueFailForNonNumber(NODES.booleanNode(true));
+        _assertLongValueFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertLongValueFailForNonNumber(NODES.stringNode("123"));
+        _assertLongValueFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertLongValueFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
     }
 
     @Test
-    public void bigIntegerValueFromNonNumberScalarFail()
+    public void longValueFromStructuralFail()
     {
-        _assertFailBigIntegerForNonNumber(NODES.booleanNode(true));
-        _assertFailBigIntegerForNonNumber(NODES.binaryNode(new byte[3]));
-        _assertFailBigIntegerForNonNumber(NODES.stringNode("123"));
-        _assertFailBigIntegerForNonNumber(NODES.rawValueNode(new RawValue("abc")));
-        _assertFailBigIntegerForNonNumber(NODES.pojoNode(Boolean.TRUE));
+        _assertLongValueFailForNonNumber(NODES.arrayNode(3));
+        _assertLongValueFailForNonNumber(NODES.objectNode());
     }
 
     @Test
-    public void longValueFromStructuralFail()
+    public void longValueFromMiscOtherFail()
     {
-        _assertFailLongForNonNumber(NODES.arrayNode(3));
-        _assertDefaultLongForOtherwiseFailing(NODES.arrayNode(3));
-        _assertFailLongForNonNumber(NODES.objectNode());
-        _assertDefaultLongForOtherwiseFailing(NODES.objectNode());
+        _assertLongValueFailForNonNumber(NODES.nullNode());
+        _assertLongValueFailForNonNumber(NODES.missingNode());
     }
 
+    // // // asLong() tests
+
     @Test
-    public void bigIntegerValueFromStructuralFail()
+    public void asLongFromNumberIntOk()
     {
-        _assertFailBigIntegerForNonNumber(NODES.arrayNode(3));
-        _assertFailBigIntegerForNonNumber(NODES.objectNode());
+        // First safe from `long`
+        _assertAsLong(1L, NODES.numberNode(1L));
+        _assertAsLong(Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertAsLong(Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
+
+        // Then other integer types, byte/short/int
+        _assertAsLong(1L, NODES.numberNode((byte) 1));
+        _assertAsLong((long)Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE));
+        _assertAsLong((long)Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE));
+
+        _assertAsLong(1L, NODES.numberNode((short) 1));
+        _assertAsLong((long)Short.MIN_VALUE, NODES.numberNode(Short.MIN_VALUE));
+        _assertAsLong((long)Short.MAX_VALUE, NODES.numberNode(Short.MAX_VALUE));
+
+        _assertAsLong(1L, NODES.numberNode(1));
+        _assertAsLong((long) Integer.MIN_VALUE, NODES.numberNode(Integer.MIN_VALUE));
+        _assertAsLong((long) Integer.MAX_VALUE, NODES.numberNode(Integer.MAX_VALUE));
+
+        _assertAsLong(1L, NODES.numberNode(BigInteger.valueOf(1)));
+        _assertAsLong(Long.MIN_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MIN_VALUE)));
+        _assertAsLong(Long.MAX_VALUE, NODES.numberNode(BigInteger.valueOf(Long.MAX_VALUE)));
     }
 
     @Test
-    public void longValueFromMiscOtherFail()
+    public void asLongFromNumberIntFailRange() {
+        // Can only fail for underflow/overflow: and that only for Long / BigInteger
+        final BigInteger underflow = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE);
+        final BigInteger overflow = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
+    
+        _assertAsLongFailForValueRange(NODES.numberNode(underflow));
+        _assertAsLongFailForValueRange(NODES.numberNode(overflow));
+    }
+
+    // longValue() + Numbers/FPs
+
+    @Test
+    public void asLongFromNumberFPOk()
     {
-        _assertFailLongForNonNumber(NODES.nullNode());
-        _assertDefaultLongForOtherwiseFailing(NODES.nullNode());
-        _assertFailLongForNonNumber(NODES.missingNode());
-        _assertDefaultLongForOtherwiseFailing(NODES.missingNode());
+        _assertAsLong(1, NODES.numberNode(1.0f));
+        _assertAsLong(100_000, NODES.numberNode(100_000.0f));
+        _assertAsLong(-100_000, NODES.numberNode(-100_000.0f));
+
+        _assertAsLong(1, NODES.numberNode(1.0d));
+        _assertAsLong(100_000, NODES.numberNode(100_000.0d));
+        _assertAsLong(-100_000, NODES.numberNode(-100_000.0d));
+        _assertAsLong(Long.MIN_VALUE, NODES.numberNode((double) Long.MIN_VALUE));
+        _assertAsLong(Long.MAX_VALUE, NODES.numberNode((double) Long.MAX_VALUE));
+
+        _assertAsLong(1,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)));
+        _assertAsLong(Long.MIN_VALUE,
+                NODES.numberNode(new BigDecimal(Long.MIN_VALUE+".0")));
+        _assertAsLong(Long.MAX_VALUE,
+                NODES.numberNode(new BigDecimal(Long.MAX_VALUE+".0")));
     }
 
     @Test
-    public void bigIntegerValueFromMiscOtherFail()
+    public void asLongFromNumberFPFailRange()
     {
-        _assertFailBigIntegerForNonNumber(NODES.nullNode());
-        _assertFailBigIntegerForNonNumber(NODES.missingNode());
+        // For Float and Double both it's tricky to do too-big/too-small accurately so
+
+        final double underflow_d = -Double.MAX_VALUE;
+        final double overflow_d = Double.MAX_VALUE;
+
+        _assertAsLongFailForValueRange(NODES.numberNode(underflow_d));
+        _assertAsLongFailForValueRange(NODES.numberNode(overflow_d));
+
+        _assertAsLongFailForValueRange(NODES.numberNode(-Float.MAX_VALUE));
+        _assertAsLongFailForValueRange(NODES.numberNode(Float.MAX_VALUE));
+
+        // But for BigDecimal can do exact check
+        
+        final BigDecimal underflow_big = BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE);
+        final BigDecimal overflow_big = BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE);
+
+        _assertAsLongFailForValueRange(NODES.numberNode(underflow_big));
+        _assertAsLongFailForValueRange(NODES.numberNode(overflow_big));
     }
 
-    // // // Shared helper methods
+    @Test
+    public void asLongFromNumberFPWithFraction()
+    {
+        _assertAsLong(100L, NODES.numberNode(100.75f));
+        _assertAsLong(-1L, NODES.numberNode(-1.25f));
+
+        _assertAsLong(100L, NODES.numberNode(100.75d));
+        _assertAsLong(-1L, NODES.numberNode(-1.25d));
+
+        _assertAsLong(100L, NODES.numberNode(BigDecimal.valueOf(100.75d)));
+        _assertAsLong(-1L, NODES.numberNode(BigDecimal.valueOf(-1.25d)));
+    }
 
-    private void _assertFailLongForValueRange(JsonNode node) {
+    @Test
+    public void asLongFromNumberFPFailNaN()
+    {
+        _assertAsLongFailForNaN(NODES.numberNode(Float.NaN));
+        _assertAsLongFailForNaN(NODES.numberNode(Float.NEGATIVE_INFINITY));
+        _assertAsLongFailForNaN(NODES.numberNode(Float.POSITIVE_INFINITY));
+
+        _assertAsLongFailForNaN(NODES.numberNode(Double.NaN));
+        _assertAsLongFailForNaN(NODES.numberNode(Double.NEGATIVE_INFINITY));
+        _assertAsLongFailForNaN(NODES.numberNode(Double.POSITIVE_INFINITY));
+    }
+
+    // longValue() + non-Numeric types
+
+    @Test
+    public void asLongFromNonNumberScalarFail()
+    {
+        // Some fail;
+        _assertAsLongFailForNonNumber(NODES.booleanNode(true));
+        _assertAsLongFailForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertAsLongFailForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertAsLongFailForNonNumber(NODES.pojoNode(Boolean.TRUE));
+        _assertAsLongFailForNonNumber(NODES.stringNode("abcdef"), "not a valid String representation of `long`");
+
+        // Some pass
+        _assertAsLong(123456L, NODES.pojoNode(123456L));
+        _assertAsLong(1234L, NODES.stringNode("1234"));
+    }
+
+    @Test
+    public void asLongFromStructuralFail()
+    {
+        _assertAsLongFailForNonNumber(NODES.arrayNode(3));
+        _assertAsLongFailForNonNumber(NODES.objectNode());
+    }
+
+    @Test
+    public void asLongFromMiscOther()
+    {
+        // NullNode works, Missing fails
+        _assertAsLong(0L, NODES.nullNode());
+
+        _assertAsLongFailForNonNumber(NODES.missingNode());
+    }
+    
+    // // // Shared helper methods, longValue()
+
+    private void _assertLongValue(long expected, JsonNode node)
+    {
+        assertEquals(expected, node.longValue());
+
+        // But also fallbacks
+        assertEquals(expected, node.longValue(999999L));
+        assertEquals(expected, node.longValueOpt().getAsLong());
+    }
+
+    private void _assertLongValueFailForValueRange(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.longValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("longValue()")
             .contains("cannot convert value")
             .contains("value not in 64-bit `long` range");
+
+        // Verify default value handling
+        assertEquals(1L, node.longValue(1L));
+        assertFalse(node.longValueOpt().isPresent());
     }
 
-    private void _assertFailLongValueForFraction(JsonNode node) {
+    private void _assertLongValueFailForFraction(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.longValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("longValue()")
             .contains("cannot convert value")
             .contains("to `long`: value has fractional part");
+
+        // Verify default value handling
+        assertEquals(1L, node.longValue(1L));
+        assertFalse(node.longValueOpt().isPresent());
     }
 
-    private void _assertFailBigIntegerValueForFraction(JsonNode node) {
+    private void _assertLongValueFailForNonNumber(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.bigIntegerValue(),
+                () ->  node.longValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("longValue()")
             .contains("cannot convert value")
-            .contains("to `java.math.BigInteger`: value has fractional part");
+            .contains("value type not numeric");
+
+        // Verify default value handling
+        assertEquals(1L, node.longValue(1L));
+        assertFalse(node.longValueOpt().isPresent());
     }
 
-    private void _assertFailLongForNonNumber(JsonNode node) {
+    private void _assertLongValueFailForNaN(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
                 () ->  node.longValue(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("longValue()")
             .contains("cannot convert value")
-            .contains("value type not numeric");
+            .contains("value non-Finite");
+
+        // Verify default value handling
+        assertEquals(1L, node.longValue(1L));
+        assertFalse(node.longValueOpt().isPresent());
+    }
+
+    // // // Shared helper methods, asLong()
+
+    private void _assertAsLong(long expected, JsonNode node)
+    {
+        assertEquals(expected, node.asLong());
+
+        // But also fallbacks
+        assertEquals(expected, node.asLong(999999L));
+        assertEquals(expected, node.asLongOpt().getAsLong());
     }
 
-    private void _assertFailBigIntegerForNonNumber(JsonNode node) {
+    private void _assertAsLongFailForValueRange(JsonNode node) {
         Exception e = assertThrows(JsonNodeException.class,
-                () ->  node.bigIntegerValue(),
+                () ->  node.asLong(),
                 "For ("+node.getClass().getSimpleName()+") value: "+node);
         assertThat(e.getMessage())
+            .contains("asLong()")
             .contains("cannot convert value")
-            .contains("value type not numeric");
+            .contains("value not in 64-bit `long` range");
+
+        // Verify default value handling
+        assertEquals(1L, node.asLong(1L));
+        assertFalse(node.asLongOpt().isPresent());
     }
 
-    private void _assertDefaultLongForOtherwiseFailing(JsonNode node) {
-        assertEquals(99L, node.longValue(99L));
-        assertEquals(OptionalLong.empty(), node.longValueOpt());
+    private void _assertAsLongFailForNonNumber(JsonNode node) {
+        _assertAsLongFailForNonNumber(node, "value type not numeric");
     }
+
+    private void _assertAsLongFailForNonNumber(JsonNode node, String extraMsg) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asLong(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("asLong()")
+            .contains("cannot convert value")
+            .contains(extraMsg);
+
+        // Verify default value handling
+        assertEquals(1L, node.asLong(1L));
+        assertFalse(node.asLongOpt().isPresent());
+    }
+
+    private void _assertAsLongFailForNaN(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.asLong(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("asLong()")
+            .contains("cannot convert value")
+            .contains("value non-Finite");
+
+        // Verify default value handling
+        assertEquals(1L, node.asLong(1L));
+        assertFalse(node.asLongOpt().isPresent());
+    }
+    
 }
diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java
new file mode 100644
index 000000000..93ac0fc4b
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java
@@ -0,0 +1,171 @@
+package tools.jackson.databind.node;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.junit.jupiter.api.Test;
+
+import tools.jackson.databind.JsonNode;
+import tools.jackson.databind.exc.JsonNodeException;
+import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.util.RawValue;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * Tests for [databind#4958], JsonNode.intValue() (and related) parts
+ * over all types.
+ *<p>
+ * Also contains tests for {@code JsonNode.shortValue()}.
+ */
+public class JsonNodeShortValueTest
+    extends DatabindTestUtil
+{
+    private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();
+
+    // // // shortValue()
+
+    @Test
+    public void shortValueFromNumberIntOk()
+    {
+        final short SHORT_1 = (short) 1;
+        final short MIN_SHORT = Short.MIN_VALUE;
+        final short MAX_SHORT = Short.MAX_VALUE;
+        
+        // First safe from `short`
+        assertEquals(SHORT_1, NODES.numberNode((short) 1).shortValue());
+        assertEquals((int)Short.MIN_VALUE, NODES.numberNode(MIN_SHORT).shortValue());
+        assertEquals((int)Short.MAX_VALUE, NODES.numberNode(MAX_SHORT).shortValue());
+
+        // Then other integer types
+
+        assertEquals(SHORT_1, NODES.numberNode((byte) 1).shortValue());
+        assertEquals((short) Byte.MIN_VALUE, NODES.numberNode(Byte.MIN_VALUE).shortValue());
+        assertEquals((short) Byte.MAX_VALUE, NODES.numberNode(Byte.MAX_VALUE).shortValue());
+
+        assertEquals(SHORT_1, NODES.numberNode(1).shortValue());
+        assertEquals(MIN_SHORT, NODES.numberNode((int) MIN_SHORT).shortValue());
+        assertEquals(MAX_SHORT, NODES.numberNode((int) MAX_SHORT).shortValue());
+
+        assertEquals(SHORT_1, NODES.numberNode(1L).shortValue());
+        assertEquals(MIN_SHORT, NODES.numberNode((long) MIN_SHORT).shortValue());
+        assertEquals(MAX_SHORT, NODES.numberNode((long) MAX_SHORT).shortValue());
+
+        assertEquals(SHORT_1, NODES.numberNode(BigInteger.valueOf(1)).shortValue());
+        assertEquals(MIN_SHORT, NODES.numberNode(BigInteger.valueOf(MIN_SHORT)).shortValue());
+        assertEquals(MAX_SHORT, NODES.numberNode(BigInteger.valueOf(MAX_SHORT)).shortValue());
+    }
+
+    @Test
+    public void shortValueFromNumberIntFailRange() {
+        // Can only fail for underflow/overflow: and that only for Long / BigInteger
+        final int underflow = -1 + Short.MIN_VALUE;
+        final int overflow = +1 + Short.MAX_VALUE;
+
+        _assertFailShortForValueRange(NODES.numberNode(underflow));
+        _assertFailShortForValueRange(NODES.numberNode(overflow));
+
+        _assertFailShortForValueRange(NODES.numberNode(BigInteger.valueOf(underflow)));
+        _assertFailShortForValueRange(NODES.numberNode(BigInteger.valueOf(overflow)));
+    }
+
+    @Test
+    public void shortValueFromNumberFPOk()
+    {
+        assertEquals(1, NODES.numberNode(1.0f).shortValue());
+        assertEquals(10_000, NODES.numberNode(10_000.0f).shortValue());
+        assertEquals(-10_000, NODES.numberNode(-10_000.0f).shortValue());
+
+        assertEquals(1, NODES.numberNode(1.0d).shortValue());
+        assertEquals(10_000, NODES.numberNode(10_000.0d).shortValue());
+        assertEquals(-10_000, NODES.numberNode(-10_000.0d).shortValue());
+        assertEquals(Short.MIN_VALUE, NODES.numberNode((double) Short.MIN_VALUE).shortValue());
+        assertEquals(Short.MAX_VALUE, NODES.numberNode((double) Short.MAX_VALUE).shortValue());
+
+        assertEquals(1,
+                NODES.numberNode(BigDecimal.valueOf(1.0d)).shortValue());
+        assertEquals(Short.MIN_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Short.MIN_VALUE)).shortValue());
+        assertEquals(Short.MAX_VALUE,
+                NODES.numberNode(BigDecimal.valueOf((double) Short.MAX_VALUE)).shortValue());
+    }
+
+    @Test
+    public void shortValueFromNumberFPFailRange()
+    {
+        // Can only fail for underflow/overflow: and that only for Long / BigInteger
+        final long underflow = Short.MIN_VALUE - 1L;
+        final long overflow =  Short.MAX_VALUE + 1L;
+
+        _assertFailShortForValueRange(NODES.numberNode((double)underflow));
+        _assertFailShortForValueRange(NODES.numberNode((double)overflow));
+
+        // Float is too inexact for using same test as Double, so:
+
+        _assertFailShortForValueRange(NODES.numberNode(-Float.MAX_VALUE));
+        _assertFailShortForValueRange(NODES.numberNode(Float.MAX_VALUE));
+
+        _assertFailShortForValueRange(NODES.numberNode(BigDecimal.valueOf(underflow)));
+        _assertFailShortForValueRange(NODES.numberNode(BigDecimal.valueOf(overflow)));
+    }
+
+    @Test
+    public void shortValueFromNumberFPFailFraction()
+    {
+        _assertFailShortValueForFraction(NODES.numberNode(100.5f));
+        _assertFailShortValueForFraction(NODES.numberNode(-0.25f));
+
+        _assertFailShortValueForFraction(NODES.numberNode(100.5d));
+        _assertFailShortValueForFraction(NODES.numberNode(-0.25d));
+        
+        _assertFailShortValueForFraction(NODES.numberNode(BigDecimal.valueOf(100.5d)));
+        _assertFailShortValueForFraction(NODES.numberNode(BigDecimal.valueOf(-0.25d)));
+    }
+
+    @Test
+    public void shortValueFromNonNumberFail()
+    {
+        _assertFailShortForNonNumber(NODES.booleanNode(true));
+        _assertFailShortForNonNumber(NODES.binaryNode(new byte[3]));
+        _assertFailShortForNonNumber(NODES.stringNode("123"));
+        _assertFailShortForNonNumber(NODES.rawValueNode(new RawValue("abc")));
+        _assertFailShortForNonNumber(NODES.pojoNode(Boolean.TRUE));
+
+        _assertFailShortForNonNumber(NODES.arrayNode(3));
+        _assertFailShortForNonNumber(NODES.objectNode());
+        
+        _assertFailShortForNonNumber(NODES.nullNode());
+        _assertFailShortForNonNumber(NODES.missingNode());
+    }
+
+    // // // Shared helper methods
+
+    private void _assertFailShortForValueRange(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.shortValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value not in 16-bit `short` range");
+
+    }
+
+    private void _assertFailShortValueForFraction(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.shortValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("to `short`: value has fractional part");
+    }
+
+    private void _assertFailShortForNonNumber(JsonNode node) {
+        Exception e = assertThrows(JsonNodeException.class,
+                () ->  node.shortValue(),
+                "For ("+node.getClass().getSimpleName()+") value: "+node);
+        assertThat(e.getMessage())
+            .contains("cannot convert value")
+            .contains("value type not numeric");
+    }
+}
diff --git a/src/test/java/tools/jackson/databind/node/NodeTestBase.java b/src/test/java/tools/jackson/databind/node/NodeTestBase.java
index e63e38dac..671d77301 100644
--- a/src/test/java/tools/jackson/databind/node/NodeTestBase.java
+++ b/src/test/java/tools/jackson/databind/node/NodeTestBase.java
@@ -17,12 +17,10 @@ abstract class NodeTestBase extends DatabindTestUtil
         assertFalse(n.canConvertToLong());
         assertFalse(n.canConvertToExactIntegral());
 
-        assertEquals(0, n.asInt());
-        assertEquals(-42, n.asInt(-42));
-        assertEquals(0, n.asLong());
-        assertEquals(12345678901L, n.asLong(12345678901L));
-        assertEquals(0.0, n.asDouble());
-        assertEquals(-19.25, n.asDouble(-19.25));
+        // As of 3.0, coercion rules vary by specific type so can no longer test these
+        //assertEquals(-42, n.asInt(-42));
+        //assertEquals(12345678901L, n.asLong(12345678901L));
+        //assertEquals(-19.25, n.asDouble(-19.25));
     }
 
     // Test to check conversions, coercions
diff --git a/src/test/java/tools/jackson/databind/node/StringNodeTest.java b/src/test/java/tools/jackson/databind/node/StringNodeTest.java
index a1653c29b..316f69dae 100644
--- a/src/test/java/tools/jackson/databind/node/StringNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/StringNodeTest.java
@@ -18,7 +18,6 @@ public class StringNodeTest extends NodeTestBase
         assertTrue(empty.isEmpty());
 
         assertNodeNumbers(StringNode.valueOf("-3"), -3, -3.0);
-        assertNodeNumbers(StringNode.valueOf("17.75"), 17, 17.75);
 
         long value = 127353264013893L;
         StringNode n = StringNode.valueOf(String.valueOf(value));
