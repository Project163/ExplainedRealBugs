diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index c97a87390..2ebbba052 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -728,3 +728,8 @@ Peter Jurkovic (peterjurkovic@github)
 alinakovalenko@github:
   * Reported #1844: Map "deep" merge only adds new items, but not override existing values
    (2.9.3)
+
+Pier-Luc Whissell (pwhissell@github):
+  * Reported #1673: Serialising generic value classes via Reference Types (like Optional) fails
+    to include type information
+   (2.9.4)
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index d19a1df6d..aec9c251a 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -5,6 +5,9 @@ Project: jackson-databind
 
 2.9.4 (not yet released)
 
+#1673: Serialising generic value classes via Reference Types (like Optional) fails
+  to include type information
+ (reported by Pier-Luc W)
 #1729: Integer bounds verification when calling `TokenBuffer.getIntValue()`
  (reported by Kevin G)
 #1854: NPE deserializing collection with `@JsonCreator` and `ACCEPT_CASE_INSENSITIVE_PROPERTIES`
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
index 89300ce60..b300c3551 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java
@@ -442,33 +442,36 @@ public abstract class ReferenceTypeSerializer<T>
      * serializer.
      */
     private final JsonSerializer<Object> _findCachedSerializer(SerializerProvider provider,
-            Class<?> type) throws JsonMappingException
+            Class<?> rawType) throws JsonMappingException
     {
-        JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type);
+        JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(rawType);
         if (ser == null) {
-            ser = _findSerializer(provider, type, _property);
+            // NOTE: call this instead of `map._findAndAddDynamic(...)` (which in turn calls
+            // `findAndAddSecondarySerializer`) since we may need to apply unwrapper
+            // too, before caching. But calls made are the same
+            if (_referredType.hasGenericTypes()) {
+                // [databind#1673] Must ensure we will resolve all available type information
+                //  so as not to miss generic declaration of, say, `List<GenericPojo>`...
+                JavaType fullType = provider.constructSpecializedType(_referredType, rawType);
+                ser = provider.findValueSerializer(fullType, _property);
+            } else {
+                ser = provider.findValueSerializer(rawType, _property);
+            }
             if (_unwrapper != null) {
                 ser = ser.unwrappingSerializer(_unwrapper);
             }
-            _dynamicSerializers = _dynamicSerializers.newWith(type, ser);
+            _dynamicSerializers = _dynamicSerializers.newWith(rawType, ser);
         }
         return ser;
     }
 
-    private final JsonSerializer<Object> _findSerializer(SerializerProvider provider,
-            Class<?> type, BeanProperty prop) throws JsonMappingException
-    {
-        // 13-Mar-2017, tatu: Used to call `findTypeValueSerializer()`, but contextualization
-        //   not working for that case for some reason
-//        return provider.findTypedValueSerializer(type, true, prop);
-        return provider.findValueSerializer(type, prop);
-    }
-
     private final JsonSerializer<Object> _findSerializer(SerializerProvider provider,
         JavaType type, BeanProperty prop) throws JsonMappingException
     {
         // 13-Mar-2017, tatu: Used to call `findTypeValueSerializer()`, but contextualization
         //   not working for that case for some reason
+        // 15-Jan-2017, tatu: ... possibly because we need to access "secondary" serializer,
+        //   not primary (primary being one for Reference type itself, not value)
 //        return provider.findTypedValueSerializer(type, true, prop);
         return provider.findValueSerializer(type, prop);
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java
index 621397267..8da999f6e 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java
@@ -1,19 +1,17 @@
 package com.fasterxml.jackson.databind.ser.jdk;
 
 import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.TimeZone;
+import java.util.*;
 import java.util.concurrent.atomic.*;
 
-import com.fasterxml.jackson.annotation.JsonFormat;
-import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+import com.fasterxml.jackson.annotation.*;
 import com.fasterxml.jackson.databind.BaseMapTest;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 
 /**
- * Unit tests for verifying serialization of simple basic non-structured
- * types; primitives (and/or their wrappers), Strings.
+ * Unit tests for verifying serialization of {@link java.util.concurrent.AtomicReference}
+ * and other atomic types, via various settings.
  */
 public class AtomicTypeSerializationTest
     extends BaseMapTest
@@ -38,6 +36,34 @@ public class AtomicTypeSerializationTest
         public AtomicReference<Date> date2;
     }
 
+    // [databind#1673]
+    static class ContainerA {
+        public AtomicReference<Strategy> strategy =
+                new AtomicReference<>((Strategy) new Foo(42));
+    }
+
+    static class ContainerB {
+        public AtomicReference<List<Strategy>> strategy;
+        {
+            List<Strategy> list = new ArrayList<>();
+            list.add(new Foo(42));
+            strategy = new AtomicReference<>(list);
+        }
+    }
+
+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
+    @JsonSubTypes({ @JsonSubTypes.Type(name = "Foo", value = Foo.class) })
+    interface Strategy { }
+
+    static class Foo implements Strategy {
+        public int foo;
+
+        @JsonCreator
+        Foo(@JsonProperty("foo") int foo) {
+            this.foo = foo;
+        }
+    }
+
     /*
     /**********************************************************
     /* Test methods
@@ -91,4 +117,22 @@ public class AtomicTypeSerializationTest
                 "{'date1':'1970+01+01','date2':'1970*01*01','date':'1970/01/01'}"),
                 json);
     }
+
+    // [databind#1673]
+    public void testPolymorphicReferenceSimple() throws Exception
+    {
+        final String EXPECTED = "{\"type\":\"Foo\",\"foo\":42}";
+        String json = MAPPER.writeValueAsString(new ContainerA());
+        assertEquals("{\"strategy\":" + EXPECTED + "}", json);
+    }
+
+    // [databind#1673]
+    public void testPolymorphicReferenceListOf() throws Exception
+    {
+        final String EXPECTED = "{\"type\":\"Foo\",\"foo\":42}";
+        // Reproduction of issue seen with scala.Option and java8 Optional types:
+        // https://github.com/FasterXML/jackson-module-scala/issues/346#issuecomment-336483326
+        String json = MAPPER.writeValueAsString(new ContainerB());
+        assertEquals("{\"strategy\":[" + EXPECTED + "]}", json);
+    }
 }
