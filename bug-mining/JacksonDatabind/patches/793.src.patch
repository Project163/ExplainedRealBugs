diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 1677f2d80..b23a5d8f8 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -44,5 +44,8 @@ Andy Boothe (@sigpwned)
 Sébastien Deleuze (@sdeleuze)
  * Requested #5110: Add missing `ObjectMapper#createNonBlockingByteBufferParser()` method
   [3.0.0]
+ * Requested #5111: Improve support for deserializing from `TokenBuffer` (f.ex for
+   content buffered for non-blocking parsing)
+  [3.0.0]
  * Requested #5112: Add a `MapperBuilder#findAndAddModules(ClassLoader)` variant
   [3.0.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 821ba4fb4..47e55c09b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -13,6 +13,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
  to use `Supplier`
 #5110: Add missing `ObjectMapper#createNonBlockingByteBufferParser()` method
  (requested by Sébastien D)
+#5111: Improve support for deserializing from `TokenBuffer` (f.ex for
+  content buffered for non-blocking parsing)
+ (requested by Sébastien D)
 #5112: Add a `MapperBuilder#findAndAddModules(ClassLoader)` variant
  (requested by Sébastien D)
 
diff --git a/src/main/java/tools/jackson/databind/ObjectMapper.java b/src/main/java/tools/jackson/databind/ObjectMapper.java
index 49b4a701f..503f186e6 100644
--- a/src/main/java/tools/jackson/databind/ObjectMapper.java
+++ b/src/main/java/tools/jackson/databind/ObjectMapper.java
@@ -1204,8 +1204,6 @@ public class ObjectMapper
     /**
      * Same as {@link #readTree(InputStream)} except content read from
      * passed-in {@link Path}.
-     *
-     * @since 3.0
      */
     public JsonNode readTree(Path path) throws JacksonException
     {
@@ -1230,6 +1228,16 @@ public class ObjectMapper
         return _readTreeAndClose(ctxt, _streamFactory.createParser(ctxt, src));
     }
 
+    /**
+     * Same as {@link #readTree(InputStream)} except content read from
+     * passed-in {@link TokenBuffer}.
+     */
+    public JsonNode readTree(TokenBuffer src) throws JacksonException {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _readTreeAndClose(ctxt, src.asParser(ctxt));
+    }
+
     /*
     /**********************************************************************
     /* Public API serialization
@@ -1774,6 +1782,33 @@ public class ObjectMapper
                 _streamFactory.createParser(ctxt, src), _typeFactory.constructType(valueTypeRef));
     }
 
+    @SuppressWarnings("unchecked")
+    public <T> T readValue(TokenBuffer src, Class<T> valueType) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return (T) _readMapAndClose(ctxt,
+                src.asParser(ctxt), _typeFactory.constructType(valueType));
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> T readValue(TokenBuffer src, JavaType valueType) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return (T) _readMapAndClose(ctxt,
+                src.asParser(ctxt), valueType);
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> T readValue(TokenBuffer src, TypeReference<T> valueTypeRef) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return (T) _readMapAndClose(ctxt,
+                src.asParser(ctxt), _typeFactory.constructType(valueTypeRef));
+    }
+
     /*
     /**********************************************************************
     /* Public API: serialization (mapping from Java types to external format)
@@ -1891,6 +1926,20 @@ public class ObjectMapper
         }
     }
 
+    /**
+     * Convenience method that can be used to serialize any Java value into newly created
+     * {@link TokenBuffer}. Functionally equivalent to calling
+     * {@link #writeValue(JsonGenerator, Object)} passing buffer as generator.
+     */
+    public TokenBuffer writeValueIntoBuffer(Object value) throws JacksonException
+    {
+        final SerializationContextExt ctxt = _serializationContext();
+        try (TokenBuffer buf = ctxt.bufferForValueConversion()) {
+            _configAndWriteValue(ctxt, buf, value);
+            return buf;
+        }
+    }
+
     /**
      * Method called to configure the generator as necessary and then
      * call write functionality
diff --git a/src/main/java/tools/jackson/databind/ObjectReader.java b/src/main/java/tools/jackson/databind/ObjectReader.java
index feb6bcc72..6b3d19e77 100644
--- a/src/main/java/tools/jackson/databind/ObjectReader.java
+++ b/src/main/java/tools/jackson/databind/ObjectReader.java
@@ -27,6 +27,7 @@ import tools.jackson.databind.node.TreeTraversingParser;
 import tools.jackson.databind.type.SimpleType;
 import tools.jackson.databind.type.TypeFactory;
 import tools.jackson.databind.util.ClassUtil;
+import tools.jackson.databind.util.TokenBuffer;
 
 /**
  * Builder object that can be used for per-serialization configuration of
@@ -1280,8 +1281,6 @@ public class ObjectReader
      * was specified with {@link #withValueToUpdate(Object)}.
      *
      * @param path Path that contains content to read
-     *
-     * @since 3.0
      */
     @SuppressWarnings("unchecked")
     public <T> T readValue(Path path) throws JacksonException
@@ -1341,6 +1340,23 @@ public class ObjectReader
                 _considerFilter(_parserFactory.createParser(ctxt, input), false));
     }
 
+    /**
+     * Method that binds content read from given {@link TokenBuffer}
+     * using configuration of this reader.
+     * Value return is either newly constructed, or root value that
+     * was specified with {@link #withValueToUpdate(Object)}.
+     *
+     * @param src {@link TokenBuffer} that contains content to read
+     */
+    @SuppressWarnings("unchecked")
+    public <T> T readValue(TokenBuffer src) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return (T) _bindAndClose(ctxt,
+                _considerFilter(src.asParser(ctxt) , false));
+    }
+
     /*
     /**********************************************************************
     /* Deserialization methods; JsonNode ("tree")
@@ -1432,6 +1448,18 @@ public class ObjectReader
                 _considerFilter(_parserFactory.createParser(ctxt, content), false));
     }
 
+    /**
+     * Same as {@link #readTree(InputStream)} except content read using
+     * passed-in {@link TokenBuffer}.
+     */
+    public JsonNode readTree(TokenBuffer src) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _bindAndCloseAsTree(ctxt,
+                _considerFilter(src.asParser(ctxt), false));
+    }
+
     /*
     /**********************************************************************
     /* Deserialization methods; reading sequence of values
@@ -1586,6 +1614,14 @@ public class ObjectReader
                 _considerFilter(_parserFactory.createParser(ctxt, src), true));
     }
 
+    public <T> MappingIterator<T> readValues(TokenBuffer src) throws JacksonException
+    {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _bindAndReadValues(ctxt,
+                _considerFilter(src.asParser(ctxt), true));
+    }
+
     /*
     /**********************************************************************
     /* Misc conversion methods
diff --git a/src/main/java/tools/jackson/databind/ObjectWriter.java b/src/main/java/tools/jackson/databind/ObjectWriter.java
index 07955022e..337925098 100644
--- a/src/main/java/tools/jackson/databind/ObjectWriter.java
+++ b/src/main/java/tools/jackson/databind/ObjectWriter.java
@@ -1090,6 +1090,20 @@ public class ObjectWriter
         }
     }
 
+    /**
+     * Convenience method that can be used to serialize any Java value into newly created
+     * {@link TokenBuffer}. Functionally equivalent to calling
+     * {@link #writeValue(JsonGenerator, Object)} passing buffer as generator.
+     */
+    public TokenBuffer writeValueIntoBuffer(Object value) throws JacksonException
+    {
+        final SerializationContextExt ctxt = _serializationContext();
+        try (TokenBuffer buf = ctxt.bufferForValueConversion()) {
+            _configAndWriteValue(ctxt, buf, value);
+            return buf;
+        }
+    }
+    
     /**
      * Method called to configure the generator as necessary and then
      * call write functionality
diff --git a/src/test/java/tools/jackson/databind/util/TokenBufferTest.java b/src/test/java/tools/jackson/databind/util/TokenBufferTest.java
index a75e31c8d..4d71366a6 100644
--- a/src/test/java/tools/jackson/databind/util/TokenBufferTest.java
+++ b/src/test/java/tools/jackson/databind/util/TokenBufferTest.java
@@ -51,7 +51,7 @@ public class TokenBufferTest extends DatabindTestUtil
 
     /*
     /**********************************************************************
-    /* Basic TokenBuffer tests
+    /* Basic TokenBuffer tests, direct access
     /**********************************************************************
      */
 
@@ -524,6 +524,57 @@ public class TokenBufferTest extends DatabindTestUtil
         }
     }
 
+    /*
+    /**********************************************************************
+    /* TokenBuffer as source for ObjectMapper/ObjectReader tests
+    /**********************************************************************
+     */
+
+    @Test
+    public void readFromBufferViaObjectMapper() throws Exception {
+        final Point TEST_OB = new Point(123, -456);
+
+        assertEquals(TEST_OB, MAPPER.readValue(_tokenBufferFor(TEST_OB),
+                Point.class));
+        assertEquals(TEST_OB, MAPPER.readValue(_tokenBufferFor(TEST_OB),
+                MAPPER.constructType(Point.class)));
+        assertEquals(TEST_OB, MAPPER.readValue(_tokenBufferFor(TEST_OB),
+                new TypeReference<Point>() {}));
+
+        assertEquals(MAPPER.valueToTree(TEST_OB),
+                MAPPER.readTree(_tokenBufferFor(TEST_OB)));
+
+        // Try alternate that fills TokenBuffer using mapper itself
+        assertEquals(TEST_OB, MAPPER.readValue(MAPPER.writeValueIntoBuffer(TEST_OB),
+                Point.class));
+    }
+
+    @Test
+    public void readFromBufferViaObjectReader() throws Exception {
+        final Point TEST_OB = new Point(234, 5678);
+        final ObjectReader R = MAPPER.readerFor(Point.class);
+
+        assertEquals(TEST_OB, R.readValue(_tokenBufferFor(TEST_OB)));
+
+        assertEquals(MAPPER.valueToTree(TEST_OB),
+                R.readTree(_tokenBufferFor(TEST_OB)));
+
+        // Try alternate that fills TokenBuffer using ObjectWriter
+        assertEquals(TEST_OB,
+                R.readValue(MAPPER.writer().writeValueIntoBuffer(TEST_OB)));
+    }
+
+    private TokenBuffer _tokenBufferFor(Object value) {
+        final String json = MAPPER.writeValueAsString(value);
+        TokenBuffer buf = TokenBuffer.forGeneration();
+        try (JsonParser p = MAPPER.createParser(json)) {
+            while (p.nextToken() != null) {
+                buf.copyCurrentEvent(p);
+            }
+        }
+        return buf;
+    }
+    
     /*
     /**********************************************************
     /* Tests for read/output contexts
