diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index b9e5da099..1e67bf0ea 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -439,6 +439,8 @@ Yoann Rodi√®re (fenrhil@github)
 Mark Woon (markwoon@github)
   * Reported #1178: `@JsonSerialize(contentAs=superType)` behavior disallowed in 2.7
    (2.7.4)
+  * Reported #1231: `@JsonSerialize(as=superType)` behavior disallowed in 2.7.4
+   (2.7.5)
 
 Tom Mack (tommack@github)
   * Reported #1208: treeToValue doesn't handle POJONodes that contain exactly
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5e9c25389..39a0c3531 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -10,6 +10,8 @@ Project: jackson-databind
  (reported by Nick B)
 #1228: @JsonAnySetter does not deserialize null to Deserializer's NullValue
  (contributed by Eric S)
+#1231: `@JsonSerialize(as=superType)` behavior disallowed in 2.7.4
+ (reported by Mark W)
 
 2.7.4 (29-Apr-2016)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
index 464feedcb..3966997e9 100644
--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
@@ -813,10 +813,19 @@ public abstract class AnnotationIntrospector
                 //    static typing this way
                 type = type.withStaticTyping();
             } else {
+                Class<?> currRaw = type.getRawClass();
                 try {
                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                     //   may be needed here too in future?
-                    type = tf.constructGeneralizedType(type, serClass);
+                    if (serClass.isAssignableFrom(currRaw)) { // common case
+                        type = tf.constructGeneralizedType(type, serClass);
+                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well
+                        type = tf.constructSpecializedType(type, serClass);
+                    } else {
+                        throw new JsonMappingException(null,
+                                String.format("Can not refine serialization type %s into %s; types not related",
+                                        type, serClass.getName()));
+                    }
                 } catch (IllegalArgumentException iae) {
                     throw new JsonMappingException(null,
                             String.format("Failed to widen type %s with annotation (value %s), from '%s': %s",
@@ -835,8 +844,20 @@ public abstract class AnnotationIntrospector
                 if (keyType.hasRawClass(keyClass)) {
                     keyType = keyType.withStaticTyping();
                 } else {
+                    Class<?> currRaw = keyType.getRawClass();
                     try {
-                        keyType = tf.constructGeneralizedType(keyType, keyClass);
+                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually
+                        //   specialize (narrow) type sometimes, even if more commonly opposite
+                        //   is needed.
+                        if (keyClass.isAssignableFrom(currRaw)) { // common case
+                            keyType = tf.constructGeneralizedType(keyType, keyClass);
+                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well
+                            keyType = tf.constructSpecializedType(keyType, keyClass);
+                        } else {
+                            throw new JsonMappingException(null,
+                                    String.format("Can not refine serialization key type %s into %s; types not related",
+                                            keyType, keyClass.getName()));
+                        }
                     } catch (IllegalArgumentException iae) {
                         throw new JsonMappingException(null,
                                 String.format("Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s",
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java
index 5af31f8f4..01cabf2f1 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java
@@ -149,7 +149,7 @@ public class TestJsonSerialize
         try {
             serializeAsString(MAPPER, new BrokenClass());
         } catch (Exception e) {
-            verifyException(e, "not a super-type of");
+            verifyException(e, "types not related");
         }
     }
 
