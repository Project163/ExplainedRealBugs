diff --git a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java
index 12fcaa287..7bc3e7f03 100644
--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java
+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java
@@ -510,12 +510,24 @@ public abstract class MapperConfig<T extends MapperConfig<T>>
      * Accessor for the baseline merge info used as the global baseline,
      * not considering possible per-type overrides.
      *
-     * @return Global base settings; never null
+     * @return Global base settings, if any; `null` if none.
      *
      * @since 2.9
      */
     public abstract Boolean getDefaultMergeable();
 
+    /**
+     * Accessor for the baseline merge info used for given type, including global
+     * defaults if no type-specific overrides defined.
+     *
+     * @return Type-specific settings (if any); global defaults (same as
+     *    {@link #getDefaultMergeable()}) otherwise, if any defined; or `null`
+     *    if neither defined
+     *
+     * @since 2.9
+     */
+    public abstract Boolean getDefaultMergeable(Class<?> baseType);
+
     /*
     /**********************************************************
     /* Configuration: other
diff --git a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java
index 920961bd8..82c9ed941 100644
--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java
+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java
@@ -717,6 +717,19 @@ public abstract class MapperConfigBase<CFG extends ConfigFeature,
         return _configOverrides.getDefaultMergeable();
     }
 
+    @Override
+    public Boolean getDefaultMergeable(Class<?> baseType) {
+        Boolean b;
+        ConfigOverride cfg = _configOverrides.findOverride(baseType);
+        if (cfg != null) {
+            b = cfg.getMergeable();
+            if (b != null) {
+                return b;
+            }
+        }
+        return _configOverrides.getDefaultMergeable();
+    }
+
     /*
     /**********************************************************
     /* Other config access
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
index a4aa05c7c..3bb2c1af3 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
@@ -68,6 +68,11 @@ public class UntypedObjectDeserializer
      */
     protected JavaType _mapType;
 
+    /**
+     * @since 2.9
+     */
+    protected final boolean _nonMerging;
+    
     /**
      * @deprecated Since 2.6 use variant takes type arguments
      */
@@ -80,6 +85,7 @@ public class UntypedObjectDeserializer
         super(Object.class);
         _listType = listType;
         _mapType = mapType;
+        _nonMerging = false;
     }
 
     @SuppressWarnings("unchecked")
@@ -94,6 +100,23 @@ public class UntypedObjectDeserializer
         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;
         _listType = base._listType;
         _mapType = base._mapType;
+        _nonMerging = base._nonMerging;
+    }
+
+    /**
+     * @since 2.9
+     */
+    protected UntypedObjectDeserializer(UntypedObjectDeserializer base,
+            boolean nonMerging)
+    {
+        super(Object.class);
+        _mapDeserializer = base._mapDeserializer;
+        _listDeserializer = base._listDeserializer;
+        _stringDeserializer = base._stringDeserializer;
+        _numberDeserializer = base._numberDeserializer;
+        _listType = base._listType;
+        _mapType = base._mapType;
+        _nonMerging = nonMerging;
     }
 
     /*
@@ -169,12 +192,18 @@ public class UntypedObjectDeserializer
     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
             BeanProperty property) throws JsonMappingException
     {
+        // 14-Jun-2017, tatu: [databind#1625]: may want to block merging, for root value
+        boolean preventMerge = (property == null)
+                && Boolean.FALSE.equals(ctxt.getConfig().getDefaultMergeable(Object.class));
         // 20-Apr-2014, tatu: If nothing custom, let's use "vanilla" instance,
         //     simpler and can avoid some of delegation
         if ((_stringDeserializer == null) && (_numberDeserializer == null)
                 && (_mapDeserializer == null) && (_listDeserializer == null)
                 &&  getClass() == UntypedObjectDeserializer.class) {
-            return Vanilla.std;
+            return Vanilla.instance(preventMerge);
+        }
+        if (preventMerge != _nonMerging) {
+            return new UntypedObjectDeserializer(this, preventMerge);
         }
         return this;
     }
@@ -271,7 +300,8 @@ public class UntypedObjectDeserializer
     }
 
     @Override
-    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException
+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
+            TypeDeserializer typeDeserializer) throws IOException
     {
         switch (p.getCurrentTokenId()) {
         // First: does it look like we had type id wrapping of some kind?
@@ -329,6 +359,10 @@ public class UntypedObjectDeserializer
     public Object deserialize(JsonParser p, DeserializationContext ctxt, Object intoValue)
         throws IOException
     {
+        if (_nonMerging) {
+            return deserialize(p, ctxt);
+        }
+
         switch (p.getCurrentTokenId()) {
         case JsonTokenId.ID_START_OBJECT:
         case JsonTokenId.ID_FIELD_NAME:
@@ -579,12 +613,30 @@ public class UntypedObjectDeserializer
 
         public final static Vanilla std = new Vanilla();
 
-        public Vanilla() { super(Object.class); }
+        /**
+         * @since 2.9
+         */
+        protected final boolean _nonMerging;
+        
+        public Vanilla() { this(false); }
+
+        protected Vanilla(boolean nonMerging) {
+            super(Object.class);
+            _nonMerging = nonMerging;
+        }
 
+        public static Vanilla instance(boolean nonMerging) {
+            if (nonMerging) {
+                return new Vanilla(true);
+            }
+            return std;
+        }
+        
         @Override // since 2.9
         public Boolean supportsUpdate(DeserializationConfig config) {
             // 21-Apr-2017, tatu: Bit tricky... some values, yes. So let's say "dunno"
-            return null;
+            // 14-Jun-2017, tatu: Well, if merging blocked, can say no, as well.
+            return _nonMerging ? Boolean.FALSE : null;
         }
 
         @Override
@@ -693,6 +745,10 @@ public class UntypedObjectDeserializer
         public Object deserialize(JsonParser p, DeserializationContext ctxt, Object intoValue)
             throws IOException
         {
+            if (_nonMerging) {
+                return deserialize(p, ctxt);
+            }
+
             switch (p.getCurrentTokenId()) {
             case JsonTokenId.ID_END_OBJECT:
             case JsonTokenId.ID_END_ARRAY:
diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
index 602e88d92..19378d158 100644
--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
@@ -303,10 +303,8 @@ public class POJOPropertyBuilder
             }
             if (needMerge) {
                 Boolean b = _config.getDefaultMergeable();
-                if ((acc != null) && (b != null)) {
-                    if (b.booleanValue()) {
-                        metadata = metadata.withMergeInfo(PropertyMetadata.MergeInfo.createForDefaults(acc));
-                    }
+                if (Boolean.TRUE.equals(b) && (acc != null)) {
+                    metadata = metadata.withMergeInfo(PropertyMetadata.MergeInfo.createForDefaults(acc));
                 }
             }
         }
diff --git a/src/test/java/com/fasterxml/jackson/failing/MapMerge1625Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMerge1625Test.java
similarity index 83%
rename from src/test/java/com/fasterxml/jackson/failing/MapMerge1625Test.java
rename to src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMerge1625Test.java
index 0ca4655f4..fcdb688c6 100644
--- a/src/test/java/com/fasterxml/jackson/failing/MapMerge1625Test.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMerge1625Test.java
@@ -1,4 +1,4 @@
-package com.fasterxml.jackson.failing;
+package com.fasterxml.jackson.databind.deser.merge;
 
 import java.util.*;
 
@@ -11,15 +11,6 @@ public class MapMerge1625Test extends BaseMapTest
     public void testDefaultDeepMapMerge() throws Exception
     {
         // First: deep merge should be enabled by default
-
-        /*
-//        mapper.configOverride(Map.class)
-        mapper.configOverride(List.class)
-            .setMergeable(false);
-        mapper.configOverride(Object.class)
-        .setMergeable(false);
-        */
-
         HashMap<String,Object> input = new HashMap<>();
         input.put("list", new ArrayList<>(Arrays.asList("a")));
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMergeTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMergeTest.java
index c56ecc8d4..647d93443 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMergeTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/merge/MapMergeTest.java
@@ -145,4 +145,71 @@ public class MapMergeTest extends BaseMapTest
         assertEquals("bar", names.get(1));
     }
 
+    /*
+    /********************************************************
+    /* Forcing shallow merge of root Maps:
+    /********************************************************
+     */
+    
+    public void testDefaultDeepMapMerge() throws Exception
+    {
+        // First: deep merge should be enabled by default
+        HashMap<String,Object> input = new HashMap<>();
+        input.put("list", new ArrayList<>(Arrays.asList("a")));
+
+        Map<?,?> resultMap = MAPPER.readerForUpdating(input)
+                .readValue(aposToQuotes("{'list':['b']}"));
+
+        List<?> resultList = (List<?>) resultMap.get("list");
+        assertEquals(Arrays.asList("a", "b"), resultList);
+    }
+
+    public void testDisabledMergeViaGlobal() throws Exception
+    {
+        ObjectMapper mapper = newObjectMapper();
+        // disable merging, globally; does not affect main level
+        mapper.setDefaultMergeable(false);
+
+        HashMap<String,Object> input = new HashMap<>();
+        input.put("list", new ArrayList<>(Arrays.asList("a")));
+
+        Map<?,?> resultMap = mapper.readerForUpdating(input)
+                .readValue(aposToQuotes("{'list':['b']}"));
+
+        List<?> resultList = (List<?>) resultMap.get("list");
+
+        assertEquals(Arrays.asList("b"), resultList);
+    }
+
+    public void testDisabledMergeByType() throws Exception
+    {
+        ObjectMapper mapper = newObjectMapper();
+        // disable merging for "untyped", that is, `Object.class`
+        mapper.configOverride(Object.class)
+            .setMergeable(false);
+
+        HashMap<String,Object> input = new HashMap<>();
+        input.put("list", new ArrayList<>(Arrays.asList("a")));
+
+        Map<?,?> resultMap = mapper.readerForUpdating(input)
+                .readValue(aposToQuotes("{'list':['b']}"));
+        List<?> resultList = (List<?>) resultMap.get("list");
+        assertEquals(Arrays.asList("b"), resultList);
+
+        // and for extra points, disable by default but ENABLE for type,
+        // which should once again allow merging
+
+        mapper = newObjectMapper();
+        mapper.setDefaultMergeable(false);
+        mapper.configOverride(Object.class)
+            .setMergeable(true);
+
+        input = new HashMap<>();
+        input.put("list", new ArrayList<>(Arrays.asList("x")));
+
+        resultMap = mapper.readerForUpdating(input)
+                .readValue(aposToQuotes("{'list':['y']}"));
+        resultList = (List<?>) resultMap.get("list");
+        assertEquals(Arrays.asList("x", "y"), resultList);
+    }
 }
