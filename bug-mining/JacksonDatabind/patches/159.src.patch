diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 96d20ea5c..663a703b0 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -401,3 +401,7 @@ Hugo Wood (hgwood@github)
 Julian Hyde (julianhyde@github)
   * Reported #1083: Field in base class is not recognized, when using `@JsonType.defaultImpl`
    (2.7.1)
+
+Thibault Kruse (tkruse@github)
+  * Reported #1102: Handling of deprecated `SimpleType.construct()` too minimalistic
+   (2.7.1)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 706160a70..06247ec16 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -9,6 +9,8 @@ Project: jackson-databind
 #1079: Add back `TypeFactory.constructType(Type, Class)` as "deprecated" in 2.7.1
 #1083: Field in base class is not recognized, when using `@JsonType.defaultImpl`
  (reported by Julian H)
+#1102: Handling of deprecated `SimpleType.construct()` too minimalistic
+ (reported by Thibault K)
 
 2.7.0 (10-Jan-2016)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/JavaType.java b/src/main/java/com/fasterxml/jackson/databind/JavaType.java
index 7c7303960..752edd189 100644
--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java
@@ -202,6 +202,7 @@ public abstract class JavaType
         return result;
     }
 
+    @Deprecated // since 2.7
     protected abstract JavaType _narrow(Class<?> subclass);
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java
index 132fbf297..d4543a2ac 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java
@@ -111,6 +111,7 @@ public final class ArrayType
      * it is not even allowed.
      */
     @Override
+    @Deprecated // since 2.7
     protected JavaType _narrow(Class<?> subclass) {
         return _reportUnsupported();
     }
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
index dc7444124..45d6ca478 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
@@ -1,5 +1,6 @@
 package com.fasterxml.jackson.databind.type;
 
+import java.lang.reflect.TypeVariable;
 import java.util.Collection;
 
 import com.fasterxml.jackson.databind.JavaType;
@@ -59,8 +60,16 @@ public class CollectionLikeType extends TypeBase
      */
     @Deprecated // since 2.7
     public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) {
-        return new CollectionLikeType(rawType, null, 
-                // !!! TODO: wrong, probably has super-types, but:
+        // First: may need to fabricate TypeBindings (needed for refining into
+        // concrete collection types, as per [databind#1102])
+        TypeVariable<?>[] vars = rawType.getTypeParameters();
+        TypeBindings bindings;
+        if ((vars == null) || (vars.length != 1)) {
+            bindings = TypeBindings.emptyBindings();
+        } else {
+            bindings = TypeBindings.create(rawType, elemT);
+        }
+        return new CollectionLikeType(rawType, bindings,
                 _bogusSuperClass(rawType), null,
                 elemT, null, null, false);
     }
@@ -81,6 +90,7 @@ public class CollectionLikeType extends TypeBase
     }
 
     @Override
+    @Deprecated // since 2.7
     protected JavaType _narrow(Class<?> subclass) {
         return new CollectionLikeType(subclass, _bindings,
                 _superClass, _superInterfaces, _elementType,
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java
index b7acfa91f..e0a785672 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java
@@ -1,5 +1,7 @@
 package com.fasterxml.jackson.databind.type;
 
+import java.lang.reflect.TypeVariable;
+
 import com.fasterxml.jackson.databind.JavaType;
 
 /**
@@ -44,13 +46,22 @@ public final class CollectionType
      */
     @Deprecated // since 2.7
     public static CollectionType construct(Class<?> rawType, JavaType elemT) {
-        // nominally component types will be just Object.class
-        return new CollectionType(rawType, null,
+        // First: may need to fabricate TypeBindings (needed for refining into
+        // concrete collection types, as per [databind#1102])
+        TypeVariable<?>[] vars = rawType.getTypeParameters();
+        TypeBindings bindings;
+        if ((vars == null) || (vars.length != 1)) {
+            bindings = TypeBindings.emptyBindings();
+        } else {
+            bindings = TypeBindings.create(rawType, elemT);
+        }
+        return new CollectionType(rawType, bindings,
                 // !!! TODO: Wrong, does have supertypes, but:
                 _bogusSuperClass(rawType), null, elemT,
                 null, null, false);
     }
 
+    @Deprecated // since 2.7
     @Override
     protected JavaType _narrow(Class<?> subclass) {
         return new CollectionType(subclass, _bindings,
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
index 50d96b085..b8d5ea432 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
@@ -1,19 +1,19 @@
 package com.fasterxml.jackson.databind.type;
 
+import java.lang.reflect.TypeVariable;
 import java.util.*;
 
 import com.fasterxml.jackson.databind.JavaType;
 
 /**
- * Type that represents Map-like types; things that consist of key/value pairs but that
- * do not necessarily implement {@link java.util.Map}, but that do not have enough
- * introspection functionality to allow for some level of generic handling.
- * This specifically allows framework to check for configuration and annotation
- * settings used for Map types, and pass these to custom handlers that may be more
- * familiar with actual type.
+ * Type that represents Map-like types; things that consist of key/value pairs
+ * but that do not necessarily implement {@link java.util.Map}, but that do not
+ * have enough introspection functionality to allow for some level of generic
+ * handling. This specifically allows framework to check for configuration and
+ * annotation settings used for Map types, and pass these to custom handlers
+ * that may be more familiar with actual type.
  */
-public class MapLikeType extends TypeBase
-{
+public class MapLikeType extends TypeBase {
     private static final long serialVersionUID = 1L;
 
     /**
@@ -27,17 +27,16 @@ public class MapLikeType extends TypeBase
     protected final JavaType _valueType;
 
     /*
-    /**********************************************************
-    /* Life-cycle
-    /**********************************************************
+     * /********************************************************** /* Life-cycle
+     * /**********************************************************
      */
 
     protected MapLikeType(Class<?> mapType, TypeBindings bindings,
-            JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT,
-            Object valueHandler, Object typeHandler, boolean asStatic)
-    {
-        super(mapType, bindings, superClass, superInts,
-                keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
+            JavaType superClass, JavaType[] superInts, JavaType keyT,
+            JavaType valueT, Object valueHandler, Object typeHandler,
+            boolean asStatic) {
+        super(mapType, bindings, superClass, superInts, keyT.hashCode()
+                ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
         _keyType = keyT;
         _valueType = valueT;
     }
@@ -45,38 +44,54 @@ public class MapLikeType extends TypeBase
     /**
      * @since 2.7
      */
-    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT)
-    {
+    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) {
         super(base);
         _keyType = keyT;
         _valueType = valueT;
     }
 
     /**
-     * Factory method that can be used to "upgrade" a basic type into collection-like
-     * one; usually done via {@link TypeModifier}
+     * Factory method that can be used to "upgrade" a basic type into
+     * collection-like one; usually done via {@link TypeModifier}
      *
      * @since 2.7
      */
-    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT, JavaType valueT) {
-        // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
-        //    will cross that bridge if and when need be
+    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT,
+            JavaType valueT) {
+        // 19-Oct-2015, tatu: Not sure if and how other types could be used as
+        // base;
+        // will cross that bridge if and when need be
         if (baseType instanceof TypeBase) {
             return new MapLikeType((TypeBase) baseType, keyT, valueT);
         }
-        throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
+        throw new IllegalArgumentException(
+                "Can not upgrade from an instance of " + baseType.getClass());
     }
 
-    @Deprecated // since 2.7
-    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {
-        return new MapLikeType(rawType, null, _bogusSuperClass(rawType), null,
-                keyT, valueT, null, null, false);
+    @Deprecated
+    // since 2.7; remove from 2.8
+    public static MapLikeType construct(Class<?> rawType, JavaType keyT,
+            JavaType valueT) {
+        // First: may need to fabricate TypeBindings (needed for refining into
+        // concrete collection types, as per [databind#1102])
+        TypeVariable<?>[] vars = rawType.getTypeParameters();
+        TypeBindings bindings;
+        if ((vars == null) || (vars.length != 2)) {
+            bindings = TypeBindings.emptyBindings();
+        } else {
+            bindings = TypeBindings.create(rawType, keyT, valueT);
+        }
+        return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType),
+                null, keyT, valueT, null, null, false);
     }
 
+    @Deprecated
+    // since 2.7
     @Override
     protected JavaType _narrow(Class<?> subclass) {
-        return new MapLikeType(subclass, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
+        return new MapLikeType(subclass, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType, _valueHandler,
+                _typeHandler, _asStatic);
     }
 
     /**
@@ -86,42 +101,46 @@ public class MapLikeType extends TypeBase
         if (keyType == _keyType) {
             return this;
         }
-        return new MapLikeType(_class, _bindings, _superClass, _superInterfaces,
-                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, keyType, _valueType, _valueHandler,
+                _typeHandler, _asStatic);
     }
-    
+
     @Override
     public JavaType withContentType(JavaType contentType) {
         if (_valueType == contentType) {
             return this;
         }
-        return new MapLikeType(_class, _bindings, _superClass, _superInterfaces,
-                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, contentType, _valueHandler,
+                _typeHandler, _asStatic);
     }
 
     @Override
     public MapLikeType withTypeHandler(Object h) {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType, _valueHandler, h,
+                _asStatic);
     }
 
     @Override
     public MapLikeType withContentTypeHandler(Object h) {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType.withTypeHandler(h),
                 _valueHandler, _typeHandler, _asStatic);
     }
 
     @Override
     public MapLikeType withValueHandler(Object h) {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType, h, _typeHandler,
+                _asStatic);
     }
 
     @Override
     public MapLikeType withContentValueHandler(Object h) {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType.withValueHandler(h),
                 _valueHandler, _typeHandler, _asStatic);
     }
 
@@ -130,17 +149,16 @@ public class MapLikeType extends TypeBase
         if (_asStatic) {
             return this;
         }
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType, _valueType.withStaticTyping(),
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType, _valueType.withStaticTyping(),
                 _valueHandler, _typeHandler, true);
     }
 
     @Override
     public JavaType refine(Class<?> rawType, TypeBindings bindings,
             JavaType superClass, JavaType[] superInterfaces) {
-        return new MapLikeType(rawType, bindings,
-                superClass, superInterfaces, _keyType, _valueType,
-                _valueHandler, _typeHandler, _asStatic);
+        return new MapLikeType(rawType, bindings, superClass, superInterfaces,
+                _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
     }
 
     @Override
@@ -156,24 +174,31 @@ public class MapLikeType extends TypeBase
         }
         return sb.toString();
     }
- 
+
     /*
-    /**********************************************************
-    /* Public API
-    /**********************************************************
+     * /********************************************************** /* Public API
+     * /**********************************************************
      */
 
     @Override
-    public boolean isContainerType() { return true; }
+    public boolean isContainerType() {
+        return true;
+    }
 
     @Override
-    public boolean isMapLikeType() { return true; }
-    
+    public boolean isMapLikeType() {
+        return true;
+    }
+
     @Override
-    public JavaType getKeyType() { return _keyType; }
+    public JavaType getKeyType() {
+        return _keyType;
+    }
 
     @Override
-    public JavaType getContentType() { return _valueType; }
+    public JavaType getContentType() {
+        return _valueType;
+    }
 
     @Override
     public Object getContentValueHandler() {
@@ -189,10 +214,9 @@ public class MapLikeType extends TypeBase
     public StringBuilder getErasedSignature(StringBuilder sb) {
         return _classSignature(_class, sb, true);
     }
-    
+
     @Override
-    public StringBuilder getGenericSignature(StringBuilder sb)
-    {
+    public StringBuilder getGenericSignature(StringBuilder sb) {
         _classSignature(_class, sb, false);
         sb.append('<');
         _keyType.getGenericSignature(sb);
@@ -200,58 +224,55 @@ public class MapLikeType extends TypeBase
         sb.append(">;");
         return sb;
     }
- 
+
     /*
-    /**********************************************************
-    /* Extended API
-    /**********************************************************
+     * /********************************************************** /* Extended
+     * API /**********************************************************
      */
 
-    public MapLikeType withKeyTypeHandler(Object h)
-    {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,
+    public MapLikeType withKeyTypeHandler(Object h) {
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType.withTypeHandler(h), _valueType,
                 _valueHandler, _typeHandler, _asStatic);
     }
 
     public MapLikeType withKeyValueHandler(Object h) {
-        return new MapLikeType(_class, _bindings,
-                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,
+        return new MapLikeType(_class, _bindings, _superClass,
+                _superInterfaces, _keyType.withValueHandler(h), _valueType,
                 _valueHandler, _typeHandler, _asStatic);
     }
-    
+
     /**
-     * Method that can be used for checking whether this type is a
-     * "real" Collection type; meaning whether it represents a parameterized
-     * subtype of {@link java.util.Collection} or just something that acts
-     * like one.
+     * Method that can be used for checking whether this type is a "real"
+     * Collection type; meaning whether it represents a parameterized subtype of
+     * {@link java.util.Collection} or just something that acts like one.
      */
     public boolean isTrueMapType() {
         return Map.class.isAssignableFrom(_class);
     }
 
     /*
-    /**********************************************************
-    /* Standard methods
-    /**********************************************************
+     * /********************************************************** /* Standard
+     * methods /**********************************************************
      */
 
     @Override
-    public String toString()
-    {
-        return "[map-like type; class "+_class.getName()+", "+_keyType+" -> "+_valueType+"]";
+    public String toString() {
+        return "[map-like type; class " + _class.getName() + ", " + _keyType
+                + " -> " + _valueType + "]";
     }
 
     @Override
-    public boolean equals(Object o)
-    {
-        if (o == this) return true;
-        if (o == null) return false;
-        if (o.getClass() != getClass()) return false;
+    public boolean equals(Object o) {
+        if (o == this)
+            return true;
+        if (o == null)
+            return false;
+        if (o.getClass() != getClass())
+            return false;
 
         MapLikeType other = (MapLikeType) o;
-        return (_class == other._class)
-            && _keyType.equals(other._keyType)
-            && _valueType.equals(other._valueType);
+        return (_class == other._class) && _keyType.equals(other._keyType)
+                && _valueType.equals(other._valueType);
     }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java
index d1d42476b..e71abb683 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java
@@ -1,5 +1,7 @@
 package com.fasterxml.jackson.databind.type;
 
+import java.lang.reflect.TypeVariable;
+
 import com.fasterxml.jackson.databind.JavaType;
 
 /**
@@ -39,12 +41,23 @@ public final class MapType extends MapLikeType
     }
     
     @Deprecated // since 2.7
-    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {
+    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
+    {
+        // First: may need to fabricate TypeBindings (needed for refining into
+        // concrete collection types, as per [databind#1102])
+        TypeVariable<?>[] vars = rawType.getTypeParameters();
+        TypeBindings bindings;
+        if ((vars == null) || (vars.length != 2)) {
+            bindings = TypeBindings.emptyBindings();
+        } else {
+            bindings = TypeBindings.create(rawType, keyT, valueT);
+        }
         // !!! TODO: Wrong, does have supertypes
-        return new MapType(rawType, null, _bogusSuperClass(rawType), null,
+        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,
                 keyT, valueT, null, null, false);
     }
 
+    @Deprecated // since 2.7
     @Override
     protected JavaType _narrow(Class<?> subclass) {
         return new MapType(subclass, _bindings,
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
index 844128a4a..6052ab092 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
@@ -151,8 +151,9 @@ public class ReferenceType extends SimpleType
     /* Narrow/widen
     /**********************************************************
      */
-    
+
     @Override
+    @Deprecated // since 2.7
     protected JavaType _narrow(Class<?> subclass)
     {
         // Should we check that there is a sub-class relationship?
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
index 0895e688e..02fa3d7b0 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
@@ -68,6 +68,7 @@ public class ResolvedRecursiveType extends TypeBase
         return this;
     }
 
+    @Deprecated // since 2.7
     @Override
     protected JavaType _narrow(Class<?> subclass) {
         return this;
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
index a59258c23..1174710df 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
@@ -100,7 +100,6 @@ public class SimpleType // note: until 2.6 was final
     @Deprecated
     public static SimpleType construct(Class<?> cls)
     {
-                
         /* Let's add sanity checks, just to ensure no
          * Map/Collection entries are constructed
          */
@@ -114,12 +113,13 @@ public class SimpleType // note: until 2.6 was final
         if (cls.isArray()) {
             throw new IllegalArgumentException("Can not construct SimpleType for an array (class: "+cls.getName()+")");
         }
-        return new SimpleType(cls, TypeBindings.emptyBindings(),
-                // 18-Oct-2015, tatu: Should be ok to pass very minimal supertype info?
-                _bogusSuperClass(cls), null, null, null, false);
+        TypeBindings b = TypeBindings.emptyBindings();
+        return new SimpleType(cls, b,
+                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);
     }
-    
+
     @Override
+    @Deprecated
     protected JavaType _narrow(Class<?> subclass)
     {
         if (_class == subclass) {
@@ -237,6 +237,31 @@ public class SimpleType // note: until 2.6 was final
         return sb;
     }
 
+    /*
+    /**********************************************************
+    /* Internal methods
+    /**********************************************************
+     */
+
+    /**
+     * Helper method we need to recursively build skeletal representations
+     * of superclasses.
+     * 
+     * @since 2.7 -- remove when not needed (2.8?)
+     */
+    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)
+    {
+        if (superClass == null) {
+            return null;
+        }
+        if (superClass == Object.class) {
+            return TypeFactory.unknownType();
+        }
+        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);
+        return new SimpleType(superClass, b,
+                superSuper, null, null, null, false);
+    }
+
     /*
     /**********************************************************
     /* Standard methods
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java
index 697fac1b8..d3c884a6f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java
@@ -96,7 +96,6 @@ public class TypeBindings
         case 2:
             return create(erasedType, types[0], types[1]);
         }
-        
         TypeVariable<?>[] vars = erasedType.getTypeParameters();
         String[] names;
         if (vars == null || vars.length == 0) {
@@ -195,8 +194,6 @@ public class TypeBindings
      * Method for creating an instance that has same bindings as this object,
      * plus an indicator for additional type variable that may be unbound within
      * this context; this is needed to resolve recursive self-references.
-     * 
-     * @since 1.3 (renamed from "withAdditionalBinding" in 1.2)
      */
     public TypeBindings withUnboundVariable(String name)
     {
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
index 11991efc1..2c96d2c1b 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
@@ -373,7 +373,7 @@ public final class TypeFactory
             }
 
             // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
-            // !!! TODO
+            // !!! TODO (as of 28-Jan-2016, at least)
 
             // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
             //    a way to fully resolve and merge hierarchies; but that gets expensive
diff --git a/src/test/java/com/fasterxml/jackson/failing/DeprecatedTypeHandling1102Test.java b/src/test/java/com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
similarity index 54%
rename from src/test/java/com/fasterxml/jackson/failing/DeprecatedTypeHandling1102Test.java
rename to src/test/java/com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
index d07ea3e39..b361b2a09 100644
--- a/src/test/java/com/fasterxml/jackson/failing/DeprecatedTypeHandling1102Test.java
+++ b/src/test/java/com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java
@@ -1,9 +1,10 @@
-package com.fasterxml.jackson.failing;
+package com.fasterxml.jackson.databind.interop;
 
-import java.util.List;
+import java.util.*;
 
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.type.CollectionType;
+import com.fasterxml.jackson.databind.type.MapType;
 import com.fasterxml.jackson.databind.type.SimpleType;
 
 /**
@@ -21,6 +22,10 @@ public class DeprecatedTypeHandling1102Test extends BaseMapTest
         public int getY() { return _y; }
     }
 
+    static class Point3D extends Point {
+        public int z;
+    }
+    
     final ObjectMapper MAPPER = objectMapper();
 
     @SuppressWarnings("deprecation")
@@ -33,14 +38,27 @@ public class DeprecatedTypeHandling1102Test extends BaseMapTest
         assertEquals(1, p.x);
         assertEquals(2, p.getY());
     }
+
+    @SuppressWarnings("deprecation")
+    public void testPOJOSubType() throws Exception
+    {
+        JavaType elem = SimpleType.construct(Point3D.class);
+
+        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
+        assertNotNull(p);
+        assertEquals(1, p.x);
+        assertEquals(2, p.getY());
+        assertEquals(3, p.z);
+    }
     
     @SuppressWarnings("deprecation")
     public void testExplicitCollectionType() throws Exception
     {
         JavaType elem = SimpleType.construct(Point.class);
-        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");
-        
         JavaType t = CollectionType.construct(List.class, elem);
+
+        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        
+
         List<Point> l = MAPPER.readValue(json, t);
         assertNotNull(l);
         assertEquals(2, l.size());
@@ -50,4 +68,23 @@ public class DeprecatedTypeHandling1102Test extends BaseMapTest
         assertEquals(1, p.x);
         assertEquals(2, p.getY());
     }
+
+    @SuppressWarnings("deprecation")
+    public void testExplicitMapType() throws Exception
+    {
+        JavaType key = SimpleType.construct(String.class);
+        JavaType elem = SimpleType.construct(Point.class);
+        JavaType t = MapType.construct(Map.class, key, elem);
+
+        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        
+
+        Map<String,Point> m = MAPPER.readValue(json, t);
+        assertNotNull(m);
+        assertEquals(1, m.size());
+        Object ob = m.values().iterator().next();
+        assertEquals(Point.class, ob.getClass());
+        Point p = (Point) ob;
+        assertEquals(3, p.x);
+        assertEquals(5, p.getY());
+    }
 }
