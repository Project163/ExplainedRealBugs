diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
index 57a07870c..02afe5fce 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
@@ -434,8 +434,23 @@ public class StdDateFormat
     {
         Calendar cal = _getCalendar(tz);
         cal.setTime(date);
+        // [databind#2167]: handle range beyond [1, 9999]
+        final int year = cal.get(Calendar.YEAR);
 
-        pad4(buffer, cal.get(Calendar.YEAR));
+        // Assuming GregorianCalendar, special handling needed for BCE (aka BC)
+        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {
+            _formatBCEYear(buffer, year);
+        } else {
+            if (year > 9999) {
+                // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but
+                //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement
+                //   for max length would be needed, we ewould need to limit to arbitrary length
+                //   like five digits (erroring out if beyond or padding to that as minimum).
+                //   Instead, let's just print number out as is and let decoder try to make sense of it.
+                buffer.append('+');
+            }
+            pad4(buffer, year);
+        }
         buffer.append('-');
         pad2(buffer, cal.get(Calendar.MONTH) + 1);
         buffer.append('-');
@@ -472,6 +487,21 @@ public class StdDateFormat
         }
     }
 
+    protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {
+        // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become
+        // "+0000", but rest (from `2` up, in that era) need minus sign.
+        if (bceYearNoSign == 1) {
+            buffer.append("+0000");
+            return;
+        }
+        final int isoYear = bceYearNoSign - 1;
+        buffer.append('-');
+        // as with CE, 4 digit variant needs padding; beyond that not (although that part is
+        // open to debate, needs agreement with receiver)
+        // But `pad4()` deals with "big" numbers now so:
+        pad4(buffer, isoYear);
+    }
+
     private static void pad2(StringBuffer buffer, int value) {
         int tens = value / 10;
         if (tens == 0) {
@@ -499,7 +529,11 @@ public class StdDateFormat
         if (h == 0) {
             buffer.append('0').append('0');
         } else {
-            pad2(buffer, h);
+            if (h > 99) { // [databind#2167]: handle above 9999 correctly
+                buffer.append(h);
+            } else {
+                pad2(buffer, h);
+            }
             value -= (100 * h);
         }
         pad2(buffer, value);
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
index 07605755a..e0f38e0cf 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/DateSerializationTest.java
@@ -117,8 +117,38 @@ public class DateSerializationTest
         ObjectMapper mapper = new ObjectMapper();
         mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
 
-        serialize( mapper, judate(1970, 1, 1,  02, 00, 00, 0, "GMT+2"), "1970-01-01T00:00:00.000+0000");
-		serialize( mapper, judate(1970, 1, 1,  00, 00, 00, 0, "UTC"),   "1970-01-01T00:00:00.000+0000");
+        serialize(mapper, judate(1970, 1, 1,  02, 00, 00, 0, "GMT+2"), "1970-01-01T00:00:00.000+0000");
+        serialize(mapper, judate(1970, 1, 1,  00, 00, 00, 0, "UTC"),   "1970-01-01T00:00:00.000+0000");
+
+        // 22-Nov-2018, tatu: Also ensure we use padding...
+        serialize(mapper, judate(911, 1, 1,  00, 00, 00, 0, "UTC"),   "0911-01-01T00:00:00.000+0000");
+        serialize(mapper, judate(87, 1, 1,  00, 00, 00, 0, "UTC"),   "0087-01-01T00:00:00.000+0000");
+        serialize(mapper, judate(1, 1, 1,  00, 00, 00, 0, "UTC"),   "0001-01-01T00:00:00.000+0000");
+    }
+
+    // [databind#2167]: beyond year 9999 needs special handling
+    public void testDateISO8601_10k() throws IOException
+    {
+        ObjectWriter w = MAPPER.writer()
+                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
+        serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, "UTC"),   "+10204-01-01T00:00:00.000+0000");
+        // and although specification lacks for beyond 5 digits (well, actually even 5...), let's do our best:
+        serialize(w, judate(123456, 1, 1,  00, 00, 00, 0, "UTC"),   "+123456-01-01T00:00:00.000+0000");
+    }
+
+    // [databind#2167]: dates before Common Era (CE), that is, BCE, need special care:
+    public void testDateISO8601_BCE() throws IOException
+    {
+        ObjectWriter w = MAPPER.writer()
+                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
+
+        // First: I _think_ BCE-1 is what you get with year 0, and should become "+0000"
+        // and from further back in time, it'll be "-0001" (BCE-2) etc)
+
+        serialize(w, judate(0, 1, 1,  00, 00, 00, 0, "UTC"),   "+0000-01-01T00:00:00.000+0000");
+        serialize(w, judate(-1, 1, 1,  00, 00, 00, 0, "UTC"),   "-0001-01-01T00:00:00.000+0000");
+        serialize(w, judate(-49, 1, 1,  00, 00, 00, 0, "UTC"),   "-0049-01-01T00:00:00.000+0000"); // All hail Caesar
+        serialize(w, judate(-264, 1, 1,  00, 00, 00, 0, "UTC"),   "-0264-01-01T00:00:00.000+0000"); // Carthage FTW?
     }
     
     /**
@@ -329,7 +359,10 @@ public class DateSerializationTest
     }
 
     private void serialize(ObjectMapper mapper, Object date, String expected) throws IOException {
-        String actual = mapper.writeValueAsString(date);
-        Assert.assertEquals(quote(expected), actual);
+        Assert.assertEquals(quote(expected), mapper.writeValueAsString(date));
+    }
+
+    private void serialize(ObjectWriter w, Object date, String expected) throws IOException {
+        Assert.assertEquals(quote(expected), w.writeValueAsString(date));
     }
 }
