diff --git a/release-notes/VERSION b/release-notes/VERSION
index 735bda465..9306254a6 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -22,6 +22,7 @@ Project: jackson-databind
 #865: `JsonFormat.Shape.OBJECT` ignored when class implements `Map.Entry`
 #888: Allow specifying custom exclusion comparator via `@JsonInclude`,
   using `JsonInclude.Include.CUSTOM`
+#994: `DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS` only works for POJOs, Maps
 #1029: Add a way to define property name aliases
 #1035: `@JsonAnySetter` assumes key of `String`, does not consider declared type.
  (reported by Michael F)
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
index c8bac9136..14bddb3ba 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java
@@ -7,13 +7,11 @@ import java.text.*;
 import java.util.*;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
+
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonToken;
-import com.fasterxml.jackson.databind.BeanProperty;
-import com.fasterxml.jackson.databind.DeserializationContext;
-import com.fasterxml.jackson.databind.DeserializationFeature;
-import com.fasterxml.jackson.databind.JsonDeserializer;
-import com.fasterxml.jackson.databind.JsonMappingException;
+
+import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.util.ClassUtil;
@@ -179,8 +177,7 @@ public class DateDeserializers
             throws IOException
         {
             if (_customFormat != null) {
-                JsonToken t = p.getCurrentToken();
-                if (t == JsonToken.VALUE_STRING) {
+                if (p.hasToken(JsonToken.VALUE_STRING)) {
                     String str = p.getText().trim();
                     if (str.length() == 0) {
                         return (Date) getEmptyValue(ctxt);
@@ -194,16 +191,6 @@ public class DateDeserializers
                         }
                     }
                 }
-                // [databind#381]
-                if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                    p.nextToken();
-                    final Date parsed = _parseDate(p, ctxt);
-                    t = p.nextToken();
-                    if (t != JsonToken.END_ARRAY) {
-                        handleMissingEndArrayForSingle(p, ctxt);
-                    }            
-                    return parsed;            
-                }
             }
             return super._parseDate(p, ctxt);
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
index 608a017e5..01cedce7c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
@@ -239,14 +239,8 @@ public class NumberDeserializers
                         "only \"true\" or \"false\" recognized");
             }
             // [databind#381]
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
-                final Boolean parsed = _parseBoolean(p, ctxt);
-                t = p.nextToken();
-                if (t != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }            
-                return parsed;            
+            if (t == JsonToken.START_ARRAY) {
+                return _deserializeFromArray(p, ctxt);
             }
             // Otherwise, no can do:
             return (Boolean) ctxt.handleUnexpectedToken(_valueClass, p);
@@ -314,14 +308,8 @@ public class NumberDeserializers
                 return (Byte) _coerceNullToken(ctxt, _primitive);
             }
             // [databind#381]
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
-                final Byte parsed = _parseByte(p, ctxt);
-                t = p.nextToken();
-                if (t != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }            
-                return parsed;            
+            if (t == JsonToken.START_ARRAY) {
+                return _deserializeFromArray(p, ctxt);
             }
             return (Byte) ctxt.handleUnexpectedToken(_valueClass, p);
         }
@@ -386,15 +374,8 @@ public class NumberDeserializers
             if (t == JsonToken.VALUE_NULL) {
                 return (Short) _coerceNullToken(ctxt, _primitive);
             }
-            // [databind#381]
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
-                final Short parsed = _parseShort(p, ctxt);
-                t = p.nextToken();
-                if (t != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }
-                return parsed;
+            if (t == JsonToken.START_ARRAY) {
+                return _deserializeFromArray(p, ctxt);
             }
             return (Short) ctxt.handleUnexpectedToken(_valueClass, p);
         }
@@ -521,15 +502,7 @@ public class NumberDeserializers
             case JsonTokenId.ID_NULL:
                 return (Integer) _coerceNullToken(ctxt, _primitive);
             case JsonTokenId.ID_START_ARRAY:
-                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                    p.nextToken();
-                    final Integer parsed = _parseInteger(p, ctxt);
-                    if (p.nextToken() != JsonToken.END_ARRAY) {
-                        handleMissingEndArrayForSingle(p, ctxt);
-                    }            
-                    return parsed;            
-                }
-                break;
+                return _deserializeFromArray(p, ctxt);
             }
             // Otherwise, no can do:
             return (Integer) ctxt.handleUnexpectedToken(_valueClass, p);
@@ -591,16 +564,7 @@ public class NumberDeserializers
             case JsonTokenId.ID_NULL:
                 return (Long) _coerceNullToken(ctxt, _primitive);
             case JsonTokenId.ID_START_ARRAY:
-                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                    p.nextToken();
-                    final Long parsed = _parseLong(p, ctxt);
-                    JsonToken t = p.nextToken();
-                    if (t != JsonToken.END_ARRAY) {
-                        handleMissingEndArrayForSingle(p, ctxt);
-                    }            
-                    return parsed;            
-                }
-                break;
+                return _deserializeFromArray(p, ctxt);
             }
             // Otherwise, no can do:
             return (Long) ctxt.handleUnexpectedToken(_valueClass, p);
@@ -670,14 +634,8 @@ public class NumberDeserializers
             if (t == JsonToken.VALUE_NULL) {
                 return (Float) _coerceNullToken(ctxt, _primitive);
             }
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
-                final Float parsed = _parseFloat(p, ctxt);
-                t = p.nextToken();
-                if (t != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }            
-                return parsed;            
+            if (t == JsonToken.START_ARRAY) {
+                return _deserializeFromArray(p, ctxt);
             }
             // Otherwise, no can do:
             return (Float) ctxt.handleUnexpectedToken(_valueClass, p);
@@ -714,7 +672,6 @@ public class NumberDeserializers
         protected final Double _parseDouble(JsonParser p, DeserializationContext ctxt) throws IOException
         {
             JsonToken t = p.getCurrentToken();
-            
             if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
                 return p.getDoubleValue();
             }
@@ -752,14 +709,8 @@ public class NumberDeserializers
             if (t == JsonToken.VALUE_NULL) {
                 return (Double) _coerceNullToken(ctxt, _primitive);
             }
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                p.nextToken();
-                final Double parsed = _parseDouble(p, ctxt);
-                t = p.nextToken();
-                if (t != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }            
-                return parsed;            
+            if (t == JsonToken.START_ARRAY) {
+                return _deserializeFromArray(p, ctxt);
             }
             // Otherwise, no can do:
             return (Double) ctxt.handleUnexpectedToken(_valueClass, p);
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
index f87e7bb61..b4760ccda 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
@@ -43,6 +43,12 @@ public abstract class StdDeserializer<T>
     protected final static int F_MASK_INT_COERCIONS = 
             DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.getMask()
             | DeserializationFeature.USE_LONG_FOR_INTS.getMask();
+
+    // @since 2.9
+    protected final static int F_MASK_ACCEPT_ARRAYS =
+            DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask() |
+            DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT.getMask();
+
     
     /**
      * Type of values this deserializer handles: sometimes
@@ -128,7 +134,7 @@ public abstract class StdDeserializer<T>
             TypeDeserializer typeDeserializer) throws IOException {
         return typeDeserializer.deserializeTypedFromAny(p, ctxt);
     }
-    
+
     /*
     /**********************************************************
     /* Helper methods for sub-classes, parsing: while mostly
@@ -455,26 +461,42 @@ public abstract class StdDeserializer<T>
     protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = p.getCurrentToken();
-        if (t == JsonToken.VALUE_NUMBER_INT) {
+        switch (p.getCurrentTokenId()) {
+        case JsonTokenId.ID_STRING:
+            return _parseDate(p.getText().trim(), ctxt);
+        case JsonTokenId.ID_NUMBER_INT:
             return new java.util.Date(p.getLongValue());
-        }
-        if (t == JsonToken.VALUE_NULL) {
+        case JsonTokenId.ID_NULL:
             return (java.util.Date) getNullValue(ctxt);
-        }
-        if (t == JsonToken.VALUE_STRING) {
-            return _parseDate(p.getText().trim(), ctxt);
-        }
-        // [databind#381]
-        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            p.nextToken();
-            final Date parsed = _parseDate(p, ctxt);
-            _verifyEndArrayForSingle(p, ctxt);
-            return parsed;            
+        case JsonTokenId.ID_START_ARRAY:
+            return _parseDateFromArray(p, ctxt);
         }
         return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, p);
     }
 
+    // @since 2.9
+    protected java.util.Date _parseDateFromArray(JsonParser p, DeserializationContext ctxt)
+            throws IOException
+    {
+        JsonToken t;
+        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {
+            t = p.nextToken();
+            if (t == JsonToken.END_ARRAY) {
+                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
+                    return (java.util.Date) getNullValue(ctxt);
+                }
+            }
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                final Date parsed = _parseDate(p, ctxt);
+                _verifyEndArrayForSingle(p, ctxt);
+                return parsed;            
+            }
+        } else {
+            t = p.getCurrentToken();
+        }
+        return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
+    }
+
     /**
      * @since 2.8
      */
@@ -594,6 +616,78 @@ public abstract class StdDeserializer<T>
 
     protected final boolean _isNaN(String text) { return "NaN".equals(text); }
 
+    /*
+    /**********************************************************
+    /* Helper methods for sub-classes regarding decoding from
+    /* alternate representations
+    /**********************************************************
+     */
+
+    /**
+     * Helper method that allows easy support for array-related {@link DeserializationFeature}s
+     * `ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT` and `UNWRAP_SINGLE_VALUE_ARRAYS`: checks for either
+     * empty array, or single-value array-wrapped value (respectively), and either reports
+     * an exception (if no match, or feature(s) not enabled), or returns appropriate
+     * result value.
+     *<p>
+     * This method should NOT be called if Array representation is explicitly supported
+     * for type: it should only be called in case it is otherwise unrecognized.
+     *<p>
+     * NOTE: in case of unwrapped single element, will handle actual decoding
+     * by calling {@link #_deserializeWrappedValue}, which by default calls
+     * {@link #deserialize(JsonParser, DeserializationContext)}.
+     *
+     * @since 2.9
+     */
+    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
+    {
+        JsonToken t;
+        if (ctxt.hasSomeOfFeatures(F_MASK_ACCEPT_ARRAYS)) {
+            t = p.nextToken();
+            if (t == JsonToken.END_ARRAY) {
+                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
+                    return getNullValue(ctxt);
+                }
+            }
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                final T parsed = deserialize(p, ctxt);
+                if (p.nextToken() != JsonToken.END_ARRAY) {
+                    handleMissingEndArrayForSingle(p, ctxt);
+                }
+                return parsed;            
+            }
+        } else {
+            t = p.getCurrentToken();
+        }
+        @SuppressWarnings("unchecked")
+        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
+        return result;
+    }
+
+    /**
+     * Helper called to support {@link DeserializationFeature#UNWRAP_SINGLE_VALUE_ARRAYS}:
+     * default implementation simply calls
+     * {@link #deserialize(JsonParser, DeserializationContext)},
+     * but handling may be overridden.
+     *
+     * @since 2.9
+     */
+    protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException
+    {
+        // 23-Mar-2017, tatu: Let's specifically block recursive resolution to avoid
+        //   either supporting nested arrays, or to cause infinite looping.
+        if (p.hasToken(JsonToken.START_ARRAY)) {
+            String msg = String.format(
+"Can not deserialize instance of %s out of %s token: nested Arrays not allowed with %s",
+                    ClassUtil.nameOf(_valueClass), JsonToken.START_ARRAY,
+                    "DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS");
+            @SuppressWarnings("unchecked")
+            T result = (T) ctxt.handleUnexpectedToken(_valueClass, p.getCurrentToken(), p, msg);
+            return result;
+        }
+        return (T) deserialize(p, ctxt);
+    }
+
     /*
     /****************************************************
     /* Helper methods for sub-classes, coercions
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java
index fec7d03ac..8a91bff0c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java
@@ -3,10 +3,7 @@ package com.fasterxml.jackson.databind.deser.std;
 import java.io.IOException;
 
 import com.fasterxml.jackson.core.*;
-import com.fasterxml.jackson.databind.DeserializationConfig;
-import com.fasterxml.jackson.databind.DeserializationContext;
-import com.fasterxml.jackson.databind.DeserializationFeature;
-import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 import com.fasterxml.jackson.databind.util.AccessPattern;
 
@@ -16,11 +13,6 @@ import com.fasterxml.jackson.databind.util.AccessPattern;
  */
 public abstract class StdScalarDeserializer<T> extends StdDeserializer<T>
 {
-    // @since 2.8.8
-    protected final static int FEATURES_ACCEPT_ARRAYS =
-            DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask() |
-            DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT.getMask();
-
     private static final long serialVersionUID = 1L;
 
     protected StdScalarDeserializer(Class<?> vc) { super(vc); }
@@ -67,29 +59,4 @@ public abstract class StdScalarDeserializer<T> extends StdDeserializer<T>
     public AccessPattern getEmptyAccessPattern() {
         return AccessPattern.CONSTANT;
     }
-
-    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
-    {
-        JsonToken t;
-        if (ctxt.hasSomeOfFeatures(FEATURES_ACCEPT_ARRAYS)) {
-            t = p.nextToken();
-            if (t == JsonToken.END_ARRAY) {
-                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
-                    return getNullValue(ctxt);
-                }
-            }
-            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                final T parsed = deserialize(p, ctxt);
-                if (p.nextToken() != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }
-                return parsed;            
-            }
-        } else {
-            t = p.getCurrentToken();
-        }
-        @SuppressWarnings("unchecked")
-        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
-        return result;
-    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java
index 8f0081b7d..a889c9322 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java
@@ -12,11 +12,6 @@ public class StringDeserializer extends StdScalarDeserializer<String> // non-fin
 {
     private static final long serialVersionUID = 1L;
 
-    // @since 2.8.8
-    protected final static int FEATURES_ACCEPT_ARRAYS =
-            DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask() |
-            DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT.getMask();
-    
     /**
      * @since 2.2
      */
@@ -70,28 +65,4 @@ public class StringDeserializer extends StdScalarDeserializer<String> // non-fin
     public String deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
         return deserialize(p, ctxt);
     }
-
-    // @since 2.8.8
-    protected String _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
-    {
-        JsonToken t;
-        if (ctxt.hasSomeOfFeatures(FEATURES_ACCEPT_ARRAYS)) {
-            t = p.nextToken();
-            if (t == JsonToken.END_ARRAY) {
-                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
-                    return getNullValue(ctxt);
-                }
-            }
-            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                final String parsed = _parseString(p, ctxt);
-                if (p.nextToken() != JsonToken.END_ARRAY) {
-                    handleMissingEndArrayForSingle(p, ctxt);
-                }
-                return parsed;            
-            }
-        } else {
-            t = p.getCurrentToken();
-        }
-        return (String) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
-    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/struct/EmptyArrayAsNullTest.java b/src/test/java/com/fasterxml/jackson/databind/struct/EmptyArrayAsNullTest.java
index 5199545a5..71aba3253 100644
--- a/src/test/java/com/fasterxml/jackson/databind/struct/EmptyArrayAsNullTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/struct/EmptyArrayAsNullTest.java
@@ -2,11 +2,8 @@ package com.fasterxml.jackson.databind.struct;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.EnumMap;
-import java.util.Map;
-import java.util.UUID;
+
+import java.util.*;
 
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.*;
@@ -105,14 +102,14 @@ public class EmptyArrayAsNullTest extends BaseMapTest
 
     public void testWrapperFromEmptyArray() throws Exception
     {
-//        _testNullWrapper(Boolean.class);
-//        _testNullWrapper(Byte.class);
+        _testNullWrapper(Boolean.class);
+        _testNullWrapper(Byte.class);
         _testNullWrapper(Character.class);
-//        _testNullWrapper(Short.class);
-//        _testNullWrapper(Integer.class);
-//        _testNullWrapper(Long.class);
-//        _testNullWrapper(Float.class);
-//        _testNullWrapper(Double.class);
+        _testNullWrapper(Short.class);
+        _testNullWrapper(Integer.class);
+        _testNullWrapper(Long.class);
+        _testNullWrapper(Float.class);
+        _testNullWrapper(Double.class);
     }
 
     /*
@@ -136,10 +133,8 @@ public class EmptyArrayAsNullTest extends BaseMapTest
 
         _testNullWrapper(UUID.class);
 
-        /*
         _testNullWrapper(Date.class);
         _testNullWrapper(Calendar.class);
-        */
     }
 
     /*
