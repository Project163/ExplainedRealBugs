diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 1081d5fa4..e3a7ea18e 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -647,3 +647,7 @@ Jared Jacobs (2is10@github)
   * Requested #1605: Allow serialization of `InetAddress` as simple numeric host address
    (2.9.0)
 
+Patrick Gunia (pgunia@github)
+  * Reported #1440: Wrong `JsonStreamContext` in `DeserializationProblemHandler` when reading
+  `TokenBuffer` content
+   (2.9.0)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 541f6b4b6..3792d1517 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -55,6 +55,9 @@ Project: jackson-databind
 #1433: `ObjectMapper.convertValue()` with null does not consider null conversions
   (`JsonDeserializer.getNullValue()`)
  (contributed by jdmichal@github)
+#1440: Wrong `JsonStreamContext` in `DeserializationProblemHandler` when reading
+  `TokenBuffer` content
+ (reported by Patrick G)
 #1444: Change `ObjectMapper.setSerializationInclusion()` to apply to content inclusion too
 #1450: `SimpleModule.addKeyDeserializer()' should throw `IllegalArgumentException` if `null`
   reference of `KeyDeserializer` passed
diff --git a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java
index 6a023ae16..2e884aaac 100644
--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java
+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java
@@ -157,24 +157,20 @@ public class ArrayNode
         for (int i = 0; i < size; ++i) { // we'll typically have array list
             // For now, assuming it's either BaseJsonNode, JsonSerializable
             JsonNode n = c.get(i);
-            if (n instanceof BaseJsonNode) {
-                ((BaseJsonNode) n).serialize(f, provider);
-            } else {
-                ((JsonSerializable) n).serialize(f, provider);
-            }
+            ((BaseJsonNode) n).serialize(f, provider);
         }
         f.writeEndArray();
     }
 
     @Override
-    public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer)
+    public void serializeWithType(JsonGenerator g, SerializerProvider provider, TypeSerializer typeSer)
         throws IOException
     {
-        typeSer.writeTypePrefixForArray(this, jg);
+        typeSer.writeTypePrefixForArray(this, g);
         for (JsonNode n : _children) {
-            ((BaseJsonNode)n).serialize(jg, provider);
+            ((BaseJsonNode)n).serialize(g, provider);
         }
-        typeSer.writeTypeSuffixForArray(this, jg);
+        typeSer.writeTypeSuffixForArray(this, g);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
index c62146382..0d3a4af69 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
@@ -7,7 +7,6 @@ import java.util.TreeMap;
 
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.core.base.ParserMinimalBase;
-import com.fasterxml.jackson.core.json.JsonReadContext;
 import com.fasterxml.jackson.core.json.JsonWriteContext;
 import com.fasterxml.jackson.core.util.ByteArrayBuilder;
 import com.fasterxml.jackson.databind.*;
@@ -45,6 +44,14 @@ public class TokenBuffer
      */
     protected ObjectCodec _objectCodec;
 
+    /**
+     * Parse context from "parent" parser (one from which content to buffer is read,
+     * if specified). Used, if available, when reading content, to present full
+     * context as if content was read from the original parser: this is useful
+     * in error reporting and sometimes processing as well.
+     */
+    protected JsonStreamContext _parentContext;
+
     /**
      * Bit flag composed of bits that indicate which
      * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s
@@ -132,18 +139,6 @@ public class TokenBuffer
     /**********************************************************
      */
 
-    /**
-     * @param codec Object codec to use for stream-based object
-     *   conversion through parser/generator interfaces. If null,
-     *   such methods can not be used.
-     *   
-     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.
-     */
-    @Deprecated
-    public TokenBuffer(ObjectCodec codec) {
-        this(codec, false);
-    }
-
     /**
      * @param codec Object codec to use for stream-based object
      *   conversion through parser/generator interfaces. If null,
@@ -178,6 +173,7 @@ public class TokenBuffer
     public TokenBuffer(JsonParser p, DeserializationContext ctxt)
     {
         _objectCodec = p.getCodec();
+        _parentContext = p.getParsingContext();
         _generatorFeatures = DEFAULT_GENERATOR_FEATURES;
         _writeContext = JsonWriteContext.createRootContext(null);
         // at first we have just one segment
@@ -206,6 +202,19 @@ public class TokenBuffer
         return b;
     }
 
+    /**
+     * Method that allows explicitly specifying parent parse context to associate
+     * with contents of this buffer. Usually context is assigned at construction,
+     * based on given parser; but it is not always available, and may not contain
+     * intended context.
+     *
+     * @since 2.9
+     */
+    public TokenBuffer overrideParentContext(JsonStreamContext ctxt) {
+        _parentContext = ctxt;
+        return this;
+    }
+
     /**
      * @since 2.7
      */
@@ -264,7 +273,7 @@ public class TokenBuffer
      */
     public JsonParser asParser(ObjectCodec codec)
     {
-        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);
+        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds, _parentContext);
     }
 
     /**
@@ -273,7 +282,7 @@ public class TokenBuffer
      */
     public JsonParser asParser(JsonParser src)
     {
-        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);
+        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds, _parentContext);
         p.setLocation(src.getTokenLocation());
         return p;
     }
@@ -1257,7 +1266,7 @@ sb.append("NativeObjectIds=").append(_hasNativeObjectIds).append(",");
          * Information about parser context, context in which
          * the next token is to be parsed (root, array, object).
          */
-        protected JsonReadContext _parsingContext;
+        protected TokenBufferReadContext _parsingContext;
         
         protected boolean _closed;
 
@@ -1271,15 +1280,22 @@ sb.append("NativeObjectIds=").append(_hasNativeObjectIds).append(",");
         /**********************************************************
          */
 
+        @Deprecated // since 2.9
+        public Parser(Segment firstSeg, ObjectCodec codec,
+                boolean hasNativeTypeIds, boolean hasNativeObjectIds)
+        {
+            this(firstSeg, codec, hasNativeTypeIds, hasNativeObjectIds, null);
+        }
+        
         public Parser(Segment firstSeg, ObjectCodec codec,
-                boolean hasNativeTypeIds,
-                boolean hasNativeObjectIds)
+                boolean hasNativeTypeIds, boolean hasNativeObjectIds,
+                JsonStreamContext parentContext)
         {
             super(0);
             _segment = firstSeg;
             _segmentPtr = -1; // not yet read
             _codec = codec;
-            _parsingContext = JsonReadContext.createRootContext(null);
+            _parsingContext = TokenBufferReadContext.createRootContext(parentContext);
             _hasNativeTypeIds = hasNativeTypeIds;
             _hasNativeObjectIds = hasNativeObjectIds;
             _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);
@@ -1359,17 +1375,13 @@ sb.append("NativeObjectIds=").append(_hasNativeObjectIds).append(",");
                 String name = (ob instanceof String) ? ((String) ob) : ob.toString();
                 _parsingContext.setCurrentName(name);
             } else if (_currToken == JsonToken.START_OBJECT) {
-                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);
+                _parsingContext = _parsingContext.createChildObjectContext();
             } else if (_currToken == JsonToken.START_ARRAY) {
-                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);
+                _parsingContext = _parsingContext.createChildArrayContext();
             } else if (_currToken == JsonToken.END_OBJECT
                     || _currToken == JsonToken.END_ARRAY) {
                 // Closing JSON Object/Array? Close matching context
-                _parsingContext = _parsingContext.getParent();
-                // but allow unbalanced cases too (more close markers)
-                if (_parsingContext == null) {
-                    _parsingContext = JsonReadContext.createRootContext(null);
-                }
+                _parsingContext = _parsingContext.parentOrCopy();
             }
             return _currToken;
         }
@@ -1415,7 +1427,7 @@ sb.append("NativeObjectIds=").append(_hasNativeObjectIds).append(",");
         public String getCurrentName() {
             // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase
             if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {
-                JsonReadContext parent = _parsingContext.getParent();
+                JsonStreamContext parent = _parsingContext.getParent();
                 return parent.getCurrentName();
             }
             return _parsingContext.getCurrentName();
@@ -1425,14 +1437,16 @@ sb.append("NativeObjectIds=").append(_hasNativeObjectIds).append(",");
         public void overrideCurrentName(String name)
         {
             // Simple, but need to look for START_OBJECT/ARRAY's "off-by-one" thing:
-            JsonReadContext ctxt = _parsingContext;
+            JsonStreamContext ctxt = _parsingContext;
             if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {
                 ctxt = ctxt.getParent();
             }
-            try {
-                ctxt.setCurrentName(name);
-            } catch (IOException e) {
-                throw new RuntimeException(e);
+            if (ctxt instanceof TokenBufferReadContext) {
+                try {
+                    ((TokenBufferReadContext) ctxt).setCurrentName(name);
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
             }
         }
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBufferReadContext.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBufferReadContext.java
new file mode 100644
index 000000000..66520368e
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBufferReadContext.java
@@ -0,0 +1,135 @@
+package com.fasterxml.jackson.databind.util;
+
+import com.fasterxml.jackson.core.*;
+import com.fasterxml.jackson.core.json.JsonReadContext;
+
+/**
+ * Implementation of {@link JsonStreamContext} used by {@link TokenBuffer}
+ * to link back to the original context to try to keep location information
+ * consistent between source location and buffered content when it's re-read
+ * from the buffer.
+ *
+ * @since 2.9
+ */
+public class TokenBufferReadContext extends JsonStreamContext
+{
+    protected final JsonStreamContext _parent;
+
+    protected final JsonLocation _startLocation;
+
+    // Benefit for reusing?
+//    protected JsonReadContext _child;
+
+    /*
+    /**********************************************************
+    /* Location/state information (minus source reference)
+    /**********************************************************
+     */
+
+    protected String _currentName;
+
+    protected Object _currentValue;
+
+    protected TokenBufferReadContext(JsonStreamContext base, Object srcRef) {
+        super(base);
+        _parent = base.getParent();
+        _currentName = base.getCurrentName();
+        _currentValue = base.getCurrentValue();
+        if (base instanceof JsonReadContext) {
+            JsonReadContext rc = (JsonReadContext) base;
+            _startLocation = rc.getStartLocation(srcRef);
+        } else {
+            _startLocation = JsonLocation.NA;
+        }
+    }
+
+    protected TokenBufferReadContext(JsonStreamContext base, JsonLocation startLoc) {
+        super(base);
+        _parent = base.getParent();
+        _currentName = base.getCurrentName();
+        _currentValue = base.getCurrentValue();
+        _startLocation = startLoc;
+    }
+
+    /**
+     * Constructor for case where there is no real surrounding context: just create
+     * virtual ROOT
+     */
+    protected TokenBufferReadContext() {
+        super(TYPE_ROOT, -1);
+        _parent = null;
+        _startLocation = JsonLocation.NA;
+    }
+
+    protected TokenBufferReadContext(TokenBufferReadContext parent, int type, int index) {
+        super(type, index);
+        _parent = parent;
+        _startLocation = parent._startLocation;
+    }
+
+    @Override
+    public Object getCurrentValue() {
+        return _currentValue;
+    }
+
+    @Override
+    public void setCurrentValue(Object v) {
+        _currentValue = v;
+    }
+
+    /*
+    /**********************************************************
+    /* Factory methods
+    /**********************************************************
+     */
+
+    public static TokenBufferReadContext createRootContext(JsonStreamContext origContext) {
+        // First: possible to have no current context; if so, just create bogus ROOT context
+        if (origContext == null) {
+            return new TokenBufferReadContext();
+        }
+        return new TokenBufferReadContext(origContext, null);
+    }
+
+    public TokenBufferReadContext createChildArrayContext() {
+        return new TokenBufferReadContext(this, TYPE_ARRAY, -1);
+    }
+
+    public TokenBufferReadContext createChildObjectContext() {
+        return new TokenBufferReadContext(this, TYPE_OBJECT, -1);
+    }
+
+    /**
+     * Helper method we need to handle discontinuity between "real" contexts buffer
+     * creates, and ones from parent: problem being they are of different types.
+     */
+    public TokenBufferReadContext parentOrCopy() {
+        // 30-Apr-2017, tatu: This is bit awkward since part on ancestor stack is of different
+        //     type (usually `JsonReadContext`)... and so for unbalanced buffers (with extra
+        //     END_OBJECT / END_ARRAY), we may need to create 
+        if (_parent instanceof TokenBufferReadContext) {
+            return (TokenBufferReadContext) _parent;
+        }
+        if (_parent == null) { // unlikely, but just in case let's support
+            return new TokenBufferReadContext();
+        }
+        return new TokenBufferReadContext(_parent, _startLocation);
+    }
+
+    /*
+    /**********************************************************
+    /* Abstract method implementation
+    /**********************************************************
+     */
+
+    @Override public String getCurrentName() { return _currentName; }
+
+    // @since 2.9
+    @Override public boolean hasCurrentName() { return _currentName != null; }
+
+    @Override public JsonStreamContext getParent() { return _parent; }
+
+    public void setCurrentName(String name) throws JsonProcessingException {
+        _currentName = name;
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/failing/IncorrectContext1440Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/filter/ProblemHandlerLocation1440Test.java
similarity index 95%
rename from src/test/java/com/fasterxml/jackson/failing/IncorrectContext1440Test.java
rename to src/test/java/com/fasterxml/jackson/databind/deser/filter/ProblemHandlerLocation1440Test.java
index dc7a9a2d0..14464e7b4 100644
--- a/src/test/java/com/fasterxml/jackson/failing/IncorrectContext1440Test.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/filter/ProblemHandlerLocation1440Test.java
@@ -1,4 +1,4 @@
-package com.fasterxml.jackson.failing;
+package com.fasterxml.jackson.databind.deser.filter;
 
 import java.io.IOException;
 import java.util.*;
@@ -10,7 +10,8 @@ import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;
 
-public class IncorrectContext1440Test extends BaseMapTest
+// Test(s) to verify [databind#1440]
+public class ProblemHandlerLocation1440Test extends BaseMapTest
 {
     static class DeserializationProblem {
         public List<String> unknownProperties = new ArrayList<>();
@@ -44,9 +45,6 @@ public class IncorrectContext1440Test extends BaseMapTest
                         throws IOException
         {
             final JsonStreamContext parsingContext = p.getParsingContext();
-
-//    System.err.println("DEBUG: parser == "+p.getClass());
-
             final List<String> pathList = new ArrayList<>();
             addParent(parsingContext, pathList);
             Collections.reverse(pathList);
@@ -136,7 +134,7 @@ public class IncorrectContext1440Test extends BaseMapTest
         List<String> probs = logger.problems();
         assertEquals(4, probs.size());
         assertEquals("actor.invalid_1#invalid_1", probs.get(0));
-        assertEquals("object.object_invalid_2#object_invalid_2", probs.get(1));
+        assertEquals("object.invalid_2#invalid_2", probs.get(1));
         assertEquals("target.invalid_3#invalid_3", probs.get(2));
         assertEquals("target.invalid_4#invalid_4", probs.get(3));
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/util/JsonParserSequenceTest.java b/src/test/java/com/fasterxml/jackson/databind/util/JsonParserSequenceTest.java
index e8faedde8..b7b62280a 100644
--- a/src/test/java/com/fasterxml/jackson/databind/util/JsonParserSequenceTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/util/JsonParserSequenceTest.java
@@ -13,6 +13,7 @@ public class JsonParserSequenceTest extends BaseMapTest {
     /**
      * Verifies fix for [core#372]
      */
+    @SuppressWarnings("resource")
     public void testJsonParserSequenceOverridesSkipChildren() throws Exception
     {
         // Create parser from TokenBuffer containing an incomplete JSON object
