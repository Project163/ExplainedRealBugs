diff --git a/release-notes/VERSION b/release-notes/VERSION
index c2ec48ef9..5c366cf36 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -10,6 +10,9 @@ Project: jackson-databind
 #348: ObjectMapper.valueToTree does not work with @JsonRawValue
  (reported by Chris P, pimlottc@github)
 #649: Make `BeanDeserializer` use new `parser.nextFieldName()` and `.hasTokenId()` methods
+#664: Add `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to prevent coercion of floating point
+ numbers int `int`/`long`/`Integer`/`Long`
+ (requested by wenzis@github)
 #679: Add `isEmpty()` implementation for `JsonNode` serializers
 #688: Provide a means for an ObjectMapper to discover mixin annotation classes on demand
  (requested by Laird N)
diff --git a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
index 77aca58d6..31e094cbd 100644
--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
@@ -685,7 +685,8 @@ public abstract class DeserializationContext
             DateFormat df = getDateFormat();
             return df.parse(dateStr);
         } catch (ParseException e) {
-            throw new IllegalArgumentException("Failed to parse Date value '"+dateStr+"': "+e.getMessage());
+            throw new IllegalArgumentException(String.format(
+                    "Failed to parse Date value '%s': %s", dateStr, e.getMessage()));
         }
     }
 
@@ -826,7 +827,9 @@ public abstract class DeserializationContext
     }
 
     public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {
-        return JsonMappingException.from(_parser, "Can not deserialize instance of "+_calcName(targetClass)+" out of "+token+" token");
+        return JsonMappingException.from(_parser,
+                String.format("Can not deserialize instance of %s out of %s token",
+                        _calcName(targetClass), token));
     }
     
     /**
@@ -844,23 +847,12 @@ public abstract class DeserializationContext
      */
     public JsonMappingException instantiationException(Class<?> instClass, Throwable t) {
         return JsonMappingException.from(_parser,
-                "Can not construct instance of "+instClass.getName()+", problem: "+t.getMessage(), t);
+                String.format("Can not construct instance of %s, problem: %s", instClass.getName(), t.getMessage()), t);
     }
 
     public JsonMappingException instantiationException(Class<?> instClass, String msg) {
-        return JsonMappingException.from(_parser, "Can not construct instance of "+instClass.getName()+", problem: "+msg);
-    }
-    
-    /**
-     * Method that will construct an exception suitable for throwing when
-     * some String values are acceptable, but the one encountered is not.
-     * 
-     * 
-     * @deprecated Since 2.1 should use variant that takes value
-     */
-    @Deprecated
-    public JsonMappingException weirdStringException(Class<?> instClass, String msg) {
-        return weirdStringException(null, instClass, msg);
+        return JsonMappingException.from(_parser,
+                String.format("Can not construct instance of %s, problem: %s", instClass.getName(), msg));
     }
 
     /**
@@ -875,26 +867,19 @@ public abstract class DeserializationContext
      */
     public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg) {
         return InvalidFormatException.from(_parser,
-                "Can not construct instance of "+instClass.getName()+" from String value '"+_valueDesc()+"': "+msg,
+                String.format("Can not construct instance of %s from String value '%s': %s",
+                        instClass.getName(), _valueDesc(), msg),
                 value, instClass);
     }
 
-    /**
-     * Helper method for constructing exception to indicate that input JSON
-     * Number was not suitable for deserializing into given type.
-     */
-    @Deprecated
-    public JsonMappingException weirdNumberException(Class<?> instClass, String msg) {
-        return weirdStringException(null, instClass, msg);
-    }
-
     /**
      * Helper method for constructing exception to indicate that input JSON
      * Number was not suitable for deserializing into given target type.
      */
     public JsonMappingException weirdNumberException(Number value, Class<?> instClass, String msg) {
         return InvalidFormatException.from(_parser,
-                "Can not construct instance of "+instClass.getName()+" from number value ("+_valueDesc()+"): "+msg,
+                String.format("Can not construct instance of %s from number value (%s): %s",
+                        instClass.getName(), _valueDesc(), msg),
                 null, instClass);
     }
     
@@ -905,7 +890,8 @@ public abstract class DeserializationContext
      */
     public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) {
         return InvalidFormatException.from(_parser,
-                "Can not construct Map key of type "+keyClass.getName()+" from String \""+_desc(keyValue)+"\": "+msg,
+                String.format("Can not construct Map key of type %s from String \"%s\": ",
+                        keyClass.getName(), _desc(keyValue), msg),
                 keyValue, keyClass);
     }
 
@@ -914,7 +900,8 @@ public abstract class DeserializationContext
      * token.
      */
     public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg0) {
-        String msg = "Unexpected token ("+p.getCurrentToken()+"), expected "+expToken;
+        String msg = String.format("Unexpected token (%s), expected %s",
+                p.getCurrentToken(), expToken);
         if (msg0 != null) {
             msg = msg + ": "+msg0;
         }
diff --git a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java
index 608674386..a3fefd8b5 100644
--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java
+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java
@@ -280,6 +280,20 @@ public enum DeserializationFeature implements ConfigFeature
      * @since 2.5
      */
     ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT(false),
+
+    /**
+     * Feature that determines whether coercion from JSON floating point
+     * number (anything with command (`.`) or exponent portion (`e` / `E'))
+     * to an expected integral number (`int`, `long`, `java.lang.Integer`, `java.lang.Long`,
+     * `java.math.BigDecimal`) is allowed or not.
+     * If enabled, coercion truncates value; if disabled, a {@link JsonMappingException}
+     * will be thrown.
+     *<p>
+     * Feature is enabled by default.
+     * 
+     * @since 2.6
+     */
+    ACCEPT_FLOAT_AS_INT(true),
     
     /**
      * Feature that allows unknown Enum values to be parsed as null values. 
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
index 9154ece6e..d7cc4bcfa 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
@@ -8,6 +8,7 @@ import java.util.HashSet;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.core.JsonTokenId;
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonDeserializer;
@@ -233,19 +234,19 @@ public class NumberDeserializers
         }
 
         @Override
-        public Character deserialize(JsonParser jp, DeserializationContext ctxt)
+        public Character deserialize(JsonParser p, DeserializationContext ctxt)
             throws IOException, JsonProcessingException
         {
-            JsonToken t = jp.getCurrentToken();
-            
-            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value
-                int value = jp.getIntValue();
+            switch (p.getCurrentTokenId()) {
+            case JsonTokenId.ID_NUMBER_INT: // ok iff ascii value
+                int value = p.getIntValue();
                 if (value >= 0 && value <= 0xFFFF) {
                     return Character.valueOf((char) value);
                 }
-            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type
+                break;
+            case JsonTokenId.ID_STRING: // this is the usual type
                 // But does it have to be exactly one char?
-                String text = jp.getText();
+                String text = p.getText();
                 if (text.length() == 1) {
                     return Character.valueOf(text.charAt(0));
                 }
@@ -253,18 +254,20 @@ public class NumberDeserializers
                 if (text.length() == 0) {
                     return (Character) getEmptyValue();
                 }               
-            } else if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                //Issue#381
-                jp.nextToken();
-                final Character value = deserialize(jp, ctxt);
-                if (jp.nextToken() != JsonToken.END_ARRAY) {
-                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
-                            "Attempted to unwrap single value array for single '" + _valueClass.getName() + "' value but there was more than a single value in the array"
-                            );
+                break;
+            case JsonTokenId.ID_START_ARRAY:
+                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                    p.nextToken();
+                    final Character C = deserialize(p, ctxt);
+                    if (p.nextToken() != JsonToken.END_ARRAY) {
+                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
+                                "Attempted to unwrap single value array for single '" + _valueClass.getName() + "' value but there was more than a single value in the array"
+                                );
+                    }
+                    return C;
                 }
-                return value;
             }
-            throw ctxt.mappingException(_valueClass, t);
+            throw ctxt.mappingException(_valueClass, p.getCurrentToken());
         }
     }
 
@@ -286,17 +289,23 @@ public class NumberDeserializers
         public boolean isCachable() { return true; }
 
         @Override
-        public Integer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
-            return _parseInteger(jp, ctxt);
+        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
+                return p.getIntValue();
+            }
+            return _parseInteger(p, ctxt);
         }
 
         // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
         // (is it an error to even call this version?)
         @Override
-        public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt,
+        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt,
                 TypeDeserializer typeDeserializer) throws IOException
         {
-            return _parseInteger(jp, ctxt);
+            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
+                return p.getIntValue();
+            }
+            return _parseInteger(p, ctxt);
         }
     }
 
@@ -318,8 +327,11 @@ public class NumberDeserializers
         public boolean isCachable() { return true; }
         
         @Override
-        public Long deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
-            return _parseLong(jp, ctxt);
+        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
+                return p.getLongValue();
+            }
+            return _parseLong(p, ctxt);
         }
     }
 
@@ -394,29 +406,25 @@ public class NumberDeserializers
         public NumberDeserializer() { super(Number.class); }
 
         @Override
-        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
+        public Number deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
-            JsonToken t = jp.getCurrentToken();
-            if (t == JsonToken.VALUE_NUMBER_INT) {
+            switch (p.getCurrentTokenId()) {
+            case JsonTokenId.ID_NUMBER_INT:
                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {
-                    return jp.getBigIntegerValue();
+                    return p.getBigIntegerValue();
                 }
-                return jp.getNumberValue();
-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {
-                /* [JACKSON-72]: need to allow overriding the behavior
-                 * regarding which type to use
-                 */
+                return p.getNumberValue();
+            case JsonTokenId.ID_NUMBER_FLOAT:
                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
-                    return jp.getDecimalValue();
+                    return p.getDecimalValue();
                 }
-                return Double.valueOf(jp.getDoubleValue());
-            }
+                return Double.valueOf(p.getDoubleValue());
 
-            /* Textual values are more difficult... not parsing itself, but figuring
-             * out 'minimal' type to use 
-             */
-            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-                String text = jp.getText().trim();
+            case JsonTokenId.ID_STRING:
+                /* Textual values are more difficult... not parsing itself, but figuring
+                 * out 'minimal' type to use 
+                 */
+                String text = p.getText().trim();
                 if (text.length() == 0) {
                     return getEmptyValue();
                 }
@@ -450,20 +458,21 @@ public class NumberDeserializers
                 } catch (IllegalArgumentException iae) {
                     throw ctxt.weirdStringException(text, _valueClass, "not a valid number");
                 }
-            }
-            
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                jp.nextToken();
-                final Number value = deserialize(jp, ctxt);
-                if (jp.nextToken() != JsonToken.END_ARRAY) {
-                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
-                            "Attempted to unwrap single value array for single '" + _valueClass.getName() + "' value but there was more than a single value in the array"
-                            );
+            case JsonTokenId.ID_START_ARRAY:
+                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                    p.nextToken();
+                    final Number value = deserialize(p, ctxt);
+                    if (p.nextToken() != JsonToken.END_ARRAY) {
+                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
+                                "Attempted to unwrap single value array for single '" + _valueClass.getName() + "' value but there was more than a single value in the array"
+                                );
+                    }
+                    return value;
                 }
-                return value;
+                break;
             }
             // Otherwise, no can do:
-            throw ctxt.mappingException(_valueClass, t);
+            throw ctxt.mappingException(_valueClass, p.getCurrentToken());
         }
 
         /**
@@ -472,16 +481,15 @@ public class NumberDeserializers
          * we must actually check for "raw" integers and doubles first, before
          * calling type deserializer.
          */
-        @SuppressWarnings("incomplete-switch")
         @Override
         public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
                                           TypeDeserializer typeDeserializer)
             throws IOException
         {
-            switch (jp.getCurrentToken()) {
-            case VALUE_NUMBER_INT:
-            case VALUE_NUMBER_FLOAT:
-            case VALUE_STRING:
+            switch (jp.getCurrentTokenId()) {
+            case JsonTokenId.ID_NUMBER_INT:
+            case JsonTokenId.ID_NUMBER_FLOAT:
+            case JsonTokenId.ID_STRING:
                 // can not point to type information: hence must be non-typed (int/double)
                 return deserialize(jp, ctxt);
             }
@@ -511,45 +519,47 @@ public class NumberDeserializers
 
         @SuppressWarnings("incomplete-switch")
         @Override
-        public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)
-            throws IOException
+        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
-            JsonToken t = jp.getCurrentToken();
-            String text;
-
-            if (t == JsonToken.VALUE_NUMBER_INT) {
-                switch (jp.getNumberType()) {
+            switch (p.getCurrentTokenId()) {
+            case JsonTokenId.ID_NUMBER_INT:
+                switch (p.getNumberType()) {
                 case INT:
                 case LONG:
-                    return BigInteger.valueOf(jp.getLongValue());
+                case BIG_INTEGER:
+                    return p.getBigIntegerValue();
                 }
-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {
-                /* Whether to fail if there's non-integer part?
-                 * Could do by calling BigDecimal.toBigIntegerExact()
-                 */
-                return jp.getDecimalValue().toBigInteger();
-            } else if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                jp.nextToken();
-                final BigInteger value = deserialize(jp, ctxt);
-                if (jp.nextToken() != JsonToken.END_ARRAY) {
-                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY,
-                        "Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array"
-                    );
+                break;
+            case JsonTokenId.ID_NUMBER_FLOAT:
+                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                    _failDoubleToIntCoercion(p, ctxt, "java.math.BigInteger");
+                }
+                return p.getDecimalValue().toBigInteger();
+            case JsonTokenId.ID_START_ARRAY:
+                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                    p.nextToken();
+                    final BigInteger value = deserialize(p, ctxt);
+                    if (p.nextToken() != JsonToken.END_ARRAY) {
+                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,
+                            "Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array"
+                        );
+                    }
+                    return value;
+                }
+                break;
+            case JsonTokenId.ID_STRING: // let's do implicit re-parse
+                String text = p.getText().trim();
+                if (text.length() == 0) {
+                    return null;
+                }
+                try {
+                    return new BigInteger(text);
+                } catch (IllegalArgumentException iae) {
+                    throw ctxt.weirdStringException(text, _valueClass, "not a valid representation");
                 }
-                return value;
-            } else if (t != JsonToken.VALUE_STRING) { // let's do implicit re-parse
-                // String is ok too, can easily convert; otherwise, no can do:
-                throw ctxt.mappingException(_valueClass, t);
-            }            
-            text = jp.getText().trim();
-            if (text.length() == 0) {
-                return null;
-            }
-            try {
-                return new BigInteger(text);
-            } catch (IllegalArgumentException iae) {
-                throw ctxt.weirdStringException(text, _valueClass, "not a valid representation");
             }
+            // String is ok too, can easily convert; otherwise, no can do:
+            throw ctxt.mappingException(_valueClass, p.getCurrentToken());
         }
     }
     
@@ -563,16 +573,15 @@ public class NumberDeserializers
         public BigDecimalDeserializer() { super(BigDecimal.class); }
 
         @Override
-        public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt)
+        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt)
             throws IOException
         {
-            JsonToken t = jp.getCurrentToken();
-            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {
-                return jp.getDecimalValue();
-            }
-            // String is ok too, can easily convert
-            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-                String text = jp.getText().trim();
+            switch (p.getCurrentTokenId()) {
+            case JsonTokenId.ID_NUMBER_INT:
+            case JsonTokenId.ID_NUMBER_FLOAT:
+                return p.getDecimalValue();
+            case JsonTokenId.ID_STRING:
+                String text = p.getText().trim();
                 if (text.length() == 0) {
                     return null;
                 }
@@ -581,20 +590,21 @@ public class NumberDeserializers
                 } catch (IllegalArgumentException iae) {
                     throw ctxt.weirdStringException(text, _valueClass, "not a valid representation");
                 }
-            }
-            
-            if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-                jp.nextToken();
-                final BigDecimal value = deserialize(jp, ctxt);
-                if (jp.nextToken() != JsonToken.END_ARRAY) {
-                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY,
-                        "Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array"
-                    );
+            case JsonTokenId.ID_START_ARRAY:
+                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                    p.nextToken();
+                    final BigDecimal value = deserialize(p, ctxt);
+                    if (p.nextToken() != JsonToken.END_ARRAY) {
+                        throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,
+                            "Attempted to unwrap single value array for single 'BigDecimal' value but there was more than a single value in the array"
+                        );
+                    }
+                    return value;
                 }
-                return value;
+                break;
             }
             // Otherwise, no can do:
-            throw ctxt.mappingException(_valueClass, t);
+            throw ctxt.mappingException(_valueClass, p.getCurrentToken());
         }
     }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
index 10aebe5c8..fceac9fbc 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
@@ -229,15 +229,15 @@ public abstract class StdDeserializer<T>
         return Boolean.TRUE;
     }
 
-    protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt)
+    protected Byte _parseByte(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
-            return jp.getByteValue();
+        JsonToken t = p.getCurrentToken();
+        if (t == JsonToken.VALUE_NUMBER_INT) {
+            return p.getByteValue();
         }
         if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-            String text = jp.getText().trim();
+            String text = p.getText().trim();
             if (_hasTextualNull(text)) {
                 return (Byte) getNullValue();
             }
@@ -258,16 +258,22 @@ public abstract class StdDeserializer<T>
             }
             return Byte.valueOf((byte) value);
         }
+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "Byte");
+            }
+            return p.getByteValue();
+        }
         if (t == JsonToken.VALUE_NULL) {
             return (Byte) getNullValue();
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Byte parsed = _parseByte(jp, ctxt);
-            t = jp.nextToken();
+            p.nextToken();
+            final Byte parsed = _parseByte(p, ctxt);
+            t = p.nextToken();
             if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                         "Attempted to unwrap single value array for single 'Byte' value but there was more than a single value in the array");
             }            
             return parsed;            
@@ -275,15 +281,15 @@ public abstract class StdDeserializer<T>
         throw ctxt.mappingException(_valueClass, t);
     }
     
-    protected Short _parseShort(JsonParser jp, DeserializationContext ctxt)
+    protected Short _parseShort(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
-            return jp.getShortValue();
+        JsonToken t = p.getCurrentToken();
+        if (t == JsonToken.VALUE_NUMBER_INT) {
+            return p.getShortValue();
         }
         if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-            String text = jp.getText().trim();
+            String text = p.getText().trim();
             int value;
             try {
                 int len = text.length();
@@ -303,16 +309,22 @@ public abstract class StdDeserializer<T>
             }
             return Short.valueOf((short) value);
         }
+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "Short");
+            }
+            return p.getShortValue();
+        }
         if (t == JsonToken.VALUE_NULL) {
             return (Short) getNullValue();
         }
         // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Short parsed = _parseShort(jp, ctxt);
-            t = jp.nextToken();
+            p.nextToken();
+            final Short parsed = _parseShort(p, ctxt);
+            t = p.nextToken();
             if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                         "Attempted to unwrap single value array for single 'Short' value but there was more than a single value in the array");
             }            
             return parsed;            
@@ -332,17 +344,15 @@ public abstract class StdDeserializer<T>
         return (short) value;
     }
     
-    protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt)
+    protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-
-        // Int works as is, coercing fine as well
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
-            return jp.getIntValue();
+        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
+            return p.getIntValue();
         }
+        JsonToken t = p.getCurrentToken();
         if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-            String text = jp.getText().trim();
+            String text = p.getText().trim();
             if (_hasTextualNull(text)) {
                 return 0;
             }
@@ -364,16 +374,21 @@ public abstract class StdDeserializer<T>
                 throw ctxt.weirdStringException(text, _valueClass, "not a valid int value");
             }
         }
+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "int");
+            }
+            return p.getValueAsInt();
+        }
         if (t == JsonToken.VALUE_NULL) {
             return 0;
         }
-        // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final int parsed = _parseIntPrimitive(jp, ctxt);
-            t = jp.nextToken();
+            p.nextToken();
+            final int parsed = _parseIntPrimitive(p, ctxt);
+            t = p.nextToken();
             if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                         "Attempted to unwrap single value array for single 'int' value but there was more than a single value in the array");
             }            
             return parsed;            
@@ -382,15 +397,20 @@ public abstract class StdDeserializer<T>
         throw ctxt.mappingException(_valueClass, t);
     }
 
-    protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt)
+    protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
-            return Integer.valueOf(jp.getIntValue());
-        }
-        if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse
-            String text = jp.getText().trim();
+        switch (p.getCurrentTokenId()) {
+        // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
+        case JsonTokenId.ID_NUMBER_INT:
+            return Integer.valueOf(p.getIntValue());
+        case JsonTokenId.ID_NUMBER_FLOAT: // coercing may work too
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "Integer");
+            }
+            return Integer.valueOf(p.getValueAsInt());
+        case JsonTokenId.ID_STRING: // let's do implicit re-parse
+            String text = p.getText().trim();
             try {
                 int len = text.length();
                 if (_hasTextualNull(text)) {
@@ -411,37 +431,39 @@ public abstract class StdDeserializer<T>
             } catch (IllegalArgumentException iae) {
                 throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value");
             }
-        }
-        if (t == JsonToken.VALUE_NULL) {
+        case JsonTokenId.ID_NULL:
             return (Integer) getNullValue();
-        }
-        // Issue#381
-        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Integer parsed = _parseInteger(jp, ctxt);
-            t = jp.nextToken();
-            if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
-                        "Attempted to unwrap single value array for single 'Integer' value but there was more than a single value in the array");
-            }            
-            return parsed;            
+        case JsonTokenId.ID_START_ARRAY:
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                p.nextToken();
+                final Integer parsed = _parseInteger(p, ctxt);
+                if (p.nextToken() != JsonToken.END_ARRAY) {
+                    throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
+                            "Attempted to unwrap single value array for single 'Integer' value but there was more than a single value in the array");
+                }            
+                return parsed;            
+            }
+            break;
         }
         // Otherwise, no can do:
-        throw ctxt.mappingException(_valueClass, t);
+        throw ctxt.mappingException(_valueClass, p.getCurrentToken());
     }
 
-    protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException
+    protected final Long _parseLong(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-    
-        // it should be ok to coerce (although may fail, too)
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {
-            return jp.getLongValue();
-        }
-        // let's allow Strings to be converted too
-        if (t == JsonToken.VALUE_STRING) {
+        switch (p.getCurrentTokenId()) {
+        // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
+        case JsonTokenId.ID_NUMBER_INT:
+            return p.getLongValue();
+        case JsonTokenId.ID_NUMBER_FLOAT:
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "Long");
+            }
+            return p.getValueAsLong();
+        case JsonTokenId.ID_STRING:
+            // let's allow Strings to be converted too
             // !!! 05-Jan-2009, tatu: Should we try to limit value space, JDK is too lenient?
-            String text = jp.getText().trim();
+            String text = p.getText().trim();
             if (text.length() == 0) {
                 return (Long) getEmptyValue();
             }
@@ -452,34 +474,38 @@ public abstract class StdDeserializer<T>
                 return Long.valueOf(NumberInput.parseLong(text));
             } catch (IllegalArgumentException iae) { }
             throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value");
-        }
-        if (t == JsonToken.VALUE_NULL) {
+        case JsonTokenId.ID_NULL:
             return (Long) getNullValue();
-        }
-        // Issue#381
-        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final Long parsed = _parseLong(jp, ctxt);
-            t = jp.nextToken();
-            if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
-                        "Attempted to unwrap single value array for single 'Long' value but there was more than a single value in the array");
-            }            
-            return parsed;            
+        case JsonTokenId.ID_START_ARRAY:
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+                p.nextToken();
+                final Long parsed = _parseLong(p, ctxt);
+                JsonToken t = p.nextToken();
+                if (t != JsonToken.END_ARRAY) {
+                    throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
+                            "Attempted to unwrap single value array for single 'Long' value but there was more than a single value in the array");
+                }            
+                return parsed;            
+            }
+            break;
         }
         // Otherwise, no can do:
-        throw ctxt.mappingException(_valueClass, t);
+        throw ctxt.mappingException(_valueClass, p.getCurrentToken());
     }
 
-    protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt)
+    protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt)
         throws IOException
     {
-        JsonToken t = jp.getCurrentToken();
-        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {
-            return jp.getLongValue();
-        }
-        if (t == JsonToken.VALUE_STRING) {
-            String text = jp.getText().trim();
+        switch (p.getCurrentTokenId()) {
+        case JsonTokenId.ID_NUMBER_INT:
+            return p.getLongValue();
+        case JsonTokenId.ID_NUMBER_FLOAT:
+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
+                _failDoubleToIntCoercion(p, ctxt, "long");
+            }
+            return p.getValueAsLong();
+        case JsonTokenId.ID_STRING:
+            String text = p.getText().trim();
             if (text.length() == 0 || _hasTextualNull(text)) {
                 return 0L;
             }
@@ -487,22 +513,22 @@ public abstract class StdDeserializer<T>
                 return NumberInput.parseLong(text);
             } catch (IllegalArgumentException iae) { }
             throw ctxt.weirdStringException(text, _valueClass, "not a valid long value");
-        }
-        if (t == JsonToken.VALUE_NULL) {
+        case JsonTokenId.ID_NULL:
             return 0L;
-        }
-        // Issue#381
-        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
-            jp.nextToken();
-            final long parsed = _parseLongPrimitive(jp, ctxt);
-            t = jp.nextToken();
+        case JsonTokenId.ID_START_ARRAY:
+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
+            p.nextToken();
+            final long parsed = _parseLongPrimitive(p, ctxt);
+            JsonToken t = p.nextToken();
             if (t != JsonToken.END_ARRAY) {
-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
                         "Attempted to unwrap single value array for single 'long' value but there was more than a single value in the array");
             }            
-            return parsed;            
+            return parsed;
+            }
+            break;
         }
-        throw ctxt.mappingException(_valueClass, t);
+        throw ctxt.mappingException(_valueClass, p.getCurrentToken());
     }
     
     protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt)
@@ -567,7 +593,7 @@ public abstract class StdDeserializer<T>
         throws IOException
     {
         JsonToken t = jp.getCurrentToken();
-        
+
         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too
             return jp.getFloatValue();
         }
@@ -655,7 +681,6 @@ public abstract class StdDeserializer<T>
         if (t == JsonToken.VALUE_NULL) {
             return (Double) getNullValue();
         }
-        // Issue#381
         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
             jp.nextToken();
             final Double parsed = _parseDouble(jp, ctxt);
@@ -962,4 +987,12 @@ public abstract class StdDeserializer<T>
          */
         jp.skipChildren();
     }
+
+    protected void _failDoubleToIntCoercion(JsonParser jp, DeserializationContext ctxt,
+            String type) throws IOException
+    {
+        throw ctxt.mappingException(String.format
+                ("Can not coerce a floating-point value ('%s') into %s; enable `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to allow",
+                        jp.getValueAsString(), type));
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
index b7fc64a5c..9e9f59837 100644
--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
@@ -39,6 +39,13 @@ public abstract class BaseMapTest
         public IntWrapper() { }
         public IntWrapper(int value) { i = value; }
     }
+
+    protected static class LongWrapper {
+        public long l;
+
+        public LongWrapper() { }
+        public LongWrapper(long value) { l = value; }
+    }
     
     /**
      * Simple wrapper around String type, usually to test value
diff --git a/src/test/java/com/fasterxml/jackson/databind/convert/NumericConversionTest.java b/src/test/java/com/fasterxml/jackson/databind/convert/NumericConversionTest.java
new file mode 100644
index 000000000..8055146d9
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/convert/NumericConversionTest.java
@@ -0,0 +1,69 @@
+package com.fasterxml.jackson.databind.convert;
+
+import com.fasterxml.jackson.databind.*;
+
+public class NumericConversionTest extends BaseMapTest
+{
+    private final ObjectMapper MAPPER = objectMapper();
+    private final ObjectReader R = MAPPER.reader().without(DeserializationFeature.ACCEPT_FLOAT_AS_INT);
+
+    public void testDoubleToInt() throws Exception
+    {
+        // by default, should be ok
+        Integer I = MAPPER.readValue(" 1.25 ", Integer.class);
+        assertEquals(1, I.intValue());
+        IntWrapper w = MAPPER.readValue("{\"i\":-2.25 }", IntWrapper.class);
+        assertEquals(-2, w.i);
+
+        try {
+            R.forType(Integer.class).readValue("1.5");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+
+        try {
+            R.forType(Integer.TYPE).readValue("1.5");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+        
+        try {
+            R.forType(IntWrapper.class).readValue("{\"i\":-2.25 }");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+    }
+
+    public void testDoubleToLong() throws Exception
+    {
+        // by default, should be ok
+        Long L = MAPPER.readValue(" 3.33 ", Long.class);
+        assertEquals(3L, L.longValue());
+        LongWrapper w = MAPPER.readValue("{\"l\":-2.25 }", LongWrapper.class);
+        assertEquals(-2L, w.l);
+
+        try {
+            R.forType(Long.class).readValue("1.5");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+
+        try {
+            R.forType(Long.TYPE).readValue("1.5");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+        
+        try {
+            R.forType(LongWrapper.class).readValue("{\"l\": 7.7 }");
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Can not coerce a floating-point");
+        }
+    }
+}
