diff --git a/release-notes/VERSION b/release-notes/VERSION
index e25c7d2f4..d4f29a41f 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -6,6 +6,7 @@ Project: jackson-databind
 
 2.8.1 (not yet released)
 
+#1256: `Optional.empty()` not excluded if property declared with type `Object`
 #1288: Type id not exposed for `JsonTypeInfo.As.EXTERNAL_PROPERTY` even when `visible` set to `true`
  (reported by libetl@github)
 #1289: Optimize construction of `ArrayList`, `LinkedHashMap` instances
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
index 25d45f3b8..248633207 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
@@ -103,6 +103,9 @@ public class PropertyBuilder
             inclusion = JsonInclude.Include.ALWAYS;
         }
 
+        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement
+        JavaType actualType = (serializationType == null) ? declaredType : serializationType;
+        
         switch (inclusion) {
         case NON_DEFAULT:
             // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
@@ -110,11 +113,10 @@ public class PropertyBuilder
             //    whereas for global defaults OR per-property overrides, we have more
             //    static definition. Sigh.
             // First: case of class specifying it; try to find POJO property defaults
-            JavaType t = (serializationType == null) ? declaredType : serializationType;
             if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {
-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, t);
+                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);
             } else {
-                valueToSuppress = getDefaultValue(t);
+                valueToSuppress = getDefaultValue(actualType);
             }
             if (valueToSuppress == null) {
                 suppressNulls = true;
@@ -129,7 +131,7 @@ public class PropertyBuilder
             // always suppress nulls
             suppressNulls = true;
             // and for referential types, also "empty", which in their case means "absent"
-            if (declaredType.isReferenceType()) {
+            if (actualType.isReferenceType()) {
                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
             }
             break;
@@ -145,7 +147,7 @@ public class PropertyBuilder
         case ALWAYS: // default
         default:
             // we may still want to suppress empty collections, as per [JACKSON-254]:
-            if (declaredType.isContainerType()
+            if (actualType.isContainerType()
                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
             }
diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
index 9438ec2f6..e5153beca 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
@@ -401,8 +401,7 @@ public final class TypeFactory
             }
             
             // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
-            // !!! TODO (as of 28-Jan-2016, at least)
-            
+
             // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
             //    a way to fully resolve and merge hierarchies; but that gets expensive
             //    so let's, for now, try to create close-enough approximation that
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java b/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java
index dd253c38c..871a929b2 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java
@@ -7,6 +7,7 @@ import java.util.concurrent.atomic.*;
 import com.fasterxml.jackson.annotation.*;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 
 public class TestJDKAtomicTypes
     extends com.fasterxml.jackson.databind.BaseMapTest
@@ -86,6 +87,13 @@ public class TestJDKAtomicTypes
         public LCStringWrapper() { }
     }
 
+    @JsonPropertyOrder({ "a", "b" })
+    static class Issue1256Bean {
+        @JsonSerialize(as=AtomicReference.class)
+        public Object a = new AtomicReference<Object>();
+        public AtomicReference<Object> b = new AtomicReference<Object>();
+    }
+
     /*
     /**********************************************************
     /* Test methods
@@ -250,4 +258,13 @@ public class TestJDKAtomicTypes
                 LCStringWrapper.class);
         assertEquals("foobar", w.value.get());
     }
+
+    public void testEmpty1256() throws Exception
+    {
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);
+
+        String json = mapper.writeValueAsString(new Issue1256Bean());
+        assertEquals("{}", json);
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java
index 1bc2d3e03..d756d4045 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java
@@ -1,21 +1,15 @@
 package com.fasterxml.jackson.databind.jsontype.ext;
 
-import java.io.IOException;
 import java.util.UUID;
 
-import org.junit.Test;
-
 import com.fasterxml.jackson.annotation.JsonPropertyOrder;
 import com.fasterxml.jackson.annotation.JsonTypeInfo;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
 
-import com.fasterxml.jackson.core.JsonParseException;
-
 import com.fasterxml.jackson.databind.*;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
 import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
-import com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest1288.ClassesWithBuilder.PaymentMean;
 import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;
 
 @SuppressWarnings("hiding")
@@ -510,12 +504,10 @@ public class ExternalTypeIdTest1288 extends BaseMapTest
                 + "\"csc\":666,\"address\":\"10 boulevard de Sebastopol\",\"zip_code\":\"75001\",\"city\":\"Paris\",\"province\":\"Ile-de-France\",\"country_code\":\"FR\",\"description\":\"John Doe personal credit card\"}}";
         final String asJson2 = "{\"form_of_payment\":\"INSTRUMENTED_CREDIT_CARD\",\"payment_details\":{\"payment_instrument_id\":\"00000000-0000-0000-0000-000000000000\", \"name\":\"Mr John Doe encrypted credit card\"}}";
         final ObjectMapper objectMapper = new ObjectMapper ().setPropertyNamingStrategy (PropertyNamingStrategy.SNAKE_CASE);
-//                .disable (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
 
         ClassesWithoutBuilder.PaymentMean ob1 = objectMapper.readValue (asJson1, ClassesWithoutBuilder.PaymentMean.class);
         assertNotNull(ob1);
         ClassesWithBuilder.PaymentMean ob2 = objectMapper.readValue (asJson2, ClassesWithBuilder.PaymentMean.class);
         assertNotNull(ob2);
-
     }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
index 858b91cf1..91be3f7a7 100644
--- a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java
@@ -185,4 +185,16 @@ public class TestJavaType
         assertFalse(rt.isAnchorType());
         assertEquals(AtomicReference.class, rt.getAnchorType().getRawClass());
     }
+
+    // for [databind#1290]
+    public void testObjectToReferenceSpecialization() throws Exception
+    {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        JavaType base = tf.constructType(Object.class);
+        assertTrue(base.isJavaLangObject());
+
+        JavaType sub = tf.constructSpecializedType(base, AtomicReference.class);
+        assertEquals(AtomicReference.class, sub.getRawClass());
+        assertTrue(sub.isReferenceType());
+    }
 }
