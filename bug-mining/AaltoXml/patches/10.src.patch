diff --git a/pom.xml b/pom.xml
index 4b1c50d..4fa804e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -98,6 +98,7 @@ org.xml.sax, org.xml.sax.ext, org.xml.sax.helpers</osgi.import>
         <configuration>
           <includes>
             <include>**/Test*.java</include>
+            <include>**/*Test.java</include>
           </includes>
           <excludes>
             <exclude>**/Base*</exclude>
diff --git a/release-notes/VERSION b/release-notes/VERSION
index f9c9420..a8feb01 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -15,6 +15,7 @@ Project: aalto-xml
 #46: 3-byte Unicode character causes an extra character to be appended by
   `XMLStreamWriter2.writeRaw()`
  (reported by philippe-tr@github)
+#52: Non-informative fail message for multiple root elements, in async parsing mode
 #53: AsyncByteScanner.validPublicIdChar() incorrectly rejects digits
  (reported by David M)
 - Add "Automatic-Module-Name" for Java 9
diff --git a/src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java b/src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java
index 508a4f0..a4a272b 100644
--- a/src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java
+++ b/src/main/java/com/fasterxml/aalto/async/AsyncByteArrayScanner.java
@@ -1063,8 +1063,8 @@ public class AsyncByteArrayScanner
                     _state = STATE_DEFAULT;
                     return handlePI();
                 }
-                if (b == BYTE_SLASH || !isProlog) {
-                    reportPrologUnexpChar(isProlog, decodeCharForError(b), " (unbalanced start/end tags?)");
+                if (!isProlog || (b == BYTE_SLASH)) {
+                    reportPrologUnexpElement(isProlog, b);
                 }
                 return handleStartElementStart(b);
             }
diff --git a/src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java b/src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java
index 8332322..e592819 100644
--- a/src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java
+++ b/src/main/java/com/fasterxml/aalto/async/AsyncByteBufferScanner.java
@@ -1072,7 +1072,7 @@ public class AsyncByteBufferScanner
                     return handlePI();
                 }
                 if (b == BYTE_SLASH || !isProlog) {
-                    reportPrologUnexpChar(isProlog, decodeCharForError(b), " (unbalanced start/end tags?)");
+                    reportPrologUnexpElement(isProlog, b);
                 }
                 return handleStartElementStart(b);
             }
diff --git a/src/main/java/com/fasterxml/aalto/in/ReaderScanner.java b/src/main/java/com/fasterxml/aalto/in/ReaderScanner.java
index a9e31cb..bcd5faa 100644
--- a/src/main/java/com/fasterxml/aalto/in/ReaderScanner.java
+++ b/src/main/java/com/fasterxml/aalto/in/ReaderScanner.java
@@ -231,7 +231,7 @@ public final class ReaderScanner
          * element (one root-level start tag)
          */
         if (c == '/' || !isProlog) {
-            reportPrologUnexpChar(isProlog, c, " (unbalanced start/end tags?)");
+            reportPrologUnexpElement(isProlog, c);
         }
         return handleStartElement(c);
     }
diff --git a/src/main/java/com/fasterxml/aalto/in/StreamScanner.java b/src/main/java/com/fasterxml/aalto/in/StreamScanner.java
index e72d6cd..7a13280 100644
--- a/src/main/java/com/fasterxml/aalto/in/StreamScanner.java
+++ b/src/main/java/com/fasterxml/aalto/in/StreamScanner.java
@@ -177,7 +177,7 @@ public abstract class StreamScanner
          * element (one root-level start tag)
          */
         if (b == BYTE_SLASH || !isProlog) {
-            reportPrologUnexpChar(isProlog, decodeCharForError(b), " (unbalanced start/end tags?)");
+            reportPrologUnexpElement(isProlog, b);
         }
         return handleStartElement(b);
     }
diff --git a/src/main/java/com/fasterxml/aalto/in/XmlScanner.java b/src/main/java/com/fasterxml/aalto/in/XmlScanner.java
index 55db174..85ed907 100644
--- a/src/main/java/com/fasterxml/aalto/in/XmlScanner.java
+++ b/src/main/java/com/fasterxml/aalto/in/XmlScanner.java
@@ -1344,6 +1344,27 @@ public abstract class XmlScanner
                            +(isNsDecl ? "namespace declaration" : "attribute value"));
     }
 
+    protected void reportPrologUnexpElement(boolean isProlog, int ch)
+        throws XMLStreamException
+    {
+        if (ch < 0) { // just to be safe, in case caller passed signed byte
+            ch &= 0x7FFFF;
+        }
+        if (ch == '/') { // end element
+            if (isProlog) {
+                reportInputProblem("Unexpected end element in prolog: malformed XML document, expected root element");
+            }
+            reportInputProblem("Unexpected end element in epilog: malformed XML document (unbalanced start/end tags?)");
+        }
+
+        // Otherwise, likely start element. But check for invalid white space for funsies
+        if (ch < 32) {
+            String type = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG;
+            throwUnexpectedChar(ch, "Unrecognized directive "+type);
+        }
+        reportInputProblem("Second root element in content: malformed XML document, only one allowed");
+    }
+    
     protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg)
         throws XMLStreamException
     {
diff --git a/src/test/java/async/AsyncTestBase.java b/src/test/java/async/AsyncTestBase.java
index 515c04b..69cfb2a 100644
--- a/src/test/java/async/AsyncTestBase.java
+++ b/src/test/java/async/AsyncTestBase.java
@@ -2,7 +2,9 @@ package async;
 
 import javax.xml.stream.XMLStreamException;
 
+import com.fasterxml.aalto.AsyncXMLInputFactory;
 import com.fasterxml.aalto.AsyncXMLStreamReader;
+import com.fasterxml.aalto.stax.InputFactoryImpl;
 
 abstract class AsyncTestBase extends base.BaseTestCase
 {
@@ -12,7 +14,13 @@ abstract class AsyncTestBase extends base.BaseTestCase
     protected final static char UNICODE_3BYTES = (char) 0x4567;
 
     protected final static String UNICODE_SEGMENT = "["+UNICODE_2BYTES+"/"+UNICODE_3BYTES+"]";
-    
+
+    protected AsyncXMLInputFactory newAsyncInputFactory()
+    {
+        // Can hard-code things here, being Aalto-specific tests.
+        return new InputFactoryImpl();
+    }
+
     public static String spaces(int count) 
     {
         return SPACES.substring(0, Math.min(SPACES.length(), count));
diff --git a/src/test/java/async/Issue40.java b/src/test/java/async/Issue40Test.java
similarity index 96%
rename from src/test/java/async/Issue40.java
rename to src/test/java/async/Issue40Test.java
index 7069cce..4488026 100644
--- a/src/test/java/async/Issue40.java
+++ b/src/test/java/async/Issue40Test.java
@@ -32,14 +32,14 @@ import com.fasterxml.aalto.stax.InputFactoryImpl;
  *                    | '&#x' [0-9a-fA-F]+ ';'  <-- here
  *  
  */
-public class Issue40 {
-	
+public class Issue40Test extends AsyncTestBase
+{
 	static AsyncXMLInputFactory FACTORY = new InputFactoryImpl();
 	static String HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><root att=\"";
 	static String FOOTER = "\"></root>";
 
-	@Test
-	public void testHexEntitiesInAttributes() throws XMLStreamException {
+	public void testHexEntitiesInAttributes() throws XMLStreamException
+	{
 		// non-regression of the fix 
 		testHexEntityInAttribute("&#x0A;", "\n" /*expected string value*/);
 		testHexEntityInAttribute("&#x0a;", "\n" /*expected string value*/);
@@ -59,7 +59,8 @@ public class Issue40 {
 	}
 
 	private void testHexEntityInAttribute(String entity, String expectedStringValue)
-			throws XMLStreamException {
+			throws XMLStreamException
+	{
 		AsyncXMLStreamReader<AsyncByteArrayFeeder> parser = FACTORY.createAsyncFor((HEADER + entity + FOOTER).getBytes(StandardCharsets.UTF_8));
 		assertEquals(AsyncXMLStreamReader.START_DOCUMENT, parser.next());
 		assertEquals(AsyncXMLStreamReader.START_ELEMENT, parser.next());
@@ -67,7 +68,5 @@ public class Issue40 {
 		assertEquals(expectedStringValue, parser.getAttributeValue(0));
 		assertEquals(AsyncXMLStreamReader.END_ELEMENT, parser.next());
 		assertEquals("root", parser.getName().getLocalPart());
-		
 	}
-	
 }
diff --git a/src/test/java/async/TestAsyncErrorHandling.java b/src/test/java/async/TestAsyncErrorHandling.java
new file mode 100644
index 0000000..fcccd04
--- /dev/null
+++ b/src/test/java/async/TestAsyncErrorHandling.java
@@ -0,0 +1,36 @@
+package async;
+
+import javax.xml.stream.XMLStreamException;
+
+import com.fasterxml.aalto.AsyncByteArrayFeeder;
+import com.fasterxml.aalto.AsyncXMLInputFactory;
+import com.fasterxml.aalto.AsyncXMLStreamReader;
+
+// for [aalto-xml#52]: improve error reporting for multiple roots
+public class TestAsyncErrorHandling extends AsyncTestBase
+{
+    public void testSimpleByteArray() throws Exception
+    {
+        final AsyncXMLInputFactory f = newAsyncInputFactory();
+
+        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr = f.createAsyncForByteArray();
+        final AsyncReaderWrapperForByteArray asyncR = new AsyncReaderWrapperForByteArray(sr,
+                1000, "<root>a</root><second>x>/second>");
+
+        int t = verifyStart(asyncR);
+        assertTokenType(START_ELEMENT, t);
+        assertEquals("root", sr.getLocalName());
+        assertEquals(0, sr.getAttributeCount());
+
+        assertTokenType(CHARACTERS, sr.next());
+        assertTokenType(END_ELEMENT, sr.next());
+
+        // and now expect problems
+        try {
+            sr.next();
+            fail("Should not pass");
+        } catch (XMLStreamException e) {
+            verifyException(e, "Second root element in content");
+        }
+    }
+}
diff --git a/src/test/java/async/TestAsyncViaEventReader.java b/src/test/java/async/TestAsyncViaEventReader.java
index 939ee33..42aa00e 100644
--- a/src/test/java/async/TestAsyncViaEventReader.java
+++ b/src/test/java/async/TestAsyncViaEventReader.java
@@ -14,111 +14,91 @@ import java.nio.ByteBuffer;
  */
 public class TestAsyncViaEventReader extends AsyncTestBase
 {
-    public void testSimple_byteArray() throws Exception
+    public void testSimpleByteArray() throws Exception
     {
-        final AsyncXMLInputFactory f = new InputFactoryImpl();
-        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr = null;
-        try {
-            sr = f.createAsyncFor("<root>a</r".getBytes("UTF-8"));
-            assertTokenType(START_DOCUMENT, sr.next());
-
-            XMLEventReader er = null;
-            try {
-                er = f.createXMLEventReader(sr);
-
-                XMLEvent evt = er.nextEvent();
-                assertTokenType(START_DOCUMENT, evt.getEventType());
-
-                evt = er.nextEvent();
-                assertTokenType(START_ELEMENT, evt.getEventType());
-                assertEquals("root", sr.getLocalName());
-
-                evt = er.nextEvent();
-                assertTokenType(CHARACTERS, evt.getEventType());
-                assertEquals("a", sr.getText());
-
-                // then need more input
-                evt = er.nextEvent();
-                assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
-
-                byte[] b = "oot>".getBytes("UTF-8");
-                sr.getInputFeeder().feedInput(b, 0, b.length);
-
-                evt = er.nextEvent();
-                assertTokenType(END_ELEMENT, evt.getEventType());
-                assertEquals("root", sr.getLocalName());
-
-                evt = er.nextEvent();
-                assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
-
-                sr.getInputFeeder().endOfInput();
-                evt = er.nextEvent();
-                assertTokenType(END_DOCUMENT, evt.getEventType());
-
-                assertFalse(er.hasNext());
-            } finally {
-                if(er != null) {
-                    er.close();
-                }
-            }
-        } finally {
-            if(sr != null) {
-                sr.close();
-            }
-        }
+        final AsyncXMLInputFactory f = newAsyncInputFactory();
+        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr
+            = f.createAsyncFor("<root>a</r".getBytes("UTF-8"));
+        assertTokenType(START_DOCUMENT, sr.next());
+
+        XMLEventReader er = f.createXMLEventReader(sr);
+
+        XMLEvent evt = er.nextEvent();
+        assertTokenType(START_DOCUMENT, evt.getEventType());
+
+        evt = er.nextEvent();
+        assertTokenType(START_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(CHARACTERS, evt.getEventType());
+        assertEquals("a", sr.getText());
+
+        // then need more input
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        byte[] b = "oot>".getBytes("UTF-8");
+        sr.getInputFeeder().feedInput(b, 0, b.length);
+
+        evt = er.nextEvent();
+        assertTokenType(END_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        sr.getInputFeeder().endOfInput();
+        evt = er.nextEvent();
+        assertTokenType(END_DOCUMENT, evt.getEventType());
+
+        assertFalse(er.hasNext());
+        er.close();
+        sr.close();
     }
 
-    public void testSimple_byteBuffer() throws Exception
+    public void testSimpleByteBuffer() throws Exception
     {
         final AsyncXMLInputFactory f = new InputFactoryImpl();
-        AsyncXMLStreamReader<AsyncByteBufferFeeder> sr = null;
-        try {
-            sr = f.createAsyncFor(ByteBuffer.wrap("<root>a</r".getBytes("UTF-8")));
-            assertTokenType(START_DOCUMENT, sr.next());
-
-            XMLEventReader er = null;
-            try {
-                er = f.createXMLEventReader(sr);
-
-                XMLEvent evt = er.nextEvent();
-                assertTokenType(START_DOCUMENT, evt.getEventType());
-
-                evt = er.nextEvent();
-                assertTokenType(START_ELEMENT, evt.getEventType());
-                assertEquals("root", sr.getLocalName());
-
-                evt = er.nextEvent();
-                assertTokenType(CHARACTERS, evt.getEventType());
-                assertEquals("a", sr.getText());
-
-                // then need more input
-                evt = er.nextEvent();
-                assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
-
-                byte[] b = "oot>".getBytes("UTF-8");
-                sr.getInputFeeder().feedInput(ByteBuffer.wrap(b));
-
-                evt = er.nextEvent();
-                assertTokenType(END_ELEMENT, evt.getEventType());
-                assertEquals("root", sr.getLocalName());
-
-                evt = er.nextEvent();
-                assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
-
-                sr.getInputFeeder().endOfInput();
-                evt = er.nextEvent();
-                assertTokenType(END_DOCUMENT, evt.getEventType());
-
-                assertFalse(er.hasNext());
-            } finally {
-                if(er != null) {
-                    er.close();
-                }
-            }
-        } finally {
-            if(sr != null) {
-                sr.close();
-            }
-        }
+        AsyncXMLStreamReader<AsyncByteBufferFeeder> sr
+            = f.createAsyncFor(ByteBuffer.wrap("<root>a</r".getBytes("UTF-8")));
+
+        assertTokenType(START_DOCUMENT, sr.next());
+
+        XMLEventReader er = f.createXMLEventReader(sr);
+
+        XMLEvent evt = er.nextEvent();
+        assertTokenType(START_DOCUMENT, evt.getEventType());
+
+        evt = er.nextEvent();
+        assertTokenType(START_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(CHARACTERS, evt.getEventType());
+        assertEquals("a", sr.getText());
+
+        // then need more input
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        byte[] b = "oot>".getBytes("UTF-8");
+        sr.getInputFeeder().feedInput(ByteBuffer.wrap(b));
+
+        evt = er.nextEvent();
+        assertTokenType(END_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        sr.getInputFeeder().endOfInput();
+        evt = er.nextEvent();
+        assertTokenType(END_DOCUMENT, evt.getEventType());
+
+        assertFalse(er.hasNext());
+
+        er.close();
+        sr.close();
     }
 }
diff --git a/src/test/java/async/TestCDataParsing.java b/src/test/java/async/TestCDataParsing.java
index 590a501..1a5611c 100644
--- a/src/test/java/async/TestCDataParsing.java
+++ b/src/test/java/async/TestCDataParsing.java
@@ -51,28 +51,16 @@ public class TestCDataParsing extends AsyncTestBase
         final AsyncXMLInputFactory f = new InputFactoryImpl();
 
         //test for byte array
-        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr_array = null;
-        try {
-            sr_array = f.createAsyncForByteArray();
-            final AsyncReaderWrapperForByteArray reader_array = new AsyncReaderWrapperForByteArray(sr_array, chunkSize, SPC + XML);
-            _testCData(sr_array, reader_array);
-        } finally {
-            if(sr_array != null) {
-                sr_array.close();
-            }
-        }
+        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr_array = f.createAsyncForByteArray();
+        final AsyncReaderWrapperForByteArray reader_array = new AsyncReaderWrapperForByteArray(sr_array, chunkSize, SPC + XML);
+        _testCData(sr_array, reader_array);
+        sr_array.close();
 
         //test for byte buffer
-        AsyncXMLStreamReader<AsyncByteBufferFeeder> sr_buffer = null;
-        try {
-            sr_buffer = f.createAsyncForByteBuffer();
-            final AsyncReaderWrapperForByteBuffer reader_buffer = new AsyncReaderWrapperForByteBuffer(sr_buffer, chunkSize, SPC + XML);
-            _testCData(sr_buffer, reader_buffer);
-        } finally {
-            if(sr_buffer != null) {
-                sr_buffer.close();
-            }
-        }
+        AsyncXMLStreamReader<AsyncByteBufferFeeder> sr_buffer = f.createAsyncForByteBuffer();
+        final AsyncReaderWrapperForByteBuffer reader_buffer = new AsyncReaderWrapperForByteBuffer(sr_buffer, chunkSize, SPC + XML);
+        _testCData(sr_buffer, reader_buffer);
+        sr_buffer.close();
     }
 
     private void _testCData(final AsyncXMLStreamReader<?> sr, final AsyncReaderWrapper reader) throws Exception
