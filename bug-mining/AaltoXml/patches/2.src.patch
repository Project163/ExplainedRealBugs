diff --git a/pom.xml b/pom.xml
index 1c705c0..cfbc456 100644
--- a/pom.xml
+++ b/pom.xml
@@ -60,7 +60,7 @@ org.xml.sax, org.xml.sax.ext, org.xml.sax.helpers</osgi.import>
     <dependency>
       <groupId>org.codehaus.woodstox</groupId>
       <artifactId>stax2-api</artifactId>
-      <version>3.1.4</version>
+      <version>4.0.0</version>
     </dependency>
     <!--
      | Test dependencies
@@ -68,7 +68,7 @@ org.xml.sax, org.xml.sax.ext, org.xml.sax.helpers</osgi.import>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>4.8.2</version>
+      <version>4.11</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 857b745..d45efc2 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -6,10 +6,15 @@ Project: aalto-xml
 
 0.9.11 (not yet released)
 
+#10: Support for capturing EVENT_INCOMPLETE with XMLEventReader
+ (suggested by Henry S, bblfish@github)
 #23: Fix buffer-smashing bug in loadAndRetain()
  (reported by Steven T, stebulus@github)
 #26: `ByteXmlWriter` outputs extra characters on buffer boundaries
  (reported by Vasily K, elDracoRus@github)
+- Fix a bug with `AsyncXMLInputFactory.createAsyncFor(byte[])`; was not feeding
+  initial input.
+- Update to Stax2-api 4.0.0 (no major changes but has working generic signatures)
 
 0.9.10 (23-Feb-2015)
 
@@ -23,7 +28,7 @@ Project: aalto-xml
  (contributed by jakeri@github)
 #21: Remove JAXP/SAX auto-registration from META-INF, to avoid conflicts
  (suggested by Dave P)
-* Minor improvement to AsyncUtfScanner.handleNsValuePending to avoid problems
+* Minor improvement to `AsyncUtfScanner.handleNsValuePending()` to avoid problems
   with split (across chunk boundary) namespace declaration.
 
 
diff --git a/src/main/java/com/fasterxml/aalto/evt/EventAllocatorImpl.java b/src/main/java/com/fasterxml/aalto/evt/EventAllocatorImpl.java
index eec2dae..8c1dd96 100644
--- a/src/main/java/com/fasterxml/aalto/evt/EventAllocatorImpl.java
+++ b/src/main/java/com/fasterxml/aalto/evt/EventAllocatorImpl.java
@@ -15,10 +15,13 @@
 package com.fasterxml.aalto.evt;
 
 import javax.xml.stream.*;
+import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.XMLEventAllocator;
 
 import org.codehaus.stax2.ri.evt.Stax2EventAllocatorImpl;
 
+import com.fasterxml.aalto.AsyncXMLStreamReader;
+
 /**
  * Specialized event allocator implementation. Beyond additions needed
  * to support DTD entities, implements non-location-preserving optimization.
@@ -88,10 +91,18 @@ public final class EventAllocatorImpl
 
     /*
     /**********************************************************************
-    /* Overridable methods
+    /* Overriden methods
     /**********************************************************************
      */
 
+    public XMLEvent allocate(XMLStreamReader r) throws XMLStreamException
+    {
+        if (r.getEventType() == AsyncXMLStreamReader.EVENT_INCOMPLETE) {
+            return IncompleteEvent.instance();
+        }
+        return super.allocate(r);
+    }
+    
     /**
      * Method used to get the {@link Location} object to use for
      * an event to create. Base implementation just calls stream
diff --git a/src/main/java/com/fasterxml/aalto/evt/IncompleteEvent.java b/src/main/java/com/fasterxml/aalto/evt/IncompleteEvent.java
new file mode 100644
index 0000000..79e3f8b
--- /dev/null
+++ b/src/main/java/com/fasterxml/aalto/evt/IncompleteEvent.java
@@ -0,0 +1,51 @@
+package com.fasterxml.aalto.evt;
+
+import java.io.Writer;
+
+import javax.xml.stream.XMLStreamException;
+
+import org.codehaus.stax2.XMLStreamWriter2;
+import org.codehaus.stax2.ri.evt.BaseEventImpl;
+
+import com.fasterxml.aalto.AsyncXMLStreamReader;
+import com.fasterxml.aalto.impl.LocationImpl;
+
+/**
+ * Bogus {@link XmlEvent} returned when the next event is not yet available,
+ * in case of non-blocking (async) parsing.
+ */
+public class IncompleteEvent extends BaseEventImpl
+{
+    private final static IncompleteEvent INSTANCE = new IncompleteEvent();
+
+    protected IncompleteEvent() {
+        super(LocationImpl.getEmptyLocation());
+    }
+
+    public static IncompleteEvent instance() { return INSTANCE; }
+    
+    @Override
+    public int getEventType() {
+        return AsyncXMLStreamReader.EVENT_INCOMPLETE;
+    }
+
+    @Override
+    public void writeAsEncodedUnicode(Writer w) throws XMLStreamException {
+        ; // nothing to write
+    }
+
+    @Override
+    public void writeUsing(XMLStreamWriter2 w) throws XMLStreamException {
+        ; // nothing to write
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return (o == this);
+    }
+
+    @Override
+    public int hashCode() {
+        return 42;
+    }
+}
diff --git a/src/main/java/com/fasterxml/aalto/impl/LocationImpl.java b/src/main/java/com/fasterxml/aalto/impl/LocationImpl.java
index 8d39474..57b4f04 100644
--- a/src/main/java/com/fasterxml/aalto/impl/LocationImpl.java
+++ b/src/main/java/com/fasterxml/aalto/impl/LocationImpl.java
@@ -9,26 +9,26 @@ import org.codehaus.stax2.XMLStreamLocation2;
 public class LocationImpl
     implements XMLStreamLocation2
 {
-    private final static LocationImpl sEmptyLocation = new LocationImpl("", "", -1, -1, -1);
+    private final static LocationImpl EMPTY = new LocationImpl("", "", -1, -1, -1);
 
-    final protected String mPublicId, mSystemId;
+    final protected String _publicId, _systemId;
     
-    final protected int mCharOffset;
-    final protected int mCol, mRow;
+    final protected int _charOffset;
+    final protected int _col, _row;
 
-    transient protected  String mDesc = null;
+    transient protected  String _desc = null;
 
     public LocationImpl(String pubId, String sysId,
                         int charOffset, int row, int col)
     {
-        mPublicId = pubId;
-        mSystemId = sysId;
+        _publicId = pubId;
+        _systemId = sysId;
         /* Overflow? Can obviously only handle limited range of overflows,
          * but let's do that at least?
          */
-        mCharOffset = (charOffset < 0) ? Integer.MAX_VALUE : charOffset;
-        mCol = col;
-        mRow = row;
+        _charOffset = (charOffset < 0) ? Integer.MAX_VALUE : charOffset;
+        _col = col;
+        _row = row;
     }
 
     /**
@@ -45,23 +45,23 @@ public class LocationImpl
     }
 
     public static LocationImpl getEmptyLocation() {
-        return sEmptyLocation;
+        return EMPTY;
     }
 
     @Override
-    public int getCharacterOffset() { return mCharOffset; }
+    public int getCharacterOffset() { return _charOffset; }
 
     @Override
-    public int getColumnNumber() { return mCol; }
+    public int getColumnNumber() { return _col; }
 
     @Override
-    public int getLineNumber() { return mRow; }
+    public int getLineNumber() { return _row; }
     
     @Override
-    public String getPublicId() { return mPublicId; }
+    public String getPublicId() { return _publicId; }
 
     @Override
-    public String getSystemId() { return mSystemId; }
+    public String getSystemId() { return _systemId; }
 
     /*
     /**********************************************************************
@@ -84,12 +84,12 @@ public class LocationImpl
     @Override
     public String toString()
     {
-        if (mDesc == null) {
+        if (_desc == null) {
             StringBuffer sb = new StringBuffer(100);
             appendDesc(sb);
-            mDesc = sb.toString();
+            _desc = sb.toString();
         }
-        return mDesc;
+        return _desc;
     }
 
     /*
@@ -102,20 +102,20 @@ public class LocationImpl
     {
         String srcId;
 
-        if (mSystemId != null) {
+        if (_systemId != null) {
             sb.append("[row,col,system-id]: ");
-            srcId = mSystemId;
-        } else if (mPublicId != null) {
+            srcId = _systemId;
+        } else if (_publicId != null) {
             sb.append("[row,col,public-id]: ");
-            srcId = mPublicId;
+            srcId = _publicId;
         } else {
             sb.append("[row,col {unknown-source}]: ");
             srcId = null;
         }
         sb.append('[');
-        sb.append(mRow);
+        sb.append(_row);
         sb.append(',');
-        sb.append(mCol);
+        sb.append(_col);
 
         if (srcId != null) {
             sb.append(',');
diff --git a/src/main/java/com/fasterxml/aalto/in/ByteSourceBootstrapper.java b/src/main/java/com/fasterxml/aalto/in/ByteSourceBootstrapper.java
index 4cb275c..aa45c4d 100644
--- a/src/main/java/com/fasterxml/aalto/in/ByteSourceBootstrapper.java
+++ b/src/main/java/com/fasterxml/aalto/in/ByteSourceBootstrapper.java
@@ -122,8 +122,7 @@ public final class ByteSourceBootstrapper
             _config.freeSmallCBuffer(mKeyword);
         }
     }
-    
-    @SuppressWarnings("resource")
+
     public XmlScanner doBootstrap() throws IOException, XMLStreamException
     {
         String normEnc = null;
diff --git a/src/main/java/com/fasterxml/aalto/in/FixedNsContext.java b/src/main/java/com/fasterxml/aalto/in/FixedNsContext.java
index f468d06..6fee286 100644
--- a/src/main/java/com/fasterxml/aalto/in/FixedNsContext.java
+++ b/src/main/java/com/fasterxml/aalto/in/FixedNsContext.java
@@ -157,10 +157,10 @@ public final class FixedNsContext
             throw new IllegalArgumentException("Illegal to pass null/empty prefix as argument.");
         }
         if (nsURI.equals(XMLConstants.XML_NS_URI)) {
-            return new SingletonIterator(XMLConstants.XML_NS_PREFIX);
+            return SingletonIterator.create(XMLConstants.XML_NS_PREFIX);
         }
         if (nsURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)) {
-            return new SingletonIterator(XMLConstants.XMLNS_ATTRIBUTE);
+            return SingletonIterator.create(XMLConstants.XMLNS_ATTRIBUTE);
         }
 
         String[] ns = _declarationData;
@@ -195,7 +195,7 @@ public final class FixedNsContext
             return all.iterator();
         }
         if (first != null) {
-            return new SingletonIterator(first);
+            return SingletonIterator.create(first);
         }
         return EmptyIterator.getInstance();
     }
diff --git a/src/main/java/com/fasterxml/aalto/sax/SAXParserImpl.java b/src/main/java/com/fasterxml/aalto/sax/SAXParserImpl.java
index da72843..cfbed04 100644
--- a/src/main/java/com/fasterxml/aalto/sax/SAXParserImpl.java
+++ b/src/main/java/com/fasterxml/aalto/sax/SAXParserImpl.java
@@ -331,7 +331,6 @@ class SAXParserImpl
     /**********************************************************************
      */
 
-    @SuppressWarnings("resource")
     @Override
     public void parse(InputSource input) throws SAXException
     {
diff --git a/src/main/java/com/fasterxml/aalto/stax/InputFactoryImpl.java b/src/main/java/com/fasterxml/aalto/stax/InputFactoryImpl.java
index b9893e4..7b90a74 100644
--- a/src/main/java/com/fasterxml/aalto/stax/InputFactoryImpl.java
+++ b/src/main/java/com/fasterxml/aalto/stax/InputFactoryImpl.java
@@ -350,11 +350,9 @@ public final class InputFactoryImpl
     }
 
     @Override
-    public AsyncXMLStreamReader<AsyncByteArrayFeeder> createAsyncFor(byte[] input) {
-        ReaderConfig cfg = getNonSharedConfig(null, null, null, false, false);
-        cfg.setActualEncoding("UTF-8");
-        AsyncByteArrayScanner scanner = new AsyncByteArrayScanner(cfg);
-        return new AsyncStreamReaderImpl<AsyncByteArrayFeeder>(scanner);
+    public AsyncXMLStreamReader<AsyncByteArrayFeeder> createAsyncFor(byte[] input) throws XMLStreamException
+    {
+        return createAsyncFor(input, 0, input.length);
     }
 
     @Override
@@ -438,7 +436,6 @@ public final class InputFactoryImpl
         return StreamReaderImpl.construct(ByteSourceBootstrapper.construct(cfg, in));
     }
 
-    @SuppressWarnings("resource")
     protected XMLStreamReader2 constructSR(javax.xml.transform.Source src,
                                           boolean forEventReader)
         throws XMLStreamException
@@ -516,7 +513,6 @@ public final class InputFactoryImpl
         throw new XMLStreamException("Can not create Stax reader for the Source passed -- neither reader, input stream nor system id was accessible; can not use other types of sources (like embedded SAX streams)");
     }
 
-    @SuppressWarnings("resource")
     protected XMLStreamReader2 constructSR2(Stax2Source ss, boolean forEventReader)
         throws XMLStreamException
     {
@@ -556,7 +552,6 @@ public final class InputFactoryImpl
         throw new IllegalArgumentException("Can not create stream reader for given Stax2Source: neither InputStream nor Reader available");
     }
 
-    @SuppressWarnings("resource")
     protected XMLStreamReader2 constructSR(URL src, boolean forEventReader)
         throws XMLStreamException
     {
@@ -571,7 +566,6 @@ public final class InputFactoryImpl
         return StreamReaderImpl.construct(ByteSourceBootstrapper.construct(cfg, in));
     }
 
-    @SuppressWarnings("resource")
     protected XMLStreamReader2 constructSR(File f, boolean forEventReader)
         throws XMLStreamException
     {
diff --git a/src/main/java/com/fasterxml/aalto/stax/OutputFactoryImpl.java b/src/main/java/com/fasterxml/aalto/stax/OutputFactoryImpl.java
index 53c9bd5..d342a1f 100644
--- a/src/main/java/com/fasterxml/aalto/stax/OutputFactoryImpl.java
+++ b/src/main/java/com/fasterxml/aalto/stax/OutputFactoryImpl.java
@@ -195,7 +195,6 @@ public final class OutputFactoryImpl
      * @param autoCloseOutput Whether writer should automatically close the
      *   output stream or Writer, when close() is called on stream writer.
      */
-    @SuppressWarnings("resource")
     private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc,
                                       boolean forceAutoClose)
         throws XMLStreamException
@@ -287,7 +286,6 @@ public final class OutputFactoryImpl
         return new NonRepairingStreamWriter(cfg, xw, symbols);
     }
 
-    @SuppressWarnings("resource")
     private XMLStreamWriter2 createSW(Result res) throws XMLStreamException
     {
         OutputStream out = null;
diff --git a/src/main/java/test/TestStreamCopier.java b/src/main/java/test/TestStreamCopier.java
index f40b3e2..412be97 100644
--- a/src/main/java/test/TestStreamCopier.java
+++ b/src/main/java/test/TestStreamCopier.java
@@ -49,9 +49,7 @@ public class TestStreamCopier
         return (XMLOutputFactory2) f;
     }
 
-    @SuppressWarnings("resource")
-    protected void test(String input, OutputStream out)
-        throws Exception
+    protected void test(String input, OutputStream out) throws Exception
     {
         XMLInputFactory2 ifact = getFactory();
         XMLOutputFactory2 of = getOutputFactory();
diff --git a/src/test/java/async/TestAsyncViaEventReader.java b/src/test/java/async/TestAsyncViaEventReader.java
new file mode 100644
index 0000000..3be24d5
--- /dev/null
+++ b/src/test/java/async/TestAsyncViaEventReader.java
@@ -0,0 +1,58 @@
+package async;
+
+import javax.xml.stream.XMLEventReader;
+import javax.xml.stream.events.XMLEvent;
+
+import com.fasterxml.aalto.*;
+import com.fasterxml.aalto.stax.InputFactoryImpl;
+
+/**
+ * Set of tests to ensure that it is possible to use Stax {@link XMLEventReader} with
+ * async parser.
+ */
+public class TestAsyncViaEventReader extends AsyncTestBase
+{
+    public void testSimple() throws Exception
+    {
+        AsyncXMLInputFactory f = new InputFactoryImpl();
+        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr = f.createAsyncFor("<root>a</r".getBytes("UTF-8"));
+//        AsyncReaderWrapperForByteArray reader = new AsyncReaderWrapperForByteArray(sr, 3, "<root>abc</root>";
+
+        assertTokenType(START_DOCUMENT, sr.next());
+        
+        XMLEventReader er = f.createXMLEventReader(sr);
+
+        XMLEvent evt = er.nextEvent();
+        assertTokenType(START_DOCUMENT, evt.getEventType());
+
+        evt = er.nextEvent();
+        assertTokenType(START_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(CHARACTERS, evt.getEventType());
+        assertEquals("a", sr.getText());
+        
+        // then need more input
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        byte[] b = "oot>".getBytes("UTF-8");
+        sr.getInputFeeder().feedInput(b, 0, b.length);
+
+        evt = er.nextEvent();
+        assertTokenType(END_ELEMENT, evt.getEventType());
+        assertEquals("root", sr.getLocalName());
+
+        evt = er.nextEvent();
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, evt.getEventType());
+
+        sr.getInputFeeder().endOfInput();
+        evt = er.nextEvent();
+        assertTokenType(END_DOCUMENT, evt.getEventType());
+        
+        assertFalse(er.hasNext());
+        
+        sr.close();
+    }
+}
diff --git a/src/test/java/async/TestCDataParsing.java b/src/test/java/async/TestCDataParsing.java
index dbecc5a..e540b1d 100644
--- a/src/test/java/async/TestCDataParsing.java
+++ b/src/test/java/async/TestCDataParsing.java
@@ -36,7 +36,7 @@ public class TestCDataParsing extends AsyncTestBase
             _testCDataSkip(999, SPC);
         }
     }
-    
+
     /*
     /**********************************************************************
     /* Secondary test methods
@@ -44,7 +44,7 @@ public class TestCDataParsing extends AsyncTestBase
      */
 
     private final static String XML = "<root><![CDATA[cdata\r\n&] ]] stuff]]>...<![CDATA[this\r\r and Unicode: "+UNICODE_SEGMENT+"!]]></root>";
-    
+
     private void _testCData(int chunkSize, String SPC) throws Exception
     {
         AsyncXMLInputFactory f = new InputFactoryImpl();
diff --git a/src/test/java/async/TestElementParsing.java b/src/test/java/async/TestElementParsing.java
index 194fd89..dac5557 100644
--- a/src/test/java/async/TestElementParsing.java
+++ b/src/test/java/async/TestElementParsing.java
@@ -10,6 +10,27 @@ import com.fasterxml.aalto.util.IllegalCharHandler;
 
 public class TestElementParsing extends AsyncTestBase
 {
+    /**
+     * Trivial test to verify basic operation with a full buffer.
+     */
+    public void testTrivial() throws Exception
+    {
+        AsyncXMLInputFactory f = new InputFactoryImpl();
+        AsyncXMLStreamReader<AsyncByteArrayFeeder> sr = f.createAsyncFor("<root>a</root>".getBytes("UTF-8"));
+        assertTokenType(START_DOCUMENT, sr.next());
+        assertTokenType(START_ELEMENT, sr.next());
+        assertEquals("root", sr.getLocalName());
+        assertTokenType(CHARACTERS, sr.next());
+        assertEquals("a", sr.getText());
+        assertTokenType(END_ELEMENT, sr.next());
+        assertEquals("root", sr.getLocalName());
+        // no input to see (could still get a PI, comment etc), so
+        assertTokenType(AsyncXMLStreamReader.EVENT_INCOMPLETE, sr.next());
+        sr.getInputFeeder().endOfInput();
+        
+        assertTokenType(END_DOCUMENT, sr.next());
+    }
+    
     public void testRootElement() throws Exception
     {
         // let's try with different chunking, addition (or not) of space
