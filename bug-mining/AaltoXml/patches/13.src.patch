diff --git a/release-notes/VERSION b/release-notes/VERSION
index 0a2a36f..d5d7530 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -4,6 +4,10 @@ Project: aalto-xml
 = Releases
 ------------------------------------------------------------------------
 
+1.2.2 (not yet released)
+
+#69: `BufferRecycler` access not safe if readers/writers used from different threads
+
 1.2.1 (31-May-2019)
 
 #47: NPE when trying to parse document with DTD declaration
diff --git a/src/main/java/com/fasterxml/aalto/in/ReaderConfig.java b/src/main/java/com/fasterxml/aalto/in/ReaderConfig.java
index be8fc05..eddbc7f 100644
--- a/src/main/java/com/fasterxml/aalto/in/ReaderConfig.java
+++ b/src/main/java/com/fasterxml/aalto/in/ReaderConfig.java
@@ -561,7 +561,6 @@ public final class ReaderConfig
 
     public char[] allocSmallCBuffer(int minSize)
     {
-//System.err.println("DEBUG: cfg, allocCSmall: "+mCurrRecycler);
         if (_currRecycler != null) {
             char[] result = _currRecycler.getSmallCBuffer(minSize);
             if (result != null) {
@@ -574,7 +573,6 @@ public final class ReaderConfig
 
     public void freeSmallCBuffer(char[] buffer)
     {
-//System.err.println("DEBUG: cfg, freeCSmall: "+buffer);
         // Need to create (and assign) the buffer?
         if (_currRecycler == null) {
             _currRecycler = createRecycler();
@@ -584,7 +582,6 @@ public final class ReaderConfig
 
     public char[] allocMediumCBuffer(int minSize)
     {
-//System.err.println("DEBUG: cfg, allocCMed: "+mCurrRecycler);
         if (_currRecycler != null) {
             char[] result = _currRecycler.getMediumCBuffer(minSize);
             if (result != null) {
@@ -596,7 +593,6 @@ public final class ReaderConfig
 
     public void freeMediumCBuffer(char[] buffer)
     {
-//System.err.println("DEBUG: cfg, freeCMed: "+buffer);
         if (_currRecycler == null) {
             _currRecycler = createRecycler();
         }
@@ -605,7 +601,6 @@ public final class ReaderConfig
 
     public char[] allocFullCBuffer(int minSize)
     {
-//System.err.println("DEBUG: cfg, allocCFull: "+mCurrRecycler);
         if (_currRecycler != null) {
             char[] result = _currRecycler.getFullCBuffer(minSize);
             if (result != null) {
@@ -617,7 +612,6 @@ public final class ReaderConfig
 
     public void freeFullCBuffer(char[] buffer)
     {
-//System.err.println("DEBUG: cfg, freeCFull: "+buffer);
         // Need to create (and assign) the buffer?
         if (_currRecycler == null) {
             _currRecycler = createRecycler();
@@ -627,7 +621,6 @@ public final class ReaderConfig
 
     public byte[] allocFullBBuffer(int minSize)
     {
-//System.err.println("DEBUG: cfg, allocBFull: "+mCurrRecycler);
         if (_currRecycler != null) {
             byte[] result = _currRecycler.getFullBBuffer(minSize);
             if (result != null) {
@@ -639,7 +632,6 @@ public final class ReaderConfig
 
     public void freeFullBBuffer(byte[] buffer)
     {
-//System.err.println("DEBUG: cfg, freeBFull: "+buffer);
         // Need to create (and assign) the buffer?
         if (_currRecycler == null) {
             _currRecycler = createRecycler();
@@ -647,13 +639,10 @@ public final class ReaderConfig
         _currRecycler.returnFullBBuffer(buffer);
     }
 
-//static int Counter = 0;
-
     private BufferRecycler createRecycler()
     {
         BufferRecycler recycler = new BufferRecycler();
         // No way to reuse/reset SoftReference, have to create new always:
-//System.err.println("DEBUG: RefCount: "+(++Counter));
         _recyclerRef.set(new SoftReference<BufferRecycler>(recycler));
         return recycler;
     }
diff --git a/src/main/java/com/fasterxml/aalto/out/WriterConfig.java b/src/main/java/com/fasterxml/aalto/out/WriterConfig.java
index d60271c..2f9165e 100644
--- a/src/main/java/com/fasterxml/aalto/out/WriterConfig.java
+++ b/src/main/java/com/fasterxml/aalto/out/WriterConfig.java
@@ -391,27 +391,6 @@ public final class WriterConfig
     /**********************************************************************
      */
 
-    public char[] allocSmallCBuffer(int minSize)
-    {
-        if (_currRecycler != null) {
-            char[] result = _currRecycler.getSmallCBuffer(minSize);
-            if (result != null) {
-                return result;
-            }
-        }
-        // Nope; no recycler, or it has no suitable buffers, let's create:
-        return new char[minSize];
-    }
-
-    public void freeSmallCBuffer(char[] buffer)
-    {
-        // Need to create (and assign) the buffer?
-        if (_currRecycler == null) {
-            _currRecycler = createRecycler();
-        }
-        _currRecycler.returnSmallCBuffer(buffer);
-    }
-
     public char[] allocMediumCBuffer(int minSize)
     {
         if (_currRecycler != null) {
diff --git a/src/main/java/com/fasterxml/aalto/util/BufferRecycler.java b/src/main/java/com/fasterxml/aalto/util/BufferRecycler.java
index 9619e98..d44c85d 100644
--- a/src/main/java/com/fasterxml/aalto/util/BufferRecycler.java
+++ b/src/main/java/com/fasterxml/aalto/util/BufferRecycler.java
@@ -1,18 +1,3 @@
-/* Woodstox Lite ("wool") XML processor
- *
- * Copyright (c) 2006- Tatu Saloranta, tatu.saloranta@iki.fi
- *
- * Licensed under the License specified in the file LICENSE which is
- * included with the source code.
- * You may not use this file except in compliance with the License.
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 package com.fasterxml.aalto.util;
 
 /**
@@ -33,11 +18,11 @@ package com.fasterxml.aalto.util;
  */
 public final class BufferRecycler
 {
-    private char[] mSmallCBuffer = null; // temp buffers
-    private char[] mMediumCBuffer = null; // text collector
-    private char[] mFullCBuffer = null; // for actual parsing buffer
+    private volatile char[] mSmallCBuffer = null; // temp buffers
+    private volatile char[] mMediumCBuffer = null; // text collector
+    private volatile char[] mFullCBuffer = null; // for actual parsing buffer
 
-    private byte[] mFullBBuffer = null;
+    private volatile byte[] mFullBBuffer = null;
 
     public BufferRecycler() { }
 
@@ -45,79 +30,71 @@ public final class BufferRecycler
 
     // // Small buffers, for temporary parsing
 
-    public char[] getSmallCBuffer(int minSize)
+    public synchronized char[] getSmallCBuffer(int minSize)
     {
-        char[] result = null;
-        if (mSmallCBuffer != null && mSmallCBuffer.length >= minSize) {
-            result = mSmallCBuffer;
+        char[] result = mSmallCBuffer;
+        if (result != null && result.length >= minSize) {
             mSmallCBuffer = null;
+            return result;
         }
-//System.err.println("DEBUG: Alloc CSmall: "+result);
-        return result;
+        return null;
     }
 
-    public void returnSmallCBuffer(char[] buffer)
+    public synchronized void returnSmallCBuffer(char[] buffer)
     {
-//System.err.println("DEBUG: Return CSmall ("+buffer.length+"): "+buffer);
         mSmallCBuffer = buffer;
     }
 
     // // Medium buffers, for text output collection
 
-    public char[] getMediumCBuffer(int minSize)
+    public synchronized char[] getMediumCBuffer(int minSize)
     {
-        char[] result = null;
-        if (mMediumCBuffer != null && mMediumCBuffer.length >= minSize) {
-            result = mMediumCBuffer;
+        char[] result = mMediumCBuffer;
+        if (result != null && result.length >= minSize) {
             mMediumCBuffer = null;
+            return result;
         }
-//System.err.println("DEBUG: Alloc CMed: "+result);
-        return result;
+        return null;
     }
 
-    public void returnMediumCBuffer(char[] buffer)
+    public synchronized void returnMediumCBuffer(char[] buffer)
     {
         mMediumCBuffer = buffer;
-//System.err.println("DEBUG: Return CMed ("+buffer.length+"): "+buffer);
     }
 
     // // Full buffers, for parser buffering
 
-    public char[] getFullCBuffer(int minSize)
+    public synchronized char[] getFullCBuffer(int minSize)
     {
-        char[] result = null;
-        if (mFullCBuffer != null && mFullCBuffer.length >= minSize) {
-            result = mFullCBuffer;
+        char[] result = mFullCBuffer;
+        if (result != null && result.length >= minSize) {
             mFullCBuffer = null;
+            return result;
         }
-//System.err.println("DEBUG: Alloc CFull: "+result);
-        return result;
+        return null;
     }
 
-    public void returnFullCBuffer(char[] buffer)
+    public synchronized void returnFullCBuffer(char[] buffer)
     {
         mFullCBuffer = buffer;
-//System.err.println("DEBUG: Return CFull ("+buffer.length+"): "+buffer);
     }
 
     // // // Byte buffers:
 
     // // Full byte buffers, for byte->char conversion (Readers)
 
-    public byte[] getFullBBuffer(int minSize)
+    public synchronized byte[] getFullBBuffer(int minSize)
     {
-        byte[] result = null;
-        if (mFullBBuffer != null && mFullBBuffer.length >= minSize) {
-            result = mFullBBuffer;
+        byte[] result = mFullBBuffer;
+        if (result != null && result.length >= minSize) {
             mFullBBuffer = null;
+            return result;
         }
-//System.err.println("DEBUG: Alloc BFull: "+result);
-        return result;
+        return null;
     }
 
-    public void returnFullBBuffer(byte[] buffer)
+    public synchronized void returnFullBBuffer(byte[] buffer)
     {
         mFullBBuffer = buffer;
-//System.err.println("DEBUG: Return BFull ("+buffer.length+"): "+buffer);
     }
 }
