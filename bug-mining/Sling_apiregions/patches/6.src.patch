diff --git a/src/main/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandler.java b/src/main/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandler.java
index b9975d4..6b4c18b 100644
--- a/src/main/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandler.java
+++ b/src/main/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandler.java
@@ -18,7 +18,10 @@ package org.apache.sling.feature.extension.apiregions;
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
 import javax.json.JsonArray;
 
 import org.apache.sling.feature.ArtifactId;
@@ -78,18 +81,39 @@ public class APIRegionMergeHandler implements MergeHandler {
                 }
             }
 
-            // If there are any remaining regions in the src extension, process them now
-            for (final ApiRegion r : srcRegions.listRegions()) {
-                if (targetRegions.getRegionByName(r.getName()) == null) {
-                    LinkedHashSet<ArtifactId> origins = new LinkedHashSet<>(Arrays.asList(r.getFeatureOrigins()));
+            // Build up a region map to identify the insertion positions
+            Map<String, Integer> regionPos = new HashMap<>();
+            List<ApiRegion> tRegions = targetRegions.listRegions();
+            for (int i=0; i<tRegions.size(); i++) {
+                regionPos.put(tRegions.get(i).getName(), i);
+            }
+
+            // Process the source regions back to front, to not interfere with the positions in the map
+            // Merge them in to have an ordered list that is consistent with both what was already in
+            // the target and what is in the source.
+            List<ApiRegion> sRegions = srcRegions.listRegions();
+            int nextInsertPosition = tRegions.size();
+            String nextFound = getNextFound(sRegions.size() - 1, regionPos, sRegions);
+
+            for (int i=sRegions.size() - 1; i>=0; i--) {
+                ApiRegion cur = sRegions.get(i);
+                if (cur.getName().equals(nextFound)) {
+                    nextFound = getNextFound(i - 1, regionPos, sRegions);
+                    if (nextFound == null) {
+                        nextInsertPosition = 0;
+                    } else {
+                        nextInsertPosition = regionPos.get(nextFound) + 1;
+                    }
+                } else {
+                    LinkedHashSet<ArtifactId> origins = new LinkedHashSet<>(Arrays.asList(cur.getFeatureOrigins()));
                     if (origins.isEmpty())
                     {
                         origins.add(source.getId());
-                        r.setFeatureOrigins(origins.toArray(new ArtifactId[0]));
+                        cur.setFeatureOrigins(origins.toArray(new ArtifactId[0]));
                     }
-                    if (!targetRegions.add(r))
+                    if (!targetRegions.add(nextInsertPosition, cur))
                     {
-                        throw new IllegalStateException("Duplicate region " + r.getName());
+                        throw new IllegalStateException("Duplicate region " + cur.getName());
                     }
                 }
             }
@@ -100,4 +124,14 @@ public class APIRegionMergeHandler implements MergeHandler {
             throw new RuntimeException(e);
         }
     }
+
+    private String getNextFound(int startPos, Map<String, Integer> regionPos, List<ApiRegion> sourceRegions) {
+        for (int i=startPos; i>=0; i--) {
+            String name = sourceRegions.get(i).getName();
+            if (regionPos.get(name) != null) {
+                return name;
+            }
+        }
+        return null;
+    }
 }
diff --git a/src/main/java/org/apache/sling/feature/extension/apiregions/api/ApiRegions.java b/src/main/java/org/apache/sling/feature/extension/apiregions/api/ApiRegions.java
index e92908f..755ca3b 100644
--- a/src/main/java/org/apache/sling/feature/extension/apiregions/api/ApiRegions.java
+++ b/src/main/java/org/apache/sling/feature/extension/apiregions/api/ApiRegions.java
@@ -27,6 +27,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
+
 import javax.json.Json;
 import javax.json.JsonArray;
 import javax.json.JsonArrayBuilder;
@@ -98,6 +99,18 @@ public class ApiRegions {
      * @return {@code true} if the region could be added, {@code false} otherwise
      */
     public boolean add(final ApiRegion region) {
+        return add(this.regions.size(), region);
+    }
+
+    /**
+     * Add the region. The region is only added if there isn't already a region with
+     * the same name
+     *
+     * @param idx The position to add
+     * @param region The region to add
+     * @return {@code true} if the region could be added, {@code false} otherwise
+     */
+    public boolean add(final int idx, final ApiRegion region) {
         for (final ApiRegion c : this.regions) {
             if (c.getName().equals(region.getName())) {
                 return false;
@@ -115,10 +128,11 @@ public class ApiRegions {
                 }
             ).reduce((a,b) -> b).ifPresent(region::setParent);
 
-        this.regions.add(region);
+        this.regions.add(idx, region);
         return true;
     }
 
+
     /**
      * Get a named region
      *
diff --git a/src/test/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandlerTest.java b/src/test/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandlerTest.java
index 6a20185..f31b965 100644
--- a/src/test/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandlerTest.java
+++ b/src/test/java/org/apache/sling/feature/extension/apiregions/APIRegionMergeHandlerTest.java
@@ -16,16 +16,15 @@
  */
 package org.apache.sling.feature.extension.apiregions;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Comparator;
+import java.util.List;
 
 import javax.json.Json;
 import javax.json.JsonArray;
@@ -45,6 +44,10 @@ import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 public class APIRegionMergeHandlerTest {
     private Path tempDir;
 
@@ -192,4 +195,62 @@ public class APIRegionMergeHandlerTest {
         assertEquals("middle", result.getRegionNames().get(1));
         assertEquals("bottom", result.getRegionNames().get(2));
     }
+
+    @Test
+    public void testAPIRegioOrdering2() throws Exception {
+        testAPIRegionOrdering(
+                Arrays.asList("middle"),
+                Arrays.asList("top", "middle", "bottom"),
+                Arrays.asList("top", "middle", "bottom"));
+
+        testAPIRegionOrdering(
+                Arrays.asList("r2", "r6", "r7"),
+                Arrays.asList("r1", "r2", "r3", "r4", "r5", "r7", "r8"),
+                Arrays.asList("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"));
+
+        testAPIRegionOrdering(
+                Arrays.asList("r2", "r3", "r6"),
+                Arrays.asList("r1", "r2", "r3", "r4", "r5", "r6"),
+                Arrays.asList("r1", "r2", "r3", "r4", "r5", "r6"));
+    }
+
+    private void testAPIRegionOrdering(List<String> targetNames, List<String> sourceNames, List<String> resultNames) throws Exception {
+        APIRegionMergeHandler armh = new APIRegionMergeHandler();
+
+        Feature f1 = new Feature(ArtifactId.fromMvnId("x:t:1"));
+        Feature f2 = new Feature(ArtifactId.fromMvnId("y:s:2"));
+
+        final ApiRegions regionsF1 = new ApiRegions();
+        for (String s : targetNames) {
+            ApiRegion r = new ApiRegion(s);
+            regionsF1.add(r);
+        }
+
+        final Extension extF1 = new Extension(ExtensionType.JSON, ApiRegions.EXTENSION_NAME, ExtensionState.OPTIONAL);
+        extF1.setJSONStructure(regionsF1.toJSONArray());
+        f1.getExtensions().add(extF1);
+
+        final ApiRegions regionsF2 = new ApiRegions();
+        for (String s : sourceNames) {
+            ApiRegion r = new ApiRegion(s);
+            regionsF2.add(r);
+        }
+
+        final Extension extF2 = new Extension(ExtensionType.JSON, ApiRegions.EXTENSION_NAME, ExtensionState.OPTIONAL);
+        extF2.setJSONStructure(regionsF2.toJSONArray());
+        f2.getExtensions().add(extF2);
+
+
+        HandlerContext hc = Mockito.mock(HandlerContext.class);
+        armh.merge(hc, f1, f2, extF1, extF2);
+
+        // order must be top - middle - bottom
+        final ApiRegions result = ApiRegions.parse((JsonArray)extF1.getJSONStructure());
+
+        List<String> actualNames = new ArrayList<>();
+        for (String s : result.getRegionNames()) {
+            actualNames.add(s);
+        }
+        assertEquals(resultNames, actualNames);
+    }
 }
