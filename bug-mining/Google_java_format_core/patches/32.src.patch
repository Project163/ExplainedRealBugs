diff --git a/core/src/main/java/com/google/googlejavaformat/java/FormatFileCallable.java b/core/src/main/java/com/google/googlejavaformat/java/FormatFileCallable.java
index 9b7436b..89cb339 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/FormatFileCallable.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/FormatFileCallable.java
@@ -55,7 +55,7 @@ class FormatFileCallable implements Callable<String> {
       input = RemoveUnusedImports.removeUnusedImports(input);
     }
     if (parameters.sortImports()) {
-      input = ImportOrderer.reorderImports(input);
+      input = ImportOrderer.reorderImports(input, options.style());
     }
     return input;
   }
diff --git a/core/src/main/java/com/google/googlejavaformat/java/Formatter.java b/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
index 064e0bc..a6f9311 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
@@ -216,7 +216,7 @@ public final class Formatter {
    *     Google Java Style Guide - 3.3.3 Import ordering and spacing</a>
    */
   public String formatSourceAndFixImports(String input) throws FormatterException {
-    input = ImportOrderer.reorderImports(input);
+    input = ImportOrderer.reorderImports(input, options.style());
     input = RemoveUnusedImports.removeUnusedImports(input);
     String formatted = formatSource(input);
     formatted = StringWrapper.wrap(formatted);
diff --git a/core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java b/core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java
index 7387740..a364c15 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java
@@ -14,30 +14,94 @@
 package com.google.googlejavaformat.java;
 
 import static com.google.common.collect.Iterables.getLast;
+import static com.google.common.primitives.Booleans.trueFirst;
 
 import com.google.common.base.CharMatcher;
 import com.google.common.base.Preconditions;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.googlejavaformat.Newlines;
+import com.google.googlejavaformat.java.JavaFormatterOptions.Style;
 import com.google.googlejavaformat.java.JavaInput.Tok;
 import java.util.ArrayList;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
+import java.util.function.BiFunction;
+import java.util.stream.Stream;
 import org.openjdk.tools.javac.parser.Tokens.TokenKind;
 
 /** Orders imports in Java source code. */
 public class ImportOrderer {
+
+  private static final Splitter DOT_SPLITTER = Splitter.on('.');
+
   /**
    * Reorder the inputs in {@code text}, a complete Java program. On success, another complete Java
    * program is returned, which is the same as the original except the imports are in order.
    *
    * @throws FormatterException if the input could not be parsed.
    */
-  public static String reorderImports(String text) throws FormatterException {
+  public static String reorderImports(String text, Style style) throws FormatterException {
     ImmutableList<Tok> toks = JavaInput.buildToks(text, CLASS_START);
-    return new ImportOrderer(text, toks).reorderImports();
+    return new ImportOrderer(text, toks, style).reorderImports();
+  }
+
+  /**
+   * Reorder the inputs in {@code text}, a complete Java program, in Google style. On success,
+   * another complete Java program is returned, which is the same as the original except the imports
+   * are in order.
+   *
+   * @deprecated Use {@link #reorderImports(String, Style)} instead
+   * @throws FormatterException if the input could not be parsed.
+   */
+  @Deprecated
+  public static String reorderImports(String text) throws FormatterException {
+    return reorderImports(text, Style.GOOGLE);
+  }
+
+  private String reorderImports() throws FormatterException {
+    int firstImportStart;
+    Optional<Integer> maybeFirstImport = findIdentifier(0, IMPORT_OR_CLASS_START);
+    if (!maybeFirstImport.isPresent() || !tokenAt(maybeFirstImport.get()).equals("import")) {
+      // No imports, so nothing to do.
+      return text;
+    }
+    firstImportStart = maybeFirstImport.get();
+    int unindentedFirstImportStart = unindent(firstImportStart);
+
+    ImportsAndIndex imports = scanImports(firstImportStart);
+    int afterLastImport = imports.index;
+
+    // Make sure there are no more imports before the next class (etc) definition.
+    Optional<Integer> maybeLaterImport = findIdentifier(afterLastImport, IMPORT_OR_CLASS_START);
+    if (maybeLaterImport.isPresent() && tokenAt(maybeLaterImport.get()).equals("import")) {
+      throw new FormatterException("Imports not contiguous (perhaps a comment separates them?)");
+    }
+
+    StringBuilder result = new StringBuilder();
+    String prefix = tokString(0, unindentedFirstImportStart);
+    result.append(prefix);
+    if (!prefix.isEmpty() && Newlines.getLineEnding(prefix) == null) {
+      result.append(lineSeparator).append(lineSeparator);
+    }
+    result.append(reorderedImportsString(imports.imports));
+
+    List<String> tail = new ArrayList<>();
+    tail.add(CharMatcher.whitespace().trimLeadingFrom(tokString(afterLastImport, toks.size())));
+    if (!toks.isEmpty()) {
+      Tok lastTok = getLast(toks);
+      int tailStart = lastTok.getPosition() + lastTok.length();
+      tail.add(text.substring(tailStart));
+    }
+    if (tail.stream().anyMatch(s -> !s.isEmpty())) {
+      result.append(lineSeparator);
+      tail.forEach(result::append);
+    }
+
+    return result.toString();
   }
 
   /**
@@ -55,20 +119,113 @@ public class ImportOrderer {
   private static final ImmutableSet<String> IMPORT_OR_CLASS_START =
       ImmutableSet.of("import", "class", "interface", "enum");
 
+  /**
+   * A {@link Comparator} that orders {@link Import}s by Google Style, defined at
+   * https://google.github.io/styleguide/javaguide.html#s3.3.3-import-ordering-and-spacing.
+   */
+  private static final Comparator<Import> GOOGLE_IMPORT_COMPARATOR =
+      Comparator.comparing(Import::isStatic, trueFirst()).thenComparing(Import::imported);
+
+  /**
+   * A {@link Comparator} that orders {@link Import}s by AOSP Style, defined at
+   * https://source.android.com/setup/contribute/code-style#order-import-statements and implemented
+   * in IntelliJ at
+   * https://android.googlesource.com/platform/development/+/master/ide/intellij/codestyles/AndroidStyle.xml.
+   */
+  private static final Comparator<Import> AOSP_IMPORT_COMPARATOR =
+      Comparator.comparing(Import::isStatic, trueFirst())
+          .thenComparing(Import::isAndroid, trueFirst())
+          .thenComparing(Import::isThirdParty, trueFirst())
+          .thenComparing(Import::isJava, trueFirst())
+          .thenComparing(Import::imported);
+
+  /**
+   * Determines whether to insert a blank line between the {@code prev} and {@code curr} {@link
+   * Import}s based on Google style.
+   */
+  private static boolean shouldInsertBlankLineGoogle(Import prev, Import curr) {
+    return prev.isStatic() && !curr.isStatic();
+  }
+
+  /**
+   * Determines whether to insert a blank line between the {@code prev} and {@code curr} {@link
+   * Import}s based on AOSP style.
+   */
+  private static boolean shouldInsertBlankLineAosp(Import prev, Import curr) {
+    if (prev.isStatic() && !curr.isStatic()) {
+      return true;
+    }
+    // insert blank line between "com.android" from "com.anythingelse"
+    if (prev.isAndroid() && !curr.isAndroid()) {
+      return true;
+    }
+    return !prev.topLevel().equals(curr.topLevel());
+  }
+
   private final String text;
   private final ImmutableList<Tok> toks;
   private final String lineSeparator;
+  private final Comparator<Import> importComparator;
+  private final BiFunction<Import, Import, Boolean> shouldInsertBlankLineFn;
 
-  private ImportOrderer(String text, ImmutableList<Tok> toks) throws FormatterException {
+  private ImportOrderer(String text, ImmutableList<Tok> toks, Style style) {
     this.text = text;
     this.toks = toks;
     this.lineSeparator = Newlines.guessLineSeparator(text);
+    if (style.equals(Style.GOOGLE)) {
+      this.importComparator = GOOGLE_IMPORT_COMPARATOR;
+      this.shouldInsertBlankLineFn = ImportOrderer::shouldInsertBlankLineGoogle;
+    } else if (style.equals(Style.AOSP)) {
+      this.importComparator = AOSP_IMPORT_COMPARATOR;
+      this.shouldInsertBlankLineFn = ImportOrderer::shouldInsertBlankLineAosp;
+    } else {
+      throw new IllegalArgumentException("Unsupported code style: " + style);
+    }
   }
 
   /** An import statement. */
-  private class Import implements Comparable<Import> {
+  class Import {
+    private final String imported;
+    private final boolean isStatic;
+    private final String trailing;
+
+    Import(String imported, String trailing, boolean isStatic) {
+      this.imported = imported;
+      this.trailing = trailing;
+      this.isStatic = isStatic;
+    }
+
     /** The name being imported, for example {@code java.util.List}. */
-    final String imported;
+    String imported() {
+      return imported;
+    }
+
+    /** True if this is {@code import static}. */
+    boolean isStatic() {
+      return isStatic;
+    }
+
+    /** The top-level package of the import. */
+    String topLevel() {
+      return DOT_SPLITTER.split(imported()).iterator().next();
+    }
+
+    /** True if this is an Android import per AOSP style. */
+    boolean isAndroid() {
+      return Stream.of("android.", "androidx.", "dalvik.", "libcore.", "com.android.")
+          .anyMatch(imported::startsWith);
+    }
+
+    /** True if this is a Java import per AOSP style. */
+    boolean isJava() {
+      switch (topLevel()) {
+        case "java":
+        case "javax":
+          return true;
+        default:
+          return false;
+      }
+    }
 
     /**
      * The {@code //} comment lines after the final {@code ;}, up to and including the line
@@ -76,24 +233,13 @@ public class ImportOrderer {
      * disallowed by the style guide), the trailing whitespace of the first import does not include
      * a line terminator.
      */
-    final String trailing;
-
-    /** True if this is {@code import static}. */
-    final boolean isStatic;
-
-    Import(String imported, String trailing, boolean isStatic) {
-      this.imported = imported;
-      this.trailing = trailing;
-      this.isStatic = isStatic;
+    String trailing() {
+      return trailing;
     }
 
-    // This is how the sorting happens, including sorting static imports before non-static ones.
-    @Override
-    public int compareTo(Import that) {
-      if (this.isStatic != that.isStatic) {
-        return this.isStatic ? -1 : +1;
-      }
-      return this.imported.compareTo(that.imported);
+    /** True if this is a third-party import per AOSP style. */
+    public boolean isThirdParty() {
+      return !(isAndroid() || isJava());
     }
 
     // One or multiple lines, the import itself and following comments, including the line
@@ -102,61 +248,19 @@ public class ImportOrderer {
     public String toString() {
       StringBuilder sb = new StringBuilder();
       sb.append("import ");
-      if (isStatic) {
+      if (isStatic()) {
         sb.append("static ");
       }
-      sb.append(imported).append(';');
-      if (trailing.trim().isEmpty()) {
+      sb.append(imported()).append(';');
+      if (trailing().trim().isEmpty()) {
         sb.append(lineSeparator);
       } else {
-        sb.append(trailing);
+        sb.append(trailing());
       }
       return sb.toString();
     }
   }
 
-  private String reorderImports() throws FormatterException {
-    int firstImportStart;
-    Optional<Integer> maybeFirstImport = findIdentifier(0, IMPORT_OR_CLASS_START);
-    if (!maybeFirstImport.isPresent() || !tokenAt(maybeFirstImport.get()).equals("import")) {
-      // No imports, so nothing to do.
-      return text;
-    }
-    firstImportStart = maybeFirstImport.get();
-    int unindentedFirstImportStart = unindent(firstImportStart);
-
-    ImportsAndIndex imports = scanImports(firstImportStart);
-    int afterLastImport = imports.index;
-
-    // Make sure there are no more imports before the next class (etc) definition.
-    Optional<Integer> maybeLaterImport = findIdentifier(afterLastImport, IMPORT_OR_CLASS_START);
-    if (maybeLaterImport.isPresent() && tokenAt(maybeLaterImport.get()).equals("import")) {
-      throw new FormatterException("Imports not contiguous (perhaps a comment separates them?)");
-    }
-
-    StringBuilder result = new StringBuilder();
-    String prefix = tokString(0, unindentedFirstImportStart);
-    result.append(prefix);
-    if (!prefix.isEmpty() && Newlines.getLineEnding(prefix) == null) {
-      result.append(lineSeparator).append(lineSeparator);
-    }
-    result.append(reorderedImportsString(imports.imports));
-
-    List<String> tail = new ArrayList<>();
-    tail.add(CharMatcher.whitespace().trimLeadingFrom(tokString(afterLastImport, toks.size())));
-    if (!toks.isEmpty()) {
-      Tok lastTok = getLast(toks);
-      int tailStart = lastTok.getPosition() + lastTok.length();
-      tail.add(text.substring(tailStart));
-    }
-    if (tail.stream().anyMatch(s -> !s.isEmpty())) {
-      result.append(lineSeparator);
-      tail.forEach(result::append);
-    }
-
-    return result.toString();
-  }
-
   private String tokString(int start, int end) {
     StringBuilder sb = new StringBuilder();
     for (int i = start; i < end; i++) {
@@ -191,7 +295,7 @@ public class ImportOrderer {
    */
   private ImportsAndIndex scanImports(int i) throws FormatterException {
     int afterLastImport = i;
-    ImmutableSortedSet.Builder<Import> imports = ImmutableSortedSet.naturalOrder();
+    ImmutableSortedSet.Builder<Import> imports = ImmutableSortedSet.orderedBy(importComparator);
     // JavaInput.buildToks appends a zero-width EOF token after all tokens. It won't match any
     // of our tests here and protects us from running off the end of the toks list. Since it is
     // zero-width it doesn't matter if we include it in our string concatenation at the end.
@@ -258,20 +362,18 @@ public class ImportOrderer {
   private String reorderedImportsString(ImmutableSortedSet<Import> imports) {
     Preconditions.checkArgument(!imports.isEmpty(), "imports");
 
-    Import firstImport = imports.iterator().next();
-
-    // Pretend that the first import was preceded by another import of the same kind
-    // (static or non-static), so we don't insert a newline there.
-    boolean lastWasStatic = firstImport.isStatic;
+    // Pretend that the first import was preceded by another import of the same kind, so we don't
+    // insert a newline there.
+    Import prevImport = imports.iterator().next();
 
     StringBuilder sb = new StringBuilder();
-    for (Import thisImport : imports) {
-      if (lastWasStatic && !thisImport.isStatic) {
+    for (Import currImport : imports) {
+      if (shouldInsertBlankLineFn.apply(prevImport, currImport)) {
         // Blank line between static and non-static imports.
         sb.append(lineSeparator);
       }
-      lastWasStatic = thisImport.isStatic;
-      sb.append(thisImport);
+      sb.append(currImport);
+      prevImport = currImport;
     }
     return sb.toString();
   }
diff --git a/core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java b/core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java
index b5b9b46..950eca6 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java
@@ -30,7 +30,6 @@ import com.google.errorprone.annotations.Immutable;
 public class JavaFormatterOptions {
 
   public enum Style {
-
     /** The default Google Java Style configuration. */
     GOOGLE(1),
 
@@ -54,11 +53,16 @@ public class JavaFormatterOptions {
     this.style = style;
   }
 
-  /** Returns the multiplier for the unit of indent */
+  /** Returns the multiplier for the unit of indent. */
   public int indentationMultiplier() {
     return style.indentationMultiplier();
   }
 
+  /** Returns the code style. */
+  public Style style() {
+    return style;
+  }
+
   /** Returns the default formatting options. */
   public static JavaFormatterOptions defaultOptions() {
     return builder().build();
diff --git a/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java b/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
index 2d202e1..9527278 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
@@ -20,6 +20,7 @@ import static org.junit.Assert.fail;
 
 import com.google.common.base.Joiner;
 import com.google.common.io.CharStreams;
+import com.google.googlejavaformat.java.JavaFormatterOptions.Style;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -449,9 +450,9 @@ public final class FormatterTest {
 
     // Just fixing imports preserves whitespace around imports.
     assertThat(RemoveUnusedImports.removeUnusedImports(withBlank)).isEqualTo(withBlank);
-    assertThat(ImportOrderer.reorderImports(withBlank)).isEqualTo(withBlank);
+    assertThat(ImportOrderer.reorderImports(withBlank, Style.GOOGLE)).isEqualTo(withBlank);
     assertThat(RemoveUnusedImports.removeUnusedImports(withoutBlank)).isEqualTo(withoutBlank);
-    assertThat(ImportOrderer.reorderImports(withoutBlank)).isEqualTo(withoutBlank);
+    assertThat(ImportOrderer.reorderImports(withoutBlank, Style.GOOGLE)).isEqualTo(withoutBlank);
   }
 
   @Test
diff --git a/core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java b/core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java
index 6c92c89..5a6b1f9 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java
@@ -19,540 +19,825 @@ import static com.google.common.truth.Truth.assertWithMessage;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.googlejavaformat.java.JavaFormatterOptions.Style;
+import java.util.Arrays;
 import java.util.Collection;
 import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 /** Tests for {@link ImportOrderer}. */
-@RunWith(Parameterized.class)
+@RunWith(Enclosed.class)
 public class ImportOrdererTest {
 
-  @Parameters(name = "{index}: {0}")
-  public static Collection<Object[]> parameters() {
-    // A three-dimensional array! Each element of the outer array is a test case. It consists of
-    // two arrays of lines. The first array of lines is the test input, and the second one is the
-    // expected output. If the second array has a single element starting with !! then it is
-    // expected that ImportOrderer will throw a FormatterException with that message.
-    //
-    // If a line ends with \ then we remove the \ and don't append a \n. That allows us to check
-    // some parsing edge cases.
-    String[][][] inputsOutputs = {
-      {
-        // Empty input produces empty output.
-        {}, //
-        {}
-      },
-      {
-        {
-          "foo", "bar",
-        },
-        {
-          "foo", "bar",
-        },
-      },
-      {
-        {
-          "package foo;", //
-          "",
-          "import com.google.first.Bar;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;", //
-          "",
-          "import com.google.first.Bar;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        {
-          "package foo;",
-          "",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;",
-          "",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        {
-          "package foo;",
-          "",
-          "import com.google.second.Foo;",
-          "import com.google.first.Bar;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;",
-          "",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        {
-          "import java.util.Collection;",
-          "// BUG: diagnostic contains",
-          "import java.util.List;",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import java.util.Collection;",
-          "// BUG: diagnostic contains",
-          "import java.util.List;",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "import java.util.Set;",
-          "import java.util.Collection;",
-          "// BUG: diagnostic contains",
-          "import java.util.List;",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import java.util.Collection;",
-          "// BUG: diagnostic contains",
-          "import java.util.List;",
-          "import java.util.Set;",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "import java.util.List;",
-          "// BUG: diagnostic contains",
-          "import java.util.Set;",
-          "import java.util.Collection;",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import java.util.Collection;",
-          "import java.util.List;",
-          "// BUG: diagnostic contains",
-          "import java.util.Set;",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "// BEGIN-STRIP",
-          "import com.google.testing.testsize.MediumTest;",
-          "import com.google.testing.testsize.MediumTestAttribute;",
-          "// END-STRIP",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "// BEGIN-STRIP",
-          "import com.google.testing.testsize.MediumTest;",
-          "import com.google.testing.testsize.MediumTestAttribute;",
-          "// END-STRIP",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "import com.google.testing.testsize.MediumTest;          // Keep this import",
-          "import com.google.testing.testsize.MediumTestAttribute; // Keep this import",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import com.google.testing.testsize.MediumTest;          // Keep this import",
-          "import com.google.testing.testsize.MediumTestAttribute; // Keep this import",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "import java.util.Set;",
-          "import java.util.List;",
-          "",
-          "// This comment doesn't get moved because of the blank line.",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import java.util.List;",
-          "import java.util.Set;",
-          "",
-          "// This comment doesn't get moved because of the blank line.",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          "import b.B;",
-          "// MOE: end_strip",
-          "import c.C;",
-          "// MOE: begin_strip",
-          "import a.A;",
-          "",
-          "class B74235047 {}"
-        },
-        {
-          "import a.A;",
-          "import b.B;",
-          "// MOE: end_strip",
-          "import c.C;",
-          "// MOE: begin_strip",
-          "",
-          "class B74235047 {}"
-        }
-      },
-      {
-        {
-          // Check double semicolons
-          "package foo;",
-          "",
-          "import com.google.second.Foo;;",
-          "import com.google.first.Bar;;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;",
-          "",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        {
-          "package foo;",
-          "",
-          "import com.google.second.Foo;",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "import com.google.first.Bar;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;",
-          "",
-          "import com.google.first.Bar;",
-          "import com.google.second.Foo;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        // Google style frowns on wildcard imports, but we handle them all the same.
-        {
-          "package foo;",
-          "",
-          "import com.google.second.*;",
-          "import com.google.first.Bar;",
-          "import com.google.first.*;",
-          "",
-          "public class Blim {}",
-        },
-        {
-          "package foo;",
-          "",
-          "import com.google.first.*;",
-          "import com.google.first.Bar;",
-          "import com.google.second.*;",
-          "",
-          "public class Blim {}",
-        },
-      },
-      {
-        {
-          "package com.google.example;",
-          "",
-          "import com.google.common.base.Preconditions;",
-          "",
-          "import org.junit.runner.RunWith;",
-          "import org.junit.runners.JUnit4;",
-          "",
-          "import java.util.List;",
-          "",
-          "import javax.annotations.Nullable;",
-          "",
-          "import static org.junit.Assert.fail;",
-          "import static com.google.truth.Truth.assertThat;",
-          "",
-          "@RunWith(JUnit4.class)",
-          "public class SomeTest {}",
-        },
-        {
-          "package com.google.example;",
-          "",
-          "import static com.google.truth.Truth.assertThat;",
-          "import static org.junit.Assert.fail;",
-          "",
-          "import com.google.common.base.Preconditions;",
-          "import java.util.List;",
-          "import javax.annotations.Nullable;",
-          "import org.junit.runner.RunWith;",
-          "import org.junit.runners.JUnit4;",
-          "",
-          "@RunWith(JUnit4.class)",
-          "public class SomeTest {}",
-        },
-      },
+  /** Tests for import ordering in Google style. */
+  @RunWith(Parameterized.class)
+  public static class GoogleStyle {
 
-      // we unindent imports, if we reorder them
-      {
-        {
-          "  import  com.foo.Second;", //
-          "  import com.foo.First;",
-          "  public class Foo {}",
-        },
-        {
-          "import com.foo.First;", //
-          "import com.foo.Second;",
-          "",
-          "public class Foo {}",
-        }
-      },
+    private final String input;
+    private final String reordered;
 
-      // Error cases
-      {
-        {
-          "package com.google.example;", //
-          "",
-          "import\\", // \\ means there is no newline here.
-        },
-        {
-          "!!Unexpected token after import: ",
-        }
-      },
-      {
-        {
-          "package com.google.example;", //
-          "",
-          "import",
-        },
-        {
-          "!!Unexpected token after import: \n",
-        }
-      },
-      {
-        {
-          "package com.google.example;", //
-          "",
-          "import foo\\",
-        },
-        {
-          "!!Expected ; after import",
-        }
-      },
-      {
-        {
-          "package com.google.example;", //
-          "",
-          "import foo.\\",
-        },
-        {
-          "!!Could not parse imported name, at: ",
-        }
-      },
-      {
-        {
-          "import com.foo.Second;",
-          "import com.foo.First;",
-          "/* we don't support block comments",
-          "   between imports either */",
-          "import com.foo.Third;",
-        },
-        {
-          "!!Imports not contiguous (perhaps a comment separates them?)",
-        }
-      },
-      {
-        {
-          "import com.foo.Second; /* no block comments after imports */", //
-          "import com.foo.First;",
-        },
-        {
-          "!!Imports not contiguous (perhaps a comment separates them?)",
-        }
-      },
-      {
-        {
-          "import com.foo.Second;",
-          "import com.foo.First;",
-          "/* but we're not fooled by comments that look like imports:",
-          "import com.foo.Third;",
-          "*/",
-        },
-        {
-          "import com.foo.First;",
-          "import com.foo.Second;",
-          "",
-          "/* but we're not fooled by comments that look like imports:",
-          "import com.foo.Third;",
-          "*/",
-        }
-      },
-      {
-        {
-          "import com . foo . Second ;", // syntactically valid, but we don't support it
-          "import com.foo.First;",
-        },
-        {
-          "!!Expected ; after import",
-        }
-      },
-      {
-        {
-          "import com.abc.@;", //
-          "import com.abc.@@;",
-        },
-        {
-          "!!Could not parse imported name, at: @",
-        }
-      },
-      {
-        {
-          "import com.abc.3;", // digits not syntactically valid
-          "import com.abc.2;",
-        },
-        {
-          // .3 is a single token (a floating-point constant)
-          "!!Expected ; after import",
-        }
-      },
-      {
-        {
-          "import com.foo.Second", // missing semicolon
-          "import com.foo.First;",
-        },
-        {
-          "!!Expected ; after import",
-        }
-      },
-      {
-        {
-          "import com.foo.Second; import com.foo.First;", "class Test {}",
+    public GoogleStyle(String input, String reordered) {
+      this.input = input;
+      this.reordered = reordered;
+    }
+
+    @Parameters(name = "{index}: {0}")
+    public static Collection<Object[]> parameters() {
+      // Inputs are provided as three-dimensional arrays. Each element of the outer array is a test
+      // case. It consists of two arrays of lines. The first array of lines is the test input, and
+      // the second one is the expected output. If the second array has a single element starting
+      // with !! then it is expected that ImportOrderer will throw a FormatterException with that
+      // message.
+      //
+      // If a line ends with \ then we remove the \ and don't append a \n. That allows us to check
+      // some parsing edge cases.
+      String[][][] inputsOutputs = {
+        {
+          // Empty input produces empty output.
+          {}, //
+          {}
+        },
+        {
+          {
+            "foo", "bar",
+          },
+          {
+            "foo", "bar",
+          },
+        },
+        {
+          {
+            "package foo;", //
+            "",
+            "import com.google.first.Bar;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;", //
+            "",
+            "import com.google.first.Bar;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          {
+            "package foo;",
+            "",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          {
+            "package foo;",
+            "",
+            "import com.google.second.Foo;",
+            "import com.google.first.Bar;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          {
+            "import java.util.Collection;",
+            "// BUG: diagnostic contains",
+            "import java.util.List;",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import java.util.Collection;",
+            "// BUG: diagnostic contains",
+            "import java.util.List;",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "import java.util.Set;",
+            "import java.util.Collection;",
+            "// BUG: diagnostic contains",
+            "import java.util.List;",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import java.util.Collection;",
+            "// BUG: diagnostic contains",
+            "import java.util.List;",
+            "import java.util.Set;",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "import java.util.List;",
+            "// BUG: diagnostic contains",
+            "import java.util.Set;",
+            "import java.util.Collection;",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import java.util.Collection;",
+            "import java.util.List;",
+            "// BUG: diagnostic contains",
+            "import java.util.Set;",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "// BEGIN-STRIP",
+            "import com.google.testing.testsize.MediumTest;",
+            "import com.google.testing.testsize.MediumTestAttribute;",
+            "// END-STRIP",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "// BEGIN-STRIP",
+            "import com.google.testing.testsize.MediumTest;",
+            "import com.google.testing.testsize.MediumTestAttribute;",
+            "// END-STRIP",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "import com.google.testing.testsize.MediumTest;          // Keep this import",
+            "import com.google.testing.testsize.MediumTestAttribute; // Keep this import",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import com.google.testing.testsize.MediumTest;          // Keep this import",
+            "import com.google.testing.testsize.MediumTestAttribute; // Keep this import",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "import java.util.Set;",
+            "import java.util.List;",
+            "",
+            "// This comment doesn't get moved because of the blank line.",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import java.util.List;",
+            "import java.util.Set;",
+            "",
+            "// This comment doesn't get moved because of the blank line.",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            "import b.B;",
+            "// MOE: end_strip",
+            "import c.C;",
+            "// MOE: begin_strip",
+            "import a.A;",
+            "",
+            "class B74235047 {}"
+          },
+          {
+            "import a.A;",
+            "import b.B;",
+            "// MOE: end_strip",
+            "import c.C;",
+            "// MOE: begin_strip",
+            "",
+            "class B74235047 {}"
+          }
+        },
+        {
+          {
+            // Check double semicolons
+            "package foo;",
+            "",
+            "import com.google.second.Foo;;",
+            "import com.google.first.Bar;;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          {
+            "package foo;",
+            "",
+            "import com.google.second.Foo;",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "import com.google.first.Bar;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.google.first.Bar;",
+            "import com.google.second.Foo;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          // Google style frowns on wildcard imports, but we handle them all the same.
+          {
+            "package foo;",
+            "",
+            "import com.google.second.*;",
+            "import com.google.first.Bar;",
+            "import com.google.first.*;",
+            "",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.google.first.*;",
+            "import com.google.first.Bar;",
+            "import com.google.second.*;",
+            "",
+            "public class Blim {}",
+          },
+        },
+        {
+          {
+            "package com.google.example;",
+            "",
+            "import com.google.common.base.Preconditions;",
+            "",
+            "import org.junit.runner.RunWith;",
+            "import org.junit.runners.JUnit4;",
+            "",
+            "import java.util.List;",
+            "",
+            "import javax.annotations.Nullable;",
+            "",
+            "import static org.junit.Assert.fail;",
+            "import static com.google.truth.Truth.assertThat;",
+            "",
+            "@RunWith(JUnit4.class)",
+            "public class SomeTest {}",
+          },
+          {
+            "package com.google.example;",
+            "",
+            "import static com.google.truth.Truth.assertThat;",
+            "import static org.junit.Assert.fail;",
+            "",
+            "import com.google.common.base.Preconditions;",
+            "import java.util.List;",
+            "import javax.annotations.Nullable;",
+            "import org.junit.runner.RunWith;",
+            "import org.junit.runners.JUnit4;",
+            "",
+            "@RunWith(JUnit4.class)",
+            "public class SomeTest {}",
+          },
         },
-        {
-          "import com.foo.First;", //
-          "import com.foo.Second;",
-          "",
-          "class Test {}",
-        }
-      },
-      {
-        {
-          "import com.foo.Second; import com.foo.First; class Test {}",
+
+        // we unindent imports, if we reorder them
+        {
+          {
+            "  import  com.foo.Second;", //
+            "  import com.foo.First;",
+            "  public class Foo {}",
+          },
+          {
+            "import com.foo.First;", //
+            "import com.foo.Second;",
+            "",
+            "public class Foo {}",
+          }
         },
-        {
-          "import com.foo.First;", //
-          "import com.foo.Second;",
-          "",
-          "class Test {}",
-        }
-      },
-      {
-        {
-          "package p;", //
-          "",
-          "/** test */",
-          "",
-          "import a.A;",
-          "",
-          "/** test */",
-          "",
-          "class Test {}",
-        },
-        {
-          "package p;", //
-          "",
-          "/** test */",
-          "",
-          "import a.A;",
-          "",
-          "/** test */",
-          "",
-          "class Test {}",
-        }
-      },
-      {
-        {
-          "package p; import a.A; class Test {}",
+
+        // Error cases
+        {
+          {
+            "package com.google.example;", //
+            "",
+            "import\\", // \\ means there is no newline here.
+          },
+          {
+            "!!Unexpected token after import: ",
+          }
+        },
+        {
+          {
+            "package com.google.example;", //
+            "",
+            "import",
+          },
+          {
+            "!!Unexpected token after import: \n",
+          }
+        },
+        {
+          {
+            "package com.google.example;", //
+            "",
+            "import foo\\",
+          },
+          {
+            "!!Expected ; after import",
+          }
+        },
+        {
+          {
+            "package com.google.example;", //
+            "",
+            "import foo.\\",
+          },
+          {
+            "!!Could not parse imported name, at: ",
+          }
+        },
+        {
+          {
+            "import com.foo.Second;",
+            "import com.foo.First;",
+            "/* we don't support block comments",
+            "   between imports either */",
+            "import com.foo.Third;",
+          },
+          {
+            "!!Imports not contiguous (perhaps a comment separates them?)",
+          }
+        },
+        {
+          {
+            "import com.foo.Second; /* no block comments after imports */", //
+            "import com.foo.First;",
+          },
+          {
+            "!!Imports not contiguous (perhaps a comment separates them?)",
+          }
+        },
+        {
+          {
+            "import com.foo.Second;",
+            "import com.foo.First;",
+            "/* but we're not fooled by comments that look like imports:",
+            "import com.foo.Third;",
+            "*/",
+          },
+          {
+            "import com.foo.First;",
+            "import com.foo.Second;",
+            "",
+            "/* but we're not fooled by comments that look like imports:",
+            "import com.foo.Third;",
+            "*/",
+          }
+        },
+        {
+          {
+            "import com . foo . Second ;", // syntactically valid, but we don't support it
+            "import com.foo.First;",
+          },
+          {
+            "!!Expected ; after import",
+          }
+        },
+        {
+          {
+            "import com.abc.@;", //
+            "import com.abc.@@;",
+          },
+          {
+            "!!Could not parse imported name, at: @",
+          }
+        },
+        {
+          {
+            "import com.abc.3;", // digits not syntactically valid
+            "import com.abc.2;",
+          },
+          {
+            // .3 is a single token (a floating-point constant)
+            "!!Expected ; after import",
+          }
+        },
+        {
+          {
+            "import com.foo.Second", // missing semicolon
+            "import com.foo.First;",
+          },
+          {
+            "!!Expected ; after import",
+          }
+        },
+        {
+          {
+            "import com.foo.Second; import com.foo.First;", "class Test {}",
+          },
+          {
+            "import com.foo.First;", //
+            "import com.foo.Second;",
+            "",
+            "class Test {}",
+          }
+        },
+        {
+          {
+            "import com.foo.Second; import com.foo.First; class Test {}",
+          },
+          {
+            "import com.foo.First;", //
+            "import com.foo.Second;",
+            "",
+            "class Test {}",
+          }
+        },
+        {
+          {
+            "package p;", //
+            "",
+            "/** test */",
+            "",
+            "import a.A;",
+            "",
+            "/** test */",
+            "",
+            "class Test {}",
+          },
+          {
+            "package p;", //
+            "",
+            "/** test */",
+            "",
+            "import a.A;",
+            "",
+            "/** test */",
+            "",
+            "class Test {}",
+          }
+        },
+        {
+          {
+            "package p; import a.A; class Test {}",
+          },
+          {
+            "package p;", //
+            "",
+            "import a.A;",
+            "",
+            "class Test {}",
+          }
         },
-        {
-          "package p;", //
-          "",
-          "import a.A;",
-          "",
-          "class Test {}",
+      };
+
+      ImmutableList.Builder<Object[]> builder = ImmutableList.builder();
+      Arrays.stream(inputsOutputs).forEach(input -> builder.add(createRow(input)));
+      return builder.build();
+    }
+
+    @Test
+    public void reorder() throws FormatterException {
+      try {
+        String output = ImportOrderer.reorderImports(input, Style.GOOGLE);
+        assertWithMessage("Expected exception").that(reordered).doesNotMatch("^!!");
+        assertWithMessage(input).that(output).isEqualTo(reordered);
+      } catch (FormatterException e) {
+        if (!reordered.startsWith("!!")) {
+          throw e;
         }
-      },
-    };
-    ImmutableList.Builder<Object[]> builder = ImmutableList.builder();
-    for (String[][] inputAndOutput : inputsOutputs) {
-      assertThat(inputAndOutput.length).isEqualTo(2);
-      String[] input = inputAndOutput[0];
-      String[] output = inputAndOutput[1];
-      if (output.length == 0) {
-        output = input;
+        assertThat(reordered).endsWith("\n");
+        assertThat(e)
+            .hasMessageThat()
+            .isEqualTo("error: " + reordered.substring(2, reordered.length() - 1));
       }
-      String[] parameters = {
-        Joiner.on('\n').join(input) + '\n', //
-        Joiner.on('\n').join(output) + '\n',
-      };
-      // If a line ends with \ then we remove the \ and don't append a \n. That allows us to check
-      // some parsing edge cases.
-      parameters[0] = parameters[0].replace("\\\n", "");
-      builder.add(parameters);
     }
-    return builder.build();
   }
 
-  private final String input;
-  private final String reordered;
+  /** Tests for import ordering in AOSP style. */
+  @RunWith(Parameterized.class)
+  public static class AospStyle {
 
-  public ImportOrdererTest(String input, String reordered) {
-    this.input = input;
-    this.reordered = reordered;
-  }
+    private final String input;
+    private final String reordered;
+
+    public AospStyle(String input, String reordered) {
+      this.input = input;
+      this.reordered = reordered;
+    }
+
+    @Parameters(name = "{index}: {0}")
+    public static Collection<Object[]> parameters() {
+      // Inputs are provided as three-dimensional arrays. Each element of the outer array is a test
+      // case. It consists of two arrays of lines. The first array of lines is the test input, and
+      // the second one is the expected output. If the second array has a single element starting
+      // with !! then it is expected that ImportOrderer will throw a FormatterException with that
+      // message.
+      //
+      // If a line ends with \ then we remove the \ and don't append a \n. That allows us to check
+      // some parsing edge cases.
+      String[][][] inputsOutputs = {
+        // Capital letter before lowercase
+        {
+          {
+            "package foo;",
+            "",
+            "import android.abC.Bar;",
+            "import android.abc.Bar;",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import android.abC.Bar;",
+            "import android.abc.Bar;",
+            "",
+            "public class Blim {}",
+          }
+        },
+        // Blank line between "com.android" and "com.anythingelse"
+        {
+          {
+            "package foo;",
+            "",
+            "import com.android.Bar;",
+            "import com.google.Bar;",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import com.android.Bar;",
+            "",
+            "import com.google.Bar;",
+            "",
+            "public class Blim {}",
+          }
+        },
+        // Rough ordering -- statics, android, third party, then java, with blank lines between
+        // major groupings
+        {
+          {
+            "package foo;",
+            "",
+            "import static net.Bar.baz;",
+            "import static org.junit.Bar.baz;",
+            "import static com.google.Bar.baz;",
+            "import static java.lang.Bar.baz;",
+            "import static junit.Bar.baz;",
+            "import static javax.annotation.Bar.baz;",
+            "import static android.Bar.baz;",
+            "import net.Bar;",
+            "import org.junit.Bar;",
+            "import com.google.Bar;",
+            "import java.lang.Bar;",
+            "import junit.Bar;",
+            "import javax.annotation.Bar;",
+            "import android.Bar;",
+            "public class Blim {}",
+          },
+          {
+            "package foo;",
+            "",
+            "import static android.Bar.baz;",
+            "",
+            "import static com.google.Bar.baz;",
+            "",
+            "import static junit.Bar.baz;",
+            "",
+            "import static net.Bar.baz;",
+            "",
+            "import static org.junit.Bar.baz;",
+            "",
+            "import static java.lang.Bar.baz;",
+            "",
+            "import static javax.annotation.Bar.baz;",
+            "",
+            "import android.Bar;",
+            "",
+            "import com.google.Bar;",
+            "",
+            "import junit.Bar;",
+            "",
+            "import net.Bar;",
+            "",
+            "import org.junit.Bar;",
+            "",
+            "import java.lang.Bar;",
+            "",
+            "import javax.annotation.Bar;",
+            "",
+            "public class Blim {}",
+          }
+        },
+        {
+          {
+            "package foo;",
+            "",
+            "import static java.first.Bar.baz;",
+            "import static com.second.Bar.baz;",
+            "import com.first.Bar;",
+            "import static android.second.Bar.baz;",
+            "import dalvik.first.Bar;",
+            "import static dalvik.first.Bar.baz;",
+            "import static androidx.second.Bar.baz;",
+            "import java.second.Bar;",
+            "import static com.android.second.Bar.baz;",
+            "import static net.first.Bar.baz;",
+            "import gov.second.Bar;",
+            "import junit.second.Bar;",
+            "import static libcore.second.Bar.baz;",
+            "import static java.second.Bar.baz;",
+            "import static net.second.Bar.baz;",
+            "import static org.first.Bar.baz;",
+            "import static dalvik.second.Bar.baz;",
+            "import javax.first.Bar;",
+            "import static javax.second.Bar.baz;",
+            "import android.first.Bar;",
+            "import android.second.Bar;",
+            "import static javax.first.Bar.baz;",
+            "import androidx.first.Bar;",
+            "import static androidx.first.Bar.baz;",
+            "import androidx.second.Bar;",
+            "import com.android.first.Bar;",
+            "import gov.first.Bar;",
+            "import com.android.second.Bar;",
+            "import dalvik.second.Bar;",
+            "import static org.second.Bar.baz;",
+            "import net.first.Bar;",
+            "import libcore.second.Bar;",
+            "import static android.first.Bar.baz;",
+            "import com.second.Bar;",
+            "import static gov.second.Bar.baz;",
+            "import static gov.first.Bar.baz;",
+            "import static junit.first.Bar.baz;",
+            "import libcore.first.Bar;",
+            "import junit.first.Bar;",
+            "import javax.second.Bar;",
+            "import static libcore.first.Bar.baz;",
+            "import net.second.Bar;",
+            "import static com.first.Bar.baz;",
+            "import org.second.Bar;",
+            "import static junit.second.Bar.baz;",
+            "import java.first.Bar;",
+            "import org.first.Bar;",
+            "import static com.android.first.Bar.baz;",
+            "public class Blim {}",
+          },
+          {
+            "package foo;", //
+            "",
+            "import static android.first.Bar.baz;",
+            "import static android.second.Bar.baz;",
+            "",
+            "import static androidx.first.Bar.baz;",
+            "import static androidx.second.Bar.baz;",
+            "",
+            "import static com.android.first.Bar.baz;",
+            "import static com.android.second.Bar.baz;",
+            "",
+            "import static dalvik.first.Bar.baz;",
+            "import static dalvik.second.Bar.baz;",
+            "",
+            "import static libcore.first.Bar.baz;",
+            "import static libcore.second.Bar.baz;",
+            "",
+            "import static com.first.Bar.baz;",
+            "import static com.second.Bar.baz;",
+            "",
+            "import static gov.first.Bar.baz;",
+            "import static gov.second.Bar.baz;",
+            "",
+            "import static junit.first.Bar.baz;",
+            "import static junit.second.Bar.baz;",
+            "",
+            "import static net.first.Bar.baz;",
+            "import static net.second.Bar.baz;",
+            "",
+            "import static org.first.Bar.baz;",
+            "import static org.second.Bar.baz;",
+            "",
+            "import static java.first.Bar.baz;",
+            "import static java.second.Bar.baz;",
+            "",
+            "import static javax.first.Bar.baz;",
+            "import static javax.second.Bar.baz;",
+            "",
+            "import android.first.Bar;",
+            "import android.second.Bar;",
+            "",
+            "import androidx.first.Bar;",
+            "import androidx.second.Bar;",
+            "",
+            "import com.android.first.Bar;",
+            "import com.android.second.Bar;",
+            "",
+            "import dalvik.first.Bar;",
+            "import dalvik.second.Bar;",
+            "",
+            "import libcore.first.Bar;",
+            "import libcore.second.Bar;",
+            "",
+            "import com.first.Bar;",
+            "import com.second.Bar;",
+            "",
+            "import gov.first.Bar;",
+            "import gov.second.Bar;",
+            "",
+            "import junit.first.Bar;",
+            "import junit.second.Bar;",
+            "",
+            "import net.first.Bar;",
+            "import net.second.Bar;",
+            "",
+            "import org.first.Bar;",
+            "import org.second.Bar;",
+            "",
+            "import java.first.Bar;",
+            "import java.second.Bar;",
+            "",
+            "import javax.first.Bar;",
+            "import javax.second.Bar;",
+            "",
+            "public class Blim {}",
+          },
+        },
+      };
+      ImmutableList.Builder<Object[]> builder = ImmutableList.builder();
+      Arrays.stream(inputsOutputs).forEach(input -> builder.add(createRow(input)));
+      return builder.build();
+    }
 
-  @Test
-  public void reorder() throws FormatterException {
-    try {
-      String output = ImportOrderer.reorderImports(input);
-      assertWithMessage("Expected exception").that(reordered).doesNotMatch("^!!");
-      assertWithMessage(input).that(output).isEqualTo(reordered);
-    } catch (FormatterException e) {
-      if (!reordered.startsWith("!!")) {
-        throw e;
+    @Test
+    public void reorder() throws FormatterException {
+      try {
+        String output = ImportOrderer.reorderImports(input, Style.AOSP);
+        assertWithMessage("Expected exception").that(reordered).doesNotMatch("^!!");
+        assertWithMessage(input).that(output).isEqualTo(reordered);
+      } catch (FormatterException e) {
+        if (!reordered.startsWith("!!")) {
+          throw e;
+        }
+        assertThat(reordered).endsWith("\n");
+        assertThat(e)
+            .hasMessageThat()
+            .isEqualTo("error: " + reordered.substring(2, reordered.length() - 1));
       }
-      assertThat(reordered).endsWith("\n");
-      assertThat(e.getMessage())
-          .isEqualTo("error: " + reordered.substring(2, reordered.length() - 1));
     }
   }
+
+  private static Object[] createRow(String[][] inputAndOutput) {
+    assertThat(inputAndOutput).hasLength(2);
+    String[] input = inputAndOutput[0];
+    String[] output = inputAndOutput[1];
+    if (output.length == 0) {
+      output = input;
+    }
+    Object[] row = {
+      Joiner.on('\n').join(input) + '\n', //
+      Joiner.on('\n').join(output) + '\n',
+    };
+    // If a line ends with \ then we remove the \ and don't append a \n. That allows us to check
+    // some parsing edge cases.
+    row[0] = ((String) row[0]).replace("\\\n", "");
+    return row;
+  }
 }
