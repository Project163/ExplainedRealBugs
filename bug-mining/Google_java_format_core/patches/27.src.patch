diff --git a/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptions.java b/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptions.java
index 47a6cfd..a919284 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptions.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptions.java
@@ -38,6 +38,8 @@ final class CommandLineOptions {
   private final boolean removeJavadocOnlyImports;
   private final boolean sortImports;
   private final boolean removeUnusedImports;
+  private final boolean dryRun;
+  private final boolean setExitIfChanged;
 
   CommandLineOptions(
       ImmutableList<String> files,
@@ -52,7 +54,9 @@ final class CommandLineOptions {
       boolean fixImportsOnly,
       boolean removeJavadocOnlyImports,
       boolean sortImports,
-      boolean removeUnusedImports) {
+      boolean removeUnusedImports,
+      boolean dryRun,
+      boolean setExitIfChanged) {
     this.files = files;
     this.inPlace = inPlace;
     this.lines = lines;
@@ -66,6 +70,8 @@ final class CommandLineOptions {
     this.removeJavadocOnlyImports = removeJavadocOnlyImports;
     this.sortImports = sortImports;
     this.removeUnusedImports = removeUnusedImports;
+    this.dryRun = dryRun;
+    this.setExitIfChanged = setExitIfChanged;
   }
 
   /** The files to format. */
@@ -136,6 +142,18 @@ final class CommandLineOptions {
     return removeUnusedImports;
   }
 
+  /**
+   * Print the paths of the files whose contents would change if the formatter were run normally.
+   */
+  boolean dryRun() {
+    return dryRun;
+  }
+
+  /** Return exit code 1 if there are any formatting changes. */
+  boolean setExitIfChanged() {
+    return setExitIfChanged;
+  }
+
   /** Returns true if partial formatting was selected. */
   boolean isSelection() {
     return !lines().isEmpty() || !offsets().isEmpty() || !lengths().isEmpty();
@@ -151,15 +169,17 @@ final class CommandLineOptions {
     private final ImmutableRangeSet.Builder<Integer> lines = ImmutableRangeSet.builder();
     private final ImmutableList.Builder<Integer> offsets = ImmutableList.builder();
     private final ImmutableList.Builder<Integer> lengths = ImmutableList.builder();
-    private Boolean inPlace = false;
-    private Boolean aosp = false;
-    private Boolean version = false;
-    private Boolean help = false;
-    private Boolean stdin = false;
-    private Boolean fixImportsOnly = false;
-    private Boolean removeJavadocOnlyImports = false;
-    private Boolean sortImports = true;
-    private Boolean removeUnusedImports = true;
+    private boolean inPlace = false;
+    private boolean aosp = false;
+    private boolean version = false;
+    private boolean help = false;
+    private boolean stdin = false;
+    private boolean fixImportsOnly = false;
+    private boolean removeJavadocOnlyImports = false;
+    private boolean sortImports = true;
+    private boolean removeUnusedImports = true;
+    private boolean dryRun = false;
+    private boolean setExitIfChanged = false;
 
     ImmutableList.Builder<String> filesBuilder() {
       return files;
@@ -224,21 +244,33 @@ final class CommandLineOptions {
       return this;
     }
 
+    Builder dryRun(boolean dryRun) {
+      this.dryRun = dryRun;
+      return this;
+    }
+
+    Builder setExitIfChanged(boolean setExitIfChanged) {
+      this.setExitIfChanged = setExitIfChanged;
+      return this;
+    }
+
     CommandLineOptions build() {
       return new CommandLineOptions(
-          this.files.build(),
-          this.inPlace,
-          this.lines.build(),
-          this.offsets.build(),
-          this.lengths.build(),
-          this.aosp,
-          this.version,
-          this.help,
-          this.stdin,
-          this.fixImportsOnly,
-          this.removeJavadocOnlyImports,
-          this.sortImports,
-          this.removeUnusedImports);
+          files.build(),
+          inPlace,
+          lines.build(),
+          offsets.build(),
+          lengths.build(),
+          aosp,
+          version,
+          help,
+          stdin,
+          fixImportsOnly,
+          removeJavadocOnlyImports,
+          sortImports,
+          removeUnusedImports,
+          dryRun,
+          setExitIfChanged);
     }
   }
 }
diff --git a/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java b/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
index b12e2bf..3017c8f 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
@@ -98,6 +98,13 @@ final class CommandLineOptionsParser {
         case "-":
           optionsBuilder.stdin(true);
           break;
+        case "-n":
+        case "--dry-run":
+          optionsBuilder.dryRun(true);
+          break;
+        case "--set-exit-if-changed":
+          optionsBuilder.setExitIfChanged(true);
+          break;
         default:
           throw new IllegalArgumentException("unexpected flag: " + flag);
       }
diff --git a/core/src/main/java/com/google/googlejavaformat/java/Main.java b/core/src/main/java/com/google/googlejavaformat/java/Main.java
index 7164d96..8f937ef 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/Main.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/Main.java
@@ -132,6 +132,7 @@ public final class Main {
 
     boolean allOk = true;
     for (Map.Entry<Path, Future<String>> result : results.entrySet()) {
+      Path path = result.getKey();
       String formatted;
       try {
         formatted = result.getValue().get();
@@ -142,26 +143,34 @@ public final class Main {
       } catch (ExecutionException e) {
         if (e.getCause() instanceof FormatterException) {
           for (FormatterDiagnostic diagnostic : ((FormatterException) e.getCause()).diagnostics()) {
-            errWriter.println(result.getKey() + ":" + diagnostic.toString());
+            errWriter.println(path + ":" + diagnostic.toString());
           }
         } else {
-          errWriter.println(result.getKey() + ": error: " + e.getCause().getMessage());
+          errWriter.println(path + ": error: " + e.getCause().getMessage());
           e.getCause().printStackTrace(errWriter);
         }
         allOk = false;
         continue;
       }
+      boolean changed = !formatted.equals(inputs.get(path));
+      if (changed && parameters.setExitIfChanged()) {
+        allOk = false;
+      }
       if (parameters.inPlace()) {
-        if (formatted.equals(inputs.get(result.getKey()))) {
+        if (!changed) {
           continue; // preserve original file
         }
         try {
-          Files.write(result.getKey(), formatted.getBytes(UTF_8));
+          Files.write(path, formatted.getBytes(UTF_8));
         } catch (IOException e) {
-          errWriter.println(result.getKey() + ": could not write file: " + e.getMessage());
+          errWriter.println(path + ": could not write file: " + e.getMessage());
           allOk = false;
           continue;
         }
+      } else if (parameters.dryRun()) {
+        if (changed) {
+          outWriter.println(path);
+        }
       } else {
         outWriter.write(formatted);
       }
@@ -176,17 +185,28 @@ public final class Main {
     } catch (IOException e) {
       throw new IOError(e);
     }
+    boolean ok = true;
     try {
       String output = new FormatFileCallable(parameters, input, options).call();
-      outWriter.write(output);
-      return 0;
+      boolean changed = !input.equals(output);
+      if (changed && parameters.setExitIfChanged()) {
+        ok = false;
+      }
+      if (parameters.dryRun()) {
+        if (changed) {
+          outWriter.println(STDIN_FILENAME);
+        }
+      } else {
+        outWriter.write(output);
+      }
     } catch (FormatterException e) {
       for (FormatterDiagnostic diagnostic : e.diagnostics()) {
         errWriter.println(STDIN_FILENAME + ":" + diagnostic.toString());
       }
-      return 1;
+      ok = false;
       // TODO(cpovirk): Catch other types of exception (as we do in the formatFiles case).
     }
+    return ok ? 0 : 1;
   }
 
   /** Parses and validates command-line flags. */
@@ -212,12 +232,17 @@ public final class Main {
       throw new UsageException("partial formatting is only support for a single file");
     }
     if (parameters.offsets().size() != parameters.lengths().size()) {
-      throw new UsageException(
-          String.format("-offsets and -lengths flags must be provided in matching pairs"));
+      throw new UsageException("-offsets and -lengths flags must be provided in matching pairs");
     }
     if (filesToFormat <= 0 && !parameters.version() && !parameters.help()) {
       throw new UsageException("no files were provided");
     }
+    if (parameters.stdin() && !parameters.files().isEmpty()) {
+      throw new UsageException("cannot format from standard input and files simultaneously");
+    }
+    if (parameters.dryRun() && parameters.inPlace()) {
+      throw new UsageException("cannot use --dry-run and --in-place at the same time");
+    }
     return parameters;
   }
 }
diff --git a/core/src/main/java/com/google/googlejavaformat/java/UsageException.java b/core/src/main/java/com/google/googlejavaformat/java/UsageException.java
index 6a29991..82a1277 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/UsageException.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/UsageException.java
@@ -44,6 +44,11 @@ public final class UsageException extends Exception {
     "    Do not fix the import order. Unused imports will still be removed.",
     "  --skip-removing-unused-imports",
     "    Do not remove unused imports. Imports will still be sorted.",
+    "  --dry-run, -n",
+    "    Prints the paths of the files whose contents would change if the formatter were run"
+        + " normally.",
+    "  --set-exit-if-changed",
+    "    Return exit code 1 if there are any formatting changes.",
     "  --length, -length",
     "    Character length to format.",
     "  --lines, -lines, --line, -line",
diff --git a/core/src/test/java/com/google/googlejavaformat/java/CommandLineFlagsTest.java b/core/src/test/java/com/google/googlejavaformat/java/CommandLineFlagsTest.java
index 7967f72..3da87d9 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/CommandLineFlagsTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/CommandLineFlagsTest.java
@@ -14,6 +14,7 @@
 
 package com.google.googlejavaformat.java;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import org.junit.Test;
@@ -148,4 +149,40 @@ public class CommandLineFlagsTest {
       // expected
     }
   }
+
+  @Test
+  public void stdinAndFiles() {
+    try {
+      Main.processArgs("-", "A.java");
+      fail();
+    } catch (UsageException e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("cannot format from standard input and files simultaneously");
+    }
+  }
+
+  @Test
+  public void inPlaceStdin() {
+    try {
+      Main.processArgs("-i", "-");
+      fail();
+    } catch (UsageException e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("in-place formatting was requested but no files were provided");
+    }
+  }
+
+  @Test
+  public void inPlaceDryRun() {
+    try {
+      Main.processArgs("-i", "-n", "A.java");
+      fail();
+    } catch (UsageException e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("cannot use --dry-run and --in-place at the same time");
+    }
+  }
 }
diff --git a/core/src/test/java/com/google/googlejavaformat/java/CommandLineOptionsParserTest.java b/core/src/test/java/com/google/googlejavaformat/java/CommandLineOptionsParserTest.java
index 8c6328e..f3816e9 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/CommandLineOptionsParserTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/CommandLineOptionsParserTest.java
@@ -42,6 +42,8 @@ public class CommandLineOptionsParserTest {
     assertThat(options.version()).isFalse();
     assertThat(options.sortImports()).isTrue();
     assertThat(options.removeUnusedImports()).isTrue();
+    assertThat(options.dryRun()).isFalse();
+    assertThat(options.setExitIfChanged()).isFalse();
   }
 
   @Test
@@ -102,7 +104,7 @@ public class CommandLineOptionsParserTest {
 
   @Test
   public void inPlace() {
-    assertThat(CommandLineOptionsParser.parse(Arrays.asList("-i")).inPlace()).isTrue();
+    assertThat(CommandLineOptionsParser.parse(Arrays.asList("-i", "A.java")).inPlace()).isTrue();
   }
 
   @Test
@@ -125,6 +127,20 @@ public class CommandLineOptionsParserTest {
         .isFalse();
   }
 
+  @Test
+  public void dryRun() {
+    assertThat(CommandLineOptionsParser.parse(Arrays.asList("--dry-run")).dryRun()).isTrue();
+    assertThat(CommandLineOptionsParser.parse(Arrays.asList("-n")).dryRun()).isTrue();
+  }
+
+  @Test
+  public void setExitIfChanged() {
+    assertThat(
+            CommandLineOptionsParser.parse(Arrays.asList("--set-exit-if-changed"))
+                .setExitIfChanged())
+        .isTrue();
+  }
+
   // TODO(cushon): consider handling this in the parser and reporting a more detailed error
   @Test
   public void illegalLines() {
@@ -135,4 +151,5 @@ public class CommandLineOptionsParserTest {
       assertThat(e.getMessage()).contains("overlap");
     }
   }
+
 }
diff --git a/core/src/test/java/com/google/googlejavaformat/java/MainTest.java b/core/src/test/java/com/google/googlejavaformat/java/MainTest.java
index 103791a..aac415d 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/MainTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/MainTest.java
@@ -315,4 +315,110 @@ public class MainTest {
     assertThat(main.format("-")).isEqualTo(0);
     assertThat(out.toString()).isEqualTo("class T {}\n");
   }
+
+  @Test
+  public void dryRunStdinUnchanged() throws Exception {
+    StringWriter out = new StringWriter();
+    StringWriter err = new StringWriter();
+    Main main =
+        new Main(
+            new PrintWriter(out, true),
+            new PrintWriter(err, true),
+            new ByteArrayInputStream("class Test {}\n".getBytes(UTF_8)));
+    assertThat(main.format("-n", "-")).isEqualTo(0);
+    assertThat(out.toString()).isEmpty();
+    assertThat(err.toString()).isEmpty();
+  }
+
+  @Test
+  public void dryRunStdinChanged() throws Exception {
+    StringWriter out = new StringWriter();
+    StringWriter err = new StringWriter();
+    String input = "class Test {\n}\n";
+    Main main =
+        new Main(
+            new PrintWriter(out, true),
+            new PrintWriter(err, true),
+            new ByteArrayInputStream(input.getBytes(UTF_8)));
+    assertThat(main.format("-n", "-")).isEqualTo(0);
+    assertThat(out.toString()).isEqualTo("<stdin>\n");
+    assertThat(err.toString()).isEmpty();
+  }
+
+  @Test
+  public void dryRunFiles() throws Exception {
+    Path a = testFolder.newFile("A.java").toPath();
+    Path b = testFolder.newFile("B.java").toPath();
+    Path c = testFolder.newFile("C.java").toPath();
+    Files.write(a, "class A {}\n".getBytes(UTF_8));
+    Files.write(b, "class B {\n}\n".getBytes(UTF_8));
+    Files.write(c, "class C {\n}\n".getBytes(UTF_8));
+
+    StringWriter out = new StringWriter();
+    StringWriter err = new StringWriter();
+    Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true), System.in);
+    int exitCode =
+        main.format(
+            "-n",
+            a.toAbsolutePath().toAbsolutePath().toString(),
+            b.toAbsolutePath().toString(),
+            c.toAbsolutePath().toString());
+
+    assertThat(exitCode).isEqualTo(0);
+
+    assertThat(out.toString())
+        .isEqualTo(b.toAbsolutePath().toString() + "\n" + c.toAbsolutePath().toString() + "\n");
+    assertThat(err.toString()).isEmpty();
+  }
+
+  @Test
+  public void exitIfChangedStdin() throws Exception {
+    Path path = testFolder.newFile("Test.java").toPath();
+    Files.write(path, "class Test {\n}\n".getBytes(UTF_8));
+    Process process =
+        new ProcessBuilder(
+                ImmutableList.of(
+                    Paths.get(System.getProperty("java.home")).resolve("bin/java").toString(),
+                    "-cp",
+                    System.getProperty("java.class.path"),
+                    Main.class.getName(),
+                    "-n",
+                    "--set-exit-if-changed",
+                    "-"))
+            .redirectInput(path.toFile())
+            .redirectError(Redirect.PIPE)
+            .redirectOutput(Redirect.PIPE)
+            .start();
+    process.waitFor();
+    String err = new String(ByteStreams.toByteArray(process.getErrorStream()), UTF_8);
+    String out = new String(ByteStreams.toByteArray(process.getInputStream()), UTF_8);
+    assertThat(err).isEmpty();
+    assertThat(out).isEqualTo("<stdin>\n");
+    assertThat(process.exitValue()).isEqualTo(1);
+  }
+
+  @Test
+  public void exitIfChangedFiles() throws Exception {
+    Path path = testFolder.newFile("Test.java").toPath();
+    Files.write(path, "class Test {\n}\n".getBytes(UTF_8));
+    Process process =
+        new ProcessBuilder(
+                ImmutableList.of(
+                    Paths.get(System.getProperty("java.home")).resolve("bin/java").toString(),
+                    "-cp",
+                    System.getProperty("java.class.path"),
+                    Main.class.getName(),
+                    "-n",
+                    "--set-exit-if-changed",
+                    path.toAbsolutePath().toString()))
+            .redirectError(Redirect.PIPE)
+            .redirectOutput(Redirect.PIPE)
+            .start();
+    process.waitFor();
+    String err = new String(ByteStreams.toByteArray(process.getErrorStream()), UTF_8);
+    String out = new String(ByteStreams.toByteArray(process.getInputStream()), UTF_8);
+    assertThat(err).isEmpty();
+    assertThat(out).isEqualTo(path.toAbsolutePath().toString() + "\n");
+    assertThat(process.exitValue()).isEqualTo(1);
+  }
 }
