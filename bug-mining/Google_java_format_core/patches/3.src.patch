diff --git a/core/src/main/java/com/google/googlejavaformat/Input.java b/core/src/main/java/com/google/googlejavaformat/Input.java
index bf3ada9..b64294c 100644
--- a/core/src/main/java/com/google/googlejavaformat/Input.java
+++ b/core/src/main/java/com/google/googlejavaformat/Input.java
@@ -60,28 +60,19 @@ public abstract class Input extends InputOutput {
      */
     String getOriginalText();
 
-    /**
-     * Is the {@code Tok} a newline?
-     * @return whether it is a newline
-     */
+    /** Is the {@code Tok} a newline? */
     boolean isNewline();
 
-    /**
-     * Is the {@code Tok} a "//" comment?
-     * @return whether it is a "//" comment
-     */
+    /** Is the {@code Tok} a "//" comment? */
     boolean isSlashSlashComment();
 
-    /**
-     * Is the {@code Tok} a "/*" comment?
-     * @return whether it is a "/*" comment
-     */
+    /** Is the {@code Tok} a "//" comment? */
     boolean isSlashStarComment();
 
-    /**
-     * Is the {@code Tok} a comment?
-     * @return whether it is a comment
-     */
+    /** Is the {@code Tok} a javadoc comment? */
+    boolean isJavadocComment();
+
+    /** Is the {@code Tok} a comment? */
     boolean isComment();
   }
 
diff --git a/core/src/main/java/com/google/googlejavaformat/OpsBuilder.java b/core/src/main/java/com/google/googlejavaformat/OpsBuilder.java
index 11827fc..32c2d46 100644
--- a/core/src/main/java/com/google/googlejavaformat/OpsBuilder.java
+++ b/core/src/main/java/com/google/googlejavaformat/OpsBuilder.java
@@ -91,7 +91,7 @@ public final class OpsBuilder {
             return Optional.of(true);
           }
         }
-        return Optional.of(false);
+        return Optional.absent();
       }
 
       @Override
@@ -392,6 +392,7 @@ public final class OpsBuilder {
           int newlines = 0; // Count of newlines in a row.
           boolean space = false; // Do we need an extra space after a previous "/*" comment?
           boolean lastWasComment = false; // Was the last thing we output a comment?
+          boolean allowBlankAfterLastComment = false;
           for (Input.Tok tokBefore : token.getToksBefore()) {
             if (tokBefore.isNewline()) {
               newlines++;
@@ -406,8 +407,15 @@ public final class OpsBuilder {
               space = tokBefore.isSlashStarComment();
               newlines = 0;
               lastWasComment = true;
+              allowBlankAfterLastComment =
+                  tokBefore.isSlashSlashComment()
+                      || (tokBefore.isSlashStarComment() && !tokBefore.isJavadocComment());
             }
           }
+          if (allowBlankAfterLastComment && newlines > 1) {
+            // Force a line break after two newlines in a row following a line or block comment
+            output.blankLine(token.getTok().getIndex(), BlankLineWanted.YES);
+          }
           if (lastWasComment && newlines > 0) {
             tokOps.put(j, Doc.Break.makeForced());
           } else if (space) {
diff --git a/core/src/main/java/com/google/googlejavaformat/Output.java b/core/src/main/java/com/google/googlejavaformat/Output.java
index 7c46609..c6d7f7f 100644
--- a/core/src/main/java/com/google/googlejavaformat/Output.java
+++ b/core/src/main/java/com/google/googlejavaformat/Output.java
@@ -50,12 +50,6 @@ public abstract class Output extends InputOutput {
    */
   public abstract void indent(int indent);
 
-  /**
-   * Insert a blank line into the output stream during formatting,
-   * e.g. if a specific break is taken.
-   */
-  public abstract void forceBlankLine();
-
   /**
    * Output a string.
    * @param text the string
diff --git a/core/src/main/java/com/google/googlejavaformat/java/FileToFormatStdin.java b/core/src/main/java/com/google/googlejavaformat/java/FileToFormatStdin.java
index 8bcac55..54757ec 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/FileToFormatStdin.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/FileToFormatStdin.java
@@ -26,7 +26,7 @@ class FileToFormatStdin extends FileToFormat {
   /**
    * A fake filename to return when the file to format comes from stdin.
    */
-  private static final String STDIN_FILENAME = "<stdin>";
+  public static final String STDIN_FILENAME = "<stdin>";
 
   private final InputStream inputStream;
 
diff --git a/core/src/main/java/com/google/googlejavaformat/java/Formatter.java b/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
index 74421a2..6c48020 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/Formatter.java
@@ -14,6 +14,8 @@
 
 package com.google.googlejavaformat.java;
 
+import static com.google.googlejavaformat.java.FileToFormatStdin.STDIN_FILENAME;
+
 import com.google.common.collect.DiscreteDomain;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Range;
@@ -130,7 +132,7 @@ public final class Formatter {
    * @throws FormatterException if the input string cannot be parsed
    */
   public String formatSource(String input) throws FormatterException {
-    JavaInput javaInput = new JavaInput(null, input);
+    JavaInput javaInput = new JavaInput(STDIN_FILENAME, input);
     JavaOutput javaOutput = new JavaOutput(javaInput, new JavaCommentsHelper());
     List<FormatterDiagnostic> errors = new ArrayList<>();
     format(javaInput, javaOutput, MAX_WIDTH, errors, 1);
@@ -158,7 +160,7 @@ public final class Formatter {
    */
   public String formatSource(String input, List<Range<Integer>> characterRanges)
       throws FormatterException {
-    JavaInput javaInput = new JavaInput(null, input);
+    JavaInput javaInput = new JavaInput(STDIN_FILENAME, input);
     JavaOutput javaOutput = new JavaOutput(javaInput, new JavaCommentsHelper());
     List<FormatterDiagnostic> errors = new ArrayList<>();
     format(javaInput, javaOutput, MAX_WIDTH, errors, 1);
@@ -185,7 +187,7 @@ public final class Formatter {
    */
   public ImmutableList<Replacement> getFormatReplacements(
       String input, List<Range<Integer>> characterRanges) throws FormatterException {
-    JavaInput javaInput = new JavaInput(null, input);
+    JavaInput javaInput = new JavaInput(STDIN_FILENAME, input);
     JavaOutput javaOutput = new JavaOutput(javaInput, new JavaCommentsHelper());
     List<FormatterDiagnostic> errors = new ArrayList<>();
     format(javaInput, javaOutput, MAX_WIDTH, errors, 1);
diff --git a/core/src/main/java/com/google/googlejavaformat/java/JavaInput.java b/core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
index dcb5055..23adf20 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
@@ -15,6 +15,7 @@
 package com.google.googlejavaformat.java;
 
 import static com.google.common.base.MoreObjects.firstNonNull;
+import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Splitter;
@@ -123,6 +124,11 @@ public final class JavaInput extends Input {
       return text.startsWith("/*");
     }
 
+    @Override
+    public boolean isJavadocComment() {
+      return text.startsWith("/**");
+    }
+
     @Override
     public boolean isComment() {
       return isSlashSlashComment() || isSlashStarComment();
@@ -229,8 +235,8 @@ public final class JavaInput extends Input {
    * @throws FormatterException if the input cannot be parsed
    */
   public JavaInput(String filename, String text) throws FormatterException {
-    this.filename = filename;
-    this.text = text;
+    this.filename = checkNotNull(filename);
+    this.text = checkNotNull(text);
     char[] chars = text.toCharArray();
     List<String> lines = NEWLINE_SPLITTER.splitToList(text);
     setLines(ImmutableList.copyOf(lines));
diff --git a/core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java b/core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
index 5295ed1..552299a 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
@@ -51,6 +51,7 @@ import org.eclipse.jdt.core.dom.BreakStatement;
 import org.eclipse.jdt.core.dom.CastExpression;
 import org.eclipse.jdt.core.dom.CatchClause;
 import org.eclipse.jdt.core.dom.CharacterLiteral;
+import org.eclipse.jdt.core.dom.ChildListPropertyDescriptor;
 import org.eclipse.jdt.core.dom.ClassInstanceCreation;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.eclipse.jdt.core.dom.ConditionalExpression;
@@ -103,6 +104,7 @@ import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Statement;
 import org.eclipse.jdt.core.dom.StringLiteral;
+import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
 import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
@@ -130,6 +132,7 @@ import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Deque;
+import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -230,6 +233,33 @@ public final class JavaInputAstVisitor extends ASTVisitor {
     }
   }
 
+  /** Position in a list of declarations. */
+  enum DeclarationPosition {
+    FIRST,
+    INTERIOR,
+    LAST;
+
+    static EnumSet<DeclarationPosition> getPositionInParent(ASTNode node) {
+      EnumSet<DeclarationPosition> position = EnumSet.noneOf(DeclarationPosition.class);
+      StructuralPropertyDescriptor locationInParent = node.getLocationInParent();
+      if (locationInParent instanceof ChildListPropertyDescriptor) {
+        List<ASTNode> propertyList =
+            (List<ASTNode>) node.getParent().getStructuralProperty(locationInParent);
+        int idx = propertyList.indexOf(node);
+        if (idx == 0) {
+          position.add(DeclarationPosition.FIRST);
+        }
+        if (idx == propertyList.size() - 1) {
+          position.add(DeclarationPosition.LAST);
+        }
+        if (position.isEmpty()) {
+          position.add(DeclarationPosition.INTERIOR);
+        }
+      }
+      return position;
+    }
+  }
+
   private final OpsBuilder builder;
 
   private static final Indent.Const ZERO = Indent.Const.ZERO;
@@ -348,6 +378,7 @@ public final class JavaInputAstVisitor extends ASTVisitor {
       }
       for (ImportDeclaration importDeclaration : (List<ImportDeclaration>) node.imports()) {
         markForPartialFormat();
+        builder.blankLineWanted(BlankLineWanted.PRESERVE);
         visit(importDeclaration);
         builder.forcedBreak();
       }
@@ -1719,16 +1750,24 @@ public final class JavaInputAstVisitor extends ASTVisitor {
     tokenBreakTrailingComment("{", plusTwo);
     builder.blankLineWanted(BlankLineWanted.NO);
     builder.open(plusFour);
+    boolean first = true;
+    boolean lastWasSwitchCase = false;
     for (ASTNode statement : (List<ASTNode>) node.statements()) {
+      if (!first && !lastWasSwitchCase) {
+        builder.blankLineWanted(BlankLineWanted.PRESERVE);
+      }
       if (statement.getNodeType() == ASTNode.SWITCH_CASE) {
         builder.open(minusTwo);
         builder.forcedBreak();
         visit((SwitchCase) statement);
         builder.close();
+        lastWasSwitchCase = true;
       } else {
         builder.forcedBreak();
         statement.accept(this);
+        lastWasSwitchCase = false;
       }
+      first = false;
     }
     builder.close();
     builder.forcedBreak();
@@ -2133,9 +2172,16 @@ public final class JavaInputAstVisitor extends ASTVisitor {
       tokenBreakTrailingComment("{", plusTwo);
       if (allowLeadingBlankLine == AllowLeadingBlankLine.NO) {
         builder.blankLineWanted(BlankLineWanted.NO);
+      } else {
+        builder.blankLineWanted(BlankLineWanted.PRESERVE);
       }
+      boolean first = true;
       for (Statement statement : (List<Statement>) node.statements()) {
         builder.forcedBreak();
+        if (!first) {
+          builder.blankLineWanted(BlankLineWanted.PRESERVE);
+        }
+        first = false;
         markForPartialFormat();
         statement.accept(this);
       }
@@ -2144,6 +2190,8 @@ public final class JavaInputAstVisitor extends ASTVisitor {
       builder.close();
       if (allowTrailingBlankLine == AllowTrailingBlankLine.NO) {
         builder.blankLineWanted(BlankLineWanted.NO);
+      } else {
+        builder.blankLineWanted(BlankLineWanted.PRESERVE);
       }
       markForPartialFormat();
       token("}", plusTwo);
@@ -2615,7 +2663,7 @@ public final class JavaInputAstVisitor extends ASTVisitor {
   private void visitDotWithPrefix(List<Expression> items, boolean needDot, int prefixIndex) {
     // Are there method invocations or field accesses after the prefix?
     boolean trailingDereferences = prefixIndex >= 0 && prefixIndex < items.size() - 1;
-    
+
     builder.open(plusFour, MAX_LINES_FOR_CHAINED_ACCESSES);
     builder.open(trailingDereferences ? ZERO : ZERO);
 
@@ -2638,7 +2686,7 @@ public final class JavaInputAstVisitor extends ASTVisitor {
       if (prefixIndex >= 0 && i == prefixIndex) {
         builder.close();
       }
-      
+
       Indent tyargIndent = Indent.If.make(tyargTag, plusFour, ZERO);
       Indent argsIndent = Indent.If.make(nameTag, plusFour, trailingDereferences ? plusFour : ZERO);
       dotExpressionArgsAndParen(e, tyargIndent, argsIndent);
@@ -2909,15 +2957,19 @@ public final class JavaInputAstVisitor extends ASTVisitor {
     BreakTag typeBreak = genSym();
     BreakTag verticalAnnotationBreak = genSym();
 
+    EnumSet<DeclarationPosition> position = DeclarationPosition.getPositionInParent(node);
+
     // If the node is a field declaration, try to output any declaration
     // annotations in-line. If the entire declaration doesn't fit on a single
     // line, fall back to one-per-line.
-    boolean variableDeclarationAnnotations =
-        node.getNodeType() == ASTNode.FIELD_DECLARATION
-            && hasDeclarationAnnotations(modifiers);
+    boolean isField = node.getNodeType() == ASTNode.FIELD_DECLARATION;
 
-    if (variableDeclarationAnnotations) {
-      builder.blankLineWanted(BlankLineWanted.conditional(verticalAnnotationBreak));
+    if (isField) {
+      if (!position.contains(DeclarationPosition.FIRST)) {
+        builder.blankLineWanted(BlankLineWanted.conditional(verticalAnnotationBreak));
+      } else {
+        builder.blankLineWanted(BlankLineWanted.PRESERVE);
+      }
     }
 
     builder.open(ZERO);
@@ -2982,8 +3034,12 @@ public final class JavaInputAstVisitor extends ASTVisitor {
     }
     builder.close();
 
-    if (variableDeclarationAnnotations) {
-      builder.blankLineWanted(BlankLineWanted.conditional(verticalAnnotationBreak));
+    if (isField) {
+      if (!position.contains(DeclarationPosition.LAST)) {
+        builder.blankLineWanted(BlankLineWanted.conditional(verticalAnnotationBreak));
+      } else {
+        builder.blankLineWanted(BlankLineWanted.NO);
+      }
     }
   }
 
@@ -3135,19 +3191,6 @@ public final class JavaInputAstVisitor extends ASTVisitor {
     }
   }
 
-  /** Does a list of {@link IExtendedModifier}s contain annotations? */
-  private static boolean hasDeclarationAnnotations(List<IExtendedModifier> extendedModifiers) {
-    for (IExtendedModifier extendedModifier : extendedModifiers) {
-      if (extendedModifier.isModifier()) {
-        break;
-      }
-      if (extendedModifier.isAnnotation()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   // Use Eclipse token ID instead of position?
   /** Does this {@link BodyDeclaration} have JavaDoc preceding it? */
   private boolean hasJavaDoc(BodyDeclaration bodyDeclaration) {
diff --git a/core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java b/core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
index bc38e57..7ac0ff5 100644
--- a/core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
+++ b/core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
@@ -93,16 +93,6 @@ public final class JavaOutput extends Output {
     partialFormatBoundaries.add(k);
   }
 
-  @Override
-  public void forceBlankLine() {
-    // respect existing blank line suppressions to avoid inserting blanks for
-    // breaks at the start/end of a block, or beginning/end of a method
-    // declaration
-    if (!blankLines.containsKey(lastK)) {
-      blankLines.put(lastK, BlankLineWanted.YES);
-    }
-  }
-
   // TODO(jdd): Add invariant.
   @Override
   public void append(String text, Range<Integer> range) {
@@ -121,11 +111,10 @@ public final class JavaOutput extends Output {
       }
       /*
        * Output blank line if we've called {@link OpsBuilder#blankLine}{@code (true)} here, or if
-       * there's a blank line here and we haven't called {@link OpsBuilder#blankLine}{@code (false)}
-       * here, OR if it's a comment.
+       * there's a blank line here and it's a comment.
        */
-      BlankLineWanted wanted = blankLines.get(lastK);
-      if ((wanted == null || isComment(text)) ? sawNewlines : wanted.wanted().or(sawNewlines)) {
+      BlankLineWanted wanted = firstNonNull(blankLines.get(lastK), BlankLineWanted.NO);
+      if (isComment(text) ? sawNewlines : wanted.wanted().or(sawNewlines)) {
         ++newlinesPending;
       }
     }
diff --git a/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java b/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
index 73078e4..7504d73 100644
--- a/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
+++ b/core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
@@ -50,6 +50,7 @@ import java.util.TreeMap;
  */
 @RunWith(JUnit4.class)
 public final class FormatterTest {
+
   @Rule
   public TemporaryFolder testFolder = new TemporaryFolder();
 
@@ -147,16 +148,8 @@ public final class FormatterTest {
 
   @Test
   public void testFormatStdinStdoutWithDashFlag() throws Exception {
-    String input =
-        "class Foo{\n"
-        + "void f\n"
-        + "() {\n"
-        + "}\n"
-        + "}\n";
-    String expectedOutput =
-        "class Foo {\n"
-        + "  void f() {}\n"
-        + "}\n";
+    String input = "class Foo{\n" + "void f\n" + "() {\n" + "}\n" + "}\n";
+    String expectedOutput = "class Foo {\n" + "  void f() {}\n" + "}\n";
 
     InputStream in = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));
     StringWriter out = new StringWriter();
@@ -174,16 +167,8 @@ public final class FormatterTest {
 
   @Test
   public void testFormatLengthUpToEOF() throws Exception {
-    String input =
-        "class Foo{\n"
-        + "void f\n"
-        + "() {\n"
-        + "}\n"
-        + "}\n\n\n\n\n\n";
-    String expectedOutput =
-        "class Foo {\n"
-        + "  void f() {}\n"
-        + "}\n";
+    String input = "class Foo{\n" + "void f\n" + "() {\n" + "}\n" + "}\n\n\n\n\n\n";
+    String expectedOutput = "class Foo {\n" + "  void f() {}\n" + "}\n";
 
     Path tmpdir = testFolder.newFolder().toPath();
     Path path = tmpdir.resolve("Foo.java");
@@ -231,4 +216,36 @@ public final class FormatterTest {
     String expect = "package test;\n\nclass T {}\n";
     assertThat(output).isEqualTo(expect);
   }
+
+  @Test
+  public void docCommentTrailingBlank() throws FormatterException {
+    String input = "class T {\n/** asd */\n\nint x;\n}";
+    String output = new Formatter().formatSource(input);
+    String expect = "class T {\n  /** asd */\n  int x;\n}\n";
+    assertThat(output).isEqualTo(expect);
+  }
+
+  @Test
+  public void blockCommentTrailingBlank() throws FormatterException {
+    String input = "class T {\n/* asd */\n\nint x;\n}";
+    String output = new Formatter().formatSource(input);
+    String expect = "class T {\n  /* asd */\n\n  int x;\n}\n";
+    assertThat(output).isEqualTo(expect);
+  }
+
+  @Test
+  public void lineCommentTrailingBlank() throws FormatterException {
+    String input = "class T {\n// asd \n\nint x;\n}";
+    String output = new Formatter().formatSource(input);
+    String expect = "class T {\n  // asd\n\n  int x;\n}\n";
+    assertThat(output).isEqualTo(expect);
+  }
+  
+  @Test
+  public void noBlankAfterLineCommentWithInteriorBlankLine() throws FormatterException {
+    String input = "class T {\n// asd \n\n// dsa \nint x;\n}";
+    String output = new Formatter().formatSource(input);
+    String expect = "class T {\n  // asd\n\n  // dsa\n  int x;\n}\n";
+    assertThat(output).isEqualTo(expect);
+  }
 }
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20128588.output b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20128588.output
index bd6474c..a8f5cca 100644
--- a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20128588.output
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20128588.output
@@ -24,7 +24,9 @@ class Test {
   void f() {}
 
   @Foo @Bar @Baz static Object field;
+
   static @Foo @Bar @Baz Object field;
+
   @Foo @Bar @Baz Object field;
 
   @Foo(xs = 42)
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20577626.output b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20577626.output
index 8ee0a38..bc3df14 100644
--- a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20577626.output
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B20577626.output
@@ -1,5 +1,6 @@
 class B20577626 {
   private @Mock GsaConfigFlags mGsaConfig;
+
   @Foo @Bar private @Mock GsaConfigFlags mGsaConfig;
 
   @Foo
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.input b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.input
new file mode 100644
index 0000000..631f076
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.input
@@ -0,0 +1,54 @@
+class B24702438 {
+
+  @Inject int x;
+
+  @Inject int y;
+
+  @Inject int z;
+
+  @Inject int x;
+  @Inject int y;
+  @Inject int z;
+
+  // this is a comment
+
+  // another comment
+  int x;
+
+  // another comment
+
+  int y;
+
+  {
+    switch (x) {
+
+      case 1:
+
+        break;
+
+      case 1:
+
+        break;
+
+      default:
+
+        break;
+
+    }
+
+    // this is a comment
+
+    // another comment
+    System.err.println("asd");
+  }
+
+  void f(
+      int a,
+      @Nullable @Deprecated ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      int c) {}
+  void g(
+      @Nullable @Deprecated ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated ImmutableList<String> veryVeryLoooooooooooooooooooooooooooooooooooooooooooooooooooooooong) {}
+}
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.output b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.output
new file mode 100644
index 0000000..8ffcdc2
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/B24702438.output
@@ -0,0 +1,55 @@
+class B24702438 {
+
+  @Inject int x;
+
+  @Inject int y;
+
+  @Inject int z;
+
+  @Inject int x;
+  @Inject int y;
+  @Inject int z;
+
+  // this is a comment
+
+  // another comment
+  int x;
+
+  // another comment
+
+  int y;
+
+  {
+    switch (x) {
+      case 1:
+        break;
+
+      case 1:
+        break;
+
+      default:
+        break;
+    }
+
+    // this is a comment
+
+    // another comment
+    System.err.println("asd");
+  }
+
+  void f(
+      int a,
+      @Nullable @Deprecated
+      ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated
+      ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated
+      ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      int c) {}
+
+  void g(
+      @Nullable @Deprecated
+      ImmutableList<String> veryVeryLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong,
+      @Nullable @Deprecated
+      ImmutableList<String> veryVeryLoooooooooooooooooooooooooooooooooooooooooooooooooooooooong) {}
+}
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.input b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.input
new file mode 100644
index 0000000..5d8a058
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.input
@@ -0,0 +1,19 @@
+public class Test {
+
+
+
+}
+
+public class Test {
+
+
+}
+
+public class Test {
+
+}
+
+public class Test {
+}
+
+public class Test {}
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.output b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.output
new file mode 100644
index 0000000..0b72fab
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I12.output
@@ -0,0 +1,9 @@
+public class Test {}
+
+public class Test {}
+
+public class Test {}
+
+public class Test {}
+
+public class Test {}
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.input b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.input
new file mode 100644
index 0000000..079e78b
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.input
@@ -0,0 +1,10 @@
+class I13 {
+
+  @Nullable
+
+  public int f;
+
+  @Override
+
+  public void m() {}
+}
diff --git a/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.output b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.output
new file mode 100644
index 0000000..b902fe6
--- /dev/null
+++ b/core/src/test/resources/com/google/googlejavaformat/java/testdata/I13.output
@@ -0,0 +1,7 @@
+class I13 {
+
+  @Nullable public int f;
+
+  @Override
+  public void m() {}
+}
