{"url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110","repository_url":"https://api.github.com/repos/sidekiq/sidekiq","labels_url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110/labels{/name}","comments_url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110/comments","events_url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110/events","html_url":"https://github.com/sidekiq/sidekiq/issues/110","id":3941662,"node_id":"MDU6SXNzdWUzOTQxNjYy","number":110,"title":"Sidekiq::Manager loses long-running jobs on exit","user":{"login":"Burgestrand","id":99166,"node_id":"MDQ6VXNlcjk5MTY2","avatar_url":"https://avatars.githubusercontent.com/u/99166?v=4","gravatar_id":"","url":"https://api.github.com/users/Burgestrand","html_url":"https://github.com/Burgestrand","followers_url":"https://api.github.com/users/Burgestrand/followers","following_url":"https://api.github.com/users/Burgestrand/following{/other_user}","gists_url":"https://api.github.com/users/Burgestrand/gists{/gist_id}","starred_url":"https://api.github.com/users/Burgestrand/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Burgestrand/subscriptions","organizations_url":"https://api.github.com/users/Burgestrand/orgs","repos_url":"https://api.github.com/users/Burgestrand/repos","events_url":"https://api.github.com/users/Burgestrand/events{/privacy}","received_events_url":"https://api.github.com/users/Burgestrand/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2012-04-03T09:28:32Z","updated_at":"2012-04-07T14:11:37Z","closed_at":"2012-04-07T03:53:18Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"When requesting Sidekiq to stop when running the Sidekiq CLI, it’ll [tell the manager to stop](https://github.com/mperham/sidekiq/blob/2e58b1d9d8f3f06ec8d2499238121fc2ec6b1ed6/lib/sidekiq/cli.rb#L68). This in turn will make the manager stop accepting new jobs, and if there are any currently running jobs it will wait for five seconds before [trying to terminate the running jobs](https://github.com/mperham/sidekiq/blob/2e58b1d9d8f3f06ec8d2499238121fc2ec6b1ed6/lib/sidekiq/manager.rb#L61).\n\nHowever, if the jobs are doing some kind of blocking (but interruptible) operation, the currently busy workers won’t be terminated. The reason for this is that Celluloid, on terminate, just adds a message to the workers’ mailbox which will only be picked up after the current job has been processed.\n\nTo demonstrate this issue, one could create a job that just sleeps forever.\n\n``` ruby\nclass SleepyWorker\n  include Sidekiq::Worker\n\n  def perform\n    sleep\n  end\nend\n```\n\nAfter queuing this worker Sidekiq’ll run it. However, when requesting Sidekiq to exit (say, by sending a TERM signal to it, like Heroku does), this job won’t ever be killed. The result is that Sidekiq waits forever for this job to finish (because it’s using the synchronous version of `terminate`), and never terminates cleanly.\n\nOn Heroku this is a huge issue, because it means that if you have any kind of job that is long-running (which is the main reason for using workers in the first place) it will never be terminated by Sidekiq. After ten seconds Heroku will SIGKILL Sidekiq, and the job is lost forever with no trace. This can happen for any restart, redeploy, config change or any kind of action that requires a restart of the workers.\n\nEssentially, this issue is more a result of Sidekiq not being able to handle getting killed by a SIGKILL.\n\nI currently don’t have a good solution to this issue. What we’ve done, where we use Sidekiq, is add a middleware that intercepts the shutdown signals (TERM and INT) and raises an error in the currently running worker when it is running. After that it’ll run Sidekiqs’ own handlers so it can shut itself down as well.\n\nFor completeness, I’ve gisted our current solution (that I’m not entirely happy with, it is a bit of a hack as it still does not resolve the issue of sudden SIGKILL or even power failure): https://gist.github.com/2290629\n\nI’m thinking a solution to this would be to add jobs that are currently running (but not yet complete) to some kind of list of running jobs. When Sidekiq starts up it can inspect this list and re-queue the jobs that never finished. One needs to take extra care to finish jobs that exited with an error (as opposed to never finished at all). This operation (moving the job to the \"currently running\"-queue) would have to be atomic to protect against Sidekiq getting killed between pulling the job and securing it. One also needs to secure against using multiple workers, so they don’t re-queue some other workers’ jobs while they are actually running the job.\n","closed_by":{"login":"mperham","id":2911,"node_id":"MDQ6VXNlcjI5MTE=","avatar_url":"https://avatars.githubusercontent.com/u/2911?v=4","gravatar_id":"","url":"https://api.github.com/users/mperham","html_url":"https://github.com/mperham","followers_url":"https://api.github.com/users/mperham/followers","following_url":"https://api.github.com/users/mperham/following{/other_user}","gists_url":"https://api.github.com/users/mperham/gists{/gist_id}","starred_url":"https://api.github.com/users/mperham/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mperham/subscriptions","organizations_url":"https://api.github.com/users/mperham/orgs","repos_url":"https://api.github.com/users/mperham/repos","events_url":"https://api.github.com/users/mperham/events{/privacy}","received_events_url":"https://api.github.com/users/mperham/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sidekiq/sidekiq/issues/110/timeline","performed_via_github_app":null,"state_reason":"completed"}