diff --git a/Changes.md b/Changes.md
index f07288d1..690b1f4f 100644
--- a/Changes.md
+++ b/Changes.md
@@ -2,6 +2,11 @@
 
 [Sidekiq Changes](https://github.com/sidekiq/sidekiq/blob/main/Changes.md) | [Sidekiq Pro Changes](https://github.com/sidekiq/sidekiq/blob/main/Pro-Changes.md) | [Sidekiq Enterprise Changes](https://github.com/sidekiq/sidekiq/blob/main/Ent-Changes.md)
 
+HEAD
+----------
+
+- Fix issue with the `batch_size` and `at` options in `S::Client.push_bulk` [#6040]
+
 7.1.4
 ----------
 
diff --git a/lib/sidekiq/client.rb b/lib/sidekiq/client.rb
index 35190ae0..bf167cec 100644
--- a/lib/sidekiq/client.rb
+++ b/lib/sidekiq/client.rb
@@ -124,19 +124,21 @@ module Sidekiq
       raise ArgumentError, "Explicitly passing 'jid' when pushing more than one job is not supported" if jid && args.size > 1
 
       normed = normalize_item(items)
+      slice_index = 0
       result = args.each_slice(batch_size).flat_map do |slice|
         raise ArgumentError, "Bulk arguments must be an Array of Arrays: [[1], [2]]" unless slice.is_a?(Array) && slice.all?(Array)
         break [] if slice.empty? # no jobs to push
 
         payloads = slice.map.with_index { |job_args, index|
           copy = normed.merge("args" => job_args, "jid" => SecureRandom.hex(12))
-          copy["at"] = (at.is_a?(Array) ? at[index] : at) if at
+          copy["at"] = (at.is_a?(Array) ? at[slice_index + index] : at) if at
           result = middleware.invoke(items["class"], copy, copy["queue"], @redis_pool) do
             verify_json(copy)
             copy
           end
           result || nil
         }
+        slice_index += batch_size
 
         to_push = payloads.compact
         raw_push(to_push) unless to_push.empty?
diff --git a/test/client_test.rb b/test/client_test.rb
index 8d6ecd27..2b1646be 100644
--- a/test/client_test.rb
+++ b/test/client_test.rb
@@ -558,4 +558,17 @@ describe Sidekiq::Client do
       end
     end
   end
+
+  it "can specify different times when there are more jobs than the batch size" do
+    job_count = 5
+    times = job_count.times.map { |i| Time.new(2019, 1, i + 1).utc }
+    args = job_count.times.map { |i| [i] }
+    # When there are 3 jobs, we want to use `times[2]` for the final job.
+    batch_size = 2
+
+    jids = Sidekiq::Client.push_bulk("class" => QueuedJob, "args" => args, "at" => times.map(&:to_f), :batch_size => batch_size)
+
+    assert_equal job_count, jids.size
+    assert_equal times, jids.map { |jid| Sidekiq::ScheduledSet.new.find_job(jid).at }
+  end
 end
