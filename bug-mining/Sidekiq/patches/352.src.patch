diff --git a/Changes.md b/Changes.md
index b9b2ac47..3b4fb876 100644
--- a/Changes.md
+++ b/Changes.md
@@ -5,6 +5,7 @@
 HEAD
 ----------
 
+- Job iteration now exposes `current_object` for easy access within the `around_iteration` callback [#6774]
 - Fix JS race condition which could skip confirmation dialogs when Live Polling [#6768]
 - Fix edge case which could lose CurrentAttributes [#6767]
 
diff --git a/lib/sidekiq/job/iterable.rb b/lib/sidekiq/job/iterable.rb
index ce59a086..a0d0aa1b 100644
--- a/lib/sidekiq/job/iterable.rb
+++ b/lib/sidekiq/job/iterable.rb
@@ -32,8 +32,14 @@ module Sidekiq
         @_runtime = 0
         @_args = nil
         @_cancelled = nil
+        @current_object = nil
       end
 
+      # Access to the current object while iterating.
+      # This value is not reset so the latest element is
+      # explicitly available to cleanup/complete callbacks.
+      attr_reader :current_object
+
       def arguments
         @_args
       end
@@ -203,6 +209,7 @@ module Sidekiq
         enumerator.each do |object, cursor|
           found_record = true
           @_cursor = cursor
+          @current_object = object
 
           is_interrupted = interrupted?
           if ::Process.clock_gettime(::Process::CLOCK_MONOTONIC) - state_flushed_at >= STATE_FLUSH_INTERVAL || is_interrupted
diff --git a/test/iterable/iterable_jobs.rb b/test/iterable/iterable_jobs.rb
index f1cbce0b..70835e7c 100644
--- a/test/iterable/iterable_jobs.rb
+++ b/test/iterable/iterable_jobs.rb
@@ -165,7 +165,7 @@ end
 class DynamicCallbackJob < IterableJobWithArguments
   CB = {}
 
-  %w[on_start on_complete on_stop on_resume].each do |cb|
+  %w[on_start on_complete on_stop on_resume around_iteration].each do |cb|
     name = cb.to_sym
     CB[name] = []
     define_method(name) do
@@ -177,6 +177,7 @@ class DynamicCallbackJob < IterableJobWithArguments
     CB[:on_stop] = []
     CB[:on_resume] = []
     CB[:on_complete] = []
+    CB[:around_iteration] = []
   end
 end
 
diff --git a/test/iterable/iterable_test.rb b/test/iterable/iterable_test.rb
index 614f0799..fa7388a8 100644
--- a/test/iterable/iterable_test.rb
+++ b/test/iterable/iterable_test.rb
@@ -297,15 +297,15 @@ describe Sidekiq::Job::Iterable do
 
   describe "job arguments" do
     it "are available to all callbacks" do
-      $args = {}
+      args = {}
       DynamicCallbackJob.reset
-      DynamicCallbackJob::CB[:on_stop] << -> { $args[:on_stop] = arguments }
-      DynamicCallbackJob::CB[:on_start] << -> { $args[:on_start] = arguments }
-      DynamicCallbackJob::CB[:on_complete] << -> { $args[:on_complete] = arguments }
-      DynamicCallbackJob::CB[:on_resume] << -> { $args[:on_resume] = arguments }
+      DynamicCallbackJob::CB[:on_stop] << -> { args[:on_stop] = arguments }
+      DynamicCallbackJob::CB[:on_start] << -> { args[:on_start] = arguments }
+      DynamicCallbackJob::CB[:on_complete] << -> { args[:on_complete] = arguments }
+      DynamicCallbackJob::CB[:on_resume] << -> { args[:on_resume] = arguments }
 
       DynamicCallbackJob.perform_inline("mike", 123)
-      assert_equal($args, {on_start: ["mike", 123], on_stop: ["mike", 123], on_complete: ["mike", 123]})
+      assert_equal(args, {on_start: ["mike", 123], on_stop: ["mike", 123], on_complete: ["mike", 123]})
     end
 
     it "are frozen" do
@@ -316,12 +316,20 @@ describe Sidekiq::Job::Iterable do
       end
     end
 
+    it "provides current_object to around_iteration" do
+      objects = []
+      DynamicCallbackJob.reset
+      DynamicCallbackJob::CB[:around_iteration] << -> { objects << current_object }
+      DynamicCallbackJob.perform_inline("mike", 123)
+      assert_equal [0, 1], objects
+    end
+
     it "mangles keyword arguments, per JSON" do
-      $args = {}
+      args = {}
       DynamicCallbackJob.reset
-      DynamicCallbackJob::CB[:on_start] << -> { $args[:on_start] = arguments }
+      DynamicCallbackJob::CB[:on_start] << -> { args[:on_start] = arguments }
       DynamicCallbackJob.perform_inline("first", mike: 456, bob: "string")
-      assert_equal($args, {on_start: ["first", {"mike" => 456, "bob" => "string"}]})
+      assert_equal(args, {on_start: ["first", {"mike" => 456, "bob" => "string"}]})
     end
   end
 
