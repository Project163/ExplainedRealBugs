diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 3f7312503..2b70a8bc2 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -276,6 +276,10 @@
       Use of final keyword where applicable, minor performance improvements by properly
       initializing the capacity of newly created collections when known in advance.
     </action>
+    <action issue="COLLECTIONS-307" dev="tn" type="update" due-to="Christian Semrau, Thomas Vahrst">
+      "SetUniqueList#subList()" will now return an unmodifiable list as changes to it
+      may invalidate the parent list.
+    </action>
     <action issue="COLLECTIONS-307" dev="bayard" type="fix" due-to="Christian Semrau">
       "SetUniqueList#subList()#contains(Object)" will now correctly check the subList
       rather than the parent list.
diff --git a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
index 47dc76de7..f7f04b2dc 100644
--- a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
+++ b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
@@ -24,6 +24,7 @@ import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
+import org.apache.commons.collections4.ListUtils;
 import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;
 import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;
@@ -319,11 +320,17 @@ public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {
         return new SetListListIterator<E>(super.listIterator(index), set);
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the
+     * subList can invalidate the parent list. 
+     */
     @Override
     public List<E> subList(final int fromIndex, final int toIndex) {
         final List<E> superSubList = super.subList(fromIndex, toIndex);
         final Set<E> subSet = createSetBasedOnList(set, superSubList);
-        return new SetUniqueList<E>(superSubList, subSet);
+        return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet));
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java b/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java
index 4c818f9dd..bbe546ed8 100644
--- a/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java
+++ b/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java
@@ -43,6 +43,7 @@ public class SetUniqueListTest<E> extends AbstractListTest<E> {
         return new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());
     }
 
+    //-----------------------------------------------------------------------
     @Override
     public void testListIteratorSet() {
         // override to block
@@ -461,6 +462,16 @@ public class SetUniqueListTest<E> extends AbstractListTest<E> {
         assertEquals(4, decoratedList.size());
     }
 
+    public void testSubListIsUnmodifiable() {
+        resetFull();
+        List<E> subList = getCollection().subList(1, 3);
+        try {
+            subList.remove(0);
+            fail("subList should be unmodifiable");
+        } catch (UnsupportedOperationException e) {
+            // expected
+        }
+    }
     @SuppressWarnings("unchecked")
     public void testCollections307() {
         List<E> list = new ArrayList<E>();
