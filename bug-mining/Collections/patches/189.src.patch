diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
index 1848e99fa..a86afa1f3 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
@@ -187,9 +187,6 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {
      * <p>Specifically all counts for the unique indices produced by the {@code hasher} will be
      * decremented by 1.</p>
      *
-     * <p>For HasherCollections each enclosed Hasher will be considered a single item and decremented
-     * from the counts separately.</p>
-     *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
      * @param hasher the hasher to provide the indexes
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java
deleted file mode 100644
index 337d03893..000000000
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Objects;
-import java.util.function.IntPredicate;
-
-/**
- * A collection of Hashers. Useful when the generation of a Bloom filter depends upon
- * multiple items.
- * <p>
- * Hashers for each item are added to the HasherCollection and then
- * the collection is used wherever a Hasher can be used in the API.
- * </p>
- * @since 4.5
- */
-public class HasherCollection implements Hasher {
-
-    /**
-     * The list of hashers to be used to generate the indices.
-     */
-    private final List<Hasher> hashers;
-
-    /**
-     * Constructs an empty HasherCollection.
-     */
-    public HasherCollection() {
-        this.hashers = new ArrayList<>();
-    }
-
-    /**
-     * Constructs a HasherCollection from a collection of Hasher objects.
-     *
-     * @param hashers A collections of Hashers to build the indices with.
-     */
-    public HasherCollection(final Collection<Hasher> hashers) {
-        Objects.requireNonNull(hashers, "hashers");
-        this.hashers = new ArrayList<>(hashers);
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param hashers A list of Hashers to initialize the collection with.
-     */
-    public HasherCollection(final Hasher... hashers) {
-        this(Arrays.asList(hashers));
-    }
-
-    /**
-     * Adds a hasher to the collection.
-     * @param hasher The hasher to add.
-     */
-    public void add(final Hasher hasher) {
-        Objects.requireNonNull(hasher, "hasher");
-        hashers.add(hasher);
-    }
-
-    /**
-     * Add all the Hashers in a collection to this HasherCollection.
-     * @param hashers The hashers to add.
-     */
-    public void add(final Collection<Hasher> hashers) {
-        Objects.requireNonNull(hashers, "hashers");
-        this.hashers.addAll(hashers);
-    }
-
-    @Override
-    public IndexProducer indices(final Shape shape) {
-        Objects.requireNonNull(shape, "shape");
-        return new HasherCollectionIndexProducer(shape);
-    }
-
-    /**
-     * Creates an IndexProducer comprising the unique indices from each of the contained
-     * hashers.
-     *
-     * <p>This method may return duplicates if the collection of unique values from each of the contained
-     * hashers contain duplicates. This is equivalent to creating Bloom filters for each contained hasher
-     * and returning an IndexProducer with the concatenated output indices from each filter.</p>
-     *
-     * <p>A BitCountProducer generated from this IndexProducer is equivalent to a BitCountProducer from a
-     * counting Bloom filter that was constructed from the contained hashers unique indices.<p>
-     *
-     * @param shape the shape of the desired Bloom filter.
-     * @return the iterator of integers
-     */
-    @Override
-    public IndexProducer uniqueIndices(final Shape shape) {
-        Objects.requireNonNull(shape, "shape");
-        return new HasherCollectionIndexProducer(shape) {
-            @Override
-            public boolean forEachIndex(final IntPredicate consumer) {
-                for (final Hasher hasher : hashers) {
-                    if (!hasher.uniqueIndices(shape).forEachIndex(consumer)) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        };
-    }
-
-    /**
-     * Creates an IndexProducer comprising the unique indices across all the contained
-     * hashers.
-     *
-     * <p>This is equivalent to an IndexProducer created from a Bloom filter that comprises all
-     * the contained hashers.</p>
-     *
-     * @param shape the shape of the desired Bloom filter.
-     * @return the iterator of integers
-     */
-    public IndexProducer absoluteUniqueIndices(final Shape shape) {
-        final int kCount = hashers.size() > 0 ? hashers.size() : 1;
-        return consumer -> {
-            Objects.requireNonNull(consumer, "consumer");
-            // shape must handle maximum unique indices
-            return uniqueIndices(shape).forEachIndex(IndexFilter.create(
-                    Shape.fromKM(shape.getNumberOfHashFunctions() * kCount,
-                                 shape.getNumberOfBits()), consumer));
-        };
-    }
-
-    /**
-     * Allow child classes access to the hashers.
-     * @return hashers
-     */
-    protected List<Hasher> getHashers() {
-        return Collections.unmodifiableList(hashers);
-    }
-
-    /**
-     * IndexProducer that will return duplicates from the collection.
-     */
-    private class HasherCollectionIndexProducer implements IndexProducer {
-        private final Shape shape;
-
-        /**
-         * Create an instance.
-         *
-         * @param shape The shape for the filter.
-         */
-        HasherCollectionIndexProducer(final Shape shape) {
-            this.shape = shape;
-        }
-
-        @Override
-        public boolean forEachIndex(final IntPredicate consumer) {
-            for (final Hasher hasher : hashers) {
-                if (!hasher.indices(shape).forEachIndex(consumer)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        @Override
-        public int[] asIndexArray() {
-            final int[] result = new int[shape.getNumberOfHashFunctions() * hashers.size()];
-            final int[] idx = new int[1];
-
-            // This method needs to return duplicate indices
-
-            forEachIndex(i -> {
-                result[idx[0]++] = i;
-                return true;
-            });
-            return Arrays.copyOf(result, idx[0]);
-        }
-    }
-}
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
index a8d18c8c2..a7fb00954 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
@@ -79,9 +79,8 @@
  *
  * <h3>Hasher</h3>
  *
- * <p>A Hasher converts bytes into a series of integers based on a Shape. With the exception of the HasherCollecton,
- * each hasher represents one item being added to the Bloom filter. The HasherCollection represents the number of
- * items as the sum of the number of items represented by the Hashers in the collection.</p>
+ * <p>A Hasher converts bytes into a series of integers based on a Shape. Each hasher represents one item being added
+ * to the Bloom filter.</p>
  *
  * <p>The EnhancedDoubleHasher uses a combinatorial generation technique to create the integers. It is easily
  * initialized by using a byte array returned by the standard {@code MessageDigest} or other hash function to
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
index d44ed9d59..e525aca8b 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
@@ -34,18 +34,6 @@ import org.junit.jupiter.api.Test;
  */
 public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
 
-    protected final Hasher from1 = new IncrementingHasher(1, 1);
-    protected final long from1Value = 0x3fffeL;
-    protected final Hasher from11 = new IncrementingHasher(11, 1);
-    protected final long from11Value = 0xffff800L;
-    protected final HasherCollection bigHasher = new HasherCollection(from1, from11);
-    protected final long bigHashValue = 0xffffffeL;
-    protected final HasherCollection fullHasher = new HasherCollection(new IncrementingHasher(0, 1)/* 0-16 */,
-            new IncrementingHasher(17, 1)/* 17-33 */, new IncrementingHasher(33, 1)/* 33-49 */, new IncrementingHasher(50, 1)/* 50-66 */,
-            new IncrementingHasher(67, 1)/* 67-83 */
-    );
-    protected final long[] fullHashValue = {0xffffffffffffffffL, 0xfffffL};
-
     /**
      * The shape of the Bloom filters for testing.
      * <ul>
@@ -182,8 +170,8 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
 
     @Test
     public final void testContains() {
-        BloomFilter bf1 = createFilter(getTestShape(), from1);
-        final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
+        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));
 
         assertTrue(bf1.contains(bf1), "BF Should contain itself");
         assertTrue(bf2.contains(bf2), "BF2 Should contain itself");
@@ -206,21 +194,21 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
         assertFalse(bf2.contains(bitMapProducer), "BF2 Should not contain this hasher");
 
         // Test different lengths
-        bf1 = createFilter(getTestShape(), from1);
+        bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
         final BloomFilter bf3 = createFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1),
-                from1);
+                TestingHashers.FROM1);
         assertTrue(bf1.contains(bf3));
         assertTrue(bf3.contains(bf1));
 
-        final BloomFilter bf4 = createFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1),
-                bigHasher);
+        final BloomFilter bf4 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1)));
+
         assertFalse(bf1.contains(bf4));
         assertTrue(bf4.contains(bf1));
     }
 
     @Test
     public void testClear() {
-        final BloomFilter bf1 = createFilter(getTestShape(), from1);
+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
         assertNotEquals(0, bf1.cardinality());
         bf1.clear();
         assertEquals(0, bf1.cardinality());
@@ -232,8 +220,9 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
     @Test
     public final void testEstimateIntersection() {
 
-        final BloomFilter bf = createFilter(getTestShape(), from1);
-        final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
+        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));
+
 
         assertEquals(1, bf.estimateIntersection(bf2));
         assertEquals(1, bf2.estimateIntersection(bf));
@@ -249,8 +238,8 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
      */
     @Test
     public final void testEstimateUnion() {
-        final BloomFilter bf = createFilter(getTestShape(), from1);
-        final BloomFilter bf2 = createFilter(getTestShape(), from11);
+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
+        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);
 
         assertEquals(2, bf.estimateUnion(bf2));
         assertEquals(2, bf2.estimateUnion(bf));
@@ -267,7 +256,7 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
     @Test
     public final void testEstimateN() {
         // build a filter
-        final BloomFilter filter1 = createFilter(getTestShape(), from1);
+        final BloomFilter filter1 = createFilter(getTestShape(), TestingHashers.FROM1);
         assertEquals(1, filter1.estimateN());
 
         // the data provided above do not generate an estimate that is equivalent to the
@@ -306,7 +295,7 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
         BloomFilter filter = createEmptyFilter(getTestShape());
         assertFalse(filter.isFull(), "Should not be full");
 
-        filter = createFilter(getTestShape(), fullHasher);
+        filter = TestingHashers.populateEntireFilter(filter);
         assertTrue(filter.isFull(), "Should be full");
 
         filter = createFilter(getTestShape(), new IncrementingHasher(1, 3));
@@ -319,8 +308,8 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
     @Test
     public final void testMerge() {
 
-        final BloomFilter bf1 = createFilter(getTestShape(), from1);
-        final BloomFilter bf2 = createFilter(getTestShape(), from11);
+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
+        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);
         final BloomFilter bf3 = bf1.copy();
         bf3.merge(bf2);
 
@@ -343,8 +332,8 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
 
         // test with hasher
 
-        final BloomFilter bf4 = createFilter(getTestShape(), from1);
-        bf4.merge(from11);
+        final BloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf4.merge(TestingHashers.FROM11);
 
         assertTrue(bf4.contains(bf2), "Should contain Bf2");
         assertTrue(bf4.contains(bf3), "Should contain Bf3");
@@ -403,7 +392,7 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
     @Test
     public void testBitMapProducerSize() {
         final int[] idx = new int[1];
-        createFilter(getTestShape(), from1).forEachBitMap(i -> {
+        createFilter(getTestShape(), TestingHashers.FROM1).forEachBitMap(i -> {
             idx[0]++;
             return true;
         });
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
index d90a13769..d2892f492 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
@@ -31,12 +31,14 @@ import org.junit.jupiter.api.Test;
  */
 public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFilter>
         extends AbstractBloomFilterTest<T> {
-    protected int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};
-    protected int[] from11Counts = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-        0};
-    protected int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+
+    private static final int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+    private static final int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
         1, 0};
 
+    private static final long bigHashValue = 0xffffffeL;
+
     protected final BitCountProducer maximumValueProducer = consumer -> {
         for (int i = 1; i < 18; i++) {
             if (!consumer.test(i, Integer.MAX_VALUE)) {
@@ -79,8 +81,8 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
     public final void testCountingSpecificConstructor() {
         // verify hasher duplicates are counted.
         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17
-        final CountingBloomFilter bf = createFilter(getTestShape(), from1);
-        bf.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         final long[] lb = bf.asBitMapArray();
         assertEquals(2, lb.length);
@@ -92,8 +94,8 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
     @Test
     public final void testCountingBloomFilterSpecificContains() {
         final BloomFilter bf = new SimpleBloomFilter(getTestShape());
-        bf.merge(from1);
-        final CountingBloomFilter bf2 = createFilter(getTestShape(), bigHasher);
+        bf.merge(TestingHashers.FROM1);
+        final CountingBloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11( createEmptyFilter(getTestShape()));
 
         assertTrue(bf.contains(bf), "BF Should contain itself");
         assertTrue(bf2.contains(bf2), "BF2 Should contain itself");
@@ -108,10 +110,10 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
      */
     @Test
     public final void testCountingSpecificMerge() {
-        final BloomFilter bf1 = createFilter(getTestShape(), from1);
+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
 
         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());
-        bf2.merge(from11);
+        bf2.merge(TestingHashers.FROM11);
 
         final BloomFilter bf3 = bf1.copy();
         bf3.merge(bf2);
@@ -133,7 +135,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
 
         final CountingBloomFilter bf6 = bf5.copy();
         final BloomFilter bf7 = new SimpleBloomFilter(getTestShape());
-        bf7.merge(from1);
+        bf7.merge(TestingHashers.FROM1);
         bf6.merge(bf7);
         assertFalse(bf6.isValid(), "Should not be valid");
     }
@@ -144,10 +146,10 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
      */
     @Test
     public void testAdd() {
-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);
-        assertTrue(bf1.add(createFilter(getTestShape(), from11)), "Add should work");
-        assertTrue(bf1.contains(from1), "Should contain");
-        assertTrue(bf1.contains(from11), "Should contain");
+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
+        assertTrue(bf1.add(createFilter(getTestShape(), TestingHashers.FROM11)), "Add should work");
+        assertTrue(bf1.contains(TestingHashers.FROM1), "Should contain");
+        assertTrue(bf1.contains(TestingHashers.FROM11), "Should contain");
         assertCounts(bf1, bigHashCounts);
 
         // test overflow
@@ -156,7 +158,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
         assertTrue(bf2.add(maximumValueProducer), "Should add to empty");
         assertTrue(bf2.isValid(), "Should be valid");
 
-        assertFalse(bf2.add(createFilter(getTestShape(), from1)), "Should not add");
+        assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), "Should not add");
         assertFalse(bf2.isValid(), "Should not be valid");
     }
 
@@ -166,25 +168,25 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
      */
     @Test
     public final void testSubtract() {
-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);
-        bf1.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
-        final CountingBloomFilter bf2 = createFilter(getTestShape(), from11);
+        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);
 
         assertTrue(bf1.subtract(bf2), "Subtract should work");
-        assertFalse(bf1.contains(bigHasher), "Should not contain bitHasher");
-        assertTrue(bf1.contains(from1), "Should contain from1");
+        assertFalse(bf1.contains( TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape()))), "Should not contain bitHasher");
+        assertTrue(bf1.contains(TestingHashers.FROM1), "Should contain TestingHashers.from1");
 
         assertCounts(bf1, from1Counts);
 
         // test underflow
-        final CountingBloomFilter bf3 = createFilter(getTestShape(), from1);
+        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);
 
-        final CountingBloomFilter bf4 = createFilter(getTestShape(), from11);
+        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM11);
 
         assertFalse(bf3.subtract(bf4), "Subtract should not work");
         assertFalse(bf3.isValid(), "isValid should return false");
-        assertFalse(bf3.contains(from1), "Should not contain");
+        assertFalse(bf3.contains(TestingHashers.FROM1), "Should not contain");
         assertFalse(bf3.contains(bf4), "Should not contain");
 
         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0});
@@ -197,65 +199,65 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
     @Test
     public final void testRemove() {
         final BloomFilter simple = new SimpleBloomFilter(getTestShape());
-        simple.merge(from11);
+        simple.merge(TestingHashers.FROM11);
 
-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);
-        bf1.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf1.remove(simple), "Remove should work");
-        assertFalse(bf1.contains(from11), "Should not contain");
-        assertTrue(bf1.contains(from1), "Should contain");
+        assertFalse(bf1.contains(TestingHashers.FROM11), "Should not contain");
+        assertTrue(bf1.contains(TestingHashers.FROM1), "Should contain");
 
         assertCounts(bf1, from1Counts);
 
         // with hasher
-        final CountingBloomFilter bf2 = createFilter(getTestShape(), from1);
-        bf2.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf2.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
-        assertTrue(bf2.remove(from11), "Remove should work");
-        assertFalse(bf2.contains(from11), "Should not contain");
-        assertTrue(bf2.contains(from1), "Should contain");
+        assertTrue(bf2.remove(TestingHashers.FROM11), "Remove should work");
+        assertFalse(bf2.contains(TestingHashers.FROM11), "Should not contain");
+        assertTrue(bf2.contains(TestingHashers.FROM1), "Should contain");
 
         assertCounts(bf2, from1Counts);
 
         // test underflow
-        final CountingBloomFilter bf3 = createFilter(getTestShape(), from1);
+        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);
         assertFalse(bf3.remove(simple), "Subtract should not work");
         assertFalse(bf3.isValid(), "isValid should return false");
-        assertFalse(bf3.contains(from1), "Should not contain");
+        assertFalse(bf3.contains(TestingHashers.FROM1), "Should not contain");
         assertFalse(bf3.contains(simple), "Should not contain");
 
         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1});
 
         // with IndexProducer
-        final IndexProducer ip = from11.indices(getTestShape());
+        final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());
 
-        final CountingBloomFilter bf4 = createFilter(getTestShape(), from1);
-        bf4.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf4.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf4.remove(ip), "Remove should work");
-        assertFalse(bf4.contains(from11), "Should not contain");
-        assertTrue(bf4.contains(from1), "Should contain");
+        assertFalse(bf4.contains(TestingHashers.FROM11), "Should not contain");
+        assertTrue(bf4.contains(TestingHashers.FROM1), "Should contain");
 
         assertCounts(bf4, from1Counts);
 
         // with BitMapProducer
         final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());
-        final CountingBloomFilter bf5 = createFilter(getTestShape(), from1);
-        bf5.add(BitCountProducer.from(from11.indices(getTestShape())));
+        final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);
+        bf5.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf5.remove(bmp), "Remove should work");
-        assertFalse(bf5.contains(from11), "Should not contain");
-        assertTrue(bf5.contains(from1), "Should contain");
+        assertFalse(bf5.contains(TestingHashers.FROM11), "Should not contain");
+        assertTrue(bf5.contains(TestingHashers.FROM1), "Should contain");
 
         assertCounts(bf5, from1Counts);
 
         // test producer errors
         final IndexProducer ip2 = IndexProducer.fromIndexArray(1, 2, getTestShape().getNumberOfBits());
-        final CountingBloomFilter bf6 = createFilter(getTestShape(), from1);
+        final CountingBloomFilter bf6 = createFilter(getTestShape(), TestingHashers.FROM1);
         assertThrows(IllegalArgumentException.class, () -> bf6.remove(ip2));
 
-        final CountingBloomFilter bf7 = createFilter(getTestShape(), from1);
+        final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);
         final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());
         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java
deleted file mode 100644
index 47a6299df..000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-public class BitCountProducerFromAbsoluteUniqueHasherCollectionTest extends AbstractBitCountProducerTest {
-
-    @Override
-    protected BitCountProducer createProducer() {
-        // hasher has collisions and wraps
-        return BitCountProducer.from(new HasherCollection(
-                new IncrementingHasher(1, 1),
-                new IncrementingHasher(7, 2)).absoluteUniqueIndices(Shape.fromKM(5, 10)));
-    }
-
-    @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(new HasherCollection().absoluteUniqueIndices(Shape.fromKM(11, 10)));
-    }
-
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        return DISTINCT;
-    }
-
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {1, 2, 3, 4, 5, 7, 9};
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java
deleted file mode 100644
index d339add48..000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-public class BitCountProducerFromHasherCollectionTest extends AbstractBitCountProducerTest {
-
-    @Override
-    protected BitCountProducer createProducer() {
-        // hasher has collisions and wraps
-        return BitCountProducer.from(new HasherCollection(
-                new IncrementingHasher(0, 1),
-                new IncrementingHasher(2, 7)).indices(Shape.fromKM(17, 72)));
-    }
-
-    @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));
-    }
-
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        return 0;
-    }
-
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
-            2, 9, 16, 23, 30, 37, 44, 51, 58, 65, 0, 7, 14, 21, 28, 35, 42};
-    }
-
-    @Override
-    protected int[][] getExpectedBitCount() {
-        return new int[][] {{0, 2}, {1, 1}, {2, 2}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 2}, {8, 1},
-            {9, 2}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {14, 2}, {15, 1}, {16, 2}, {21, 1}, {23, 1},
-            {28, 1}, {30, 1}, {35, 1}, {37, 1}, {42, 1}, {44, 1}, {51, 1}, {58, 1}, {65, 1} };
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java
deleted file mode 100644
index f854f68f9..000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-public class BitCountProducerFromUniqueHasherCollectionTest extends AbstractBitCountProducerTest {
-
-    @Override
-    protected BitCountProducer createProducer() {
-        // hasher has collisions and wraps
-        return BitCountProducer.from(new HasherCollection(
-                new IncrementingHasher(1, 1),
-                new IncrementingHasher(7, 12)).uniqueIndices(Shape.fromKM(5, 10)));
-    }
-
-    @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(NullHasher.INSTANCE.uniqueIndices(Shape.fromKM(5, 10)));
-    }
-
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        // HasherCollection uniqueIndices() allows duplicates and may be unordered
-        return 0;
-    }
-
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {1, 2, 3, 4, 5, 7, 9, 1, 3, 5};
-    }
-
-    @Override
-    protected int[][] getExpectedBitCount() {
-        return new int[][] {{1, 2}, {2, 1}, {3, 2}, {4, 1}, {5, 2}, {7, 1}, {9, 1}};
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java
deleted file mode 100644
index 7ae251097..000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import java.util.Arrays;
-import java.util.stream.IntStream;
-
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Test;
-
-/**
- * Tests the {@link HasherCollection}.
- */
-
-public class HasherCollectionTest extends AbstractHasherTest {
-    @Override
-    protected HasherCollection createHasher() {
-        return new HasherCollection(new IncrementingHasher(1, 1),
-                new IncrementingHasher(2, 2));
-    }
-
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 2, 4, 6, 8, 10, 12, 14, 16, 18,
-            20, 22, 24, 26, 28, 30, 32, 34};
-    }
-
-    @Override
-    protected HasherCollection createEmptyHasher() {
-        return new HasherCollection();
-    }
-
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        // Allows duplicates and may be unordered
-        return 0;
-    }
-
-    @Override
-    protected int getHasherSize(final Hasher hasher) {
-        return ((HasherCollection) hasher).getHashers().size();
-    }
-
-    @Test
-    public void testAdd() {
-        final HasherCollection hasher = createHasher();
-        hasher.add(new IncrementingHasher(2, 2));
-        assertEquals(3, hasher.getHashers().size());
-
-        hasher.add(Arrays.asList(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2)));
-        assertEquals(5, hasher.getHashers().size());
-    }
-
-    @Test
-    void testHasherCollection() {
-        final Hasher h1 = new IncrementingHasher(13, 4678);
-        final Hasher h2 = new IncrementingHasher(42, 987);
-        final Hasher h3 = new IncrementingHasher(454, 2342);
-
-        final HasherCollection hc1 = new HasherCollection(Arrays.asList(h1, h1));
-        final HasherCollection hc2 = new HasherCollection(Arrays.asList(h2, h3));
-        final HasherCollection hc3 = new HasherCollection(Arrays.asList(hc1, hc2));
-
-        final ArrayCountingBloomFilter bf = new ArrayCountingBloomFilter(Shape.fromKM(5, 10000));
-
-        // Should add h1, h1, h2, h3
-        Assertions.assertTrue(bf.merge(hc3));
-        Assertions.assertTrue(bf.remove(h1));
-        Assertions.assertTrue(bf.remove(h1));
-        Assertions.assertNotEquals(0, bf.cardinality());
-        Assertions.assertTrue(bf.remove(hc2));
-        Assertions.assertEquals(0, bf.cardinality());
-    }
-
-    @Test
-    public void testAbsoluteUniqueIndices() {
-        final int[] actual = new HasherCollection(
-            new IncrementingHasher(1, 1),
-            new IncrementingHasher(10, 1)
-        ).absoluteUniqueIndices(Shape.fromKM(5, 1000)).asIndexArray();
-        final int[] expected = IntStream.concat(
-                IntStream.range(1, 1 + 5),
-                IntStream.range(10, 10 + 5)
-            ).toArray();
-        Assertions.assertArrayEquals(expected, actual);
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
index 6b90e1151..792917bc1 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
@@ -28,12 +28,6 @@ import org.junit.jupiter.api.Test;
  */
 public class SetOperationsTest {
 
-    protected final Hasher from1 = new IncrementingHasher(1, 1);
-    protected final long from1Value = 0x3FFFEL;
-    protected final Hasher from11 = new IncrementingHasher(11, 1);
-    protected final long from11Value = 0xFFFF800L;
-    protected final HasherCollection bigHasher = new HasherCollection(from1, from11);
-    protected final long bigHashValue = 0xFFFFFFEL;
     private final Shape shape = Shape.fromKM(17, 72);
 
     private static void assertSymmetricOperation(final int expected, final ToIntBiFunction<BloomFilter, BloomFilter> operation,
@@ -66,15 +60,15 @@ public class SetOperationsTest {
     @Test
     public final void testCosineDistance() {
 
-        BloomFilter filter1 = createFilter(shape, from1);
-        BloomFilter filter2 = createFilter(shape, from1);
+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);
+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);
 
         // identical filters should have no distance.
         double expected = 0;
         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);
 
         final Shape shape2 = Shape.fromKM(2, 72);
-        filter1 = createFilter(shape2, from1);
+        filter1 = createFilter(shape2, TestingHashers.FROM1);
         filter2 = createFilter(shape2, new IncrementingHasher(2, 1));
 
         int dotProduct = /* [1,2] & [2,3] = [2] = */ 1;
@@ -83,8 +77,8 @@ public class SetOperationsTest {
         expected = 1 - dotProduct / Math.sqrt(cardinalityA * cardinalityB);
         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);
 
-        filter1 = createFilter(shape, from1);
-        filter2 = createFilter(shape, from11);
+        filter1 = createFilter(shape, TestingHashers.FROM1);
+        filter2 = createFilter(shape, TestingHashers.FROM11);
         dotProduct = /* [1..17] & [11..27] = [] = */ 7;
         cardinalityA = 17;
         cardinalityB = 17;
@@ -92,7 +86,7 @@ public class SetOperationsTest {
         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);
 
         // test with no values
-        filter1 = createFilter(shape, from1);
+        filter1 = createFilter(shape, TestingHashers.FROM1);
         filter2 = new SimpleBloomFilter(shape);
 
         dotProduct = /* [1,2] & [] = [] = */ 0;
@@ -113,8 +107,8 @@ public class SetOperationsTest {
      */
     @Test
     public final void testCosineSimilarity() {
-        BloomFilter filter1 = createFilter(shape, from1);
-        BloomFilter filter2 = createFilter(shape, from1);
+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);
+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);
 
         int dotProduct = /* [1..17] & [1..17] = [1..17] = */ 17;
         int cardinalityA = 17;
@@ -126,14 +120,14 @@ public class SetOperationsTest {
         cardinalityA = 17;
         cardinalityB = 17;
         expected = dotProduct / Math.sqrt(cardinalityA * cardinalityB);
-        filter2 = createFilter(shape, from11);
+        filter2 = createFilter(shape, TestingHashers.FROM11);
         assertSymmetricOperation(expected, SetOperations::cosineSimilarity, filter1, filter2);
 
         // test no values
         filter1 = new SimpleBloomFilter(shape);
         filter2 = new SimpleBloomFilter(shape);
         // build a filter
-        final BloomFilter filter3 = createFilter(shape, from1);
+        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);
         assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter2);
         assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter3);
     }
@@ -143,13 +137,13 @@ public class SetOperationsTest {
      */
     @Test
     public final void testHammingDistance() {
-        final BloomFilter filter1 = createFilter(shape, from1);
-        BloomFilter filter2 = createFilter(shape, from1);
+        final BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);
+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);
 
         int hammingDistance = /* [1..17] ^ [1..17] = [] = */ 0;
         assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);
 
-        filter2 = createFilter(shape, from11);
+        filter2 = createFilter(shape, TestingHashers.FROM11);
         hammingDistance = /* [1..17] ^ [11..27] = [1..10][17-27] = */ 20;
         assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);
     }
@@ -159,13 +153,13 @@ public class SetOperationsTest {
      */
     @Test
     public final void testJaccardDistance() {
-        BloomFilter filter1 = createFilter(shape, from1);
-        BloomFilter filter2 = createFilter(shape, from1);
+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);
+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);
 
         // 1 - jaccardSimilarity -- see jaccardSimilarityTest
         assertSymmetricOperation(0.0, SetOperations::jaccardDistance, filter1, filter2);
 
-        filter2 = createFilter(shape, from11);
+        filter2 = createFilter(shape, TestingHashers.FROM11);
         final double intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;
         final int union = /* [1..17] | [11..27] = [1..27] = */ 27;
         final double expected = 1 - intersection / union;
@@ -174,7 +168,7 @@ public class SetOperationsTest {
         // test no values
         filter1 = new SimpleBloomFilter(shape);
         filter2 = new SimpleBloomFilter(shape);
-        final BloomFilter filter3 = createFilter(shape, from1);
+        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);
 
         // 1 - jaccardSimilarity -- see jaccardSimilarityTest
         assertSymmetricOperation(1.0, SetOperations::jaccardDistance, filter1, filter2);
@@ -186,15 +180,15 @@ public class SetOperationsTest {
      */
     @Test
     public final void testJaccardSimilarity() {
-        BloomFilter filter1 = createFilter(shape, from1);
-        BloomFilter filter2 = createFilter(shape, from1);
+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);
+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);
 
         double intersection = /* [1..17] & [1..17] = [1..17] = */ 17.0;
         int union = /* [1..17] | [1..17] = [1..17] = */ 17;
         double expected = intersection / union;
         assertSymmetricOperation(expected, SetOperations::jaccardSimilarity, filter1, filter2);
 
-        filter2 = createFilter(shape, from11);
+        filter2 = createFilter(shape, TestingHashers.FROM11);
         intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;
         union = /* [1..17] | [11..27] = [1..27] = */ 27;
         expected = intersection / union;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
index ba018134a..aa9a4cd6d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
@@ -85,7 +85,7 @@ public class SparseBloomFilterTest extends AbstractBloomFilterTest<SparseBloomFi
     public void testBloomFilterBasedMergeEdgeCases() {
         final BloomFilter bf1 = createEmptyFilter(getTestShape());
         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());
-        bf2.merge(from1);
+        bf2.merge(TestingHashers.FROM1);
         bf1.merge(bf2);
         assertTrue(bf2.forEachBitMapPair(bf1, (x, y) -> x == y));
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
new file mode 100644
index 000000000..8589000fb
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+/**
+ * A collection of methods and statics that represent standard hashers in testing.
+ */
+class TestingHashers {
+    /**
+     * Hasher that increments from 1.
+     */
+    static final Hasher FROM1 = new IncrementingHasher(1, 1);
+
+    /**
+     * Hasher that increments from 11.
+     */
+    static final Hasher FROM11 = new IncrementingHasher(11, 1);
+
+    /**
+     * Do not instantiate.
+     */
+    private TestingHashers() {}
+
+    /**
+     * Merge several Hashers together into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @param hashers The hashers to merge
+     * @return {@code filter} for chaining
+     */
+    static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {
+        for (Hasher h : hashers) {
+            filter.merge(h);
+        }
+        return filter;
+    }
+
+    /**
+     * Merge {@code from1} and {@code from11} into a single Bloom filter.
+     * @param <T> The type of bloom filter.
+     * @param filter The Bloom filter to populate
+     * @return {@code filter} for chaining
+     */
+    static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(T filter) {
+        return mergeHashers(filter, FROM1, FROM11);
+    }
+
+    /**
+     * Create a hasher that fills the entire range.
+     * @param <T> the Bloom filter type.
+     * @param filter the Bloom filter to populate
+     * @return {@code filter} for chaining
+     */
+    static <T extends BloomFilter> T populateEntireFilter(T filter) {
+        int n = filter.getShape().getNumberOfBits();
+        int k = filter.getShape().getNumberOfHashFunctions();
+        for (int i = 0; i < n; i += k) {
+            filter.merge(new IncrementingHasher(i, 1));
+        }
+        return filter;
+    }
+}
