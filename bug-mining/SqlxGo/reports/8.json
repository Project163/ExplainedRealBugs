{"url":"https://api.github.com/repos/jmoiron/sqlx/issues/24","repository_url":"https://api.github.com/repos/jmoiron/sqlx","labels_url":"https://api.github.com/repos/jmoiron/sqlx/issues/24/labels{/name}","comments_url":"https://api.github.com/repos/jmoiron/sqlx/issues/24/comments","events_url":"https://api.github.com/repos/jmoiron/sqlx/issues/24/events","html_url":"https://github.com/jmoiron/sqlx/issues/24","id":22409265,"node_id":"MDU6SXNzdWUyMjQwOTI2NQ==","number":24,"title":"NamedQuery causes panic for embedded struct","user":{"login":"e-dard","id":501993,"node_id":"MDQ6VXNlcjUwMTk5Mw==","avatar_url":"https://avatars.githubusercontent.com/u/501993?v=4","gravatar_id":"","url":"https://api.github.com/users/e-dard","html_url":"https://github.com/e-dard","followers_url":"https://api.github.com/users/e-dard/followers","following_url":"https://api.github.com/users/e-dard/following{/other_user}","gists_url":"https://api.github.com/users/e-dard/gists{/gist_id}","starred_url":"https://api.github.com/users/e-dard/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/e-dard/subscriptions","organizations_url":"https://api.github.com/users/e-dard/orgs","repos_url":"https://api.github.com/users/e-dard/repos","events_url":"https://api.github.com/users/e-dard/events{/privacy}","received_events_url":"https://api.github.com/users/e-dard/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":26465058,"node_id":"MDU6TGFiZWwyNjQ2NTA1OA==","url":"https://api.github.com/repos/jmoiron/sqlx/labels/bug","name":"bug","color":"fc2929","default":true,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2013-11-10T14:15:19Z","updated_at":"2013-12-27T19:05:36Z","closed_at":"2013-12-27T04:59:05Z","author_association":"NONE","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"I spoke to @jmoiron briefly about this on Friday, and have put together a simple example to show problem.\n\nWhen using NamedQuery with an embedded struct, Go panics:\n\n``` text\ngo run main.go\nclassic OK - id = 16\npanic: reflect: Field index out of range\n\ngoroutine 1 [running]:\nreflect.Value.Field(0x1cef60, 0xc2000796c0, 0x192, 0x1, 0x1, ...)\n    /usr/local/share/go/src/pkg/reflect/value.go:785 +0x164\ngithub.com/jmoiron/sqlx.BindStruct(0x2, 0x25f770, 0x56, 0x1cef60, 0xc2000796c0, ...)\n    <snip>/src/github.com/jmoiron/sqlx/bind.go:84 +0x4d9\ngithub.com/jmoiron/sqlx.(*Tx).BindStruct(0xc200095700, 0x25f770, 0x56, 0x1cef60, 0xc2000796c0, ...)\n    <snip>/src/github.com/jmoiron/sqlx/sqlx.go:298 +0x71\ngithub.com/jmoiron/sqlx.NamedQuery(0xc2000b5300, 0xc200095700, 0x25f770, 0x56, 0x1cef60, ...)\n    <snip>/src/github.com/jmoiron/sqlx/sqlx.go:1021 +0x61\ngithub.com/jmoiron/sqlx.(*Tx).NamedQuery(0xc200095700, 0x25f770, 0x56, 0x1cef60, 0xc2000796c0, ...)\n    <snip>/src/github.com/jmoiron/sqlx/sqlx.go:303 +0x67\nmain.InsertNamed(0x0, 0x16, 0xc2000b3150, 0x1)\n    <snip>/src/scratch/sqlx_bug/main.go:49 +0xfc\nmain.main()\n    <snip>/src/scratch/sqlx_bug/main.go:78 +0x16d\n\ngoroutine 2 [syscall]:\nexit status 2\n```\n#### Reproduce Issue\n\nI can reproduce the issue by creating a PostgreSQL table according to the following schema:\n\n``` sql\nCREATE TABLE \"public\".\"table\" (\n    \"id\" SERIAL PRIMARY KEY,\n    \"field\" int4\n);\n```\n\nAnd then using the following Go program:\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/jmoiron/sqlx\"\n    _ \"github.com/lib/pq\"\n)\n\ntype T struct {\n    Id    int\n    Field int `db:\"field\"`\n}\n\ntype Container struct {\n    T\n}\n\nfunc InsertClassic(c Container, db *sqlx.DB) (id int) {\n    stmt := `INSERT into \"table\" (\"field\")\n             VALUES ($1)\n             RETURNING \"id\"`\n\n    tx, err := db.Begin()\n    if err != nil {\n        panic(err)\n    }\n\n    if err = tx.QueryRow(stmt, c.Field).Scan(&id); err != nil {\n        panic(err)\n    }\n\n    if err = tx.Commit(); err != nil {\n        panic(err)\n    }\n    return\n}\n\nfunc InsertNamed(c Container, db *sqlx.DB) (id int) {\n    stmt := `INSERT into \"table\" (\"field\")\n             VALUES (:field)\n             RETURNING \"id\"`\n\n    tx, err := db.Beginx()\n    if err != nil {\n        panic(err)\n    }\n\n    var rows *sqlx.Rows\n    if rows, err = tx.NamedQuery(stmt, c); err != nil {\n        panic(err)\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        if err = rows.Scan(&id); err != nil {\n            panic(err)\n        }\n    }\n\n    if err = rows.Err(); err != nil {\n        panic(err)\n    }\n\n    if err = tx.Commit(); err != nil {\n        panic(err)\n    }\n    return\n}\n\nfunc main() {\n    db, err := sqlx.Connect(\"postgres\", \"dbname=postgres sslmode=disable port=5432\")\n    if err != nil {\n        panic(err)\n    }\n\n    c := Container{T{Field: 22}}\n    fmt.Printf(\"classic OK - id = %v\\n\", InsertClassic(c, db))\n    fmt.Println(\"named OK - id = %v\\n\", InsertNamed(c, db))\n}\n```\n\nThe `database/sql` approach of using PG parameters works fine, but using sqlx's `NamedQuery` results in a panic.\n\nI believe that the issue is stemming from the fact `sqlx.getFieldMap` maps the fields in the embedded struct `T` to indexes as follows:\n\n``` go\nmap[string]int{\n    \"id\": 0, \n    \"field\": 1,\n}\n```\n\n, while the application of that mapping, via `reflect.ValueOf(arg)`, where `arg` is the `Container` struct `c`, results in the first index of the map (which should map to `c.T.Id`) actually mapping to `c.T`. From there it's straightforward to see that there is no field available at the index 1 in the struct.\n\nSo, it appears that the implementation in `sqlx.BindStruct` does not make the right calls to the `reflect` package to get fields in the embedded field `T`, but instead gets the field(s) in the `Container` struct.\n","closed_by":{"login":"jmoiron","id":218132,"node_id":"MDQ6VXNlcjIxODEzMg==","avatar_url":"https://avatars.githubusercontent.com/u/218132?v=4","gravatar_id":"","url":"https://api.github.com/users/jmoiron","html_url":"https://github.com/jmoiron","followers_url":"https://api.github.com/users/jmoiron/followers","following_url":"https://api.github.com/users/jmoiron/following{/other_user}","gists_url":"https://api.github.com/users/jmoiron/gists{/gist_id}","starred_url":"https://api.github.com/users/jmoiron/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jmoiron/subscriptions","organizations_url":"https://api.github.com/users/jmoiron/orgs","repos_url":"https://api.github.com/users/jmoiron/repos","events_url":"https://api.github.com/users/jmoiron/events{/privacy}","received_events_url":"https://api.github.com/users/jmoiron/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/jmoiron/sqlx/issues/24/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/jmoiron/sqlx/issues/24/timeline","performed_via_github_app":null,"state_reason":"completed"}