{"url":"https://api.github.com/repos/jmoiron/sqlx/issues/73","repository_url":"https://api.github.com/repos/jmoiron/sqlx","labels_url":"https://api.github.com/repos/jmoiron/sqlx/issues/73/labels{/name}","comments_url":"https://api.github.com/repos/jmoiron/sqlx/issues/73/comments","events_url":"https://api.github.com/repos/jmoiron/sqlx/issues/73/events","html_url":"https://github.com/jmoiron/sqlx/issues/73","id":38013583,"node_id":"MDU6SXNzdWUzODAxMzU4Mw==","number":73,"title":"StructScan and Bindstruct do not play by the same rules.","user":{"login":"troyk","id":13517,"node_id":"MDQ6VXNlcjEzNTE3","avatar_url":"https://avatars.githubusercontent.com/u/13517?v=4","gravatar_id":"","url":"https://api.github.com/users/troyk","html_url":"https://github.com/troyk","followers_url":"https://api.github.com/users/troyk/followers","following_url":"https://api.github.com/users/troyk/following{/other_user}","gists_url":"https://api.github.com/users/troyk/gists{/gist_id}","starred_url":"https://api.github.com/users/troyk/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/troyk/subscriptions","organizations_url":"https://api.github.com/users/troyk/orgs","repos_url":"https://api.github.com/users/troyk/repos","events_url":"https://api.github.com/users/troyk/events{/privacy}","received_events_url":"https://api.github.com/users/troyk/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2014-07-16T19:00:40Z","updated_at":"2014-07-28T18:16:34Z","closed_at":"2014-07-23T04:20:30Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Moving data from mysql to postgres and noticed I can scan a struct in fine, but using the same names for a namedquery does not honor the mapperfunc.  After looking at the code a bit, it seems this is not a simple fix as compileNamedQuery in named.go is not aware of a mapper.  I can take a crack at a fix if this is something you feel the library should support, imho it is very confusing to bind using different naming schemes depending on the type of query.\n\nThanks -- Troy\n\n``` go\n\npackage main\n\nimport (\n    _ \"database/sql\"\n    \"log\"\n    \"strings\"\n\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/jmoiron/sqlx\"\n    \"github.com/jmoiron/sqlx/reflectx\"\n    _ \"github.com/lib/pq\"\n)\n\nvar (\n    myDB *sqlx.DB\n    pgDB *sqlx.DB\n)\n\ntype Category struct {\n    Id          int\n    Slug        string\n    Name        string\n    NameEs      string `json:\"name_es\"`\n    Description string\n    ParentId    int `json:\"parent_id\"`\n}\n\nfunc main() {\n    var err error\n    // lazily open db (doesn't truly open until first request)\n    pgDB, err = sqlx.Open(\"postgres\", \"host=localhost dbname=adgasm sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    myDB, err = sqlx.Open(\"mysql\", \"root@/foo\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    pgDB.Mapper = reflectx.NewMapperFunc(\"json\", strings.ToLower)\n    myDB.Mapper = reflectx.NewMapperFunc(\"json\", strings.ToLower)\n\n    convertCategories()\n}\n\nfunc convertCategories() {\n    // MariaDB []> show columns from categories;\n    // +------------------+------------------+------+-----+----------+----------------+\n    // | Field            | Type             | Null | Key | Default  | Extra          |\n    // +------------------+------------------+------+-----+----------+----------------+\n    // | id               | int(10) unsigned | NO   | PRI | NULL     | auto_increment |\n    // | name             | varchar(64)      | NO   |     | NULL     |                |\n    // | description      | text             | YES  |     | NULL     |                |\n    // | businesses_count | int(11)          | YES  |     | 0        |                |\n    // | alias            | varchar(256)     | YES  |     |          |                |\n    // | slug             | varchar(64)      | YES  | MUL | NULL     |                |\n    // | sp_name          | varchar(64)      | YES  |     | NULL     |                |\n    // | ads_count        | int(11)          | YES  |     | 0        |                |\n    // | type             | varchar(255)     | NO   |     | Category |                |\n    // | category_id      | int(10) unsigned | YES  |     | NULL     |                |\n    // +------------------+------------------+------+-----+----------+----------------+\n\n    // adgasm=# \\d categories\n    //                               Table \"public.categories\"\n    //       Column      |  Type   |                        Modifiers\n    // ------------------+---------+---------------------------------------------------------\n    //  id               | integer | not null default nextval('categories_id_seq'::regclass)\n    //  slug             | citext  |\n    //  name             | citext  |\n    //  name_es          | citext  |\n    //  description      | citext  |\n    //  parent_id        | integer |\n    //  businesses_count | integer | not null default 0\n    //  ads_count        | integer | not null default 0\n\n    rows, err := myDB.Queryx(\"select id,slug,name,coalesce(sp_name,'') as name_es,description,coalesce(category_id,0) as parent_id from categories order by id\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    for rows.Next() {\n        cat := Category{}\n\n        err := rows.StructScan(&cat)\n        if err != nil {\n            log.Fatal(err)\n        }\n        log.Println(cat)\n        _, err = pgDB.NamedExec(\"INSERT INTO categories(id,slug,name,name_es,description,parent_id) VALUES(:id,:slug,:name,:name_es,:description,NULLIF(:parent_id,0))\", &cat)\n        if err != nil {\n            log.Fatal(err)\n        }\n\n    }\n    rows.Close()\n\n}\n\n\n```\n","closed_by":{"login":"jmoiron","id":218132,"node_id":"MDQ6VXNlcjIxODEzMg==","avatar_url":"https://avatars.githubusercontent.com/u/218132?v=4","gravatar_id":"","url":"https://api.github.com/users/jmoiron","html_url":"https://github.com/jmoiron","followers_url":"https://api.github.com/users/jmoiron/followers","following_url":"https://api.github.com/users/jmoiron/following{/other_user}","gists_url":"https://api.github.com/users/jmoiron/gists{/gist_id}","starred_url":"https://api.github.com/users/jmoiron/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jmoiron/subscriptions","organizations_url":"https://api.github.com/users/jmoiron/orgs","repos_url":"https://api.github.com/users/jmoiron/repos","events_url":"https://api.github.com/users/jmoiron/events{/privacy}","received_events_url":"https://api.github.com/users/jmoiron/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/jmoiron/sqlx/issues/73/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/jmoiron/sqlx/issues/73/timeline","performed_via_github_app":null,"state_reason":"completed"}