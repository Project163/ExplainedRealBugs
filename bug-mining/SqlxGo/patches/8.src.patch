diff --git a/bind.go b/bind.go
index 707b400..ff85bc2 100644
--- a/bind.go
+++ b/bind.go
@@ -75,8 +75,11 @@ func BindStruct(bindType int, query string, arg interface{}) (string, []interfac
 	for v = reflect.ValueOf(arg); v.Kind() == reflect.Ptr; {
 		v = v.Elem()
 	}
+
+	values := getValues(v)
+
 	for key, val := range fm {
-		argmap[key] = v.Field(val).Interface()
+		argmap[key] = values[val]
 	}
 
 	return BindMap(bindType, query, argmap)
diff --git a/sqlx.go b/sqlx.go
index 28b4514..d3a42a5 100644
--- a/sqlx.go
+++ b/sqlx.go
@@ -827,25 +827,24 @@ func getFields(fm fieldmap, columns []string) ([]int, error) {
 	return fields, nil
 }
 
-// Return a slice of values representing the columns
-// These values are actually pointers into the addresses of struct fields
-// The values interface must be initialized to the length of fields, ie
-// make([]interface{}, len(fields)).  This function is the complement of
-// the getFieldmap function, in that they enumerate struct fields the same way.
-func setValues(fields []int, vptr reflect.Value, values []interface{}) {
-	queue := []reflect.Value{vptr}
-	fieldMap, _ := getFieldmap(vptr.Type())
-	flattenedValues := make([]interface{}, len(fieldMap))
-	// TODO: cache indexes into value and use -- what? -jm
-
-	// keep track of struct names we've encountered, so we can skip duplicates.
-	// this mirrors logic in the fieldmap construction process, which is a
-	// breadth first descent.
+// Given a value for a struct, return a slice of values which are pointers
+// to the well ordered fields in the struct, including embedded structs.
+// The indexes of this list correspond to the indexes from the fieldmap.
+func getValues(v reflect.Value) []interface{} {
+	queue := []reflect.Value{v}
+	fieldMap, _ := getFieldmap(v.Type())
+	values := make([]interface{}, len(fieldMap))
 	encountered := map[string]uint8{}
 	var isPtr, isScanner bool
 
+	// if v is addressable, we return value pointers which are settable.
+	// if v is not addressable, we return the values themselves, which are
+	// then not settable.  This behavior is so that we can use getValues
+	// in read-only contexts, like named binding.
+	returnAddrs := v.CanAddr()
+
 	for i := 0; len(queue) != 0; {
-		vptr = queue[0]
+		vptr := queue[0]
 		queue = queue[1:]
 		for j := 0; j < vptr.NumField(); j++ {
 			v := vptr.Field(j)
@@ -869,7 +868,7 @@ func setValues(fields []int, vptr reflect.Value, values []interface{}) {
 				isPtr = true
 			}
 
-			if isPtr {
+			if isPtr || !returnAddrs {
 				_, isScanner = v.Interface().(sql.Scanner)
 			} else {
 				_, isScanner = v.Addr().Interface().(sql.Scanner)
@@ -885,17 +884,28 @@ func setValues(fields []int, vptr reflect.Value, values []interface{}) {
 					queue = append(queue, v)
 				}
 			} else {
-				if isPtr {
-					flattenedValues[i] = v.Interface()
-				} else {
-					flattenedValues[i] = v.Addr().Interface()
+				if isPtr || !returnAddrs {
+					values[i] = v.Interface()
+				} else if returnAddrs {
+					values[i] = v.Addr().Interface()
 				}
 				i++
 			}
 		}
 	}
+
+	return values
+}
+
+// Return a slice of values representing the columns
+// These values are actually pointers into the addresses of struct fields
+// The values interface must be initialized to the length of fields, ie
+// make([]interface{}, len(fields)).  This function is the complement of
+// the getFieldmap function, in that they enumerate struct fields the same way.
+func setValues(fields []int, vptr reflect.Value, values []interface{}) {
+	vals := getValues(vptr)
 	for i, field := range fields {
-		values[i] = flattenedValues[field]
+		values[i] = vals[field]
 	}
 }
 
diff --git a/sqlx_test.go b/sqlx_test.go
index 3ca38f3..3461bac 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -699,7 +699,10 @@ func TestBindMap(t *testing.T) {
 }
 
 func TestBindStruct(t *testing.T) {
+	var err error
+
 	q1 := `INSERT INTO foo (a, b, c, d) VALUES (:name, :age, :first, :last)`
+
 	type tt struct {
 		Name  string
 		Age   int
@@ -712,6 +715,11 @@ func TestBindStruct(t *testing.T) {
 		Field2 string `db:"field_2"`
 	}
 
+	type tt3 struct {
+		tt2
+		Name string
+	}
+
 	am := tt{"Jason Moiron", 30, "Jason", "Moiron"}
 
 	bq, args, _ := BindStruct(QUESTION, q1, am)
@@ -750,6 +758,30 @@ func TestBindStruct(t *testing.T) {
 		t.Errorf("Expected 'Hello', got %s\n", args[1].(string))
 	}
 
+	am3 := tt3{Name: "Hello!"}
+	am3.Field1 = "Hello"
+	am3.Field2 = "World"
+
+	bq, args, err = BindStruct(QUESTION, "INSERT INTO foo (a, b, c) VALUES (:name, :field_1, :field_2)", am3)
+
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	expect = `INSERT INTO foo (a, b, c) VALUES (?, ?, ?)`
+	if bq != expect {
+		t.Errorf("Interpolation of query failed: got `%v`, expected `%v`\n", bq, expect)
+	}
+
+	if args[0].(string) != "Hello!" {
+		t.Errorf("Expected 'Hello!', got %s\n", args[0].(string))
+	}
+	if args[1].(string) != "Hello" {
+		t.Errorf("Expected 'Hello', got %s\n", args[1].(string))
+	}
+	if args[2].(string) != "World" {
+		t.Errorf("Expected 'World', got %s\n", args[0].(string))
+	}
 }
 
 func BenchmarkBindStruct(b *testing.B) {
