diff --git a/bind.go b/bind.go
index 176f333..707b400 100644
--- a/bind.go
+++ b/bind.go
@@ -82,6 +82,12 @@ func BindStruct(bindType int, query string, arg interface{}) (string, []interfac
 	return BindMap(bindType, query, argmap)
 }
 
+// Allow digits and letters in bind params;  additionally runes are
+// checked against underscores, meaning that bind params can have be
+// alphanumeric with underscores.  Mind the difference between unicode
+// digits and numbers, where '5' is a digit but 'äº”' is not.
+var allowedBindRunes = []*unicode.RangeTable{unicode.Letter, unicode.Digit}
+
 // Bind a named parameter query with a map of arguments.
 func BindMap(bindType int, query string, args map[string]interface{}) (string, []interface{}, error) {
 	arglist := make([]interface{}, 0, 5)
@@ -108,14 +114,14 @@ func BindMap(bindType int, query string, args map[string]interface{}) (string, [
 			}
 			inName = true
 			name = []byte{}
-		} else if inName && (unicode.IsLetter(rune(b)) || b == '_') && i != last {
+		} else if inName && (unicode.IsOneOf(allowedBindRunes, rune(b)) || b == '_') && i != last {
 			// append the rune to the name if we are in a name and not on the last rune
 			name = append(name, b)
 		} else if inName {
 			inName = false
 			// if this is the final rune of the string and it is part of the name, then
 			// make sure to add it to the name
-			if i == last && unicode.IsLetter(rune(b)) {
+			if i == last && unicode.IsOneOf(allowedBindRunes, rune(b)) {
 				name = append(name, b)
 			}
 			sname = string(name)
@@ -141,7 +147,7 @@ func BindMap(bindType int, query string, args map[string]interface{}) (string, [
 			// is last but is not a letter
 			if i != last {
 				rebound = append(rebound, b)
-			} else if !unicode.IsLetter(rune(b)) {
+			} else if !unicode.IsOneOf(allowedBindRunes, rune(b)) {
 				rebound = append(rebound, b)
 			}
 		} else {
diff --git a/sqlx_test.go b/sqlx_test.go
index fc59955..269c440 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -536,6 +536,12 @@ func TestBindStruct(t *testing.T) {
 		First string
 		Last  string
 	}
+
+	type tt2 struct {
+		Field1 string `db:"field_1"`
+		Field2 string `db:"field_2"`
+	}
+
 	am := tt{"Jason Moiron", 30, "Jason", "Moiron"}
 
 	bq, args, _ := BindStruct(QUESTION, q1, am)
@@ -560,6 +566,20 @@ func TestBindStruct(t *testing.T) {
 		t.Errorf("Expected Moiron, got %v\n", args[3])
 	}
 
+	am2 := tt2{"Hello", "World"}
+	bq, args, _ = BindStruct(QUESTION, "INSERT INTO foo (a, b) VALUES (:field_2, :field_1)", am2)
+	expect = `INSERT INTO foo (a, b) VALUES (?, ?)`
+	if bq != expect {
+		t.Errorf("Interpolation of query failed: got `%v`, expected `%v`\n", bq, expect)
+	}
+
+	if args[0].(string) != "World" {
+		t.Errorf("Expected 'World', got %s\n", args[0].(string))
+	}
+	if args[1].(string) != "Hello" {
+		t.Errorf("Expected 'Hello', got %s\n", args[1].(string))
+	}
+
 }
 
 func BenchmarkBindStruct(b *testing.B) {
