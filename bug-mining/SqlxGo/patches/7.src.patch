diff --git a/sqlx.go b/sqlx.go
index e1ea7f0..28b4514 100644
--- a/sqlx.go
+++ b/sqlx.go
@@ -2,6 +2,7 @@ package sqlx
 
 import (
 	"database/sql"
+	"database/sql/driver"
 	"errors"
 
 	"io/ioutil"
@@ -740,6 +741,11 @@ func BaseStructType(t reflect.Type) (reflect.Type, error) {
 	return t, nil
 }
 
+var scannerVal *sql.Scanner
+var scannerIface = reflect.TypeOf(scannerVal).Elem()
+var valuerVal *driver.Valuer
+var valuerIface = reflect.TypeOf(valuerVal).Elem()
+
 // Create a fieldmap for a given type and return its fieldmap (or error)
 // The fieldmap maps names to integers which represent the position of
 // a struct field in a breadth first search of the fields.
@@ -749,9 +755,11 @@ func getFieldmap(t reflect.Type) (fm fieldmap, err error) {
 	if err != nil {
 		return nil, err
 	}
+
 	fieldmapCacheLock.RLock()
 	fm, ok := fieldmapCache[t]
 	fieldmapCacheLock.RUnlock()
+
 	if ok {
 		return fm, nil
 	} else {
@@ -759,22 +767,27 @@ func getFieldmap(t reflect.Type) (fm fieldmap, err error) {
 	}
 
 	var f reflect.StructField
+	var ft reflect.Type
 	var name string
-	scannerVal := new(sql.Scanner)
-	scanner := reflect.TypeOf(scannerVal).Elem()
+
 	queue := []reflect.Type{t}
+
 	for i := 0; len(queue) != 0; {
 		ty := queue[0]
 		queue = queue[1:]
 		for j := 0; j < ty.NumField(); j++ {
 			f = ty.Field(j)
+			ft = f.Type
 			// skip unexported field
 			if len(f.PkgPath) != 0 {
 				continue
 			}
-			// skip structs which implement `scanner`
-			if f.Type.Kind() == reflect.Struct && !reflect.PtrTo(f.Type).Implements(scanner) && f.Type != timeType {
-				queue = append(queue, f.Type)
+			// perform one level of indirection for pointers to structs
+			if ft.Kind() == reflect.Ptr {
+				ft = ft.Elem()
+			}
+			if ft.Kind() == reflect.Struct && !reflect.PtrTo(ft).Implements(scannerIface) && ft != timeType {
+				queue = append(queue, ft)
 			} else {
 				name = NameMapper(f.Name)
 				if tag := f.Tag.Get("db"); tag != "" {
@@ -817,36 +830,66 @@ func getFields(fm fieldmap, columns []string) ([]int, error) {
 // Return a slice of values representing the columns
 // These values are actually pointers into the addresses of struct fields
 // The values interface must be initialized to the length of fields, ie
-// make([]interface{}, len(fields)).
+// make([]interface{}, len(fields)).  This function is the complement of
+// the getFieldmap function, in that they enumerate struct fields the same way.
 func setValues(fields []int, vptr reflect.Value, values []interface{}) {
 	queue := []reflect.Value{vptr}
 	fieldMap, _ := getFieldmap(vptr.Type())
 	flattenedValues := make([]interface{}, len(fieldMap))
-	// TODO: cache indexes into value and use
+	// TODO: cache indexes into value and use -- what? -jm
 
 	// keep track of struct names we've encountered, so we can skip duplicates.
 	// this mirrors logic in the fieldmap construction process, which is a
 	// breadth first descent.
 	encountered := map[string]uint8{}
+	var isPtr, isScanner bool
 
 	for i := 0; len(queue) != 0; {
 		vptr = queue[0]
 		queue = queue[1:]
 		for j := 0; j < vptr.NumField(); j++ {
 			v := vptr.Field(j)
-			vt := vptr.Type().Field(j)
-			if _, ok := encountered[vt.Name]; ok {
+			vsf := vptr.Type().Field(j)
+			vt := v.Type()
+			isPtr = false
+			isScanner = false
+
+			// skip duplicate names in the struct tree
+			if _, ok := encountered[vsf.Name]; ok {
 				continue
 			}
-			if tag := vt.Tag.Get("db"); tag == "-" {
+			// skip fields with the db tag set to "-"
+			if tag := vsf.Tag.Get("db"); tag == "-" {
 				continue
 			}
-			encountered[vt.Name] = 0
-			_, isScanner := v.Addr().Interface().(sql.Scanner)
-			if v.Kind() == reflect.Struct && !isScanner && v.Type() != timeType {
-				queue = append(queue, v)
+
+			encountered[vsf.Name] = 0
+			if vt.Kind() == reflect.Ptr {
+				vt = vt.Elem()
+				isPtr = true
+			}
+
+			if isPtr {
+				_, isScanner = v.Interface().(sql.Scanner)
 			} else {
-				flattenedValues[i] = v.Addr().Interface()
+				_, isScanner = v.Addr().Interface().(sql.Scanner)
+			}
+
+			if vt.Kind() == reflect.Struct && !isScanner && vt != timeType {
+				if isPtr {
+					// Allocate a new struct for this poissibly nil pointer field, set it, and add to queue
+					alloc := reflect.New(vt)
+					v.Set(alloc)
+					queue = append(queue, reflect.Indirect(v))
+				} else {
+					queue = append(queue, v)
+				}
+			} else {
+				if isPtr {
+					flattenedValues[i] = v.Interface()
+				} else {
+					flattenedValues[i] = v.Addr().Interface()
+				}
 				i++
 			}
 		}
diff --git a/sqlx_test.go b/sqlx_test.go
index 94cf22f..3ca38f3 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -18,15 +18,16 @@ package sqlx
 import (
 	"database/sql"
 	"fmt"
-	_ "github.com/go-sql-driver/mysql"
-	_ "github.com/lib/pq"
-	_ "github.com/mattn/go-sqlite3"
 	"os"
 	"os/user"
 	"reflect"
 	"strings"
 	"testing"
 	"time"
+
+	_ "github.com/go-sql-driver/mysql"
+	_ "github.com/lib/pq"
+	_ "github.com/mattn/go-sqlite3"
 )
 
 /* compile time checks that Db, Tx, Stmt (qStmt) implement expected interfaces */
@@ -188,6 +189,11 @@ type PersonPlace struct {
 	Place
 }
 
+type PersonPlacePtr struct {
+	*Person
+	*Place
+}
+
 type NonEmbedded struct {
 	Person Person
 	Place  Place
@@ -286,6 +292,24 @@ func TestUsage(t *testing.T) {
 			}
 		}
 
+		// test the same for embedded pointer structs
+		peopleAndPlacesPtrs := []PersonPlacePtr{}
+		err = db.Select(
+			&peopleAndPlacesPtrs,
+			`SELECT person.*, place.* FROM
+             person natural join place`)
+		if err != nil {
+			t.Fatal(err)
+		}
+		for _, pp := range peopleAndPlacesPtrs {
+			if len(pp.Person.FirstName) == 0 {
+				t.Errorf("Expected non zero lengthed first name.")
+			}
+			if len(pp.Place.Country) == 0 {
+				t.Errorf("Expected non zero lengthed country.")
+			}
+		}
+
 		// test "non embedded" struct namespace collapsing..
 		nes := []NonEmbedded{}
 		err = db.Select(&nes, `select person.*, place.* FROM person natural join place`)
@@ -792,6 +816,9 @@ func TestGetFieldMap(t *testing.T) {
 		reflect.TypeOf(new(PersonPlace)): {
 			"first_name": 0, "last_name": 1, "email": 2, "added_at": 3,
 			"country": 4, "city": 5, "telcode": 6},
+		reflect.TypeOf(new(PersonPlacePtr)): {
+			"first_name": 0, "last_name": 1, "email": 2, "added_at": 3,
+			"country": 4, "city": 5, "telcode": 6},
 	}
 	for typ, expected := range testing_table {
 		fields, err := getFieldmap(typ)
@@ -799,7 +826,7 @@ func TestGetFieldMap(t *testing.T) {
 			t.Fatal(err)
 		}
 		if !reflect.DeepEqual(fields, expected) {
-			t.Fatalf("wtf %v %v", fields, expected)
+			t.Fatalf("Fieldmap error: got `%v`, expected `%v`", fields, expected)
 		}
 	}
 }
