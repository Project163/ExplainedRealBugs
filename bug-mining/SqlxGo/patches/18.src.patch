diff --git a/README.md b/README.md
index 2b1ead6..e5d138f 100644
--- a/README.md
+++ b/README.md
@@ -34,6 +34,8 @@ var names []string
 err := db.Select(&names, "SELECT email FROM person;")
 ```
 
+See the note on Scannability at the bottom of this README for some more info.
+
 ### Backwards Compatibility
 
 There is no Go1-like promise of absolute stability, but I take the issue
diff --git a/named.go b/named.go
index 2409a09..329bd3e 100644
--- a/named.go
+++ b/named.go
@@ -231,12 +231,16 @@ func compileNamedQuery(qs []byte, bindType int) (query string, names []string, e
 
 	for i, b := range qs {
 		// a ':' while we're in a name is an error
-		if b == ':' && inName {
-			err = errors.New("unexpected `:` while reading named param at " + strconv.Itoa(i))
-			return query, names, err
-			// if we encounter a ':' and we aren't in a name, it's a new parameter
-			// FIXME: escaping?
-		} else if b == ':' {
+		if b == ':' {
+			// if this is the second ':' in a '::' escape sequence, append a ':'
+			if inName && i > 0 && qs[i-1] == ':' {
+				rebound = append(rebound, ':')
+				inName = false
+				continue
+			} else if inName {
+				err = errors.New("unexpected `:` while reading named param at " + strconv.Itoa(i))
+				return query, names, err
+			}
 			inName = true
 			name = []byte{}
 			// if we're in a name, and this is an allowed character, continue
diff --git a/named_test.go b/named_test.go
index 633700e..d3459a8 100644
--- a/named_test.go
+++ b/named_test.go
@@ -7,22 +7,38 @@ import (
 
 func TestCompileQuery(t *testing.T) {
 	table := []struct {
-		Q, R, D string
-		N       []string
+		Q, R, D, N string
+		V          []string
 	}{
 		// basic test for named parameters, invalid char ',' terminating
 		{
 			Q: `INSERT INTO foo (a,b,c,d) VALUES (:name, :age, :first, :last)`,
 			R: `INSERT INTO foo (a,b,c,d) VALUES (?, ?, ?, ?)`,
 			D: `INSERT INTO foo (a,b,c,d) VALUES ($1, $2, $3, $4)`,
-			N: []string{"name", "age", "first", "last"},
+			N: `INSERT INTO foo (a,b,c,d) VALUES (:name, :age, :first, :last)`,
+			V: []string{"name", "age", "first", "last"},
 		},
 		// This query tests a named parameter ending the string as well as numbers
 		{
 			Q: `SELECT * FROM a WHERE first_name=:name1 AND last_name=:name2`,
 			R: `SELECT * FROM a WHERE first_name=? AND last_name=?`,
 			D: `SELECT * FROM a WHERE first_name=$1 AND last_name=$2`,
-			N: []string{"name1", "name2"},
+			N: `SELECT * FROM a WHERE first_name=:name1 AND last_name=:name2`,
+			V: []string{"name1", "name2"},
+		},
+		{
+			Q: `SELECT "::foo" FROM a WHERE first_name=:name1 AND last_name=:name2`,
+			R: `SELECT ":foo" FROM a WHERE first_name=? AND last_name=?`,
+			D: `SELECT ":foo" FROM a WHERE first_name=$1 AND last_name=$2`,
+			N: `SELECT ":foo" FROM a WHERE first_name=:name1 AND last_name=:name2`,
+			V: []string{"name1", "name2"},
+		},
+		{
+			Q: `SELECT 'a::b::c' || first_name, '::::ABC::_::' FROM person WHERE first_name=:first_name AND last_name=:last_name`,
+			R: `SELECT 'a:b:c' || first_name, '::ABC:_:' FROM person WHERE first_name=? AND last_name=?`,
+			D: `SELECT 'a:b:c' || first_name, '::ABC:_:' FROM person WHERE first_name=$1 AND last_name=$2`,
+			N: `SELECT 'a:b:c' || first_name, '::ABC:_:' FROM person WHERE first_name=:first_name AND last_name=:last_name`,
+			V: []string{"first_name", "last_name"},
 		},
 		/* This unicode awareness test sadly fails, because of our byte-wise worldview.
 		 * We could certainly iterate by Rune instead, though it's a great deal slower,
@@ -44,23 +60,23 @@ func TestCompileQuery(t *testing.T) {
 		if qr != test.R {
 			t.Errorf("expected %s, got %s", test.R, qr)
 		}
-		if len(names) != len(test.N) {
-			t.Errorf("expected %#v, got %#v", test.N, names)
+		if len(names) != len(test.V) {
+			t.Errorf("expected %#v, got %#v", test.V, names)
 		} else {
 			for i, name := range names {
-				if name != test.N[i] {
-					t.Errorf("expected %dth name to be %s, got %s", i+1, test.N[i], name)
+				if name != test.V[i] {
+					t.Errorf("expected %dth name to be %s, got %s", i+1, test.V[i], name)
 				}
 			}
 		}
 		qd, _, _ := compileNamedQuery([]byte(test.Q), DOLLAR)
 		if qd != test.D {
-			t.Errorf("expected %s, got %s", test.D, qd)
+			t.Errorf("\nexpected: `%s`\ngot:      `%s`", test.D, qd)
 		}
 
 		qq, _, _ := compileNamedQuery([]byte(test.Q), NAMED)
-		if qq != test.Q {
-			t.Errorf("expected %s, got %s", test.Q, qq)
+		if qq != test.N {
+			t.Errorf("\nexpected: `%s`\ngot:      `%s`\n(len: %d vs %d)", test.N, qq, len(test.N), len(qq))
 		}
 	}
 }
