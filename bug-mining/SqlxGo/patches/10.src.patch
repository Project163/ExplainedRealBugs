diff --git a/sqlx.go b/sqlx.go
index 52a7568..bb0fe05 100644
--- a/sqlx.go
+++ b/sqlx.go
@@ -827,11 +827,12 @@ func getFields(fm fieldmap, columns []string) ([]int, error) {
 // to the well ordered fields in the struct, including embedded structs.
 // The indexes of this list correspond to the indexes from the fieldmap.
 func getValues(v reflect.Value) []interface{} {
+
 	queue := []reflect.Value{v}
 	fieldMap, _ := getFieldmap(v.Type())
 	values := make([]interface{}, len(fieldMap))
 	encountered := map[string]uint8{}
-	var isPtr, isScanner bool
+	var isPtr, isScanner, isValuer bool
 
 	// if v is addressable, we return value pointers which are settable.
 	// if v is not addressable, we return the values themselves, which are
@@ -866,11 +867,13 @@ func getValues(v reflect.Value) []interface{} {
 
 			if isPtr || !returnAddrs {
 				_, isScanner = v.Interface().(sql.Scanner)
+				_, isValuer = v.Interface().(driver.Valuer)
 			} else {
 				_, isScanner = v.Addr().Interface().(sql.Scanner)
+				_, isValuer = v.Addr().Interface().(driver.Valuer)
 			}
 
-			if vt.Kind() == reflect.Struct && !isScanner && vt != timeType {
+			if vt.Kind() == reflect.Struct && !isScanner && !isValuer && vt != timeType {
 				if isPtr {
 					// Allocate a new struct for this poissibly nil pointer field, set it, and add to queue
 					alloc := reflect.New(vt)
diff --git a/sqlx_test.go b/sqlx_test.go
index c470a76..3fdaad4 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -13,6 +13,7 @@ package sqlx
 import (
 	"database/sql"
 	"fmt"
+	"log"
 	"os"
 	"reflect"
 	"strings"
@@ -331,6 +332,57 @@ func TestEmbeddedStructs(t *testing.T) {
 	})
 }
 
+func TestNamedQuery(t *testing.T) {
+	var schema = Schema{
+		create: `
+			CREATE TABLE person (
+				first_name text NULL,
+				last_name text NULL,
+				email text NULL
+			);`,
+		drop: `drop table person;`,
+	}
+
+	RunWithSchema(schema, t, func(db *DB, t *testing.T) {
+		type Person struct {
+			FirstName sql.NullString `db:"first_name"`
+			LastName  sql.NullString `db:"last_name"`
+			Email     sql.NullString
+		}
+
+		p := Person{
+			FirstName: sql.NullString{"ben", true},
+			LastName:  sql.NullString{"doe", true},
+			Email:     sql.NullString{"ben@doe.com", true},
+		}
+
+		q1 := `INSERT INTO person (first_name, last_name, email) VALUES (:first_name, :last_name, :email)`
+		_, err := db.NamedExec(q1, p)
+		if err != nil {
+			log.Fatal(err)
+		}
+
+		p2 := &Person{}
+		rows, err := db.NamedQuery("SELECT * FROM person WHERE first_name=:first_name", p)
+		if err != nil {
+			log.Fatal(err)
+		}
+		for rows.Next() {
+			err = rows.StructScan(p2)
+			if err != nil {
+				t.Error(err)
+			}
+			if p2.FirstName.String != "ben" {
+				t.Error("Expected first name of `ben`, got " + p2.FirstName.String)
+			}
+			if p2.LastName.String != "doe" {
+				t.Error("Expected first name of `doe`, got " + p2.LastName.String)
+			}
+		}
+	})
+
+}
+
 func TestUsage(t *testing.T) {
 	RunWithSchema(defaultSchema, t, func(db *DB, t *testing.T) {
 		loadDefaultFixture(db, t)
