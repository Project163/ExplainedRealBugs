diff --git a/sqlx.go b/sqlx.go
index 7ec4dc9..9477c66 100644
--- a/sqlx.go
+++ b/sqlx.go
@@ -375,9 +375,6 @@ func (tx *Tx) Preparex(query string) (*Stmt, error) {
 // Returns a version of the prepared statement which runs within a transaction.  Provided
 // stmt can be either *sql.Stmt or *sqlx.Stmt, and the return value is always *sqlx.Stmt.
 func (tx *Tx) Stmtx(stmt interface{}) *Stmt {
-	// TODO: test with more scrutiny what happens when pre-prepared statements are
-	// transactionized, as there are problems with copying these as the original
-	// driver's internal info might not make it across
 	var st sql.Stmt
 	var s *sql.Stmt
 	switch stmt.(type) {
@@ -386,8 +383,12 @@ func (tx *Tx) Stmtx(stmt interface{}) *Stmt {
 		s = &st
 	case Stmt:
 		s = stmt.(Stmt).Stmt
+	case *Stmt:
+		s = stmt.(*Stmt).Stmt
+	case *sql.Stmt:
+		s = stmt.(*sql.Stmt)
 	}
-	return &Stmt{s}
+	return &Stmt{tx.Stmt(s)}
 }
 
 // An sqlx wrapper around database/sql's Stmt with extra functionality
diff --git a/sqlx_test.go b/sqlx_test.go
index 11ae537..64d1667 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -374,6 +374,23 @@ func TestUsage(t *testing.T) {
 		}
 		err = stmt1.Get(&jason, "DoesNotExist User 2")
 
+		stmt2, err := db.Preparex(db.Rebind("SELECT * FROM person WHERE first_name=?"))
+		if err != nil {
+			t.Fatal(err)
+		}
+		jason = Person{}
+		tx, err = db.Beginx()
+		if err != nil {
+			t.Fatal(err)
+		}
+		tstmt2 := tx.Stmtx(stmt2)
+		row2 := tstmt2.QueryRowx("Jason")
+		err = row2.StructScan(&jason)
+		if err != nil {
+			t.Error(err)
+		}
+		tx.Commit()
+
 		places := []*Place{}
 		err = db.Select(&places, "SELECT telcode FROM place ORDER BY telcode ASC")
 		usa, singsing, honkers := places[0], places[1], places[2]
