diff --git a/README.md b/README.md
index 7387d74..2b1ead6 100644
--- a/README.md
+++ b/README.md
@@ -184,6 +184,26 @@ func main() {
 }
 ```
 
+## Scannability
+
+Get and Select are able to take base types, so the following is now possible:
+
+```go
+var name string
+db.Get(&name, "SELECT first_name FROM person WHERE id=$1", 10)
+
+var ids []int64
+db.Select(&ids, "SELECT id FROM person LIMIT 20;")
+```
+
+This can get complicated with destination types which are structs, like `sql.NullString`.  Because of this, straightforward rules for *scannability* had to be developed.  Iff something is "Scannable", then it is used directly in `rows.Scan`;  if it's not, then the standard sqlx struct rules apply.
+
+Something is scannable if any of the following are true:
+
+* It is not a struct, ie. `reflect.ValueOf(v).Kind() != reflect.Struct`
+* It implements the `sql.Scanner` interface
+* It has no exported fields (eg. `time.Time`)
+
 ## embedded structs
 
 Scan targets obey Go attribute rules directly, including nested embedded structs.  Older versions of sqlx would attempt to also descend into non-embedded structs, but this is no longer supported.
diff --git a/reflectx/reflect.go b/reflectx/reflect.go
index d38d101..847b760 100644
--- a/reflectx/reflect.go
+++ b/reflectx/reflect.go
@@ -58,7 +58,7 @@ func (m *Mapper) TypeMap(t reflect.Type) fieldMap {
 	return mapping
 }
 
-// Fieldmap returns the mapper's mapping of field names to reflect values.  Panics
+// FieldMap returns the mapper's mapping of field names to reflect values.  Panics
 // if v's Kind is not Struct, or v is not Indirectable to a struct kind.
 func (m *Mapper) FieldMap(v reflect.Value) map[string]reflect.Value {
 	v = reflect.Indirect(v)
diff --git a/sqlx.go b/sqlx.go
index 46ecb93..e7304c8 100644
--- a/sqlx.go
+++ b/sqlx.go
@@ -42,6 +42,28 @@ func mapper() *reflectx.Mapper {
 	return mpr
 }
 
+// isScannable takes the reflect.Type and the actual dest value and returns
+// whether or not it's Scannable.  Something is scannable if:
+//   * it is not a struct
+//   * it implements sql.Scanner
+//   * it has no exported fields
+func isScannable(t reflect.Type) bool {
+	if reflect.PtrTo(t).Implements(_scannerInterface) {
+		return true
+	}
+	if t.Kind() != reflect.Struct {
+		return true
+	}
+
+	// it's not important that we use the right mapper for this particular object,
+	// we're only concerned on how many exported fields this struct has
+	m := mapper()
+	if len(m.TypeMap(t)) == 0 {
+		return true
+	}
+	return false
+}
+
 // ColScanner is an interface used by MapScan and SliceScan
 type ColScanner interface {
 	Columns() ([]string, error)
@@ -665,22 +687,10 @@ func (r *Row) scanAny(dest interface{}, structOnly bool) error {
 	}
 
 	base := reflectx.Deref(v.Type())
-	// We have a serious thing to consider here;  if this struct is a Scanner,
-	// I think we should scan into it directly as a type and not a struct.  This
-	// brings back some "isScanner" detection we got rid of previously, and makes
-	// things a little bit more confusing, but it allows for use of NullString
-	// and its ilk
-	isStruct := base.Kind() == reflect.Struct
-	_, isScanner := dest.(sql.Scanner)
-
-	// only error out here if we require a struct but didn't get one
-	if structOnly {
-		if !isStruct {
-			return fmt.Errorf("expected %s but got %s", reflect.Struct, base.Kind())
-		}
-		if isScanner {
-			return fmt.Errorf("structscan expects a struct dest but the provided struct type %s implements scanner", base.Name())
-		}
+	scannable := isScannable(base)
+
+	if structOnly && scannable {
+		return structOnlyError(base)
 	}
 
 	columns, err := r.Columns()
@@ -688,11 +698,11 @@ func (r *Row) scanAny(dest interface{}, structOnly bool) error {
 		return err
 	}
 
-	if !isStruct && len(columns) > 1 {
-		return fmt.Errorf("non-struct or Scanner dest type %s with >1 columns (%d) in result", base.Kind(), len(columns))
+	if scannable && len(columns) > 1 {
+		return fmt.Errorf("scannable dest type %s with >1 columns (%d) in result", base.Kind(), len(columns))
 	}
 
-	if !isStruct || isScanner {
+	if scannable {
 		return r.Scan(dest)
 	}
 
@@ -787,6 +797,20 @@ type rowsi interface {
 	Scan(...interface{}) error
 }
 
+// structOnlyError returns an error appropriate for type when a non-scannable
+// struct is expected but something else is given
+func structOnlyError(t reflect.Type) error {
+	isStruct := t.Kind() == reflect.Struct
+	isScanner := reflect.PtrTo(t).Implements(_scannerInterface)
+	if !isStruct {
+		return fmt.Errorf("expected %s but got %s", reflect.Struct, t.Kind())
+	}
+	if isScanner {
+		return fmt.Errorf("structscan expects a struct dest but the provided struct type %s implements scanner", t.Name())
+	}
+	return fmt.Errorf("expected a struct, but struct %s has no exported fields", t.Name())
+}
+
 // scanAll scans all rows into a destination, which must be a slice of any
 // type.  If the destination slice type is a Struct, then StructScan will be
 // used on each row.  If the destination is some other kind of base type, then
@@ -823,23 +847,10 @@ func scanAll(rows rowsi, dest interface{}, structOnly bool) error {
 
 	isPtr := slice.Elem().Kind() == reflect.Ptr
 	base := reflectx.Deref(slice.Elem())
-	isStruct := base.Kind() == reflect.Struct
-	// check if a pointer to the slice type implements sql.Scanner; if it does, we
-	// will treat this as a base type slice rather than a struct slice;  eg, we will
-	// treat []sql.NullString as a single row rather than a struct with 2 scan targets.
-	isScanner := reflect.PtrTo(base).Implements(_scannerInterface)
-
-	// if we must have a struct and the base type isn't a struct, return an error.
-	// this maintains API compatibility for StructScan, which is only important
-	// because StructScan should involve structs and it feels gross to add more
-	// weird junk to it.
-	if structOnly {
-		if !isStruct {
-			return fmt.Errorf("expected %s but got %s", reflect.Struct, base.Kind())
-		}
-		if isScanner {
-			return fmt.Errorf("structscan expects a struct dest but the provided struct type %s implements scanner", base.Name())
-		}
+	scannable := isScannable(base)
+
+	if structOnly && scannable {
+		return structOnlyError(base)
 	}
 
 	columns, err := rows.Columns()
@@ -848,11 +859,11 @@ func scanAll(rows rowsi, dest interface{}, structOnly bool) error {
 	}
 
 	// if it's a base type make sure it only has 1 column;  if not return an error
-	if !isStruct && len(columns) > 1 {
+	if scannable && len(columns) > 1 {
 		return fmt.Errorf("non-struct dest type %s with >1 columns (%d)", base.Kind(), len(columns))
 	}
 
-	if isStruct && !isScanner {
+	if !scannable {
 		var values []interface{}
 		var m *reflectx.Mapper
 
diff --git a/sqlx_test.go b/sqlx_test.go
index a7da9d0..bc13485 100644
--- a/sqlx_test.go
+++ b/sqlx_test.go
@@ -1014,6 +1014,19 @@ func TestUsage(t *testing.T) {
 			t.Errorf("Expected %d == %d (count(*) vs len(SELECT ..)", count, len(sdest))
 		}
 
+		// test Get and Select with time.Time, #84
+		var addedAt time.Time
+		err = db.Get(&addedAt, "SELECT added_at FROM person LIMIT 1;")
+		if err != nil {
+			t.Error(err)
+		}
+
+		var addedAts []time.Time
+		err = db.Select(&addedAts, "SELECT added_at FROM person;")
+		if err != nil {
+			t.Error(err)
+		}
+
 		// test it on a double pointer
 		var pcount *int
 		err = db.Get(&pcount, "SELECT count(*) FROM person;")
