diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 2ea50d92..88bd48a8 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -13,6 +13,9 @@ Project: jackson-dataformat-xml
  (reported by Alexei V)
 #393: `MismatchedInputException` for nested repeating element name in `List`
  (reported by kaizenHorse@github)
+#399: Can not deserialize unwrapped list when `@JacksonXmlProperty` localName matches
+  the parent's localName
+ (reported by sandboxgod@github)
 
 2.11.0 (26-Apr-2020)
 
diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java
index 1334ff0d..722ffcc2 100644
--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java
+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java
@@ -326,11 +326,11 @@ public class FromXmlParser
         //   problems with Lists-in-Lists properties
         // 12-May-2020, tatu: But as per [dataformat-xml#86] NOT for root element
         //   (would still like to know why work-around needed ever, but...)
-        if (_parsingContext.inObject()
+        if (!_parsingContext.inRoot()
                  && !_parsingContext.getParent().inRoot()) {
             String name = _xmlTokens.getLocalName();
             if ((name != null) && namesToWrap.contains(name)) {
-//System.out.println("REPEAT from addVirtualWrapping()");
+//System.out.println("REPEAT from addVirtualWrapping() for '"+name+"'");
                 _xmlTokens.repeatStartElement();
             }
         }
diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
index 7624975f..9989ed9a 100644
--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
@@ -170,28 +170,33 @@ public class XmlTokenStream
         int n = next0();
         switch (n) {
         case XML_START_ELEMENT: 
-            System.out.println(" XmlTolenStream.next(): XML_START_ELEMENT '"+_localName+"'");
+            System.out.printf(" XmlTokenStream.next(): XML_START_ELEMENT '%s' %s\n", _localName, _loc());
             break;
         case XML_END_ELEMENT: 
-            System.out.println(" XmlTolenStream.next(): XML_END_ELEMENT '"+_localName+"'");
+            System.out.printf(" XmlTokenStream.next(): XML_END_ELEMENT '%s' %s\n", _localName, _loc());
             break;
         case XML_ATTRIBUTE_NAME: 
-            System.out.println(" XmlTolenStream.next(): XML_ATTRIBUTE_NAME '"+_localName+"'");
+            System.out.printf(" XmlTokenStream.next(): XML_ATTRIBUTE_NAME '%s' %s\n", _localName, _loc());
             break;
         case XML_ATTRIBUTE_VALUE: 
-            System.out.println(" XmlTolenStream.next(): XML_ATTRIBUTE_VALUE '"+_textValue+"'");
+            System.out.printf(" XmlTokenStream.next(): XML_ATTRIBUTE_VALUE '%s' %s\n", _textValue, _loc());
             break;
         case XML_TEXT: 
-            System.out.println(" XmlTolenStream.next(): XML_TEXT '"+_textValue+"'");
+            System.out.printf(" XmlTokenStream.next(): XML_TEXT '%s' %s\n", _textValue, _loc());
             break;
         case XML_END: 
-            System.out.println(" XmlTolenStream.next(): XML_END");
+            System.out.printf(" XmlTokenStream.next(): XML_END %s\n", _loc());
             break;
         default:
             throw new IllegalStateException();
         }
         return n;
     }
+
+    private String _loc() {
+        JsonLocation loc = getCurrentLocation();
+        return String.format("[line: %d, column: %d]", loc.getLineNr(), loc.getColumnNr());
+    }
     */
 
 //    public int next0() throws XMLStreamException
@@ -252,14 +257,17 @@ public class XmlTokenStream
     /**
      * Method used to add virtual wrapping, which just duplicates START_ELEMENT
      * stream points to, and its matching closing element.
-     * 
-     * @since 2.1
      */
     protected void repeatStartElement()
     {
 //System.out.println(" -> repeatStartElement for "+_localName+", _currentWrapper was: "+_currentWrapper);
         // sanity check: can only be used when just returned START_ELEMENT:
         if (_currentState != XML_START_ELEMENT) {
+            // 14-May-2020, tatu: Looks like we DO end up here with empty Lists; if so,
+            //    should NOT actually wrap.
+            if (_currentState == XML_END_ELEMENT) {
+                return;
+            }
             throw new IllegalStateException("Current state not XML_START_ELEMENT ("
                     +XML_START_ELEMENT+") but "+_currentState);
         }
diff --git a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/ListDeser399Test.java b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/ListDeser399Test.java
new file mode 100644
index 00000000..4075ec98
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/ListDeser399Test.java
@@ -0,0 +1,49 @@
+package com.fasterxml.jackson.dataformat.xml.failing;
+
+import java.util.*;
+
+import com.fasterxml.jackson.dataformat.xml.XmlMapper;
+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+public class ListDeser399Test extends XmlTestBase
+{
+    static class Main {
+        @JacksonXmlProperty(localName = "test")
+        @JacksonXmlElementWrapper(useWrapping = false)
+        List<Test> list = new ArrayList<Test>();
+    }
+
+    static class Test {
+        @JacksonXmlProperty(localName = "test")
+        @JacksonXmlElementWrapper(useWrapping = false)
+        List<Test> list = new ArrayList<Test>();
+    }    
+
+    private final XmlMapper MAPPER = newMapper();
+    
+    public void testIssue399() throws Exception {
+        final String XML =
+"<Main>\n" +
+"    <test>\n" +
+"        <test>\n" +
+"            <test>\n" +
+"            </test>\n" +
+//"            <test>\n" +
+//"            </test>\n" +
+"        </test>\n" +
+"    </test>\n" +
+"    <test>\n" +
+"    </test>\n" +
+"</Main>";
+        Main main = MAPPER.readValue(XML, Main.class);
+        assertNotNull(main);
+        assertNotNull(main.list);
+        assertEquals(2, main.list.size());
+        assertNotNull(main.list.get(0));
+        assertNotNull(main.list.get(0).list);
+        assertEquals(1, main.list.get(0).list.size());
+        assertNotNull(main.list.get(1));
+    }
+}
