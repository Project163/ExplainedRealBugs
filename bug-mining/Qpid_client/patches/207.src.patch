diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
index 2f85ccde..b48f4c9e 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
@@ -554,6 +554,12 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
                 if (listener != null) {
                     listener.onConnectionInterrupted(failedURI);
                 }
+                
+                if (!requests.isEmpty()) {
+                	for (FailoverRequest request : requests.values()) {
+                		request.whenOffline(cause);
+                	}
+                }
 
                 // Start watching for request timeouts while we are offline, unless we already are.
                 if (requestTimeoutTask == null) {
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
index d9f57138..4e3128e1 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
@@ -1140,6 +1140,70 @@ public class FailoverIntegrationTest extends QpidJmsTestCase {
         }
     }
 
+    @Test(timeout = 20000)
+    public void testFailoverHandlesDropAfterSessionCloseRequested() throws Exception {
+        try (TestAmqpPeer originalPeer = new TestAmqpPeer()) {
+
+            final CountDownLatch originalConnected = new CountDownLatch(1);
+
+            final String originalURI = createPeerURI(originalPeer);
+
+            LOG.info("Original peer is at: {}", originalURI);
+
+            // Connect to the first peer
+            originalPeer.expectSaslAnonymous();
+            originalPeer.expectOpen();
+            originalPeer.expectBegin();
+
+            final JmsConnection connection = establishAnonymousConnecton(originalPeer);
+            connection.addConnectionListener(new JmsDefaultConnectionListener() {
+                @Override
+                public void onConnectionEstablished(URI remoteURI) {
+                    LOG.info("Connection Established: {}", remoteURI);
+                    if (originalURI.equals(remoteURI.toString())) {
+                        originalConnected.countDown();
+                    }
+                }
+            });
+            connection.start();
+
+            assertTrue("Should connect to original peer", originalConnected.await(5, TimeUnit.SECONDS));
+
+            originalPeer.expectBegin();
+            originalPeer.expectEnd(false);
+            originalPeer.dropAfterLastHandler();
+
+            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+            
+            final CountDownLatch sessionCloseCompleted = new CountDownLatch(1);
+            final AtomicBoolean sessionClosedThrew = new AtomicBoolean();
+            Thread sessionCloseThread = new Thread(new Runnable() {
+				
+				@Override
+				public void run() {
+		            try {
+		            	session.close();
+		            	LOG.debug("Close of session returned ok");
+		            } catch (JMSException jmsEx) {
+		            	LOG.warn("Should not throw on session close when connection drops.", jmsEx);
+		            	sessionClosedThrew.set(true);
+		            } finally {
+		            	sessionCloseCompleted.countDown();
+		            }
+				}
+			}, "Session close thread");
+
+            sessionCloseThread.start();
+
+            originalPeer.waitForAllHandlersToComplete(2000);
+
+            assertTrue("Session close should have completed by now", sessionCloseCompleted.await(3, TimeUnit.SECONDS));
+            assertFalse("Session close should have completed normally", sessionClosedThrew.get());
+            
+            connection.close();
+        }
+    }
+
     @Test(timeout = 20000)
     public void testCreateConsumerFailsWhenLinkRefusedAndAttachResponseWriteIsNotDeferred() throws Exception {
         doCreateConsumerFailsWhenLinkRefusedTestImpl(false);
