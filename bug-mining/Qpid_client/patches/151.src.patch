diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
index de6dc9c0..2bd19477 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
@@ -24,7 +24,6 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -80,6 +79,7 @@ import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
 import org.apache.qpid.jms.provider.ProviderFuture;
 import org.apache.qpid.jms.provider.ProviderListener;
 import org.apache.qpid.jms.provider.ProviderSynchronization;
+import org.apache.qpid.jms.util.QpidJMSThreadFactory;
 import org.apache.qpid.jms.util.ThreadPoolUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -122,14 +122,8 @@ public class JmsConnection implements AutoCloseable, Connection, TopicConnection
         // will also serve as a means of preventing JVM shutdown should a client application
         // not have it's own mechanism for doing so if the configuration specifies that the
         // Connection create this thread as a non-daemon thread.
-        executor = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
-            @Override
-            public Thread newThread(Runnable target) {
-                Thread thread = new Thread(target, "QpidJMS Connection Executor: " + connectionInfo.getId());
-                thread.setDaemon(connectionInfo.isUseDaemonThread());
-                return thread;
-            }
-        });
+        executor = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
+            new QpidJMSThreadFactory("QpidJMS Connection Executor: " + connectionInfo.getId(), connectionInfo.isUseDaemonThread()));
 
         // We need to start the core thread in order for it to prevent JVM shutdown as our
         // single non-daemon thread.
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
index 8faafba3..2f13bf5a 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
@@ -28,7 +28,6 @@ import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
@@ -87,6 +86,7 @@ import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
 import org.apache.qpid.jms.provider.ProviderFuture;
 import org.apache.qpid.jms.selector.SelectorParser;
 import org.apache.qpid.jms.selector.filter.FilterException;
+import org.apache.qpid.jms.util.QpidJMSThreadFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -1067,15 +1067,7 @@ public class JmsSession implements AutoCloseable, Session, QueueSession, TopicSe
     }
 
     private ExecutorService createExecutor(final String threadNameSuffix) {
-        return Executors.newSingleThreadExecutor(new ThreadFactory() {
-            @Override
-            public Thread newThread(Runnable runner) {
-                Thread executor = new Thread(runner);
-                executor.setName("JmsSession ["+ sessionInfo.getId() + "] " + threadNameSuffix);
-                executor.setDaemon(true);
-                return executor;
-            }
-        });
+        return Executors.newSingleThreadExecutor(new QpidJMSThreadFactory("JmsSession ["+ sessionInfo.getId() + "] " + threadNameSuffix, true));
     }
 
     protected JmsSessionInfo getSessionInfo() {
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
index 463e2fe0..c40a2c29 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
@@ -24,7 +24,6 @@ import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -59,6 +58,7 @@ import org.apache.qpid.jms.provider.amqp.builders.AmqpConnectionBuilder;
 import org.apache.qpid.jms.transports.Transport;
 import org.apache.qpid.jms.transports.TransportListener;
 import org.apache.qpid.jms.util.IOExceptionSupport;
+import org.apache.qpid.jms.util.QpidJMSThreadFactory;
 import org.apache.qpid.jms.util.ThreadPoolUtils;
 import org.apache.qpid.proton.engine.Collector;
 import org.apache.qpid.proton.engine.Connection;
@@ -144,19 +144,9 @@ public class AmqpProvider implements Provider, TransportListener , AmqpResourceP
         this.remoteURI = remoteURI;
         this.transport = transport;
 
-        serializer = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
-
-            @Override
-            public Thread newThread(Runnable runner) {
-                Thread serial = new Thread(runner);
-                serial.setDaemon(true);
-                serial.setName(AmqpProvider.this.getClass().getSimpleName() + ":(" +
-                               PROVIDER_SEQUENCE.incrementAndGet() + "):[" +
-                               getRemoteURI().getScheme() + "://" +
-                               getRemoteURI().getHost() + ":" + getRemoteURI().getPort() + "]");
-                return serial;
-            }
-        });
+        serializer = new ScheduledThreadPoolExecutor(1, new QpidJMSThreadFactory(
+            "AmqpProvider :(" + PROVIDER_SEQUENCE.incrementAndGet() + "):[" +
+            remoteURI.getScheme() + "://" + remoteURI.getHost() + ":" + remoteURI.getPort() + "]", true));
 
         serializer.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
         serializer.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
index 73708fb1..b82c6f63 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
@@ -26,7 +26,6 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
@@ -56,6 +55,7 @@ import org.apache.qpid.jms.provider.ProviderListener;
 import org.apache.qpid.jms.provider.ProviderRedirectedException;
 import org.apache.qpid.jms.provider.WrappedAsyncResult;
 import org.apache.qpid.jms.util.IOExceptionSupport;
+import org.apache.qpid.jms.util.QpidJMSThreadFactory;
 import org.apache.qpid.jms.util.ThreadPoolUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -137,34 +137,14 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
     public FailoverProvider(List<URI> uris, Map<String, String> nestedOptions) {
         this.uris = new FailoverUriPool(uris, nestedOptions);
 
-        serializer = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
-
-            @Override
-            public Thread newThread(Runnable runner) {
-                Thread serial = new Thread(runner);
-                serial.setDaemon(true);
-                serial.setName("FailoverProvider: serialization thread");
-                return serial;
-            }
-        });
-
+        serializer = new ScheduledThreadPoolExecutor(1, new QpidJMSThreadFactory("FailoverProvider: serialization thread", true));
         serializer.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
         serializer.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
 
         // All Connection attempts happen in this schedulers thread.  Once a connection
         // is established it will hand the open connection back to the serializer thread
         // for state recovery.
-        connectionHub = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
-
-            @Override
-            public Thread newThread(Runnable runner) {
-                Thread serial = new Thread(runner);
-                serial.setDaemon(true);
-                serial.setName("FailoverProvider: connect thread");
-                return serial;
-            }
-        });
-
+        connectionHub = new ScheduledThreadPoolExecutor(1, new QpidJMSThreadFactory("FailoverProvider: connect thread", true));
         connectionHub.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
         connectionHub.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
     }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/QpidJMSThreadFactory.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/QpidJMSThreadFactory.java
new file mode 100644
index 00000000..6015eef5
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/QpidJMSThreadFactory.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.util;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * Simple ThreadFactory object
+ */
+public class QpidJMSThreadFactory implements ThreadFactory {
+
+    private String threadName;
+    private boolean daemon;
+
+    /**
+     * Creates a new Thread factory that will create threads with the
+     * given name and daemon state.
+     *
+     * @param threadName
+     * 		the name that will be used for each thread created.
+     * @param daemon
+     * 		should the created thread be a daemon thread.
+     */
+    public QpidJMSThreadFactory(String threadName, boolean daemon) {
+        this.threadName = threadName;
+        this.daemon = daemon;
+    }
+
+    @Override
+    public Thread newThread(Runnable target) {
+        Thread thread = new Thread(target, threadName);
+        thread.setDaemon(daemon);
+        return thread;
+    }
+}
