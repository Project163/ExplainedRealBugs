diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
index 3b577a03..463e2fe0 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
@@ -191,6 +191,7 @@ public class AmqpProvider implements Provider, TransportListener , AmqpResourceP
                     SSLContext sslContextOverride = connectionInfo.getSslContextOverride();
 
                     transport.setTransportListener(AmqpProvider.this);
+                    transport.setMaxFrameSize(maxFrameSize);
                     transport.connect(sslContextOverride);
 
                     if (saslLayer) {
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/Transport.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/Transport.java
index c0eaf6f0..b6ad697e 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/Transport.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/Transport.java
@@ -114,4 +114,21 @@ public interface Transport {
      */
     Principal getLocalPrincipal();
 
+    /**
+     * Sets the Maximum Frame Size the transport should accept from the remote.  This option
+     * is not applicable to all transport types, those that support validating the incoming
+     * frame size should apply the configured value.
+     *
+     * @param maxFrameSize
+     * 		The maximum frame size to accept from the remote.
+     */
+    void setMaxFrameSize(int maxFrameSize);
+
+    /**
+     * Returns the currently configured maximum frame size setting.
+     *
+     * @return the current max frame size setting for this transport.
+     */
+    int getMaxFrameSize();
+
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyTcpTransport.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyTcpTransport.java
index 22aaf466..1f170696 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyTcpTransport.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyTcpTransport.java
@@ -64,12 +64,14 @@ public class NettyTcpTransport implements Transport {
 
     private static final Logger LOG = LoggerFactory.getLogger(NettyTcpTransport.class);
 
-    private static final int SHUTDOWN_TIMEOUT = 50;
+    public static final int SHUTDOWN_TIMEOUT = 50;
+    public static final int DEFAULT_MAX_FRAME_SIZE = 65535;
 
     protected Bootstrap bootstrap;
     protected EventLoopGroup group;
     protected Channel channel;
     protected TransportListener listener;
+    protected int maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
 
     private final TransportOptions options;
     private final URI remote;
@@ -290,6 +292,20 @@ public class NettyTcpTransport implements Transport {
         return result;
     }
 
+    @Override
+    public void setMaxFrameSize(int maxFrameSize) {
+        if (connected.get()) {
+            throw new IllegalStateException("Cannot change Max Frame Size while connected.");
+        }
+
+        this.maxFrameSize = maxFrameSize;
+    }
+
+    @Override
+    public int getMaxFrameSize() {
+        return maxFrameSize;
+    }
+
     //----- Internal implementation details, can be overridden as needed -----//
 
     protected String getRemoteHost() {
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyWsTransport.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyWsTransport.java
index 3eff1430..d0871d24 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyWsTransport.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/transports/netty/NettyWsTransport.java
@@ -115,7 +115,8 @@ public class NettyWsTransport extends NettyTcpTransport {
 
         public NettyWebSocketTransportHandler() {
             handshaker = WebSocketClientHandshakerFactory.newHandshaker(
-                getRemoteLocation(), WebSocketVersion.V13, AMQP_SUB_PROTOCOL, true, new DefaultHttpHeaders());
+                getRemoteLocation(), WebSocketVersion.V13, AMQP_SUB_PROTOCOL,
+                true, new DefaultHttpHeaders(), getMaxFrameSize());
         }
 
         @Override
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyServer.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyServer.java
index e7a34607..dd383a6c 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyServer.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyServer.java
@@ -85,6 +85,7 @@ public abstract class NettyServer implements AutoCloseable {
     private int serverPort;
     private final boolean needClientAuth;
     private final boolean webSocketServer;
+    private int maxFrameSize = NettyTcpTransport.DEFAULT_MAX_FRAME_SIZE;
     private String webSocketPath = WEBSOCKET_PATH;
     private volatile SslHandler sslHandler;
 
@@ -120,6 +121,14 @@ public abstract class NettyServer implements AutoCloseable {
         this.webSocketPath = webSocketPath;
     }
 
+    public int getMaxFrameSize() {
+        return maxFrameSize;
+    }
+
+    public void setMaxFrameSize(int maxFrameSize) {
+        this.maxFrameSize = maxFrameSize;
+    }
+
     protected URI getConnectionURI() throws Exception {
         if (!started.get()) {
             throw new IllegalStateException("Cannot get URI of non-started server");
@@ -183,7 +192,7 @@ public abstract class NettyServer implements AutoCloseable {
                     if (webSocketServer) {
                         ch.pipeline().addLast(new HttpServerCodec());
                         ch.pipeline().addLast(new HttpObjectAggregator(65536));
-                        ch.pipeline().addLast(new WebSocketServerProtocolHandler(getWebSocketPath(), "amqp", true));
+                        ch.pipeline().addLast(new WebSocketServerProtocolHandler(getWebSocketPath(), "amqp", true, maxFrameSize));
                     }
 
                     ch.pipeline().addLast(new NettyServerOutboundHandler());
@@ -270,7 +279,6 @@ public abstract class NettyServer implements AutoCloseable {
                     public void operationComplete(Future<Channel> future) throws Exception {
                         LOG.info("Server -> SSL handshake completed. Succeeded: {}", future.isSuccess());
                         if (!future.isSuccess()) {
-                            sslHandler.close();
                             ctx.close();
                         }
                     }
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyWsTransportTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyWsTransportTest.java
index 5201381d..a50728d8 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyWsTransportTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/transports/netty/NettyWsTransportTest.java
@@ -22,7 +22,10 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
 
+import org.apache.qpid.jms.test.Wait;
 import org.apache.qpid.jms.transports.Transport;
 import org.apache.qpid.jms.transports.TransportListener;
 import org.apache.qpid.jms.transports.TransportOptions;
@@ -30,6 +33,9 @@ import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
 /**
  * Test the Netty based WebSocket Transport
  */
@@ -51,7 +57,7 @@ public class NettyWsTransportTest extends NettyTcpTransportTest {
         }
     }
 
-    @Test(timeout = 60 * 1000)
+    @Test(timeout = 60000)
     public void testConnectToServerUsingCorrectPath() throws Exception {
         final String WEBSOCKET_PATH = "/testpath";
 
@@ -84,7 +90,7 @@ public class NettyWsTransportTest extends NettyTcpTransportTest {
         assertTrue(data.isEmpty());
     }
 
-    @Test(timeout = 60 * 1000)
+    @Test(timeout = 60000)
     public void testConnectToServerUsingIncorrectPath() throws Exception {
         final String WEBSOCKET_PATH = "/testpath";
 
@@ -114,4 +120,124 @@ public class NettyWsTransportTest extends NettyTcpTransportTest {
         assertTrue(exceptions.isEmpty());
         assertTrue(data.isEmpty());
     }
+
+    @Test(timeout = 60000)
+    public void testConnectionsSendReceiveLargeDataWhenFrameSizeAllowsIt() throws Exception {
+        final int FRAME_SIZE = 8192;
+
+        ByteBuf sendBuffer = Unpooled.buffer(FRAME_SIZE);
+        for (int i = 0; i < FRAME_SIZE; ++i) {
+            sendBuffer.writeByte('A');
+        }
+
+        try (NettyEchoServer server = createEchoServer(createServerOptions())) {
+            // Server should pass the data through without issue with this size
+            server.setMaxFrameSize(FRAME_SIZE);
+            server.start();
+
+            int port = server.getServerPort();
+            URI serverLocation = new URI("tcp://localhost:" + port);
+
+            List<Transport> transports = new ArrayList<Transport>();
+
+            Transport transport = createTransport(serverLocation, testListener, createClientOptions());
+            try {
+                // The transport should allow for the size of data we sent.
+                transport.setMaxFrameSize(FRAME_SIZE);
+                transport.connect(null);
+                transport.send(sendBuffer.copy());
+                transports.add(transport);
+            } catch (Exception e) {
+                fail("Should have connected to the server at " + serverLocation + " but got exception: " + e);
+            }
+
+            assertTrue(Wait.waitFor(new Wait.Condition() {
+
+                @Override
+                public boolean isSatisified() throws Exception {
+                    LOG.debug("Checking completion: read {} expecting {}", bytesRead.get(), FRAME_SIZE);
+                    return bytesRead.get() == FRAME_SIZE || !transport.isConnected();
+                }
+            }));
+
+            assertTrue("Connection failed while receiving.", transport.isConnected());
+
+            transport.close();
+        }
+
+        assertTrue(exceptions.isEmpty());
+    }
+
+    @Test(timeout = 60000)
+    public void testConnectionsSendReceiveLargeDataFailsDueToMaxFrameSize() throws Exception {
+        final int FRAME_SIZE = 1024;
+
+        ByteBuf sendBuffer = Unpooled.buffer(FRAME_SIZE);
+        for (int i = 0; i < FRAME_SIZE; ++i) {
+            sendBuffer.writeByte('A');
+        }
+
+        try (NettyEchoServer server = createEchoServer(createServerOptions())) {
+            // Server should pass the data through, client should choke on the incoming size.
+            server.setMaxFrameSize(FRAME_SIZE);
+            server.start();
+
+            int port = server.getServerPort();
+            URI serverLocation = new URI("tcp://localhost:" + port);
+
+            List<Transport> transports = new ArrayList<Transport>();
+
+            Transport transport = createTransport(serverLocation, testListener, createClientOptions());
+            try {
+                // Transport can't receive anything bigger so it should fail the connection
+                // when data arrives that is larger than this value.
+                transport.setMaxFrameSize(FRAME_SIZE / 2);
+                transport.connect(null);
+                transport.send(sendBuffer.copy());
+                transports.add(transport);
+            } catch (Exception e) {
+                fail("Should have connected to the server at " + serverLocation + " but got exception: " + e);
+            }
+
+            assertTrue("Transport should have lost connection", Wait.waitFor(() -> !transport.isConnected()));
+        }
+
+        assertFalse(exceptions.isEmpty());
+    }
+
+    @Test(timeout = 60000)
+    public void testTransportDetectsConnectionDropWhenServerEnforcesMaxFrameSize() throws Exception {
+        final int FRAME_SIZE = 1024;
+
+        ByteBuf sendBuffer = Unpooled.buffer(FRAME_SIZE);
+        for (int i = 0; i < FRAME_SIZE; ++i) {
+            sendBuffer.writeByte('A');
+        }
+
+        try (NettyEchoServer server = createEchoServer(createServerOptions())) {
+            // Server won't accept the data as it's to large and will close the connection.
+            server.setMaxFrameSize(FRAME_SIZE / 2);
+            server.start();
+
+            int port = server.getServerPort();
+            URI serverLocation = new URI("tcp://localhost:" + port);
+
+            List<Transport> transports = new ArrayList<Transport>();
+
+            Transport transport = createTransport(serverLocation, testListener, createClientOptions());
+            try {
+                // Transport allows bigger frames in so that server is the one causing the failure.
+                transport.setMaxFrameSize(FRAME_SIZE);
+                transport.connect(null);
+                transport.send(sendBuffer.copy());
+                transports.add(transport);
+            } catch (Exception e) {
+                fail("Should have connected to the server at " + serverLocation + " but got exception: " + e);
+            }
+
+            assertTrue("Transport should have lost connection", Wait.waitFor(() -> !transport.isConnected()));
+        }
+
+        assertFalse(exceptions.isEmpty());
+    }
 }
