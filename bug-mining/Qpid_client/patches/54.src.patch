diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
index 6f72eae2..a264a7fd 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
@@ -62,7 +62,7 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
     protected final Lock lock = new ReentrantLock();
     protected final AtomicBoolean suspendedConnection = new AtomicBoolean();
     protected final AtomicBoolean delivered = new AtomicBoolean();
-    protected Exception failureCause;
+    protected volatile Exception failureCause;
 
     /**
      * Create a non-durable MessageConsumer
@@ -278,8 +278,7 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                 }
 
                 if (envelope == null) {
-                    // TODO: why only if timeout == 0 ?
-                    if (failureCause != null && !messageQueue.isClosed() && timeout == 0) {
+                    if (failureCause != null) {
                         LOG.debug("{} receive failed: {}", getConsumerId(), failureCause.getMessage());
                         throw JmsExceptionSupport.create(failureCause);
                     }
@@ -290,10 +289,15 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
                     }
 
-                    pullForced = true;
                     //TODO: don't do this if stopped, etc
                     //TODO: make it optional/configurable not to do this at all?
-                    performPullIfRequired(timeout, true);
+                    if(timeout >= 0) {
+                        // We don't do this for receive with no timeout since it
+                        // already occurred for zero-prefetch consumers, and
+                        // the rest block indefinitely on the local messageQueue
+                        pullForced = true;
+                        performPullIfRequired(timeout, true);
+                    }
                     //TODO: do we need to reset pullForced, if there are e.g expired etc messages received and then filtered after the pull?
 
                     // TODO: refresh credit if needed, since the above drains it.
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
index 39f361e0..75fe3735 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
@@ -19,11 +19,18 @@
 package org.apache.qpid.jms.integration;
 
 import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.notNullValue;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 import javax.jms.Connection;
 import javax.jms.IllegalStateException;
+import javax.jms.JMSException;
 import javax.jms.Message;
 import javax.jms.MessageConsumer;
 import javax.jms.MessageListener;
@@ -34,15 +41,22 @@ import javax.jms.Topic;
 
 import org.apache.qpid.jms.test.QpidJmsTestCase;
 import org.apache.qpid.jms.test.Wait;
+import org.apache.qpid.jms.test.testpeer.AmqpPeerRunnable;
 import org.apache.qpid.jms.test.testpeer.TestAmqpPeer;
 import org.apache.qpid.jms.test.testpeer.basictypes.AmqpError;
 import org.apache.qpid.jms.test.testpeer.describedtypes.sections.AmqpValueDescribedType;
 import org.apache.qpid.jms.test.testpeer.matchers.ModifiedMatcher;
 import org.apache.qpid.jms.test.testpeer.matchers.ReleasedMatcher;
 import org.apache.qpid.proton.amqp.DescribedType;
+import org.apache.qpid.proton.amqp.UnsignedInteger;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class ConsumerIntegrationTest extends QpidJmsTestCase {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ConsumerIntegrationTest.class);
+
     private final IntegrationTestFixture testFixture = new IntegrationTestFixture();
 
     @Test(timeout = 20000)
@@ -256,4 +270,88 @@ public class ConsumerIntegrationTest extends QpidJmsTestCase {
             connection.close();
         }
     }
+
+    @Test(timeout=20000)
+    public void testConsumerReceiveThrowsIfConnectionLost() throws Exception {
+        doConsumerReceiveThrowsIfConnectionLostTestImpl(false);
+    }
+
+    @Test(timeout=20000)
+    public void testConsumerTimedReceiveThrowsIfConnectionLost() throws Exception {
+        doConsumerReceiveThrowsIfConnectionLostTestImpl(true);
+    }
+
+    private void doConsumerReceiveThrowsIfConnectionLostTestImpl(boolean useTimeout) throws JMSException, Exception, IOException {
+        final CountDownLatch consumerReady = new CountDownLatch(1);
+
+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
+            Connection connection = testFixture.establishConnecton(testPeer);
+            connection.start();
+
+            testPeer.expectBegin();
+
+            Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
+            Queue queue = session.createQueue("queue");
+            connection.start();
+
+            testPeer.expectReceiverAttach();
+            testPeer.expectLinkFlow();
+            testPeer.runAfterLastHandler(new AmqpPeerRunnable() {
+                @Override
+                public void run() {
+                    try {
+                        consumerReady.await(2000, TimeUnit.MILLISECONDS);
+                    } catch (InterruptedException e) {
+                        LOG.warn("interrupted while waiting");
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            });
+            testPeer.dropAfterLastHandler(10);
+
+            final MessageConsumer consumer = session.createConsumer(queue);
+            consumerReady.countDown();
+
+            try {
+                if (useTimeout) {
+                    consumer.receive(100000);
+                } else {
+                    consumer.receive();
+                }
+
+                fail("An exception should have been thrown");
+            } catch (JMSException jmse) {
+                // Expected
+            }
+        }
+    }
+
+    @Test(timeout=20000)
+    public void testConsumerReceiveNoWaitThrowsIfConnectionLost() throws Exception {
+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
+            Connection connection = testFixture.establishConnecton(testPeer);
+            connection.start();
+
+            testPeer.expectBegin();
+
+            Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
+            Queue queue = session.createQueue("queue");
+            connection.start();
+
+            testPeer.expectReceiverAttach();
+            testPeer.expectLinkFlow(false, notNullValue(UnsignedInteger.class));
+            testPeer.expectLinkFlow(true, notNullValue(UnsignedInteger.class));
+            testPeer.dropAfterLastHandler();
+
+            final MessageConsumer consumer = session.createConsumer(queue);
+
+            try {
+                consumer.receiveNoWait();
+
+                fail("An exception should have been thrown");
+            } catch (JMSException jmse) {
+                // Expected
+            }
+        }
+    }
 }
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
index 040cded6..45c840c5 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
@@ -1674,10 +1674,24 @@ public class TestAmqpPeer implements AutoCloseable
         addHandler(new HeaderHandlerImpl(AmqpHeader.SASL_HEADER, AmqpHeader.SASL_HEADER, exitAfterHeader));
     }
 
+
     public void dropAfterLastHandler() {
+        dropAfterLastHandler(0);
+    }
+
+    public void dropAfterLastHandler(final long delay) {
         AmqpPeerRunnable exitEarly = new AmqpPeerRunnable() {
             @Override
             public void run() {
+                if(delay > 0) {
+                    try {
+                        Thread.sleep(delay);
+                    } catch (InterruptedException e) {
+                        LOGGER.warn("Interrupted while delaying before read loop exit");
+                        Thread.currentThread().interrupt();
+                    }
+                }
+
                 _driverRunnable.exitReadLoopEarly();
             }
         };
