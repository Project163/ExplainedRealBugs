diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
index d6fd9b40..5c4ef135 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
@@ -33,6 +33,7 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 import javax.jms.JMSException;
+import javax.jms.JMSSecurityException;
 
 import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
 import org.apache.qpid.jms.message.JmsMessageFactory;
@@ -501,16 +502,16 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
         LOG.debug("handling Provider failure: {}", cause.getMessage());
         LOG.trace("stack", cause);
 
-        this.provider.setProviderListener(closedListener);
+        provider.setProviderListener(closedListener);
         URI failedURI = this.provider.getRemoteURI();
         try {
-            this.provider.close();
+            provider.close();
         } catch (Throwable error) {
             LOG.trace("Caught exception while closing failed provider: {}", error.getMessage());
         }
-        this.provider = null;
+        provider = null;
 
-        if (reconnectAllowed()) {
+        if (reconnectAllowed(cause)) {
 
             if (cause instanceof ProviderRedirectedException) {
                 ProviderRedirectedException redirect = (ProviderRedirectedException) cause;
@@ -669,7 +670,15 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
         });
     }
 
-    private boolean reconnectAllowed() {
+    private boolean reconnectAllowed(IOException cause) {
+        // If a connection attempts fail due to Security errors than
+        // we abort reconnection as there is a configuration issue and
+        // we want to avoid a spinning reconnect cycle that can never
+        // complete.
+        if (cause.getCause() instanceof JMSSecurityException) {
+            return false;
+        }
+
         return reconnectAttemptLimit() != 0;
     }
 
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
index ce4efc3e..e1060088 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/failover/FailoverIntegrationTest.java
@@ -23,6 +23,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.net.URI;
 import java.util.Enumeration;
@@ -33,6 +34,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import javax.jms.Connection;
 import javax.jms.ConnectionFactory;
 import javax.jms.JMSException;
+import javax.jms.JMSSecurityException;
 import javax.jms.Message;
 import javax.jms.MessageConsumer;
 import javax.jms.MessageProducer;
@@ -46,6 +48,7 @@ import org.apache.qpid.jms.JmsDefaultConnectionListener;
 import org.apache.qpid.jms.JmsPrefetchPolicy;
 import org.apache.qpid.jms.test.QpidJmsTestCase;
 import org.apache.qpid.jms.test.testpeer.TestAmqpPeer;
+import org.apache.qpid.jms.test.testpeer.basictypes.AmqpError;
 import org.apache.qpid.jms.test.testpeer.describedtypes.Accepted;
 import org.apache.qpid.jms.test.testpeer.describedtypes.sections.AmqpValueDescribedType;
 import org.apache.qpid.jms.test.testpeer.matchers.sections.MessageAnnotationsSectionMatcher;
@@ -61,6 +64,26 @@ public class FailoverIntegrationTest extends QpidJmsTestCase {
 
     private static final Logger LOG = LoggerFactory.getLogger(FailoverIntegrationTest.class);
 
+    @Test(timeout = 20000)
+    public void testConnectSecurityViolation() throws Exception {
+
+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
+
+            testPeer.rejectConnect(AmqpError.UNAUTHORIZED_ACCESS, "Anonymous connections not allowed", null);
+
+            final JmsConnection connection = establishAnonymousConnecton(testPeer);
+            try {
+                connection.start();
+                fail("Should have thrown JMSSecurityException");
+            } catch (JMSSecurityException ex) {
+            } catch (Exception ex) {
+                fail("Should have thrown JMSSecurityException: " + ex);
+            }
+
+            testPeer.waitForAllHandlersToComplete(1000);
+        }
+    }
+
     @Test(timeout = 20000)
     public void testFailoverHandlesImmediateTransportDropAfterConnect() throws Exception {
         try (TestAmqpPeer originalPeer = new TestAmqpPeer();
