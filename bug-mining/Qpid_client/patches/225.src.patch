diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
index c25f86ad..d3b30c5b 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsSession.java
@@ -376,6 +376,14 @@ public class JmsSession implements AutoCloseable, Session, QueueSession, TopicSe
                     LOG.trace("Session close awaiting send completions was interrupted");
                 }
 
+                try {
+                    if (getSessionMode() == Session.CLIENT_ACKNOWLEDGE) {
+                        acknowledge(ACK_TYPE.MODIFIED_FAILED);
+                    }
+                } catch (Exception e) {
+                    LOG.trace("Exception during session shutdown cleanup acknowledgement", e);
+                }
+
                 if (shutdownError != null) {
                     throw shutdownError;
                 }
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/AmqpAcknowledgementsIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/AmqpAcknowledgementsIntegrationTest.java
index 0c0b2335..c040edd7 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/AmqpAcknowledgementsIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/AmqpAcknowledgementsIntegrationTest.java
@@ -73,13 +73,15 @@ public class AmqpAcknowledgementsIntegrationTest extends QpidJmsTestCase {
 
             testPeer.expectReceiverAttach();
             testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType(null), 1);
-            testPeer.expectEnd();
 
             MessageConsumer messageConsumer = session.createConsumer(queue);
 
             Message receivedMessage = messageConsumer.receive(6000);
             assertNotNull("Message was not recieved", receivedMessage);
 
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 1, 1);
+            testPeer.expectEnd();
+
             session.close();
 
             try {
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
index 7be79eb7..e04b8f64 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConsumerIntegrationTest.java
@@ -1755,6 +1755,89 @@ public class ConsumerIntegrationTest extends QpidJmsTestCase {
         }
     }
 
+    @Test(timeout=20000)
+    public void testConsumerWithDeferredCloseAcksDeliveryFailedAsSessionClosed() throws Exception {
+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
+            final int DEFAULT_PREFETCH = 100;
+
+            // Set to fixed known value to reduce breakage if defaults are changed.
+            Connection connection = testFixture.establishConnecton(testPeer, "jms.prefetchPolicy.all=" + DEFAULT_PREFETCH);
+            connection.start();
+
+            testPeer.expectBegin();
+
+            Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
+            Queue queue = session.createQueue(getTestName());
+
+            int messageCount = 5;
+
+            testPeer.expectReceiverAttach();
+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType("content"), messageCount);
+
+            final CountDownLatch expected = new CountDownLatch(messageCount);
+            ((JmsConnection) connection).addConnectionListener(new JmsDefaultConnectionListener() {
+                @Override
+                public void onInboundMessage(JmsInboundMessageDispatch envelope) {
+                    expected.countDown();
+                }
+            });
+
+            MessageConsumer consumer = session.createConsumer(queue);
+
+            int consumeCount = 3;
+            Message receivedMessage = null;
+
+            for (int i = 1; i <= consumeCount; i++) {
+                receivedMessage = consumer.receive(3000);
+
+                assertNotNull(receivedMessage);
+                assertTrue(receivedMessage instanceof TextMessage);
+            }
+
+            // Ensure all the messages arrived so that the matching below is deterministic
+            assertTrue("Expected transfers didnt occur: " + expected.getCount(), expected.await(5, TimeUnit.SECONDS));
+
+            // Expect the client to then drain off all credit from the link.
+            testPeer.expectLinkFlow(true, true, equalTo(UnsignedInteger.valueOf(DEFAULT_PREFETCH - messageCount)));
+
+            // Expect the prefetched messages to be released for dispatch elsewhere.
+            testPeer.expectDisposition(true, new ReleasedMatcher(), 4, 4);
+            testPeer.expectDisposition(true, new ReleasedMatcher(), 5, 5);
+
+            // Close should be deferred as these messages were delivered but not acknowledged.
+            consumer.close();
+
+            testPeer.waitForAllHandlersToComplete(3000);
+
+            // Should not be able to consume from the consumer once closed.
+            try {
+                consumer.receive();
+                fail("Should throw as this consumer is closed.");
+            } catch (IllegalStateException ise) {}
+
+            try {
+                consumer.receive(100);
+                fail("Should throw as this consumer is closed.");
+            } catch (IllegalStateException ise) {}
+
+            try {
+                consumer.receiveNoWait();
+                fail("Should throw as this consumer is closed.");
+            } catch (IllegalStateException ise) {}
+
+            // Now the delivered messages should be acknowledged as session shuts down.
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 1, 1);
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 2, 2);
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 3, 3);
+            testPeer.expectDetach(true, true, true);
+
+            testPeer.expectClose();
+            connection.close();
+
+            testPeer.waitForAllHandlersToComplete(3000);
+        }
+    }
+
     @Test(timeout=20000)
     public void testDeferredCloseTimeoutAlertsExceptionListener() throws Exception {
         try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
@@ -1835,7 +1918,7 @@ public class ConsumerIntegrationTest extends QpidJmsTestCase {
             assertNotNull(receivedMessage);
             assertTrue(receivedMessage instanceof TextMessage);
 
-            testPeer.waitForAllHandlersToComplete(3000);
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 1, 1);
             testPeer.expectEnd();
 
             session.close();
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
index 6ca6fc54..a5bca624 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
@@ -2269,4 +2269,55 @@ public class SessionIntegrationTest extends QpidJmsTestCase {
             connection.close();
         }
     }
+
+    @Test(timeout = 20000)
+    public void testCloseSessionWithWithUnackedClientAckMessages() throws Exception {
+        doCloseWithWithUnackedClientAckMessagesTestImpl(true);
+    }
+
+    @Test(timeout = 20000)
+    public void testCloseConnectionWithUnackedClientAckMessages() throws Exception {
+        doCloseWithWithUnackedClientAckMessagesTestImpl(false);
+    }
+
+    private void doCloseWithWithUnackedClientAckMessagesTestImpl(boolean closeSession) throws JMSException, Exception, IOException {
+        try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
+            Connection connection = testFixture.establishConnecton(testPeer, false, "?jms.clientID=myClientId", null, null, false);
+            connection.start();
+
+            testPeer.expectBegin();
+
+            Session session = connection.createSession(Session.CLIENT_ACKNOWLEDGE);
+
+            String subscriptionName = "mySubName";
+            String topicName = "myTopic";
+            Topic topic = session.createTopic(topicName);
+
+            int msgCount = 2;
+            testPeer.expectDurableSubscriberAttach(topicName, subscriptionName);
+            testPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, new AmqpValueDescribedType("content"), msgCount, false, false,
+                    Matchers.greaterThanOrEqualTo(UnsignedInteger.valueOf(msgCount)), 1, false, true);
+
+            MessageConsumer subscriber = session.createDurableConsumer(topic, subscriptionName);
+
+            TextMessage receivedTextMessage = null;
+            assertNotNull("Expected a message", receivedTextMessage = (TextMessage) subscriber.receive(3000));
+            assertEquals("Unexpected delivery number", 1,  receivedTextMessage.getIntProperty(TestAmqpPeer.MESSAGE_NUMBER) + 1);
+            assertNotNull("Expected a message", receivedTextMessage = (TextMessage) subscriber.receive(3000));
+            assertEquals("Unexpected delivery number", 2,  receivedTextMessage.getIntProperty(TestAmqpPeer.MESSAGE_NUMBER) + 1);
+
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 1, 1);
+            testPeer.expectDisposition(true, new ModifiedMatcher().withDeliveryFailed(equalTo(true)), 2, 2);
+
+            if(closeSession) {
+                testPeer.expectEnd();
+
+                session.close();
+            }
+
+            testPeer.expectClose();
+
+            connection.close();
+        }
+    }
 }
