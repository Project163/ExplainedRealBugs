diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
index b3ae7f36..f3f7740a 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
@@ -226,16 +226,7 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
             timeout = -1;
         }
 
-        sendPullCommand(timeout);
-
-        JmsInboundMessageDispatch envelope = null;
-        if (isPullConsumer()) {
-            envelope = dequeue(-1); // Let server tell us if empty.
-        } else {
-            envelope = dequeue(timeout); // Check local prefetch only.
-        }
-
-        return copy(ackFromReceive(envelope));
+        return copy(ackFromReceive(dequeue(timeout)));
     }
 
     /**
@@ -247,16 +238,7 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
     public Message receiveNoWait() throws JMSException {
         checkClosed();
         checkMessageListener();
-        sendPullCommand(0);
-
-        JmsInboundMessageDispatch envelope = null;
-        if (isPullConsumer()) {
-            envelope = dequeue(-1); // Let server tell us if empty.
-        } else {
-            envelope = dequeue(0); // Check local prefetch only.
-        }
-
-        return copy(ackFromReceive(envelope));
+        return copy(ackFromReceive(dequeue(0)));
     }
 
     /**
@@ -281,8 +263,16 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                 deadline = System.currentTimeMillis() + timeout;
             }
 
+            sendPullCommand(timeout);
+
             while (true) {
-                JmsInboundMessageDispatch envelope = messageQueue.dequeue(timeout);
+                JmsInboundMessageDispatch envelope = null;
+                if (isPullConsumer()) {
+                    envelope = messageQueue.dequeue(-1);
+                } else {
+                    envelope = messageQueue.dequeue(timeout);
+                }
+
                 if (envelope == null) {
                     if (timeout > 0 && !messageQueue.isClosed()) {
                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
@@ -305,9 +295,8 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                     }
                     sendPullCommand(timeout);
                 } else if (redeliveryExceeded(envelope)) {
-                    LOG.debug("{} received with excessive redelivered: {}", getConsumerId(), envelope);
-                    // TODO - Future
-                    // Reject this delivery as not deliverable here
+                    LOG.debug("{} filtered message with excessive redelivery count: {}", getConsumerId(), envelope);
+                    doAckUndeliverable(envelope);
                     if (timeout > 0) {
                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
                     }
@@ -334,10 +323,12 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
     }
 
     protected boolean redeliveryExceeded(JmsInboundMessageDispatch envelope) {
-        // TODO - Future
-        // Check for message that have been redelivered to see if they exceed
-        // some set maximum redelivery count
-        return false;
+        LOG.info("checking envelope with {} redeliveries", envelope.getRedeliveryCount());
+
+        JmsRedeliveryPolicy redeliveryPolicy = consumerInfo.getRedeliveryPolicy();
+        return redeliveryPolicy != null &&
+               redeliveryPolicy.getMaxRedeliveries() != JmsRedeliveryPolicy.DEFAULT_MAX_REDELIVERIES &&
+               redeliveryPolicy.getMaxRedeliveries() < envelope.getRedeliveryCount();
     }
 
     protected void checkClosed() throws IllegalStateException {
@@ -409,6 +400,15 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
         }
     }
 
+    private void doAckUndeliverable(final JmsInboundMessageDispatch envelope) throws JMSException {
+        try {
+            session.acknowledge(envelope, ACK_TYPE.POISONED);
+        } catch (JMSException ex) {
+            session.onException(ex);
+            throw ex;
+        }
+    }
+
     private void doAckReleased(final JmsInboundMessageDispatch envelope) throws JMSException {
         try {
             session.acknowledge(envelope, ACK_TYPE.RELEASED);
@@ -690,6 +690,9 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                     if (consumeExpiredMessage(envelope)) {
                         LOG.trace("{} filtered expired message: {}", getConsumerId(), envelope);
                         doAckExpired(envelope);
+                    } else if (redeliveryExceeded(envelope)) {
+                        LOG.trace("{} filtered message with excessive redlivery count: {}", getConsumerId(), envelope);
+                        doAckUndeliverable(envelope);
                     } else {
                         boolean autoAckOrDupsOk = acknowledgementMode == Session.AUTO_ACKNOWLEDGE ||
                                                   acknowledgementMode == Session.DUPS_OK_ACKNOWLEDGE;
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/message/JmsInboundMessageDispatch.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/message/JmsInboundMessageDispatch.java
index 817c3c1f..0f0f1eea 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/message/JmsInboundMessageDispatch.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/message/JmsInboundMessageDispatch.java
@@ -62,6 +62,16 @@ public class JmsInboundMessageDispatch extends JmsAbstractResourceId {
         return enqueueFirst;
     }
 
+    public int getRedeliveryCount() {
+        int redeliveryCount = 0;
+
+        if (message != null) {
+            redeliveryCount = message.getFacade().getRedeliveryCount();
+        }
+
+        return redeliveryCount;
+    }
+
     @Override
     public String toString() {
         return "JmsInboundMessageDispatch {sequence = " + sequence
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
index 7710ec29..ec3a7860 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
@@ -423,6 +423,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
                     public void run() {
                         if (getEndpoint().getRemoteCredit() != 0) {
                             getEndpoint().drain(0);
+                            session.getProvider().pumpToProtonTransport();
                         }
                     }
                 }, timeout);
@@ -479,17 +480,6 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
     private void processDelivery(Delivery incoming) throws Exception {
         setDefaultDeliveryState(incoming, Released.getInstance());
         Message amqpMessage = decodeIncomingMessage(incoming);
-        long deliveryCount = amqpMessage.getDeliveryCount();
-        int maxRedeliveries = getJmsResource().getRedeliveryPolicy().getMaxRedeliveries();
-
-        if (maxRedeliveries >= 0 && deliveryCount > maxRedeliveries) {
-            LOG.trace("{} rejecting delivery that exceeds max redelivery count. {}", this, amqpMessage.getMessageId());
-            deliveryFailed(incoming);
-            return;
-        } else {
-            getEndpoint().advance();
-        }
-
         JmsMessage message = null;
         try {
             message = AmqpJmsMessageBuilder.createJmsMessage(this, amqpMessage);
@@ -504,6 +494,8 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
             return;
         }
 
+        getEndpoint().advance();
+
         // Let the message do any final processing before sending it onto a consumer.
         // We could defer this to a later stage such as the JmsConnection or even in
         // the JmsMessageConsumer dispatch method if we needed to.
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
index ff36ab3f..f6ef9ed0 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
@@ -815,7 +815,11 @@ public class AmqpProvider implements Provider, TransportListener {
         }
     }
 
-    private boolean pumpToProtonTransport(AsyncResult request) {
+    protected boolean pumpToProtonTransport() {
+        return pumpToProtonTransport(NOOP_REQUEST);
+    }
+
+    protected boolean pumpToProtonTransport(AsyncResult request) {
         try {
             boolean done = false;
             while (!done) {
@@ -1087,7 +1091,7 @@ public class AmqpProvider implements Provider, TransportListener {
                 long now = System.currentTimeMillis();
                 long deadline = protonTransport.tick(now);
 
-                boolean pumpSucceeded = pumpToProtonTransport(NOOP_REQUEST);
+                boolean pumpSucceeded = pumpToProtonTransport();
 
                 if (protonTransport.isClosed()) {
                     LOG.info("IdleTimeoutCheck closed the transport due to the peer exceeding our requested idle-timeout.");
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
index e7e5beaf..6b91559a 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
@@ -927,7 +927,8 @@ public class SessionIntegrationTest extends QpidJmsTestCase {
                 testPeer.expectDisposition(true, modified);
             }
 
-            session.createConsumer(queue);
+            MessageConsumer consumer = session.createConsumer(queue);
+            consumer.receive(100);
 
             testPeer.waitForAllHandlersToComplete(1000);
         }
