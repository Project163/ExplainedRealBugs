diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAbstractResource.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAbstractResource.java
index 29bff501..336a296a 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAbstractResource.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAbstractResource.java
@@ -37,61 +37,24 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
 
     private static final Logger LOG = LoggerFactory.getLogger(AmqpAbstractResource.class);
 
-    protected AsyncResult openRequest;
     protected AsyncResult closeRequest;
 
-    private E endpoint;
-    protected R resource;
-
-    /**
-     * Creates a new instance with the JmsResource provided, and sets the Endpoint to null.
-     *
-     * @param resource
-     *        The JmsResource instance that this AmqpResource is managing.
-     */
-    public AmqpAbstractResource(R resource) {
-        this(resource, null);
-    }
+    private final E endpoint;
+    private final R resourceInfo;
 
     /**
      * Creates a new instance with the JmsResource provided, and sets the Endpoint to the given value.
      *
-     * @param resource
+     * @param resourceInfo
      *        The JmsResource instance that this AmqpResource is managing.
      * @param endpoint
      *        The Proton Endpoint instance that this object maps to.
      */
-    public AmqpAbstractResource(R resource, E endpoint) {
-        this.resource = resource;
-        setEndpoint(endpoint);
-    }
-
-    @Override
-    public void open(AsyncResult request) {
-        this.openRequest = request;
-        doOpen();
-        getEndpoint().setContext(this);
-    }
-
-    @Override
-    public boolean isOpen() {
-        return getEndpoint().getRemoteState() == EndpointState.ACTIVE;
-    }
-
-    @Override
-    public boolean isAwaitingOpen() {
-        return this.openRequest != null;
-    }
-
-    @Override
-    public void opened() {
-        if (this.openRequest != null) {
-            this.openRequest.onSuccess();
-            this.openRequest = null;
-        }
+    public AmqpAbstractResource(R resourceInfo, E endpoint) {
+        this.resourceInfo = resourceInfo;
+        this.endpoint = endpoint;
     }
 
-    @Override
     public void close(AsyncResult request) {
         // If already closed signal success or else the caller might never get notified.
         if (getEndpoint().getLocalState() == EndpointState.CLOSED ||
@@ -111,18 +74,7 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
         doClose();
     }
 
-    @Override
-    public boolean isClosed() {
-        return getEndpoint().getLocalState() == EndpointState.CLOSED;
-    }
-
-    @Override
-    public boolean isAwaitingClose() {
-        return this.closeRequest != null;
-    }
-
-    @Override
-    public void closed() {
+    public void resourceClosed() {
         endpoint.close();
         endpoint.free();
 
@@ -132,25 +84,6 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
         }
     }
 
-    @Override
-    public void failed(Exception cause) {
-        if (openRequest != null) {
-            if (endpoint != null) {
-                // TODO: if this is a producer/consumer link then we may only be detached,
-                // rather than fully closed, and should respond appropriately.
-                endpoint.close();
-            }
-            openRequest.onFailure(cause);
-            openRequest = null;
-        }
-
-        if (closeRequest != null) {
-            closeRequest.onFailure(cause);
-            closeRequest = null;
-        }
-    }
-
-    @Override
     public void remotelyClosed(AmqpProvider provider) {
         Exception error = AmqpSupport.convertToException(getEndpoint().getRemoteCondition());
 
@@ -160,25 +93,46 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
             endpoint.close();
         }
 
-        LOG.info("Resource {} was remotely closed", getJmsResource());
+        LOG.info("Resource {} was remotely closed", getResourceInfo());
 
-        if (getJmsResource() instanceof JmsConnectionInfo) {
+        if (getResourceInfo() instanceof JmsConnectionInfo) {
             provider.fireProviderException(error);
         } else {
-            provider.fireResourceRemotelyClosed(getJmsResource(), error);
+            provider.fireResourceRemotelyClosed(getResourceInfo(), error);
         }
     }
 
+    /**
+     * Perform the close operation on the managed endpoint.  A subclass may
+     * override this method to provide additional close actions or alter the
+     * standard close path such as endpoint detach etc.
+     */
+    protected void doClose() {
+        getEndpoint().close();
+    }
+
+    //----- Access methods ---------------------------------------------------//
+
     public E getEndpoint() {
         return this.endpoint;
     }
 
-    public void setEndpoint(E endpoint) {
-        this.endpoint = endpoint;
+    public R getResourceInfo() {
+        return this.resourceInfo;
+    }
+
+    //----- Endpoint state access methods ------------------------------------//
+
+    public boolean isOpen() {
+        return getEndpoint().getRemoteState() == EndpointState.ACTIVE;
     }
 
-    public R getJmsResource() {
-        return this.resource;
+    public boolean isClosed() {
+        return getEndpoint().getLocalState() == EndpointState.CLOSED;
+    }
+
+    public boolean isAwaitingClose() {
+        return this.closeRequest != null;
     }
 
     public EndpointState getLocalState() {
@@ -195,20 +149,18 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
         return getEndpoint().getRemoteState();
     }
 
-    protected boolean hasRemoteError() {
-        return getEndpoint().getRemoteCondition().getCondition() != null;
-    }
+    //----- AmqpResource implementation --------------------------------------//
 
     @Override
-    public void processRemoteOpen(AmqpProvider provider) throws IOException {
-        doOpenCompletion();
+    public final void processRemoteOpen(AmqpProvider provider) throws IOException {
+        // Open is handled by the resource builder
     }
 
     @Override
     public void processRemoteDetach(AmqpProvider provider) throws IOException {
         if (isAwaitingClose()) {
             LOG.debug("{} is now closed: ", this);
-            closed();
+            resourceClosed();
         } else {
             remotelyClosed(provider);
         }
@@ -218,18 +170,7 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
     public void processRemoteClose(AmqpProvider provider) throws IOException {
         if (isAwaitingClose()) {
             LOG.debug("{} is now closed: ", this);
-            closed();
-        } else if (isAwaitingOpen()) {
-            // Error on Open, create exception and signal failure.
-            LOG.warn("Open of {} failed: ", this);
-            Exception openError;
-            if (hasRemoteError()) {
-                openError = AmqpSupport.convertToException(getEndpoint().getRemoteCondition());
-            } else {
-                openError = getOpenAbortException();
-            }
-
-            failed(openError);
+            resourceClosed();
         } else {
             remotelyClosed(provider);
         }
@@ -237,46 +178,11 @@ public abstract class AmqpAbstractResource<R extends JmsResource, E extends Endp
 
     @Override
     public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
+        // Nothing do be done here, subclasses can override as needed.
     }
 
     @Override
     public void processFlowUpdates(AmqpProvider provider) throws IOException {
-    }
-
-    /**
-     * Perform the open operation on the managed endpoint.  A subclass may
-     * override this method to provide additional open actions or configuration
-     * updates.
-     */
-    protected void doOpen() {
-        getEndpoint().open();
-    }
-
-    /**
-     * Complete the open operation on the managed endpoint. A subclass may
-     * override this method to provide additional verification actions or configuration
-     * updates.
-     */
-    protected void doOpenCompletion() {
-        LOG.debug("{} is now open: ", this);
-        opened();
-    }
-
-    /**
-     * When aborting the open operation, and there isn't an error condition,
-     * provided by the peer, the returned exception will be used instead.
-     * A subclass may override this method to provide alternative behavior.
-     */
-    protected Exception getOpenAbortException() {
-        return new IOException("Open failed unexpectedly.");
-    }
-
-    /**
-     * Perform the close operation on the managed endpoint.  A subclass may
-     * override this method to provide additional close actions or alter the
-     * standard close path such as endpoint detach etc.
-     */
-    protected void doClose() {
-        getEndpoint().close();
+        // Nothing do be done here, subclasses can override as needed.
     }
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java
index f34f5f96..a541b91d 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpAnonymousFallbackProducer.java
@@ -27,6 +27,7 @@ import org.apache.qpid.jms.meta.JmsProducerId;
 import org.apache.qpid.jms.meta.JmsProducerInfo;
 import org.apache.qpid.jms.provider.AsyncResult;
 import org.apache.qpid.jms.provider.WrappedAsyncResult;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpProducerBuilder;
 import org.apache.qpid.jms.util.IdGenerator;
 import org.apache.qpid.jms.util.LRUCache;
 import org.apache.qpid.proton.engine.EndpointState;
@@ -81,14 +82,13 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
 
             // We open a Fixed Producer instance with the target destination.  Once it opens
             // it will trigger the open event which will in turn trigger the send event.
-            producer = new AmqpFixedProducer(session, info);
-            producer.setPresettle(isPresettle());
-            AnonymousOpenRequest open = new AnonymousOpenRequest(request, producer, envelope);
-            producer.open(open);
+            // If caching is disabled the created producer will be closed immediately.
+            AmqpProducerBuilder builder = new AmqpProducerBuilder(session, info);
+            builder.buildResource(new AnonymousSendRequest(request, builder, envelope));
 
             if (connection.isAnonymousProducerCache()) {
                 // Cache it in hopes of not needing to create large numbers of producers.
-                producerCache.put(envelope.getDestination(), producer);
+                producerCache.put(envelope.getDestination(), builder.getResource());
             }
 
             return true;
@@ -97,13 +97,6 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
         }
     }
 
-    @Override
-    public void open(AsyncResult request) {
-        // Trigger an immediate open, we don't talk to the Broker until
-        // a send occurs so we must not let the client block.
-        request.onSuccess();
-    }
-
     @Override
     public void close(AsyncResult request) {
         // Trigger an immediate close, the internal producers that are currently in the cache
@@ -135,12 +128,10 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
 
     private abstract class AnonymousRequest extends WrappedAsyncResult {
 
-        protected final AmqpProducer producer;
         protected final JmsOutboundMessageDispatch envelope;
 
-        public AnonymousRequest(AsyncResult sendResult, AmqpProducer producer, JmsOutboundMessageDispatch envelope) {
+        public AnonymousRequest(AsyncResult sendResult, JmsOutboundMessageDispatch envelope) {
             super(sendResult);
-            this.producer = producer;
             this.envelope = envelope;
         }
 
@@ -153,36 +144,51 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
             LOG.debug("Send failed during {} step in chain: {}", this.getClass().getName(), getProducerId());
             super.onFailure(result);
         }
+
+        public abstract AmqpProducer getProducer();
     }
 
-    private final class AnonymousOpenRequest extends AnonymousRequest {
+    private final class AnonymousSendRequest extends AnonymousRequest {
 
-        public AnonymousOpenRequest(AsyncResult sendResult, AmqpProducer producer, JmsOutboundMessageDispatch envelope) {
-            super(sendResult, producer, envelope);
+        private final AmqpProducerBuilder producerBuilder;
+
+        public AnonymousSendRequest(AsyncResult sendResult, AmqpProducerBuilder producerBuilder, JmsOutboundMessageDispatch envelope) {
+            super(sendResult, envelope);
+
+            this.producerBuilder = producerBuilder;
         }
 
         @Override
         public void onSuccess() {
             LOG.trace("Open phase of anonymous send complete: {} ", getProducerId());
-            AnonymousSendRequest send = new AnonymousSendRequest(this);
+            AnonymousSendCompleteRequest send = new AnonymousSendCompleteRequest(this);
             try {
-                producer.send(envelope, send);
+                getProducer().send(envelope, send);
             } catch (Exception e) {
                 super.onFailure(e);
             }
         }
+
+        @Override
+        public AmqpProducer getProducer() {
+            return producerBuilder.getResource();
+        }
     }
 
-    private final class AnonymousSendRequest extends AnonymousRequest {
+    private final class AnonymousSendCompleteRequest extends AnonymousRequest {
 
-        public AnonymousSendRequest(AnonymousOpenRequest open) {
-            super(open.getWrappedRequest(), open.producer, open.envelope);
+        private final AmqpProducer producer;
+
+        public AnonymousSendCompleteRequest(AnonymousSendRequest open) {
+            super(open.getWrappedRequest(), open.envelope);
+
+            this.producer = open.getProducer();
         }
 
         @Override
         public void onFailure(Throwable result) {
             // Ensure that cache get purged of any failed producers.
-            AmqpAnonymousFallbackProducer.this.producerCache.remove(producer.getJmsResource().getDestination());
+            AmqpAnonymousFallbackProducer.this.producerCache.remove(producer.getResourceInfo().getDestination());
             super.onFailure(result);
         }
 
@@ -196,12 +202,21 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
                 super.onSuccess();
             }
         }
+
+        @Override
+        public AmqpProducer getProducer() {
+            return producer;
+        }
     }
 
     private final class AnonymousCloseRequest extends AnonymousRequest {
 
-        public AnonymousCloseRequest(AnonymousSendRequest send) {
-            super(send.getWrappedRequest(), send.producer, send.envelope);
+        private final AmqpProducer producer;
+
+        public AnonymousCloseRequest(AnonymousSendCompleteRequest sendComplete) {
+            super(sendComplete.getWrappedRequest(), sendComplete.envelope);
+
+            this.producer = sendComplete.getProducer();
         }
 
         @Override
@@ -209,6 +224,11 @@ public class AmqpAnonymousFallbackProducer extends AmqpProducer {
             LOG.trace("Close phase of anonymous send complete: {} ", getProducerId());
             super.onSuccess();
         }
+
+        @Override
+        public AmqpProducer getProducer() {
+            return producer;
+        }
     }
 
     private final class CloseRequest implements AsyncResult {
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnection.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnection.java
index ebec59a9..b3da9a55 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnection.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnection.java
@@ -16,18 +16,13 @@
  */
 package org.apache.qpid.jms.provider.amqp;
 
-import static org.apache.qpid.jms.provider.amqp.AmqpSupport.SOLE_CONNECTION_CAPABILITY;
-
 import java.net.URI;
 import java.util.HashMap;
-import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 import javax.jms.JMSException;
-import javax.jms.JMSSecurityException;
-import javax.jms.Session;
 
 import org.apache.qpid.jms.JmsDestination;
 import org.apache.qpid.jms.JmsTemporaryDestination;
@@ -35,15 +30,14 @@ import org.apache.qpid.jms.meta.JmsConnectionInfo;
 import org.apache.qpid.jms.meta.JmsSessionId;
 import org.apache.qpid.jms.meta.JmsSessionInfo;
 import org.apache.qpid.jms.provider.AsyncResult;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpSessionBuilder;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpTemporaryDestinationBuilder;
 import org.apache.qpid.jms.provider.amqp.message.AmqpJmsMessageFactory;
-import org.apache.qpid.jms.util.IOExceptionSupport;
-import org.apache.qpid.jms.util.MetaDataSupport;
-import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.engine.Connection;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Connection> {
+public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Connection> implements AmqpResourceParent {
 
     private static final Logger LOG = LoggerFactory.getLogger(AmqpConnection.class);
 
@@ -53,66 +47,34 @@ public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Conn
     private final Map<JmsSessionId, AmqpSession> sessions = new HashMap<JmsSessionId, AmqpSession>();
     private final Map<JmsDestination, AmqpTemporaryDestination> tempDests = new HashMap<JmsDestination, AmqpTemporaryDestination>();
     private final AmqpProvider provider;
-    private AmqpSaslAuthenticator authenticator;
-    private final AmqpConnectionSession connectionSession;
     private final AmqpConnectionProperties properties;
+    private AmqpConnectionSession connectionSession;
 
     private boolean objectMessageUsesAmqpTypes = false;
     private boolean anonymousProducerCache = false;
     private int anonymousProducerCacheSize = 10;
 
-    public AmqpConnection(AmqpProvider provider, Connection protonConnection, AmqpSaslAuthenticator authenticator, JmsConnectionInfo info) {
+    public AmqpConnection(AmqpProvider provider, JmsConnectionInfo info, Connection protonConnection) {
         super(info, protonConnection);
 
         this.provider = provider;
         this.remoteURI = provider.getRemoteURI();
         this.amqpMessageFactory = new AmqpJmsMessageFactory(this);
-        this.authenticator = authenticator;
 
-        this.resource.getConnectionId().setProviderHint(this);
+        getResourceInfo().getConnectionId().setProviderHint(this);
 
         // Create connection properties initialized with defaults from the JmsConnectionInfo
         this.properties = new AmqpConnectionProperties(info);
-
-        // Create a Session for this connection that is used for Temporary Destinations
-        // and perhaps later on management and advisory monitoring.
-        JmsSessionInfo sessionInfo = new JmsSessionInfo(this.resource, -1);
-        sessionInfo.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
-
-        this.connectionSession = new AmqpConnectionSession(this, sessionInfo);
     }
 
-    @Override
-    protected void doOpen() {
-        String hostname = provider.getVhost();
-        if(hostname == null) {
-            hostname = remoteURI.getHost();
-        } else if (hostname.isEmpty()) {
-            hostname = null;
-        }
-
-        Map<Symbol, Object> props = new LinkedHashMap<Symbol, Object>();
-        props.put(AmqpSupport.PRODUCT, MetaDataSupport.PROVIDER_NAME);
-        props.put(AmqpSupport.VERSION, MetaDataSupport.PROVIDER_VERSION);
-        props.put(AmqpSupport.PLATFORM, MetaDataSupport.PLATFORM_DETAILS);
-
-        Connection conn = getEndpoint();
-        conn.setHostname(hostname);
-        conn.setContainer(resource.getClientId());
-        conn.setDesiredCapabilities(new Symbol[] { SOLE_CONNECTION_CAPABILITY });
-        conn.setProperties(props);
-
-        super.doOpen();
+    public void createSession(JmsSessionInfo sessionInfo, AsyncResult request) {
+        AmqpSessionBuilder builder = new AmqpSessionBuilder(this, sessionInfo);
+        builder.buildResource(request);
     }
 
-    public AmqpSession createSession(JmsSessionInfo sessionInfo) {
-        AmqpSession session = new AmqpSession(this, sessionInfo);
-        return session;
-    }
-
-    public AmqpTemporaryDestination createTemporaryDestination(JmsTemporaryDestination destination) {
-        AmqpTemporaryDestination temporary = new AmqpTemporaryDestination(connectionSession, destination);
-        return temporary;
+    public void createTemporaryDestination(JmsTemporaryDestination destination, AsyncResult request) {
+        AmqpTemporaryDestinationBuilder builder = new AmqpTemporaryDestinationBuilder(connectionSession, destination);
+        builder.buildResource(request);
     }
 
     public AmqpTemporaryDestination getTemporaryDestination(JmsTemporaryDestination destination) {
@@ -132,93 +94,39 @@ public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Conn
     }
 
     @Override
-    protected void doOpenCompletion() {
-        properties.initialize(getEndpoint().getRemoteOfferedCapabilities(), getEndpoint().getRemoteProperties());
-
-        // If the remote reports that the connection attempt failed then we can assume a
-        // close follows so do nothing and wait so a proper error can be constructed from
-        // the information in the remote close.
-        if (!properties.isConnectionOpenFailed()) {
-            connectionSession.open(new AsyncResult() {
-
-                @Override
-                public boolean isComplete() {
-                    return connectionSession.isOpen();
-                }
-
-                @Override
-                public void onSuccess() {
-                    LOG.debug("{} is now open: ", AmqpConnection.this);
-                    opened();
-                }
-
-                @Override
-                public void onFailure(Throwable result) {
-                    LOG.debug("AMQP Connection Session failed to open.");
-                    failed(IOExceptionSupport.create(result));
-                }
-            });
+    public void addChildResource(AmqpResource resource) {
+        if (resource instanceof AmqpConnectionSession) {
+            connectionSession = (AmqpConnectionSession) resource;
+        } else if (resource instanceof AmqpSession) {
+            AmqpSession session = (AmqpSession) resource;
+            sessions.put(session.getSessionId(), session);
+        } else if (resource instanceof AmqpTemporaryDestination) {
+            AmqpTemporaryDestination tempDest = (AmqpTemporaryDestination) resource;
+            tempDests.put(tempDest.getResourceInfo(), tempDest);
         }
     }
 
-    public void processSaslAuthentication() {
-        if (authenticator == null) {
-            return;
-        }
-
-        try {
-            if (authenticator.authenticate()) {
-                authenticator = null;
-            }
-        } catch (JMSSecurityException ex) {
-            try {
-                // TODO: this is a hack to stop Proton sending the open(+close) frame(s)
-                org.apache.qpid.proton.engine.Transport t = getEndpoint().getTransport();
-                t.close_head();
-            } finally {
-                failed(ex);
-            }
+    @Override
+    public void removeChildResource(AmqpResource resource) {
+        if (resource instanceof AmqpSession) {
+            AmqpSession session = (AmqpSession) resource;
+            sessions.remove(session.getSessionId());
+        } else if (resource instanceof AmqpTemporaryDestination) {
+            AmqpTemporaryDestination tempDest = (AmqpTemporaryDestination) resource;
+            tempDests.remove(tempDest.getResourceInfo());
         }
     }
 
-    void addTemporaryDestination(AmqpTemporaryDestination destination) {
-        tempDests.put(destination.getJmsDestination(), destination);
-    }
-
-    void removeTemporaryDestination(AmqpTemporaryDestination destination) {
-        tempDests.remove(destination.getJmsDestination());
-    }
-
-    void addSession(AmqpSession session) {
-        this.sessions.put(session.getSessionId(), session);
-    }
-
-    void removeSession(AmqpSession session) {
-        this.sessions.remove(session.getSessionId());
-    }
-
-    public JmsConnectionInfo getConnectionInfo() {
-        return this.resource;
-    }
-
     public Connection getProtonConnection() {
-        return this.getEndpoint();
+        return getEndpoint();
     }
 
     public URI getRemoteURI() {
-        return this.remoteURI;
-    }
-
-    public String getUsername() {
-        return this.resource.getUsername();
-    }
-
-    public String getPassword() {
-        return this.resource.getPassword();
+        return remoteURI;
     }
 
     public AmqpProvider getProvider() {
-        return this.provider;
+        return provider;
     }
 
     public String getQueuePrefix() {
@@ -249,7 +157,7 @@ public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Conn
         if (sessionId.getProviderHint() instanceof AmqpSession) {
             return (AmqpSession) sessionId.getProviderHint();
         }
-        return this.sessions.get(sessionId);
+        return sessions.get(sessionId);
     }
 
     /**
@@ -318,7 +226,7 @@ public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Conn
      * @return the AMQP based JmsMessageFactory for this Connection.
      */
     public AmqpJmsMessageFactory getAmqpMessageFactory() {
-        return this.amqpMessageFactory;
+        return amqpMessageFactory;
     }
 
     /**
@@ -353,6 +261,6 @@ public class AmqpConnection extends AmqpAbstractResource<JmsConnectionInfo, Conn
 
     @Override
     public String toString() {
-        return "AmqpConnection { " + getConnectionInfo().getConnectionId() + " }";
+        return "AmqpConnection { " + getResourceInfo().getConnectionId() + " }";
     }
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnectionSession.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnectionSession.java
index 935c9a40..2181e5d5 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnectionSession.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConnectionSession.java
@@ -25,10 +25,12 @@ import org.apache.qpid.jms.meta.JmsSessionInfo;
 import org.apache.qpid.jms.provider.AsyncResult;
 import org.apache.qpid.jms.provider.NoOpAsyncResult;
 import org.apache.qpid.jms.provider.WrappedAsyncResult;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpResourceBuilder;
 import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
 import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
 import org.apache.qpid.proton.engine.Receiver;
+import org.apache.qpid.proton.engine.Session;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -49,9 +51,11 @@ public class AmqpConnectionSession extends AmqpSession {
      *        the connection that owns this session.
      * @param info
      *        the <code>JmsSessionInfo</code> for the Session to create.
+     * @param session
+     *        the Proton session instance that this resource wraps.
      */
-    public AmqpConnectionSession(AmqpConnection connection, JmsSessionInfo info) {
-        super(connection, info);
+    public AmqpConnectionSession(AmqpConnection connection, JmsSessionInfo info, Session session) {
+        super(connection, info, session);
     }
 
     /**
@@ -63,47 +67,70 @@ public class AmqpConnectionSession extends AmqpSession {
      *        the request that awaits the completion of this action.
      */
     public void unsubscribe(String subscriptionName, AsyncResult request) {
-        DurableSubscriptionReattach subscriber = new DurableSubscriptionReattach(getJmsResource(), subscriptionName);
-        DurableSubscriptionReattachRequest subscribeRequest = new DurableSubscriptionReattachRequest(subscriber, request);
+        DurableSubscriptionReattachBuilder builder = new DurableSubscriptionReattachBuilder(this, getResourceInfo(), subscriptionName);
+        DurableSubscriptionReattachRequest subscribeRequest = new DurableSubscriptionReattachRequest(builder, request);
         pendingUnsubs.put(subscriptionName, subscribeRequest);
 
         LOG.debug("Attempting remove of subscription: {}", subscriptionName);
-        subscriber.open(subscribeRequest);
+        builder.buildResource(subscribeRequest);
     }
 
     private class DurableSubscriptionReattach extends AmqpAbstractResource<JmsSessionInfo, Receiver> {
+
+        public DurableSubscriptionReattach(JmsSessionInfo resource, Receiver receiver) {
+            super(resource, receiver);
+        }
+
+        public String getSubscriptionName() {
+            return getEndpoint().getName();
+        }
+    }
+
+    private final class DurableSubscriptionReattachBuilder extends AmqpResourceBuilder<DurableSubscriptionReattach, AmqpSession, JmsSessionInfo, Receiver> {
+
         private final String subscriptionName;
 
-        public DurableSubscriptionReattach(JmsSessionInfo resource, String subscriptionName) {
-            super(resource, AmqpConnectionSession.this.getProtonSession().receiver(subscriptionName));
+        public DurableSubscriptionReattachBuilder(AmqpSession parent, JmsSessionInfo resourceInfo, String subscriptionName) {
+            super(parent, resourceInfo);
+
             this.subscriptionName = subscriptionName;
         }
 
         @Override
-        protected void doOpen() {
-            Receiver receiver = getEndpoint();
+        protected Receiver createEndpoint(JmsSessionInfo resourceInfo) {
+            Receiver receiver = getParent().getProtonSession().receiver(subscriptionName);
             receiver.setTarget(new Target());
             receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
             receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-            super.doOpen();
+
+            return receiver;
         }
 
-        public String getSubscriptionName() {
-            return subscriptionName;
+        @Override
+        protected DurableSubscriptionReattach createResource(AmqpSession parent, JmsSessionInfo resourceInfo, Receiver endpoint) {
+            return new DurableSubscriptionReattach(resourceInfo, endpoint);
+        }
+
+        @Override
+        protected boolean isClosePending() {
+            // When no link terminus was created, the peer will now detach/close us otherwise
+            // we need to validate the returned remote source prior to open completion.
+            return endpoint.getRemoteSource() == null;
         }
     }
 
     private class DurableSubscriptionReattachRequest extends WrappedAsyncResult {
 
-        private final DurableSubscriptionReattach subscriber;
+        private final DurableSubscriptionReattachBuilder subscriberBuilder;
 
-        public DurableSubscriptionReattachRequest(DurableSubscriptionReattach subscriber, AsyncResult originalRequest) {
+        public DurableSubscriptionReattachRequest(DurableSubscriptionReattachBuilder subscriberBuilder, AsyncResult originalRequest) {
             super(originalRequest);
-            this.subscriber = subscriber;
+            this.subscriberBuilder = subscriberBuilder;
         }
 
         @Override
         public void onSuccess() {
+            DurableSubscriptionReattach subscriber = subscriberBuilder.getResource();
             LOG.trace("Reattached to subscription: {}", subscriber.getSubscriptionName());
             pendingUnsubs.remove(subscriber.getSubscriptionName());
             if (subscriber.getEndpoint().getRemoteSource() != null) {
@@ -116,9 +143,10 @@ public class AmqpConnectionSession extends AmqpSession {
 
         @Override
         public void onFailure(Throwable result) {
+            DurableSubscriptionReattach subscriber = subscriberBuilder.getResource();
             LOG.trace("Failed to reattach to subscription: {}", subscriber.getSubscriptionName());
             pendingUnsubs.remove(subscriber.getSubscriptionName());
-            subscriber.closed();
+            subscriber.resourceClosed();
             super.onFailure(result);
         }
     }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
index 58dfe261..62971a2e 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpConsumer.java
@@ -16,6 +16,8 @@
  */
 package org.apache.qpid.jms.provider.amqp;
 
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.MODIFIED_FAILED;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.MODIFIED_UNDELIVERABLE;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 
@@ -23,14 +25,12 @@ import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.atomic.AtomicLong;
 
-import javax.jms.InvalidDestinationException;
 import javax.jms.JMSException;
 
 import org.apache.qpid.jms.JmsDestination;
@@ -41,24 +41,13 @@ import org.apache.qpid.jms.meta.JmsConsumerInfo;
 import org.apache.qpid.jms.provider.AsyncResult;
 import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
 import org.apache.qpid.jms.provider.ProviderListener;
-import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
 import org.apache.qpid.jms.provider.amqp.message.AmqpJmsMessageBuilder;
 import org.apache.qpid.jms.util.IOExceptionSupport;
 import org.apache.qpid.proton.amqp.Binary;
-import org.apache.qpid.proton.amqp.DescribedType;
-import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.messaging.Source;
-import org.apache.qpid.proton.amqp.messaging.Target;
-import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
-import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
-import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.Receiver;
 import org.apache.qpid.proton.message.Message;
@@ -72,22 +61,8 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
 
     private static final Logger LOG = LoggerFactory.getLogger(AmqpConsumer.class);
 
-    protected static final Symbol COPY = Symbol.getSymbol("copy");
-    protected static final Symbol JMS_NO_LOCAL_SYMBOL = Symbol.valueOf("no-local");
-    protected static final Symbol JMS_SELECTOR_SYMBOL = Symbol.valueOf("jms-selector");
-
     private static final int INITIAL_BUFFER_CAPACITY = 1024 * 128;
 
-    private static final Modified MODIFIED_FAILED = new Modified();
-    private static final Modified MODIFIED_UNDELIVERABLE = new Modified();
-
-    static {
-        MODIFIED_FAILED.setDeliveryFailed(true);
-
-        MODIFIED_UNDELIVERABLE.setDeliveryFailed(true);
-        MODIFIED_UNDELIVERABLE.setUndeliverableHere(true);
-    }
-
     protected final AmqpSession session;
     protected final Map<JmsInboundMessageDispatch, Delivery> delivered = new LinkedHashMap<JmsInboundMessageDispatch, Delivery>();
     protected boolean presettle;
@@ -96,12 +71,13 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
     protected final ByteBuf incomingBuffer = Unpooled.buffer(INITIAL_BUFFER_CAPACITY);
     protected final AtomicLong incomingSequence = new AtomicLong(0);
 
-    public AmqpConsumer(AmqpSession session, JmsConsumerInfo info) {
-        super(info);
+    public AmqpConsumer(AmqpSession session, JmsConsumerInfo info, Receiver receiver) {
+        super(info, receiver);
+
         this.session = session;
 
         // Add a shortcut back to this Consumer for quicker lookups
-        this.resource.getConsumerId().setProviderHint(this);
+        getResourceInfo().getConsumerId().setProviderHint(this);
     }
 
     /**
@@ -162,110 +138,9 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
     }
 
     @Override
-    protected void doOpen() {
-        JmsDestination destination = resource.getDestination();
-        String subscription = AmqpDestinationHelper.INSTANCE.getDestinationAddress(destination, session.getConnection());
-
-        Source source = new Source();
-        source.setAddress(subscription);
-        Target target = new Target();
-
-        configureSource(source);
-
-        String receiverName = "qpid-jms:receiver:" + getConsumerId() + ":" + subscription;
-        if (resource.getSubscriptionName() != null && !resource.getSubscriptionName().isEmpty()) {
-            // In the case of Durable Topic Subscriptions the client must use the same
-            // receiver name which is derived from the subscription name property.
-            receiverName = resource.getSubscriptionName();
-        }
-
-        Receiver receiver = session.getProtonSession().receiver(receiverName);
-        receiver.setSource(source);
-        receiver.setTarget(target);
-        if (isPresettle()) {
-            receiver.setSenderSettleMode(SenderSettleMode.SETTLED);
-        } else {
-            receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
-        }
-        receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
-        setEndpoint(receiver);
-
-        super.doOpen();
-    }
-
-    @Override
-    protected void doOpenCompletion() {
-        // Verify the attach response contained a non-null Source
-        org.apache.qpid.proton.amqp.transport.Source source = getEndpoint().getRemoteSource();
-        if (source != null) {
-            super.doOpenCompletion();
-        } else {
-            // No link terminus was created, the peer will now detach/close us.
-        }
-    }
-
-    @Override
-    protected Exception getOpenAbortException() {
-        // Verify the attach response contained a non-null Source
-        org.apache.qpid.proton.amqp.transport.Source source = getEndpoint().getRemoteSource();
-        if (source != null) {
-            return super.getOpenAbortException();
-        } else {
-            // No link terminus was created, the peer has detach/closed us, create IDE.
-            return new InvalidDestinationException("Link creation was refused");
-        }
-    }
-
-    @Override
-    public void opened() {
-        this.session.addResource(this);
-        super.opened();
-    }
-
-    @Override
-    public void closed() {
-        this.session.removeResource(this);
-        super.closed();
-    }
-
-    protected void configureSource(Source source) {
-        Map<Symbol, DescribedType> filters = new HashMap<Symbol, DescribedType>();
-        Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL,
-                                          Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL };
-
-        if (resource.getSubscriptionName() != null && !resource.getSubscriptionName().isEmpty()) {
-            source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
-            source.setDurable(TerminusDurability.UNSETTLED_STATE);
-            source.setDistributionMode(COPY);
-        } else {
-            source.setDurable(TerminusDurability.NONE);
-            source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
-        }
-
-        if (resource.isBrowser()) {
-            source.setDistributionMode(COPY);
-        }
-
-        Symbol typeCapability =  AmqpDestinationHelper.INSTANCE.toTypeCapability(resource.getDestination());
-        if(typeCapability != null) {
-            source.setCapabilities(typeCapability);
-        }
-
-        source.setOutcomes(outcomes);
-        source.setDefaultOutcome(MODIFIED_FAILED);
-
-        if (resource.isNoLocal()) {
-            filters.put(JMS_NO_LOCAL_SYMBOL, AmqpJmsNoLocalType.NO_LOCAL);
-        }
-
-        if (resource.getSelector() != null && !resource.getSelector().trim().equals("")) {
-            filters.put(JMS_SELECTOR_SYMBOL, new AmqpJmsSelectorType(resource.getSelector()));
-        }
-
-        if (!filters.isEmpty()) {
-            source.setFilter(filters);
-        }
+    public void resourceClosed() {
+        this.session.removeChildResource(this);
+        super.resourceClosed();
     }
 
     /**
@@ -278,7 +153,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
      * would already have been given for these so we just need to settle them.
      */
     public void acknowledge() {
-        LOG.trace("Session Acknowledge for consumer: {}", resource.getConsumerId());
+        LOG.trace("Session Acknowledge for consumer: {}", getResourceInfo().getConsumerId());
         for (Delivery delivery : delivered.values()) {
             delivery.disposition(Accepted.getInstance());
             delivery.settle();
@@ -326,7 +201,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
             }
             LOG.debug("Consumed Ack of message: {}", envelope);
             if (!delivery.isSettled()) {
-                if (session.isTransacted() && !resource.isBrowser()) {
+                if (session.isTransacted() && !getResourceInfo().isBrowser()) {
                     Binary txnId = session.getTransactionContext().getAmqpTransactionId();
                     if (txnId != null) {
                         TransactionalState txState = new TransactionalState();
@@ -359,13 +234,13 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
      * or we are draining then we never send credit here.
      */
     private void sendFlowIfNeeded() {
-        if (resource.getPrefetchSize() == 0 || isDraining()) {
+        if (getResourceInfo().getPrefetchSize() == 0 || isDraining()) {
             return;
         }
 
         int currentCredit = getEndpoint().getCredit();
-        if (currentCredit <= resource.getPrefetchSize() * 0.2) {
-            int newCredit = resource.getPrefetchSize() - currentCredit;
+        if (currentCredit <= getResourceInfo().getPrefetchSize() * 0.2) {
+            int newCredit = getResourceInfo().getPrefetchSize() - currentCredit;
             LOG.trace("Consumer {} granting additional credit: {}", getConsumerId(), newCredit);
             getEndpoint().flow(newCredit);
         }
@@ -377,7 +252,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
      * @throws Exception if an error occurs while performing the recover.
      */
     public void recover() throws Exception {
-        LOG.debug("Session Recover for consumer: {}", resource.getConsumerId());
+        LOG.debug("Session Recover for consumer: {}", getResourceInfo().getConsumerId());
         Collection<JmsInboundMessageDispatch> values = delivered.keySet();
         ArrayList<JmsInboundMessageDispatch> envelopes = new ArrayList<JmsInboundMessageDispatch>(values);
         ListIterator<JmsInboundMessageDispatch> reverseIterator = envelopes.listIterator(values.size());
@@ -422,7 +297,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
                 // try to fulfill the pull request, otherwise we want to drain down
                 // what is there to ensure we consume everything available.
                 if (getEndpoint().getCredit() == 0) {
-                    getEndpoint().drain(resource.getPrefetchSize() > 0 ? resource.getPrefetchSize() : 1);
+                    getEndpoint().drain(getResourceInfo().getPrefetchSize() > 0 ? getResourceInfo().getPrefetchSize() : 1);
                 } else {
                     getEndpoint().drain(0);
                 }
@@ -513,7 +388,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
 
         JmsInboundMessageDispatch envelope = new JmsInboundMessageDispatch(getNextIncomingSequenceNumber());
         envelope.setMessage(message);
-        envelope.setConsumerId(resource.getConsumerId());
+        envelope.setConsumerId(getResourceInfo().getConsumerId());
         // Store link to delivery in the hint for use in acknowledge requests.
         envelope.setProviderHint(incoming);
         envelope.setMessageId(message.getFacade().getProviderMessageIdObject());
@@ -541,7 +416,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
 
     @Override
     protected void doClose() {
-        if (resource.isDurable()) {
+        if (getResourceInfo().isDurable()) {
             getEndpoint().detach();
         } else {
             getEndpoint().close();
@@ -557,11 +432,11 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
     }
 
     public JmsConsumerId getConsumerId() {
-        return this.resource.getConsumerId();
+        return this.getResourceInfo().getConsumerId();
     }
 
     public JmsDestination getDestination() {
-        return this.resource.getDestination();
+        return this.getResourceInfo().getDestination();
     }
 
     public Receiver getProtonReceiver() {
@@ -569,7 +444,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
     }
 
     public boolean isPresettle() {
-        return presettle || resource.isBrowser();
+        return presettle || getResourceInfo().isBrowser();
     }
 
     public boolean isDraining() {
@@ -582,7 +457,7 @@ public class AmqpConsumer extends AmqpAbstractResource<JmsConsumerInfo, Receiver
 
     @Override
     public String toString() {
-        return "AmqpConsumer { " + this.resource.getConsumerId() + " }";
+        return "AmqpConsumer { " + getResourceInfo().getConsumerId() + " }";
     }
 
     protected void deliveryFailed(Delivery incoming) {
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpEventSink.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpEventSink.java
new file mode 100644
index 00000000..75c1056a
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpEventSink.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp;
+
+import java.io.IOException;
+
+/**
+ * Interface used by classes that want to process AMQP events sent from
+ * the transport layer.
+ */
+public interface AmqpEventSink {
+
+    /**
+     * Event handler for remote peer open of this resource.
+     *
+     * @param provider
+     *        the AmqpProvider instance for easier access to fire events.
+     *
+     * @throws IOException if an error occurs while processing the update.
+     */
+    void processRemoteOpen(AmqpProvider provider) throws IOException;
+
+    /**
+     * Event handler for remote peer detach of this resource.
+     *
+     * @param provider
+     *        the AmqpProvider instance for easier access to fire events.
+     *
+     * @throws IOException if an error occurs while processing the update.
+     */
+    void processRemoteDetach(AmqpProvider provider) throws IOException;
+
+    /**
+     * Event handler for remote peer close of this resource.
+     *
+     * @param provider
+     *        the AmqpProvider instance for easier access to fire events.
+     *
+     * @throws IOException if an error occurs while processing the update.
+     */
+    void processRemoteClose(AmqpProvider provider) throws IOException;
+
+    /**
+     * Called when the Proton Engine signals an Delivery related event has been triggered
+     * for the given endpoint.
+     *
+     * @param provider
+     *        the AmqpProvider instance for easier access to fire events.
+     *
+     * @throws IOException if an error occurs while processing the update.
+     */
+    void processDeliveryUpdates(AmqpProvider provider) throws IOException;
+
+    /**
+     * Called when the Proton Engine signals an Flow related event has been triggered
+     * for the given endpoint.
+     *
+     * @param provider
+     *        the AmqpProvider instance for easier access to fire events.
+     *
+     * @throws IOException if an error occurs while processing the update.
+     */
+    void processFlowUpdates(AmqpProvider provider) throws IOException;
+
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpFixedProducer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpFixedProducer.java
index 3f4ccb45..c8ec42b1 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpFixedProducer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpFixedProducer.java
@@ -23,29 +23,21 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
-import javax.jms.InvalidDestinationException;
 import javax.jms.JMSException;
 
-import org.apache.qpid.jms.JmsDestination;
 import org.apache.qpid.jms.message.JmsOutboundMessageDispatch;
 import org.apache.qpid.jms.message.facade.JmsMessageFacade;
 import org.apache.qpid.jms.meta.JmsProducerInfo;
 import org.apache.qpid.jms.provider.AsyncResult;
-import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
 import org.apache.qpid.jms.provider.amqp.message.AmqpJmsMessageFacade;
 import org.apache.qpid.jms.util.IOExceptionSupport;
 import org.apache.qpid.proton.amqp.Binary;
-import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Outcome;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Source;
-import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
-import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.Sender;
 import org.apache.qpid.proton.message.Message;
@@ -72,6 +64,10 @@ public class AmqpFixedProducer extends AmqpProducer {
         super(session, info);
     }
 
+    public AmqpFixedProducer(AmqpSession session, JmsProducerInfo info, Sender sender) {
+        super(session, info, sender);
+    }
+
     @Override
     public void close(AsyncResult request) {
         // If any sends are held we need to wait for them to complete.
@@ -247,76 +243,17 @@ public class AmqpFixedProducer extends AmqpProducer {
         super.processDeliveryUpdates(provider);
     }
 
-    @Override
-    protected void doOpen() {
-        JmsDestination destination = resource.getDestination();
-        String targetAddress = AmqpDestinationHelper.INSTANCE.getDestinationAddress(destination, session.getConnection());
-
-        Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL };
-        String sourceAddress = getProducerId().toString();
-        Source source = new Source();
-        source.setAddress(sourceAddress);
-        source.setOutcomes(outcomes);
-        //TODO: default outcome. Accepted normally, Rejected for transaction controller?
-
-        Target target = new Target();
-        target.setAddress(targetAddress);
-        Symbol typeCapability =  AmqpDestinationHelper.INSTANCE.toTypeCapability(destination);
-        if (typeCapability != null) {
-            target.setCapabilities(typeCapability);
-        }
-
-        String senderName = "qpid-jms:sender:" + sourceAddress + ":" + targetAddress;
-
-        Sender sender = session.getProtonSession().sender(senderName);
-        sender.setSource(source);
-        sender.setTarget(target);
-        if (presettle) {
-            sender.setSenderSettleMode(SenderSettleMode.SETTLED);
-        } else {
-            sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
-        }
-        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
-        setEndpoint(sender);
-
-        super.doOpen();
-    }
-
-    @Override
-    protected void doOpenCompletion() {
-        // Verify the attach response contained a non-null target
-        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
-        if (target != null) {
-            super.doOpenCompletion();
-        } else {
-            // No link terminus was created, the peer will now detach/close us.
-        }
-    }
-
-    @Override
-    protected Exception getOpenAbortException() {
-        // Verify the attach response contained a non-null target
-        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
-        if (target != null) {
-            return super.getOpenAbortException();
-        } else {
-            // No link terminus was created, the peer has detach/closed us, create IDE.
-            return new InvalidDestinationException("Link creation was refused");
-        }
-    }
-
     public AmqpSession getSession() {
-        return this.session;
+        return session;
     }
 
     public Sender getProtonSender() {
-        return this.getEndpoint();
+        return getEndpoint();
     }
 
     @Override
     public boolean isAnonymous() {
-        return this.resource.getDestination() == null;
+        return getResourceInfo().getDestination() == null;
     }
 
     @Override
@@ -326,7 +263,7 @@ public class AmqpFixedProducer extends AmqpProducer {
 
     @Override
     public boolean isPresettle() {
-        return this.presettle;
+        return presettle;
     }
 
     @Override
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProducer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProducer.java
index a27820b4..7fb8d530 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProducer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProducer.java
@@ -36,12 +36,17 @@ public abstract class AmqpProducer extends AmqpAbstractResource<JmsProducerInfo,
     protected boolean presettle;
 
     public AmqpProducer(AmqpSession session, JmsProducerInfo info) {
-        super(info);
+        this(session, info, null);
+    }
+
+    public AmqpProducer(AmqpSession session, JmsProducerInfo info, Sender endpoint) {
+        super(info, endpoint);
+
         this.session = session;
         this.connection = session.getConnection();
 
         // Add a shortcut back to this Producer for quicker lookup.
-        this.resource.getProducerId().setProviderHint(this);
+        getResourceInfo().getProducerId().setProviderHint(this);
     }
 
     /**
@@ -69,7 +74,7 @@ public abstract class AmqpProducer extends AmqpAbstractResource<JmsProducerInfo,
      * @return the JmsProducerId that was assigned to this AmqpProducer.
      */
     public JmsProducerId getProducerId() {
-        return this.resource.getProducerId();
+        return getResourceInfo().getProducerId();
     }
 
     /**
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
index bce9282b..648ad409 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
@@ -34,6 +34,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.jms.JMSException;
+import javax.jms.JMSSecurityException;
 
 import org.apache.qpid.jms.JmsTemporaryDestination;
 import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
@@ -57,6 +58,7 @@ import org.apache.qpid.jms.provider.ProviderClosedException;
 import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
 import org.apache.qpid.jms.provider.ProviderFuture;
 import org.apache.qpid.jms.provider.ProviderListener;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpConnectionBuilder;
 import org.apache.qpid.jms.transports.SSLTransport;
 import org.apache.qpid.jms.transports.TransportFactory;
 import org.apache.qpid.jms.transports.TransportListener;
@@ -87,7 +89,7 @@ import org.slf4j.LoggerFactory;
  * All work within this Provider is serialized to a single Thread.  Any asynchronous exceptions
  * will be dispatched from that Thread and all in-bound requests are handled there as well.
  */
-public class AmqpProvider implements Provider, TransportListener {
+public class AmqpProvider implements Provider, TransportListener , AmqpResourceParent {
 
     private static final Logger LOG = LoggerFactory.getLogger(AmqpProvider.class);
 
@@ -102,6 +104,7 @@ public class AmqpProvider implements Provider, TransportListener {
 
     private ProviderListener listener;
     private AmqpConnection connection;
+    private AmqpSaslAuthenticator authenticator;
     private org.apache.qpid.jms.transports.Transport transport;
     private String transportType = AmqpProviderFactory.DEFAULT_TRANSPORT_TYPE;
     private String vhost;
@@ -125,6 +128,7 @@ public class AmqpProvider implements Provider, TransportListener {
     private final ScheduledExecutorService serializer;
     private final Transport protonTransport = Transport.Factory.create();
     private final Collector protonCollector = new CollectorImpl();
+    private final Connection protonConnection = Connection.Factory.create();
 
     private AsyncResult connectionOpenRequest;
     private ScheduledFuture<?> nextIdleTimeoutCheck;
@@ -253,22 +257,19 @@ public class AmqpProvider implements Provider, TransportListener {
                     resource.visit(new JmsResourceVistor() {
                         @Override
                         public void processSessionInfo(JmsSessionInfo sessionInfo) throws Exception {
-                            AmqpSession session = connection.createSession(sessionInfo);
-                            session.open(request);
+                            connection.createSession(sessionInfo, request);
                         }
 
                         @Override
                         public void processProducerInfo(JmsProducerInfo producerInfo) throws Exception {
                             AmqpSession session = connection.getSession(producerInfo.getParentId());
-                            AmqpProducer producer = session.createProducer(producerInfo);
-                            producer.open(request);
+                            session.createProducer(producerInfo, request);
                         }
 
                         @Override
                         public void processConsumerInfo(JmsConsumerInfo consumerInfo) throws Exception {
                             AmqpSession session = connection.getSession(consumerInfo.getParentId());
-                            AmqpConsumer consumer = session.createConsumer(consumerInfo);
-                            consumer.open(request);
+                            session.createConsumer(consumerInfo, request);
                         }
 
                         @Override
@@ -278,17 +279,15 @@ public class AmqpProvider implements Provider, TransportListener {
                             sendTimeout = connectionInfo.getSendTimeout();
                             requestTimeout = connectionInfo.getRequestTimeout();
 
-                            Connection protonConnection = Connection.Factory.create();
-
                             if (getMaxFrameSize() > 0) {
                                 protonTransport.setMaxFrameSize(getMaxFrameSize());
                             }
+
                             protonTransport.setChannelMax(getChannelMax());
                             protonTransport.setIdleTimeout(idleTimeout);
                             protonTransport.bind(protonConnection);
                             protonConnection.collect(protonCollector);
 
-                            AmqpSaslAuthenticator authenticator = null;
                             if (saslLayer) {
                                 Sasl sasl = protonTransport.sasl();
                                 sasl.client();
@@ -305,7 +304,7 @@ public class AmqpProvider implements Provider, TransportListener {
                                 authenticator = new AmqpSaslAuthenticator(sasl, connectionInfo, getLocalPrincipal(), saslMechanisms);
                             }
 
-                            connection = new AmqpConnection(AmqpProvider.this, protonConnection, authenticator, connectionInfo);
+                            AmqpConnectionBuilder builder = new AmqpConnectionBuilder(AmqpProvider.this, connectionInfo);
                             AsyncResult wrappedOpenRequest = new AsyncResult() {
                                 @Override
                                 public void onSuccess() {
@@ -326,14 +325,13 @@ public class AmqpProvider implements Provider, TransportListener {
 
                             connectionOpenRequest = wrappedOpenRequest;
 
-                            connection.open(wrappedOpenRequest);
+                            builder.buildResource(wrappedOpenRequest);
                         }
 
                         @Override
                         public void processDestination(JmsTemporaryDestination destination) throws Exception {
                             if (destination.isTemporary()) {
-                                AmqpTemporaryDestination temporary = connection.createTemporaryDestination(destination);
-                                temporary.open(request);
+                                connection.createTemporaryDestination(destination, request);
                             } else {
                                 request.onSuccess();
                             }
@@ -705,6 +703,7 @@ public class AmqpProvider implements Provider, TransportListener {
                 // Process the state changes from the latest data and then answer back
                 // any pending updates to the Broker.
                 processUpdates();
+                LOG.info("Pumping proton transport");
                 pumpToProtonTransport();
             }
         });
@@ -727,7 +726,7 @@ public class AmqpProvider implements Provider, TransportListener {
                     if (!closed.get()) {
                         fireProviderException(error);
                         if (connection != null) {
-                            connection.closed();
+                            connection.resourceClosed();
                         }
                     }
                 }
@@ -752,7 +751,7 @@ public class AmqpProvider implements Provider, TransportListener {
                         fireProviderException(new IOException("Transport connection remotely closed."));
                         //TODO: close the proton transport as well/instead?
                         if (connection != null) {
-                            connection.closed();
+                            connection.resourceClosed();
                         }
                     }
                 }
@@ -768,43 +767,43 @@ public class AmqpProvider implements Provider, TransportListener {
                     LOG.trace("New Proton Event: {}", protonEvent.getType());
                 }
 
-                AmqpResource amqpResource = null;
+                AmqpEventSink amqpEventSink = null;
                 switch (protonEvent.getType()) {
                     case CONNECTION_REMOTE_CLOSE:
-                        amqpResource = (AmqpResource) protonEvent.getConnection().getContext();
-                        amqpResource.processRemoteClose(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
+                        amqpEventSink.processRemoteClose(this);
                         break;
                     case CONNECTION_REMOTE_OPEN:
-                        amqpResource = (AmqpResource) protonEvent.getConnection().getContext();
-                        amqpResource.processRemoteOpen(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
+                        amqpEventSink.processRemoteOpen(this);
                         break;
                     case SESSION_REMOTE_CLOSE:
-                        amqpResource = (AmqpSession) protonEvent.getSession().getContext();
-                        amqpResource.processRemoteClose(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
+                        amqpEventSink.processRemoteClose(this);
                         break;
                     case SESSION_REMOTE_OPEN:
-                        amqpResource = (AmqpSession) protonEvent.getSession().getContext();
-                        amqpResource.processRemoteOpen(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
+                        amqpEventSink.processRemoteOpen(this);
                         break;
                     case LINK_REMOTE_CLOSE:
-                        amqpResource = (AmqpResource) protonEvent.getLink().getContext();
-                        amqpResource.processRemoteClose(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
+                        amqpEventSink.processRemoteClose(this);
                         break;
                     case LINK_REMOTE_DETACH:
-                        amqpResource = (AmqpResource) protonEvent.getLink().getContext();
-                        amqpResource.processRemoteDetach(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
+                        amqpEventSink.processRemoteDetach(this);
                         break;
                     case LINK_REMOTE_OPEN:
-                        amqpResource = (AmqpResource) protonEvent.getLink().getContext();
-                        amqpResource.processRemoteOpen(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
+                        amqpEventSink.processRemoteOpen(this);
                         break;
                     case LINK_FLOW:
-                        amqpResource = (AmqpResource) protonEvent.getLink().getContext();
-                        amqpResource.processFlowUpdates(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
+                        amqpEventSink.processFlowUpdates(this);
                         break;
                     case DELIVERY:
-                        amqpResource = (AmqpResource) protonEvent.getLink().getContext();
-                        amqpResource.processDeliveryUpdates(this);
+                        amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
+                        amqpEventSink.processDeliveryUpdates(this);
                         break;
                     default:
                         break;
@@ -814,15 +813,32 @@ public class AmqpProvider implements Provider, TransportListener {
             }
 
             // We have to do this to pump SASL bytes in as SASL is not event driven yet.
-            if (connection != null) {
-                connection.processSaslAuthentication();
-            }
+            processSaslAuthentication();
         } catch (Exception ex) {
             LOG.warn("Caught Exception during update processing: {}", ex.getMessage(), ex);
             fireProviderException(ex);
         }
     }
 
+    private void processSaslAuthentication() {
+        if (authenticator == null) {
+            return;
+        }
+
+        try {
+            if (authenticator.authenticate()) {
+                authenticator = null;
+            }
+        } catch (JMSSecurityException ex) {
+            try {
+                org.apache.qpid.proton.engine.Transport t = protonConnection.getTransport();
+                t.close_head();
+            } finally {
+                fireProviderException(ex);
+            }
+        }
+    }
+
     protected boolean pumpToProtonTransport() {
         return pumpToProtonTransport(NOOP_REQUEST);
     }
@@ -898,6 +914,18 @@ public class AmqpProvider implements Provider, TransportListener {
         }
     }
 
+    @Override
+    public void addChildResource(AmqpResource resource) {
+        if (resource instanceof AmqpConnection) {
+            this.connection = (AmqpConnection) resource;
+        }
+    }
+
+    @Override
+    public void removeChildResource(AmqpResource resource) {
+        // No need to remove resources
+    }
+
     //---------- Property Setters and Getters --------------------------------//
 
     @Override
@@ -1086,6 +1114,14 @@ public class AmqpProvider implements Provider, TransportListener {
         return remoteURI;
     }
 
+    public Transport getProtonTransport() {
+        return protonTransport;
+    }
+
+    public Connection getProtonConnection() {
+        return protonConnection;
+    }
+
     ScheduledExecutorService getScheduler() {
         return this.serializer;
     }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResource.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResource.java
index e1b71481..da558abf 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResource.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResource.java
@@ -16,136 +16,12 @@
  */
 package org.apache.qpid.jms.provider.amqp;
 
-import java.io.IOException;
-
-import org.apache.qpid.jms.provider.AsyncResult;
-
 /**
  * AmqpResource specification.
  *
  * All AMQP types should implement this interface to allow for control of state
  * and configuration details.
  */
-public interface AmqpResource {
-
-    /**
-     * Perform all the work needed to open this resource and store the request
-     * until such time as the remote peer indicates the resource has become active.
-     *
-     * @param request
-     *        The initiating request that triggered this open call.
-     */
-    void open(AsyncResult request);
-
-    /**
-     * @return if the resource has moved to the opened state on the remote.
-     */
-    boolean isOpen();
-
-    /**
-     * @return true if the resource is awaiting the remote end to signal opened.
-     */
-    boolean isAwaitingOpen();
-
-    /**
-     * Called to indicate that this resource is now remotely opened.  Once opened a
-     * resource can start accepting incoming requests.
-     */
-    void opened();
-
-    /**
-     * Perform all work needed to close this resource and store the request
-     * until such time as the remote peer indicates the resource has been closed.
-     *
-     * @param request
-     *        The initiating request that triggered this close call.
-     */
-    void close(AsyncResult request);
-
-    /**
-     * @return if the resource has moved to the closed state on the remote.
-     */
-    boolean isClosed();
-
-    /**
-     * @return true if the resource is awaiting the remote end to signal closed.
-     */
-    boolean isAwaitingClose();
-
-    /**
-     * Called to indicate that this resource is now remotely closed.  Once closed a
-     * resource can not accept any incoming requests.
-     */
-    void closed();
-
-    /**
-     * Called to indicate that the remote end has become closed but the resource
-     * was not awaiting an open/close completion.
-     *
-     * @param provider
-     *        a reference to the AMQP provider to use to send the remote close event.
-     */
-    void remotelyClosed(AmqpProvider provider);
-
-    /**
-     * Sets the failed state for this Resource and triggers a failure signal for
-     * any pending ProduverRequest.
-     *
-     * @param cause
-     *        The Exception that triggered the failure.
-     */
-    void failed(Exception cause);
-
-    /**
-     * Event handler for remote peer open of this resource.
-     *
-     * @param provider
-     *        the AmqpProvider instance for easier access to fire events.
-     *
-     * @throws IOException if an error occurs while processing the update.
-     */
-    void processRemoteOpen(AmqpProvider provider) throws IOException;
-
-    /**
-     * Event handler for remote peer detach of this resource.
-     *
-     * @param provider
-     *        the AmqpProvider instance for easier access to fire events.
-     *
-     * @throws IOException if an error occurs while processing the update.
-     */
-    void processRemoteDetach(AmqpProvider provider) throws IOException;
-
-    /**
-     * Event handler for remote peer close of this resource.
-     *
-     * @param provider
-     *        the AmqpProvider instance for easier access to fire events.
-     *
-     * @throws IOException if an error occurs while processing the update.
-     */
-    void processRemoteClose(AmqpProvider provider) throws IOException;
-
-    /**
-     * Called when the Proton Engine signals an Delivery related event has been triggered
-     * for the given endpoint.
-     *
-     * @param provider
-     *        the AmqpProvider instance for easier access to fire events.
-     *
-     * @throws IOException if an error occurs while processing the update.
-     */
-    void processDeliveryUpdates(AmqpProvider provider) throws IOException;
-
-    /**
-     * Called when the Proton Engine signals an Flow related event has been triggered
-     * for the given endpoint.
-     *
-     * @param provider
-     *        the AmqpProvider instance for easier access to fire events.
-     *
-     * @throws IOException if an error occurs while processing the update.
-     */
-    void processFlowUpdates(AmqpProvider provider) throws IOException;
+public interface AmqpResource extends AmqpEventSink {
 
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResourceParent.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResourceParent.java
new file mode 100644
index 00000000..6486719e
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpResourceParent.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp;
+
+/**
+ * Interface for any object that can will manage the lifetime of AmqpResource
+ * based object instances.
+ */
+public interface AmqpResourceParent {
+
+    /**
+     * Adds the given resource as a child of this resource so that it's
+     * lifetime becomes managed by that of its parent.
+     *
+     * @param resource
+     *      The AmqpResource that is a child of this one.
+     */
+    void addChildResource(AmqpResource resource);
+
+    /**
+     * Removes the given resource from the registered child resources
+     * managed by this one.
+     *
+     * @param resource
+     *      The AmqpResource that is no longer a child of this one.
+     */
+    void removeChildResource(AmqpResource resource);
+
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSession.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSession.java
index 96f47190..1123b979 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSession.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSession.java
@@ -31,58 +31,30 @@ import org.apache.qpid.jms.meta.JmsSessionId;
 import org.apache.qpid.jms.meta.JmsSessionInfo;
 import org.apache.qpid.jms.meta.JmsTransactionId;
 import org.apache.qpid.jms.provider.AsyncResult;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpConsumerBuilder;
+import org.apache.qpid.jms.provider.amqp.builders.AmqpProducerBuilder;
 import org.apache.qpid.proton.engine.Session;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
+public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> implements AmqpResourceParent {
 
     private static final Logger LOG = LoggerFactory.getLogger(AmqpSession.class);
 
     private final AmqpConnection connection;
-    private final AmqpTransactionContext txContext;
+    private AmqpTransactionContext txContext;
 
     private final Map<JmsConsumerId, AmqpConsumer> consumers = new HashMap<JmsConsumerId, AmqpConsumer>();
 
-    public AmqpSession(AmqpConnection connection, JmsSessionInfo info) {
-        super(info, connection.getProtonConnection().session());
+    public AmqpSession(AmqpConnection connection, JmsSessionInfo info, Session session) {
+        super(info, session);
         this.connection = connection;
-
-        this.resource.getSessionId().setProviderHint(this);
-        if (this.resource.isTransacted()) {
-            txContext = new AmqpTransactionContext(this);
-        } else {
-            txContext = null;
-        }
-    }
-
-    @Override
-    public void opened() {
-        if (this.txContext != null) {
-            this.txContext.open(openRequest);
-        } else {
-            super.opened();
-        }
-    }
-
-    @Override
-    protected void doOpen() {
-        long outgoingWindow = getProvider().getSessionOutgoingWindow();
-
-        Session session = this.getEndpoint();
-        session.setIncomingCapacity(Integer.MAX_VALUE);
-        if (outgoingWindow >= 0) {
-            session.setOutgoingWindow(outgoingWindow);
-        }
-
-        this.connection.addSession(this);
-
-        super.doOpen();
+        getResourceInfo().getSessionId().setProviderHint(this);
     }
 
     @Override
     protected void doClose() {
-        this.connection.removeSession(this);
+        connection.removeChildResource(this);
         super.doClose();
     }
 
@@ -108,20 +80,20 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
         }
     }
 
-    public AmqpProducer createProducer(JmsProducerInfo producerInfo) {
-        AmqpProducer producer = null;
-
-        if (producerInfo.getDestination() != null || connection.getProperties().isAnonymousRelaySupported()) {
-            LOG.debug("Creating AmqpFixedProducer for: {}", producerInfo.getDestination());
-            producer = new AmqpFixedProducer(this, producerInfo);
-        } else {
+    public void createProducer(JmsProducerInfo producerInfo, AsyncResult request) {
+        if (producerInfo.getDestination() == null && !getConnection().getProperties().isAnonymousRelaySupported()) {
             LOG.debug("Creating an AmqpAnonymousFallbackProducer");
-            producer = new AmqpAnonymousFallbackProducer(this, producerInfo);
-        }
 
-        producer.setPresettle(connection.isPresettleProducers());
+            AmqpProducer producer = new AmqpAnonymousFallbackProducer(this, producerInfo);
+            producer.setPresettle(getConnection().isPresettleProducers());
 
-        return producer;
+            // No producer is created yet so this is always successful.
+            request.onSuccess();
+        } else {
+            LOG.debug("Creating AmqpFixedProducer for: {}", producerInfo.getDestination());
+            AmqpProducerBuilder builder = new AmqpProducerBuilder(this, producerInfo);
+            builder.buildResource(request);
+        }
     }
 
     public AmqpProducer getProducer(JmsProducerInfo producerInfo) {
@@ -136,10 +108,9 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
         return null;
     }
 
-    public AmqpConsumer createConsumer(JmsConsumerInfo consumerInfo) {
-        AmqpConsumer result = new AmqpConsumer(this, consumerInfo);
-        result.setPresettle(connection.isPresettleConsumers());
-        return result;
+    public void createConsumer(JmsConsumerInfo consumerInfo, AsyncResult request) {
+        AmqpConsumerBuilder builder = new AmqpConsumerBuilder(this, consumerInfo);
+        builder.buildResource(request);
     }
 
     public AmqpConsumer getConsumer(JmsConsumerInfo consumerInfo) {
@@ -150,11 +121,11 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
         if (consumerId.getProviderHint() instanceof AmqpConsumer) {
             return (AmqpConsumer) consumerId.getProviderHint();
         }
-        return this.consumers.get(consumerId);
+        return consumers.get(consumerId);
     }
 
     public AmqpTransactionContext getTransactionContext() {
-        return this.txContext;
+        return txContext;
     }
 
     /**
@@ -169,7 +140,7 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
      * @throws Exception if an error occurs while performing the operation.
      */
     public void begin(JmsTransactionId txId, AsyncResult request) throws Exception {
-        if (!this.resource.isTransacted()) {
+        if (!getResourceInfo().isTransacted()) {
             throw new IllegalStateException("Non-transacted Session cannot start a TX.");
         }
 
@@ -185,7 +156,7 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
      * @throws Exception if an error occurs while performing the operation.
      */
     public void commit(AsyncResult request) throws Exception {
-        if (!this.resource.isTransacted()) {
+        if (!getResourceInfo().isTransacted()) {
             throw new IllegalStateException("Non-transacted Session cannot start a TX.");
         }
 
@@ -201,7 +172,7 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
      * @throws Exception if an error occurs while performing the operation.
      */
     public void rollback(AsyncResult request) throws Exception {
-        if (!this.resource.isTransacted()) {
+        if (!getResourceInfo().isTransacted()) {
             throw new IllegalStateException("Non-transacted Session cannot start a TX.");
         }
 
@@ -227,12 +198,28 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
         return getProvider().getScheduler().schedule(task, delay, TimeUnit.MILLISECONDS);
     }
 
-    void addResource(AmqpConsumer consumer) {
-        consumers.put(consumer.getConsumerId(), consumer);
+    @Override
+    public void addChildResource(AmqpResource resource) {
+        // delegate to the connection if the type is not managed here.
+        if (resource instanceof AmqpConsumer) {
+            AmqpConsumer consumer = (AmqpConsumer) resource;
+            consumers.put(consumer.getConsumerId(), consumer);
+        } else if (resource instanceof AmqpTransactionContext) {
+            txContext = (AmqpTransactionContext) resource;
+        } else {
+            connection.addChildResource(resource);
+        }
     }
 
-    void removeResource(AmqpConsumer consumer) {
-        consumers.remove(consumer.getConsumerId());
+    @Override
+    public void removeChildResource(AmqpResource resource) {
+        // delegate to the connection if the type is not managed here.
+        if (resource instanceof AmqpConsumer) {
+            AmqpConsumer consumer = (AmqpConsumer) resource;
+            consumers.remove(consumer.getConsumerId());
+        } else {
+            connection.removeChildResource(resource);
+        }
     }
 
     /**
@@ -246,7 +233,7 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
      */
     public boolean containsSubscription(String subscriptionName) {
         for (AmqpConsumer consumer : consumers.values()) {
-            if (subscriptionName.equals(consumer.getJmsResource().getSubscriptionName())) {
+            if (subscriptionName.equals(consumer.getResourceInfo().getSubscriptionName())) {
                 return true;
             }
         }
@@ -266,27 +253,27 @@ public class AmqpSession extends AmqpAbstractResource<JmsSessionInfo, Session> {
     }
 
     public AmqpProvider getProvider() {
-        return this.connection.getProvider();
+        return connection.getProvider();
     }
 
     public AmqpConnection getConnection() {
-        return this.connection;
+        return connection;
     }
 
     public JmsSessionId getSessionId() {
-        return this.resource.getSessionId();
+        return getResourceInfo().getSessionId();
     }
 
     public Session getProtonSession() {
-        return this.getEndpoint();
+        return getEndpoint();
     }
 
     boolean isTransacted() {
-        return this.resource.isTransacted();
+        return getResourceInfo().isTransacted();
     }
 
     boolean isAsyncAck() {
-        return this.resource.isSendAcksAsync() || isTransacted();
+        return getResourceInfo().isSendAcksAsync() || isTransacted();
     }
 
     @Override
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSupport.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSupport.java
index f23eb69d..9e5356de 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSupport.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpSupport.java
@@ -26,6 +26,7 @@ import javax.jms.JMSSecurityException;
 
 import org.apache.qpid.jms.provider.ProviderRedirectedException;
 import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.messaging.Modified;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ConnectionError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
@@ -54,6 +55,29 @@ public class AmqpSupport {
     public static final Symbol VERSION = Symbol.valueOf("version");
     public static final Symbol PLATFORM = Symbol.valueOf("platform");
 
+    // Symbols used for receivers.
+    public static final Symbol COPY = Symbol.getSymbol("copy");
+    public static final Symbol JMS_NO_LOCAL_SYMBOL = Symbol.valueOf("no-local");
+    public static final Symbol JMS_SELECTOR_SYMBOL = Symbol.valueOf("jms-selector");
+    public static final Modified MODIFIED_FAILED = new Modified();
+    public static final Modified MODIFIED_UNDELIVERABLE = new Modified();
+
+    // Temporary Destination constants
+    public static final Symbol DYNAMIC_NODE_LIFETIME_POLICY = Symbol.valueOf("lifetime-policy");
+    public static final String TEMP_QUEUE_CREATOR = "temp-queue-creator:";
+    public static final String TEMP_TOPIC_CREATOR = "temp-topic-creator:";
+
+    //----- Static initializer -----------------------------------------------//
+
+    static {
+        MODIFIED_FAILED.setDeliveryFailed(true);
+
+        MODIFIED_UNDELIVERABLE.setDeliveryFailed(true);
+        MODIFIED_UNDELIVERABLE.setUndeliverableHere(true);
+    }
+
+    //----- Utility Methods --------------------------------------------------//
+
     /**
      * Given an ErrorCondition instance create a new JMSException that best matches
      * the error type.
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTemporaryDestination.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTemporaryDestination.java
index 2759e7a8..ce87f946 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTemporaryDestination.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTemporaryDestination.java
@@ -16,23 +16,8 @@
  */
 package org.apache.qpid.jms.provider.amqp;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.qpid.jms.JmsDestination;
 import org.apache.qpid.jms.JmsTemporaryDestination;
-import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.messaging.DeleteOnClose;
-import org.apache.qpid.proton.amqp.messaging.Source;
-import org.apache.qpid.proton.amqp.messaging.Target;
-import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
-import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
-import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
 import org.apache.qpid.proton.engine.Sender;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * Manages a Temporary Destination linked to a given Connection.
@@ -48,116 +33,32 @@ import org.slf4j.LoggerFactory;
  */
 public class AmqpTemporaryDestination extends AmqpAbstractResource<JmsTemporaryDestination, Sender> {
 
-    public static final Symbol DYNAMIC_NODE_LIFETIME_POLICY = Symbol.valueOf("lifetime-policy");
-    private static final String TEMP_QUEUE_CREATOR = "temp-queue-creator:";
-    private static final String TEMP_TOPIC_CREATOR = "temp-topic-creator:";
-
-    private static final Logger LOG = LoggerFactory.getLogger(AmqpTemporaryDestination.class);
-
     private final AmqpConnection connection;
     private final AmqpSession session;
 
-    public AmqpTemporaryDestination(AmqpSession session, JmsTemporaryDestination destination) {
-        super(destination);
+    public AmqpTemporaryDestination(AmqpSession session, JmsTemporaryDestination destination, Sender endpoint) {
+        super(destination, endpoint);
+
         this.session = session;
         this.connection = session.getConnection();
     }
 
-    @Override
-    public void opened() {
-
-        // Once our producer is opened we can read the updated name from the target address.
-        String oldDestinationName = resource.getName();
-        String destinationName = getEndpoint().getRemoteTarget().getAddress();
-
-        this.resource.setName(destinationName);
-
-        LOG.trace("Updated temp destination to: {} from: {}", resource, oldDestinationName);
-
-        this.connection.addTemporaryDestination(this);
-
-        super.opened();
-    }
-
-    @Override
-    protected void doOpen() {
-        // Form a link name, use the local generated name with a prefix to aid debugging
-        String localDestinationName = resource.getName();
-        String senderLinkName = null;
-        if (resource.isQueue()) {
-            senderLinkName = "qpid-jms:" + TEMP_QUEUE_CREATOR + localDestinationName;
-        } else {
-            senderLinkName = "qpid-jms:" + TEMP_TOPIC_CREATOR + localDestinationName;
-        }
-
-        // Just use a bare Source, this is a producer which
-        // wont send anything and the link name is unique.
-        Source source = new Source();
-
-        Target target = new Target();
-        target.setDynamic(true);
-        target.setDurable(TerminusDurability.NONE);
-        target.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
-
-        // Set the dynamic node lifetime-policy
-        Map<Symbol, Object> dynamicNodeProperties = new HashMap<Symbol, Object>();
-        dynamicNodeProperties.put(DYNAMIC_NODE_LIFETIME_POLICY, DeleteOnClose.getInstance());
-        target.setDynamicNodeProperties(dynamicNodeProperties);
-
-        // Set the capability to indicate the node type being created
-        if (resource.isQueue()) {
-            target.setCapabilities(AmqpDestinationHelper.TEMP_QUEUE_CAPABILITY);
-        } else {
-            target.setCapabilities(AmqpDestinationHelper.TEMP_TOPIC_CAPABILITY);
-        }
-
-        Sender sender = session.getProtonSession().sender(senderLinkName);
-        sender.setSource(source);
-        sender.setTarget(target);
-        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
-        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
-        setEndpoint(sender);
-
-        super.doOpen();
-    }
-
-    @Override
-    protected void doOpenCompletion() {
-        // Verify the attach response contained a non-null target
-        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
-        if (target != null) {
-            super.doOpenCompletion();
-        } else {
-            // No link terminus was created, the peer will now detach/close us.
-        }
-    }
-
     @Override
     protected void doClose() {
-        this.connection.removeTemporaryDestination(this);
-
+        connection.removeChildResource(this);
         super.doClose();
     }
 
     public AmqpConnection getConnection() {
-        return this.connection;
+        return connection;
     }
 
     public AmqpSession getSession() {
-        return this.session;
-    }
-
-    public Sender getProtonSender() {
-        return getEndpoint();
-    }
-
-    public JmsDestination getJmsDestination() {
-        return this.resource;
+        return session;
     }
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + " { " + resource + "}";
+        return getClass().getSimpleName() + " { " + getResourceInfo() + "}";
     }
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java
index c150bb59..486aef51 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpTransactionContext.java
@@ -31,15 +31,10 @@ import org.apache.qpid.jms.util.IOExceptionSupport;
 import org.apache.qpid.proton.amqp.Binary;
 import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Source;
-import org.apache.qpid.proton.amqp.transaction.Coordinator;
 import org.apache.qpid.proton.amqp.transaction.Declare;
 import org.apache.qpid.proton.amqp.transaction.Declared;
 import org.apache.qpid.proton.amqp.transaction.Discharge;
-import org.apache.qpid.proton.amqp.transaction.TxnCapability;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
-import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.Sender;
 import org.apache.qpid.proton.message.Message;
@@ -68,13 +63,18 @@ public class AmqpTransactionContext extends AmqpAbstractResource<JmsSessionInfo,
     private AsyncResult pendingRequest;
 
     /**
-     * Creates a new AmqpTransaction instance.
+     * Creates a new AmqpTransactionContext instance.
      *
      * @param session
-     *        The session that owns this transaction
+     *        The session that owns this transaction context.
+     * @param resourceInfo
+     *        The resourceInfo that defines this transaction context.
+     * @param sender
+     *        The local sender endpoint for this transaction context.
      */
-    public AmqpTransactionContext(AmqpSession session) {
-        super(session.getJmsResource());
+    public AmqpTransactionContext(AmqpSession session, JmsSessionInfo resourceInfo, Sender sender) {
+        super(resourceInfo, sender);
+
         this.session = session;
     }
 
@@ -128,25 +128,6 @@ public class AmqpTransactionContext extends AmqpAbstractResource<JmsSessionInfo,
         }
     }
 
-    @Override
-    protected void doOpen() {
-        Coordinator coordinator = new Coordinator();
-        coordinator.setCapabilities(TxnCapability.LOCAL_TXN);
-        Source source = new Source();
-
-        String coordinatorName = "qpid-jms:coordinator:" + resource.getSessionId().toString();
-
-        Sender sender = session.getProtonSession().sender(coordinatorName);
-        sender.setSource(source);
-        sender.setTarget(coordinator);
-        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
-        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
-        setEndpoint(sender);
-
-        super.doOpen();
-    }
-
     public void begin(JmsTransactionId txId, AsyncResult request) throws Exception {
         if (current != null) {
             throw new IOException("Begin called while a TX is still Active.");
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java
new file mode 100644
index 00000000..f4c290f7
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java
@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.SOLE_CONNECTION_CAPABILITY;
+
+import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import javax.jms.Session;
+
+import org.apache.qpid.jms.meta.JmsConnectionInfo;
+import org.apache.qpid.jms.meta.JmsSessionInfo;
+import org.apache.qpid.jms.provider.AsyncResult;
+import org.apache.qpid.jms.provider.amqp.AmqpConnection;
+import org.apache.qpid.jms.provider.amqp.AmqpProvider;
+import org.apache.qpid.jms.provider.amqp.AmqpSupport;
+import org.apache.qpid.jms.util.MetaDataSupport;
+import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.engine.Connection;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpConnectionSession instance.
+ */
+public class AmqpConnectionBuilder extends AmqpResourceBuilder<AmqpConnection, AmqpProvider, JmsConnectionInfo, Connection> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AmqpConnectionBuilder.class);
+
+    public AmqpConnectionBuilder(AmqpProvider parent, JmsConnectionInfo resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    public void buildResource(final AsyncResult request) {
+
+        AsyncResult connectionRequest = new AsyncResult() {
+
+            @Override
+            public void onSuccess() {
+                // Create a Session for this connection that is used for Temporary Destinations
+                // and perhaps later on management and advisory monitoring.
+                JmsSessionInfo sessionInfo = new JmsSessionInfo(getResourceInfo(), -1);
+                sessionInfo.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
+
+                final AmqpConnectionSessionBuilder builder = new AmqpConnectionSessionBuilder(getResource(), sessionInfo);
+                builder.buildResource(new AsyncResult() {
+
+                    @Override
+                    public boolean isComplete() {
+                        return builder.getResource().isOpen();
+                    }
+
+                    @Override
+                    public void onSuccess() {
+                        LOG.debug("{} is now open: ", getResource());
+                        request.onSuccess();
+                    }
+
+                    @Override
+                    public void onFailure(Throwable result) {
+                        LOG.debug("AMQP Connection Session failed to open.");
+                        request.onFailure(result);
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(Throwable result) {
+                request.onFailure(result);
+            }
+
+            @Override
+            public boolean isComplete() {
+                return getResource().isOpen();
+            }
+        };
+
+        super.buildResource(connectionRequest);
+    }
+
+    @Override
+    protected void handleOpened(AmqpProvider provider) throws IOException {
+        // Initialize the connection properties so that the state of the remote can
+        // be determined, this allows us to check for close pending.
+        getResource().getProperties().initialize(
+            getEndpoint().getRemoteOfferedCapabilities(), getEndpoint().getRemoteProperties());
+
+        super.handleOpened(provider);
+    }
+
+    @Override
+    protected Connection createEndpoint(JmsConnectionInfo resourceInfo) {
+        String hostname = getParent().getVhost();
+        if (hostname == null) {
+            hostname = getParent().getRemoteURI().getHost();
+        } else if (hostname.isEmpty()) {
+            hostname = null;
+        }
+
+        Map<Symbol, Object> props = new LinkedHashMap<Symbol, Object>();
+        props.put(AmqpSupport.PRODUCT, MetaDataSupport.PROVIDER_NAME);
+        props.put(AmqpSupport.VERSION, MetaDataSupport.PROVIDER_VERSION);
+        props.put(AmqpSupport.PLATFORM, MetaDataSupport.PLATFORM_DETAILS);
+
+        Connection connection = getParent().getProtonConnection();
+        connection.setHostname(hostname);
+        connection.setContainer(resourceInfo.getClientId());
+        connection.setDesiredCapabilities(new Symbol[] { SOLE_CONNECTION_CAPABILITY });
+        connection.setProperties(props);
+
+        return connection;
+    }
+
+    @Override
+    protected AmqpConnection createResource(AmqpProvider parent, JmsConnectionInfo resourceInfo, Connection endpoint) {
+        return new AmqpConnection(parent, resourceInfo, endpoint);
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        return getResource().getProperties().isConnectionOpenFailed();
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionSessionBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionSessionBuilder.java
new file mode 100644
index 00000000..d87b0eb3
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionSessionBuilder.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import org.apache.qpid.jms.meta.JmsSessionInfo;
+import org.apache.qpid.jms.provider.amqp.AmqpConnection;
+import org.apache.qpid.jms.provider.amqp.AmqpConnectionSession;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.proton.engine.Session;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpConnectionSession instance.
+ */
+public class AmqpConnectionSessionBuilder extends AmqpSessionBuilder {
+
+    public AmqpConnectionSessionBuilder(AmqpConnection parent, JmsSessionInfo resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    protected AmqpSession createResource(AmqpConnection parent, JmsSessionInfo resourceInfo, Session endpoint) {
+        return new AmqpConnectionSession(parent, resourceInfo, endpoint);
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConsumerBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConsumerBuilder.java
new file mode 100644
index 00000000..50dece38
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConsumerBuilder.java
@@ -0,0 +1,156 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.COPY;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.JMS_NO_LOCAL_SYMBOL;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.JMS_SELECTOR_SYMBOL;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.MODIFIED_FAILED;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.jms.InvalidDestinationException;
+
+import org.apache.qpid.jms.JmsDestination;
+import org.apache.qpid.jms.meta.JmsConsumerInfo;
+import org.apache.qpid.jms.provider.amqp.AmqpConsumer;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.jms.provider.amqp.filters.AmqpJmsNoLocalType;
+import org.apache.qpid.jms.provider.amqp.filters.AmqpJmsSelectorType;
+import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
+import org.apache.qpid.proton.amqp.DescribedType;
+import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Modified;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Released;
+import org.apache.qpid.proton.amqp.messaging.Source;
+import org.apache.qpid.proton.amqp.messaging.Target;
+import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
+import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
+import org.apache.qpid.proton.engine.Receiver;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpConsumer instance.
+ */
+public class AmqpConsumerBuilder extends AmqpResourceBuilder<AmqpConsumer, AmqpSession, JmsConsumerInfo, Receiver> {
+
+    public AmqpConsumerBuilder(AmqpSession parent, JmsConsumerInfo consumerInfo) {
+        super(parent, consumerInfo);
+    }
+
+    @Override
+    protected Receiver createEndpoint(JmsConsumerInfo resourceInfo) {
+        JmsDestination destination = resourceInfo.getDestination();
+        String subscription = AmqpDestinationHelper.INSTANCE.getDestinationAddress(destination, getParent().getConnection());
+
+        Source source = new Source();
+        source.setAddress(subscription);
+        Target target = new Target();
+
+        configureSource(source);
+
+        String receiverName = "qpid-jms:receiver:" + resourceInfo.getConsumerId() + ":" + subscription;
+        if (resourceInfo.getSubscriptionName() != null && !resourceInfo.getSubscriptionName().isEmpty()) {
+            // In the case of Durable Topic Subscriptions the client must use the same
+            // receiver name which is derived from the subscription name property.
+            receiverName = resourceInfo.getSubscriptionName();
+        }
+
+        Receiver receiver = getParent().getProtonSession().receiver(receiverName);
+        receiver.setSource(source);
+        receiver.setTarget(target);
+        if (getParent().getConnection().isPresettleConsumers() || resourceInfo.isBrowser()) {
+            receiver.setSenderSettleMode(SenderSettleMode.SETTLED);
+        } else {
+            receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
+        }
+        receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
+
+        return receiver;
+    }
+
+    @Override
+    protected AmqpConsumer createResource(AmqpSession parent, JmsConsumerInfo resourceInfo, Receiver endpoint) {
+        return new AmqpConsumer(parent, resourceInfo, endpoint);
+    }
+
+    @Override
+    protected Exception getOpenAbortException() {
+        // Verify the attach response contained a non-null Source
+        org.apache.qpid.proton.amqp.transport.Source source = endpoint.getRemoteSource();
+        if (source != null) {
+            return super.getOpenAbortException();
+        } else {
+            // No link terminus was created, the peer has detach/closed us, create IDE.
+            return new InvalidDestinationException("Link creation was refused");
+        }
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        org.apache.qpid.proton.amqp.transport.Source source = endpoint.getRemoteSource();
+
+        // When no link terminus was created, the peer will now detach/close us otherwise
+        // we need to validate the returned remote source prior to open completion.
+        return source == null;
+    }
+
+    //----- Internal implementation ------------------------------------------//
+
+    private void configureSource(Source source) {
+        Map<Symbol, DescribedType> filters = new HashMap<Symbol, DescribedType>();
+        Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL,
+                                          Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL };
+
+        if (resourceInfo.getSubscriptionName() != null && !resourceInfo.getSubscriptionName().isEmpty()) {
+            source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
+            source.setDurable(TerminusDurability.UNSETTLED_STATE);
+            source.setDistributionMode(COPY);
+        } else {
+            source.setDurable(TerminusDurability.NONE);
+            source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
+        }
+
+        if (resourceInfo.isBrowser()) {
+            source.setDistributionMode(COPY);
+        }
+
+        Symbol typeCapability =  AmqpDestinationHelper.INSTANCE.toTypeCapability(resourceInfo.getDestination());
+        if(typeCapability != null) {
+            source.setCapabilities(typeCapability);
+        }
+
+        source.setOutcomes(outcomes);
+        source.setDefaultOutcome(MODIFIED_FAILED);
+
+        if (resourceInfo.isNoLocal()) {
+            filters.put(JMS_NO_LOCAL_SYMBOL, AmqpJmsNoLocalType.NO_LOCAL);
+        }
+
+        if (resourceInfo.getSelector() != null && !resourceInfo.getSelector().trim().equals("")) {
+            filters.put(JMS_SELECTOR_SYMBOL, new AmqpJmsSelectorType(resourceInfo.getSelector()));
+        }
+
+        if (!filters.isEmpty()) {
+            source.setFilter(filters);
+        }
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpProducerBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpProducerBuilder.java
new file mode 100644
index 00000000..29a47401
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpProducerBuilder.java
@@ -0,0 +1,104 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import javax.jms.InvalidDestinationException;
+
+import org.apache.qpid.jms.JmsDestination;
+import org.apache.qpid.jms.meta.JmsProducerInfo;
+import org.apache.qpid.jms.provider.amqp.AmqpFixedProducer;
+import org.apache.qpid.jms.provider.amqp.AmqpProducer;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
+import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Source;
+import org.apache.qpid.proton.amqp.messaging.Target;
+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
+import org.apache.qpid.proton.engine.Sender;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpProducer instance.
+ */
+public class AmqpProducerBuilder extends AmqpResourceBuilder<AmqpProducer, AmqpSession, JmsProducerInfo, Sender> {
+
+    public AmqpProducerBuilder(AmqpSession parent, JmsProducerInfo resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    protected Sender createEndpoint(JmsProducerInfo resourceInfo) {
+        JmsDestination destination = resourceInfo.getDestination();
+        String targetAddress = AmqpDestinationHelper.INSTANCE.getDestinationAddress(destination, getParent().getConnection());
+
+        Symbol[] outcomes = new Symbol[]{ Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL };
+        String sourceAddress = resourceInfo.getProducerId().toString();
+        Source source = new Source();
+        source.setAddress(sourceAddress);
+        source.setOutcomes(outcomes);
+        // TODO: default outcome. Accepted normally, Rejected for transaction controller?
+
+        Target target = new Target();
+        target.setAddress(targetAddress);
+        Symbol typeCapability =  AmqpDestinationHelper.INSTANCE.toTypeCapability(destination);
+        if (typeCapability != null) {
+            target.setCapabilities(typeCapability);
+        }
+
+        String senderName = "qpid-jms:sender:" + sourceAddress + ":" + targetAddress;
+
+        Sender sender = getParent().getProtonSession().sender(senderName);
+        sender.setSource(source);
+        sender.setTarget(target);
+        if (getParent().getConnection().isPresettleProducers()) {
+            sender.setSenderSettleMode(SenderSettleMode.SETTLED);
+        } else {
+            sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
+        }
+        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
+
+        return sender;
+    }
+
+    @Override
+    protected AmqpProducer createResource(AmqpSession parent, JmsProducerInfo resourceInfo, Sender endpoint) {
+        return new AmqpFixedProducer(getParent(), getResourceInfo(), endpoint);
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
+
+        // When no link terminus was created, the peer will now detach/close us otherwise
+        // we need to validate the returned remote source prior to open completion.
+        return target == null;
+    }
+
+    @Override
+    protected Exception getOpenAbortException() {
+        // Verify the attach response contained a non-null target
+        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
+        if (target != null) {
+            return super.getOpenAbortException();
+        } else {
+            // No link terminus was created, the peer has detach/closed us, create IDE.
+            return new InvalidDestinationException("Link creation was refused");
+        }
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpResourceBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpResourceBuilder.java
new file mode 100644
index 00000000..eed2b20c
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpResourceBuilder.java
@@ -0,0 +1,229 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import java.io.IOException;
+
+import org.apache.qpid.jms.meta.JmsResource;
+import org.apache.qpid.jms.provider.AsyncResult;
+import org.apache.qpid.jms.provider.amqp.AmqpEventSink;
+import org.apache.qpid.jms.provider.amqp.AmqpProvider;
+import org.apache.qpid.jms.provider.amqp.AmqpResource;
+import org.apache.qpid.jms.provider.amqp.AmqpResourceParent;
+import org.apache.qpid.jms.provider.amqp.AmqpSupport;
+import org.apache.qpid.proton.engine.Endpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Base for all AmqpResource builders.
+ */
+public abstract class AmqpResourceBuilder<TARGET extends AmqpResource, PARENT extends AmqpResourceParent, INFO extends JmsResource, ENDPOINT extends Endpoint> implements AmqpEventSink {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AmqpResourceBuilder.class);
+
+    protected AsyncResult request;
+    protected TARGET resource;
+    protected ENDPOINT endpoint;
+    protected final PARENT parent;
+    protected final INFO resourceInfo;
+
+    public AmqpResourceBuilder(PARENT parent, INFO resourceInfo) {
+        this.parent = parent;
+        this.resourceInfo = resourceInfo;
+    }
+
+    /**
+     * Called to initiate the process of building the resource type that is
+     * managed by this builder.  The resource is created and the open process
+     * occurs asynchronously.  If the resource is successfully opened it will
+     * added to its parent resource for use.
+     *
+     * @param request
+     *      The request that initiated the resource creation.
+     */
+    public void buildResource(AsyncResult request) {
+        this.request = request;
+
+        // Create the local end of the manage resource.
+        endpoint = createEndpoint(resourceInfo);
+        endpoint.setContext(this);
+        endpoint.open();
+
+        // Create the resource object now
+        resource = createResource(parent, resourceInfo, endpoint);
+    }
+
+    //----- Event handlers ---------------------------------------------------//
+
+    @Override
+    public void processRemoteOpen(AmqpProvider provider) throws IOException {
+        handleOpened(provider);
+    }
+
+    @Override
+    public void processRemoteClose(AmqpProvider provider) throws IOException {
+        handleClosed(provider);
+    }
+
+    @Override
+    public void processRemoteDetach(AmqpProvider provider) throws IOException {
+        // No implementation needed here for this event.
+    }
+
+    @Override
+    public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
+        // No implementation needed here for this event.
+    }
+
+    @Override
+    public void processFlowUpdates(AmqpProvider provider) throws IOException {
+        // No implementation needed here for this event.
+    }
+
+    //----- Standard open and close handlers ---------------------------------//
+
+    protected void handleOpened(AmqpProvider provider) throws IOException {
+
+        if (isClosePending()) {
+            return;
+        }
+
+        if (isOpenedEndpointValid()) {
+            afterOpened();
+
+            getEndpoint().setContext(resource);
+            getParent().addChildResource(resource);
+            getRequest().onSuccess();
+        } else {
+            getEndpoint().close();
+            getEndpoint().free();
+
+            // TODO: Perhaps the validate method should thrown an exception so that we
+            // can return a specific error message to the create initiator.
+            getRequest().onFailure(new IOException("Failed to open requested endpoint"));
+        }
+    }
+
+    protected void handleClosed(AmqpProvider provider) throws IOException {
+        // If the resource being built is closed during the creation process
+        // then this is always an error.
+
+        Exception openError;
+        if (hasRemoteError()) {
+            openError = AmqpSupport.convertToException(getEndpoint().getRemoteCondition());
+        } else {
+            openError = getOpenAbortException();
+        }
+
+        LOG.warn("Open of resource:({}) failed: {}", resourceInfo, openError.getMessage());
+
+        // This resource is now terminated.
+        getEndpoint().close();
+        getEndpoint().free();
+
+        getRequest().onFailure(openError);
+    }
+
+    //----- Implementation methods used to customize the build process -------//
+
+    /**
+     * Given the resource information provided create and configure the local endpoint
+     * whose open phase is managed by this builder.
+     *
+     * @return a new endpoint to be managed.
+     */
+    protected abstract ENDPOINT createEndpoint(INFO resourceInfo);
+
+    /**
+     * Create the managed resource instance.
+     *
+     * @param parent
+     *      The parent of the newly created resource.
+     * @param resourceInfo
+     *      The resource information used to configure the resource.
+     * @param endpoint
+     *      The local endpoint for the managed resource to wrap.
+     *
+     * @return the resource instance who open life-cycle is managed by this builder.
+     */
+    protected abstract TARGET createResource(PARENT parent, INFO resourceInfo, ENDPOINT endpoint);
+
+    /**
+     * If the resource was opened but its current state indicates a close is pending
+     * then we do no need to proceed further into the resource creation process.  Each
+     * endpoint build must implement this and examine the opened endpoint to determine
+     * if a close frame will follow the open.
+     *
+     * @return true if the resource state indicates it will be immediately closed.
+     */
+    protected abstract boolean isClosePending();
+
+    /**
+     * Following the open of the endpoint implementations of this method should validate
+     * that the endpoint properties match what was requested.
+     *
+     * @return true if the endpoint is valid based on what was requested.
+     */
+    protected boolean isOpenedEndpointValid() {
+        return true;
+    }
+
+    /**
+     * Called once an endpoint has been opened and validated to give the subclasses a
+     * place to perform any follow-on processing or setup steps before the operation
+     * is deemed to have been completed and success is signalled.
+     */
+    protected void afterOpened() {
+        // Nothing to do here.
+    }
+
+    protected boolean hasRemoteError() {
+        return getEndpoint().getRemoteCondition().getCondition() != null;
+    }
+
+    /**
+     * When aborting the open operation, and there isn't an error condition,
+     * provided by the peer, the returned exception will be used instead.
+     * A subclass may override this method to provide alternative behavior.
+     */
+    protected Exception getOpenAbortException() {
+        return new IOException("Open failed unexpectedly.");
+    }
+
+    //----- Public access methods for the managed resources ------------------//
+
+    public ENDPOINT getEndpoint() {
+        return endpoint;
+    }
+
+    public AsyncResult getRequest() {
+        return request;
+    }
+
+    public TARGET getResource() {
+        return resource;
+    }
+
+    public PARENT getParent() {
+        return parent;
+    }
+
+    public INFO getResourceInfo() {
+        return resourceInfo;
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpSessionBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpSessionBuilder.java
new file mode 100644
index 00000000..439f08cb
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpSessionBuilder.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import org.apache.qpid.jms.meta.JmsSessionInfo;
+import org.apache.qpid.jms.provider.AsyncResult;
+import org.apache.qpid.jms.provider.amqp.AmqpConnection;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.proton.engine.Session;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpSession instance.
+ */
+public class AmqpSessionBuilder extends AmqpResourceBuilder<AmqpSession, AmqpConnection, JmsSessionInfo, Session> {
+
+    public AmqpSessionBuilder(AmqpConnection parent, JmsSessionInfo resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    public void buildResource(final AsyncResult request) {
+
+        AsyncResult opened = request;
+
+        if (getResourceInfo().isTransacted()) {
+            opened = new AsyncResult() {
+
+                @Override
+                public void onSuccess() {
+                    AmqpTransactionContextBuilder builder = new AmqpTransactionContextBuilder(getResource(), getResourceInfo());
+                    builder.buildResource(request);
+                }
+
+                @Override
+                public void onFailure(Throwable result) {
+                    request.onFailure(result);
+                }
+
+                @Override
+                public boolean isComplete() {
+                    return request.isComplete();
+                }
+            };
+        }
+
+        super.buildResource(opened);
+    }
+
+    @Override
+    protected Session createEndpoint(JmsSessionInfo resourceInfo) {
+        long outgoingWindow = getParent().getProvider().getSessionOutgoingWindow();
+
+        Session session = getParent().getProtonConnection().session();
+        session.setIncomingCapacity(Integer.MAX_VALUE);
+        if (outgoingWindow >= 0) {
+            session.setOutgoingWindow(outgoingWindow);
+        }
+
+        return session;
+    }
+
+    @Override
+    protected AmqpSession createResource(AmqpConnection parent, JmsSessionInfo resourceInfo, Session endpoint) {
+        return new AmqpSession(parent, resourceInfo, endpoint);
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        return false;
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTemporaryDestinationBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTemporaryDestinationBuilder.java
new file mode 100644
index 00000000..93e0f915
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTemporaryDestinationBuilder.java
@@ -0,0 +1,118 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.DYNAMIC_NODE_LIFETIME_POLICY;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.TEMP_QUEUE_CREATOR;
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.TEMP_TOPIC_CREATOR;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.qpid.jms.JmsTemporaryDestination;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.jms.provider.amqp.AmqpTemporaryDestination;
+import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
+import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.messaging.DeleteOnClose;
+import org.apache.qpid.proton.amqp.messaging.Source;
+import org.apache.qpid.proton.amqp.messaging.Target;
+import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
+import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
+import org.apache.qpid.proton.engine.Sender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpTemporaryDestination instance.
+ */
+public class AmqpTemporaryDestinationBuilder extends AmqpResourceBuilder<AmqpTemporaryDestination, AmqpSession, JmsTemporaryDestination, Sender> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AmqpTemporaryDestinationBuilder.class);
+
+    public AmqpTemporaryDestinationBuilder(AmqpSession parent, JmsTemporaryDestination resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    protected Sender createEndpoint(JmsTemporaryDestination resourceInfo) {
+        // Form a link name, use the local generated name with a prefix to aid debugging
+        String localDestinationName = resourceInfo.getName();
+        String senderLinkName = null;
+        if (resourceInfo.isQueue()) {
+            senderLinkName = "qpid-jms:" + TEMP_QUEUE_CREATOR + localDestinationName;
+        } else {
+            senderLinkName = "qpid-jms:" + TEMP_TOPIC_CREATOR + localDestinationName;
+        }
+
+        // Just use a bare Source, this is a producer which
+        // wont send anything and the link name is unique.
+        Source source = new Source();
+
+        Target target = new Target();
+        target.setDynamic(true);
+        target.setDurable(TerminusDurability.NONE);
+        target.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
+
+        // Set the dynamic node lifetime-policy
+        Map<Symbol, Object> dynamicNodeProperties = new HashMap<Symbol, Object>();
+        dynamicNodeProperties.put(DYNAMIC_NODE_LIFETIME_POLICY, DeleteOnClose.getInstance());
+        target.setDynamicNodeProperties(dynamicNodeProperties);
+
+        // Set the capability to indicate the node type being created
+        if (resourceInfo.isQueue()) {
+            target.setCapabilities(AmqpDestinationHelper.TEMP_QUEUE_CAPABILITY);
+        } else {
+            target.setCapabilities(AmqpDestinationHelper.TEMP_TOPIC_CAPABILITY);
+        }
+
+        Sender sender = getParent().getProtonSession().sender(senderLinkName);
+        sender.setSource(source);
+        sender.setTarget(target);
+        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
+        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
+
+        return sender;
+    }
+
+    @Override
+    protected AmqpTemporaryDestination createResource(AmqpSession parent, JmsTemporaryDestination resourceInfo, Sender endpoint) {
+        return new AmqpTemporaryDestination(getParent(), getResourceInfo(), endpoint);
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
+
+        // When no link terminus was created, the peer will now detach/close us otherwise
+        // we need to validate the returned remote source prior to open completion.
+        return target == null;
+    }
+
+    @Override
+    protected void afterOpened() {
+        // Once our sender is opened we can read the updated name from the target address.
+        String oldDestinationName = resourceInfo.getName();
+        String destinationName = getEndpoint().getRemoteTarget().getAddress();
+
+        resourceInfo.setName(destinationName);
+
+        LOG.trace("Updated temp destination to: {} from: {}", destinationName, oldDestinationName);
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTransactionContextBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTransactionContextBuilder.java
new file mode 100644
index 00000000..7398ec1a
--- /dev/null
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpTransactionContextBuilder.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.qpid.jms.provider.amqp.builders;
+
+import org.apache.qpid.jms.meta.JmsSessionInfo;
+import org.apache.qpid.jms.provider.amqp.AmqpSession;
+import org.apache.qpid.jms.provider.amqp.AmqpTransactionContext;
+import org.apache.qpid.proton.amqp.messaging.Source;
+import org.apache.qpid.proton.amqp.transaction.Coordinator;
+import org.apache.qpid.proton.amqp.transaction.TxnCapability;
+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
+import org.apache.qpid.proton.engine.Sender;
+
+/**
+ * Resource builder responsible for creating and opening an AmqpTemporaryDestination instance.
+ */
+public class AmqpTransactionContextBuilder extends AmqpResourceBuilder<AmqpTransactionContext, AmqpSession, JmsSessionInfo, Sender> {
+
+    public AmqpTransactionContextBuilder(AmqpSession parent, JmsSessionInfo resourceInfo) {
+        super(parent, resourceInfo);
+    }
+
+    @Override
+    protected Sender createEndpoint(JmsSessionInfo resourceInfo) {
+        Coordinator coordinator = new Coordinator();
+        coordinator.setCapabilities(TxnCapability.LOCAL_TXN);
+        Source source = new Source();
+
+        String coordinatorName = "qpid-jms:coordinator:" + resourceInfo.getSessionId().toString();
+
+        Sender sender = getParent().getProtonSession().sender(coordinatorName);
+        sender.setSource(source);
+        sender.setTarget(coordinator);
+        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);
+        sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
+
+        return sender;
+    }
+
+    @Override
+    protected AmqpTransactionContext createResource(AmqpSession parent, JmsSessionInfo resourceInfo, Sender endpoint) {
+        return new AmqpTransactionContext(parent, resourceInfo, endpoint);
+    }
+
+    @Override
+    protected boolean isClosePending() {
+        org.apache.qpid.proton.amqp.transport.Target target = getEndpoint().getRemoteTarget();
+
+        // When no link terminus was created, the peer will now detach/close us otherwise
+        // we need to validate the returned remote source prior to open completion.
+        return target == null;
+    }
+}
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsNoLocalType.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsNoLocalType.java
similarity index 96%
rename from qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsNoLocalType.java
rename to qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsNoLocalType.java
index 24c62866..e042f505 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsNoLocalType.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsNoLocalType.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.qpid.jms.provider.amqp;
+package org.apache.qpid.jms.provider.amqp.filters;
 
 import org.apache.qpid.proton.amqp.DescribedType;
 import org.apache.qpid.proton.amqp.UnsignedLong;
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsSelectorType.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsSelectorType.java
similarity index 96%
rename from qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsSelectorType.java
rename to qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsSelectorType.java
index c6c26015..3b10ad5b 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpJmsSelectorType.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/filters/AmqpJmsSelectorType.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.qpid.jms.provider.amqp;
+package org.apache.qpid.jms.provider.amqp.filters;
 
 import org.apache.qpid.proton.amqp.DescribedType;
 import org.apache.qpid.proton.amqp.UnsignedLong;
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java
index a3b2b15a..3e032952 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/ConnectionIntegrationTest.java
@@ -99,7 +99,7 @@ public class ConnectionIntegrationTest extends QpidJmsTestCase {
         }
     }
 
-    @Test(timeout = 20000)
+    @Test //(timeout = 20000)
     public void testCreateTransactedSession() throws Exception {
         try (TestAmqpPeer testPeer = new TestAmqpPeer();) {
             Connection connection = testFixture.establishConnecton(testPeer);
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
index ce48fdd6..9fae2d1d 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
@@ -18,6 +18,7 @@
  */
 package org.apache.qpid.jms.test.testpeer;
 
+import static org.apache.qpid.jms.provider.amqp.AmqpSupport.DYNAMIC_NODE_LIFETIME_POLICY;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.arrayContaining;
 import static org.hamcrest.Matchers.equalTo;
@@ -38,7 +39,6 @@ import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
 
 import org.apache.qpid.jms.provider.amqp.AmqpSupport;
-import org.apache.qpid.jms.provider.amqp.AmqpTemporaryDestination;
 import org.apache.qpid.jms.provider.amqp.message.AmqpDestinationHelper;
 import org.apache.qpid.jms.test.testpeer.basictypes.ReceiverSettleMode;
 import org.apache.qpid.jms.test.testpeer.basictypes.Role;
@@ -714,7 +714,7 @@ public class TestAmqpPeer implements AutoCloseable
         targetMatcher.withDynamic(equalTo(true));
         targetMatcher.withDurable(equalTo(TerminusDurability.NONE));
         targetMatcher.withExpiryPolicy(equalTo(TerminusExpiryPolicy.LINK_DETACH));
-        targetMatcher.withDynamicNodeProperties(hasEntry(equalTo(AmqpTemporaryDestination.DYNAMIC_NODE_LIFETIME_POLICY), new DeleteOnCloseMatcher()));
+        targetMatcher.withDynamicNodeProperties(hasEntry(equalTo(DYNAMIC_NODE_LIFETIME_POLICY), new DeleteOnCloseMatcher()));
         targetMatcher.withCapabilities(arrayContaining(nodeTypeCapability));
 
         final AttachMatcher attachMatcher = new AttachMatcher()
diff --git a/qpid-jms-client/src/test/resources/log4j.properties b/qpid-jms-client/src/test/resources/log4j.properties
index 11c98c63..c5c11d1a 100644
--- a/qpid-jms-client/src/test/resources/log4j.properties
+++ b/qpid-jms-client/src/test/resources/log4j.properties
@@ -18,7 +18,7 @@
 #
 # The logging properties used during tests..
 #
-log4j.rootLogger=INFO, out, stdout
+log4j.rootLogger=TRACE, out, stdout
 
 log4j.logger.org.apache.qpid.jms=DEBUG
 log4j.logger.org.apache.qpid.jms.provider=TRACE
