diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
index d3a77c7e..022bc0fa 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnection.java
@@ -18,7 +18,6 @@ package org.apache.qpid.jms;
 
 import java.io.IOException;
 import java.net.URI;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -1370,26 +1369,6 @@ public class JmsConnection implements AutoCloseable, Connection, TopicConnection
         onAsyncException(cause);
     }
 
-    @Override
-    public void onRemoteDiscovery(final List<URI> remotes) {
-        for (URI remote : remotes) {
-            LOG.trace("Discovered new remote at: {}", remote);
-        }
-
-        // Give listeners a chance to know what we've discovered.
-        if (!connectionListeners.isEmpty()) {
-            for (final JmsConnectionListener listener : connectionListeners) {
-                executor.submit(new Runnable() {
-
-                    @Override
-                    public void run() {
-                        listener.onRemoteDiscovery(remotes);
-                    }
-                });
-            }
-        }
-    }
-
     /**
      * Handles any asynchronous errors that occur from the JMS framework classes.
      *
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnectionListener.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnectionListener.java
index b25a2b1a..f9389f43 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnectionListener.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsConnectionListener.java
@@ -17,7 +17,6 @@
 package org.apache.qpid.jms;
 
 import java.net.URI;
-import java.util.List;
 
 import javax.jms.MessageConsumer;
 import javax.jms.MessageProducer;
@@ -105,12 +104,4 @@ public interface JmsConnectionListener {
      */
     void onProducerClosed(MessageProducer producer, Throwable cause);
 
-    /**
-     * Called when additional remote peers are discovered by this connection.
-     *
-     * @param remotes
-     * 		A list of remote peers that have been discovered.
-     */
-    void onRemoteDiscovery(List<URI> remotes);
-
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/DefaultProviderListener.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/DefaultProviderListener.java
index 6fe23349..1d98e015 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/DefaultProviderListener.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/DefaultProviderListener.java
@@ -18,7 +18,6 @@ package org.apache.qpid.jms.provider;
 
 import java.io.IOException;
 import java.net.URI;
-import java.util.List;
 
 import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
 import org.apache.qpid.jms.message.JmsOutboundMessageDispatch;
@@ -72,8 +71,4 @@ public class DefaultProviderListener implements ProviderListener {
     @Override
     public void onProviderException(Exception cause) {
     }
-
-    @Override
-    public void onRemoteDiscovery(List<URI> remotes) {
-    }
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/Provider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/Provider.java
index d8535791..a61cb349 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/Provider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/Provider.java
@@ -18,6 +18,7 @@ package org.apache.qpid.jms.provider;
 
 import java.io.IOException;
 import java.net.URI;
+import java.util.List;
 
 import javax.jms.JMSException;
 
@@ -77,6 +78,15 @@ public interface Provider {
      */
     URI getRemoteURI();
 
+    /**
+     * Returns a {@link List} of alternate remote peers (possibly found via discovery) to
+     * which the caller can attempt a recoonect should this provider connection fail. If there
+     * are no known alternates this method returns an empty {@link List}.
+     *
+     * @return a List or alternate remote URIs that could be connected to later.
+     */
+    List<URI> getAlternateURIs();
+
     /**
      * Create the Provider version of the given JmsResource.
      *
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderListener.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderListener.java
index 412242eb..a96de4f9 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderListener.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderListener.java
@@ -18,7 +18,6 @@ package org.apache.qpid.jms.provider;
 
 import java.io.IOException;
 import java.net.URI;
-import java.util.List;
 
 import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
 import org.apache.qpid.jms.message.JmsOutboundMessageDispatch;
@@ -156,15 +155,4 @@ public interface ProviderListener {
      */
     void onProviderException(Exception cause);
 
-    /**
-     * Called when additional remote peers are discovered.
-     * <p>
-     * If new peers are discovered their URIs are provided to listeners to allow for
-     * failover or update of client connection information.
-     *
-     * @param remotes
-     * 		A list of remote peers that have been discovered.
-     */
-    void onRemoteDiscovery(List<URI> remotes);
-
 }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderWrapper.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderWrapper.java
index 5b89c0ad..6dfa4c63 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderWrapper.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/ProviderWrapper.java
@@ -75,6 +75,11 @@ public class ProviderWrapper<E extends Provider> implements Provider, ProviderLi
         return next.getRemoteURI();
     }
 
+    @Override
+    public List<URI> getAlternateURIs() {
+        return next.getAlternateURIs();
+    }
+
     @Override
     public void create(JmsResource resource, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
         next.create(resource, request);
@@ -205,11 +210,6 @@ public class ProviderWrapper<E extends Provider> implements Provider, ProviderLi
         listener.onProviderException(cause);
     }
 
-    @Override
-    public void onRemoteDiscovery(List<URI> remotes) {
-        listener.onRemoteDiscovery(remotes);
-    }
-
     /**
      * @return the wrapped Provider.
      */
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
index f5c9e566..b68e161b 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpProvider.java
@@ -19,6 +19,7 @@ package org.apache.qpid.jms.provider.amqp;
 import java.io.IOException;
 import java.net.URI;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
@@ -112,7 +113,7 @@ public class AmqpProvider implements Provider, TransportListener , AmqpResourceP
     private static final NoOpAsyncResult NOOP_REQUEST = new NoOpAsyncResult();
 
     private volatile ProviderListener listener;
-    private AmqpConnection connection;
+    private volatile AmqpConnection connection;
     private AmqpSaslAuthenticator authenticator;
     private final Transport transport;
     private String vhost;
@@ -1063,13 +1064,6 @@ public class AmqpProvider implements Provider, TransportListener , AmqpResourceP
         }
     }
 
-    public void fireRemotesDiscovered(List<URI> remotes) {
-        ProviderListener listener = this.listener;
-        if (listener != null) {
-            listener.onRemoteDiscovery(remotes);
-        }
-    }
-
     @Override
     public void addChildResource(AmqpResource resource) {
         if (resource instanceof AmqpConnection) {
@@ -1292,6 +1286,27 @@ public class AmqpProvider implements Provider, TransportListener , AmqpResourceP
         return remoteURI;
     }
 
+    @Override
+    public List<URI> getAlternateURIs() {
+        List<URI> alternates = new ArrayList<>();
+
+        if (connection != null) {
+            // If there are failover servers in the open then we signal that to the listeners
+            List<AmqpRedirect> failoverList = connection.getProperties().getFailoverServerList();
+            if (!failoverList.isEmpty()) {
+                for (AmqpRedirect redirect : failoverList) {
+                    try {
+                        alternates.add(redirect.toURI());
+                    } catch (Exception ex) {
+                        LOG.trace("Error while creating URI from failover server: {}", redirect);
+                    }
+                }
+            }
+        }
+
+        return alternates;
+    }
+
     public org.apache.qpid.proton.engine.Transport getProtonTransport() {
         return protonTransport;
     }
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpRedirect.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpRedirect.java
index 2e2588ae..448fc5c3 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpRedirect.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/AmqpRedirect.java
@@ -200,6 +200,15 @@ public class AmqpRedirect {
         return URISupport.applyParameters(result, queryOptions);
     }
 
+    @Override
+    public String toString() {
+        try {
+            return toURI().toString();
+        } catch (Exception ex) {
+            return "<Invalid-Redirect-Value>";
+        }
+    }
+
     private static ProviderFactory findProviderFactoryByTransportScheme(String scheme) throws IOException {
         if (scheme == null || scheme.isEmpty()) {
             throw new IOException("No Transport scheme specified.");
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java
index def9c0c2..d599b824 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/amqp/builders/AmqpConnectionBuilder.java
@@ -148,10 +148,6 @@ public class AmqpConnectionBuilder extends AmqpResourceBuilder<AmqpConnection, A
                     LOG.trace("Error while creating URI from failover server: {}", redirect);
                 }
             }
-
-            if (!failoverURIs.isEmpty()) {
-                getResource().getProvider().fireRemotesDiscovered(failoverURIs);
-            }
         }
     }
 
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
index 28714c2c..5e381f03 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/provider/failover/FailoverProvider.java
@@ -594,21 +594,31 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
                 try {
                     FailoverProvider.this.provider = provider;
                     provider.setProviderListener(FailoverProvider.this);
+                    connectedURI = provider.getRemoteURI();
 
                     if (!firstConnection) {
                         LOG.debug("Signalling connection recovery: {}", provider);
 
                         // Stage 1: Allow listener to recover its resources
-                        listener.onConnectionRecovery(provider);
+                        try {
+                            listener.onConnectionRecovery(provider);
+                        } finally {
+                            // Stage 2: If the provider knows of others lets add them to the URI pool
+                            //          even if something failed here we can learn of new hosts so we
+                            //          always process the potential Open frame failover URI results.
+                            processAlternates(provider.getAlternateURIs());
+                        }
 
-                        // Stage 2: Connection state recovered, get newly configured message factory.
+                        // Stage 3: Connection state recovered, get newly configured message factory.
                         FailoverProvider.this.messageFactory.set(provider.getMessageFactory());
 
-                        // Stage 3: Restart consumers, send pull commands, etc.
+                        // Stage 4: Restart consumers, send pull commands, etc.
                         listener.onConnectionRecovered(provider);
 
-                        // Stage 4: Let the client know that connection has restored.
+                        // Stage 5: Let the client know that connection has restored.
                         listener.onConnectionRestored(provider.getRemoteURI());
+                    } else {
+                        processAlternates(provider.getAlternateURIs());
                     }
 
                     // Last step: Send pending actions.
@@ -619,7 +629,6 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
 
                     nextReconnectDelay = reconnectDelay;
                     reconnectAttempts = 0;
-                    connectedURI = provider.getRemoteURI();
                     uris.connected();
 
                     // Cancel timeout processing since we are connected again.  We waited until
@@ -844,56 +853,36 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
         });
     }
 
-    @Override
-    public void onRemoteDiscovery(final List<URI> discovered) {
-        if (closingConnection.get() || closed.get() || failed.get()) {
-            return;
-        }
-
-        if (discovered == null || discovered.isEmpty()) {
-            return;
-        }
-
-        serializer.execute(new Runnable() {
-            @Override
-            public void run() {
-                if (!closingConnection.get() && !closed.get() && !failed.get()) {
-
-                    List<URI> newRemotes = new ArrayList<URI>(discovered);
-                    switch (amqpOpenServerListAction) {
-                        case ADD:
-                            try {
-                                uris.addAll(discovered);
-                            } catch (Throwable err) {
-                                LOG.warn("Error while attempting to add discovered URIs: {}", discovered);
-                            }
-                            break;
-                        case REPLACE:
-                            // The current server is assumed not to be in the list of updated remote
-                            // as it is meant for the failover nodes. The pool will de-dup if it is.
-                            newRemotes.add(0, connectedURI);
-                            try {
-                                LOG.info("Replacing uris:{} with new set: {}", uris, newRemotes);
-                                uris.replaceAll(newRemotes);
-                            } catch (Throwable err) {
-                                LOG.warn("Error while attempting to add discovered URIs: {}", discovered);
-                            }
-                            break;
-                        case IGNORE:
-                            // Do Nothing
-                            break;
-                        default:
-                            // Shouldn't get here, but do nothing if we do.
-                            break;
+    private void processAlternates(List<URI> alternates) {
+        if (!alternates.isEmpty()) {
+            List<URI> newRemotes = new ArrayList<URI>(alternates);
+            switch (amqpOpenServerListAction) {
+                case ADD:
+                    try {
+                        uris.addAll(alternates);
+                    } catch (Throwable err) {
+                        LOG.warn("Error while attempting to add discovered URIs: {}", alternates);
                     }
-
-                    // Inform any listener that we've made a new discovery.
-                    if (listener != null) {
-                        listener.onRemoteDiscovery(discovered);
+                    break;
+                case REPLACE:
+                    // The current server is assumed not to be in the list of updated remote
+                    // as it is meant for the failover nodes. The pool will de-dup if it is.
+                    newRemotes.add(0, connectedURI);
+                    try {
+                        LOG.info("Replacing uris:{} with new set: {}", uris, newRemotes);
+                        uris.replaceAll(newRemotes);
+                    } catch (Throwable err) {
+                        LOG.warn("Error while attempting to add discovered URIs: {}", alternates);
                     }
-                }
+                    break;
+                case IGNORE:
+                    // Do Nothing
+                    break;
+                default:
+                    // Shouldn't get here, but do nothing if we do.
+                    break;
             }
-        });
+        }
     }
 
     //--------------- URI update and rebalance methods -----------------------//
@@ -927,6 +916,16 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
         return null;
     }
 
+
+    @Override
+    public List<URI> getAlternateURIs() {
+        Provider provider = this.provider;
+        if (provider != null) {
+            return provider.getAlternateURIs();
+        }
+        return null;
+    };
+
     @Override
     public void setProviderListener(ProviderListener listener) {
         this.listener = listener;
@@ -1236,6 +1235,7 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
                     if (firstConnection) {
                         LOG.trace("First connection requst has completed:");
                         FailoverProvider.this.messageFactory.set(provider.getMessageFactory());
+                        processAlternates(provider.getAlternateURIs());
                         listener.onConnectionEstablished(provider.getRemoteURI());
                         firstConnection = false;
                     } else {
@@ -1257,6 +1257,9 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
                 serializer.execute(new Runnable() {
                     @Override
                     public void run() {
+                        // If we managed to receive an Open frame it might contain
+                        // a failover update so process it before handling the error.
+                        processAlternates(provider.getAlternateURIs());
                         handleProviderFailure(IOExceptionSupport.create(result));
                     }
                 });
@@ -1270,5 +1273,5 @@ public class FailoverProvider extends DefaultProviderListener implements Provide
 
     private static enum FailoverServerListAction {
         ADD, REPLACE, IGNORE
-    };
+    }
 }
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/JmsDefaultConnectionListener.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/JmsDefaultConnectionListener.java
index b1528945..c1b8b9ec 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/JmsDefaultConnectionListener.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/JmsDefaultConnectionListener.java
@@ -19,7 +19,6 @@
 package org.apache.qpid.jms;
 
 import java.net.URI;
-import java.util.List;
 
 import javax.jms.MessageConsumer;
 import javax.jms.MessageProducer;
@@ -60,8 +59,4 @@ public class JmsDefaultConnectionListener implements JmsConnectionListener {
     @Override
     public void onProducerClosed(MessageProducer producer, Throwable cause) {
     }
-
-    @Override
-    public void onRemoteDiscovery(List<URI> remotes) {
-    }
 }
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/mock/MockProvider.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/mock/MockProvider.java
index 6ea4a951..7a198675 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/mock/MockProvider.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/provider/mock/MockProvider.java
@@ -18,6 +18,8 @@ package org.apache.qpid.jms.provider.mock;
 
 import java.io.IOException;
 import java.net.URI;
+import java.util.Collections;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.ThreadFactory;
@@ -169,6 +171,11 @@ public class MockProvider implements Provider {
         return remoteURI;
     }
 
+    @Override
+    public List<URI> getAlternateURIs() {
+        return Collections.emptyList();
+    }
+
     @Override
     public void create(final JmsResource resource, final AsyncResult request) throws IOException, JMSException {
         checkClosed();
@@ -513,5 +520,4 @@ public class MockProvider implements Provider {
             throw new ProviderClosedException("This Provider is already closed");
         }
     }
-
 }
\ No newline at end of file
