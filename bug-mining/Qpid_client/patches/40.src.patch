diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
index f3f7740a..80f16fcc 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
@@ -691,7 +691,7 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                         LOG.trace("{} filtered expired message: {}", getConsumerId(), envelope);
                         doAckExpired(envelope);
                     } else if (redeliveryExceeded(envelope)) {
-                        LOG.trace("{} filtered message with excessive redlivery count: {}", getConsumerId(), envelope);
+                        LOG.trace("{} filtered message with excessive redelivery count: {}", getConsumerId(), envelope);
                         doAckUndeliverable(envelope);
                     } else {
                         boolean autoAckOrDupsOk = acknowledgementMode == Session.AUTO_ACKNOWLEDGE ||
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
index 6b91559a..25e05ba9 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/integration/SessionIntegrationTest.java
@@ -32,6 +32,7 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
 import javax.jms.Connection;
 import javax.jms.Destination;
@@ -927,10 +928,16 @@ public class SessionIntegrationTest extends QpidJmsTestCase {
                 testPeer.expectDisposition(true, modified);
             }
 
-            MessageConsumer consumer = session.createConsumer(queue);
-            consumer.receive(100);
+            final MessageConsumer consumer = session.createConsumer(queue);
 
-            testPeer.waitForAllHandlersToComplete(1000);
+            assertTrue("Messages were not rejected as expected",
+                            Wait.waitFor(new Wait.Condition() {
+                                @Override
+                                public boolean isSatisified() throws Exception {
+                                    consumer.receive(20);
+                                    return testPeer.waitForAllHandlersToCompleteNoAssert(10);
+                                }
+                            }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(2)));
         }
     }
 
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
index d5f84c07..f9ca6417 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/test/testpeer/TestAmqpPeer.java
@@ -300,16 +300,20 @@ public class TestAmqpPeer implements AutoCloseable
     }
 
     public void waitForAllHandlersToComplete(int timeoutMillis) throws InterruptedException
+    {
+        boolean countedDownOk =  waitForAllHandlersToCompleteNoAssert(timeoutMillis);
+
+        Assert.assertTrue("All handlers should have completed within the " + timeoutMillis + "ms timeout", countedDownOk);
+    }
+
+    public boolean waitForAllHandlersToCompleteNoAssert(int timeoutMillis) throws InterruptedException
     {
         synchronized(_handlersLock)
         {
             _handlersCompletedLatch = new CountDownLatch(_handlers.size());
         }
 
-        boolean countedDownOk = _handlersCompletedLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);
-
-        Assert.assertTrue(
-                "All handlers should have completed within the " + timeoutMillis + "ms timeout", countedDownOk);
+        return _handlersCompletedLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);
     }
 
     void sendHeader(byte[] header)
