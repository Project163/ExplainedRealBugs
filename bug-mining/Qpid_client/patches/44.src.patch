diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
index e492d4a1..78234993 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/JmsMessageConsumer.java
@@ -274,16 +274,19 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
                 }
 
                 if (envelope == null) {
-                    if (timeout > 0 && !messageQueue.isClosed()) {
+
+                    if (failureCause != null && !messageQueue.isClosed() && timeout == 0) {
+                        LOG.debug("{} receive failed: {}", getConsumerId(), failureCause.getMessage());
+                        throw JmsExceptionSupport.create(failureCause);
+                    }
+
+                    if (timeout == 0 || messageQueue.isClosed()) {
+                        return null;
+                    } else if (timeout > 0) {
                         timeout = Math.max(deadline - System.currentTimeMillis(), 0);
-                    } else {
-                        if (failureCause != null && !messageQueue.isClosed()) {
-                            LOG.debug("{} receive failed: {}", getConsumerId(), failureCause.getMessage());
-                            throw JmsExceptionSupport.create(failureCause);
-                        } else {
-                            return null;
-                        }
                     }
+
+                    sendPullCommand(timeout);
                 } else if (envelope.getMessage() == null) {
                     LOG.trace("{} no message was available for this consumer: {}", getConsumerId());
                     return null;
@@ -621,9 +624,6 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
     }
 
     protected void onConnectionInterrupted() {
-        // TODO - We might want to wake all blocking receive calls
-        //        to interrupt pull consumers, although that also
-        //        wakes infinite wait receivers so how to deal with that?
         messageQueue.clear();
     }
 
@@ -637,6 +637,17 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
         ProviderFuture request = new ProviderFuture();
         provider.start(consumerInfo, request);
         request.sync();
+
+        // For a pull consumer we want to stop the Queue waking an blocked receives and
+        // preventing a new one from blocking until it has reissued a new pull.
+        if (isPullConsumer()) {
+            lock.lock();
+            try {
+                messageQueue.stop();
+            } finally {
+                lock.unlock();
+            }
+        }
     }
 
     protected void onConnectionRestored() {
@@ -657,6 +668,17 @@ public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableC
     protected void sendPullCommand(long timeout) throws JMSException {
         if (!messageQueue.isClosed() && messageQueue.isEmpty() && (getPrefetchSize() == 0 || isBrowser())) {
             connection.pull(getConsumerId(), timeout);
+
+            // Once a new pull has gone out check to see if the queue was stopped due to failover
+            // and restart it so that the receive calls can once again start blocking on dequeue.
+            lock.lock();
+            try {
+                if (started) {
+                    messageQueue.start();
+                }
+            } finally {
+                lock.unlock();
+            }
         }
     }
 
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/AbstractMessageQueue.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/AbstractMessageQueue.java
index f20c21f6..18f69916 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/AbstractMessageQueue.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/AbstractMessageQueue.java
@@ -29,17 +29,17 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     protected Object lock = new Object();
 
     @Override
-    public JmsInboundMessageDispatch peek() {
+    public final JmsInboundMessageDispatch peek() {
         synchronized (lock) {
             return peekFirst();
         }
     }
 
     @Override
-    public JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException {
+    public final JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException {
         synchronized (lock) {
             // Wait until the consumer is ready to deliver messages.
-            while (timeout != 0 && !closed && (isEmpty() || !running)) {
+            while (timeout != 0 && !closed && isEmpty() && running) {
                 if (timeout == -1) {
                     lock.wait();
                 } else {
@@ -57,7 +57,7 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     }
 
     @Override
-    public JmsInboundMessageDispatch dequeueNoWait() {
+    public final JmsInboundMessageDispatch dequeueNoWait() {
         synchronized (lock) {
             if (closed || !running || isEmpty()) {
                 return null;
@@ -67,7 +67,7 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     }
 
     @Override
-    public void start() {
+    public final void start() {
         synchronized (lock) {
             running = true;
             lock.notifyAll();
@@ -75,7 +75,7 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     }
 
     @Override
-    public void stop() {
+    public final void stop() {
         synchronized (lock) {
             running = false;
             lock.notifyAll();
@@ -83,12 +83,12 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     }
 
     @Override
-    public boolean isRunning() {
+    public final boolean isRunning() {
         return running;
     }
 
     @Override
-    public void close() {
+    public final void close() {
         synchronized (lock) {
             if (!closed) {
                 running = false;
@@ -99,12 +99,12 @@ public abstract class AbstractMessageQueue implements MessageQueue {
     }
 
     @Override
-    public boolean isClosed() {
+    public final boolean isClosed() {
         return closed;
     }
 
     @Override
-    public Object getLock() {
+    public final Object getLock() {
         return lock;
     }
 
diff --git a/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/MessageQueue.java b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/MessageQueue.java
index 11a19a47..bdd99d0f 100644
--- a/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/MessageQueue.java
+++ b/qpid-jms-client/src/main/java/org/apache/qpid/jms/util/MessageQueue.java
@@ -76,13 +76,13 @@ public interface MessageQueue {
 
     /**
      * Starts the Message Queue.  An non-started Queue will always return null for
-     * any of the Queue accessor methods.
+     * any of the Queue methods.
      */
     void start();
 
     /**
      * Stops the Message Queue.  Messages cannot be read from the Queue when it is in
-     * the stopped state.
+     * the stopped state and any waiters will be awoken.
      */
     void stop();
 
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/FifoMessageQueueTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/FifoMessageQueueTest.java
index fa540508..4a349189 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/FifoMessageQueueTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/FifoMessageQueueTest.java
@@ -277,6 +277,24 @@ public class FifoMessageQueueTest {
         assertSame(message, queue.dequeue(-1));
     }
 
+    @Test(timeout = 10000)
+    public void testDequeueReturnsWhenQueueIsStopped() throws InterruptedException {
+        Thread runner = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                try {
+                    TimeUnit.MILLISECONDS.sleep(500);
+                } catch (InterruptedException e) {
+                }
+                queue.stop();
+            }
+        });
+        runner.start();
+
+        assertNull(queue.dequeue(-1));
+    }
+
     private List<JmsInboundMessageDispatch> createFullRangePrioritySet() {
         List<JmsInboundMessageDispatch> messages = new ArrayList<JmsInboundMessageDispatch>();
         for (int i = 0; i < 10; ++i) {
diff --git a/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/PriorityMessageQueueTest.java b/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/PriorityMessageQueueTest.java
index 325cf8ba..1b460923 100644
--- a/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/PriorityMessageQueueTest.java
+++ b/qpid-jms-client/src/test/java/org/apache/qpid/jms/util/PriorityMessageQueueTest.java
@@ -347,6 +347,24 @@ public class PriorityMessageQueueTest {
         assertSame(message, queue.dequeue(-1));
     }
 
+    @Test(timeout = 10000)
+    public void testDequeueReturnsWhenQueueIsStopped() throws InterruptedException {
+        Thread runner = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                try {
+                    TimeUnit.MILLISECONDS.sleep(500);
+                } catch (InterruptedException e) {
+                }
+                queue.stop();
+            }
+        });
+        runner.start();
+
+        assertNull(queue.dequeue(-1));
+    }
+
     private List<JmsInboundMessageDispatch> createFullRangePrioritySet() {
         List<JmsInboundMessageDispatch> messages = new ArrayList<JmsInboundMessageDispatch>();
         for (int i = 0; i < 10; ++i) {
