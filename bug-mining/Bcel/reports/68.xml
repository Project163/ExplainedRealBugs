<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 17:14:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[BCEL-195] addition of hashCode() to generic/Instruction.java breaks Targeters</title>
                <link>https://issues.apache.org/jira/browse/BCEL-195</link>
                <project id="12314220" key="BCEL">Commons BCEL</project>
                    <description>&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/r1532198&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Revision 1532198&lt;/a&gt; added a &lt;tt&gt;hashCode()&lt;/tt&gt; function to the Instruction class.  Unfortunately, this breaks the Instruction targeting mechanism. I understand the goal of trying to reuse instructions - an &apos;iadd&apos; is the same as any other &apos;iadd&apos;.  However,  one &apos;goto 50&apos; is not the same as another &apos;goto 50&apos; due to the way Targeters are implemented.  If branch instructions are reused, then only one entry gets put on the Targeter list.  So when some api is used to modify the instruction list and location 50 becomes location 52 ONLY ONE of the branches gets updated. A very bad thing.  So unless you modify the hash to special case branch instructions (and there might be other instructions needing special treatment as well) its broken.  We fixed it by simply commenting the hash out to make things like they used to be and all works great.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12772499">BCEL-195</key>
            <summary>addition of hashCode() to generic/Instruction.java breaks Targeters</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="markro">Mark Roberts</reporter>
                        <labels>
                    </labels>
                <created>Wed, 4 Feb 2015 21:34:58 +0000</created>
                <updated>Thu, 14 Jul 2016 12:48:27 +0000</updated>
                            <resolved>Tue, 14 Jun 2016 16:42:56 +0000</resolved>
                                    <version>6.0</version>
                                    <fixVersion>6.0</fixVersion>
                                    <component>Main</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="14306051" author="ebourg" created="Wed, 4 Feb 2015 21:56:44 +0000"  >&lt;p&gt;Do you think it would be possible to build a test case to secure this fix?&lt;/p&gt;</comment>
                            <comment id="14306067" author="markro" created="Wed, 4 Feb 2015 22:04:41 +0000"  >&lt;p&gt;I know, I know...   Unfortunately, the simplest way for me would require you (or somebody on the team) to install Daikon.   Otherwise, I not sure how to proceed. &lt;/p&gt;

&lt;p&gt; In any case, I would prefer to get all my issues on board first so you can see which make the 6.0 cut.&lt;/p&gt;

&lt;p&gt;Thank you your all your help.&lt;/p&gt;

&lt;p&gt;Mark&lt;/p&gt;
</comment>
                            <comment id="14329160" author="ebourg" created="Fri, 20 Feb 2015 16:58:39 +0000"  >&lt;p&gt;Ok let me recap:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;tt&gt;InstructionHandler&lt;/tt&gt; contains a &lt;tt&gt;Set&lt;/tt&gt; of &lt;tt&gt;InstructionTarget&lt;/tt&gt;. If the same targeter is added twice it&apos;s referenced only once&lt;/li&gt;
	&lt;li&gt;The &lt;tt&gt;BranchInstruction&lt;/tt&gt; hierarchy implements &lt;tt&gt;InstructionTarget&lt;/tt&gt; and inherit the equals/hashCode methods from the base abstract &lt;tt&gt;Instruction&lt;/tt&gt; class&lt;/li&gt;
	&lt;li&gt;Before r1532198 the &lt;tt&gt;Instruction&lt;/tt&gt; class defined the &lt;tt&gt;equals()&lt;/tt&gt; method but not &lt;tt&gt;hashCode()&lt;/tt&gt;. Thus two instructions that were equal didn&apos;t have the same hashcode. This was a violation of the equals/hashCode contract (equal objects must have the same hashcode).&lt;/li&gt;
	&lt;li&gt;This flaw allowed two distinct but equal instances of a &lt;tt&gt;BranchInstruction&lt;/tt&gt; to be listed as targeters of the same &lt;tt&gt;InstructionHandler&lt;/tt&gt;, because the &lt;tt&gt;HashSet&lt;/tt&gt; holding the targeters checks the hashcode before calling &lt;tt&gt;equals()&lt;/tt&gt; to detect if it already contains the element.&lt;/li&gt;
	&lt;li&gt;The addition of &lt;tt&gt;Instruction.hashCode()&lt;/tt&gt; in r1532198 fixed this flaw but had the side effect of &quot;merging&quot; equal but different &lt;tt&gt;BranchInstructions&lt;/tt&gt; in the set of targeters.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The issue here is not &lt;tt&gt;Instruction.hashCode()&lt;/tt&gt; which is correct, but the &lt;tt&gt;equals()&lt;/tt&gt; implementation that is wrong. I agree with you that two GOTO 50 shouldn&apos;t be considered equal, it doesn&apos;t make sense for flow instructions. The question is, do we even need this &lt;tt&gt;equals()&lt;/tt&gt; method? What is it really used for? I removed it and no test complained (but we have a poor coverage). I&apos;m pondering if I should either remove it (instruction equality can still be checked with &lt;tt&gt;InstructionComparator&lt;/tt&gt;) or just remove the code related to &lt;tt&gt;BranchInstruction&lt;/tt&gt; from &lt;tt&gt;InstructionComparator&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="14329229" author="markro" created="Fri, 20 Feb 2015 17:36:13 +0000"  >&lt;p&gt;so you&apos;re suggesting I try turning Instruction.hashCode() back on and removing Instruction.equals() instead?  I can try that with our test set. Does InstructionComparator.equals get used by the HashSet&amp;lt;InstructionTargeter&amp;gt;.add() method?  If so, maybe the soulution is to change the (applicable part of)  the code to &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i1 &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; BranchInstruction) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ............
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="14329454" author="markro" created="Fri, 20 Feb 2015 19:59:12 +0000"  >&lt;p&gt;Okay - thanks for the pointer to InstructionComparator.  I have tested and prepared a new patch for this problem.  Instruction.hash and Instruction.equal are left untouched.  InstructionComparator is modified to always say two branch instructions are not equal.  This fix exposed another problem in the order of initialization for Select instructions.  A fix for that is included as well.&lt;/p&gt;</comment>
                            <comment id="14329485" author="ebourg" created="Fri, 20 Feb 2015 20:17:03 +0000"  >&lt;p&gt;Thank you Mark. Could you explain the issue with the Select initialization? Does it occur when &lt;tt&gt;Instruction.equals()&lt;/tt&gt; is removed? I&apos;d like to cover that with a test.&lt;/p&gt;</comment>
                            <comment id="14329936" author="markro" created="Sat, 21 Feb 2015 02:27:40 +0000"  >&lt;p&gt;I think it would not occur if there was no Instruction.equals as then InstructionComparator would no longer be called.&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The initialization order issue is hidden in the super call to BranchInstruction init &lt;br/&gt;
which calls setTarget&lt;br/&gt;
which calls notifyTarget&lt;br/&gt;
which calls addTargeter&lt;br/&gt;
which calls targeters.add&lt;br/&gt;
which calls the java runtime for HashSet &lt;br/&gt;
which leads back to Instruction.equals&lt;br/&gt;
which calls InstructionComparator.equals&lt;br/&gt;
which sees it has a Select and calls getTargets&lt;br/&gt;
which returns null as the rest of the select instruction fields have not been set&lt;br/&gt;
and t1.length goes boom&lt;/p&gt;

&lt;p&gt;I believe I never saw it before as we had the hash function commented out.  You probably never saw it due to lack of code coverage.  &lt;/p&gt;

&lt;p&gt;Given that (I believe) InstructionComparator is fixed, I think you want to leave in Instruction.equals so that the simple instructions do get cached.&lt;/p&gt;

&lt;p&gt;And after thinking about this some more to write this email - I&apos;m wondering if InstructionComparator should always return false for Select as well?  The odds of two identical switches located at different locations in the code is probably close to zero.  Certainly never happens in our exhaustive test suite.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;Mark&lt;/p&gt;

</comment>
                            <comment id="14695556" author="markro" created="Thu, 13 Aug 2015 16:53:13 +0000"  >&lt;p&gt;Well, about 6 months later and we still haven&apos;t run into any problems with Select.  So I&apos;ll answer my own question and say we should just go ahead with the change as proposed.  Thanks.&lt;/p&gt;</comment>
                            <comment id="14697292" author="markro" created="Fri, 14 Aug 2015 16:04:57 +0000"  >&lt;p&gt;I have updated the diff file to be relative to the current trunk.&lt;/p&gt;</comment>
                            <comment id="14697506" author="sebb@apache.org" created="Fri, 14 Aug 2015 18:29:02 +0000"  >&lt;p&gt;It seems to me that having to delay setting the default target until the rest of the superclass has been built is a workround for a design issue.&lt;br/&gt;
Constructors should not allow &quot;this&quot; to escape.&lt;/p&gt;

&lt;p&gt;There&apos;s another design problem which is that the setTarget() method is called from the ctor but is overrideable. This can lead to problems with subclasses.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;Easy enough to fix this by extracting the code into a private method shared by ctor and setTarget() - or just duplicating the code in the ctor&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="14698644" author="sebb@apache.org" created="Sun, 16 Aug 2015 12:46:52 +0000"  >&lt;p&gt;I think the fact that all branch instructions have the same hash is a red herring.&lt;br/&gt;
So long as one GOTO 50 compares equal with another GOTO 50, and does not compare equal with a GOTO 51, then it&apos;s possible to ensure that one, and only one, instance is added to the list.&lt;br/&gt;
So I don&apos;t understand the comment&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, one &apos;goto 50&apos; is not the same as another &apos;goto 50&apos; due to the way Targeters are implemented.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As I see it, the problem here is that when two Instructions have the same hashcode, then the code needs to use the equals method to distinguish them, and the equals method needs data that has not yet been set up. &lt;/p&gt;

&lt;p&gt;Removing the definition of the hashCode does not solve this problem, it just makes it very unlikely to occur (because Object hashCode collisions are deliberately rare). &lt;/p&gt;

&lt;p&gt;An alternative solution would be to ensure that the hashCode for branches took account of the target somehow.&lt;/p&gt;

&lt;p&gt;Or at least allow non-variable instructions to be shared by keeping the existing hashcode method and overriding it with a call to System.identityHashCode() for variable instructions such as branches.&lt;br/&gt;
This should be easy to test.&lt;/p&gt;</comment>
                            <comment id="14700090" author="markro" created="Mon, 17 Aug 2015 19:30:40 +0000"  >&lt;p&gt;I need to think about this some more.  Maybe there is a problem with Targeters being confused about Instructions vs Instruction handles.  After I get Daikon running again with the latest &apos;trunk&apos; version of BCEL, I will look at this.&lt;/p&gt;
</comment>
                            <comment id="14710190" author="markro" created="Mon, 24 Aug 2015 22:42:15 +0000"  >&lt;p&gt;Okay, I think I grok this now.  In a sense, we were both correct.  I think you are correct that you can share branches with the same target; but it didn&apos;t work properly due to problems in other code.  My change to InstructionComparator (inadvertently) worked around these problems.  There were two issues if you are going to share branch instructions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;dispose cannot set the target to null because somebody else might be using it.&lt;/li&gt;
	&lt;li&gt;you cannot allow duplicate targeters (interestingly, the &apos;fix&apos; was in the code, but commented out)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;targeters.diff has these changes.  Please review and see what you think.&lt;/p&gt;

&lt;p&gt;I have not had a chance to review the changes to Select.java; I will try to get that done tomorrow.&lt;/p&gt;</comment>
                            <comment id="14710415" author="sebb@apache.org" created="Tue, 25 Aug 2015 01:29:59 +0000"  >&lt;p&gt;InstructionHandle.addTargeter(t) currently has the code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(!targeters.contains(t)) // (A)
&lt;/span&gt;        targeters.add(t);            &lt;span class=&quot;code-comment&quot;&gt;// (B)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The patch proposes to enable (A) above.&lt;br/&gt;
According to the Javadoc for HashSet, this should make no difference to the set, as it will only add the value if it is not already contained in it.&lt;/p&gt;

&lt;p&gt;So this code already prevents duplicate Targeters, at least in the Set contained in the InstructionHandle.&lt;br/&gt;
Duplicate here means that the hashcodes are the same and the objects must compare equal.&lt;br/&gt;
And of course equal objects must have equal hashcodes. (The reverse is not true)&lt;/p&gt;

&lt;p&gt;If either the hashcode or the equals() changes whilst an object is in a set, then the object may not be found.&lt;br/&gt;
Now the hashcode is currently the opcode. &lt;br/&gt;
One might think that the opcode was immutable once set up, but GOTO may change it to GOTO_W and similarly for other instructions (JSR =&amp;gt; JSR_W, perhaps others). &lt;/p&gt;

&lt;p&gt;I think it&apos;s impossible to support changing an Instruction whilst it is in any kind of HASH set.&lt;/p&gt;

&lt;p&gt;If an Instruction can only be changed when it is not in a Hash, then of course the problem does not occur, but that may be tricky to do with the current design (and probably impossible to enforce).&lt;/p&gt;

&lt;p&gt;There are other sets that use equals() and not hashes, but they will be equally compromised by changes to the instruction - if the change does not affect the equals() method, then there&apos;s no point doing the change!&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Later&amp;#93;&lt;/span&gt; however it does look like it might be possible to use something like TreeSet or ConcurrentArraySet, which only use equals().&lt;/p&gt;

&lt;p&gt;I assume that the InstructionList is supposed to contain all distinct InstructionHandle instances (and the search uses == rather than equals) but I don&apos;t know how that is guaranteed.&lt;br/&gt;
The way that IH instances are generated is rather convoluted once the ih_list cache has been initialised.&lt;/p&gt;

&lt;p&gt;One change which should help in debugging would be to ensure that the opcode and other mutable fields are only accessed via getter/setters.&lt;br/&gt;
I will make a start on that.&lt;/p&gt;</comment>
                            <comment id="14710615" author="charles_honton@intuit.com" created="Tue, 25 Aug 2015 05:36:42 +0000"  >&lt;p&gt;I have created a pull request (&lt;a href=&quot;https://github.com/apache/commons-bcel/pull/2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/commons-bcel/pull/2&lt;/a&gt;) which peripherally concerns this issue.&lt;/p&gt;

&lt;p&gt;A simple solution is remove equals/hashCode and create an InstructionFactory that will only reuse the immutable Instructions.  All other Instructions would be newly created.&lt;/p&gt;

&lt;p&gt;Does anyone have data that shows reusing Immutable instructions has a significant impact on memory usage or execution time?&lt;/p&gt;</comment>
                            <comment id="14710921" author="sebb@apache.org" created="Tue, 25 Aug 2015 08:55:42 +0000"  >&lt;p&gt;I assume that the intention of re-using Instructions is partly to save space, but also so that BIs with the same target can be updated more easily, as only one instruction has to be changed. Though another way to do this is of course to move the IH to a different part of the list.&lt;/p&gt;

&lt;p&gt;Changing the design to require use of an Instruction Factory would probably require substantial changes to user code, so I think should be avoided unless absolutely essential. In which case, I would start again and make the Instructions immutable (I&apos;m still not sure it&apos;s necessary to be able to change them). Likewise, I&apos;m not sure the IH cache is a good idea.&lt;/p&gt;

&lt;p&gt;As to considerations of memory usage or time: we need to get the code working properly first.&lt;br/&gt;
Which means we really need unit tests that properly represent a wide range of existing use cases.&lt;/p&gt;</comment>
                            <comment id="14711725" author="markro" created="Tue, 25 Aug 2015 18:21:27 +0000"  >&lt;p&gt;This problem is very complicated and there are a number of factors in play.  One is that the objects in the HashSet of targeters are modified which violates the basic Set contract.  BranchInstructions are added to the set with their target==null.  Then the branch target is set with the correct value.  This means that there are duplicates in the set if the target is branched to from more than one location.  BUT, this turns out to be a good thing because you really do want a separate targeter for each branch so they can be modified independently of each other (more on this later).  The problem arises when we replace a branch instruction and, hence, need to remove its targeter from the target set.  Since all the branch instructions in the targeters set now compare equal, an arbitrary one is removed and is disposed.  The correct solution (ignoring the whole issue of Factories for now) is that the targeter entries really should be the instruction handle of the branch source not the branch instruction itself.  OR, and much simpler, we go back to my original solution of changing InstructionComparator to say that two branches are never equal.  This works because when we dispose the branch instruction nothing happens BUT we set the target back to null.  Then when we dispose the containing InstructionHandle it calls dispose on the instruction again and now it matches how it was originally added to the set and gets deleted.  I understand this is nasty but I would really like to adopt this solution for now.  I have used it for months and I know it works.  I&apos;ve spent two additional days on this issue and would really like to work on the other open items.  Thank you.&lt;/p&gt;</comment>
                            <comment id="14711816" author="sebb@apache.org" created="Tue, 25 Aug 2015 19:19:30 +0000"  >&lt;p&gt;For the record:&lt;br/&gt;
I tried replacing the HashSet used for InstructionHandle.targeters with a TreeSet.&lt;br/&gt;
That fails, because the entries need to be Comparable.&lt;br/&gt;
The tests work fine with CopyOnWriteArraySet.&lt;br/&gt;
Using this would avoid the problematic hashCodes.&lt;br/&gt;
However there is still the issue of equality in the case of mutable targeters.&lt;/p&gt;</comment>
                            <comment id="14711829" author="sebb@apache.org" created="Tue, 25 Aug 2015 19:29:02 +0000"  >&lt;p&gt;Is there a downside to making BIs unique (apart from the potential space/performance aspect)?&lt;br/&gt;
Is it likely to affect the way people expect to be able to modify code?&lt;/p&gt;

&lt;p&gt;We really need some tests that exercise branch instruction replacement.&lt;br/&gt;
Even a very basic one would be better than nothing.&lt;/p&gt;</comment>
                            <comment id="14711890" author="markro" created="Tue, 25 Aug 2015 20:13:40 +0000"  >&lt;p&gt;There is no space/performance hit  because they were never unique.  They are not defined in InstructionConstants so  Instruction.readInstruction always creates a new instance for every branch instruction (among others).  I guess I hadn&apos;t made that clear before.  The only purpose of my change to InstructionComparator  is to trick the current targeter design into working the way I think it should (via tricking HashSet). &lt;/p&gt;

&lt;p&gt;Daikon does branch instruction replacement all the time - but that would be the opposite of a very basic test case.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

</comment>
                            <comment id="14711977" author="sebb@apache.org" created="Tue, 25 Aug 2015 21:04:49 +0000"  >&lt;p&gt;OK, I see.&lt;/p&gt;

&lt;p&gt;Do both patches need to be applied still?&lt;/p&gt;

&lt;p&gt;But we really need some test code that can potentially expose the problem and test the new code.&lt;/p&gt;

&lt;p&gt;I realise that it&apos;s not possible to provide a copy of everything Daikon does, but even a single sample would help.&lt;/p&gt;

&lt;p&gt;Seems to me that there are at least two types of branch changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;changing one or more branch instructions to point to a new location&lt;/li&gt;
	&lt;li&gt;changing the position of an Instruction handle within the list by adding/removing instructions earlier in the list&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I assume it is the first case that is causing problems.&lt;/p&gt;</comment>
                            <comment id="14712001" author="markro" created="Tue, 25 Aug 2015 21:24:40 +0000"  >&lt;p&gt;I can still repro the Select problem.  I&apos;m working on getting a small test case for that, but it might actually cover both pieces.  &lt;/p&gt;

&lt;p&gt;Yes, it&#8217;s the first case.  Only a problem if more than one branch targets the same location.  If we try to move one of them, the targeter stuff gets confused and may change the wrong one.&lt;/p&gt;
</comment>
                            <comment id="14712122" author="markro" created="Tue, 25 Aug 2015 22:46:51 +0000"  >&lt;p&gt;I&apos;ve deleted both of the old patches and attached a new diff file.  Same change to InstructionComparator, but a much cleaner fix to the Select problem.  I&apos;ll try to create a test case tomorrow. &lt;/p&gt;</comment>
                            <comment id="14712129" author="markro" created="Tue, 25 Aug 2015 22:54:08 +0000"  >&lt;p&gt;test case;  just add the following lines to some existing test&lt;/p&gt;

&lt;p&gt;        InstructionList il = new InstructionList();&lt;br/&gt;
        InstructionHandle ih = il.append(InstructionConstants.NOP);&lt;br/&gt;
        Instruction i1 = new TABLESWITCH(new int&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, new InstructionHandle&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, ih);&lt;br/&gt;
        Instruction i2 = new TABLESWITCH(new int&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, new InstructionHandle&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, ih);&lt;/p&gt;

&lt;p&gt;Without the Select fix, it will go boom.&lt;/p&gt;</comment>
                            <comment id="14715419" author="sebb@apache.org" created="Wed, 26 Aug 2015 20:05:38 +0000"  >&lt;p&gt;I can confirm the issue. &lt;br/&gt;
This is definitely caused by accessing the class before it has been fully initialsed.&lt;br/&gt;
Even initialising the targets field in the declaration does not help, as the getTargets() method is invoked before that has been done (and before the ctors).&lt;br/&gt;
Just shows how bad it is to let the &quot;this&quot; reference escape during class construction.&lt;/p&gt;</comment>
                            <comment id="14715438" author="markro" created="Wed, 26 Aug 2015 20:16:40 +0000"  >&lt;p&gt;So my new patch only fixes a particular problem I noticed and my original patch fixes all but violates some coding guidelines?  What do you recommend we do?&lt;/p&gt;
</comment>
                            <comment id="14715578" author="sebb@apache.org" created="Wed, 26 Aug 2015 21:49:17 +0000"  >&lt;p&gt;I don&apos;t follow what you mean about coding guidelines.&lt;/p&gt;

&lt;p&gt;The new patch passes all tests including the test case you provided.&lt;/p&gt;

&lt;p&gt;However it is a work-round for the fact that the Select object is not properly constructed.&lt;br/&gt;
So there may be other nasties that appear in the future; the behaviour may well change with updates to JVMs.&lt;br/&gt;
So although it works now, it may not be a long-term solution.&lt;/p&gt;

&lt;p&gt;I never got a chance to try the original patch because I did not have a test case at the time.&lt;/p&gt;

&lt;p&gt;==&lt;/p&gt;

&lt;p&gt;I do now agree that trying to re-use branch instructions is a non-starter with the current design.&lt;br/&gt;
So I wonder why the comparator still tries to compare Select instructions?&lt;br/&gt;
Should it still try to compare them?&lt;/p&gt;

&lt;p&gt;I just checked, and always returning false for Selects also fixes the new test case - because it avoids calling getTargets().&lt;br/&gt;
Given that the behaviour of getTargets() is effectively undefined during Select construction, it would be safer not to try comparing them, even with the fix for the NPE.&lt;/p&gt;

&lt;p&gt;It would still be good to fix the construction issue however.&lt;br/&gt;
There may be other use cases that fail or behave incorrectly because the Select object behaves in other unexpected ways.&lt;/p&gt;</comment>
                            <comment id="14715743" author="markro" created="Wed, 26 Aug 2015 23:33:40 +0000"  >&lt;p&gt;Having the comparator return false for both branch and select sounds fine.&lt;br/&gt;
Then we can leave Select as is and close this out?&lt;/p&gt;

&lt;p&gt;ian.jira.plugin.system.issuetabpanels:all-tabpanel ]&lt;/p&gt;
</comment>
                            <comment id="14716208" author="sebb@apache.org" created="Thu, 27 Aug 2015 07:27:26 +0000"  >&lt;p&gt;I still think the underlying construction sequence problem needs to be addressed at some point, but that can be raised as a separate issue.&lt;/p&gt;</comment>
                            <comment id="14717224" author="markro" created="Thu, 27 Aug 2015 18:22:59 +0000"  >&lt;p&gt;I&apos;ve attached my original suggested fix to the constructor.  I think it goes a long way towards making sure the select object is initialized before allowing &apos;this&apos; to be used.&lt;/p&gt;</comment>
                            <comment id="14717698" author="sebb@apache.org" created="Thu, 27 Aug 2015 22:52:17 +0000"  >&lt;p&gt;Thanks very much.&lt;/p&gt;

&lt;p&gt;I tried the patch without the change to the comparator and without the getTargets() fix, and the test case passed.&lt;/p&gt;

&lt;p&gt;I created a new issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/BCEL-261&quot; title=&quot;Select constructor allows partially constructed instance to escape&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BCEL-261&quot;&gt;BCEL-261&lt;/a&gt;) to track the problem as it is ongoing&lt;/p&gt;</comment>
                            <comment id="14717742" author="sebb@apache.org" created="Thu, 27 Aug 2015 23:19:46 +0000"  >&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/r1698243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1698243&lt;/a&gt;&lt;br/&gt;
Log:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BCEL-195&quot; title=&quot;addition of hashCode() to generic/Instruction.java breaks Targeters&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BCEL-195&quot;&gt;&lt;del&gt;BCEL-195&lt;/del&gt;&lt;/a&gt; addition of hashCode() to generic/Instruction.java breaks Targeters. Never make distinct BranchInstructions compare equal&lt;/p&gt;

&lt;p&gt;Modified:&lt;br/&gt;
    commons/proper/bcel/trunk/src/changes/changes.xml&lt;br/&gt;
    commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java&lt;br/&gt;
    commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/generic/InstructionHandleTestCase.java&lt;/p&gt;

&lt;p&gt;I thought better of the equality short-cut check  (added as an afterthought).&lt;br/&gt;
Although that check would make sense for ordinary HashSet usage, the conditions here are different.&lt;br/&gt;
The test still passed, but I suspect it would cause problems.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;We could still add the equality check after rejecting BIs&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/r1698244&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1698244&lt;/a&gt;&lt;br/&gt;
Log:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BCEL-195&quot; title=&quot;addition of hashCode() to generic/Instruction.java breaks Targeters&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BCEL-195&quot;&gt;&lt;del&gt;BCEL-195&lt;/del&gt;&lt;/a&gt; addition of hashCode() to generic/Instruction.java breaks Targeters. Never make BranchInstructions compare equal&lt;br/&gt;
Revert short-cut equality check because that would allow a single BI to be shared.&lt;/p&gt;

&lt;p&gt;Modified:&lt;br/&gt;
    commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java&lt;/p&gt;</comment>
                            <comment id="14723437" author="markro" created="Mon, 31 Aug 2015 14:06:40 +0000"  >&lt;p&gt;What remains to be done to close this issue?&lt;/p&gt;
</comment>
                            <comment id="14727279" author="sebb@apache.org" created="Wed, 2 Sep 2015 12:48:23 +0000"  >&lt;p&gt;I&apos;m not sure if there&apos;s anything left now.&lt;/p&gt;</comment>
                            <comment id="15329840" author="sebb@apache.org" created="Tue, 14 Jun 2016 16:42:56 +0000"  >&lt;p&gt;Seems to be fixed&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12859737">BCEL-261</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12752334" name="compare.diff" size="1292" author="markro" created="Tue, 25 Aug 2015 22:11:56 +0000"/>
                            <attachment id="12752817" name="select-init.diff" size="1018" author="markro" created="Thu, 27 Aug 2015 18:23:17 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 22 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i257cn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>