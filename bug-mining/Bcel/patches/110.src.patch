diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 982a550b..fb90e3e3 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -79,6 +79,7 @@ The <action> type attribute can be add,update,fix,remove.
       <action                  type="update" dev="ggregory" due-to="Mark Roberts">Add support for invokestatic of an InterfaceMethodref #39.</action>
       <action                  type="update" dev="ggregory" due-to="Mark Roberts">Add attribute name(s) to Code.toString() #40.</action>
       <action issue="BCEL-338" type="update" dev="ggregory" due-to="Gary Gregory">org.apache.bcel.generic.InstructionFactory.createInvoke() populates its internal ConstantPoolGen on bad input, then throws exception.</action>
+      <action issue="BCEL-339" type="update" dev="ggregory" due-to="Gary Gregory">Throw IllegalArgumentException, IllegalStateException, UnsupportedOperationException instead of RuntimeException.</action>
     </release> 
     <release version="6.4.1" date="2019-09-26" description="Bug fix release.">
       <action issue="BCEL-328" type="fix" dev="ggregory" due-to="Gary Gregory, Mark Roberts">java.util.EmptyStackException at org.apache.bcel.classfile.DescendingVisitor.visitModule (DescendingVisitor.java:592).</action>
diff --git a/src/examples/ClassDumper.java b/src/examples/ClassDumper.java
index 1a0ca56a..fc89b62c 100644
--- a/src/examples/ClassDumper.java
+++ b/src/examples/ClassDumper.java
@@ -356,7 +356,7 @@ class DumpClass {
     public static void main(final String[] args) throws IOException {
 
         if (args.length != 1) {
-            throw new RuntimeException("Require file name as only argument");
+            throw new IllegalArgumentException("Require file name as only argument");
         }
 
         try (FileImageInputStream file = new FileImageInputStream(new File(args[0]))) {
diff --git a/src/main/java/org/apache/bcel/classfile/AnnotationElementValue.java b/src/main/java/org/apache/bcel/classfile/AnnotationElementValue.java
index 2aa79587..86e68ea1 100644
--- a/src/main/java/org/apache/bcel/classfile/AnnotationElementValue.java
+++ b/src/main/java/org/apache/bcel/classfile/AnnotationElementValue.java
@@ -33,7 +33,7 @@ public class AnnotationElementValue extends ElementValue
         {
                 super(type, cpool);
                 if (type != ANNOTATION) {
-                    throw new RuntimeException(
+                    throw new IllegalArgumentException(
                                     "Only element values of type annotation can be built with this ctor - type specified: " + type);
                 }
                 this.annotationEntry = annotationEntry;
diff --git a/src/main/java/org/apache/bcel/classfile/ArrayElementValue.java b/src/main/java/org/apache/bcel/classfile/ArrayElementValue.java
index 9e750c4d..293d80c1 100644
--- a/src/main/java/org/apache/bcel/classfile/ArrayElementValue.java
+++ b/src/main/java/org/apache/bcel/classfile/ArrayElementValue.java
@@ -48,7 +48,7 @@ public class ArrayElementValue extends ElementValue
     {
         super(type, cpool);
         if (type != ARRAY) {
-            throw new RuntimeException(
+            throw new IllegalArgumentException(
                     "Only element values of type array can be built with this ctor - type specified: " + type);
         }
         this.evalues = datums;
diff --git a/src/main/java/org/apache/bcel/classfile/ConstantPool.java b/src/main/java/org/apache/bcel/classfile/ConstantPool.java
index f2c946a1..0dd49658 100644
--- a/src/main/java/org/apache/bcel/classfile/ConstantPool.java
+++ b/src/main/java/org/apache/bcel/classfile/ConstantPool.java
@@ -165,7 +165,7 @@ public class ConstantPool implements Cloneable, Node {
                 str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
                 break;
             default: // Never reached
-                throw new RuntimeException("Unknown constant type " + tag);
+                throw new IllegalArgumentException("Unknown constant type " + tag);
         }
         return str;
     }
@@ -310,7 +310,7 @@ public class ConstantPool implements Cloneable, Node {
                 i = ((ConstantPackage) c).getNameIndex();
                 break;
             default:
-                throw new RuntimeException("getConstantString called with illegal tag " + tag);
+                throw new IllegalArgumentException("getConstantString called with illegal tag " + tag);
         }
         // Finally get the string from the constant pool
         c = getConstant(i, Const.CONSTANT_Utf8);
diff --git a/src/main/java/org/apache/bcel/classfile/ElementValue.java b/src/main/java/org/apache/bcel/classfile/ElementValue.java
index 0859b188..b96a97ff 100644
--- a/src/main/java/org/apache/bcel/classfile/ElementValue.java
+++ b/src/main/java/org/apache/bcel/classfile/ElementValue.java
@@ -109,7 +109,7 @@ public abstract class ElementValue
                 return new ArrayElementValue(ARRAY, evalues, cpool);
 
             default:
-                throw new RuntimeException("Unexpected element value kind in annotation: " + type);
+                throw new IllegalArgumentException("Unexpected element value kind in annotation: " + type);
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/classfile/EnumElementValue.java b/src/main/java/org/apache/bcel/classfile/EnumElementValue.java
index 4bab0a81..523d64eb 100644
--- a/src/main/java/org/apache/bcel/classfile/EnumElementValue.java
+++ b/src/main/java/org/apache/bcel/classfile/EnumElementValue.java
@@ -37,7 +37,7 @@ public class EnumElementValue extends ElementValue
     {
         super(type, cpool);
         if (type != ENUM_CONSTANT) {
-            throw new RuntimeException(
+            throw new IllegalArgumentException(
                     "Only element values of type enum can be built with this ctor - type specified: " + type);
         }
         this.typeIdx = typeIdx;
diff --git a/src/main/java/org/apache/bcel/classfile/Signature.java b/src/main/java/org/apache/bcel/classfile/Signature.java
index 38d9e6d6..6a9c50e3 100644
--- a/src/main/java/org/apache/bcel/classfile/Signature.java
+++ b/src/main/java/org/apache/bcel/classfile/Signature.java
@@ -153,7 +153,7 @@ public final class Signature extends Attribute {
     private static void matchIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {
         int ch;
         if ((ch = in.read()) == -1) {
-            throw new RuntimeException("Illegal signature: " + in.getData()
+            throw new IllegalArgumentException("Illegal signature: " + in.getData()
                     + " no ident, reaching EOF");
         }
         //System.out.println("return from ident:" + (char)ch);
@@ -203,7 +203,7 @@ public final class Signature extends Attribute {
             matchGJIdent(in, buf);
             while (((ch = in.read()) != '>') && (ch != ')')) { // List of parameters
                 if (ch == -1) {
-                    throw new RuntimeException("Illegal signature: " + in.getData()
+                    throw new IllegalArgumentException("Illegal signature: " + in.getData()
                             + " reaching EOF");
                 }
                 //System.out.println("Still no >");
@@ -224,7 +224,7 @@ public final class Signature extends Attribute {
             in.unread();
             return;
         } else if (ch != ';') {
-            throw new RuntimeException("Illegal signature: " + in.getData() + " read " + (char) ch);
+            throw new IllegalArgumentException("Illegal signature: " + in.getData() + " read " + (char) ch);
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/classfile/SimpleElementValue.java b/src/main/java/org/apache/bcel/classfile/SimpleElementValue.java
index d74202f3..9da22b6e 100644
--- a/src/main/java/org/apache/bcel/classfile/SimpleElementValue.java
+++ b/src/main/java/org/apache/bcel/classfile/SimpleElementValue.java
@@ -51,7 +51,7 @@ public class SimpleElementValue extends ElementValue
     public String getValueString()
     {
         if (super.getType() != STRING) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueString() on a non STRING ElementValue");
         }
         final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(getIndex(),
@@ -62,7 +62,7 @@ public class SimpleElementValue extends ElementValue
     public int getValueInt()
     {
         if (super.getType() != PRIMITIVE_INT) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueString() on a non STRING ElementValue");
         }
         final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),
@@ -73,7 +73,7 @@ public class SimpleElementValue extends ElementValue
     public byte getValueByte()
     {
         if (super.getType() != PRIMITIVE_BYTE) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueByte() on a non BYTE ElementValue");
         }
         final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),
@@ -84,7 +84,7 @@ public class SimpleElementValue extends ElementValue
     public char getValueChar()
     {
         if (super.getType() != PRIMITIVE_CHAR) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueChar() on a non CHAR ElementValue");
         }
         final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),
@@ -95,7 +95,7 @@ public class SimpleElementValue extends ElementValue
     public long getValueLong()
     {
         if (super.getType() != PRIMITIVE_LONG) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueLong() on a non LONG ElementValue");
         }
         final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());
@@ -105,7 +105,7 @@ public class SimpleElementValue extends ElementValue
     public float getValueFloat()
     {
         if (super.getType() != PRIMITIVE_FLOAT) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueFloat() on a non FLOAT ElementValue");
         }
         final ConstantFloat f = (ConstantFloat) super.getConstantPool().getConstant(getIndex());
@@ -115,7 +115,7 @@ public class SimpleElementValue extends ElementValue
     public double getValueDouble()
     {
         if (super.getType() != PRIMITIVE_DOUBLE) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueDouble() on a non DOUBLE ElementValue");
         }
         final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());
@@ -125,7 +125,7 @@ public class SimpleElementValue extends ElementValue
     public boolean getValueBoolean()
     {
         if (super.getType() != PRIMITIVE_BOOLEAN) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueBoolean() on a non BOOLEAN ElementValue");
         }
         final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());
@@ -135,7 +135,7 @@ public class SimpleElementValue extends ElementValue
     public short getValueShort()
     {
         if (super.getType() != PRIMITIVE_SHORT) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueShort() on a non SHORT ElementValue");
         }
         final ConstantInteger s = (ConstantInteger) super.getConstantPool().getConstant(getIndex());
@@ -196,7 +196,7 @@ public class SimpleElementValue extends ElementValue
                     Const.CONSTANT_Utf8);
             return cu8.getBytes();
         default:
-            throw new RuntimeException("SimpleElementValue class does not know how to stringify type " + _type);
+            throw new IllegalStateException("SimpleElementValue class does not know how to stringify type " + _type);
         }
     }
 
@@ -219,7 +219,7 @@ public class SimpleElementValue extends ElementValue
             dos.writeShort(getIndex());
             break;
         default:
-            throw new RuntimeException("SimpleElementValue doesnt know how to write out type " + _type);
+            throw new IllegalStateException("SimpleElementValue doesnt know how to write out type " + _type);
         }
     }
 }
diff --git a/src/main/java/org/apache/bcel/classfile/StackMapEntry.java b/src/main/java/org/apache/bcel/classfile/StackMapEntry.java
index 4f4f97a5..88ef0bf3 100644
--- a/src/main/java/org/apache/bcel/classfile/StackMapEntry.java
+++ b/src/main/java/org/apache/bcel/classfile/StackMapEntry.java
@@ -256,7 +256,7 @@ public final class StackMapEntry implements Node, Cloneable
             }
             return len;
         } else {
-            throw new RuntimeException("Invalid StackMap frame_type: " + frame_type);
+            throw new IllegalStateException("Invalid StackMap frame_type: " + frame_type);
         }
     }
 
@@ -273,7 +273,7 @@ public final class StackMapEntry implements Node, Cloneable
         } else if (f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX) { // CHECKSTYLE IGNORE EmptyBlock
         } else if (f == Const.FULL_FRAME) { // CHECKSTYLE IGNORE EmptyBlock
         } else {
-            throw new RuntimeException("Invalid StackMap frame_type");
+            throw new IllegalArgumentException("Invalid StackMap frame_type");
         }
         frame_type = f;
     }
@@ -286,7 +286,7 @@ public final class StackMapEntry implements Node, Cloneable
 
     public void setByteCodeOffset( final int new_offset ) {
         if (new_offset < 0 || new_offset > 32767) {
-            throw new RuntimeException("Invalid StackMap offset: " + new_offset);
+            throw new IllegalArgumentException("Invalid StackMap offset: " + new_offset);
         }
 
         if (frame_type >= Const.SAME_FRAME &&
@@ -311,7 +311,7 @@ public final class StackMapEntry implements Node, Cloneable
                    frame_type <= Const.APPEND_FRAME_MAX) { // CHECKSTYLE IGNORE EmptyBlock
         } else if (frame_type == Const.FULL_FRAME) { // CHECKSTYLE IGNORE EmptyBlock
         } else {
-            throw new RuntimeException("Invalid StackMap frame_type: " + frame_type);
+            throw new IllegalStateException("Invalid StackMap frame_type: " + frame_type);
         }
         byte_code_offset = new_offset;
     }
diff --git a/src/main/java/org/apache/bcel/classfile/StackMapType.java b/src/main/java/org/apache/bcel/classfile/StackMapType.java
index 4e35cb20..4cd8c1ba 100644
--- a/src/main/java/org/apache/bcel/classfile/StackMapType.java
+++ b/src/main/java/org/apache/bcel/classfile/StackMapType.java
@@ -58,7 +58,7 @@ public final class StackMapType implements Cloneable {
      */
     public StackMapType(final byte type, final int index, final ConstantPool constant_pool) {
         if ((type < Const.ITEM_Bogus) || (type > Const.ITEM_NewObject)) {
-            throw new RuntimeException("Illegal type for StackMapType: " + type);
+            throw new IllegalArgumentException("Illegal type for StackMapType: " + type);
         }
         this.type = type;
         this.index = index;
@@ -68,7 +68,7 @@ public final class StackMapType implements Cloneable {
 
     public void setType( final byte t ) {
         if ((t < Const.ITEM_Bogus) || (t > Const.ITEM_NewObject)) {
-            throw new RuntimeException("Illegal type for StackMapType: " + t);
+            throw new IllegalArgumentException("Illegal type for StackMapType: " + t);
         }
         type = t;
     }
diff --git a/src/main/java/org/apache/bcel/classfile/Utility.java b/src/main/java/org/apache/bcel/classfile/Utility.java
index b664d98b..bcd1cb64 100644
--- a/src/main/java/org/apache/bcel/classfile/Utility.java
+++ b/src/main/java/org/apache/bcel/classfile/Utility.java
@@ -1145,7 +1145,7 @@ public abstract class Utility {
                     break;
                 case '[':
                     if (!char_found) {
-                        throw new RuntimeException("Illegal type: " + type);
+                        throw new IllegalArgumentException("Illegal type: " + type);
                     }
                     index = i;
                     break loop;
@@ -1187,13 +1187,13 @@ public abstract class Utility {
             switch (c) {
                 case '[':
                     if (open) {
-                        throw new RuntimeException("Illegally nested brackets:" + brackets);
+                        throw new IllegalArgumentException("Illegally nested brackets:" + brackets);
                     }
                     open = true;
                     break;
                 case ']':
                     if (!open) {
-                        throw new RuntimeException("Illegally nested brackets:" + brackets);
+                        throw new IllegalArgumentException("Illegally nested brackets:" + brackets);
                     }
                     open = false;
                     count++;
@@ -1204,7 +1204,7 @@ public abstract class Utility {
             }
         }
         if (open) {
-            throw new RuntimeException("Illegally nested brackets:" + brackets);
+            throw new IllegalArgumentException("Illegally nested brackets:" + brackets);
         }
         return count;
     }
diff --git a/src/main/java/org/apache/bcel/generic/AnnotationElementValueGen.java b/src/main/java/org/apache/bcel/generic/AnnotationElementValueGen.java
index d8deb10f..9de92207 100644
--- a/src/main/java/org/apache/bcel/generic/AnnotationElementValueGen.java
+++ b/src/main/java/org/apache/bcel/generic/AnnotationElementValueGen.java
@@ -42,7 +42,7 @@ public class AnnotationElementValueGen extends ElementValueGen
     {
         super(type, cpool);
         if (type != ANNOTATION) {
-            throw new RuntimeException(
+            throw new IllegalArgumentException(
                     "Only element values of type annotation can be built with this ctor - type specified: " + type);
         }
         this.a = annotation;
@@ -65,7 +65,7 @@ public class AnnotationElementValueGen extends ElementValueGen
     @Override
     public String stringifyValue()
     {
-        throw new RuntimeException("Not implemented yet");
+        throw new UnsupportedOperationException("Not implemented yet");
     }
 
     /**
diff --git a/src/main/java/org/apache/bcel/generic/ArrayElementValueGen.java b/src/main/java/org/apache/bcel/generic/ArrayElementValueGen.java
index 240c1ddb..d7864b76 100644
--- a/src/main/java/org/apache/bcel/generic/ArrayElementValueGen.java
+++ b/src/main/java/org/apache/bcel/generic/ArrayElementValueGen.java
@@ -45,7 +45,7 @@ public class ArrayElementValueGen extends ElementValueGen
     {
         super(type, cpool);
         if (type != ARRAY) {
-            throw new RuntimeException(
+            throw new IllegalArgumentException(
                     "Only element values of type array can be built with this ctor - type specified: " + type);
         }
         this.evalues = new ArrayList<>();
diff --git a/src/main/java/org/apache/bcel/generic/ConstantPoolGen.java b/src/main/java/org/apache/bcel/generic/ConstantPoolGen.java
index fd0af47e..35f46cde 100644
--- a/src/main/java/org/apache/bcel/generic/ConstantPoolGen.java
+++ b/src/main/java/org/apache/bcel/generic/ConstantPoolGen.java
@@ -829,11 +829,11 @@ public class ConstantPoolGen {
                     case Const.CONSTANT_Fieldref:
                         return addFieldref(class_name, name, signature);
                     default: // Never reached
-                        throw new RuntimeException("Unknown constant type " + c);
+                        throw new IllegalArgumentException("Unknown constant type " + c);
                 }
             }
             default: // Never reached
-                throw new RuntimeException("Unknown constant type " + c);
+                throw new IllegalArgumentException("Unknown constant type " + c);
         }
     }
 }
diff --git a/src/main/java/org/apache/bcel/generic/ElementValueGen.java b/src/main/java/org/apache/bcel/generic/ElementValueGen.java
index 27f182ee..a10ee60f 100644
--- a/src/main/java/org/apache/bcel/generic/ElementValueGen.java
+++ b/src/main/java/org/apache/bcel/generic/ElementValueGen.java
@@ -146,7 +146,7 @@ public abstract class ElementValueGen
             }
             return new ArrayElementValueGen(ARRAY, evalues, cpGen);
         default:
-            throw new RuntimeException("Unexpected element value kind in annotation: " + type);
+            throw new IllegalArgumentException("Unexpected element value kind in annotation: " + type);
         }
     }
 
@@ -188,7 +188,7 @@ public abstract class ElementValueGen
             return new ClassElementValueGen((ClassElementValue) value, cpool,
                     copyPoolEntries);
         default:
-            throw new RuntimeException("Not implemented yet! (" + value.getElementValueType() + ")");
+            throw new UnsupportedOperationException("Not implemented yet! (" + value.getElementValueType() + ")");
         }
     }
 }
diff --git a/src/main/java/org/apache/bcel/generic/ElementValuePairGen.java b/src/main/java/org/apache/bcel/generic/ElementValuePairGen.java
index aa703d98..54d06860 100644
--- a/src/main/java/org/apache/bcel/generic/ElementValuePairGen.java
+++ b/src/main/java/org/apache/bcel/generic/ElementValuePairGen.java
@@ -45,7 +45,7 @@ public class ElementValuePairGen
         // if
         // (!nvp.getNameString().equals(((ConstantUtf8)cpool.getConstant(nvp.getNameIndex())).getBytes()))
         // {
-        // throw new RuntimeException("envp buggered");
+        // throw new IllegalArgumentException("envp buggered");
         // }
         if (copyPoolEntries)
         {
diff --git a/src/main/java/org/apache/bcel/generic/EnumElementValueGen.java b/src/main/java/org/apache/bcel/generic/EnumElementValueGen.java
index 73626f0c..122f4370 100644
--- a/src/main/java/org/apache/bcel/generic/EnumElementValueGen.java
+++ b/src/main/java/org/apache/bcel/generic/EnumElementValueGen.java
@@ -44,7 +44,7 @@ public class EnumElementValueGen extends ElementValueGen
     {
         super(ElementValueGen.ENUM_CONSTANT, cpool);
         if (super.getElementValueType() != ENUM_CONSTANT) {
-            throw new RuntimeException(
+            throw new IllegalArgumentException(
                     "Only element values of type enum can be built with this ctor - type specified: " + super.getElementValueType());
         }
         this.typeIdx = typeIdx;
diff --git a/src/main/java/org/apache/bcel/generic/FieldGen.java b/src/main/java/org/apache/bcel/generic/FieldGen.java
index 5884a410..5efb131b 100644
--- a/src/main/java/org/apache/bcel/generic/FieldGen.java
+++ b/src/main/java/org/apache/bcel/generic/FieldGen.java
@@ -252,7 +252,7 @@ public class FieldGen extends FieldGenOrMethodGen {
             case Const.T_REFERENCE:
                 return super.getConstantPool().addString((String) value);
             default:
-                throw new RuntimeException("Unhandled : " + super.getType().getType()); // sic
+                throw new IllegalStateException("Unhandled : " + super.getType().getType()); // sic
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/generic/InstructionFactory.java b/src/main/java/org/apache/bcel/generic/InstructionFactory.java
index 244463b5..74d731b3 100644
--- a/src/main/java/org/apache/bcel/generic/InstructionFactory.java
+++ b/src/main/java/org/apache/bcel/generic/InstructionFactory.java
@@ -101,7 +101,7 @@ public class InstructionFactory implements InstructionConstants {
         final Type[] arg_types, final short kind, final boolean use_interface) {
         if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC
             && kind != Const.INVOKEINTERFACE && kind != Const.INVOKEDYNAMIC) {
-            throw new RuntimeException("Unknown invoke kind: " + kind);
+            throw new IllegalArgumentException("Unknown invoke kind: " + kind);
         }
         int index;
         int nargs = 0;
@@ -276,7 +276,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_OBJECT:
                 return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);
             default:
-                throw new RuntimeException("No append for this type? " + type);
+                throw new IllegalArgumentException("No append for this type? " + type);
         }
     }
 
@@ -303,7 +303,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.PUTSTATIC:
                 return new PUTSTATIC(index);
             default:
-                throw new RuntimeException("Unknown getfield kind:" + kind);
+                throw new IllegalArgumentException("Unknown getfield kind:" + kind);
         }
     }
 
@@ -337,7 +337,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_VOID:
                 return InstructionConst.RETURN;
             default:
-                throw new RuntimeException("Invalid type: " + type);
+                throw new IllegalArgumentException("Invalid type: " + type);
         }
     }
 
@@ -365,7 +365,7 @@ public class InstructionFactory implements InstructionConstants {
             case '>':
                 return op.equals(">>>") ? InstructionConst.IUSHR : InstructionConst.ISHR;
             default:
-                throw new RuntimeException("Invalid operand " + op);
+                throw new IllegalArgumentException("Invalid operand " + op);
         }
     }
 
@@ -393,7 +393,7 @@ public class InstructionFactory implements InstructionConstants {
             case '>':
                 return op.equals(">>>") ? InstructionConst.LUSHR : InstructionConst.LSHR;
             default:
-                throw new RuntimeException("Invalid operand " + op);
+                throw new IllegalArgumentException("Invalid operand " + op);
         }
     }
 
@@ -411,7 +411,7 @@ public class InstructionFactory implements InstructionConstants {
             case '%':
                 return InstructionConst.FREM;
             default:
-                throw new RuntimeException("Invalid operand " + op);
+                throw new IllegalArgumentException("Invalid operand " + op);
         }
     }
 
@@ -429,7 +429,7 @@ public class InstructionFactory implements InstructionConstants {
             case '%':
                 return InstructionConst.DREM;
             default:
-                throw new RuntimeException("Invalid operand " + op);
+                throw new IllegalArgumentException("Invalid operand " + op);
         }
     }
 
@@ -454,7 +454,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_DOUBLE:
                 return createBinaryDoubleOp(first);
             default:
-                throw new RuntimeException("Invalid type " + type);
+                throw new IllegalArgumentException("Invalid type " + type);
         }
     }
 
@@ -512,7 +512,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_OBJECT:
                 return new ASTORE(index);
             default:
-                throw new RuntimeException("Invalid type " + type);
+                throw new IllegalArgumentException("Invalid type " + type);
         }
     }
 
@@ -538,7 +538,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_OBJECT:
                 return new ALOAD(index);
             default:
-                throw new RuntimeException("Invalid type " + type);
+                throw new IllegalArgumentException("Invalid type " + type);
         }
     }
 
@@ -567,7 +567,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_OBJECT:
                 return InstructionConst.AALOAD;
             default:
-                throw new RuntimeException("Invalid type " + type);
+                throw new IllegalArgumentException("Invalid type " + type);
         }
     }
 
@@ -596,7 +596,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_OBJECT:
                 return InstructionConst.AASTORE;
             default:
-                throw new RuntimeException("Invalid type " + type);
+                throw new IllegalArgumentException("Invalid type " + type);
         }
     }
 
@@ -618,7 +618,7 @@ public class InstructionFactory implements InstructionConstants {
             try {
                 i = (Instruction) java.lang.Class.forName(name).newInstance();
             } catch (final Exception e) {
-                throw new RuntimeException("Could not find instruction: " + name, e);
+                throw new IllegalArgumentException("Could not find instruction: " + name, e);
             }
             return i;
         } else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {
@@ -627,7 +627,7 @@ public class InstructionFactory implements InstructionConstants {
             }
             return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
         } else {
-            throw new RuntimeException("Can not cast " + src_type + " to " + dest_type);
+            throw new IllegalArgumentException("Cannot cast " + src_type + " to " + dest_type);
         }
     }
 
@@ -723,7 +723,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.T_VOID:
                 return InstructionConst.NOP;
             default:
-                throw new RuntimeException("Invalid type: " + type);
+                throw new IllegalArgumentException("Invalid type: " + type);
         }
     }
 
@@ -774,7 +774,7 @@ public class InstructionFactory implements InstructionConstants {
             case Const.JSR_W:
                 return new JSR_W(target);
             default:
-                throw new RuntimeException("Invalid opcode: " + opcode);
+                throw new IllegalArgumentException("Invalid opcode: " + opcode);
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/generic/JsrInstruction.java b/src/main/java/org/apache/bcel/generic/JsrInstruction.java
index 8844b565..55fb51dc 100644
--- a/src/main/java/org/apache/bcel/generic/JsrInstruction.java
+++ b/src/main/java/org/apache/bcel/generic/JsrInstruction.java
@@ -70,7 +70,7 @@ public abstract class JsrInstruction extends BranchInstruction implements Uncond
         while (ih != null) {
             ih = ih.getNext();
             if ((ih != null) && (ih.getInstruction() == this)) {
-                throw new RuntimeException("physicalSuccessor() called on a shared JsrInstruction.");
+                throw new IllegalStateException("physicalSuccessor() called on a shared JsrInstruction.");
             }
         }
         // Return the physical successor
diff --git a/src/main/java/org/apache/bcel/generic/LDC.java b/src/main/java/org/apache/bcel/generic/LDC.java
index 88bdfb0f..b324ae95 100644
--- a/src/main/java/org/apache/bcel/generic/LDC.java
+++ b/src/main/java/org/apache/bcel/generic/LDC.java
@@ -108,7 +108,7 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
                 c = cpg.getConstantPool().getConstant(nameIndex);
                 return new ObjectType(((org.apache.bcel.classfile.ConstantUtf8) c).getBytes());
             default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + super.getIndex());
+                throw new IllegalArgumentException("Unknown or invalid constant type at " + super.getIndex());
         }
     }
 
@@ -125,7 +125,7 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
             case org.apache.bcel.Const.CONSTANT_Class:
                 return Type.CLASS;
             default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + super.getIndex());
+                throw new IllegalArgumentException("Unknown or invalid constant type at " + super.getIndex());
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/generic/LDC2_W.java b/src/main/java/org/apache/bcel/generic/LDC2_W.java
index 2b055655..4dd64d9d 100644
--- a/src/main/java/org/apache/bcel/generic/LDC2_W.java
+++ b/src/main/java/org/apache/bcel/generic/LDC2_W.java
@@ -46,7 +46,7 @@ public class LDC2_W extends CPInstruction implements PushInstruction {
             case org.apache.bcel.Const.CONSTANT_Double:
                 return Type.DOUBLE;
             default: // Never reached
-                throw new RuntimeException("Unknown constant type " + super.getOpcode());
+                throw new IllegalArgumentException("Unknown constant type " + super.getOpcode());
         }
     }
 
@@ -59,7 +59,7 @@ public class LDC2_W extends CPInstruction implements PushInstruction {
             case org.apache.bcel.Const.CONSTANT_Double:
                 return new Double(((org.apache.bcel.classfile.ConstantDouble) c).getBytes());
             default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + super.getIndex());
+                throw new IllegalArgumentException("Unknown or invalid constant type at " + super.getIndex());
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/generic/SimpleElementValueGen.java b/src/main/java/org/apache/bcel/generic/SimpleElementValueGen.java
index f8334389..169a3dca 100644
--- a/src/main/java/org/apache/bcel/generic/SimpleElementValueGen.java
+++ b/src/main/java/org/apache/bcel/generic/SimpleElementValueGen.java
@@ -162,7 +162,7 @@ public class SimpleElementValueGen extends ElementValueGen
                 idx = cpool.addInteger(value.getValueShort());
                 break;
             default:
-                throw new RuntimeException(
+                throw new IllegalArgumentException(
                     "SimpleElementValueGen class does not know how to copy this type " + super.getElementValueType());
             }
         }
@@ -185,7 +185,7 @@ public class SimpleElementValueGen extends ElementValueGen
     public String getValueString()
     {
         if (super.getElementValueType() != STRING) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueString() on a non STRING ElementValue");
         }
         final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);
@@ -195,7 +195,7 @@ public class SimpleElementValueGen extends ElementValueGen
     public int getValueInt()
     {
         if (super.getElementValueType() != PRIMITIVE_INT) {
-            throw new RuntimeException(
+            throw new IllegalStateException(
                     "Dont call getValueString() on a non STRING ElementValue");
         }
         final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);
@@ -239,7 +239,7 @@ public class SimpleElementValueGen extends ElementValueGen
             final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(idx);
             return cu8.getBytes();
         default:
-            throw new RuntimeException(
+            throw new IllegalStateException(
                 "SimpleElementValueGen class does not know how to stringify type " + super.getElementValueType());
         }
     }
@@ -262,7 +262,7 @@ public class SimpleElementValueGen extends ElementValueGen
             dos.writeShort(idx);
             break;
         default:
-            throw new RuntimeException(
+            throw new IllegalStateException(
                 "SimpleElementValueGen doesnt know how to write out type " + super.getElementValueType());
         }
     }
diff --git a/src/main/java/org/apache/bcel/util/BCELFactory.java b/src/main/java/org/apache/bcel/util/BCELFactory.java
index 2910e5c6..a9e8ae5d 100644
--- a/src/main/java/org/apache/bcel/util/BCELFactory.java
+++ b/src/main/java/org/apache/bcel/util/BCELFactory.java
@@ -196,7 +196,7 @@ class BCELFactory extends EmptyVisitor {
                         + ", (short) " + dim + "));");
                 break;
             default:
-                throw new RuntimeException("Unhandled opcode: " + opcode);
+                throw new IllegalArgumentException("Unhandled opcode: " + opcode);
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/util/InstructionFinder.java b/src/main/java/org/apache/bcel/util/InstructionFinder.java
index 1f07ae7f..2b3214f3 100644
--- a/src/main/java/org/apache/bcel/util/InstructionFinder.java
+++ b/src/main/java/org/apache/bcel/util/InstructionFinder.java
@@ -117,7 +117,7 @@ public class InstructionFinder {
                 return "" + makeChar(i);
             }
         }
-        throw new RuntimeException("Instruction unknown: " + pattern);
+        throw new IllegalArgumentException("Instruction unknown: " + pattern);
     }
 
 
diff --git a/src/main/java/org/apache/bcel/util/JavaWrapper.java b/src/main/java/org/apache/bcel/util/JavaWrapper.java
index 89dc474b..2e0ee616 100644
--- a/src/main/java/org/apache/bcel/util/JavaWrapper.java
+++ b/src/main/java/org/apache/bcel/util/JavaWrapper.java
@@ -43,12 +43,12 @@ public class JavaWrapper {
     private static java.lang.ClassLoader getClassLoader() {
         final String s = System.getProperty("bcel.classloader");
         if ((s == null) || "".equals(s)) {
-            throw new IllegalArgumentException("The property 'bcel.classloader' must be defined");
+            throw new IllegalStateException("The property 'bcel.classloader' must be defined");
         }
         try {
             return (java.lang.ClassLoader) Class.forName(s).newInstance();
         } catch (final Exception e) {
-            throw new RuntimeException(e.toString(), e);
+            throw new IllegalStateException(e.toString(), e);
         }
     }
 
diff --git a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
index f8fc6e57..cbe91b9a 100644
--- a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
+++ b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
@@ -1127,7 +1127,7 @@ public final class Pass3aVerifier extends PassVerifier{
         /** Checks if the constraints of operands of the said instruction(s) are satisfied. */
         @Override
         public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC o) {
-            throw new RuntimeException("INVOKEDYNAMIC instruction is not supported at this time");
+            throw new UnsupportedOperationException("INVOKEDYNAMIC instruction is not supported at this time");
         }
 
         /** Checks if the constraints of operands of the said instruction(s) are satisfied. */
diff --git a/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java b/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
index 09863cc9..35a71c9e 100644
--- a/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
+++ b/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
@@ -1802,7 +1802,7 @@ public class InstConstraintVisitor extends EmptyVisitor{
      */
     @Override
     public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC o) {
-        throw new RuntimeException("INVOKEDYNAMIC instruction is not supported at this time");
+        throw new UnsupportedOperationException("INVOKEDYNAMIC instruction is not supported at this time");
     }
 
     /**
diff --git a/src/main/java/org/apache/bcel/verifier/structurals/Pass3bVerifier.java b/src/main/java/org/apache/bcel/verifier/structurals/Pass3bVerifier.java
index fd7b5da1..50d2ed9a 100644
--- a/src/main/java/org/apache/bcel/verifier/structurals/Pass3bVerifier.java
+++ b/src/main/java/org/apache/bcel/verifier/structurals/Pass3bVerifier.java
@@ -323,7 +323,7 @@ public final class Pass3bVerifier extends PassVerifier{
                             }
                         } catch (final ClassNotFoundException e) {
                             // Don't know what do do now, so raise RuntimeException
-                            throw new RuntimeException(e);
+                            throw new IllegalArgumentException(e);
                         }
                     } else if (!returnedType.equals(m.getReturnType().normalizeForStackOrLocal())) {
                         invalidReturnTypeError(returnedType, m);
