diff --git a/src/main/java/org/apache/commons/bcel6/generic/InstructionList.java b/src/main/java/org/apache/commons/bcel6/generic/InstructionList.java
index 11d717e8..066159be 100644
--- a/src/main/java/org/apache/commons/bcel6/generic/InstructionList.java
+++ b/src/main/java/org/apache/commons/bcel6/generic/InstructionList.java
@@ -31,22 +31,16 @@ import org.apache.commons.bcel6.Const;
 import org.apache.commons.bcel6.classfile.Constant;
 import org.apache.commons.bcel6.util.ByteSequence;
 
-/** 
- * This class is a container for a list of <a
- * href="Instruction.html">Instruction</a> objects. Instructions can
- * be appended, inserted, moved, deleted, etc.. Instructions are being
- * wrapped into <a
- * href="InstructionHandle.html">InstructionHandles</a> objects that
- * are returned upon append/insert operations. They give the user
- * (read only) access to the list structure, such that it can be traversed and
- * manipulated in a controlled way.
+/**
+ * This class is a container for a list of <a href="Instruction.html">Instruction</a> objects. Instructions can be appended, inserted, moved, deleted, etc..
+ * Instructions are being wrapped into <a href="InstructionHandle.html">InstructionHandles</a> objects that are returned upon append/insert operations. They
+ * give the user (read only) access to the list structure, such that it can be traversed and manipulated in a controlled way.
  *
- * A list is finally dumped to a byte code array with <a
- * href="#getByteCode()">getByteCode</a>.
+ * A list is finally dumped to a byte code array with <a href="#getByteCode()">getByteCode</a>.
  *
  * @version $Id$
- * @see     Instruction
- * @see     InstructionHandle
+ * @see Instruction
+ * @see InstructionHandle
  * @see BranchHandle
  */
 public class InstructionList implements Iterable<InstructionHandle> {
@@ -56,43 +50,42 @@ public class InstructionList implements Iterable<InstructionHandle> {
     private int length = 0; // number of elements in list
     private int[] byte_positions; // byte code offsets corresponding to instructions
 
-
     /**
      * Create (empty) instruction list.
      */
     public InstructionList() {
     }
 
-
     /**
      * Create instruction list containing one instruction.
-     * @param i initial instruction
+     * 
+     * @param i
+     *            initial instruction
      */
     public InstructionList(Instruction i) {
         append(i);
     }
 
-
     /**
      * Create instruction list containing one instruction.
-     * @param i initial instruction
+     * 
+     * @param i
+     *            initial instruction
      */
     public InstructionList(BranchInstruction i) {
         append(i);
     }
 
-
     /**
-     * Initialize list with (nonnull) compound instruction. Consumes argument
-     * list, i.e., it becomes empty.
+     * Initialize list with (nonnull) compound instruction. Consumes argument list, i.e., it becomes empty.
      *
-     * @param c compound instruction (list)
+     * @param c
+     *            compound instruction (list)
      */
     public InstructionList(CompoundInstruction c) {
         append(c.getInstructionList());
     }
 
-
     /**
      * Test for empty list.
      */
@@ -100,22 +93,24 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return start == null;
     } // && end == null
 
-
     /**
-     * Find the target instruction (handle) that corresponds to the given target
-     * position (byte code offset).
+     * Find the target instruction (handle) that corresponds to the given target position (byte code offset).
      *
-     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()
-     * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()
-     * @param count length of arrays
-     * @param target target position to search for
+     * @param ihs
+     *            array of instruction handles, i.e. il.getInstructionHandles()
+     * @param pos
+     *            array of positions corresponding to ihs, i.e. il.getInstructionPositions()
+     * @param count
+     *            length of arrays
+     * @param target
+     *            target position to search for
      * @return target position's instruction handle if available
      */
-    public static InstructionHandle findHandle( InstructionHandle[] ihs, int[] pos, int count,
-            int target ) {
+    public static InstructionHandle findHandle(InstructionHandle[] ihs, int[] pos, int count, int target) {
         int l = 0;
         int r = count - 1;
-        /* Do a binary search since the pos array is orderd.
+        /*
+         * Do a binary search since the pos array is orderd.
          */
         do {
             int i = (l + r) / 2;
@@ -131,20 +126,19 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return null;
     }
 
-
     /**
-     * Get instruction handle for instruction at byte code position pos.
-     * This only works properly, if the list is freshly initialized from a byte array or
+     * Get instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly initialized from a byte array or
      * setPositions() has been called before this method.
      *
-     * @param pos byte code position to search for
+     * @param pos
+     *            byte code position to search for
      * @return target position's instruction handle if available
      */
-    public InstructionHandle findHandle( int pos ) {
+    public InstructionHandle findHandle(int pos) {
         int[] positions = byte_positions;
         InstructionHandle ih = start;
-        for (int i = 0; i < length; i++) { 
-            if(positions[i] == pos) {
+        for (int i = 0; i < length; i++) {
+            if (positions[i] == pos) {
                 return ih;
             }
             ih = ih.getNext();
@@ -152,27 +146,27 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return null;
     }
 
-
     /**
      * Initialize instruction list from byte array.
      *
-     * @param code byte array containing the instructions
+     * @param code
+     *            byte array containing the instructions
      */
     public InstructionList(byte[] code) {
         ByteSequence bytes = new ByteSequence(code);
         InstructionHandle[] ihs = new InstructionHandle[code.length];
         int[] pos = new int[code.length]; // Can't be more than that
         int count = 0; // Contains actual length
-        /* Pass 1: Create an object for each byte code and append them
-         * to the list.
+        /*
+         * Pass 1: Create an object for each byte code and append them to the list.
          */
         try {
             while (bytes.available() > 0) {
                 // Remember byte offset and associate it with the instruction
                 int off = bytes.getIndex();
                 pos[count] = off;
-                /* Read one instruction from the byte stream, the byte position is set
-                 * accordingly.
+                /*
+                 * Read one instruction from the byte stream, the byte position is set accordingly.
                  */
                 Instruction i = Instruction.readInstruction(bytes);
                 InstructionHandle ih;
@@ -190,14 +184,15 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
         byte_positions = new int[count]; // Trim to proper size
         System.arraycopy(pos, 0, byte_positions, 0, count);
-        /* Pass 2: Look for BranchInstruction and update their targets, i.e.,
-         * convert offsets to instruction handles.
+        /*
+         * Pass 2: Look for BranchInstruction and update their targets, i.e., convert offsets to instruction handles.
          */
         for (int i = 0; i < count; i++) {
             if (ihs[i] instanceof BranchHandle) {
                 BranchInstruction bi = (BranchInstruction) ihs[i].getInstruction();
-                int target = bi.getPosition() + bi.getIndex(); /* Byte code position:
-                 * relative -> absolute. */
+                int target = bi.getPosition() + bi.getIndex(); /*
+                                                                * Byte code position: relative -> absolute.
+                                                                */
                 // Search for target position
                 InstructionHandle ih = findHandle(ihs, pos, count, target);
                 if (ih == null) {
@@ -214,23 +209,23 @@ public class InstructionList implements Iterable<InstructionHandle> {
                         if (ih == null) {
                             throw new ClassGenException("Couldn't find target for switch: " + bi);
                         }
-                        s.setTarget(j, ih); // Update target      
+                        s.setTarget(j, ih); // Update target
                     }
                 }
             }
         }
     }
 
-
     /**
-     * Append another list after instruction (handle) ih contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
+     * Append another list after instruction (handle) ih contained in this list. Consumes argument list, i.e., it becomes empty.
      *
-     * @param ih where to append the instruction list 
-     * @param il Instruction list to append to this one
+     * @param ih
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to append to this one
      * @return instruction handle pointing to the <B>first</B> appended instruction
      */
-    public InstructionHandle append( InstructionHandle ih, InstructionList il ) {
+    public InstructionHandle append(InstructionHandle ih, InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Appending null InstructionList");
         }
@@ -252,16 +247,16 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return ret;
     }
 
-
     /**
-     * Append another list after instruction i contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
+     * Append another list after instruction i contained in this list. Consumes argument list, i.e., it becomes empty.
      *
-     * @param i  where to append the instruction list 
-     * @param il Instruction list to append to this one
+     * @param i
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to append to this one
      * @return instruction handle pointing to the <B>first</B> appended instruction
      */
-    public InstructionHandle append( Instruction i, InstructionList il ) {
+    public InstructionHandle append(Instruction i, InstructionList il) {
         InstructionHandle ih;
         if ((ih = findInstruction2(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -269,15 +264,14 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return append(ih, il);
     }
 
-
     /**
-     * Append another list to this one.
-     * Consumes argument list, i.e., it becomes empty.
+     * Append another list to this one. Consumes argument list, i.e., it becomes empty.
      *
-     * @param il list to append to end of this list
+     * @param il
+     *            list to append to end of this list
      * @return instruction handle of the <B>first</B> appended instruction
      */
-    public InstructionHandle append( InstructionList il ) {
+    public InstructionHandle append(InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Appending null InstructionList");
         }
@@ -294,13 +288,13 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return append(end, il); // was end.instruction
     }
 
-
     /**
      * Append an instruction to the end of this list.
      *
-     * @param ih instruction to append
+     * @param ih
+     *            instruction to append
      */
-    private void append( InstructionHandle ih ) {
+    private void append(InstructionHandle ih) {
         if (isEmpty()) {
             start = end = ih;
             ih.setNext(ih.setPrev(null));
@@ -313,101 +307,105 @@ public class InstructionList implements Iterable<InstructionHandle> {
         length++; // Update length
     }
 
-
     /**
      * Append an instruction to the end of this list.
      *
-     * @param i instruction to append
+     * @param i
+     *            instruction to append
      * @return instruction handle of the appended instruction
      */
-    public InstructionHandle append( Instruction i ) {
+    public InstructionHandle append(Instruction i) {
         InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
         append(ih);
         return ih;
     }
 
-
     /**
      * Append a branch instruction to the end of this list.
      *
-     * @param i branch instruction to append
+     * @param i
+     *            branch instruction to append
      * @return branch instruction handle of the appended instruction
      */
-    public BranchHandle append( BranchInstruction i ) {
+    public BranchHandle append(BranchInstruction i) {
         BranchHandle ih = BranchHandle.getBranchHandle(i);
         append(ih);
         return ih;
     }
 
-
     /**
-     * Append a single instruction j after another instruction i, which
-     * must be in this list of course!
+     * Append a single instruction j after another instruction i, which must be in this list of course!
      *
-     * @param i Instruction in list
-     * @param j Instruction to append after i in list
+     * @param i
+     *            Instruction in list
+     * @param j
+     *            Instruction to append after i in list
      * @return instruction handle of the first appended instruction
      */
-    public InstructionHandle append( Instruction i, Instruction j ) {
+    public InstructionHandle append(Instruction i, Instruction j) {
         return append(i, new InstructionList(j));
     }
 
-
     /**
      * Append a compound instruction, after instruction i.
      *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param i
+     *            Instruction in list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
-    public InstructionHandle append( Instruction i, CompoundInstruction c ) {
+    public InstructionHandle append(Instruction i, CompoundInstruction c) {
         return append(i, c.getInstructionList());
     }
 
-
     /**
      * Append a compound instruction.
      *
-     * @param c The composite instruction (containing an InstructionList)
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
-    public InstructionHandle append( CompoundInstruction c ) {
+    public InstructionHandle append(CompoundInstruction c) {
         return append(c.getInstructionList());
     }
 
-
     /**
      * Append a compound instruction.
      *
-     * @param ih where to append the instruction list 
-     * @param c The composite instruction (containing an InstructionList)
+     * @param ih
+     *            where to append the instruction list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
-    public InstructionHandle append( InstructionHandle ih, CompoundInstruction c ) {
+    public InstructionHandle append(InstructionHandle ih, CompoundInstruction c) {
         return append(ih, c.getInstructionList());
     }
 
-
     /**
      * Append an instruction after instruction (handle) ih contained in this list.
      *
-     * @param ih where to append the instruction list 
-     * @param i Instruction to append
+     * @param ih
+     *            where to append the instruction list
+     * @param i
+     *            Instruction to append
      * @return instruction handle pointing to the <B>first</B> appended instruction
      */
-    public InstructionHandle append( InstructionHandle ih, Instruction i ) {
+    public InstructionHandle append(InstructionHandle ih, Instruction i) {
         return append(ih, new InstructionList(i));
     }
 
-
     /**
      * Append an instruction after instruction (handle) ih contained in this list.
      *
-     * @param ih where to append the instruction list 
-     * @param i Instruction to append
+     * @param ih
+     *            where to append the instruction list
+     * @param i
+     *            Instruction to append
      * @return instruction handle pointing to the <B>first</B> appended instruction
      */
-    public BranchHandle append( InstructionHandle ih, BranchInstruction i ) {
+    public BranchHandle append(InstructionHandle ih, BranchInstruction i) {
         BranchHandle bh = BranchHandle.getBranchHandle(i);
         InstructionList il = new InstructionList();
         il.append(bh);
@@ -415,16 +413,16 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return bh;
     }
 
-
     /**
-     * Insert another list before Instruction handle ih contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
+     * Insert another list before Instruction handle ih contained in this list. Consumes argument list, i.e., it becomes empty.
      *
-     * @param ih  where to append the instruction list 
-     * @param il Instruction list to insert
+     * @param ih
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to insert
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( InstructionHandle ih, InstructionList il ) {
+    public InstructionHandle insert(InstructionHandle ih, InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Inserting null InstructionList");
         }
@@ -446,14 +444,14 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return ret;
     }
 
-
     /**
-     * Insert another list.   
+     * Insert another list.
      *
-     * @param il list to insert before start of this list
+     * @param il
+     *            list to insert before start of this list
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( InstructionList il ) {
+    public InstructionHandle insert(InstructionList il) {
         if (isEmpty()) {
             append(il); // Code is identical for this case
             return start;
@@ -461,13 +459,13 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return insert(start, il);
     }
 
-
     /**
      * Insert an instruction at start of this list.
      *
-     * @param ih instruction to insert
+     * @param ih
+     *            instruction to insert
      */
-    private void insert( InstructionHandle ih ) {
+    private void insert(InstructionHandle ih) {
         if (isEmpty()) {
             start = end = ih;
             ih.setNext(ih.setPrev(null));
@@ -480,17 +478,16 @@ public class InstructionList implements Iterable<InstructionHandle> {
         length++;
     }
 
-
     /**
-     * Insert another list before Instruction i contained in this list.
-     * Consumes argument list, i.e., it becomes empty.
+     * Insert another list before Instruction i contained in this list. Consumes argument list, i.e., it becomes empty.
      *
-     * @param i  where to append the instruction list 
-     * @param il Instruction list to insert
-     * @return instruction handle pointing to the first inserted instruction,
-     * i.e., il.getStart()
+     * @param i
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to insert
+     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()
      */
-    public InstructionHandle insert( Instruction i, InstructionList il ) {
+    public InstructionHandle insert(Instruction i, InstructionList il) {
         InstructionHandle ih;
         if ((ih = findInstruction1(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -498,101 +495,105 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return insert(ih, il);
     }
 
-
     /**
      * Insert an instruction at start of this list.
      *
-     * @param i instruction to insert
+     * @param i
+     *            instruction to insert
      * @return instruction handle of the inserted instruction
      */
-    public InstructionHandle insert( Instruction i ) {
+    public InstructionHandle insert(Instruction i) {
         InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
         insert(ih);
         return ih;
     }
 
-
     /**
      * Insert a branch instruction at start of this list.
      *
-     * @param i branch instruction to insert
+     * @param i
+     *            branch instruction to insert
      * @return branch instruction handle of the appended instruction
      */
-    public BranchHandle insert( BranchInstruction i ) {
+    public BranchHandle insert(BranchInstruction i) {
         BranchHandle ih = BranchHandle.getBranchHandle(i);
         insert(ih);
         return ih;
     }
 
-
     /**
-     * Insert a single instruction j before another instruction i, which
-     * must be in this list of course!
+     * Insert a single instruction j before another instruction i, which must be in this list of course!
      *
-     * @param i Instruction in list
-     * @param j Instruction to insert before i in list
+     * @param i
+     *            Instruction in list
+     * @param j
+     *            Instruction to insert before i in list
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( Instruction i, Instruction j ) {
+    public InstructionHandle insert(Instruction i, Instruction j) {
         return insert(i, new InstructionList(j));
     }
 
-
     /**
      * Insert a compound instruction before instruction i.
      *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param i
+     *            Instruction in list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( Instruction i, CompoundInstruction c ) {
+    public InstructionHandle insert(Instruction i, CompoundInstruction c) {
         return insert(i, c.getInstructionList());
     }
 
-
     /**
      * Insert a compound instruction.
      *
-     * @param c The composite instruction (containing an InstructionList)
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( CompoundInstruction c ) {
+    public InstructionHandle insert(CompoundInstruction c) {
         return insert(c.getInstructionList());
     }
 
-
     /**
      * Insert an instruction before instruction (handle) ih contained in this list.
      *
-     * @param ih where to insert to the instruction list 
-     * @param i Instruction to insert
+     * @param ih
+     *            where to insert to the instruction list
+     * @param i
+     *            Instruction to insert
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( InstructionHandle ih, Instruction i ) {
+    public InstructionHandle insert(InstructionHandle ih, Instruction i) {
         return insert(ih, new InstructionList(i));
     }
 
-
     /**
      * Insert a compound instruction.
      *
-     * @param ih where to insert the instruction list 
-     * @param c The composite instruction (containing an InstructionList)
+     * @param ih
+     *            where to insert the instruction list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
-    public InstructionHandle insert( InstructionHandle ih, CompoundInstruction c ) {
+    public InstructionHandle insert(InstructionHandle ih, CompoundInstruction c) {
         return insert(ih, c.getInstructionList());
     }
 
-
     /**
      * Insert an instruction before instruction (handle) ih contained in this list.
      *
-     * @param ih where to insert to the instruction list 
-     * @param i Instruction to insert
+     * @param ih
+     *            where to insert to the instruction list
+     * @param i
+     *            Instruction to insert
      * @return instruction handle of the first inserted instruction
      */
-    public BranchHandle insert( InstructionHandle ih, BranchInstruction i ) {
+    public BranchHandle insert(InstructionHandle ih, BranchInstruction i) {
         BranchHandle bh = BranchHandle.getBranchHandle(i);
         InstructionList il = new InstructionList();
         il.append(bh);
@@ -600,33 +601,31 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return bh;
     }
 
-
     /**
-     * Take all instructions (handles) from "start" to "end" and append them after the
-     * new location "target". Of course, "end" must be after "start" and target must
-     * not be located withing this range. If you want to move something to the start of
-     * the list use null as value for target.<br>
+     * Take all instructions (handles) from "start" to "end" and append them after the new location "target". Of course, "end" must be after "start" and target
+     * must not be located withing this range. If you want to move something to the start of the list use null as value for target.<br>
      * Any instruction targeters pointing to handles within the block, keep their targets.
      *
-     * @param start  of moved block
-     * @param end    of moved block
-     * @param target of moved block
+     * @param start
+     *            of moved block
+     * @param end
+     *            of moved block
+     * @param target
+     *            of moved block
      */
-    public void move( InstructionHandle start, InstructionHandle end, InstructionHandle target ) {
+    public void move(InstructionHandle start, InstructionHandle end, InstructionHandle target) {
         // Step 1: Check constraints
         if ((start == null) || (end == null)) {
             throw new ClassGenException("Invalid null handle: From " + start + " to " + end);
         }
         if ((target == start) || (target == end)) {
-            throw new ClassGenException("Invalid range: From " + start + " to " + end
-                    + " contains target " + target);
+            throw new ClassGenException("Invalid range: From " + start + " to " + end + " contains target " + target);
         }
         for (InstructionHandle ih = start; ih != end.getNext(); ih = ih.getNext()) {
             if (ih == null) {
                 throw new ClassGenException("Invalid range: From " + start + " to " + end);
             } else if (ih == target) {
-                throw new ClassGenException("Invalid range: From " + start + " to " + end
-                        + " contains target " + target);
+                throw new ClassGenException("Invalid range: From " + start + " to " + end + " contains target " + target);
             }
         }
         // Step 2: Temporarily remove the given instructions from the list
@@ -663,28 +662,28 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
     }
 
-
     /**
      * Move a single instruction (handle) to a new location.
      *
-     * @param ih     moved instruction
-     * @param target new location of moved instruction
+     * @param ih
+     *            moved instruction
+     * @param target
+     *            new location of moved instruction
      */
-    public void move( InstructionHandle ih, InstructionHandle target ) {
+    public void move(InstructionHandle ih, InstructionHandle target) {
         move(ih, ih, target);
     }
 
-
     /**
-     * Remove from instruction `prev' to instruction `next' both contained
-     * in this list. Throws TargetLostException when one of the removed instruction handles
+     * Remove from instruction `prev' to instruction `next' both contained in this list. Throws TargetLostException when one of the removed instruction handles
      * is still being targeted.
      *
-     * @param prev where to start deleting (predecessor, exclusive)
-     * @param next where to end deleting (successor, exclusive)
+     * @param prev
+     *            where to start deleting (predecessor, exclusive)
+     * @param next
+     *            where to end deleting (successor, exclusive)
      */
-    private void remove( InstructionHandle prev, InstructionHandle next )
-            throws TargetLostException {
+    private void remove(InstructionHandle prev, InstructionHandle next) throws TargetLostException {
         InstructionHandle first;
         InstructionHandle last; // First and last deleted instruction
         if ((prev == null) && (next == null)) {
@@ -733,25 +732,23 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
     }
 
-
     /**
-     * Remove instruction from this list. The corresponding Instruction
-     * handles must not be reused!
+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!
      *
-     * @param ih instruction (handle) to remove 
+     * @param ih
+     *            instruction (handle) to remove
      */
-    public void delete( InstructionHandle ih ) throws TargetLostException {
+    public void delete(InstructionHandle ih) throws TargetLostException {
         remove(ih.getPrev(), ih.getNext());
     }
 
-
     /**
-     * Remove instruction from this list. The corresponding Instruction
-     * handles must not be reused!
+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!
      *
-     * @param i instruction to remove
+     * @param i
+     *            instruction to remove
      */
-    public void delete( Instruction i ) throws TargetLostException {
+    public void delete(Instruction i) throws TargetLostException {
         InstructionHandle ih;
         if ((ih = findInstruction1(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -759,29 +756,29 @@ public class InstructionList implements Iterable<InstructionHandle> {
         delete(ih);
     }
 
-
     /**
-     * Remove instructions from instruction `from' to instruction `to' contained
-     * in this list. The user must ensure that `from' is an instruction before
-     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
+     * Remove instructions from instruction `from' to instruction `to' contained in this list. The user must ensure that `from' is an instruction before `to',
+     * or risk havoc. The corresponding Instruction handles must not be reused!
      *
-     * @param from where to start deleting (inclusive)
-     * @param to   where to end deleting (inclusive)
+     * @param from
+     *            where to start deleting (inclusive)
+     * @param to
+     *            where to end deleting (inclusive)
      */
-    public void delete( InstructionHandle from, InstructionHandle to ) throws TargetLostException {
+    public void delete(InstructionHandle from, InstructionHandle to) throws TargetLostException {
         remove(from.getPrev(), to.getNext());
     }
 
-
     /**
-     * Remove instructions from instruction `from' to instruction `to' contained
-     * in this list. The user must ensure that `from' is an instruction before
-     * `to', or risk havoc. The corresponding Instruction handles must not be reused!
+     * Remove instructions from instruction `from' to instruction `to' contained in this list. The user must ensure that `from' is an instruction before `to',
+     * or risk havoc. The corresponding Instruction handles must not be reused!
      *
-     * @param from where to start deleting (inclusive)
-     * @param to   where to end deleting (inclusive)
+     * @param from
+     *            where to start deleting (inclusive)
+     * @param to
+     *            where to end deleting (inclusive)
      */
-    public void delete( Instruction from, Instruction to ) throws TargetLostException {
+    public void delete(Instruction from, Instruction to) throws TargetLostException {
         InstructionHandle from_ih;
         InstructionHandle to_ih;
         if ((from_ih = findInstruction1(from)) == null) {
@@ -793,14 +790,14 @@ public class InstructionList implements Iterable<InstructionHandle> {
         delete(from_ih, to_ih);
     }
 
-
     /**
      * Search for given Instruction reference, start at beginning of list.
      *
-     * @param i instruction to search for
+     * @param i
+     *            instruction to search for
      * @return instruction found on success, null otherwise
      */
-    private InstructionHandle findInstruction1( Instruction i ) {
+    private InstructionHandle findInstruction1(Instruction i) {
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             if (ih.getInstruction() == i) {
                 return ih;
@@ -809,14 +806,14 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return null;
     }
 
-
     /**
      * Search for given Instruction reference, start at end of list
      *
-     * @param i instruction to search for
+     * @param i
+     *            instruction to search for
      * @return instruction found on success, null otherwise
      */
-    private InstructionHandle findInstruction2( Instruction i ) {
+    private InstructionHandle findInstruction2(Instruction i) {
         for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {
             if (ih.getInstruction() == i) {
                 return ih;
@@ -825,8 +822,7 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return null;
     }
 
-
-    public boolean contains( InstructionHandle i ) {
+    public boolean contains(InstructionHandle i) {
         if (i == null) {
             return false;
         }
@@ -838,31 +834,28 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return false;
     }
 
-
-    public boolean contains( Instruction i ) {
+    public boolean contains(Instruction i) {
         return findInstruction1(i) != null;
     }
 
-
     public void setPositions() { // TODO could be package-protected? (some test code would need to be repackaged)
         setPositions(false);
     }
 
-
     /**
-     * Give all instructions their position number (offset in byte stream), i.e.,
-     * make the list ready to be dumped.
+     * Give all instructions their position number (offset in byte stream), i.e., make the list ready to be dumped.
      *
-     * @param check Perform sanity checks, e.g. if all targeted instructions really belong
-     * to this list
+     * @param check
+     *            Perform sanity checks, e.g. if all targeted instructions really belong to this list
      */
-    public void setPositions( boolean check ) { // called by code in other packages
+    public void setPositions(boolean check) { // called by code in other packages
         int max_additional_bytes = 0;
         int additional_bytes = 0;
         int index = 0;
         int count = 0;
         int[] pos = new int[length];
-        /* Pass 0: Sanity checks
+        /*
+         * Pass 0: Sanity checks
          */
         if (check) {
             for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
@@ -870,62 +863,56 @@ public class InstructionList implements Iterable<InstructionHandle> {
                 if (i instanceof BranchInstruction) { // target instruction within list?
                     Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
                     if (!contains(inst)) {
-                        throw new ClassGenException("Branch target of "
-                                + Const.getOpcodeName(i.getOpcode()) + ":" + inst
-                                + " not in instruction list");
+                        throw new ClassGenException("Branch target of " + Const.getOpcodeName(i.getOpcode()) + ":" + inst + " not in instruction list");
                     }
                     if (i instanceof Select) {
                         InstructionHandle[] targets = ((Select) i).getTargets();
                         for (InstructionHandle target : targets) {
                             inst = target.getInstruction();
                             if (!contains(inst)) {
-                                throw new ClassGenException("Branch target of "
-                                        + Const.getOpcodeName(i.getOpcode()) + ":" + inst
-                                        + " not in instruction list");
+                                throw new ClassGenException("Branch target of " + Const.getOpcodeName(i.getOpcode()) + ":" + inst + " not in instruction list");
                             }
                         }
                     }
                     if (!(ih instanceof BranchHandle)) {
-                        throw new ClassGenException("Branch instruction "
-                                + Const.getOpcodeName(i.getOpcode()) + ":" + inst
-                                + " not contained in BranchHandle.");
+                        throw new ClassGenException(
+                                "Branch instruction " + Const.getOpcodeName(i.getOpcode()) + ":" + inst + " not contained in BranchHandle.");
                     }
                 }
             }
         }
-        /* Pass 1: Set position numbers and sum up the maximum number of bytes an
-         * instruction may be shifted.
+        /*
+         * Pass 1: Set position numbers and sum up the maximum number of bytes an instruction may be shifted.
          */
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             Instruction i = ih.getInstruction();
             ih.setPosition(index);
             pos[count++] = index;
-            /* Get an estimate about how many additional bytes may be added, because
-             * BranchInstructions may have variable length depending on the target
-             * offset (short vs. int) or alignment issues (TABLESWITCH and
-             * LOOKUPSWITCH).
+            /*
+             * Get an estimate about how many additional bytes may be added, because BranchInstructions may have variable length depending on the target offset
+             * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).
              */
             switch (i.getOpcode()) {
                 case Const.JSR:
                 case Const.GOTO:
                     max_additional_bytes += 2;
-                    break;
+                break;
                 case Const.TABLESWITCH:
                 case Const.LOOKUPSWITCH:
                     max_additional_bytes += 3;
-                    break;
+                break;
             }
             index += i.getLength();
         }
-        /* Pass 2: Expand the variable-length (Branch)Instructions depending on
-         * the target offset (short or int) and ensure that branch targets are
-         * within this list.
+        /*
+         * Pass 2: Expand the variable-length (Branch)Instructions depending on the target offset (short or int) and ensure that branch targets are within this
+         * list.
          */
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
         }
-        /* Pass 3: Update position numbers (which may have changed due to the
-         * preceding expansions), like pass 1.
+        /*
+         * Pass 3: Update position numbers (which may have changed due to the preceding expansions), like pass 1.
          */
         index = count = 0;
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
@@ -938,10 +925,8 @@ public class InstructionList implements Iterable<InstructionHandle> {
         System.arraycopy(pos, 0, byte_positions, 0, count);
     }
 
-
     /**
-     * When everything is finished, use this method to convert the instruction
-     * list into an array of bytes.
+     * When everything is finished, use this method to convert the instruction list into an array of bytes.
      *
      * @return the byte code ready to be dumped
      */
@@ -955,6 +940,7 @@ public class InstructionList implements Iterable<InstructionHandle> {
                 Instruction i = ih.getInstruction();
                 i.dump(out); // Traverse list
             }
+            out.flush();
         } catch (IOException e) {
             System.err.println(e);
             return new byte[0];
@@ -962,7 +948,6 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return b.toByteArray();
     }
 
-
     /**
      * @return an array of instructions without target information for branch instructions.
      */
@@ -979,18 +964,17 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return instructions.toArray(new Instruction[instructions.size()]);
     }
 
-
     @Override
     public String toString() {
         return toString(true);
     }
 
-
     /**
-     * @param verbose toggle output format
+     * @param verbose
+     *            toggle output format
      * @return String containing all instructions in this list.
      */
-    public String toString( boolean verbose ) {
+    public String toString(boolean verbose) {
         StringBuilder buf = new StringBuilder();
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             buf.append(ih.toString(verbose)).append("\n");
@@ -998,16 +982,15 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return buf.toString();
     }
 
-
     /**
      * @return iterator that lists all instructions (handles)
      */
+    @Override
     public Iterator<InstructionHandle> iterator() {
         return new Iterator<InstructionHandle>() {
 
             private InstructionHandle ih = start;
 
-
             @Override
             public InstructionHandle next() throws NoSuchElementException {
                 if (ih == null) {
@@ -1018,13 +1001,11 @@ public class InstructionList implements Iterable<InstructionHandle> {
                 return i;
             }
 
-
             @Override
             public void remove() {
                 throw new UnsupportedOperationException();
             }
 
-
             @Override
             public boolean hasNext() {
                 return ih != null;
@@ -1032,7 +1013,6 @@ public class InstructionList implements Iterable<InstructionHandle> {
         };
     }
 
-
     /**
      * @return array containing all instructions (handles)
      */
@@ -1046,11 +1026,9 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return ihs;
     }
 
-
     /**
-     * Get positions (offsets) of all instructions in the list. This relies on that
-     * the list has been freshly created from an byte code array, or that setPositions()
-     * has been called. Otherwise this may be inaccurate.
+     * Get positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from an byte code array, or that
+     * setPositions() has been called. Otherwise this may be inaccurate.
      *
      * @return array containing all instruction's offset in byte code
      */
@@ -1058,16 +1036,14 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return byte_positions;
     }
 
-
     /**
      * @return complete, i.e., deep copy of this list
      */
     public InstructionList copy() {
         Map<InstructionHandle, InstructionHandle> map = new HashMap<>();
         InstructionList il = new InstructionList();
-        /* Pass 1: Make copies of all instructions, append them to the new list
-         * and associate old instruction references with the new ones, i.e.,
-         * a 1:1 mapping.
+        /*
+         * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with the new ones, i.e., a 1:1 mapping.
          */
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             Instruction i = ih.getInstruction();
@@ -1078,7 +1054,8 @@ public class InstructionList implements Iterable<InstructionHandle> {
                 map.put(ih, il.append(c));
             }
         }
-        /* Pass 2: Update branch targets.
+        /*
+         * Pass 2: Update branch targets.
          */
         InstructionHandle ih = start;
         InstructionHandle ch = il.start;
@@ -1105,11 +1082,10 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return il;
     }
 
-
-    /** Replace all references to the old constant pool with references to the new
-     *  constant pool
+    /**
+     * Replace all references to the old constant pool with references to the new constant pool
      */
-    public void replaceConstantPool( ConstantPoolGen old_cp, ConstantPoolGen new_cp ) {
+    public void replaceConstantPool(ConstantPoolGen old_cp, ConstantPoolGen new_cp) {
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             Instruction i = ih.getInstruction();
             if (i instanceof CPInstruction) {
@@ -1120,30 +1096,26 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
     }
 
-
     private void clear() {
         start = end = null;
         length = 0;
     }
 
-
     /**
-     * Delete contents of list. Provides better memory utilization,
-     * because the system then may reuse the instruction handles. This
-     * method is typically called right after {@link MethodGen#getMethod()}.
+     * Delete contents of list. Provides better memory utilization, because the system then may reuse the instruction handles. This method is typically called
+     * right after {@link MethodGen#getMethod()}.
      */
     public void dispose() {
         // Traverse in reverse order, because ih.next is overwritten
         for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {
-            /* Causes BranchInstructions to release target and targeters, because it
-             * calls dispose() on the contained instruction.
+            /*
+             * Causes BranchInstructions to release target and targeters, because it calls dispose() on the contained instruction.
              */
             ih.dispose();
         }
         clear();
     }
 
-
     /**
      * @return start of list
      */
@@ -1151,7 +1123,6 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return start;
     }
 
-
     /**
      * @return end of list
      */
@@ -1159,7 +1130,6 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return end;
     }
 
-
     /**
      * @return length of list (Number of instructions, not bytes)
      */
@@ -1167,7 +1137,6 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return length;
     }
 
-
     /**
      * @return length of list (Number of instructions, not bytes)
      */
@@ -1175,15 +1144,15 @@ public class InstructionList implements Iterable<InstructionHandle> {
         return length;
     }
 
-
     /**
-     * Redirect all references from old_target to new_target, i.e., update targets 
-     * of branch instructions.
+     * Redirect all references from old_target to new_target, i.e., update targets of branch instructions.
      *
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      */
-    public void redirectBranches( InstructionHandle old_target, InstructionHandle new_target ) {
+    public void redirectBranches(InstructionHandle old_target, InstructionHandle new_target) {
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             Instruction i = ih.getInstruction();
             if (i instanceof BranchInstruction) {
@@ -1204,17 +1173,18 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
     }
 
-
     /**
      * Redirect all references of local variables from old_target to new_target.
      *
-     * @param lg array of local variables
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param lg
+     *            array of local variables
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      * @see MethodGen
      */
-    public void redirectLocalVariables( LocalVariableGen[] lg, InstructionHandle old_target,
-            InstructionHandle new_target ) {
+    public void redirectLocalVariables(LocalVariableGen[] lg, InstructionHandle old_target, InstructionHandle new_target) {
         for (LocalVariableGen element : lg) {
             InstructionHandle start = element.getStart();
             InstructionHandle end = element.getEnd();
@@ -1227,17 +1197,18 @@ public class InstructionList implements Iterable<InstructionHandle> {
         }
     }
 
-
     /**
      * Redirect all references of exception handlers from old_target to new_target.
      *
-     * @param exceptions array of exception handlers
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param exceptions
+     *            array of exception handlers
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      * @see MethodGen
      */
-    public void redirectExceptionHandlers( CodeExceptionGen[] exceptions,
-            InstructionHandle old_target, InstructionHandle new_target ) {
+    public void redirectExceptionHandlers(CodeExceptionGen[] exceptions, InstructionHandle old_target, InstructionHandle new_target) {
         for (CodeExceptionGen exception : exceptions) {
             if (exception.getStartPC() == old_target) {
                 exception.setStartPC(new_target);
@@ -1253,29 +1224,28 @@ public class InstructionList implements Iterable<InstructionHandle> {
 
     private List<InstructionListObserver> observers;
 
-
-    /** Add observer for this object.
+    /**
+     * Add observer for this object.
      */
-    public void addObserver( InstructionListObserver o ) {
+    public void addObserver(InstructionListObserver o) {
         if (observers == null) {
             observers = new ArrayList<>();
         }
         observers.add(o);
     }
 
-
-    /** Remove observer for this object.
+    /**
+     * Remove observer for this object.
      */
-    public void removeObserver( InstructionListObserver o ) {
+    public void removeObserver(InstructionListObserver o) {
         if (observers != null) {
             observers.remove(o);
         }
     }
 
-
-    /** Call notify() method on all observers. This method is not called
-     * automatically whenever the state has changed, but has to be
-     * called by the user after he has finished editing the object.
+    /**
+     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but has to be called by the user after he
+     * has finished editing the object.
      */
     public void update() {
         if (observers != null) {
