diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 83e7bb47..29f7e10b 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -63,6 +63,7 @@ The <action> type attribute can be add,update,fix,remove.
 
   <body>
     <release version="6.0" date="TBA" description="Major release with Java 7 and 8 support">
+      <action issue="BCEL-239" type="fix">Interfaces should not be used to define constants</action>
       <action issue="BCEL-235" type="fix">Remove unused setters</action>
       <action issue="BCEL-232" type="fix">Make mutable fields private</action>
       <action issue="BCEL-233" type="fix">The access_flags field in AccessFlags class should be final</action>
diff --git a/src/main/java/org/apache/commons/bcel6/Constants.java b/src/main/java/org/apache/commons/bcel6/Constants.java
index 1d9916f8..dadbfb51 100644
--- a/src/main/java/org/apache/commons/bcel6/Constants.java
+++ b/src/main/java/org/apache/commons/bcel6/Constants.java
@@ -22,7 +22,7 @@ package org.apache.commons.bcel6;
  *
  * @version $Id$
  */
-public interface Constants {
+public class Constants {
 
   /** Major version number of class files for Java 1.1.
    *  @see #MINOR_1_1
diff --git a/src/main/java/org/apache/commons/bcel6/classfile/AnnotationEntry.java b/src/main/java/org/apache/commons/bcel6/classfile/AnnotationEntry.java
index 0d15914e..ad827ec6 100644
--- a/src/main/java/org/apache/commons/bcel6/classfile/AnnotationEntry.java
+++ b/src/main/java/org/apache/commons/bcel6/classfile/AnnotationEntry.java
@@ -33,7 +33,7 @@ import org.apache.commons.bcel6.Constants;
  * @version $Id: AnnotationEntry
  * @since 6.0
  */
-public class AnnotationEntry implements Node, Constants, Serializable {
+public class AnnotationEntry implements Node, Serializable {
 
     private static final long serialVersionUID = 1L;
 
@@ -43,7 +43,7 @@ public class AnnotationEntry implements Node, Constants, Serializable {
 
     private List<ElementValuePair> element_value_pairs;
 
-    /**
+    /*
      * Factory method to create an AnnotionEntry from a DataInput
      * 
      * @param input
@@ -96,7 +96,7 @@ public class AnnotationEntry implements Node, Constants, Serializable {
      * @return the annotation type name
      */
     public String getAnnotationType() {
-        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(type_index, CONSTANT_Utf8);
+        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(type_index, Constants.CONSTANT_Utf8);
         return c.getBytes();
     }
 
diff --git a/src/main/java/org/apache/commons/bcel6/classfile/CodeException.java b/src/main/java/org/apache/commons/bcel6/classfile/CodeException.java
index 16f63c58..8db6ad4a 100644
--- a/src/main/java/org/apache/commons/bcel6/classfile/CodeException.java
+++ b/src/main/java/org/apache/commons/bcel6/classfile/CodeException.java
@@ -32,7 +32,7 @@ import org.apache.commons.bcel6.Constants;
  * @version $Id$
  * @see     Code
  */
-public final class CodeException implements Cloneable, Constants, Node, Serializable {
+public final class CodeException implements Cloneable, Node, Serializable {
 
     private static final long serialVersionUID = 2972500041254967221L;
     private final int start_pc; // Range in the code the exception handler is
@@ -160,7 +160,7 @@ public final class CodeException implements Cloneable, Constants, Node, Serializ
         if (catch_type == 0) {
             str = "<Any exception>(0)";
         } else {
-            str = Utility.compactClassName(cp.getConstantString(catch_type, CONSTANT_Class), false)
+            str = Utility.compactClassName(cp.getConstantString(catch_type, Constants.CONSTANT_Class), false)
                     + (verbose ? "(" + catch_type + ")" : "");
         }
         return start_pc + "\t" + end_pc + "\t" + handler_pc + "\t" + str;
diff --git a/src/main/java/org/apache/commons/bcel6/classfile/LocalVariable.java b/src/main/java/org/apache/commons/bcel6/classfile/LocalVariable.java
index d75f267c..fdc9ec89 100644
--- a/src/main/java/org/apache/commons/bcel6/classfile/LocalVariable.java
+++ b/src/main/java/org/apache/commons/bcel6/classfile/LocalVariable.java
@@ -31,7 +31,7 @@ import org.apache.commons.bcel6.Constants;
  * @version $Id$
  * @see     LocalVariableTable
  */
-public final class LocalVariable implements Constants, Cloneable, Node, Serializable {
+public final class LocalVariable implements Cloneable, Node, Serializable {
 
     private static final long serialVersionUID = -51081099265972179L;
     private final int start_pc; // Range in which the variable is valid
@@ -132,7 +132,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
      */
     public final String getName() {
         ConstantUtf8 c;
-        c = (ConstantUtf8) constant_pool.getConstant(name_index, CONSTANT_Utf8);
+        c = (ConstantUtf8) constant_pool.getConstant(name_index, Constants.CONSTANT_Utf8);
         return c.getBytes();
     }
 
@@ -150,7 +150,7 @@ public final class LocalVariable implements Constants, Cloneable, Node, Serializ
      */
     public final String getSignature() {
         ConstantUtf8 c;
-        c = (ConstantUtf8) constant_pool.getConstant(signature_index, CONSTANT_Utf8);
+        c = (ConstantUtf8) constant_pool.getConstant(signature_index, Constants.CONSTANT_Utf8);
         return c.getBytes();
     }
 
diff --git a/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java b/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java
index 21acbdbf..c53772be 100644
--- a/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java
+++ b/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java
@@ -24,15 +24,13 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import org.apache.commons.bcel6.Constants;
-
 /**
  * represents one parameter annotation in the parameter annotation table
  *
  * @version $Id: ParameterAnnotationEntry
  * @since 6.0
  */
-public class ParameterAnnotationEntry implements Node, Constants {
+public class ParameterAnnotationEntry implements Node {
 
     private final AnnotationEntry[] annotation_table;
 
diff --git a/src/main/java/org/apache/commons/bcel6/util/AttributeHTML.java b/src/main/java/org/apache/commons/bcel6/util/AttributeHTML.java
index 141106a0..0cab67e0 100644
--- a/src/main/java/org/apache/commons/bcel6/util/AttributeHTML.java
+++ b/src/main/java/org/apache/commons/bcel6/util/AttributeHTML.java
@@ -21,6 +21,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 
+import org.apache.commons.bcel6.Constants;
 import org.apache.commons.bcel6.classfile.Attribute;
 import org.apache.commons.bcel6.classfile.Code;
 import org.apache.commons.bcel6.classfile.CodeException;
@@ -43,7 +44,7 @@ import org.apache.commons.bcel6.classfile.Utility;
  * @version $Id$
  * 
  */
-final class AttributeHTML implements org.apache.commons.bcel6.Constants {
+final class AttributeHTML {
 
     private final String class_name; // name of current class
     private final PrintWriter file; // file to write to
@@ -82,7 +83,7 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
     final void writeAttribute( Attribute attribute, String anchor, int method_number ) {
         byte tag = attribute.getTag();
         int index;
-        if (tag == ATTR_UNKNOWN) {
+        if (tag == Constants.ATTR_UNKNOWN) {
             return;
         }
         attr_count++; // Increment number of attributes found so far
@@ -91,12 +92,12 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
         } else {
             file.print("<TR BGCOLOR=\"#A0A0A0\"><TD>");
         }
-        file.println("<H4><A NAME=\"" + anchor + "\">" + attr_count + " " + ATTRIBUTE_NAMES[tag]
+        file.println("<H4><A NAME=\"" + anchor + "\">" + attr_count + " " + Constants.ATTRIBUTE_NAMES[tag]
                 + "</A></H4>");
         /* Handle different attributes
          */
         switch (tag) {
-            case ATTR_CODE:
+            case Constants.ATTR_CODE:
                 Code c = (Code) attribute;
                 // Some directly printable values
                 file.print("<UL><LI>Maximum stack size = " + c.getMaxStack()
@@ -124,20 +125,20 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
                     file.print("</UL>");
                 }
                 break;
-            case ATTR_CONSTANT_VALUE:
+            case Constants.ATTR_CONSTANT_VALUE:
                 index = ((ConstantValue) attribute).getConstantValueIndex();
                 // Reference _cp.html
                 file.print("<UL><LI><A HREF=\"" + class_name + "_cp.html#cp" + index
                         + "\" TARGET=\"ConstantPool\">Constant value index(" + index
                         + ")</A></UL>\n");
                 break;
-            case ATTR_SOURCE_FILE:
+            case Constants.ATTR_SOURCE_FILE:
                 index = ((SourceFile) attribute).getSourceFileIndex();
                 // Reference _cp.html
                 file.print("<UL><LI><A HREF=\"" + class_name + "_cp.html#cp" + index
                         + "\" TARGET=\"ConstantPool\">Source file index(" + index + ")</A></UL>\n");
                 break;
-            case ATTR_EXCEPTIONS:
+            case Constants.ATTR_EXCEPTIONS:
                 // List thrown exceptions
                 int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();
                 file.print("<UL>");
@@ -148,7 +149,7 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
                 }
                 file.print("</UL>\n");
                 break;
-            case ATTR_LINE_NUMBER_TABLE:
+            case Constants.ATTR_LINE_NUMBER_TABLE:
                 LineNumber[] line_numbers = ((LineNumberTable) attribute).getLineNumberTable();
                 // List line number pairs
                 file.print("<P>");
@@ -160,14 +161,14 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
                     }
                 }
                 break;
-            case ATTR_LOCAL_VARIABLE_TABLE:
+            case Constants.ATTR_LOCAL_VARIABLE_TABLE:
                 LocalVariable[] vars = ((LocalVariableTable) attribute).getLocalVariableTable();
                 // List name, range and type
                 file.print("<UL>");
                 for (LocalVariable var : vars) {
                     index = var.getSignatureIndex();
                     String signature = ((ConstantUtf8) constant_pool.getConstant(index,
-                            CONSTANT_Utf8)).getBytes();
+                            Constants.CONSTANT_Utf8)).getBytes();
                     signature = Utility.signatureToString(signature, false);
                     int start = var.getStartPC();
                     int end = (start + var.getLength());
@@ -180,7 +181,7 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
                 }
                 file.print("</UL>\n");
                 break;
-            case ATTR_INNER_CLASSES:
+            case Constants.ATTR_INNER_CLASSES:
                 InnerClass[] classes = ((InnerClasses) attribute).getInnerClasses();
                 // List inner classes
                 file.print("<UL>");
@@ -188,7 +189,7 @@ final class AttributeHTML implements org.apache.commons.bcel6.Constants {
                     String name, access;
                     index = classe.getInnerNameIndex();
                     if (index > 0) {
-                        name = ((ConstantUtf8) constant_pool.getConstant(index, CONSTANT_Utf8))
+                        name = ((ConstantUtf8) constant_pool.getConstant(index, Constants.CONSTANT_Utf8))
                                 .getBytes();
                     } else {
                         name = "&lt;anonymous&gt;";
diff --git a/src/main/java/org/apache/commons/bcel6/util/Class2HTML.java b/src/main/java/org/apache/commons/bcel6/util/Class2HTML.java
index cbecf232..72949361 100644
--- a/src/main/java/org/apache/commons/bcel6/util/Class2HTML.java
+++ b/src/main/java/org/apache/commons/bcel6/util/Class2HTML.java
@@ -51,7 +51,7 @@ import org.apache.commons.bcel6.classfile.Utility;
  *
  * @version $Id$
  */
-public class Class2HTML implements Constants {
+public class Class2HTML {
 
     private final JavaClass java_class; // current class object
     private final String dir;
@@ -150,7 +150,7 @@ public class Class2HTML implements Constants {
      * i.e., an index to a string.
      */
     static String referenceClass( int index ) {
-        String str = constant_pool.getConstantString(index, CONSTANT_Class);
+        String str = constant_pool.getConstantString(index, Constants.CONSTANT_Class);
         str = Utility.compactClassName(str);
         str = Utility.compactClassName(str, class_package + ".", true);
         return "<A HREF=\"" + class_name + "_cp.html#cp" + index + "\" TARGET=ConstantPool>" + str
diff --git a/src/main/java/org/apache/commons/bcel6/util/CodeHTML.java b/src/main/java/org/apache/commons/bcel6/util/CodeHTML.java
index de107bb6..89d9291b 100644
--- a/src/main/java/org/apache/commons/bcel6/util/CodeHTML.java
+++ b/src/main/java/org/apache/commons/bcel6/util/CodeHTML.java
@@ -22,6 +22,7 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.BitSet;
 
+import org.apache.commons.bcel6.Constants;
 import org.apache.commons.bcel6.classfile.Attribute;
 import org.apache.commons.bcel6.classfile.Code;
 import org.apache.commons.bcel6.classfile.CodeException;
@@ -42,7 +43,7 @@ import org.apache.commons.bcel6.classfile.Utility;
  * @version $Id$
  * 
  */
-final class CodeHTML implements org.apache.commons.bcel6.Constants {
+final class CodeHTML {
 
     private final String class_name; // name of current class
 //    private Method[] methods; // Methods to print
@@ -85,11 +86,11 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
         int[] jump_table;
         int no_pad_bytes = 0, offset;
         buf = new StringBuilder(256);
-        buf.append("<TT>").append(OPCODE_NAMES[opcode]).append("</TT></TD><TD>");
+        buf.append("<TT>").append(Constants.OPCODE_NAMES[opcode]).append("</TT></TD><TD>");
         /* Special case: Skip (0-3) padding bytes, i.e., the
          * following bytes are 4-byte-aligned
          */
-        if ((opcode == TABLESWITCH) || (opcode == LOOKUPSWITCH)) {
+        if ((opcode == Constants.TABLESWITCH) || (opcode == Constants.LOOKUPSWITCH)) {
             int remainder = bytes.getIndex() % 4;
             no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
             for (int i = 0; i < no_pad_bytes; i++) {
@@ -99,7 +100,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
             default_offset = bytes.readInt();
         }
         switch (opcode) {
-            case TABLESWITCH:
+            case Constants.TABLESWITCH:
                 low = bytes.readInt();
                 high = bytes.readInt();
                 offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
@@ -123,7 +124,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 break;
             /* Lookup switch has variable length arguments.
              */
-            case LOOKUPSWITCH:
+            case Constants.LOOKUPSWITCH:
                 int npairs = bytes.readInt();
                 offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
                 jump_table = new int[npairs];
@@ -148,49 +149,49 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
             /* Two address bytes + offset from start of byte stream form the
              * jump target.
              */
-            case GOTO:
-            case IFEQ:
-            case IFGE:
-            case IFGT:
-            case IFLE:
-            case IFLT:
-            case IFNE:
-            case IFNONNULL:
-            case IFNULL:
-            case IF_ACMPEQ:
-            case IF_ACMPNE:
-            case IF_ICMPEQ:
-            case IF_ICMPGE:
-            case IF_ICMPGT:
-            case IF_ICMPLE:
-            case IF_ICMPLT:
-            case IF_ICMPNE:
-            case JSR:
+            case Constants.GOTO:
+            case Constants.IFEQ:
+            case Constants.IFGE:
+            case Constants.IFGT:
+            case Constants.IFLE:
+            case Constants.IFLT:
+            case Constants.IFNE:
+            case Constants.IFNONNULL:
+            case Constants.IFNULL:
+            case Constants.IF_ACMPEQ:
+            case Constants.IF_ACMPNE:
+            case Constants.IF_ICMPEQ:
+            case Constants.IF_ICMPGE:
+            case Constants.IF_ICMPGT:
+            case Constants.IF_ICMPLE:
+            case Constants.IF_ICMPLT:
+            case Constants.IF_ICMPNE:
+            case Constants.JSR:
                 index = (bytes.getIndex() + bytes.readShort() - 1);
                 buf.append("<A HREF=\"#code").append(method_number).append("@").append(index)
                         .append("\">").append(index).append("</A>");
                 break;
             /* Same for 32-bit wide jumps
              */
-            case GOTO_W:
-            case JSR_W:
+            case Constants.GOTO_W:
+            case Constants.JSR_W:
                 int windex = bytes.getIndex() + bytes.readInt() - 1;
                 buf.append("<A HREF=\"#code").append(method_number).append("@").append(windex)
                         .append("\">").append(windex).append("</A>");
                 break;
             /* Index byte references local variable (register)
              */
-            case ALOAD:
-            case ASTORE:
-            case DLOAD:
-            case DSTORE:
-            case FLOAD:
-            case FSTORE:
-            case ILOAD:
-            case ISTORE:
-            case LLOAD:
-            case LSTORE:
-            case RET:
+            case Constants.ALOAD:
+            case Constants.ASTORE:
+            case Constants.DLOAD:
+            case Constants.DSTORE:
+            case Constants.FLOAD:
+            case Constants.FSTORE:
+            case Constants.ILOAD:
+            case Constants.ISTORE:
+            case Constants.LLOAD:
+            case Constants.LSTORE:
+            case Constants.RET:
                 if (wide) {
                     vindex = bytes.readShort();
                     wide = false; // Clear flag
@@ -204,30 +205,30 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
              * following instruction. Relies on that the method is called again with
              * the following opcode.
              */
-            case WIDE:
+            case Constants.WIDE:
                 wide = true;
                 buf.append("(wide)");
                 break;
             /* Array of basic type.
              */
-            case NEWARRAY:
-                buf.append("<FONT COLOR=\"#00FF00\">").append(TYPE_NAMES[bytes.readByte()]).append(
+            case Constants.NEWARRAY:
+                buf.append("<FONT COLOR=\"#00FF00\">").append(Constants.TYPE_NAMES[bytes.readByte()]).append(
                         "</FONT>");
                 break;
             /* Access object/class fields.
              */
-            case GETFIELD:
-            case GETSTATIC:
-            case PUTFIELD:
-            case PUTSTATIC:
+            case Constants.GETFIELD:
+            case Constants.GETSTATIC:
+            case Constants.PUTFIELD:
+            case Constants.PUTSTATIC:
                 index = bytes.readShort();
                 ConstantFieldref c1 = (ConstantFieldref) constant_pool.getConstant(index,
-                        CONSTANT_Fieldref);
+                        Constants.CONSTANT_Fieldref);
                 class_index = c1.getClassIndex();
-                name = constant_pool.getConstantString(class_index, CONSTANT_Class);
+                name = constant_pool.getConstantString(class_index, Constants.CONSTANT_Class);
                 name = Utility.compactClassName(name, false);
                 index = c1.getNameAndTypeIndex();
-                String field_name = constant_pool.constantToString(index, CONSTANT_NameAndType);
+                String field_name = constant_pool.constantToString(index, Constants.CONSTANT_NameAndType);
                 if (name.equals(class_name)) { // Local field
                     buf.append("<A HREF=\"").append(class_name).append("_methods.html#field")
                             .append(field_name).append("\" TARGET=Methods>").append(field_name)
@@ -239,36 +240,36 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 break;
             /* Operands are references to classes in constant pool
              */
-            case CHECKCAST:
-            case INSTANCEOF:
-            case NEW:
+            case Constants.CHECKCAST:
+            case Constants.INSTANCEOF:
+            case Constants.NEW:
                 index = bytes.readShort();
                 buf.append(constant_html.referenceConstant(index));
                 break;
             /* Operands are references to methods in constant pool
              */
-            case INVOKESPECIAL:
-            case INVOKESTATIC:
-            case INVOKEVIRTUAL:
-            case INVOKEINTERFACE:
-            case INVOKEDYNAMIC:
+            case Constants.INVOKESPECIAL:
+            case Constants.INVOKESTATIC:
+            case Constants.INVOKEVIRTUAL:
+            case Constants.INVOKEINTERFACE:
+            case Constants.INVOKEDYNAMIC:
                 int m_index = bytes.readShort();
                 String str;
-                if (opcode == INVOKEINTERFACE) { // Special treatment needed
+                if (opcode == Constants.INVOKEINTERFACE) { // Special treatment needed
                     bytes.readUnsignedByte(); // Redundant
                     bytes.readUnsignedByte(); // Reserved
 //                    int nargs = bytes.readUnsignedByte(); // Redundant
 //                    int reserved = bytes.readUnsignedByte(); // Reserved
                     ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constant_pool
-                            .getConstant(m_index, CONSTANT_InterfaceMethodref);
+                            .getConstant(m_index, Constants.CONSTANT_InterfaceMethodref);
                     class_index = c.getClassIndex();
                     index = c.getNameAndTypeIndex();
                     name = Class2HTML.referenceClass(class_index);
-                } else if (opcode == INVOKEDYNAMIC) { // Special treatment needed
+                } else if (opcode == Constants.INVOKEDYNAMIC) { // Special treatment needed
                     bytes.readUnsignedByte(); // Reserved
                     bytes.readUnsignedByte(); // Reserved
                     ConstantInvokeDynamic c = (ConstantInvokeDynamic) constant_pool
-                            .getConstant(m_index, CONSTANT_InvokeDynamic);
+                            .getConstant(m_index, Constants.CONSTANT_InvokeDynamic);
                     index = c.getNameAndTypeIndex();
                     name = "#" + c.getBootstrapMethodAttrIndex();
                 } else {
@@ -276,17 +277,17 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                     // reference EITHER a Methodref OR an InterfaceMethodref.
                     // Not sure if that affects this code or not.  (markro)
                     ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(m_index,
-                            CONSTANT_Methodref);
+                            Constants.CONSTANT_Methodref);
                     class_index = c.getClassIndex();
                     index = c.getNameAndTypeIndex();
                 name = Class2HTML.referenceClass(class_index);
                 }
                 str = Class2HTML.toHTML(constant_pool.constantToString(constant_pool.getConstant(
-                        index, CONSTANT_NameAndType)));
+                        index, Constants.CONSTANT_NameAndType)));
                 // Get signature, i.e., types
                 ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(index,
-                        CONSTANT_NameAndType);
-                signature = constant_pool.constantToString(c2.getSignatureIndex(), CONSTANT_Utf8);
+                        Constants.CONSTANT_NameAndType);
+                signature = constant_pool.constantToString(c2.getSignatureIndex(), Constants.CONSTANT_Utf8);
                 String[] args = Utility.methodSignatureArgumentTypes(signature, false);
                 String type = Utility.methodSignatureReturnType(signature, false);
                 buf.append(name).append(".<A HREF=\"").append(class_name).append("_cp.html#cp")
@@ -304,15 +305,15 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 break;
             /* Operands are references to items in constant pool
              */
-            case LDC_W:
-            case LDC2_W:
+            case Constants.LDC_W:
+            case Constants.LDC2_W:
                 index = bytes.readShort();
                 buf.append("<A HREF=\"").append(class_name).append("_cp.html#cp").append(index)
                         .append("\" TARGET=\"ConstantPool\">").append(
                                 Class2HTML.toHTML(constant_pool.constantToString(index,
                                         constant_pool.getConstant(index).getTag()))).append("</a>");
                 break;
-            case LDC:
+            case Constants.LDC:
                 index = bytes.readUnsignedByte();
                 buf.append("<A HREF=\"").append(class_name).append("_cp.html#cp").append(index)
                         .append("\" TARGET=\"ConstantPool\">").append(
@@ -321,13 +322,13 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 break;
             /* Array of references.
              */
-            case ANEWARRAY:
+            case Constants.ANEWARRAY:
                 index = bytes.readShort();
                 buf.append(constant_html.referenceConstant(index));
                 break;
             /* Multidimensional array of references.
              */
-            case MULTIANEWARRAY:
+            case Constants.MULTIANEWARRAY:
                 index = bytes.readShort();
                 int dimensions = bytes.readByte();
                 buf.append(constant_html.referenceConstant(index)).append(":").append(dimensions)
@@ -335,7 +336,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 break;
             /* Increment local variable.
              */
-            case IINC:
+            case Constants.IINC:
                 if (wide) {
                     vindex = bytes.readShort();
                     constant = bytes.readShort();
@@ -347,16 +348,16 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                 buf.append("%").append(vindex).append(" ").append(constant);
                 break;
             default:
-                if (NO_OF_OPERANDS[opcode] > 0) {
-                    for (int i = 0; i < TYPE_OF_OPERANDS[opcode].length; i++) {
-                        switch (TYPE_OF_OPERANDS[opcode][i]) {
-                            case T_BYTE:
+                if (Constants.NO_OF_OPERANDS[opcode] > 0) {
+                    for (int i = 0; i < Constants.TYPE_OF_OPERANDS[opcode].length; i++) {
+                        switch (Constants.TYPE_OF_OPERANDS[opcode][i]) {
+                            case Constants.T_BYTE:
                                 buf.append(bytes.readUnsignedByte());
                                 break;
-                            case T_SHORT: // Either branch or index
+                            case Constants.T_SHORT: // Either branch or index
                                 buf.append(bytes.readShort());
                                 break;
-                            case T_INT:
+                            case Constants.T_INT:
                                 buf.append(bytes.readInt());
                                 break;
                             default: // Never reached
@@ -393,7 +394,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
             // Look for local variables and their range
             Attribute[] attributes = code.getAttributes();
             for (Attribute attribute : attributes) {
-                if (attribute.getTag() == ATTR_LOCAL_VARIABLE_TABLE) {
+                if (attribute.getTag() == Constants.ATTR_LOCAL_VARIABLE_TABLE) {
                     LocalVariable[] vars = ((LocalVariableTable) attribute)
                             .getLocalVariableTable();
                     for (LocalVariable var : vars) {
@@ -411,8 +412,8 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
             opcode = bytes.readUnsignedByte();
             //System.out.println(OPCODE_NAMES[opcode]);
             switch (opcode) {
-                case TABLESWITCH:
-                case LOOKUPSWITCH:
+                case Constants.TABLESWITCH:
+                case Constants.LOOKUPSWITCH:
                     //bytes.readByte(); // Skip already read byte
                     int remainder = bytes.getIndex() % 4;
                     int no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
@@ -423,7 +424,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                     }
                     // Both cases have a field default_offset in common
                     default_offset = bytes.readInt();
-                    if (opcode == TABLESWITCH) {
+                    if (opcode == Constants.TABLESWITCH) {
                         int low = bytes.readInt();
                         int high = bytes.readInt();
                         offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
@@ -446,30 +447,30 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                         }
                     }
                     break;
-                case GOTO:
-                case IFEQ:
-                case IFGE:
-                case IFGT:
-                case IFLE:
-                case IFLT:
-                case IFNE:
-                case IFNONNULL:
-                case IFNULL:
-                case IF_ACMPEQ:
-                case IF_ACMPNE:
-                case IF_ICMPEQ:
-                case IF_ICMPGE:
-                case IF_ICMPGT:
-                case IF_ICMPLE:
-                case IF_ICMPLT:
-                case IF_ICMPNE:
-                case JSR:
+                case Constants.GOTO:
+                case Constants.IFEQ:
+                case Constants.IFGE:
+                case Constants.IFGT:
+                case Constants.IFLE:
+                case Constants.IFLT:
+                case Constants.IFNE:
+                case Constants.IFNONNULL:
+                case Constants.IFNULL:
+                case Constants.IF_ACMPEQ:
+                case Constants.IF_ACMPNE:
+                case Constants.IF_ICMPEQ:
+                case Constants.IF_ICMPGE:
+                case Constants.IF_ICMPGT:
+                case Constants.IF_ICMPLE:
+                case Constants.IF_ICMPLT:
+                case Constants.IF_ICMPNE:
+                case Constants.JSR:
                     //bytes.readByte(); // Skip already read byte
                     index = bytes.getIndex() + bytes.readShort() - 1;
                     goto_set.set(index);
                     break;
-                case GOTO_W:
-                case JSR_W:
+                case Constants.GOTO_W:
+                case Constants.JSR_W:
                     //bytes.readByte(); // Skip already read byte
                     index = bytes.getIndex() + bytes.readInt() - 1;
                     goto_set.set(index);
@@ -517,14 +518,14 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
             file.print("<H4>Attributes</H4><UL>\n");
             for (int i = 0; i < attributes.length; i++) {
                 byte tag = attributes[i].getTag();
-                if (tag != ATTR_UNKNOWN) {
+                if (tag != Constants.ATTR_UNKNOWN) {
                     file.print("<LI><A HREF=\"" + class_name + "_attributes.html#method"
                             + method_number + "@" + i + "\" TARGET=Attributes>"
-                            + ATTRIBUTE_NAMES[tag] + "</A></LI>\n");
+                            + Constants.ATTRIBUTE_NAMES[tag] + "</A></LI>\n");
                 } else {
                     file.print("<LI>" + attributes[i] + "</LI>");
                 }
-                if (tag == ATTR_CODE) {
+                if (tag == Constants.ATTR_CODE) {
                     c = (Code) attributes[i];
                     Attribute[] attributes2 = c.getAttributes();
                     code = c.getCode();
@@ -533,7 +534,7 @@ final class CodeHTML implements org.apache.commons.bcel6.Constants {
                         tag = attributes2[j].getTag();
                         file.print("<LI><A HREF=\"" + class_name + "_attributes.html#" + "method"
                                 + method_number + "@" + i + "@" + j + "\" TARGET=Attributes>"
-                                + ATTRIBUTE_NAMES[tag] + "</A></LI>\n");
+                                + Constants.ATTRIBUTE_NAMES[tag] + "</A></LI>\n");
                     }
                     file.print("</UL>");
                 }
diff --git a/src/main/java/org/apache/commons/bcel6/util/ConstantHTML.java b/src/main/java/org/apache/commons/bcel6/util/ConstantHTML.java
index c2098bf8..c7fd6ba0 100644
--- a/src/main/java/org/apache/commons/bcel6/util/ConstantHTML.java
+++ b/src/main/java/org/apache/commons/bcel6/util/ConstantHTML.java
@@ -21,6 +21,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 
+import org.apache.commons.bcel6.Constants;
 import org.apache.commons.bcel6.classfile.Constant;
 import org.apache.commons.bcel6.classfile.ConstantClass;
 import org.apache.commons.bcel6.classfile.ConstantFieldref;
@@ -38,7 +39,7 @@ import org.apache.commons.bcel6.classfile.Utility;
  * @version $Id$
  * 
  */
-final class ConstantHTML implements org.apache.commons.bcel6.Constants {
+final class ConstantHTML {
 
     private final String class_name; // name of current class
     private final String class_package; // name of package
@@ -87,39 +88,39 @@ final class ConstantHTML implements org.apache.commons.bcel6.Constants {
         int class_index, name_index;
         String ref;
         // The header is always the same
-        file.println("<H4> <A NAME=cp" + index + ">" + index + "</A> " + CONSTANT_NAMES[tag]
+        file.println("<H4> <A NAME=cp" + index + ">" + index + "</A> " + Constants.CONSTANT_NAMES[tag]
                 + "</H4>");
         /* For every constant type get the needed parameters and print them appropiately 
          */
         switch (tag) {
-            case CONSTANT_InterfaceMethodref:
-            case CONSTANT_Methodref:
+            case Constants.CONSTANT_InterfaceMethodref:
+            case Constants.CONSTANT_Methodref:
                 // Get class_index and name_and_type_index, depending on type
-                if (tag == CONSTANT_Methodref) {
+                if (tag == Constants.CONSTANT_Methodref) {
                     ConstantMethodref c = (ConstantMethodref) constant_pool.getConstant(index,
-                            CONSTANT_Methodref);
+                            Constants.CONSTANT_Methodref);
                     class_index = c.getClassIndex();
                     name_index = c.getNameAndTypeIndex();
                 } else {
                     ConstantInterfaceMethodref c1 = (ConstantInterfaceMethodref) constant_pool
-                            .getConstant(index, CONSTANT_InterfaceMethodref);
+                            .getConstant(index, Constants.CONSTANT_InterfaceMethodref);
                     class_index = c1.getClassIndex();
                     name_index = c1.getNameAndTypeIndex();
                 }
                 // Get method name and its class
                 String method_name = constant_pool.constantToString(name_index,
-                        CONSTANT_NameAndType);
+                        Constants.CONSTANT_NameAndType);
                 String html_method_name = Class2HTML.toHTML(method_name);
                 // Partially compacted class name, i.e., / -> .
-                String method_class = constant_pool.constantToString(class_index, CONSTANT_Class);
+                String method_class = constant_pool.constantToString(class_index, Constants.CONSTANT_Class);
                 String short_method_class = Utility.compactClassName(method_class); // I.e., remove java.lang.
                 short_method_class = Utility.compactClassName(short_method_class, class_package
                         + ".", true); // Remove class package prefix
                 // Get method signature
                 ConstantNameAndType c2 = (ConstantNameAndType) constant_pool.getConstant(
-                        name_index, CONSTANT_NameAndType);
+                        name_index, Constants.CONSTANT_NameAndType);
                 String signature = constant_pool.constantToString(c2.getSignatureIndex(),
-                        CONSTANT_Utf8);
+                        Constants.CONSTANT_Utf8);
                 // Get array of strings containing the argument types
                 String[] args = Utility.methodSignatureArgumentTypes(signature, false);
                 // Get return type string
@@ -151,19 +152,19 @@ final class ConstantHTML implements org.apache.commons.bcel6.Constants {
                         + "\">Class index(" + class_index + ")</A>\n" + "<LI><A HREF=\"#cp"
                         + name_index + "\">NameAndType index(" + name_index + ")</A></UL>");
                 break;
-            case CONSTANT_Fieldref:
+            case Constants.CONSTANT_Fieldref:
                 // Get class_index and name_and_type_index
                 ConstantFieldref c3 = (ConstantFieldref) constant_pool.getConstant(index,
-                        CONSTANT_Fieldref);
+                        Constants.CONSTANT_Fieldref);
                 class_index = c3.getClassIndex();
                 name_index = c3.getNameAndTypeIndex();
                 // Get method name and its class (compacted)
-                String field_class = constant_pool.constantToString(class_index, CONSTANT_Class);
+                String field_class = constant_pool.constantToString(class_index, Constants.CONSTANT_Class);
                 String short_field_class = Utility.compactClassName(field_class); // I.e., remove java.lang.
                 short_field_class = Utility.compactClassName(short_field_class,
                         class_package + ".", true); // Remove class package prefix
                 String field_name = constant_pool
-                        .constantToString(name_index, CONSTANT_NameAndType);
+                        .constantToString(name_index, Constants.CONSTANT_NameAndType);
                 if (field_class.equals(class_name)) {
                     ref = "<A HREF=\"" + field_class + "_methods.html#field" + field_name
                             + "\" TARGET=Methods>" + field_name + "</A>";
@@ -180,8 +181,8 @@ final class ConstantHTML implements org.apache.commons.bcel6.Constants {
                         + "<LI><A HREF=\"#cp" + name_index + "\">NameAndType(" + name_index
                         + ")</A></UL>");
                 break;
-            case CONSTANT_Class:
-                ConstantClass c4 = (ConstantClass) constant_pool.getConstant(index, CONSTANT_Class);
+            case Constants.CONSTANT_Class:
+                ConstantClass c4 = (ConstantClass) constant_pool.getConstant(index, Constants.CONSTANT_Class);
                 name_index = c4.getNameIndex();
                 String class_name2 = constant_pool.constantToString(index, tag); // / -> .
                 String short_class_name = Utility.compactClassName(class_name2); // I.e., remove java.lang.
@@ -194,17 +195,17 @@ final class ConstantHTML implements org.apache.commons.bcel6.Constants {
                 file.println("<P><TT>" + ref + "</TT><UL>" + "<LI><A HREF=\"#cp" + name_index
                         + "\">Name index(" + name_index + ")</A></UL>\n");
                 break;
-            case CONSTANT_String:
+            case Constants.CONSTANT_String:
                 ConstantString c5 = (ConstantString) constant_pool.getConstant(index,
-                        CONSTANT_String);
+                        Constants.CONSTANT_String);
                 name_index = c5.getStringIndex();
                 String str = Class2HTML.toHTML(constant_pool.constantToString(index, tag));
                 file.println("<P><TT>" + str + "</TT><UL>" + "<LI><A HREF=\"#cp" + name_index
                         + "\">Name index(" + name_index + ")</A></UL>\n");
                 break;
-            case CONSTANT_NameAndType:
+            case Constants.CONSTANT_NameAndType:
                 ConstantNameAndType c6 = (ConstantNameAndType) constant_pool.getConstant(index,
-                        CONSTANT_NameAndType);
+                        Constants.CONSTANT_NameAndType);
                 name_index = c6.getNameIndex();
                 int signature_index = c6.getSignatureIndex();
                 file.println("<P><TT>"
diff --git a/src/main/java/org/apache/commons/bcel6/util/MethodHTML.java b/src/main/java/org/apache/commons/bcel6/util/MethodHTML.java
index c82a022e..b1f67949 100644
--- a/src/main/java/org/apache/commons/bcel6/util/MethodHTML.java
+++ b/src/main/java/org/apache/commons/bcel6/util/MethodHTML.java
@@ -21,6 +21,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 
+import org.apache.commons.bcel6.Constants;
 import org.apache.commons.bcel6.classfile.Attribute;
 import org.apache.commons.bcel6.classfile.Code;
 import org.apache.commons.bcel6.classfile.ConstantValue;
@@ -35,7 +36,7 @@ import org.apache.commons.bcel6.classfile.Utility;
  * @version $Id$
  * 
  */
-final class MethodHTML implements org.apache.commons.bcel6.Constants {
+final class MethodHTML {
 
     private final String class_name; // name of current class
     private final PrintWriter file; // file to write to
@@ -88,7 +89,7 @@ final class MethodHTML implements org.apache.commons.bcel6.Constants {
             attribute_html.writeAttribute(attributes[i], name + "@" + i);
         }
         for (int i = 0; i < attributes.length; i++) {
-            if (attributes[i].getTag() == ATTR_CONSTANT_VALUE) { // Default value
+            if (attributes[i].getTag() == Constants.ATTR_CONSTANT_VALUE) { // Default value
                 String str = ((ConstantValue) attributes[i]).toString();
                 // Reference attribute in _attributes.html
                 file.print("<TD>= <A HREF=\"" + class_name + "_attributes.html#" + name + "@" + i
@@ -135,7 +136,7 @@ final class MethodHTML implements org.apache.commons.bcel6.Constants {
             attribute_html.writeAttribute(attributes[i], "method" + method_number + "@" + i,
                     method_number);
             byte tag = attributes[i].getTag();
-            if (tag == ATTR_EXCEPTIONS) {
+            if (tag == Constants.ATTR_EXCEPTIONS) {
                 file.print("<TR VALIGN=TOP><TD COLSPAN=2></TD><TH ALIGN=LEFT>throws</TH><TD>");
                 int[] exceptions = ((ExceptionTable) attributes[i]).getExceptionIndexTable();
                 for (int j = 0; j < exceptions.length; j++) {
@@ -145,7 +146,7 @@ final class MethodHTML implements org.apache.commons.bcel6.Constants {
                     }
                 }
                 file.println("</TD></TR>");
-            } else if (tag == ATTR_CODE) {
+            } else if (tag == Constants.ATTR_CODE) {
                 Attribute[] c_a = ((Code) attributes[i]).getAttributes();
                 for (int j = 0; j < c_a.length; j++) {
                     attribute_html.writeAttribute(c_a[j], "method" + method_number + "@" + i + "@"
diff --git a/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass2Verifier.java b/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass2Verifier.java
index 80ba973b..8bdf808a 100644
--- a/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass2Verifier.java
+++ b/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass2Verifier.java
@@ -19,6 +19,7 @@ package org.apache.commons.bcel6.verifier.statics;
 
 
 import java.util.HashMap;
+
 import java.util.HashSet;
 import java.util.Locale;
 import java.util.Map;
@@ -82,7 +83,7 @@ import org.apache.commons.bcel6.verifier.exc.LocalVariableInfoInconsistentExcept
  * @version $Id$
  * @see #do_verify()
  */
-public final class Pass2Verifier extends PassVerifier implements Constants{
+public final class Pass2Verifier extends PassVerifier {
 
     /**
      * The LocalVariableInfo instances used by Pass3bVerifier.
@@ -537,7 +538,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
                 }
             }
 
-            if ((obj.getAccessFlags() & ~(ACC_PUBLIC|ACC_PRIVATE|ACC_PROTECTED|ACC_STATIC|ACC_FINAL|ACC_VOLATILE|ACC_TRANSIENT)) > 0){
+            if ((obj.getAccessFlags() & ~(Constants.ACC_PUBLIC|Constants.ACC_PRIVATE|Constants.ACC_PROTECTED|Constants.ACC_STATIC|Constants.ACC_FINAL|Constants.ACC_VOLATILE|Constants.ACC_TRANSIENT)) > 0){
                 addMessage("Field '"+tostring(obj)+"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored).");
             }
 
@@ -638,7 +639,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
             }
 
             // Nearly forgot this! Funny return values are allowed, but a non-empty arguments list makes a different method out of it!
-            if (name.equals(STATIC_INITIALIZER_NAME) && (ts.length != 0)){
+            if (name.equals(Constants.STATIC_INITIALIZER_NAME) && (ts.length != 0)){
                 throw new ClassConstraintException("Method '"+tostring(obj)+"' has illegal name '"+name+"'. It's name resembles the class or interface initialization method which it isn't because of its arguments (==descriptor).");
             }
 
@@ -679,7 +680,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
                 }
 
                 // A specific instance initialization method... (vmspec2,Page 116).
-                if (name.equals(CONSTRUCTOR_NAME)) {
+                if (name.equals(Constants.CONSTRUCTOR_NAME)) {
                     //..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
                     //..may also have ACC_STRICT set, but none of the other flags in table 4.5 (vmspec2, page 115)
                     if (obj.isStatic() ||
@@ -692,8 +693,8 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
                 }
             }
             else{ // isInterface!
-                if (!name.equals(STATIC_INITIALIZER_NAME)){//vmspec2, p.116, 2nd paragraph
-                    if (jc.getMajor() >= MAJOR_1_8) {
+                if (!name.equals(Constants.STATIC_INITIALIZER_NAME)){//vmspec2, p.116, 2nd paragraph
+                    if (jc.getMajor() >= Constants.MAJOR_1_8) {
                         if (!(obj.isPublic() ^ obj.isPrivate())) {
                             throw new ClassConstraintException("Interface method '" + tostring(obj) + "' must have exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set.");
                         }
@@ -724,7 +725,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
                 }
             }
 
-            if ((obj.getAccessFlags() & ~(ACC_PUBLIC|ACC_PRIVATE|ACC_PROTECTED|ACC_STATIC|ACC_FINAL|ACC_SYNCHRONIZED|ACC_NATIVE|ACC_ABSTRACT|ACC_STRICT)) > 0){
+            if ((obj.getAccessFlags() & ~(Constants.ACC_PUBLIC|Constants.ACC_PRIVATE|Constants.ACC_PROTECTED|Constants.ACC_STATIC|Constants.ACC_FINAL|Constants.ACC_SYNCHRONIZED|Constants.ACC_NATIVE|Constants.ACC_ABSTRACT|Constants.ACC_STRICT)) > 0){
                 addMessage("Method '"+tostring(obj)+"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored).");
             }
 
@@ -827,7 +828,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
                     checkIndex(obj, innername_idx, CONST_Utf8);
                 }
                 int acc = ic.getInnerAccessFlags();
-                acc = acc & (~ (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT));
+                acc = acc & (~ (Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED | Constants.ACC_STATIC | Constants.ACC_FINAL | Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT));
                 if (acc != 0){
                     addMessage("Unknown access flag for inner class '"+tostring(ic)+"' set (InnerClasses attribute '"+tostring(obj)+"').");
                 }
@@ -1263,7 +1264,7 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
 
             try{
                 Type   t  = Type.getReturnType(sig);
-                if ( name.equals(CONSTRUCTOR_NAME) && (t != Type.VOID) ){
+                if ( name.equals(Constants.CONSTRUCTOR_NAME) && (t != Type.VOID) ){
                     throw new ClassConstraintException("Instance initialization method must have VOID return type.");
                 }
             }
@@ -1295,8 +1296,8 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
 
             try{
                 Type   t  = Type.getReturnType(sig);
-                if ( name.equals(STATIC_INITIALIZER_NAME) && (t != Type.VOID) ){
-                    addMessage("Class or interface initialization method '"+STATIC_INITIALIZER_NAME+"' usually has VOID return type instead of '"+t+"'. Note this is really not a requirement of The Java Virtual Machine Specification, Second Edition.");
+                if ( name.equals(Constants.STATIC_INITIALIZER_NAME) && (t != Type.VOID) ){
+                    addMessage("Class or interface initialization method '"+Constants.STATIC_INITIALIZER_NAME+"' usually has VOID return type instead of '"+t+"'. Note this is really not a requirement of The Java Virtual Machine Specification, Second Edition.");
                 }
             }
             catch (ClassFormatException cfe){
@@ -1332,10 +1333,10 @@ public final class Pass2Verifier extends PassVerifier implements Constants{
         }
 
         if (allowStaticInit){
-            return (name.equals(CONSTRUCTOR_NAME) || name.equals(STATIC_INITIALIZER_NAME));
+            return (name.equals(Constants.CONSTRUCTOR_NAME) || name.equals(Constants.STATIC_INITIALIZER_NAME));
         }
         else{
-            return name.equals(CONSTRUCTOR_NAME);
+            return name.equals(Constants.CONSTRUCTOR_NAME);
         }
     }
 
diff --git a/src/main/java/org/apache/commons/bcel6/verifier/structurals/UninitializedObjectType.java b/src/main/java/org/apache/commons/bcel6/verifier/structurals/UninitializedObjectType.java
index 7f5a3825..156d2f0a 100644
--- a/src/main/java/org/apache/commons/bcel6/verifier/structurals/UninitializedObjectType.java
+++ b/src/main/java/org/apache/commons/bcel6/verifier/structurals/UninitializedObjectType.java
@@ -29,7 +29,7 @@ import org.apache.commons.bcel6.generic.ReferenceType;
  *
  * @version $Id$
  */
-public class UninitializedObjectType extends ReferenceType implements Constants{
+public class UninitializedObjectType extends ReferenceType{
 
     private static final long serialVersionUID = -1228341777713117641L;
     /** The "initialized" version. */
@@ -37,7 +37,7 @@ public class UninitializedObjectType extends ReferenceType implements Constants{
 
     /** Creates a new instance. */
     public UninitializedObjectType(ObjectType t){
-        super(T_UNKNOWN, "<UNINITIALIZED OBJECT OF TYPE '"+t.getClassName()+"'>");
+        super(Constants.T_UNKNOWN, "<UNINITIALIZED OBJECT OF TYPE '"+t.getClassName()+"'>");
         initialized = t;
     }
 
diff --git a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess02Creator.java b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess02Creator.java
index 23a16b4a..e4f3c739 100644
--- a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess02Creator.java
+++ b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess02Creator.java
@@ -33,13 +33,13 @@ import org.apache.commons.bcel6.generic.PUSH;
 import org.apache.commons.bcel6.generic.Type;
 import org.junit.Assert;
 
-public class TestArrayAccess02Creator extends TestCreator implements Constants {
+public class TestArrayAccess02Creator extends TestCreator {
   private InstructionFactory _factory;
   private ConstantPoolGen    _cp;
   private ClassGen           _cg;
 
   public TestArrayAccess02Creator() {
-    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", "java.lang.Object", "TestArrayAccess02.java", ACC_PUBLIC | ACC_SUPER, new String[] {  });
+    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", "java.lang.Object", "TestArrayAccess02.java", Constants.ACC_PUBLIC | Constants.ACC_SUPER, new String[] {  });
 
     _cp = _cg.getConstantPool();
     _factory = new InstructionFactory(_cg, _cp);
@@ -53,7 +53,7 @@ public class TestArrayAccess02Creator extends TestCreator implements Constants {
 
   private void createMethod_0() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionFactory.createLoad(Type.OBJECT, 0));
     Assert.assertNotNull(ih_0); // TODO why is this not used
@@ -68,7 +68,7 @@ public class TestArrayAccess02Creator extends TestCreator implements Constants {
 
   private void createMethod_1() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC | ACC_STATIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess02", il, _cp);
 
     InstructionHandle ih_0 = il.append(new PUSH(_cp, 1));
     Assert.assertNotNull(ih_0); // TODO why is this not used
diff --git a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess03Creator.java b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess03Creator.java
index 16cdabc4..2f7ca304 100644
--- a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess03Creator.java
+++ b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess03Creator.java
@@ -33,13 +33,13 @@ import org.apache.commons.bcel6.generic.PUSH;
 import org.apache.commons.bcel6.generic.Type;
 import org.junit.Assert;
 
-public class TestArrayAccess03Creator extends TestCreator implements Constants {
+public class TestArrayAccess03Creator extends TestCreator {
   private InstructionFactory _factory;
   private ConstantPoolGen    _cp;
   private ClassGen           _cg;
 
   public TestArrayAccess03Creator() {
-    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", "java.lang.Object", "TestArrayAccess03.java", ACC_PUBLIC | ACC_SUPER, new String[] {  });
+    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", "java.lang.Object", "TestArrayAccess03.java", Constants.ACC_PUBLIC | Constants.ACC_SUPER, new String[] {  });
 
     _cp = _cg.getConstantPool();
     _factory = new InstructionFactory(_cg, _cp);
@@ -53,7 +53,7 @@ public class TestArrayAccess03Creator extends TestCreator implements Constants {
 
   private void createMethod_0() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionFactory.createLoad(Type.OBJECT, 0));
     Assert.assertNotNull(ih_0); // TODO why is this not used
@@ -68,7 +68,7 @@ public class TestArrayAccess03Creator extends TestCreator implements Constants {
 
   private void createMethod_1() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC | ACC_STATIC, Type.VOID, new Type[] { Type.OBJECT }, new String[] { "arg0" }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC, Type.VOID, new Type[] { Type.OBJECT }, new String[] { "arg0" }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess03", il, _cp);
 
     InstructionHandle ih_0 = il.append(new PUSH(_cp, 1));
     Assert.assertNotNull(ih_0); // TODO why is this not used
diff --git a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess04Creator.java b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess04Creator.java
index b94f1c98..e64fa6f3 100644
--- a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess04Creator.java
+++ b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess04Creator.java
@@ -31,13 +31,13 @@ import org.apache.commons.bcel6.generic.PUSH;
 import org.apache.commons.bcel6.generic.Type;
 import org.junit.Assert;
 
-public class TestArrayAccess04Creator extends TestCreator implements Constants {
+public class TestArrayAccess04Creator extends TestCreator {
   private InstructionFactory _factory;
   private ConstantPoolGen    _cp;
   private ClassGen           _cg;
 
   public TestArrayAccess04Creator() {
-    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", "java.lang.Object", "TestArrayAccess04.java", ACC_PUBLIC | ACC_SUPER, new String[] {  });
+    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", "java.lang.Object", "TestArrayAccess04.java", Constants.ACC_PUBLIC | Constants.ACC_SUPER, new String[] {  });
 
     _cp = _cg.getConstantPool();
     _factory = new InstructionFactory(_cg, _cp);
@@ -51,7 +51,7 @@ public class TestArrayAccess04Creator extends TestCreator implements Constants {
 
   private void createMethod_0() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionFactory.createLoad(Type.OBJECT, 0));
     Assert.assertNotNull(ih_0); // TODO why is this not used
@@ -66,7 +66,7 @@ public class TestArrayAccess04Creator extends TestCreator implements Constants {
 
   private void createMethod_1() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC | ACC_STATIC, Type.VOID, new Type[] { Type.OBJECT }, new String[] { "arg0" }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC, Type.VOID, new Type[] { Type.OBJECT }, new String[] { "arg0" }, "test", "org.apache.commons.bcel6.verifier.tests.TestArrayAccess04", il, _cp);
 
     InstructionHandle ih_0 = il.append(new PUSH(_cp, 1));
     Assert.assertNotNull(ih_0); // TODO why is this not used
diff --git a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn01Creator.java b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn01Creator.java
index 1cdf82a5..5505a495 100644
--- a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn01Creator.java
+++ b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn01Creator.java
@@ -31,13 +31,13 @@ import org.apache.commons.bcel6.generic.MethodGen;
 import org.apache.commons.bcel6.generic.Type;
 import org.junit.Assert;
 
-public class TestReturn01Creator extends TestCreator implements Constants {
+public class TestReturn01Creator extends TestCreator {
   private InstructionFactory _factory;
   private ConstantPoolGen    _cp;
   private ClassGen           _cg;
 
   public TestReturn01Creator() {
-    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestReturn01", "java.lang.Object", "TestReturn01.java", ACC_PUBLIC | ACC_SUPER, new String[] {  });
+    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestReturn01", "java.lang.Object", "TestReturn01.java", Constants.ACC_PUBLIC | Constants.ACC_SUPER, new String[] {  });
 
     _cp = _cg.getConstantPool();
     _factory = new InstructionFactory(_cg, _cp);
@@ -51,7 +51,7 @@ public class TestReturn01Creator extends TestCreator implements Constants {
 
   private void createMethod_0() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestReturn01", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestReturn01", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionFactory.createLoad(Type.OBJECT, 0));
     Assert.assertNotNull(ih_0); // TODO why is this not used
@@ -66,7 +66,7 @@ public class TestReturn01Creator extends TestCreator implements Constants {
 
   private void createMethod_1() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC | ACC_STATIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "foo", "org.apache.commons.bcel6.verifier.tests.TestReturn01", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "foo", "org.apache.commons.bcel6.verifier.tests.TestReturn01", il, _cp);
 
     InstructionHandle ih_0 = il.append(_factory.createNew("java.lang.Object"));
     Assert.assertNotNull(ih_0); // TODO why is this not used
diff --git a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn03Creator.java b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn03Creator.java
index d3d59fc8..2f651087 100644
--- a/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn03Creator.java
+++ b/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn03Creator.java
@@ -31,13 +31,13 @@ import org.apache.commons.bcel6.generic.MethodGen;
 import org.apache.commons.bcel6.generic.Type;
 import org.junit.Assert;
 
-public class TestReturn03Creator extends TestCreator implements Constants {
+public class TestReturn03Creator extends TestCreator {
   private InstructionFactory _factory;
   private ConstantPoolGen    _cp;
   private ClassGen           _cg;
 
   public TestReturn03Creator() {
-    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestReturn03", "java.lang.Object", "TestReturn03.java", ACC_PUBLIC | ACC_SUPER, new String[] {  });
+    _cg = new ClassGen("org.apache.commons.bcel6.verifier.tests.TestReturn03", "java.lang.Object", "TestReturn03.java", Constants.ACC_PUBLIC | Constants.ACC_SUPER, new String[] {  });
 
     _cp = _cg.getConstantPool();
     _factory = new InstructionFactory(_cg, _cp);
@@ -51,7 +51,7 @@ public class TestReturn03Creator extends TestCreator implements Constants {
 
   private void createMethod_0() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestReturn03", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[] {  }, "<init>", "org.apache.commons.bcel6.verifier.tests.TestReturn03", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionFactory.createLoad(Type.OBJECT, 0));
     Assert.assertNotNull(ih_0); // TODO why is this not used
@@ -66,7 +66,7 @@ public class TestReturn03Creator extends TestCreator implements Constants {
 
   private void createMethod_1() {
     InstructionList il = new InstructionList();
-    MethodGen method = new MethodGen(ACC_PUBLIC | ACC_STATIC, Type.INT, Type.NO_ARGS, new String[] {  }, "test3", "org.apache.commons.bcel6.verifier.tests.TestReturn03", il, _cp);
+    MethodGen method = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC, Type.INT, Type.NO_ARGS, new String[] {  }, "test3", "org.apache.commons.bcel6.verifier.tests.TestReturn03", il, _cp);
 
     InstructionHandle ih_0 = il.append(InstructionConstants.ACONST_NULL);
     Assert.assertNotNull(ih_0); // TODO why is this not used
