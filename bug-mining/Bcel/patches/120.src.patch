diff --git a/pom.xml b/pom.xml
index e81d84a3..e830ae43 100644
--- a/pom.xml
+++ b/pom.xml
@@ -63,6 +63,8 @@
     <commons.osgi.private />
     <commons.jira.id>BCEL</commons.jira.id>
     <commons.jira.pid>12314220</commons.jira.pid>
+    <mockito.version>4.8.1</mockito.version>
+    <assertj.version>3.25.1</assertj.version>
     <jna.version>5.14.0</jna.version>
     <japicmp.skip>false</japicmp.skip>
   </properties>
@@ -450,6 +452,18 @@
       <artifactId>junit-jupiter</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <version>${mockito.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <version>${assertj.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>net.java.dev.jna</groupId>
       <artifactId>jna</artifactId>
diff --git a/src/main/java/org/apache/bcel/generic/LDC.java b/src/main/java/org/apache/bcel/generic/LDC.java
index 5969b157..559d1108 100644
--- a/src/main/java/org/apache/bcel/generic/LDC.java
+++ b/src/main/java/org/apache/bcel/generic/LDC.java
@@ -89,6 +89,8 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
             return Type.INT;
         case org.apache.bcel.Const.CONSTANT_Class:
             return Type.CLASS;
+        case org.apache.bcel.Const.CONSTANT_Dynamic:
+            return Type.OBJECT;
         default: // Never reached
             throw new IllegalArgumentException("Unknown or invalid constant type at " + super.getIndex());
         }
@@ -109,6 +111,9 @@ public class LDC extends CPInstruction implements PushInstruction, ExceptionThro
             final int nameIndex = ((org.apache.bcel.classfile.ConstantClass) c).getNameIndex();
             c = cpg.getConstantPool().getConstant(nameIndex);
             return Type.getType(Type.internalTypeNameToSignature(((org.apache.bcel.classfile.ConstantUtf8) c).getBytes()));
+        case org.apache.bcel.Const.CONSTANT_Dynamic:
+            // Really not sure what to return here, maybe a BootstrapMethod instance but how do we get it?
+            return c;
         default: // Never reached
             throw new IllegalArgumentException("Unknown or invalid constant type at " + super.getIndex());
         }
diff --git a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
index 3764ebae..25def60f 100644
--- a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
+++ b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
@@ -28,6 +28,7 @@ import org.apache.bcel.classfile.Constant;
 import org.apache.bcel.classfile.ConstantCP;
 import org.apache.bcel.classfile.ConstantClass;
 import org.apache.bcel.classfile.ConstantDouble;
+import org.apache.bcel.classfile.ConstantDynamic;
 import org.apache.bcel.classfile.ConstantFieldref;
 import org.apache.bcel.classfile.ConstantFloat;
 import org.apache.bcel.classfile.ConstantInteger;
@@ -651,9 +652,10 @@ public final class Pass3aVerifier extends PassVerifier {
             final Constant c = constantPoolGen.getConstant(ldc.getIndex());
             if (c instanceof ConstantClass) {
                 addMessage("Operand of LDC or LDC_W is CONSTANT_Class '" + tostring(c) + "' - this is only supported in JDK 1.5 and higher.");
-            } else if (!(c instanceof ConstantInteger || c instanceof ConstantFloat || c instanceof ConstantString)) {
+            } else if (!(c instanceof ConstantInteger || c instanceof ConstantFloat || c instanceof ConstantString || c instanceof ConstantDynamic)) {
                 constraintViolated(ldc,
-                    "Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float or CONSTANT_String, but is '" + tostring(c) + "'.");
+                    "Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float, CONSTANT_String or CONSTANT_Dynamic but is '"
+                            + tostring(c) + "'.");
             }
         }
 
diff --git a/src/main/java/org/apache/bcel/verifier/structurals/ExecutionVisitor.java b/src/main/java/org/apache/bcel/verifier/structurals/ExecutionVisitor.java
index 36c9af0c..d0666558 100644
--- a/src/main/java/org/apache/bcel/verifier/structurals/ExecutionVisitor.java
+++ b/src/main/java/org/apache/bcel/verifier/structurals/ExecutionVisitor.java
@@ -20,6 +20,7 @@ import org.apache.bcel.Const;
 import org.apache.bcel.classfile.Constant;
 import org.apache.bcel.classfile.ConstantClass;
 import org.apache.bcel.classfile.ConstantDouble;
+import org.apache.bcel.classfile.ConstantDynamic;
 import org.apache.bcel.classfile.ConstantFloat;
 import org.apache.bcel.classfile.ConstantInteger;
 import org.apache.bcel.classfile.ConstantLong;
@@ -1054,6 +1055,9 @@ public class ExecutionVisitor extends EmptyVisitor {
         if (c instanceof ConstantClass) {
             stack().push(Type.CLASS);
         }
+        if (c instanceof ConstantDynamic) {
+            stack().push(Type.OBJECT);
+        }
     }
 
     /** Symbolically executes the corresponding Java Virtual Machine instruction. */
diff --git a/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java b/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
index e41051b8..0b637e6d 100644
--- a/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
+++ b/src/main/java/org/apache/bcel/verifier/structurals/InstConstraintVisitor.java
@@ -21,6 +21,7 @@ import org.apache.bcel.Repository;
 import org.apache.bcel.classfile.Constant;
 import org.apache.bcel.classfile.ConstantClass;
 import org.apache.bcel.classfile.ConstantDouble;
+import org.apache.bcel.classfile.ConstantDynamic;
 import org.apache.bcel.classfile.ConstantFieldref;
 import org.apache.bcel.classfile.ConstantFloat;
 import org.apache.bcel.classfile.ConstantInteger;
@@ -2030,9 +2031,14 @@ public class InstConstraintVisitor extends EmptyVisitor {
         // visitCPInstruction is called first.
 
         final Constant c = cpg.getConstant(o.getIndex());
-        if (!(c instanceof ConstantInteger || c instanceof ConstantFloat || c instanceof ConstantString || c instanceof ConstantClass)) {
+        if (!(c instanceof ConstantInteger
+                || c instanceof ConstantFloat
+                || c instanceof ConstantString
+                || c instanceof ConstantClass
+                || c instanceof ConstantDynamic)) {
             constraintViolated(o,
-                "Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String or a CONSTANT_Class, but is '" + c + "'.");
+                "Referenced constant should be a CONSTANT_Integer, a CONSTANT_Float, a CONSTANT_String, a CONSTANT_Class, or a CONSTANT_Dynamic but is '"
+                        + c + "'.");
         }
     }
 
diff --git a/src/test/java/org/apache/bcel/classfile/ConstantPoolModuleToStringTestCase.java b/src/test/java/org/apache/bcel/classfile/ConstantPoolModuleToStringTestCase.java
index b482efe0..8048b705 100644
--- a/src/test/java/org/apache/bcel/classfile/ConstantPoolModuleToStringTestCase.java
+++ b/src/test/java/org/apache/bcel/classfile/ConstantPoolModuleToStringTestCase.java
@@ -385,7 +385,17 @@ public class ConstantPoolModuleToStringTestCase {
             append(constantModule);
             append(constantModule.toString(pool));
             final String s = constantModule.toString(pool).trim();
-            assertTrue(StringUtils.startsWithAny(s, "jdk.", "java.", "org.junit", "org.apiguardian.api", "org.opentest4j"), s);
+            boolean condition = StringUtils.startsWithAny(s, 
+                    "jdk.",
+                    "java.",
+                    "org.junit",
+                    "org.apiguardian.api",
+                    "org.opentest4j",
+                    "net.bytebuddy",
+                    "com.sun.jna",
+                    "junit",
+                    "org.hamcrest");
+            assertTrue(condition, s);
         }
 
         @Override
diff --git a/src/test/java/org/apache/bcel/generic/TypeTestCase.java b/src/test/java/org/apache/bcel/generic/TypeTestCase.java
index 4fd5c116..83780589 100644
--- a/src/test/java/org/apache/bcel/generic/TypeTestCase.java
+++ b/src/test/java/org/apache/bcel/generic/TypeTestCase.java
@@ -78,7 +78,8 @@ public class TypeTestCase {
         "org/apache/bcel/classfile/Method",
         "org/apache/bcel/classfile/Synthetic",
         "org/apache/bcel/generic/ConstantPoolGen",
-        "org/apache/bcel/generic/MethodGen"})
+        "org/apache/bcel/generic/MethodGen",
+        "com/foo/Foo"})
     // @formatter:on
     public void testLDC(final String className) throws Exception {
         final JavaClass jc = Repository.lookupClass(className);
diff --git a/src/test/java/org/apache/bcel/verifier/JiraBcel370TestCase.java b/src/test/java/org/apache/bcel/verifier/JiraBcel370TestCase.java
new file mode 100644
index 00000000..ac9e09e4
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/JiraBcel370TestCase.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.bcel.verifier;
+
+import java.io.File;
+import java.io.FileInputStream;
+
+import org.apache.bcel.AbstractTestCase;
+import org.apache.bcel.classfile.ClassParser;
+import org.apache.bcel.classfile.JavaClass;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.EmptyVisitor;
+import org.apache.bcel.generic.Instruction;
+import org.apache.bcel.generic.LDC;
+import org.apache.bcel.generic.MethodGen;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+/**
+ * Tests BCEL-370.
+ */
+public class JiraBcel370TestCase extends AbstractTestCase {
+    @ParameterizedTest
+    @ValueSource(strings = {
+    // @formatter:off
+        "com.foo.Foo"
+    })
+    // @formatter:on
+    public void testVerify(String className) throws ClassNotFoundException {
+        // Without the changes to the verifier this fails because it doesn't allow LDC CONSTANT_Dynamic
+        Verifier.verifyType(className);
+    }
+
+    @ParameterizedTest
+    @ValueSource(strings = {
+    // @formatter:off
+        "target/test-classes/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser$ClassBlockContext.class",
+        "target/test-classes/com/foo/Foo.class"
+    })
+    // @formatter:on
+    public void testLdcGetType(final String classFileName) throws Exception {
+        try (FileInputStream file = new FileInputStream(classFileName)) {
+            final ClassParser parser = new ClassParser(file, new File(classFileName).getName());
+            JavaClass clazz = parser.parse();
+            
+            Method[] methods = clazz.getMethods();
+            
+            ConstantPoolGen cp = new ConstantPoolGen(clazz.getConstantPool());
+            MethodGen methodGen = new MethodGen(methods[0], classFileName, cp);
+            
+            // The first instruction is an LDC CONSTANT_Dynamic added by Jacoco
+            Instruction instruction = methodGen.getInstructionList().getInstructions()[0];
+
+            instruction.accept(new EmptyVisitor() {
+                @Override
+                public void visitLDC(LDC ldc) {
+                    // Without the change to LDC.getType() this fails because the tag is CONSTANT_Dynamic
+                    ldc.getType(cp);
+                }
+            });
+        }
+    }
+}
diff --git a/src/test/java/org/apache/bcel/verifier/statics/Pass3aVerifierTestCase.java b/src/test/java/org/apache/bcel/verifier/statics/Pass3aVerifierTestCase.java
new file mode 100644
index 00000000..7128b235
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/statics/Pass3aVerifierTestCase.java
@@ -0,0 +1,135 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.bcel.verifier.statics;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.stream.Stream;
+
+import org.apache.bcel.Const;
+import org.apache.bcel.Repository;
+import org.apache.bcel.classfile.Attribute;
+import org.apache.bcel.classfile.Code;
+import org.apache.bcel.classfile.CodeException;
+import org.apache.bcel.classfile.Constant;
+import org.apache.bcel.classfile.ConstantDouble;
+import org.apache.bcel.classfile.ConstantFieldref;
+import org.apache.bcel.classfile.ConstantInterfaceMethodref;
+import org.apache.bcel.classfile.ConstantInvokeDynamic;
+import org.apache.bcel.classfile.ConstantLong;
+import org.apache.bcel.classfile.ConstantMethodHandle;
+import org.apache.bcel.classfile.ConstantMethodType;
+import org.apache.bcel.classfile.ConstantModule;
+import org.apache.bcel.classfile.ConstantNameAndType;
+import org.apache.bcel.classfile.ConstantPackage;
+import org.apache.bcel.classfile.ConstantPool;
+import org.apache.bcel.classfile.ConstantUtf8;
+import org.apache.bcel.classfile.JavaClass;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.util.SyntheticRepository;
+import org.apache.bcel.verifier.VerificationResult;
+import org.apache.bcel.verifier.Verifier;
+import org.apache.bcel.verifier.VerifierFactory;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class Pass3aVerifierTestCase {
+    private Verifier verifier;
+    private org.apache.bcel.util.Repository repository;
+    private ConstantPool cp;
+    private JavaClass javaClass;
+
+    @BeforeEach
+    void setup() throws ClassNotFoundException {
+        String className = "org.apache.bcel.verifier.statics.Pass3aVerifierTestCase.foo";
+        
+        verifier = spy(VerifierFactory.getVerifier(className));
+        repository = mock(org.apache.bcel.util.Repository.class);
+        cp = mock(ConstantPool.class);
+        javaClass = mock(JavaClass.class);
+        
+        // Mock the verifier
+        doReturn(VerificationResult.VR_OK).when(verifier).doPass2();
+        
+        // Mock the repository
+        Repository.setRepository(repository);
+        when(repository.loadClass(className)).thenReturn(javaClass);
+        
+        // Mock the constant pool
+        when(cp.getConstantPool()).thenReturn(new Constant[] {new ConstantModule(0)});
+        
+        // Mock the java class
+        when(javaClass.getConstantPool()).thenReturn(cp);
+    }
+    
+    @AfterAll
+    public static void restoreRepository() {
+        // We have set our mock repository, revert the change 
+        Repository.setRepository(SyntheticRepository.getInstance());
+    }
+    
+    public static Stream<Constant> constantsNotSupportedByLdc() {
+        return Stream.of(
+               new ConstantFieldref(0, 0),
+               new ConstantInterfaceMethodref(0, 0),
+               new ConstantInvokeDynamic(0, 0),
+               new ConstantMethodHandle(0, 0),
+               new ConstantDouble(0D),
+               new ConstantLong(0L),
+               new ConstantMethodHandle(0, 0),
+               new ConstantMethodType(0),
+               new ConstantModule(0),
+               new ConstantNameAndType(0, 0),
+               new ConstantPackage(0),
+               new ConstantUtf8("constant")
+                );
+    }
+    
+    @ParameterizedTest
+    @MethodSource("constantsNotSupportedByLdc")
+    public void rejectLdcConstant(Constant constant) {
+        // LDC the constant 0 and then return
+        byte[] methodCode = new byte[] {
+                Const.LDC,
+                0,
+                0,
+                (byte) Const.RETURN,
+        };
+        
+        Code code = new Code(0, 0, 0, 0, methodCode, new CodeException[0], new Attribute[0], cp);
+
+        when(cp.getConstantPool()).thenReturn(new Constant[] {constant});
+        
+        Attribute[] attributes = new Attribute[] {code};
+        Method method = new Method(0, 0, 0, attributes, cp);
+        
+        when(javaClass.getMethods()).thenReturn(new Method[] {method});
+        
+        Pass3aVerifier pass3aVerifier = new Pass3aVerifier(verifier, 0);
+        VerificationResult verificationResult = pass3aVerifier.do_verify();
+        
+        assertThat(verificationResult.getStatus()).isEqualTo(VerificationResult.VERIFIED_REJECTED);
+        assertThat(verificationResult.getMessage()).startsWith("Instruction ldc[18](2) 0 constraint violated: Operand of LDC");
+    }
+}
+
diff --git a/src/test/java/org/apache/bcel/verifier/structurals/InstConstraintVisitorTestCase.java b/src/test/java/org/apache/bcel/verifier/structurals/InstConstraintVisitorTestCase.java
new file mode 100644
index 00000000..7b12a62b
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/structurals/InstConstraintVisitorTestCase.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.bcel.verifier.structurals;
+
+import static org.assertj.core.api.Assertions.assertThatCode;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import org.apache.bcel.classfile.Constant;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.LDC;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public class InstConstraintVisitorTestCase {
+    private ConstantPoolGen cp;
+    
+    @BeforeEach
+    public void setup() {
+        cp = mock(ConstantPoolGen.class);
+    }
+    
+    @ParameterizedTest
+    @MethodSource("org.apache.bcel.verifier.statics.Pass3aVerifierTestCase#constantsNotSupportedByLdc")
+    public void rejectLdcConstantModule(Constant constant) {
+        InstConstraintVisitor visitor = new InstConstraintVisitor();
+        
+        cp = mock(ConstantPoolGen.class);
+        when(cp.getConstant(0)).thenReturn(constant);
+        
+        visitor.setConstantPoolGen(cp);
+        
+        LDC ldc = new LDC(0);
+        
+        assertThatCode(() -> visitor.visitLDC(ldc)).hasMessageStartingWith("Instruction LDC constraint violated: Referenced constant should be a");
+    }
+}
diff --git a/src/test/resources/com/foo/Foo.class b/src/test/resources/com/foo/Foo.class
new file mode 100644
index 00000000..f405e5fe
Binary files /dev/null and b/src/test/resources/com/foo/Foo.class differ
diff --git a/src/test/resources/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser$ClassBlockContext.class b/src/test/resources/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser$ClassBlockContext.class
new file mode 100644
index 00000000..c5da924a
Binary files /dev/null and b/src/test/resources/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser$ClassBlockContext.class differ
