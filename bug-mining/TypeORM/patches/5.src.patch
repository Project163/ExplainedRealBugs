diff --git a/src/driver/mysql/MysqlQueryRunner.ts b/src/driver/mysql/MysqlQueryRunner.ts
index b83bc26ab..1bb4ec6bd 100644
--- a/src/driver/mysql/MysqlQueryRunner.ts
+++ b/src/driver/mysql/MysqlQueryRunner.ts
@@ -1325,6 +1325,20 @@ export class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {
                     }));
             });
 
+        // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.
+        if (table.uniques.length > 0) {
+            table.uniques.forEach(unique => {
+                const uniqueExist = table.indices.some(index => index.name === unique.name);
+                if (!uniqueExist) {
+                    table.indices.push(new TableIndex({
+                        name: unique.name,
+                        columnNames: unique.columnNames,
+                        isUnique: true
+                    }));
+                }
+            });
+        }
+
         if (table.indices.length > 0) {
             const indicesSql = table.indices.map(index => {
                 const columnNames = index.columnNames.map(columnName => `\`${columnName}\``).join(", ");
diff --git a/src/metadata/ColumnMetadata.ts b/src/metadata/ColumnMetadata.ts
index a31f0899f..1c1e5c493 100644
--- a/src/metadata/ColumnMetadata.ts
+++ b/src/metadata/ColumnMetadata.ts
@@ -640,7 +640,7 @@ export class ColumnMetadata {
         // we add reference column to property path only if this column is virtual
         // because if its not virtual it means user defined a real column for this relation
         // also we don't do it if column is inside a junction table
-        if (!    this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)
+        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)
             path += "." + this.referencedColumn.propertyName;
 
         return path;
diff --git a/test/github-issues/1863/issue-1863.ts b/test/github-issues/1863/issue-1863.ts
new file mode 100644
index 000000000..aa7c22253
--- /dev/null
+++ b/test/github-issues/1863/issue-1863.ts
@@ -0,0 +1,47 @@
+import "reflect-metadata";
+import {Connection} from "../../../src/connection/Connection";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {Table} from "../../../src";
+
+describe("github issues > #1863 createTable.uniques doesn't work when the columnNames only has one item", () => {
+
+    let connections: Connection[];
+    before(async () => {
+        connections = await createTestingConnections({
+            enabledDrivers: ["mysql"],
+            dropSchema: true,
+        });
+    });
+    after(() => closeTestingConnections(connections));
+
+    it("should correctly create table with unique constraint", () => Promise.all(connections.map(async connection => {
+        const queryRunner = connection.createQueryRunner();
+        await queryRunner.createTable(new Table({
+            name: "post",
+            columns: [
+                {
+                    name: "id",
+                    type: "int",
+                    isPrimary: true
+                },
+                {
+                    name: "name",
+                    type: "varchar",
+                    isNullable: false
+                }
+            ],
+            uniques: [
+                {
+                    name: "table_unique",
+                    columnNames: ["name"]
+                }
+            ]
+        }));
+
+        const table = await queryRunner.getTable("post");
+        table!.indices.length.should.be.equal(1);
+        table!.indices[0].name!.should.be.equal("table_unique");
+
+    })));
+
+});
