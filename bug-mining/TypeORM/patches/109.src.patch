diff --git a/src/driver/cockroachdb/CockroachDriver.ts b/src/driver/cockroachdb/CockroachDriver.ts
index 8e2f95a88..bd3407ab7 100644
--- a/src/driver/cockroachdb/CockroachDriver.ts
+++ b/src/driver/cockroachdb/CockroachDriver.ts
@@ -490,7 +490,13 @@ export class CockroachDriver implements Driver {
             return defaultValue === true ? "true" : "false";
 
         } else if (typeof defaultValue === "function") {
-            return defaultValue();
+            const value = defaultValue();
+            if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
+                return "current_timestamp()";
+            } else if (value.toUpperCase() === "CURRENT_DATE") {
+                return "current_date()";
+            }
+            return value;
 
         } else if (typeof defaultValue === "string") {
             return `'${defaultValue}'${arrayCast}`;
diff --git a/src/driver/cockroachdb/CockroachQueryRunner.ts b/src/driver/cockroachdb/CockroachQueryRunner.ts
index dab3749e5..0caeb42ed 100644
--- a/src/driver/cockroachdb/CockroachQueryRunner.ts
+++ b/src/driver/cockroachdb/CockroachQueryRunner.ts
@@ -1527,7 +1527,7 @@ export class CockroachQueryRunner extends BaseQueryRunner implements QueryRunner
                             tableColumn.isGenerated = true;
                             tableColumn.generationStrategy = "uuid";
 
-                        } else {
+                        } else  {
                             tableColumn.default = dbColumn["column_default"].replace(/:::.*/, "");
                             tableColumn.default = tableColumn.default.replace(/^(-?[\d\.]+)$/, "($1)");
                         }
diff --git a/src/driver/mysql/MysqlDriver.ts b/src/driver/mysql/MysqlDriver.ts
index c52fa5dfc..6070561d1 100644
--- a/src/driver/mysql/MysqlDriver.ts
+++ b/src/driver/mysql/MysqlDriver.ts
@@ -602,8 +602,8 @@ export class MysqlDriver implements Driver {
             return defaultValue === true ? "1" : "0";
 
         } else if (typeof defaultValue === "function") {
-            return defaultValue();
-
+            const value = defaultValue();
+            return this.normalizeDatetimeFunction(value)
         } else {
             return defaultValue;
         }
@@ -737,35 +737,12 @@ export class MysqlDriver implements Driver {
             if (!tableColumn)
                 return false; // we don't need new columns, we only need exist and changed
 
-            // console.log("table:", columnMetadata.entityMetadata.tableName);
-            // console.log("name:", tableColumn.name, columnMetadata.databaseName);
-            // console.log("type:", tableColumn.type, this.normalizeType(columnMetadata));
-            // console.log("length:", tableColumn.length, columnMetadata.length);
-            // console.log("width:", tableColumn.width, columnMetadata.width);
-            // console.log("precision:", tableColumn.precision, columnMetadata.precision);
-            // console.log("scale:", tableColumn.scale, columnMetadata.scale);
-            // console.log("zerofill:", tableColumn.zerofill, columnMetadata.zerofill);
-            // console.log("unsigned:", tableColumn.unsigned, columnMetadata.unsigned);
-            // console.log("asExpression:", tableColumn.asExpression, columnMetadata.asExpression);
-            // console.log("generatedType:", tableColumn.generatedType, columnMetadata.generatedType);
-            // console.log("comment:", tableColumn.comment, columnMetadata.comment);
-            // console.log("default:", tableColumn.default, columnMetadata.default);
-            // console.log("enum:", tableColumn.enum, columnMetadata.enum);
-            // console.log("default changed:", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));
-            // console.log("onUpdate:", tableColumn.onUpdate, columnMetadata.onUpdate);
-            // console.log("isPrimary:", tableColumn.isPrimary, columnMetadata.isPrimary);
-            // console.log("isNullable:", tableColumn.isNullable, columnMetadata.isNullable);
-            // console.log("isUnique:", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));
-            // console.log("isGenerated:", tableColumn.isGenerated, columnMetadata.isGenerated);
-            // console.log((columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated));
-            // console.log("==========================================");
-
             let columnMetadataLength = columnMetadata.length;
             if (!columnMetadataLength && columnMetadata.generationStrategy === "uuid") { // fixing #3374
                 columnMetadataLength = this.getColumnLength(columnMetadata);
             }
 
-            return tableColumn.name !== columnMetadata.databaseName
+            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName
                 || tableColumn.type !== this.normalizeType(columnMetadata)
                 || tableColumn.length !== columnMetadataLength
                 || tableColumn.width !== columnMetadata.width
@@ -778,11 +755,39 @@ export class MysqlDriver implements Driver {
                 || tableColumn.comment !== columnMetadata.comment
                 || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default)
                 || (tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map(val => val + "")))
-                || tableColumn.onUpdate !== columnMetadata.onUpdate
+                || tableColumn.onUpdate !== this.normalizeDatetimeFunction(columnMetadata.onUpdate)
                 || tableColumn.isPrimary !== columnMetadata.isPrimary
                 || tableColumn.isNullable !== columnMetadata.isNullable
                 || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata)
                 || (columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated);
+
+            // DEBUG SECTION
+            // if (isColumnChanged) {
+            //     console.log("table:", columnMetadata.entityMetadata.tableName);
+            //     console.log("name:", tableColumn.name, columnMetadata.databaseName);
+            //     console.log("type:", tableColumn.type, this.normalizeType(columnMetadata));
+            //     console.log("length:", tableColumn.length, columnMetadata.length);
+            //     console.log("width:", tableColumn.width, columnMetadata.width);
+            //     console.log("precision:", tableColumn.precision, columnMetadata.precision);
+            //     console.log("scale:", tableColumn.scale, columnMetadata.scale);
+            //     console.log("zerofill:", tableColumn.zerofill, columnMetadata.zerofill);
+            //     console.log("unsigned:", tableColumn.unsigned, columnMetadata.unsigned);
+            //     console.log("asExpression:", tableColumn.asExpression, columnMetadata.asExpression);
+            //     console.log("generatedType:", tableColumn.generatedType, columnMetadata.generatedType);
+            //     console.log("comment:", tableColumn.comment, columnMetadata.comment);
+            //     console.log("default:", tableColumn.default, this.normalizeDefault(columnMetadata));
+            //     console.log("enum:", tableColumn.enum, columnMetadata.enum);
+            //     console.log("default changed:", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));
+            //     console.log("onUpdate:", tableColumn.onUpdate, this.normalizeOnUpdate(columnMetadata.onUpdate));
+            //     console.log("isPrimary:", tableColumn.isPrimary, columnMetadata.isPrimary);
+            //     console.log("isNullable:", tableColumn.isNullable, columnMetadata.isNullable);
+            //     console.log("isUnique:", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));
+            //     console.log("isGenerated:", tableColumn.isGenerated, columnMetadata.isGenerated);
+            //     console.log((columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated));
+            //     console.log("==========================================");
+            // }
+
+            return isColumnChanged
         });
     }
 
@@ -930,4 +935,28 @@ export class MysqlDriver implements Driver {
         return columnMetadataValue === databaseValue;
     }
 
+    /**
+     * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
+     * Otherwise returns original input.
+     */
+    protected normalizeDatetimeFunction(value?: string) {
+        if (!value) return value
+
+        // check if input is datetime function
+        const isDatetimeFunction = value.toUpperCase().indexOf("CURRENT_TIMESTAMP") !== -1
+            || value.toUpperCase().indexOf("NOW") !== -1;
+
+        if (isDatetimeFunction) {
+            // extract precision, e.g. "(3)"
+            const precision = value.match(/\(\d+\)/)
+            if (this.options.type === "mariadb") {
+                return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP()";
+            } else {
+                return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP";
+            }
+        } else {
+            return value
+        }
+    }
+
 }
diff --git a/src/driver/postgres/PostgresDriver.ts b/src/driver/postgres/PostgresDriver.ts
index 0400c18c0..d9237f273 100644
--- a/src/driver/postgres/PostgresDriver.ts
+++ b/src/driver/postgres/PostgresDriver.ts
@@ -750,7 +750,8 @@ export class PostgresDriver implements Driver {
             return defaultValue === true ? "true" : "false";
 
         } else if (typeof defaultValue === "function") {
-            return defaultValue();
+            const value = defaultValue();
+            return this.normalizeDatetimeFunction(value)
 
         } else if (typeof defaultValue === "object") {
             return `'${JSON.stringify(defaultValue)}'`;
@@ -903,7 +904,6 @@ export class PostgresDriver implements Driver {
             //     console.log("comment:", tableColumn.comment, columnMetadata.comment);
             //     console.log("enumName:", tableColumn.enumName, columnMetadata.enumName);
             //     console.log("enum:", tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map(val => val + "")));
-            //     console.log("onUpdate:", tableColumn.onUpdate, columnMetadata.onUpdate);
             //     console.log("isPrimary:", tableColumn.isPrimary, columnMetadata.isPrimary);
             //     console.log("isNullable:", tableColumn.isNullable, columnMetadata.isNullable);
             //     console.log("isUnique:", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));
@@ -1069,4 +1069,41 @@ export class PostgresDriver implements Driver {
         });
     }
 
+    /**
+     * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
+     * Otherwise returns original input.
+     */
+    protected normalizeDatetimeFunction(value: string) {
+        // check if input is datetime function
+        const upperCaseValue = value.toUpperCase()
+        const isDatetimeFunction = upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1
+            || upperCaseValue.indexOf("CURRENT_DATE") !== -1
+            || upperCaseValue.indexOf("CURRENT_TIME") !== -1
+            || upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1
+            || upperCaseValue.indexOf("LOCALTIME") !== -1;
+
+        if (isDatetimeFunction) {
+            // extract precision, e.g. "(3)"
+            const precision = value.match(/\(\d+\)/)
+
+            if (upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1) {
+                return precision ? `('now'::text)::timestamp${precision[0]} with time zone` : "now()";
+
+            } else if (upperCaseValue === "CURRENT_DATE") {
+                return "('now'::text)::date"
+
+            } else if (upperCaseValue.indexOf("CURRENT_TIME") !== -1) {
+                return precision ? `('now'::text)::time${precision[0]} with time zone` : "('now'::text)::time with time zone"
+
+            } else if (upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1) {
+                return precision ? `('now'::text)::timestamp${precision[0]} without time zone` : "('now'::text)::timestamp without time zone"
+
+            } else if (upperCaseValue.indexOf("LOCALTIME") !== -1) {
+                return precision ? `('now'::text)::time${precision[0]} without time zone` : "('now'::text)::time without time zone"
+            }
+        }
+
+        return value
+    }
+
 }
diff --git a/src/driver/postgres/PostgresQueryRunner.ts b/src/driver/postgres/PostgresQueryRunner.ts
index 62c9eef37..f4150dd2a 100644
--- a/src/driver/postgres/PostgresQueryRunner.ts
+++ b/src/driver/postgres/PostgresQueryRunner.ts
@@ -1679,6 +1679,8 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
                         } else if (dbColumn["column_default"] === "gen_random_uuid()" || /^uuid_generate_v\d\(\)/.test(dbColumn["column_default"])) {
                             tableColumn.isGenerated = true;
                             tableColumn.generationStrategy = "uuid";
+                        } else if (dbColumn["column_default"] === "now()" || dbColumn["column_default"].indexOf("'now'::text") !== -1) {
+                            tableColumn.default = dbColumn["column_default"]
                         } else {
                             tableColumn.default = dbColumn["column_default"].replace(/::.*/, "");
                             tableColumn.default = tableColumn.default.replace(/^(-?\d+)$/, "'$1'");
diff --git a/src/driver/sqlserver/SqlServerDriver.ts b/src/driver/sqlserver/SqlServerDriver.ts
index 90743f3d5..45a602902 100644
--- a/src/driver/sqlserver/SqlServerDriver.ts
+++ b/src/driver/sqlserver/SqlServerDriver.ts
@@ -501,7 +501,11 @@ export class SqlServerDriver implements Driver {
             return defaultValue === true ? "1" : "0";
 
         } else if (typeof defaultValue === "function") {
-            return /*"(" + */defaultValue()/* + ")"*/;
+            const value = defaultValue();
+            if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
+                return "getdate()"
+            }
+            return value
 
         } else if (typeof defaultValue === "string") {
             return `'${defaultValue}'`;
diff --git a/src/metadata/ColumnMetadata.ts b/src/metadata/ColumnMetadata.ts
index a2631768e..8cfd61b45 100644
--- a/src/metadata/ColumnMetadata.ts
+++ b/src/metadata/ColumnMetadata.ts
@@ -368,7 +368,7 @@ export class ColumnMetadata {
         }
         if (options.args.options.unsigned)
             this.unsigned = options.args.options.unsigned;
-        if (options.args.options.precision !== undefined)
+        if (options.args.options.precision !== null)
             this.precision = options.args.options.precision;
         if (options.args.options.enum) {
             if (options.args.options.enum instanceof Object && !Array.isArray(options.args.options.enum)) {
@@ -413,7 +413,8 @@ export class ColumnMetadata {
                 this.type = options.connection.driver.mappedDataTypes.createDate;
             if (!this.default)
                 this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;
-            if (this.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision)
+            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
+            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision)
                 this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
         }
         if (this.isUpdateDate) {
@@ -423,7 +424,8 @@ export class ColumnMetadata {
                 this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;
             if (!this.onUpdate)
                 this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;
-            if (this.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision)
+            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
+            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision)
                 this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
         }
         if (this.isDeleteDate) {
@@ -431,7 +433,8 @@ export class ColumnMetadata {
                 this.type = options.connection.driver.mappedDataTypes.deleteDate;
             if (!this.isNullable)
                 this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;
-            if (this.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision)
+            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
+            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision)
                 this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;
         }
         if (this.isVersion)
diff --git a/test/functional/query-runner/rename-column.ts b/test/functional/query-runner/rename-column.ts
index b033a46fb..481f79581 100644
--- a/test/functional/query-runner/rename-column.ts
+++ b/test/functional/query-runner/rename-column.ts
@@ -24,10 +24,6 @@ describe("query runner > rename column", () => {
 
     it("should correctly rename column and revert rename", () => Promise.all(connections.map(async connection => {
 
-        // TODO: https://github.com/cockroachdb/cockroach/issues/32555
-        if (connection.driver instanceof CockroachDriver)
-            return;
-
         const queryRunner = connection.createQueryRunner();
 
         let table = await queryRunner.getTable("post");
@@ -58,10 +54,6 @@ describe("query runner > rename column", () => {
 
     it("should correctly rename column with all constraints and revert rename", () => Promise.all(connections.map(async connection => {
 
-        // TODO: https://github.com/cockroachdb/cockroach/issues/32555
-        if (connection.driver instanceof CockroachDriver)
-            return;
-
         const queryRunner = connection.createQueryRunner();
 
         let table = await queryRunner.getTable("post");
@@ -106,10 +98,6 @@ describe("query runner > rename column", () => {
 
     it("should correctly rename column with all constraints in custom table schema and database and revert rename", () => Promise.all(connections.map(async connection => {
 
-        // TODO: https://github.com/cockroachdb/cockroach/issues/32555
-        if (connection.driver instanceof CockroachDriver)
-            return;
-
         const queryRunner = connection.createQueryRunner();
         let table: Table|undefined;
 
diff --git a/test/github-issues/2333/entity/Test.ts b/test/github-issues/2333/entity/Test.ts
new file mode 100644
index 000000000..dfc878eb1
--- /dev/null
+++ b/test/github-issues/2333/entity/Test.ts
@@ -0,0 +1,12 @@
+import {Column, Entity, PrimaryGeneratedColumn} from "../../../../src";
+
+@Entity("test")
+export class Test {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ type: "datetime", nullable: true, default: null })
+    publish_date: Date;
+
+}
diff --git a/test/github-issues/2333/issue-2333.ts b/test/github-issues/2333/issue-2333.ts
new file mode 100644
index 000000000..d7e4b6246
--- /dev/null
+++ b/test/github-issues/2333/issue-2333.ts
@@ -0,0 +1,27 @@
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {Test} from "./entity/Test";
+
+describe("github issues > #2333 datetime column showing changed on every schema:sync run", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["mysql", "mariadb"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [Test],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+})
diff --git a/test/github-issues/2737/entity/TestEntity.ts b/test/github-issues/2737/entity/TestEntity.ts
index b44b2d407..9000fe17c 100644
--- a/test/github-issues/2737/entity/TestEntity.ts
+++ b/test/github-issues/2737/entity/TestEntity.ts
@@ -1,6 +1,8 @@
-import { Entity } from "../../../../src/decorator/entity/Entity";
-import { Column } from "../../../../src/decorator/columns/Column";
-import { PrimaryGeneratedColumn } from "../../../../src/decorator/columns/PrimaryGeneratedColumn";
+import { Entity } from "../../../../src";
+import { Column } from "../../../../src";
+import { PrimaryGeneratedColumn } from "../../../../src";
+import {CreateDateColumn} from "../../../../src";
+
 @Entity()
 export class TestEntity {
     @PrimaryGeneratedColumn()
@@ -11,4 +13,16 @@ export class TestEntity {
 
     @Column({ type: "varchar", length: 100, nullable: true, unique: false })
     nonunique_column: string;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP(6)" })
+    from: Date;
+
+    @CreateDateColumn({ precision: 3, type: "timestamp", default: () => "CURRENT_TIMESTAMP(3)" })
+    from2: Date;
+
+    @CreateDateColumn({ precision: null, type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    from3: Date;
+
+    @Column({ precision: null, type: "timestamp", default: null, nullable: true })
+    to: Date;
 }
diff --git a/test/github-issues/2737/issue-2737.ts b/test/github-issues/2737/issue-2737.ts
index 49ef69bc5..7c776155d 100644
--- a/test/github-issues/2737/issue-2737.ts
+++ b/test/github-issues/2737/issue-2737.ts
@@ -9,7 +9,7 @@ describe("github issues > #2737 MySQLDriver findChangedColumns (fields: width, p
     before(async () => connections = await createTestingConnections({
         dropSchema: false,
         entities: [__dirname + "/entity/*{.js,.ts}"],
-        enabledDrivers: ["mysql", "aurora-data-api"],
+        enabledDrivers: ["mysql", "mariadb", "aurora-data-api"],
         schemaCreate: false,
         cache: false,
         driverSpecific: {
diff --git a/test/github-issues/3991/entity/cockroachdb/Post.ts b/test/github-issues/3991/entity/cockroachdb/Post.ts
new file mode 100644
index 000000000..194426259
--- /dev/null
+++ b/test/github-issues/3991/entity/cockroachdb/Post.ts
@@ -0,0 +1,64 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ type: "date", default: () => "CURRENT_DATE" })
+    col1: Date;
+
+    @Column({ type: "date", default: () => "current_date" })
+    col2: Date;
+
+    @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col3: Date;
+
+    @Column({ type: "timestamp", default: () => "current_timestamp" })
+    col4: Date;
+
+    @Column({ type: "timestamp", default: () => "NOW()" })
+    col5: Date;
+
+    @Column({ type: "timestamp", default: () => "now()" })
+    col6: Date;
+
+
+    @CreateDateColumn({ type: "date", default: () => "CURRENT_DATE" })
+    col7: Date;
+
+    @CreateDateColumn({ type: "date", default: () => "current_date" })
+    col8: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col9: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "current_timestamp" })
+    col10: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "NOW()" })
+    col11: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "now()" })
+    col12: Date;
+
+
+    @UpdateDateColumn({ type: "date", default: () => "CURRENT_DATE" })
+    col13: Date;
+
+    @UpdateDateColumn({ type: "date", default: () => "current_date" })
+    col14: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col15: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "current_timestamp" })
+    col16: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "NOW()" })
+    col17: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "now()" })
+    col18: Date;
+}
diff --git a/test/github-issues/3991/entity/mssql/Post.ts b/test/github-issues/3991/entity/mssql/Post.ts
new file mode 100644
index 000000000..60dacc487
--- /dev/null
+++ b/test/github-issues/3991/entity/mssql/Post.ts
@@ -0,0 +1,37 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP" })
+    col1: Date;
+
+    @Column({ default: () => "current_timestamp" })
+    col2: Date;
+
+    @Column({ default: () => "getdate()" })
+    col3: Date;
+
+
+    @CreateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col4: Date;
+
+    @CreateDateColumn({ default: () => "current_timestamp" })
+    col5: Date;
+
+    @CreateDateColumn({ default: () => "getdate()" })
+    col6: Date;
+
+
+    @UpdateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col7: Date;
+
+    @UpdateDateColumn({ default: () => "current_timestamp" })
+    col8: Date;
+
+    @UpdateDateColumn({ default: () => "getdate()" })
+    col9: Date;
+}
diff --git a/test/github-issues/3991/entity/mysql/Post.ts b/test/github-issues/3991/entity/mysql/Post.ts
new file mode 100644
index 000000000..088377a5d
--- /dev/null
+++ b/test/github-issues/3991/entity/mysql/Post.ts
@@ -0,0 +1,89 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP" })
+    col1: Date;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP()" })
+    col2: Date;
+
+    @Column({ precision: 3, default: () => "CURRENT_TIMESTAMP(3)" })
+    col3: Date;
+
+    @Column({ default: () => "current_timestamp" })
+    col4: Date;
+
+    @Column({ default: () => "current_timestamp()" })
+    col5: Date;
+
+    @Column({ precision: 3, default: () => "current_timestamp(3)" })
+    col6: Date;
+
+    @Column({ default: () => "NOW()" })
+    col7: Date;
+
+    @Column({ precision: 3, default: () => "NOW(3)" })
+    col8: Date;
+
+    @Column({ precision: 3, default: () => "now(3)" })
+    col9: Date;
+
+    @CreateDateColumn({ precision: null, default: () => "CURRENT_TIMESTAMP" })
+    col10: Date;
+
+    @CreateDateColumn({ precision: null, default: () => "CURRENT_TIMESTAMP()" })
+    col11: Date;
+
+    @CreateDateColumn({ precision: 3, default: () => "CURRENT_TIMESTAMP(3)" })
+    col12: Date;
+
+    @CreateDateColumn({ precision: null, default: () => "current_timestamp" })
+    col13: Date;
+
+    @CreateDateColumn({ precision: 3, default: () => "current_timestamp(3)" })
+    col14: Date;
+
+    @CreateDateColumn({ precision: null, default: () => "NOW()" })
+    col15: Date;
+
+    @CreateDateColumn({ precision: 3, default: () => "NOW(3)" })
+    col16: Date;
+
+    @CreateDateColumn({ precision: null, default: () => "now()" })
+    col17: Date;
+
+    @CreateDateColumn({ precision: 3, default: () => "now(3)" })
+    col18: Date;
+
+    @UpdateDateColumn({ precision: null, default: () => "CURRENT_TIMESTAMP", onUpdate: "CURRENT_TIMESTAMP" })
+    col19: Date;
+
+    @UpdateDateColumn({ precision: null, default: () => "CURRENT_TIMESTAMP()", onUpdate: "CURRENT_TIMESTAMP()" })
+    col20: Date;
+
+    @UpdateDateColumn({ precision: 3, default: () => "CURRENT_TIMESTAMP(3)", onUpdate: "CURRENT_TIMESTAMP(3)" })
+    col21: Date;
+
+    @UpdateDateColumn({ precision: null, default: () => "current_timestamp", onUpdate: "current_timestamp" })
+    col22: Date;
+
+    @UpdateDateColumn({ precision: 3, default: () => "current_timestamp(3)", onUpdate: "current_timestamp(3)" })
+    col23: Date;
+
+    @UpdateDateColumn({ precision: null, default: () => "NOW()", onUpdate: "NOW()" })
+    col24: Date;
+
+    @UpdateDateColumn({ precision: 3, default: () => "NOW(3)", onUpdate: "NOW(3)" })
+    col25: Date;
+
+    @UpdateDateColumn({ precision: null, default: () => "now()", onUpdate: "now()" })
+    col26: Date;
+
+    @UpdateDateColumn({ precision: 3, default: () => "now(3)", onUpdate: "now(3)" })
+    col27: Date;
+}
diff --git a/test/github-issues/3991/entity/oracle/Post.ts b/test/github-issues/3991/entity/oracle/Post.ts
new file mode 100644
index 000000000..bd15cbf8f
--- /dev/null
+++ b/test/github-issues/3991/entity/oracle/Post.ts
@@ -0,0 +1,127 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP" })
+    col1: Date;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP(3)" })
+    col2: Date;
+
+    @Column({ default: () => "current_timestamp" })
+    col3: Date;
+
+    @Column({ default: () => "CURRENT_DATE" })
+    col4: Date;
+
+    @Column({ default: () => "current_date" })
+    col5: Date;
+
+    @Column({ default: () => "LOCALTIMESTAMP" })
+    col6: Date;
+
+    @Column({ default: () => "LOCALTIMESTAMP(3)" })
+    col7: Date;
+
+    @Column({ default: () => "localtimestamp" })
+    col8: Date;
+
+    @Column({ default: () => "SYSDATE" })
+    col9: Date;
+
+    @Column({ default: () => "sysdate" })
+    col10: Date;
+
+    @Column({ default: () => "SYSTIMESTAMP" })
+    col11: Date;
+
+    @Column({ default: () => "SYSTIMESTAMP(3)" })
+    col12: Date;
+
+    @Column({ default: () => "systimestamp" })
+    col13: Date;
+
+
+    @CreateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col14: Date;
+
+    @CreateDateColumn({ default: () => "CURRENT_TIMESTAMP(3)" })
+    col15: Date;
+
+    @CreateDateColumn({ default: () => "current_timestamp" })
+    col16: Date;
+
+    @CreateDateColumn({ default: () => "CURRENT_DATE" })
+    col17: Date;
+
+    @CreateDateColumn({ default: () => "current_date" })
+    col18: Date;
+
+    @CreateDateColumn({ default: () => "LOCALTIMESTAMP" })
+    col19: Date;
+
+    @CreateDateColumn({ default: () => "LOCALTIMESTAMP(3)" })
+    col20: Date;
+
+    @CreateDateColumn({ default: () => "localtimestamp" })
+    col21: Date;
+
+    @CreateDateColumn({ default: () => "SYSDATE" })
+    col22: Date;
+
+    @CreateDateColumn({ default: () => "sysdate" })
+    col23: Date;
+
+    @CreateDateColumn({ default: () => "SYSTIMESTAMP" })
+    col24: Date;
+
+    @CreateDateColumn({ default: () => "SYSTIMESTAMP(3)" })
+    col25: Date;
+
+    @CreateDateColumn({ default: () => "systimestamp" })
+    col26: Date;
+
+
+    @UpdateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col27: Date;
+
+    @UpdateDateColumn({ default: () => "CURRENT_TIMESTAMP(3)" })
+    col28: Date;
+
+    @UpdateDateColumn({ default: () => "current_timestamp" })
+    col29: Date;
+
+    @UpdateDateColumn({ default: () => "CURRENT_DATE" })
+    col30: Date;
+
+    @UpdateDateColumn({ default: () => "current_date" })
+    col31: Date;
+
+    @UpdateDateColumn({ default: () => "LOCALTIMESTAMP" })
+    col32: Date;
+
+    @UpdateDateColumn({ default: () => "LOCALTIMESTAMP(3)" })
+    col33: Date;
+
+    @UpdateDateColumn({ default: () => "localtimestamp" })
+    col34: Date;
+
+    @UpdateDateColumn({ default: () => "SYSDATE" })
+    col35: Date;
+
+    @UpdateDateColumn({ default: () => "sysdate" })
+    col36: Date;
+
+    @UpdateDateColumn({ default: () => "SYSTIMESTAMP" })
+    col37: Date;
+
+    @UpdateDateColumn({ default: () => "SYSTIMESTAMP(3)" })
+    col38: Date;
+
+    @UpdateDateColumn({ default: () => "systimestamp" })
+    col39: Date;
+}
diff --git a/test/github-issues/3991/entity/postgres/Post.ts b/test/github-issues/3991/entity/postgres/Post.ts
new file mode 100644
index 000000000..876e49a16
--- /dev/null
+++ b/test/github-issues/3991/entity/postgres/Post.ts
@@ -0,0 +1,147 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ type: "date", default: () => "CURRENT_DATE" })
+    col1: Date;
+
+    @Column({ type: "date", default: () => "current_date" })
+    col2: Date;
+
+    @Column({ type: "time", default: () => "CURRENT_TIME" })
+    col3: Date;
+
+    @Column({ type: "time", default: () => "CURRENT_TIME(3)" })
+    col4: Date;
+
+    @Column({ type: "time", default: () => "current_time" })
+    col5: Date;
+
+    @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col6: Date;
+
+    @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP(3)" })
+    col7: Date;
+
+    @Column({ type: "timestamp", default: () => "current_timestamp" })
+    col8: Date;
+
+    @Column({ type: "timestamp", default: () => "NOW()" })
+    col9: Date;
+
+    @Column({ type: "time", default: () => "LOCALTIME" })
+    col10: Date;
+
+    @Column({ type: "time", default: () => "LOCALTIME(3)" })
+    col11: Date;
+
+    @Column({ type: "time", default: () => "localtime" })
+    col12: Date;
+
+    @Column({ type: "timestamp", default: () => "LOCALTIMESTAMP" })
+    col13: Date;
+
+    @Column({ type: "timestamp", default: () => "LOCALTIMESTAMP(3)" })
+    col14: Date;
+
+    @Column({ type: "timestamp", default: () => "localtimestamp" })
+    col15: Date;
+
+
+
+    @CreateDateColumn({ type: "date", default: () => "CURRENT_DATE" })
+    col16: Date;
+
+    @CreateDateColumn({ type: "date", default: () => "current_date" })
+    col17: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "CURRENT_TIME" })
+    col18: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "CURRENT_TIME(3)" })
+    col19: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "current_time" })
+    col20: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col21: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP(3)" })
+    col22: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "current_timestamp" })
+    col23: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "NOW()" })
+    col24: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "LOCALTIME" })
+    col25: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "LOCALTIME(3)" })
+    col26: Date;
+
+    @CreateDateColumn({ type: "time", default: () => "localtime" })
+    col27: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "LOCALTIMESTAMP" })
+    col28: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "LOCALTIMESTAMP(3)" })
+    col29: Date;
+
+    @CreateDateColumn({ type: "timestamp", default: () => "localtimestamp" })
+    col30: Date;
+
+
+
+    @UpdateDateColumn({ type: "date", default: () => "CURRENT_DATE" })
+    col31: Date;
+
+    @UpdateDateColumn({ type: "date", default: () => "current_date" })
+    col32: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "CURRENT_TIME" })
+    col33: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "CURRENT_TIME(3)" })
+    col34: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "current_time" })
+    col35: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    col36: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "CURRENT_TIMESTAMP(3)" })
+    col37: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "current_timestamp" })
+    col38: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "NOW()" })
+    col39: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "LOCALTIME" })
+    col40: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "LOCALTIME(3)" })
+    col41: Date;
+
+    @UpdateDateColumn({ type: "time", default: () => "localtime" })
+    col42: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "LOCALTIMESTAMP" })
+    col43: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "LOCALTIMESTAMP(3)" })
+    col44: Date;
+
+    @UpdateDateColumn({ type: "timestamp", default: () => "localtimestamp" })
+    col45: Date;
+}
diff --git a/test/github-issues/3991/entity/sqlite/Post.ts b/test/github-issues/3991/entity/sqlite/Post.ts
new file mode 100644
index 000000000..442ae8b17
--- /dev/null
+++ b/test/github-issues/3991/entity/sqlite/Post.ts
@@ -0,0 +1,55 @@
+import {Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../../src";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column({ default: () => "CURRENT_DATE" })
+    col1: Date;
+
+    @Column({ default: () => "CURRENT_TIME" })
+    col2: Date;
+
+    @Column({ default: () => "CURRENT_TIMESTAMP" })
+    col3: Date;
+
+    @Column({ precision: 3,  default: () => "CURRENT_TIMESTAMP" })
+    col4: Date;
+
+    @Column({ default: () => "NOW()" })
+    col5: Date;
+
+
+    @CreateDateColumn({ default: () => "CURRENT_DATE" })
+    col6: Date;
+
+    @CreateDateColumn({ default: () => "CURRENT_TIME" })
+    col7: Date;
+
+    @CreateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col8: Date;
+
+    @CreateDateColumn({ precision: 3,  default: () => "CURRENT_TIMESTAMP" })
+    col9: Date;
+
+    @CreateDateColumn({ default: () => "NOW()" })
+    col10: Date;
+
+
+    @UpdateDateColumn({ default: () => "CURRENT_DATE" })
+    col11: Date;
+
+    @UpdateDateColumn({ default: () => "CURRENT_TIME" })
+    col12: Date;
+
+    @UpdateDateColumn({ default: () => "CURRENT_TIMESTAMP" })
+    col13: Date;
+
+    @UpdateDateColumn({ precision: 3,  default: () => "CURRENT_TIMESTAMP" })
+    col14: Date;
+
+    @UpdateDateColumn({ default: () => "NOW()" })
+    col15: Date;
+}
diff --git a/test/github-issues/3991/issue-3991.ts b/test/github-issues/3991/issue-3991.ts
new file mode 100644
index 000000000..3e7ad90ba
--- /dev/null
+++ b/test/github-issues/3991/issue-3991.ts
@@ -0,0 +1,155 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {createTestingConnections, closeTestingConnections} from "../../utils/test-utils";
+import {Post as CockroachPost} from "./entity/cockroachdb/Post";
+import {Post as MssqlPost} from "./entity/mssql/Post";
+import {Post as MysqlPost} from "./entity/mysql/Post";
+import {Post as PostgresPost} from "./entity/postgres/Post";
+import {Post as OraclePost} from "./entity/oracle/Post";
+import {Post as SqlitePost} from "./entity/sqlite/Post";
+
+describe("github issues > #3991 Migration keeps changing @CreateDateColumn/@UpdateDateColumn timestamp column to same definition", () => {
+    describe("postgres", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["postgres"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [PostgresPost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("cockroachdb", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["cockroachdb"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [CockroachPost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("oracle", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["oracle"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [OraclePost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("sqlite", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["sqlite"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [SqlitePost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("mysql, mariadb", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["mysql", "mariadb"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [MysqlPost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("mssql", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["mssql"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [MssqlPost],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+});
diff --git a/test/github-issues/4658/entity/User.ts b/test/github-issues/4658/entity/User.ts
new file mode 100644
index 000000000..c008d7bed
--- /dev/null
+++ b/test/github-issues/4658/entity/User.ts
@@ -0,0 +1,17 @@
+import {Entity} from "../../../../src";
+import {PrimaryColumn} from "../../../../src";
+import {CreateDateColumn, UpdateDateColumn} from "../../../../src";
+
+@Entity()
+export class User {
+
+    @PrimaryColumn()
+    id: number;
+
+    @CreateDateColumn()
+    created_at: number;
+
+    @UpdateDateColumn()
+    updated_at: string;
+
+}
diff --git a/test/github-issues/4658/issue-4658.ts b/test/github-issues/4658/issue-4658.ts
new file mode 100644
index 000000000..806c6852d
--- /dev/null
+++ b/test/github-issues/4658/issue-4658.ts
@@ -0,0 +1,66 @@
+import "reflect-metadata";
+import {expect} from "chai";
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+
+describe("query runner > rename column", () => {
+
+    let connections: Connection[];
+    before(async () => {
+        connections = await createTestingConnections({
+            entities: [__dirname + "/entity/*{.js,.ts}"],
+            schemaCreate: true,
+            dropSchema: true,
+        });
+    });
+    after(() => closeTestingConnections(connections));
+
+    it("should correctly rename column and revert rename", () => Promise.all(connections.map(async connection => {
+
+        const queryRunner = connection.createQueryRunner();
+
+        let table = await queryRunner.getTable("user");
+
+        await queryRunner.renameColumn(table!, "created_at", "createdAt");
+        await queryRunner.renameColumn(table!, "updated_at", "updatedAt");
+
+        table = await queryRunner.getTable("user");
+        expect(table!.findColumnByName("created_at")).to.be.undefined;
+        expect(table!.findColumnByName("updated_at")).to.be.undefined;
+        table!.findColumnByName("createdAt")!.should.be.exist;
+        table!.findColumnByName("updatedAt")!.should.be.exist;
+
+        await queryRunner.executeMemoryDownSql();
+
+        table = await queryRunner.getTable("user");
+        table!.findColumnByName("created_at")!.should.be.exist;
+        table!.findColumnByName("updated_at")!.should.be.exist;
+        expect(table!.findColumnByName("createdAt")).to.be.undefined;
+        expect(table!.findColumnByName("updatedAt")).to.be.undefined;
+
+        await queryRunner.release();
+    })));
+
+    it("should correctly remove column and revert it back", () => Promise.all(connections.map(async connection => {
+
+        const queryRunner = connection.createQueryRunner();
+
+        let table = await queryRunner.getTable("user");
+
+        await queryRunner.dropColumn(table!, "created_at");
+        await queryRunner.dropColumn(table!, "updated_at");
+
+        table = await queryRunner.getTable("user");
+        expect(table!.findColumnByName("created_at")).to.be.undefined;
+        expect(table!.findColumnByName("updated_at")).to.be.undefined;
+
+        await queryRunner.executeMemoryDownSql();
+
+        table = await queryRunner.getTable("user");
+        table!.findColumnByName("created_at")!.should.be.exist;
+        table!.findColumnByName("updated_at")!.should.be.exist;
+
+        await queryRunner.release();
+    })));
+
+});
diff --git a/test/github-issues/6412/entity/ProductBrand.ts b/test/github-issues/6412/entity/ProductBrand.ts
new file mode 100644
index 000000000..9f4e40c38
--- /dev/null
+++ b/test/github-issues/6412/entity/ProductBrand.ts
@@ -0,0 +1,27 @@
+import {BaseEntity, Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn} from "../../../../src";
+
+@Entity()
+export class ProductBrand extends BaseEntity {
+    @PrimaryGeneratedColumn()
+    public id: number;
+
+    @Column()
+    public name: string;
+
+    @CreateDateColumn({
+        name: 'created_at',
+        type: 'datetime',
+        precision: null,
+        default: () => 'CURRENT_TIMESTAMP',
+    })
+    public createdAt: Date;
+
+    @UpdateDateColumn({
+        name: 'updated_at',
+        type: 'datetime',
+        precision: null,
+        default: () => 'CURRENT_TIMESTAMP',
+        onUpdate: 'CURRENT_TIMESTAMP',
+    })
+    public updatedAt: Date;
+}
diff --git a/test/github-issues/6412/issue-6412.ts b/test/github-issues/6412/issue-6412.ts
new file mode 100644
index 000000000..25f6255aa
--- /dev/null
+++ b/test/github-issues/6412/issue-6412.ts
@@ -0,0 +1,28 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {createTestingConnections, closeTestingConnections} from "../../utils/test-utils";
+import {ProductBrand} from "./entity/ProductBrand";
+
+describe("github issues > #6412 Generating migrations when having entities with CreateDateColumn/UpdateDateColumn and default values as CURRENT_TIMESTAMP leads to a lot of redundant queries in resulting migrations", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["mysql", "mariadb"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [ProductBrand],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+});
diff --git a/test/github-issues/7381/entity/PushLog.ts b/test/github-issues/7381/entity/PushLog.ts
new file mode 100644
index 000000000..05af52cb8
--- /dev/null
+++ b/test/github-issues/7381/entity/PushLog.ts
@@ -0,0 +1,27 @@
+import {Column, Entity, Index, PrimaryGeneratedColumn} from "../../../../src";
+
+@Entity()
+@Index(["token"], { unique: false })
+@Index(["created"], { unique: false })
+export class PushLog {
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column()
+    token: string;
+
+    @Column()
+    os: string;
+
+    @Column("text")
+    payload: string;
+
+    @Column("text")
+    response: string;
+
+    @Column()
+    success: boolean;
+
+    @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
+    created: Date;
+}
diff --git a/test/github-issues/7381/issue-7381.ts b/test/github-issues/7381/issue-7381.ts
new file mode 100644
index 000000000..899e29e38
--- /dev/null
+++ b/test/github-issues/7381/issue-7381.ts
@@ -0,0 +1,27 @@
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {PushLog} from "./entity/PushLog";
+
+describe("github issues > #7381 Infinite same ALTERs upon startup (mysql, ver 0.2.30)", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["mysql", "mariadb"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [PushLog],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+})
