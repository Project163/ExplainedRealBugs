diff --git a/src/entity-schema/EntitySchemaTransformer.ts b/src/entity-schema/EntitySchemaTransformer.ts
index 7bcecead9..1150c1a90 100644
--- a/src/entity-schema/EntitySchemaTransformer.ts
+++ b/src/entity-schema/EntitySchemaTransformer.ts
@@ -103,6 +103,9 @@ export class EntitySchemaTransformer {
                     };
                     metadataArgsStorage.generations.push(generationArgs);
                 }
+
+                if (column.unique)
+                    metadataArgsStorage.uniques.push({ target: options.target || options.name, columns: [columnName] });
             });
 
             // add relation metadata args from the schema
diff --git a/test/github-issues/3803/entity/Post.ts b/test/github-issues/3803/entity/Post.ts
new file mode 100644
index 000000000..ad0943fc5
--- /dev/null
+++ b/test/github-issues/3803/entity/Post.ts
@@ -0,0 +1,25 @@
+import {EntitySchemaOptions} from "../../../../src/entity-schema/EntitySchemaOptions";
+
+export class Post {
+    id: number;
+    name: string;
+    title: string;
+}
+
+export const PostSchema: EntitySchemaOptions<Post> = {
+    name: "Post",
+    target: Post,
+    columns: {
+        id: {
+            primary: true,
+            type: Number
+        },
+        name: {
+            type: "varchar",
+            unique: true
+        },
+        title: {
+            type: "varchar"
+        }
+    }
+};
diff --git a/test/github-issues/3803/issue-3803.ts b/test/github-issues/3803/issue-3803.ts
new file mode 100644
index 000000000..fb2b1dff0
--- /dev/null
+++ b/test/github-issues/3803/issue-3803.ts
@@ -0,0 +1,32 @@
+import {MysqlDriver} from "../../../src/driver/mysql/MysqlDriver";
+import {closeTestingConnections, createTestingConnections, reloadTestingDatabases} from "../../utils/test-utils";
+import {Connection} from "../../../src";
+import {EntitySchema} from "../../../src";
+import {Post, PostSchema} from "./entity/Post";
+import {expect} from "chai";
+
+describe("github issues > #3803 column option unique sqlite error", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [new EntitySchema<Post>(PostSchema)],
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    it("should create unique constraints defined in EntitySchema", () => Promise.all(connections.map(async connection => {
+        const queryRunner = connection.createQueryRunner();
+        const table = await queryRunner.getTable("post");
+        await queryRunner.release();
+
+        // MySQL stores unique constraints as unique indices
+        if (connection.driver instanceof MysqlDriver) {
+            expect(table!.indices.length).to.be.equal(1);
+            expect(table!.indices[0].isUnique).to.be.true;
+            expect(table!.indices[0].columnNames[0]).to.be.equal("name");
+
+        } else {
+            expect(table!.uniques.length).to.be.equal(1);
+            expect(table!.uniques[0].columnNames[0]).to.be.equal("name");
+        }
+    })));
+});
