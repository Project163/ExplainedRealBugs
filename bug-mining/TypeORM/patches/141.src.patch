diff --git a/src/query-builder/UpdateQueryBuilder.ts b/src/query-builder/UpdateQueryBuilder.ts
index a61787afd..6067b9e39 100644
--- a/src/query-builder/UpdateQueryBuilder.ts
+++ b/src/query-builder/UpdateQueryBuilder.ts
@@ -518,6 +518,7 @@ export class UpdateQueryBuilder<Entity extends ObjectLiteral>
                         if (
                             column.referencedColumn &&
                             typeof value === "object" &&
+                            !(value instanceof Date) &&
                             value !== null &&
                             !Buffer.isBuffer(value)
                         ) {
diff --git a/test/github-issues/8747/entity/Car.ts b/test/github-issues/8747/entity/Car.ts
new file mode 100644
index 000000000..4f8129823
--- /dev/null
+++ b/test/github-issues/8747/entity/Car.ts
@@ -0,0 +1,29 @@
+import {
+    Column,
+    Entity,
+    PrimaryGeneratedColumn,
+    BaseEntity,
+    OneToMany,
+    JoinColumn,
+    ManyToOne,
+} from "../../../../src"
+import { Record } from "./Record"
+
+@Entity()
+export class Car extends BaseEntity {
+    @PrimaryGeneratedColumn("uuid")
+    uuid: string
+
+    @Column({ type: "timestamp", precision: 3, nullable: true })
+    latestRecordTimestamp?: Date
+
+    @OneToMany(() => Record, (record) => record.car)
+    records: Record[]
+
+    @ManyToOne(() => Record)
+    @JoinColumn([
+        { name: "uuid", referencedColumnName: "carUuid" },
+        { name: "latestRecordTimestamp", referencedColumnName: "timestamp" },
+    ])
+    latestRecord?: Record
+}
diff --git a/test/github-issues/8747/entity/Record.ts b/test/github-issues/8747/entity/Record.ts
new file mode 100644
index 000000000..a3b0d93c4
--- /dev/null
+++ b/test/github-issues/8747/entity/Record.ts
@@ -0,0 +1,21 @@
+import {
+    Column,
+    Entity,
+    BaseEntity,
+    JoinColumn,
+    ManyToOne,
+} from "../../../../src"
+import { Car } from "./Car"
+
+@Entity()
+export class Record extends BaseEntity {
+    @Column({ type: "timestamp", precision: 3, primary: true })
+    timestamp: Date
+
+    @Column({ type: "uuid", primary: true })
+    carUuid: string
+
+    @ManyToOne(() => Car, (car) => car.records, { onDelete: "CASCADE" })
+    @JoinColumn({ name: "carUuid" })
+    car: Car
+}
diff --git a/test/github-issues/8747/issue-8747.ts b/test/github-issues/8747/issue-8747.ts
new file mode 100644
index 000000000..17157112a
--- /dev/null
+++ b/test/github-issues/8747/issue-8747.ts
@@ -0,0 +1,52 @@
+import "../../utils/test-setup"
+import {
+    closeTestingConnections,
+    createTestingConnections,
+    reloadTestingDatabases,
+} from "../../utils/test-utils"
+import { expect } from "chai"
+import { Car } from "./entity/Car"
+import { Record } from "./entity/Record"
+import { DataSource } from "../../../src"
+
+describe("github issues > #8747 QueryBuilder update handles Date objects wrong on a ManyToOne relationship.", () => {
+    let dataSources: DataSource[]
+    before(
+        async () =>
+            (dataSources = await createTestingConnections({
+                enabledDrivers: ["mysql", "postgres", "mariadb"],
+                entities: [__dirname + "/entity/*{.js,.ts}"],
+                schemaCreate: true,
+                dropSchema: true,
+            })),
+    )
+    beforeEach(() => reloadTestingDatabases(dataSources))
+    after(() => closeTestingConnections(dataSources))
+
+    it("should correctly update the datetime field", async () => {
+        for (const dataSource of dataSources) {
+            Car.useDataSource(dataSource)
+            Record.useDataSource(dataSource)
+            const car = await Car.create({}).save()
+
+            const record = await Record.create({
+                timestamp: new Date(),
+                car,
+            }).save()
+
+            await Car.update(
+                { uuid: car.uuid },
+                { latestRecordTimestamp: record.timestamp },
+            )
+
+            const carReloaded = await Car.findOne({
+                where: { uuid: car.uuid },
+            })
+
+            expect(carReloaded).to.exist
+            expect(record.timestamp?.getTime()).to.be.equal(
+                carReloaded!.latestRecordTimestamp?.getTime(),
+            )
+        }
+    })
+})
