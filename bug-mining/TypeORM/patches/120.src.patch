diff --git a/docs/connection-options.md b/docs/connection-options.md
index de82f7294..9c590de34 100644
--- a/docs/connection-options.md
+++ b/docs/connection-options.md
@@ -189,6 +189,8 @@ See [SSL options](https://github.com/mysqljs/mysql#ssl-options).
 
 * `logNotifications` - A boolean to determine whether postgres server [notice messages](https://www.postgresql.org/docs/current/plpgsql-errors-and-messages.html) and [notification events](https://www.postgresql.org/docs/current/sql-notify.html) should be included in client's logs with `info` level (default: `false`).
 
+* `installExtensions` - A boolean to control whether to install necessary postgres extensions automatically or not (default: `true`)
+
 ## `sqlite` connection options
 
 * `database` - Database path. For example "./mydb.sql"
diff --git a/src/driver/postgres/PostgresConnectionOptions.ts b/src/driver/postgres/PostgresConnectionOptions.ts
index e37fc4d39..1353c3713 100644
--- a/src/driver/postgres/PostgresConnectionOptions.ts
+++ b/src/driver/postgres/PostgresConnectionOptions.ts
@@ -62,4 +62,9 @@ export interface PostgresConnectionOptions extends BaseConnectionOptions, Postgr
      * Include notification messages from Postgres server in client logs
      */
     readonly logNotifications?: boolean;
+
+    /**
+     * Automatically install postgres extensions
+     */
+     readonly installExtensions?: boolean;
 }
diff --git a/src/driver/postgres/PostgresDriver.ts b/src/driver/postgres/PostgresDriver.ts
index 8aa7c7b6f..14ab165a7 100644
--- a/src/driver/postgres/PostgresDriver.ts
+++ b/src/driver/postgres/PostgresDriver.ts
@@ -308,8 +308,9 @@ export class PostgresDriver implements Driver {
     async afterConnect(): Promise<void> {
         const extensionsMetadata = await this.checkMetadataForExtensions();
 
-        if (extensionsMetadata.hasExtensions) {
-            return new Promise<void>((ok, fail) => {
+        const installExtensions = this.options.installExtensions === undefined || this.options.installExtensions;
+        if (installExtensions && extensionsMetadata.hasExtensions) {
+                       return new Promise<void>((ok, fail) => {
                 this.master.connect(async (err: any, connection: any, release: Function) => {
                     await this.enableExtensions(extensionsMetadata, connection);
                     if (err) return fail(err);
@@ -1093,6 +1094,7 @@ export class PostgresDriver implements Driver {
      */
     protected executeQuery(connection: any, query: string) {
         return new Promise((ok, fail) => {
+            this.connection.logger.logQuery(query);
             connection.query(query, (err: any, result: any) => {
                 if (err) return fail(err);
                 ok(result);
diff --git a/test/github-issues/7662/entity/Dummy_UUID.ts b/test/github-issues/7662/entity/Dummy_UUID.ts
new file mode 100644
index 000000000..362d6c80a
--- /dev/null
+++ b/test/github-issues/7662/entity/Dummy_UUID.ts
@@ -0,0 +1,8 @@
+import { Entity } from "../../../../src/decorator/entity/Entity";
+import { PrimaryGeneratedColumn } from "../../../../src/decorator/columns/PrimaryGeneratedColumn";
+
+@Entity()
+export class Dummy {
+    @PrimaryGeneratedColumn("uuid")
+    id: string;
+}
diff --git a/test/github-issues/7662/issue-7662.ts b/test/github-issues/7662/issue-7662.ts
new file mode 100644
index 000000000..57f106885
--- /dev/null
+++ b/test/github-issues/7662/issue-7662.ts
@@ -0,0 +1,105 @@
+import { expect } from "chai";
+import { Connection } from "../../../src/connection/Connection";
+import {
+    createTestingConnections,
+    closeTestingConnections,
+} from "../../utils/test-utils";
+import { MemoryLogger } from "./memory-logger";
+
+describe("github issues > #7662 postgres extensions installation should be optional", function () {
+    it("should NOT install extensions if option is disabled", async function () {
+        let connection: Connection | null = null;
+        try {
+            const connections = await createTestingConnections({
+                entities: [`${__dirname}/entity/*{.js,.ts}`],
+                enabledDrivers: ["postgres"],
+                schemaCreate: false,
+                dropSchema: true,
+                createLogger: () => new MemoryLogger(true),
+                driverSpecific: {
+                    installExtensions: false,
+                },
+            });
+
+            if (connections.length < 1) {
+                this.skip();
+                return;
+            }
+
+            connection = connections[0];
+
+            const logger = connection.logger as MemoryLogger;
+            const createExtensionQueries = logger.queries.filter((q) =>
+                q.startsWith("CREATE EXTENSION IF NOT EXISTS")
+            );
+
+            expect(createExtensionQueries).to.be.empty;
+        } finally {
+            if (connection) {
+                const logger = connection.logger as MemoryLogger;
+                logger.clear();
+                await closeTestingConnections([connection]);
+            }
+        }
+    });
+
+    it("should install extensions if option is undefined", async function () {
+        let connections: Connection[] = [];
+        try {
+            connections = await createTestingConnections({
+                entities: [`${__dirname}/entity/*{.js,.ts}`],
+                enabledDrivers: ["postgres"],
+                schemaCreate: false,
+                dropSchema: true,
+                createLogger: () => new MemoryLogger(true),
+            });
+
+            if (connections.length < 1) {
+                this.skip();
+                return;
+            }
+
+            const connection = connections[0];
+
+            const logger = connection.logger as MemoryLogger;
+            const createExtensionQueries = logger.queries.filter((q) =>
+                q.startsWith("CREATE EXTENSION IF NOT EXISTS")
+            );
+
+            expect(createExtensionQueries).to.have.length(1);
+        } finally {
+            await closeTestingConnections(connections);
+        }
+    });
+
+    it("should install extensions if option is enabled", async function () {
+        let connections: Connection[] = [];
+        try {
+            connections = await createTestingConnections({
+                entities: [`${__dirname}/entity/*{.js,.ts}`],
+                enabledDrivers: ["postgres"],
+                schemaCreate: false,
+                dropSchema: true,
+                createLogger: () => new MemoryLogger(true),
+                driverSpecific: {
+                    installExtensions: true,
+                },
+            });
+
+            if (connections.length < 1) {
+                this.skip();
+            }
+
+            const connection = connections[0];
+
+            const logger = connection.logger as MemoryLogger;
+            const createExtensionQueries = logger.queries.filter((q) =>
+                q.startsWith("CREATE EXTENSION IF NOT EXISTS")
+            );
+
+            expect(createExtensionQueries).to.have.length(1);
+        } finally {
+            await closeTestingConnections(connections);
+        }
+    });
+});
diff --git a/test/github-issues/7662/memory-logger.ts b/test/github-issues/7662/memory-logger.ts
new file mode 100644
index 000000000..3221760f9
--- /dev/null
+++ b/test/github-issues/7662/memory-logger.ts
@@ -0,0 +1,28 @@
+import {Logger} from "../../../src/logger/Logger";
+
+export class MemoryLogger implements Logger {
+    constructor(public enabled = true) {}
+
+    private _queries: string[] = [];
+    get queries() { return this._queries; }
+
+    logQuery(query: string) {
+        if (this.enabled) {
+            this._queries.push(query);
+        }
+    }
+
+    logQueryError(error: string, query: string) {}
+
+    logQuerySlow(time: number, query: string) {}
+
+    logSchemaBuild(message: string) {}
+
+    logMigration(message: string) {}
+
+    log(level: "log" | "info" | "warn", message: any) {}
+
+    clear() {
+        this._queries = [];
+    }
+}
