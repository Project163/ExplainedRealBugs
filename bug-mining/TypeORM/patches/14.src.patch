diff --git a/src/metadata/EntityMetadata.ts b/src/metadata/EntityMetadata.ts
index f34aa83b7..257dde271 100644
--- a/src/metadata/EntityMetadata.ts
+++ b/src/metadata/EntityMetadata.ts
@@ -109,13 +109,13 @@ export class EntityMetadata {
 
     /**
      * Entity table path. Contains database name, schema name and table name.
-     * E.g. "myDB"."mySchema"."myTable"
+     * E.g. myDB.mySchema.myTable
      */
     tablePath: string;
 
     /**
      * Entity schema path. Contains database name and schema name.
-     * E.g. "myDB"."mySchema"
+     * E.g. myDB.mySchema
      */
     schemaPath?: string;
 
diff --git a/src/persistence/tree/ClosureSubjectExecutor.ts b/src/persistence/tree/ClosureSubjectExecutor.ts
index f8fd8e86f..0a88e3451 100644
--- a/src/persistence/tree/ClosureSubjectExecutor.ts
+++ b/src/persistence/tree/ClosureSubjectExecutor.ts
@@ -62,7 +62,7 @@ export class ClosureSubjectExecutor {
 
         if (parent) {
             const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);
-            const tableName = escape(subject.metadata.closureJunctionTable.tablePath); // todo: make sure to properly escape table path, not just a table name
+            const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);
             const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {
                 return escape(column.databaseName);
             });
@@ -85,6 +85,7 @@ export class ClosureSubjectExecutor {
                 const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.databaseName, firstQueryParameters.length - 1);
                 return columnName + " = " + parameterName;
             }).join(", ");
+
             await this.queryRunner.query(
                 `INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(", ")}) ` +
                 `SELECT ${ancestorColumnNames.join(", ")}, ${childEntityIds1.join(", ")} FROM ${tableName} WHERE ${whereCondition}`,
@@ -93,4 +94,19 @@ export class ClosureSubjectExecutor {
         }
     }
 
+    /**
+     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
+     * schema name, otherwise returns escaped table name.
+     */
+    protected getTableName(tablePath: string): string {
+        return tablePath.split(".")
+            .map(i => {
+                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
+                if (i === "")
+                    return i;
+                return this.queryRunner.connection.driver.escape(i);
+            }).join(".");
+    }
+
+
 }
\ No newline at end of file
