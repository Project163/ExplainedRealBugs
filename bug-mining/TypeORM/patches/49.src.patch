diff --git a/src/driver/mysql/MysqlQueryRunner.ts b/src/driver/mysql/MysqlQueryRunner.ts
index 49a1fcacf..1a990e83f 100644
--- a/src/driver/mysql/MysqlQueryRunner.ts
+++ b/src/driver/mysql/MysqlQueryRunner.ts
@@ -1316,7 +1316,11 @@ export class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {
             }), dbIndex => dbIndex["INDEX_NAME"]);
 
             table.indices = tableIndexConstraints.map(constraint => {
-                const indices = dbIndices.filter(index => index["INDEX_NAME"] === constraint["INDEX_NAME"]);
+                const indices = dbIndices.filter(index => {
+                    return index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"]
+                        && index["TABLE_NAME"] === constraint["TABLE_NAME"]
+                        && index["INDEX_NAME"] === constraint["INDEX_NAME"];
+                });
                 return new TableIndex(<TableIndexOptions>{
                     table: table,
                     name: constraint["INDEX_NAME"],
diff --git a/src/driver/oracle/OracleQueryRunner.ts b/src/driver/oracle/OracleQueryRunner.ts
index 290029ebe..f4da02903 100644
--- a/src/driver/oracle/OracleQueryRunner.ts
+++ b/src/driver/oracle/OracleQueryRunner.ts
@@ -1242,7 +1242,7 @@ export class OracleQueryRunner extends BaseQueryRunner implements QueryRunner {
 
             // create TableIndex objects from the loaded indices
             table.indices = dbIndices
-                .filter(dbIndex => dbIndex["TABLE_NAME"] === table.name )
+                .filter(dbIndex => dbIndex["TABLE_NAME"] === table.name)
                 .map(dbIndex => {
                     return new TableIndex({
                         name: dbIndex["INDEX_NAME"],
diff --git a/src/driver/postgres/PostgresQueryRunner.ts b/src/driver/postgres/PostgresQueryRunner.ts
index ea618c05c..7c872f2df 100644
--- a/src/driver/postgres/PostgresQueryRunner.ts
+++ b/src/driver/postgres/PostgresQueryRunner.ts
@@ -1559,7 +1559,11 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
             }), dbIndex => dbIndex["constraint_name"]);
 
             table.indices = tableIndexConstraints.map(constraint => {
-                const indices = dbIndices.filter(index => index["constraint_name"] === constraint["constraint_name"]);
+                const indices = dbIndices.filter(index => {
+                    return index["table_schema"] === constraint["table_schema"]
+                        && index["table_name"] === constraint["table_name"]
+                        && index["constraint_name"] === constraint["constraint_name"];
+                });
                 return new TableIndex(<TableIndexOptions>{
                     table: table,
                     name: constraint["constraint_name"],
diff --git a/src/driver/sqlserver/SqlServerQueryRunner.ts b/src/driver/sqlserver/SqlServerQueryRunner.ts
index 29417b000..20da28456 100644
--- a/src/driver/sqlserver/SqlServerQueryRunner.ts
+++ b/src/driver/sqlserver/SqlServerQueryRunner.ts
@@ -1659,7 +1659,12 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
             }), dbIndex => dbIndex["INDEX_NAME"]);
 
             table.indices = tableIndexConstraints.map(constraint => {
-                const indices = dbIndices.filter(index => index["INDEX_NAME"] === constraint["INDEX_NAME"]);
+                const indices = dbIndices.filter(index => {
+                    return index["TABLE_CATALOG"] === constraint["TABLE_CATALOG"]
+                        && index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"]
+                        && index["TABLE_NAME"] === constraint["TABLE_NAME"]
+                        && index["INDEX_NAME"] === constraint["INDEX_NAME"];
+                });
                 return new TableIndex(<TableIndexOptions>{
                     table: table,
                     name: constraint["INDEX_NAME"],
diff --git a/test/github-issues/1960/issue-1960.ts b/test/github-issues/1960/issue-1960.ts
index be6a6602f..145a6b898 100644
--- a/test/github-issues/1960/issue-1960.ts
+++ b/test/github-issues/1960/issue-1960.ts
@@ -16,7 +16,6 @@ describe.skip("github issues > #1960 Migration generator produces duplicated cha
 
     it("should not execute any alter queries", () => Promise.all(connections.map(async function(connection) {
         const sqlInMemory = await connection.driver.createSchemaBuilder().log();
-        console.log(sqlInMemory);
         sqlInMemory.upQueries.length.should.be.equal(0);
     })));
 
diff --git a/test/github-issues/3379/entity/Post.ts b/test/github-issues/3379/entity/Post.ts
new file mode 100644
index 000000000..7437aab22
--- /dev/null
+++ b/test/github-issues/3379/entity/Post.ts
@@ -0,0 +1,15 @@
+import {Index, PrimaryGeneratedColumn} from "../../../../src";
+import {Column} from "../../../../src";
+import {Entity} from "../../../../src";
+
+@Index("name_index", ["name"])
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column()
+    name: string;
+
+}
diff --git a/test/github-issues/3379/issue-3379.ts b/test/github-issues/3379/issue-3379.ts
new file mode 100644
index 000000000..f8266b12d
--- /dev/null
+++ b/test/github-issues/3379/issue-3379.ts
@@ -0,0 +1,83 @@
+import "reflect-metadata";
+import {MysqlDriver} from "../../../src/driver/mysql/MysqlDriver";
+import {PostgresDriver} from "../../../src/driver/postgres/PostgresDriver";
+import {AbstractSqliteDriver} from "../../../src/driver/sqlite-abstract/AbstractSqliteDriver";
+import {SqlServerDriver} from "../../../src/driver/sqlserver/SqlServerDriver";
+import {createTestingConnections, closeTestingConnections, reloadTestingDatabases} from "../../utils/test-utils";
+import {Connection, Table} from "../../../src";
+
+describe("github issues > #3379 Migration will keep create and drop indexes if index name is the same across tables", () => {
+
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [__dirname + "/entity/*{.js,.ts}"]
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    it("should not recreate indices", () => Promise.all(connections.map(async connection => {
+
+        const queryRunner = connection.createQueryRunner();
+
+        let postTableName: string = "post";
+
+        if (connection.driver instanceof SqlServerDriver) {
+            postTableName = "testDB.testSchema.post";
+            await queryRunner.createDatabase("testDB", true);
+            await queryRunner.createSchema("testDB.testSchema", true);
+
+        } else if (connection.driver instanceof PostgresDriver) {
+            postTableName = "testSchema.post";
+            await queryRunner.createSchema("testSchema", true);
+
+        } else if (connection.driver instanceof MysqlDriver) {
+            postTableName = "testDB.post";
+            await queryRunner.createDatabase("testDB", true);
+        }
+
+        await queryRunner.createTable(new Table({
+            name: postTableName,
+            columns: [
+                {
+                    name: "id",
+                    type: connection.driver instanceof AbstractSqliteDriver ? "integer" : "int",
+                    isPrimary: true,
+                    isGenerated: true,
+                    generationStrategy: "increment"
+                },
+                {
+                    name: "name",
+                    type: "varchar",
+                }
+            ],
+            indices: [{ name: "name_index", columnNames: ["name"] }]
+        }), true);
+
+        // Only MySQL and SQLServer allows non unique index names
+        if (connection.driver instanceof MysqlDriver || connection.driver instanceof SqlServerDriver) {
+            await queryRunner.createTable(new Table({
+                name: "category",
+                columns: [
+                    {
+                        name: "id",
+                        type: "int",
+                        isPrimary: true,
+                        isGenerated: true,
+                        generationStrategy: "increment"
+                    },
+                    {
+                        name: "name",
+                        type: "varchar",
+                    }
+                ],
+                indices: [{ name: "name_index", columnNames: ["name"] }]
+            }), true);
+        }
+
+        await queryRunner.release();
+
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+    })));
+
+});
