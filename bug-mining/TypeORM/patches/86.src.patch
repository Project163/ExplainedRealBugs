diff --git a/src/query-builder/QueryBuilder.ts b/src/query-builder/QueryBuilder.ts
index eda2e4054..1b1d8ef0d 100644
--- a/src/query-builder/QueryBuilder.ts
+++ b/src/query-builder/QueryBuilder.ts
@@ -797,6 +797,9 @@ export abstract class QueryBuilder<Entity> {
 
         if (where instanceof Brackets) {
             const whereQueryBuilder = this.createQueryBuilder();
+            whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;
+            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;
+            whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;
             where.whereFactory(whereQueryBuilder as any);
             const whereString = whereQueryBuilder.createWhereExpressionString();
             this.setParameters(whereQueryBuilder.getParameters());
diff --git a/test/github-issues/3685/entity/user.ts b/test/github-issues/3685/entity/user.ts
new file mode 100644
index 000000000..6c6c64daa
--- /dev/null
+++ b/test/github-issues/3685/entity/user.ts
@@ -0,0 +1,15 @@
+import { Column, Entity, PrimaryGeneratedColumn } from "../../../../src";
+
+@Entity()
+export class User {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column()
+    firstName: string;
+
+    @Column()
+    lastName: string;
+
+}
diff --git a/test/github-issues/3685/issue-3685.ts b/test/github-issues/3685/issue-3685.ts
new file mode 100644
index 000000000..70fd13a68
--- /dev/null
+++ b/test/github-issues/3685/issue-3685.ts
@@ -0,0 +1,62 @@
+import {expect} from "chai";
+import {Brackets, Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections, reloadTestingDatabases} from "../../utils/test-utils";
+import {User} from "./entity/user";
+
+describe("github issues > #3685 Brackets syntax failed when use where with object literal", () => {
+
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [__dirname + "/entity/*{.js,.ts}"],
+        dropSchema: true,
+        schemaCreate: true,
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => connections && closeTestingConnections(connections));
+
+    it("should accept objects in .where method (github issue #3685)", () => Promise.all(connections.map(async connection => {
+
+        await Promise.all([
+            connection.manager.save(Object.assign(new User(), {
+                firstName: "Jean",
+                lastName: "Doe",
+            })),
+
+            connection.manager.save(Object.assign(new User(), {
+                firstName: "John",
+                lastName: "Doe",
+            })),
+
+            connection.manager.save(Object.assign(new User(), {
+                firstName: "John",
+                lastName: "Dupont",
+            })),
+
+            connection.manager.save(Object.assign(new User(), {
+                firstName: "Fred",
+                lastName: "Doe",
+            }))
+        ]);
+
+        const qb = connection.createQueryBuilder(User, "u")
+            .where(new Brackets(qb => {
+                qb.where({ firstName: "John" })
+                    .orWhere("u.firstName = :firstName", { firstName: "Jean" });
+            }))
+            .andWhere("u.lastName = :lastName", { lastName: "Doe" })
+            .orderBy({
+                "u.firstName": "ASC",
+                "u.lastName": "ASC",
+            });
+
+        const results = await qb.getMany();
+
+        expect(results.length).to.equal(2);
+
+        expect(results[0].firstName).to.equal("Jean");
+        expect(results[0].lastName).to.equal("Doe");
+
+        expect(results[1].firstName).to.equal("John");
+        expect(results[1].lastName).to.equal("Doe");
+    })));
+});
