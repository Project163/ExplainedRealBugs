diff --git a/src/metadata/UniqueMetadata.ts b/src/metadata/UniqueMetadata.ts
index dc72c0fa0..e580dd263 100644
--- a/src/metadata/UniqueMetadata.ts
+++ b/src/metadata/UniqueMetadata.ts
@@ -50,6 +50,12 @@ export class UniqueMetadata {
      */
     name: string;
 
+    /**
+     * Map of column names with order set.
+     * Used only by MongoDB driver.
+     */
+    columnNamesWithOrderingMap: { [key: string]: number } = {};
+
     // ---------------------------------------------------------------------
     // Constructor
     // ---------------------------------------------------------------------
@@ -122,6 +128,15 @@ export class UniqueMetadata {
             })
             .reduce((a, b) => a.concat(b));
         }
+
+        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key) => {
+            const column = this.entityMetadata.columns.find(column => column.propertyPath === key);
+            if (column)
+                updatedMap[column.databasePath] = map[key];
+
+            return updatedMap;
+        }, {} as { [key: string]: number });
+
         this.name = this.givenName ? this.givenName : namingStrategy.uniqueConstraintName(this.entityMetadata.tablePath, this.columns.map(column => column.databaseName));
         return this;
     }
diff --git a/src/schema-builder/MongoSchemaBuilder.ts b/src/schema-builder/MongoSchemaBuilder.ts
index bd99ee62d..c3f58490d 100644
--- a/src/schema-builder/MongoSchemaBuilder.ts
+++ b/src/schema-builder/MongoSchemaBuilder.ts
@@ -39,9 +39,22 @@ export class MongoSchemaBuilder implements SchemaBuilder {
         const promises: Promise<any>[] = [];
         this.connection.entityMetadatas.forEach(metadata => {
             metadata.indices.forEach(index => {
-                const options = <MongodbIndexOptions>{ name: index.name, unique: index.isUnique, sparse: index.isSparse, background: index.isBackground, expireAfterSeconds: index.expireAfterSeconds };
+                const options = <MongodbIndexOptions>{
+                    name: index.name,
+                    unique: index.isUnique,
+                    sparse: index.isSparse,
+                    background: index.isBackground,
+                    expireAfterSeconds: index.expireAfterSeconds
+                };
                 promises.push(queryRunner.createCollectionIndex(metadata.tableName, index.columnNamesWithOrderingMap, options));
             });
+            metadata.uniques.forEach(unique => {
+                const options = <MongodbIndexOptions>{
+                    name: unique.name,
+                    unique: true,
+                };
+                promises.push(queryRunner.createCollectionIndex(metadata.tableName, unique.columnNamesWithOrderingMap, options));
+            });
         });
         await Promise.all(promises);
     }
