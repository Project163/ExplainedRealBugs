diff --git a/docs/decorator-reference.md b/docs/decorator-reference.md
index 9d25d2f08..2f5f133ee 100644
--- a/docs/decorator-reference.md
+++ b/docs/decorator-reference.md
@@ -14,6 +14,7 @@
         -   [`@DeleteDateColumn`](#deletedatecolumn)
         -   [`@VersionColumn`](#versioncolumn)
         -   [`@Generated`](#generated)
+        -   [`@VirtualColumn`](#virtualcolumn)
     -   [Relation decorators](#relation-decorators)
         -   [`@OneToOne`](#onetoone)
         -   [`@ManyToOne`](#manytoone)
@@ -374,6 +375,34 @@ export class User {
 
 Value will be generated only once, before inserting the entity into the database.
 
+#### `@VirtualColumn`
+
+Special column that is never saved to the database and thus acts as a readonly property.
+Each time you call `find` or `findOne` from the entity manager, the value is recalculated based on the query function that was provided in the VirtualColumn Decorator. The alias argument passed to the query references the exact entity alias of the generated query behind the scenes.
+
+```typescript
+@Entity({ name: "companies", alias: "COMP" })
+export class Company extends BaseEntity {
+  @PrimaryColumn("varchar", { length: 50 })
+  name: string;
+
+  @VirtualColumn({ query: (alias) => `SELECT COUNT("name") FROM "employees" WHERE "companyName" = ${alias}.name` })
+  totalEmployeesCount: number;
+
+  @OneToMany((type) => Employee, (employee) => employee.company)
+  employees: Employee[];
+}
+
+@Entity({ name: "employees" })
+export class Employee extends BaseEntity {
+  @PrimaryColumn("varchar", { length: 50 })
+  name: string;
+
+  @ManyToOne((type) => Company, (company) => company.employees)
+  company: Company;
+}
+```
+
 ## Relation decorators
 
 #### `@OneToOne`
diff --git a/src/decorator/columns/VirtualColumn.ts b/src/decorator/columns/VirtualColumn.ts
new file mode 100644
index 000000000..b5ef19696
--- /dev/null
+++ b/src/decorator/columns/VirtualColumn.ts
@@ -0,0 +1,74 @@
+import { ColumnType } from "../../driver/types/ColumnTypes"
+import { ColumnTypeUndefinedError } from "../../error"
+import { getMetadataArgsStorage } from "../../globals"
+import { ColumnMetadataArgs } from "../../metadata-args/ColumnMetadataArgs"
+import { VirtualColumnOptions } from "../options/VirtualColumnOptions"
+/**
+ * VirtualColumn decorator is used to mark a specific class property as a Virtual column.
+ */
+export function VirtualColumn(options: VirtualColumnOptions): PropertyDecorator
+
+/**
+ * VirtualColumn decorator is used to mark a specific class property as a Virtual column.
+ */
+export function VirtualColumn(
+    typeOrOptions: ColumnType,
+    options: VirtualColumnOptions,
+): PropertyDecorator
+
+/**
+ * VirtualColumn decorator is used to mark a specific class property as a Virtual column.
+ */
+export function VirtualColumn(
+    typeOrOptions?: ColumnType | VirtualColumnOptions,
+    options?: VirtualColumnOptions,
+): PropertyDecorator {
+    return function (object: Object, propertyName: string) {
+        // normalize parameters
+        let type: ColumnType | undefined
+        if (typeof typeOrOptions === "string") {
+            type = <ColumnType>typeOrOptions
+        } else {
+            options = <VirtualColumnOptions>typeOrOptions
+            type = options.type
+        }
+
+        if (!options?.query) {
+            throw new Error(
+                "Column options must be defined for calculated columns.",
+            )
+        }
+
+        // if type is not given explicitly then try to guess it
+        const reflectMetadataType =
+            Reflect && (Reflect as any).getMetadata
+                ? (Reflect as any).getMetadata(
+                      "design:type",
+                      object,
+                      propertyName,
+                  )
+                : undefined
+        if (!type && reflectMetadataType)
+            // if type is not given explicitly then try to guess it
+            type = reflectMetadataType
+
+        // check if there is no type in column options then set type from first function argument, or guessed one
+        if (type) options.type = type
+
+        // specify HSTORE type if column is HSTORE
+        if (options.type === "hstore" && !options.hstoreType)
+            options.hstoreType =
+                reflectMetadataType === Object ? "object" : "string"
+
+        // if we still don't have a type then we need to give error to user that type is required
+        if (!options.type)
+            throw new ColumnTypeUndefinedError(object, propertyName)
+
+        getMetadataArgsStorage().columns.push({
+            target: object.constructor,
+            propertyName: propertyName,
+            mode: "virtual-property",
+            options: options || {},
+        } as ColumnMetadataArgs)
+    }
+}
diff --git a/src/decorator/options/VirtualColumnOptions.ts b/src/decorator/options/VirtualColumnOptions.ts
new file mode 100644
index 000000000..fb74fb319
--- /dev/null
+++ b/src/decorator/options/VirtualColumnOptions.ts
@@ -0,0 +1,31 @@
+import { ColumnType } from "../../driver/types/ColumnTypes"
+import { ValueTransformer } from "./ValueTransformer"
+
+/**
+ * Describes all calculated column's options.
+ */
+export interface VirtualColumnOptions {
+    /**
+     * Column type. Must be one of the value from the ColumnTypes class.
+     */
+    type?: ColumnType
+
+    /**
+     * Return type of HSTORE column.
+     * Returns value as string or as object.
+     */
+    hstoreType?: "object" | "string"
+
+    /**
+     * Query to be used to populate the column data. This query is used when generating the relational db script.
+     * The query function is called with the current entities alias either defined by the Entity Decorator or automatically
+     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.
+     */
+    query: (alias: string) => string
+
+    /**
+     * Specifies a value transformer(s) that is to be used to unmarshal
+     * this column when reading from the database.
+     */
+    transformer?: ValueTransformer | ValueTransformer[]
+}
diff --git a/src/driver/aurora-mysql/AuroraMysqlDriver.ts b/src/driver/aurora-mysql/AuroraMysqlDriver.ts
index 54a9de4c9..b485ae6e1 100644
--- a/src/driver/aurora-mysql/AuroraMysqlDriver.ts
+++ b/src/driver/aurora-mysql/AuroraMysqlDriver.ts
@@ -633,6 +633,9 @@ export class AuroraMysqlDriver implements Driver {
         ) {
             // convert to number if that exists in possible enum options
             value = parseInt(value)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/mysql/MysqlDriver.ts b/src/driver/mysql/MysqlDriver.ts
index 47b35487f..25fd52e1e 100644
--- a/src/driver/mysql/MysqlDriver.ts
+++ b/src/driver/mysql/MysqlDriver.ts
@@ -634,6 +634,9 @@ export class MysqlDriver implements Driver {
             return "" + value
         } else if (columnMetadata.type === "set") {
             return DateUtils.simpleArrayToString(value)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         return value
@@ -683,6 +686,9 @@ export class MysqlDriver implements Driver {
             value = parseInt(value)
         } else if (columnMetadata.type === "set") {
             value = DateUtils.stringToSimpleArray(value)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/oracle/OracleDriver.ts b/src/driver/oracle/OracleDriver.ts
index f1df02409..949a32932 100644
--- a/src/driver/oracle/OracleDriver.ts
+++ b/src/driver/oracle/OracleDriver.ts
@@ -545,6 +545,9 @@ export class OracleDriver implements Driver {
             value = DateUtils.stringToSimpleArray(value)
         } else if (columnMetadata.type === "simple-json") {
             value = DateUtils.stringToSimpleJson(value)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/postgres/PostgresDriver.ts b/src/driver/postgres/PostgresDriver.ts
index 2941696e1..1621f9383 100644
--- a/src/driver/postgres/PostgresDriver.ts
+++ b/src/driver/postgres/PostgresDriver.ts
@@ -801,6 +801,9 @@ export class PostgresDriver implements Driver {
                         ? parseInt(value)
                         : value
             }
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/sap/SapDriver.ts b/src/driver/sap/SapDriver.ts
index 0b4b17190..03a796c6e 100644
--- a/src/driver/sap/SapDriver.ts
+++ b/src/driver/sap/SapDriver.ts
@@ -527,6 +527,9 @@ export class SapDriver implements Driver {
             value = DateUtils.stringToSimpleJson(value)
         } else if (columnMetadata.type === "simple-enum") {
             value = DateUtils.stringToSimpleEnum(value, columnMetadata)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/spanner/SpannerDriver.ts b/src/driver/spanner/SpannerDriver.ts
index f4e9f102d..6a53fa3cb 100644
--- a/src/driver/spanner/SpannerDriver.ts
+++ b/src/driver/spanner/SpannerDriver.ts
@@ -439,6 +439,9 @@ export class SpannerDriver implements Driver {
             value = DateUtils.mixedDateToDateString(value)
         } else if (columnMetadata.type === "json") {
             value = typeof value === "string" ? JSON.parse(value) : value
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/sqlite-abstract/AbstractSqliteDriver.ts b/src/driver/sqlite-abstract/AbstractSqliteDriver.ts
index f94cbb68e..d0ae3df76 100644
--- a/src/driver/sqlite-abstract/AbstractSqliteDriver.ts
+++ b/src/driver/sqlite-abstract/AbstractSqliteDriver.ts
@@ -410,6 +410,9 @@ export abstract class AbstractSqliteDriver implements Driver {
             value = DateUtils.stringToSimpleJson(value)
         } else if (columnMetadata.type === "simple-enum") {
             value = DateUtils.stringToSimpleEnum(value, columnMetadata)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/driver/sqlserver/SqlServerDriver.ts b/src/driver/sqlserver/SqlServerDriver.ts
index 01781cced..e44c6451e 100644
--- a/src/driver/sqlserver/SqlServerDriver.ts
+++ b/src/driver/sqlserver/SqlServerDriver.ts
@@ -568,6 +568,9 @@ export class SqlServerDriver implements Driver {
             value = DateUtils.stringToSimpleJson(value)
         } else if (columnMetadata.type === "simple-enum") {
             value = DateUtils.stringToSimpleEnum(value, columnMetadata)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
         }
 
         if (columnMetadata.transformer)
diff --git a/src/index.ts b/src/index.ts
index d91479dff..c7010c5f0 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -22,6 +22,7 @@ export * from "./decorator/columns/PrimaryGeneratedColumn"
 export * from "./decorator/columns/PrimaryColumn"
 export * from "./decorator/columns/UpdateDateColumn"
 export * from "./decorator/columns/VersionColumn"
+export * from "./decorator/columns/VirtualColumn"
 export * from "./decorator/columns/ViewColumn"
 export * from "./decorator/columns/ObjectIdColumn"
 export * from "./decorator/listeners/AfterInsert"
diff --git a/src/metadata-args/types/ColumnMode.ts b/src/metadata-args/types/ColumnMode.ts
index 3a0ae0955..a398a1db3 100644
--- a/src/metadata-args/types/ColumnMode.ts
+++ b/src/metadata-args/types/ColumnMode.ts
@@ -7,6 +7,7 @@
 export type ColumnMode =
     | "regular"
     | "virtual"
+    | "virtual-property"
     | "createDate"
     | "updateDate"
     | "deleteDate"
diff --git a/src/metadata-builder/EntityMetadataValidator.ts b/src/metadata-builder/EntityMetadataValidator.ts
index 5c19a8b43..8862e275a 100644
--- a/src/metadata-builder/EntityMetadataValidator.ts
+++ b/src/metadata-builder/EntityMetadataValidator.ts
@@ -123,29 +123,39 @@ export class EntityMetadataValidator {
         })
 
         if (!(driver.options.type === "mongodb")) {
-            entityMetadata.columns.forEach((column) => {
-                const normalizedColumn = driver.normalizeType(
-                    column,
-                ) as ColumnType
-                if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1)
-                    throw new DataTypeNotSupportedError(
+            entityMetadata.columns
+                .filter((column) => !column.isVirtualProperty)
+                .forEach((column) => {
+                    const normalizedColumn = driver.normalizeType(
                         column,
-                        normalizedColumn,
-                        driver.options.type,
-                    )
-                if (
-                    column.length &&
-                    driver.withLengthColumnTypes.indexOf(normalizedColumn) ===
+                    ) as ColumnType
+                    if (
+                        driver.supportedDataTypes.indexOf(normalizedColumn) ===
                         -1
-                )
-                    throw new TypeORMError(
-                        `Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`,
                     )
-                if (column.type === "enum" && !column.enum && !column.enumName)
-                    throw new TypeORMError(
-                        `Column "${column.propertyName}" of Entity "${entityMetadata.name}" is defined as enum, but missing "enum" or "enumName" properties.`,
+                        throw new DataTypeNotSupportedError(
+                            column,
+                            normalizedColumn,
+                            driver.options.type,
+                        )
+                    if (
+                        column.length &&
+                        driver.withLengthColumnTypes.indexOf(
+                            normalizedColumn,
+                        ) === -1
                     )
-            })
+                        throw new TypeORMError(
+                            `Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`,
+                        )
+                    if (
+                        column.type === "enum" &&
+                        !column.enum &&
+                        !column.enumName
+                    )
+                        throw new TypeORMError(
+                            `Column "${column.propertyName}" of Entity "${entityMetadata.name}" is defined as enum, but missing "enum" or "enumName" properties.`,
+                        )
+                })
         }
 
         if (
diff --git a/src/metadata/ColumnMetadata.ts b/src/metadata/ColumnMetadata.ts
index 868951b37..6f7d9541b 100644
--- a/src/metadata/ColumnMetadata.ts
+++ b/src/metadata/ColumnMetadata.ts
@@ -10,6 +10,7 @@ import { ValueTransformer } from "../decorator/options/ValueTransformer"
 import { ApplyValueTransformers } from "../util/ApplyValueTransformers"
 import { ObjectUtils } from "../util/ObjectUtils"
 import { InstanceChecker } from "../util/InstanceChecker"
+import { VirtualColumnOptions } from "../decorator/options/VirtualColumnOptions"
 
 /**
  * This metadata contains all information about entity's column.
@@ -238,6 +239,20 @@ export class ColumnMetadata {
      */
     isVirtual: boolean = false
 
+    /**
+     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.
+     * This property is used in tandem the virtual column decorator.
+     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.
+     */
+    isVirtualProperty: boolean = false
+
+    /**
+     * Query to be used to populate the column data. This query is used when generating the relational db script.
+     * The query function is called with the current entities alias either defined by the Entity Decorator or automatically
+     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.
+     */
+    query?: (alias: string) => string
+
     /**
      * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
      */
@@ -448,6 +463,7 @@ export class ColumnMetadata {
         if (options.args.options.array)
             this.isArray = options.args.options.array
         if (options.args.mode) {
+            this.isVirtualProperty = options.args.mode === "virtual-property"
             this.isVirtual = options.args.mode === "virtual"
             this.isTreeLevel = options.args.mode === "treeLevel"
             this.isCreateDate = options.args.mode === "createDate"
@@ -456,12 +472,18 @@ export class ColumnMetadata {
             this.isVersion = options.args.mode === "version"
             this.isObjectId = options.args.mode === "objectId"
         }
+        if (this.isVirtualProperty) {
+            this.isInsert = false
+            this.isUpdate = false
+        }
         if (options.args.options.transformer)
             this.transformer = options.args.options.transformer
         if (options.args.options.spatialFeatureType)
             this.spatialFeatureType = options.args.options.spatialFeatureType
         if (options.args.options.srid !== undefined)
             this.srid = options.args.options.srid
+        if ((options.args.options as VirtualColumnOptions).query)
+            this.query = (options.args.options as VirtualColumnOptions).query
         if (this.isTreeLevel)
             this.type = options.connection.driver.mappedDataTypes.treeLevel
         if (this.isCreateDate) {
diff --git a/src/query-builder/SelectQueryBuilder.ts b/src/query-builder/SelectQueryBuilder.ts
index e612efe43..a95813d2f 100644
--- a/src/query-builder/SelectQueryBuilder.ts
+++ b/src/query-builder/SelectQueryBuilder.ts
@@ -2690,11 +2690,17 @@ export class SelectQueryBuilder<Entity extends ObjectLiteral>
               )
             : []
         const allColumns = [...columns, ...nonSelectedPrimaryColumns]
-
         const finalSelects: SelectQuery[] = []
+
+        const escapedAliasName = this.escape(aliasName)
         allColumns.forEach((column) => {
             let selectionPath =
-                this.escape(aliasName) + "." + this.escape(column.databaseName)
+                escapedAliasName + "." + this.escape(column.databaseName)
+
+            if (column.isVirtualProperty && column.query) {
+                selectionPath = `(${column.query(escapedAliasName)})`
+            }
+
             if (
                 this.connection.driver.spatialTypes.indexOf(column.type) !== -1
             ) {
@@ -3942,7 +3948,25 @@ export class SelectQueryBuilder<Entity extends ObjectLiteral>
                         ? "NULLS LAST"
                         : undefined
 
-                this.addOrderBy(`${alias}.${propertyPath}`, direction, nulls)
+                let aliasPath = `${alias}.${propertyPath}`
+                if (column.isVirtualProperty && column.query) {
+                    const selection = this.expressionMap.selects.find(
+                        (s) => s.selection === aliasPath,
+                    )
+                    if (selection) {
+                        // this is not building correctly now???
+                        aliasPath = DriverUtils.buildAlias(
+                            this.connection.driver,
+                            alias,
+                            column.databaseName,
+                        )
+                        selection.aliasName = aliasPath
+                    } else {
+                        aliasPath = `(${column.query(alias)})`
+                    }
+                }
+
+                this.addOrderBy(aliasPath, direction, nulls)
                 // this.orderBys.push({ alias: alias + "." + propertyPath, direction, nulls });
             } else if (embed) {
                 this.buildOrder(
@@ -4029,7 +4053,10 @@ export class SelectQueryBuilder<Entity extends ObjectLiteral>
                     )
 
                 if (column) {
-                    const aliasPath = `${alias}.${propertyPath}`
+                    let aliasPath = `${alias}.${propertyPath}`
+                    if (column.isVirtualProperty && column.query) {
+                        aliasPath = `(${column.query(alias)})`
+                    }
                     // const parameterName = alias + "_" + propertyPath.split(".").join("_") + "_" + parameterIndex;
 
                     // todo: we need to handle other operators as well?
diff --git a/src/schema-builder/RdbmsSchemaBuilder.ts b/src/schema-builder/RdbmsSchemaBuilder.ts
index cf89241ba..78f66344e 100644
--- a/src/schema-builder/RdbmsSchemaBuilder.ts
+++ b/src/schema-builder/RdbmsSchemaBuilder.ts
@@ -312,18 +312,20 @@ export class RdbmsSchemaBuilder implements SchemaBuilder {
 
             if (metadata.columns.length !== table.columns.length) continue
 
-            const renamedMetadataColumns = metadata.columns.filter((column) => {
-                return !table.columns.find((tableColumn) => {
-                    return (
-                        tableColumn.name === column.databaseName &&
-                        tableColumn.type ===
-                            this.connection.driver.normalizeType(column) &&
-                        tableColumn.isNullable === column.isNullable &&
-                        tableColumn.isUnique ===
-                            this.connection.driver.normalizeIsUnique(column)
-                    )
+            const renamedMetadataColumns = metadata.columns
+                .filter((c) => !c.isVirtualProperty)
+                .filter((column) => {
+                    return !table.columns.find((tableColumn) => {
+                        return (
+                            tableColumn.name === column.databaseName &&
+                            tableColumn.type ===
+                                this.connection.driver.normalizeType(column) &&
+                            tableColumn.isNullable === column.isNullable &&
+                            tableColumn.isUnique ===
+                                this.connection.driver.normalizeIsUnique(column)
+                        )
+                    })
                 })
-            })
 
             if (
                 renamedMetadataColumns.length === 0 ||
@@ -334,6 +336,7 @@ export class RdbmsSchemaBuilder implements SchemaBuilder {
             const renamedTableColumns = table.columns.filter((tableColumn) => {
                 return !metadata.columns.find((column) => {
                     return (
+                        !column.isVirtualProperty &&
                         column.databaseName === tableColumn.name &&
                         this.connection.driver.normalizeType(column) ===
                             tableColumn.type &&
@@ -687,6 +690,7 @@ export class RdbmsSchemaBuilder implements SchemaBuilder {
             const droppedTableColumns = table.columns.filter((tableColumn) => {
                 return !metadata.columns.find(
                     (columnMetadata) =>
+                        columnMetadata.isVirtualProperty ||
                         columnMetadata.databaseName === tableColumn.name,
                 )
             })
@@ -717,9 +721,13 @@ export class RdbmsSchemaBuilder implements SchemaBuilder {
             // find which columns are new
             const newColumnMetadatas = metadata.columns.filter(
                 (columnMetadata) => {
-                    return !table.columns.find(
-                        (tableColumn) =>
-                            tableColumn.name === columnMetadata.databaseName,
+                    return (
+                        !columnMetadata.isVirtualProperty &&
+                        !table.columns.find(
+                            (tableColumn) =>
+                                tableColumn.name ===
+                                columnMetadata.databaseName,
+                        )
                     )
                 },
             )
diff --git a/src/schema-builder/table/Table.ts b/src/schema-builder/table/Table.ts
index 9345dd6d4..776ddae87 100644
--- a/src/schema-builder/table/Table.ts
+++ b/src/schema-builder/table/Table.ts
@@ -395,7 +395,7 @@ export class Table {
             withoutRowid: entityMetadata.withoutRowid,
             engine: entityMetadata.engine,
             columns: entityMetadata.columns
-                .filter((column) => column)
+                .filter((column) => column && !column.isVirtualProperty)
                 .map((column) =>
                     TableUtils.createTableColumnOptions(column, driver),
                 ),
diff --git a/src/util/DateUtils.ts b/src/util/DateUtils.ts
index 869c2219c..733996674 100644
--- a/src/util/DateUtils.ts
+++ b/src/util/DateUtils.ts
@@ -26,7 +26,7 @@ export class DateUtils {
      * Converts given value into date string in a "YYYY-MM-DD" format.
      */
     static mixedDateToDateString(value: string | Date): string {
-        if (value instanceof Date)
+        if (value instanceof Date) {
             return (
                 this.formatZerolessValue(value.getFullYear(), 4) +
                 "-" +
@@ -34,6 +34,7 @@ export class DateUtils {
                 "-" +
                 this.formatZerolessValue(value.getDate())
             )
+        }
 
         return value
     }
diff --git a/test/github-issues/9323/entity/Activity.ts b/test/github-issues/9323/entity/Activity.ts
new file mode 100644
index 000000000..22fe6ad69
--- /dev/null
+++ b/test/github-issues/9323/entity/Activity.ts
@@ -0,0 +1,20 @@
+import {
+    ManyToOne,
+    Entity,
+    BaseEntity,
+    PrimaryGeneratedColumn,
+    Column,
+} from "../../../../src"
+import TimeSheet from "./TimeSheet"
+
+@Entity({ name: "activities" })
+export default class Activity extends BaseEntity {
+    @PrimaryGeneratedColumn()
+    id: number
+
+    @Column("int")
+    hours: number
+
+    @ManyToOne((type) => TimeSheet, (timesheet) => timesheet.activities)
+    timesheet: TimeSheet
+}
diff --git a/test/github-issues/9323/entity/Company.ts b/test/github-issues/9323/entity/Company.ts
new file mode 100644
index 000000000..c4771e2e0
--- /dev/null
+++ b/test/github-issues/9323/entity/Company.ts
@@ -0,0 +1,23 @@
+import {
+    Entity,
+    OneToMany,
+    PrimaryColumn,
+    VirtualColumn,
+    BaseEntity,
+} from "../../../../src"
+import Employee from "./Employee"
+
+@Entity({ name: "companies" })
+export default class Company extends BaseEntity {
+    @PrimaryColumn("varchar", { length: 50 })
+    name: string
+
+    @VirtualColumn({
+        query: (alias) =>
+            `SELECT COUNT("name") FROM "employees" WHERE "companyName" = ${alias}.name`,
+    })
+    totalEmployeesCount: number
+
+    @OneToMany((type) => Employee, (employee) => employee.company)
+    employees: Employee[]
+}
diff --git a/test/github-issues/9323/entity/Employee.ts b/test/github-issues/9323/entity/Employee.ts
new file mode 100644
index 000000000..61a9aeca0
--- /dev/null
+++ b/test/github-issues/9323/entity/Employee.ts
@@ -0,0 +1,21 @@
+import {
+    ManyToOne,
+    Entity,
+    PrimaryColumn,
+    BaseEntity,
+    OneToMany,
+} from "../../../../src"
+import TimeSheet from "./TimeSheet"
+import Company from "./Company"
+
+@Entity({ name: "employees" })
+export default class Employee extends BaseEntity {
+    @PrimaryColumn("varchar", { length: 50 })
+    name: string
+
+    @ManyToOne((type) => Company, (company) => company.employees)
+    company: Company
+
+    @OneToMany((type) => TimeSheet, (timesheet) => timesheet.employee)
+    timesheets: TimeSheet[]
+}
diff --git a/test/github-issues/9323/entity/TimeSheet.ts b/test/github-issues/9323/entity/TimeSheet.ts
new file mode 100644
index 000000000..25689df08
--- /dev/null
+++ b/test/github-issues/9323/entity/TimeSheet.ts
@@ -0,0 +1,27 @@
+import {
+    ManyToOne,
+    Entity,
+    BaseEntity,
+    PrimaryGeneratedColumn,
+    VirtualColumn,
+} from "../../../../src"
+import Activity from "./Activity"
+import Employee from "./Employee"
+
+@Entity({ name: "timesheets" })
+export default class TimeSheet extends BaseEntity {
+    @PrimaryGeneratedColumn()
+    id: number
+
+    @VirtualColumn({
+        query: (alias) =>
+            `SELECT SUM("hours") FROM "activities" WHERE "timesheetId" = ${alias}.id`,
+    })
+    totalActvityHours: number
+
+    @ManyToOne((type) => Activity, (activity) => activity.timesheet)
+    activities: Activity[]
+
+    @ManyToOne((type) => Employee, (employee) => employee.timesheets)
+    employee: Employee
+}
diff --git a/test/github-issues/9323/issue-9323.ts b/test/github-issues/9323/issue-9323.ts
new file mode 100644
index 000000000..da3419f5e
--- /dev/null
+++ b/test/github-issues/9323/issue-9323.ts
@@ -0,0 +1,297 @@
+import { expect } from "chai"
+import "reflect-metadata"
+import {
+    DataSource,
+    FindManyOptions,
+    FindOneOptions,
+    FindOptionsUtils,
+    MoreThan,
+} from "../../../src"
+import {
+    closeTestingConnections,
+    createTestingConnections,
+} from "../../utils/test-utils"
+import Activity from "./entity/Activity"
+import Company from "./entity/Company"
+import Employee from "./entity/Employee"
+import TimeSheet from "./entity/TimeSheet"
+
+describe("github issues > #9323 Add new VirtualColumn decorator feature", () => {
+    let connections: DataSource[]
+    before(
+        async () =>
+            (connections = await createTestingConnections({
+                enabledDrivers: ["postgres"],
+                schemaCreate: true,
+                dropSchema: true,
+                entities: [Company, Employee, TimeSheet, Activity],
+            })),
+    )
+    after(() => closeTestingConnections(connections))
+
+    it("should generate expected sub-select & select statement", () =>
+        Promise.all(
+            connections.map((connection) => {
+                const metadata = connection.getMetadata(Company)
+                const options1: FindManyOptions<Company> = {
+                    select: {
+                        name: true,
+                        totalEmployeesCount: true,
+                    },
+                }
+
+                const query1 = connection
+                    .createQueryBuilder(
+                        Company,
+                        FindOptionsUtils.extractFindManyOptionsAlias(
+                            options1,
+                        ) || metadata.name,
+                    )
+                    .setFindOptions(options1 || {})
+                    .getSql()
+
+                expect(query1).to.eq(
+                    `SELECT "Company"."name" AS "Company_name", (SELECT COUNT("name") FROM "employees" WHERE "companyName" = "Company".name) AS "Company_totalEmployeesCount" FROM "companies" "Company"`,
+                )
+            }),
+        ))
+
+    it("should generate expected sub-select & nested-subselect statement", () =>
+        Promise.all(
+            connections.map((connection) => {
+                const metadata = connection.getMetadata(Company)
+                const options1: FindManyOptions<Company> = {
+                    select: {
+                        name: true,
+                        totalEmployeesCount: true,
+                        employees: {
+                            timesheets: {
+                                totalActvityHours: true,
+                            },
+                        },
+                    },
+                    relations: {
+                        employees: {
+                            timesheets: true,
+                        },
+                    },
+                }
+
+                const query1 = connection
+                    .createQueryBuilder(
+                        Company,
+                        FindOptionsUtils.extractFindManyOptionsAlias(
+                            options1,
+                        ) || metadata.name,
+                    )
+                    .setFindOptions(options1 || {})
+                    .getSql()
+
+                expect(query1).to.include(
+                    `SELECT "Company"."name" AS "Company_name"`,
+                )
+                expect(query1).to.include(
+                    `(SELECT COUNT("name") FROM "employees" WHERE "companyName" = "Company".name) AS "Company_totalEmployeesCount", (SELECT SUM("hours") FROM "activities" WHERE "timesheetId" =`,
+                )
+            }),
+        ))
+
+    it("should not generate sub-select if column is not selected", () =>
+        Promise.all(
+            connections.map((connection) => {
+                const metadata = connection.getMetadata(Company)
+                const options: FindManyOptions<Company> = {
+                    select: {
+                        name: true,
+                        totalEmployeesCount: false,
+                    },
+                }
+                const query = connection
+                    .createQueryBuilder(
+                        Company,
+                        FindOptionsUtils.extractFindManyOptionsAlias(options) ||
+                            metadata.name,
+                    )
+                    .setFindOptions(options || {})
+                    .getSql()
+
+                expect(query).to.eq(
+                    `SELECT "Company"."name" AS "Company_name" FROM "companies" "Company"`,
+                )
+            }),
+        ))
+
+    it("should be able to save and find sub-select data in the databse", () =>
+        Promise.all(
+            connections.map(async (connection) => {
+                const companyName = "My Company 1"
+                const company = Company.create({ name: companyName } as Company)
+                await company.save()
+
+                const employee1 = Employee.create({
+                    name: "Collin 1",
+                    company: company,
+                })
+                const employee2 = Employee.create({
+                    name: "John 1",
+                    company: company,
+                })
+                const employee3 = Employee.create({
+                    name: "Cory 1",
+                    company: company,
+                })
+                const employee4 = Employee.create({
+                    name: "Kevin 1",
+                    company: company,
+                })
+                await Employee.save([
+                    employee1,
+                    employee2,
+                    employee3,
+                    employee4,
+                ])
+
+                const employee1TimeSheet = TimeSheet.create({
+                    employee: employee1,
+                })
+                await employee1TimeSheet.save()
+                const employee1Activities: Activity[] = [
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                ]
+                await Activity.save(employee1Activities)
+
+                const findOneOptions: FindOneOptions<Company> = {
+                    select: {
+                        name: true,
+                        totalEmployeesCount: true,
+                        employees: {
+                            name: true,
+                            timesheets: {
+                                id: true,
+                                totalActvityHours: true,
+                            },
+                        },
+                    },
+                    relations: {
+                        employees: {
+                            timesheets: true,
+                        },
+                    },
+                    where: {
+                        name: companyName,
+                        totalEmployeesCount: MoreThan(2),
+                        employees: {
+                            timesheets: {
+                                totalActvityHours: MoreThan(0),
+                            },
+                        },
+                    },
+                    order: {
+                        employees: {
+                            timesheets: {
+                                id: "DESC",
+                                totalActvityHours: "ASC",
+                            },
+                        },
+                    },
+                }
+
+                const usersUnderCompany = await Company.findOne(findOneOptions)
+                expect(usersUnderCompany?.totalEmployeesCount).to.eq(4)
+                const employee1TimesheetFound = usersUnderCompany?.employees
+                    .find((e) => e.name === employee1.name)
+                    ?.timesheets.find((ts) => ts.id === employee1TimeSheet.id)
+                expect(employee1TimesheetFound?.totalActvityHours).to.eq(6)
+
+                const usersUnderCompanyList = await Company.find(findOneOptions)
+                const usersUnderCompanyListOne = usersUnderCompanyList[0]
+                expect(usersUnderCompanyListOne?.totalEmployeesCount).to.eq(4)
+                const employee1TimesheetListOneFound =
+                    usersUnderCompanyListOne?.employees
+                        .find((e) => e.name === employee1.name)
+                        ?.timesheets.find(
+                            (ts) => ts.id === employee1TimeSheet.id,
+                        )
+                expect(employee1TimesheetListOneFound?.totalActvityHours).to.eq(
+                    6,
+                )
+            }),
+        ))
+
+    it("should be able to save and find sub-select data in the databse (with query builder)", () =>
+        Promise.all(
+            connections.map(async (connection) => {
+                const companyName = "My Company 2"
+                const company = Company.create({ name: companyName } as Company)
+                await company.save()
+
+                const employee1 = Employee.create({
+                    name: "Collin 2",
+                    company: company,
+                })
+                const employee2 = Employee.create({
+                    name: "John 2",
+                    company: company,
+                })
+                const employee3 = Employee.create({
+                    name: "Cory 2",
+                    company: company,
+                })
+                await Employee.save([employee1, employee2, employee3])
+
+                const employee1TimeSheet = TimeSheet.create({
+                    employee: employee1,
+                })
+                await employee1TimeSheet.save()
+                const employee1Activities: Activity[] = [
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                    Activity.create({
+                        hours: 2,
+                        timesheet: employee1TimeSheet,
+                    }),
+                ]
+                await Activity.save(employee1Activities)
+
+                const companyQueryData = await connection
+                    .createQueryBuilder(Company, "company")
+                    .leftJoinAndSelect("company.employees", "employee")
+                    .leftJoinAndSelect("employee.timesheets", "timesheet")
+                    .leftJoinAndSelect("timesheet.activities", "activity")
+                    .where("company.name = :name", { name: companyName })
+                    // we won't be supporting where & order bys with VirtualColumns (you will have to make your subquery a function that gets added to the query builder)
+                    //.andWhere("company.totalEmployeesCount > 2")
+                    //.orderBy({
+                    //    "employees.timesheets.id": "DESC",
+                    //    //"employees.timesheets.totalActvityHours": "ASC",
+                    //})
+                    .getOne()
+
+                const foundEmployee = companyQueryData?.employees.find(
+                    (e) => e.name === employee1.name,
+                )
+                const foundEmployeeTimeSheet = foundEmployee?.timesheets.find(
+                    (t) => t.id === employee1TimeSheet.id,
+                )
+
+                expect(foundEmployeeTimeSheet?.totalActvityHours).to.eq(6)
+            }),
+        ))
+})
