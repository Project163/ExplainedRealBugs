diff --git a/src/query-builder/RelationLoader.ts b/src/query-builder/RelationLoader.ts
index 04eb5dd72..6f0c58ab5 100644
--- a/src/query-builder/RelationLoader.ts
+++ b/src/query-builder/RelationLoader.ts
@@ -216,7 +216,7 @@ export class RelationLoader {
 
                 // nothing is loaded yet, load relation data and save it in the model once they are loaded
                 const loader = relationLoader.load(relation, this, queryRunner).then(
-                    result => relation.isOneToOne || relation.isManyToOne ? result[0] : result
+                    result => relation.isOneToOne || relation.isManyToOne ? (result.length === 0 ? null : result[0]) : result
                 );
                 return setPromise(this, loader);
             },
diff --git a/test/github-issues/7146/entity/Category.ts b/test/github-issues/7146/entity/Category.ts
new file mode 100644
index 000000000..d04a78b67
--- /dev/null
+++ b/test/github-issues/7146/entity/Category.ts
@@ -0,0 +1,18 @@
+import { Entity, JoinColumn, OneToOne, PrimaryGeneratedColumn } from "../../../../src";
+import { Post } from "./Post";
+
+@Entity()
+export class Category {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @OneToOne(type => Post, post => post.lazyOneToOne, { nullable: true, eager: false })
+    @JoinColumn()
+    backRef1: Post;
+
+    @OneToOne(type => Post, post => post.eagerOneToOne, { nullable: true, eager: false })
+    @JoinColumn()
+    backRef2: Post;
+
+}
diff --git a/test/github-issues/7146/entity/Post.ts b/test/github-issues/7146/entity/Post.ts
new file mode 100644
index 000000000..08414825b
--- /dev/null
+++ b/test/github-issues/7146/entity/Post.ts
@@ -0,0 +1,32 @@
+import { Entity, JoinColumn, ManyToOne, OneToOne, PrimaryGeneratedColumn } from "../../../../src";
+import { Category } from "./Category";
+
+@Entity()
+export class Post {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @ManyToOne(type => Category, { nullable: true, eager: false })
+    lazyManyToOne: Promise<Category | null>;
+
+    @ManyToOne(type => Category, { nullable: true, eager: true })
+    eagerManyToOne: Category | null;
+
+    @OneToOne(type => Category, { nullable: true, eager: false })
+    @JoinColumn()
+    lazyOneToOneOwner: Promise<Category | null>;
+
+    @OneToOne(type => Category, { nullable: true, eager: true })
+    @JoinColumn()
+    eagerOneToOneOwner: Category | null;
+
+    // Not a column; actual value is stored on the other side of this relation
+    @OneToOne(type => Category, category => category.backRef1, { eager: false })
+    lazyOneToOne: Promise<Category | null>;
+
+    // Not a column; actual value is stored on the other side of this relation
+    @OneToOne(type => Category, category => category.backRef2, { eager: true })
+    eagerOneToOne: Category | null;
+
+}
diff --git a/test/github-issues/7146/issue-7146.ts b/test/github-issues/7146/issue-7146.ts
new file mode 100644
index 000000000..dac333a9a
--- /dev/null
+++ b/test/github-issues/7146/issue-7146.ts
@@ -0,0 +1,92 @@
+import "reflect-metadata";
+import { createTestingConnections, closeTestingConnections, reloadTestingDatabases } from "../../utils/test-utils";
+import { Connection } from "../../../src/connection/Connection";
+import { expect } from "chai";
+import { Post } from "./entity/Post";
+
+describe("github issues > #7146 Lazy relations resolve to 'undefined' instead of 'null'", () => {
+
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [__dirname + "/entity/*{.js,.ts}"],
+        schemaCreate: true,
+        dropSchema: true,
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    async function prepareData(connection: Connection) {
+        const savedPost = new Post();
+        await connection.manager.save(savedPost);
+    }
+
+    // The following 3 tests hilight the reported issue.
+    // The remaining 6 tests were already succeeding before, but are included for completeness sake.
+
+    describe("lazy-loaded relations", () => {
+
+        it("should return null if ManyToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(await post.lazyManyToOne).to.be.null;
+        })));
+
+        it("should return null if OneToOne+JoinColumn relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(await post.lazyOneToOneOwner).to.be.null;
+        })));
+
+        it("should return null if OneToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(await post.lazyOneToOne).to.be.null;
+        })));
+
+    });
+
+    describe("lazy-loaded relations included in 'relations' find option", () => {
+
+        it("should return null if ManyToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1, { relations: ['lazyManyToOne'] }));
+            expect(await post.lazyManyToOne).to.be.null;
+        })));
+
+        it("should return null if OneToOne+JoinColumn relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1, { relations: ['lazyOneToOneOwner'] }));
+            expect(await post.lazyOneToOneOwner).to.be.null;
+        })));
+
+        it("should return null if OneToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1, { relations: ['lazyOneToOne'] }));
+            expect(await post.lazyOneToOne).to.be.null;
+        })));
+
+    });
+
+    describe("eager-loaded relations", () => {
+
+        it("should return null if ManyToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(post.eagerManyToOne).to.be.null;
+        })));
+
+        it("should return null if OneToOne+JoinColumn relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(post.eagerOneToOneOwner).to.be.null;
+        })));
+
+        it("should return null if OneToOne relation has NULL in database", () => Promise.all(connections.map(async connection => {
+            await prepareData(connection);
+            const post = (await connection.manager.findOneOrFail(Post, 1));
+            expect(post.eagerOneToOne).to.be.null;
+        })));
+
+    });
+
+});
