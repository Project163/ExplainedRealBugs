diff --git a/src/driver/aurora-data-api/AuroraDataApiQueryRunner.ts b/src/driver/aurora-data-api/AuroraDataApiQueryRunner.ts
index 651789da3..4193a5bce 100644
--- a/src/driver/aurora-data-api/AuroraDataApiQueryRunner.ts
+++ b/src/driver/aurora-data-api/AuroraDataApiQueryRunner.ts
@@ -204,6 +204,14 @@ export class AuroraDataApiQueryRunner extends BaseQueryRunner implements QueryRu
         return result.length ? true : false;
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const query = await this.query(`SELECT DATABASE() AS \`db_name\``);
+        return query[0]["db_name"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -211,6 +219,14 @@ export class AuroraDataApiQueryRunner extends BaseQueryRunner implements QueryRu
         throw new Error(`MySql driver does not support table schemas`);
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const query = await this.query(`SELECT SCHEMA() AS \`schema_name\``);
+        return query[0]["schema_name"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1133,14 +1149,6 @@ export class AuroraDataApiQueryRunner extends BaseQueryRunner implements QueryRu
     // Protected Methods
     // -------------------------------------------------------------------------
 
-    /**
-     * Returns current database.
-     */
-    protected async getCurrentDatabase(): Promise<string> {
-        const currentDBQuery = await this.query(`SELECT DATABASE() AS \`db_name\``);
-        return currentDBQuery[0]["db_name"];
-    }
-
     protected async loadViews(viewNames: string[]): Promise<View[]> {
         const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
         if (!hasTable)
diff --git a/src/driver/cockroachdb/CockroachQueryRunner.ts b/src/driver/cockroachdb/CockroachQueryRunner.ts
index 3e9ad8273..5e89aa81c 100644
--- a/src/driver/cockroachdb/CockroachQueryRunner.ts
+++ b/src/driver/cockroachdb/CockroachQueryRunner.ts
@@ -297,6 +297,14 @@ export class CockroachQueryRunner extends BaseQueryRunner implements QueryRunner
         return result.length ? true : false;
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const query = await this.query(`SELECT * FROM current_database()`);
+        return query[0]["current_database"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -305,6 +313,14 @@ export class CockroachQueryRunner extends BaseQueryRunner implements QueryRunner
         return result.length ? true : false;
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const query = await this.query(`SELECT * FROM current_schema()`);
+        return query[0]["current_schema"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1452,9 +1468,15 @@ export class CockroachQueryRunner extends BaseQueryRunner implements QueryRunner
         return Promise.all(dbTables.map(async dbTable => {
             const table = new Table();
 
+            const getSchemaFromKey = (dbObject: any, key: string) => {
+                return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema)
+                    ? undefined
+                    : dbObject[key]
+            };
+
             // We do not need to join schema name, when database is by default.
-            // In this case we need local variable `tableFullName` for below comparision.
-            const schema = dbTable["table_schema"] === currentSchema && !this.driver.options.schema ? undefined : dbTable["table_schema"];
+            // In this case we need local variable `tableFullName` for below comparison.
+            const schema = getSchemaFromKey(dbTable, "table_schema");
             table.name = this.driver.buildTableName(dbTable["table_name"], schema);
             const tableFullName = this.driver.buildTableName(dbTable["table_name"], dbTable["table_schema"]);
 
@@ -1591,7 +1613,7 @@ export class CockroachQueryRunner extends BaseQueryRunner implements QueryRunner
                 const foreignKeys = dbForeignKeys.filter(dbFk => dbFk["constraint_name"] === dbForeignKey["constraint_name"]);
 
                 // if referenced table located in currently used schema, we don't need to concat schema name to table name.
-                const schema = dbForeignKey["referenced_table_schema"] === currentSchema ? undefined : dbForeignKey["referenced_table_schema"];
+                const schema = getSchemaFromKey(dbTable, "referenced_table_schema");
                 const referencedTableName = this.driver.buildTableName(dbForeignKey["referenced_table_name"], schema);
 
                 return new TableForeignKey({
diff --git a/src/driver/mongodb/MongoQueryRunner.ts b/src/driver/mongodb/MongoQueryRunner.ts
index edfcb17c8..efc784d24 100644
--- a/src/driver/mongodb/MongoQueryRunner.ts
+++ b/src/driver/mongodb/MongoQueryRunner.ts
@@ -513,6 +513,13 @@ export class MongoQueryRunner implements QueryRunner {
         throw new Error(`Check database queries are not supported by MongoDB driver.`);
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<undefined> {
+        throw new Error(`Check database queries are not supported by MongoDB driver.`);
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -520,6 +527,13 @@ export class MongoQueryRunner implements QueryRunner {
         throw new Error(`Check schema queries are not supported by MongoDB driver.`);
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<undefined> {
+        throw new Error(`Check schema queries are not supported by MongoDB driver.`);
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
diff --git a/src/driver/mysql/MysqlQueryRunner.ts b/src/driver/mysql/MysqlQueryRunner.ts
index c71cd6040..e31a07cdf 100644
--- a/src/driver/mysql/MysqlQueryRunner.ts
+++ b/src/driver/mysql/MysqlQueryRunner.ts
@@ -247,6 +247,14 @@ export class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {
         return result.length ? true : false;
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const query = await this.query(`SELECT DATABASE() AS \`db_name\``);
+        return query[0]["db_name"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -254,6 +262,14 @@ export class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {
         throw new Error(`MySql driver does not support table schemas`);
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const query = await this.query(`SELECT SCHEMA() AS \`schema_name\``);
+        return query[0]["schema_name"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1180,14 +1196,6 @@ export class MysqlQueryRunner extends BaseQueryRunner implements QueryRunner {
     // Protected Methods
     // -------------------------------------------------------------------------
 
-    /**
-     * Returns current database.
-     */
-    protected async getCurrentDatabase(): Promise<string> {
-        const currentDBQuery = await this.query(`SELECT DATABASE() AS \`db_name\``);
-        return currentDBQuery[0]["db_name"];
-    }
-
     protected async loadViews(viewNames: string[]): Promise<View[]> {
         const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
         if (!hasTable)
diff --git a/src/driver/oracle/OracleQueryRunner.ts b/src/driver/oracle/OracleQueryRunner.ts
index 508ef4349..f4bca69f5 100644
--- a/src/driver/oracle/OracleQueryRunner.ts
+++ b/src/driver/oracle/OracleQueryRunner.ts
@@ -246,6 +246,14 @@ export class OracleQueryRunner extends BaseQueryRunner implements QueryRunner {
         return Promise.resolve(false);
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<undefined> {
+        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','DB_NAME') AS "db_name" FROM dual`)
+        return query[0]["db_name"]
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -253,6 +261,14 @@ export class OracleQueryRunner extends BaseQueryRunner implements QueryRunner {
         return Promise.resolve(false);
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') AS "schema_name" FROM dual`)
+        return query[0]["schema_name"]
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
diff --git a/src/driver/postgres/PostgresQueryRunner.ts b/src/driver/postgres/PostgresQueryRunner.ts
index d062b83c8..518d6feb4 100644
--- a/src/driver/postgres/PostgresQueryRunner.ts
+++ b/src/driver/postgres/PostgresQueryRunner.ts
@@ -274,6 +274,14 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         return Promise.resolve(false);
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const query = await this.query(`SELECT * FROM current_database()`);
+        return query[0]["current_database"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -282,6 +290,14 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         return result.length ? true : false;
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const query = await this.query(`SELECT * FROM current_schema()`);
+        return query[0]["current_schema"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1404,9 +1420,7 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         if (!hasTable)
             return Promise.resolve([]);
 
-        const currentSchemaQuery = await this.query(`SELECT * FROM current_schema()`);
-        const currentSchema = currentSchemaQuery[0]["current_schema"];
-
+        const currentSchema = await this.getCurrentSchema()
         const viewsCondition = viewNames.map(viewName => {
             let [schema, name] = viewName.split(".");
             if (!name) {
@@ -1438,7 +1452,7 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
             return [];
 
         const currentSchemaQuery = await this.query(`SELECT * FROM current_schema()`);
-        const currentSchema = currentSchemaQuery[0]["current_schema"];
+        const currentSchema: string = currentSchemaQuery[0]["current_schema"];
 
         const tablesCondition = tableNames.map(tableName => {
             let [schema, name] = tableName.split(".");
@@ -1549,9 +1563,13 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         return Promise.all(dbTables.map(async dbTable => {
             const table = new Table();
 
-            const getSchemaFromKey = (dbObject: any, key: string) => dbObject[key] === currentSchema && !this.driver.options.schema ? undefined : dbObject[key];
+            const getSchemaFromKey = (dbObject: any, key: string) => {
+                return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema)
+                    ? undefined
+                    : dbObject[key]
+            };
             // We do not need to join schema name, when database is by default.
-            // In this case we need local variable `tableFullName` for below comparision.
+            // In this case we need local variable `tableFullName` for below comparison.
             const schema = getSchemaFromKey(dbTable, "table_schema");
             table.name = this.driver.buildTableName(dbTable["table_name"], schema);
             const tableFullName = this.driver.buildTableName(dbTable["table_name"], dbTable["table_schema"]);
@@ -2141,8 +2159,7 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
     }
 
     protected async getEnumTypeName(table: Table, column: TableColumn) {
-        const currentSchemaQuery = await this.query(`SELECT * FROM current_schema()`);
-        const currentSchema = currentSchemaQuery[0]["current_schema"];
+        const currentSchema = await this.getCurrentSchema()
         let [schema, name] = table.name.split(".");
         if (!name) {
             name = schema;
diff --git a/src/driver/sap/SapQueryRunner.ts b/src/driver/sap/SapQueryRunner.ts
index c3dc3485b..cbe943784 100644
--- a/src/driver/sap/SapQueryRunner.ts
+++ b/src/driver/sap/SapQueryRunner.ts
@@ -279,6 +279,14 @@ export class SapQueryRunner extends BaseQueryRunner implements QueryRunner {
         return databases.indexOf(database) !== -1;
     }
 
+    /**
+     * Returns current database.
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const currentDBQuery = await this.query(`SELECT "VALUE" AS "db_name" FROM "SYS"."M_SYSTEM_OVERVIEW" WHERE "SECTION" = 'System' and "NAME" = 'Instance ID'`);
+        return currentDBQuery[0]["db_name"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -287,6 +295,14 @@ export class SapQueryRunner extends BaseQueryRunner implements QueryRunner {
         return schemas.indexOf(schema) !== -1;
     }
 
+    /**
+     * Returns current schema.
+     */
+    async getCurrentSchema(): Promise<string> {
+        const currentSchemaQuery = await this.query(`SELECT CURRENT_SCHEMA AS "schema_name" FROM "SYS"."DUMMY"`);
+        return currentSchemaQuery[0]["schema_name"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1417,22 +1433,6 @@ export class SapQueryRunner extends BaseQueryRunner implements QueryRunner {
     // Protected Methods
     // -------------------------------------------------------------------------
 
-    /**
-     * Return current database.
-     */
-    protected async getCurrentDatabase(): Promise<string> {
-        const currentDBQuery = await this.query(`SELECT "VALUE" AS "db_name" FROM "SYS"."M_SYSTEM_OVERVIEW" WHERE "SECTION" = 'System' and "NAME" = 'Instance ID'`);
-        return currentDBQuery[0]["db_name"];
-    }
-
-    /**
-     * Return current schema.
-     */
-    protected async getCurrentSchema(): Promise<string> {
-        const currentSchemaQuery = await this.query(`SELECT CURRENT_SCHEMA AS "schema_name" FROM "SYS"."DUMMY"`);
-        return currentSchemaQuery[0]["schema_name"];
-    }
-
     protected async loadViews(viewNames: string[]): Promise<View[]> {
         const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
         if (!hasTable)
@@ -1529,10 +1529,15 @@ export class SapQueryRunner extends BaseQueryRunner implements QueryRunner {
         // create tables for loaded tables
         return Promise.all(dbTables.map(async dbTable => {
             const table = new Table();
+            const getSchemaFromKey = (dbObject: any, key: string) => {
+                return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema)
+                    ? undefined
+                    : dbObject[key]
+            };
 
             // We do not need to join schema name, when database is by default.
             // In this case we need local variable `tableFullName` for below comparision.
-            const schema = dbTable["SCHEMA_NAME"] === currentSchema && !this.driver.options.schema ? undefined : dbTable["SCHEMA_NAME"];
+            const schema = getSchemaFromKey(dbTable, "SCHEMA_NAME");
             table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], schema);
             const tableFullName = this.driver.buildTableName(dbTable["TABLE_NAME"], dbTable["SCHEMA_NAME"]);
 
@@ -1649,7 +1654,7 @@ export class SapQueryRunner extends BaseQueryRunner implements QueryRunner {
                 const foreignKeys = dbForeignKeys.filter(dbFk => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
 
                 // if referenced table located in currently used schema, we don't need to concat schema name to table name.
-                const schema = dbForeignKey["REFERENCED_SCHEMA_NAME"] === currentSchema ? undefined : dbForeignKey["REFERENCED_SCHEMA_NAME"];
+                const schema = getSchemaFromKey(dbTable, "REFERENCED_SCHEMA_NAME");
                 const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], schema);
 
                 return new TableForeignKey({
diff --git a/src/driver/sqlite-abstract/AbstractSqliteQueryRunner.ts b/src/driver/sqlite-abstract/AbstractSqliteQueryRunner.ts
index 3bd6d7576..12dda6b2d 100644
--- a/src/driver/sqlite-abstract/AbstractSqliteQueryRunner.ts
+++ b/src/driver/sqlite-abstract/AbstractSqliteQueryRunner.ts
@@ -166,6 +166,13 @@ export abstract class AbstractSqliteQueryRunner extends BaseQueryRunner implemen
         return Promise.resolve(false);
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<undefined> {
+        return Promise.resolve(undefined);
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -173,6 +180,13 @@ export abstract class AbstractSqliteQueryRunner extends BaseQueryRunner implemen
         throw new Error(`This driver does not support table schemas`);
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<undefined> {
+        return Promise.resolve(undefined);
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
diff --git a/src/driver/sqlserver/SqlServerQueryRunner.ts b/src/driver/sqlserver/SqlServerQueryRunner.ts
index e5a70093c..0e298c0aa 100644
--- a/src/driver/sqlserver/SqlServerQueryRunner.ts
+++ b/src/driver/sqlserver/SqlServerQueryRunner.ts
@@ -363,6 +363,14 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
         return !!dbId;
     }
 
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const currentDBQuery = await this.query(`SELECT DB_NAME() AS "db_name"`);
+        return currentDBQuery[0]["db_name"];
+    }
+
     /**
      * Checks if schema with the given name exist.
      */
@@ -372,6 +380,14 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
         return !!schemaId;
     }
 
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const currentSchemaQuery = await this.query(`SELECT SCHEMA_NAME() AS "schema_name"`);
+        return currentSchemaQuery[0]["schema_name"];
+    }
+
     /**
      * Checks if table with the given name exist in the database.
      */
@@ -1444,22 +1460,6 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
     // Protected Methods
     // -------------------------------------------------------------------------
 
-    /**
-     * Return current database.
-     */
-    protected async getCurrentDatabase(): Promise<string> {
-        const currentDBQuery = await this.query(`SELECT DB_NAME() AS "db_name"`);
-        return currentDBQuery[0]["db_name"];
-    }
-
-    /**
-     * Return current schema.
-     */
-    protected async getCurrentSchema(): Promise<string> {
-        const currentSchemaQuery = await this.query(`SELECT SCHEMA_NAME() AS "schema_name"`);
-        return currentSchemaQuery[0]["schema_name"];
-    }
-
     protected async loadViews(viewPaths: string[]): Promise<View[]> {
         const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
         if (!hasTable)
@@ -1655,10 +1655,16 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
         return await Promise.all(dbTables.map(async dbTable => {
             const table = new Table();
 
+            const getSchemaFromKey = (dbObject: any, key: string) => {
+                return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema)
+                    ? undefined
+                    : dbObject[key]
+            };
+
             // We do not need to join schema and database names, when db or schema is by default.
             // In this case we need local variable `tableFullName` for below comparision.
             const db = dbTable["TABLE_CATALOG"] === currentDatabase ? undefined : dbTable["TABLE_CATALOG"];
-            const schema = dbTable["TABLE_SCHEMA"] === currentSchema && !this.driver.options.schema ? undefined : dbTable["TABLE_SCHEMA"];
+            const schema = getSchemaFromKey(dbTable, "TABLE_SCHEMA");
             table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], schema, db);
             const tableFullName = this.driver.buildTableName(dbTable["TABLE_NAME"], dbTable["TABLE_SCHEMA"], dbTable["TABLE_CATALOG"]);
             const defaultCollation = dbCollations.find(dbCollation => dbCollation["NAME"] === dbTable["TABLE_CATALOG"])!;
@@ -1795,7 +1801,7 @@ export class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner
 
                 // if referenced table located in currently used db and schema, we don't need to concat db and schema names to table name.
                 const db = dbForeignKey["TABLE_CATALOG"] === currentDatabase ? undefined : dbForeignKey["TABLE_CATALOG"];
-                const schema = dbForeignKey["REF_SCHEMA"] === currentSchema ? undefined : dbForeignKey["REF_SCHEMA"];
+                const schema = getSchemaFromKey(dbTable, "REF_SCHEMA");
                 const referencedTableName = this.driver.buildTableName(dbForeignKey["REF_TABLE"], schema, db);
 
                 return new TableForeignKey({
diff --git a/src/query-runner/QueryRunner.ts b/src/query-runner/QueryRunner.ts
index 532fae399..6eaf07268 100644
--- a/src/query-runner/QueryRunner.ts
+++ b/src/query-runner/QueryRunner.ts
@@ -146,11 +146,21 @@ export interface QueryRunner {
      */
     hasDatabase(database: string): Promise<boolean>;
 
+    /**
+     * Loads currently using database
+     */
+    getCurrentDatabase(): Promise<string|undefined>;
+
     /**
      * Checks if a schema with the given name exist.
      */
     hasSchema(schema: string): Promise<boolean>;
 
+    /**
+     * Loads currently using database schema
+     */
+    getCurrentSchema(): Promise<string|undefined>;
+
     /**
      * Checks if a table with the given name exist.
      */
diff --git a/src/schema-builder/RdbmsSchemaBuilder.ts b/src/schema-builder/RdbmsSchemaBuilder.ts
index 602c47aa0..682fe3f2e 100644
--- a/src/schema-builder/RdbmsSchemaBuilder.ts
+++ b/src/schema-builder/RdbmsSchemaBuilder.ts
@@ -362,11 +362,14 @@ export class RdbmsSchemaBuilder implements SchemaBuilder {
      * Primary key only can be created in conclusion with auto generated column.
      */
     protected async createNewTables(): Promise<void> {
+        const currentSchema = await this.queryRunner.getCurrentSchema();
         for (const metadata of this.entityToSyncMetadatas) {
             // check if table does not exist yet
             const existTable = this.queryRunner.loadedTables.find(table => {
                 const database = metadata.database && metadata.database !== this.connection.driver.database ? metadata.database : undefined;
-                const schema = metadata.schema || (<SqlServerDriver|PostgresDriver|SapDriver>this.connection.driver).options.schema;
+                let schema = metadata.schema || (<SqlServerDriver|PostgresDriver|SapDriver>this.connection.driver).options.schema;
+                // if schema is default db schema (e.g. "public" in PostgreSQL), skip it.
+                schema = schema === currentSchema ? undefined : schema;
                 const fullTableName = this.connection.driver.buildTableName(metadata.tableName, schema, database);
 
                 return table.name === fullTableName;
diff --git a/test/github-issues/1758/issue-1758.ts b/test/github-issues/1758/issue-1758.ts
index fcceb71b7..7386c5175 100644
--- a/test/github-issues/1758/issue-1758.ts
+++ b/test/github-issues/1758/issue-1758.ts
@@ -4,20 +4,40 @@ import {closeTestingConnections, createTestingConnections} from "../../utils/tes
 
 describe("github issues > #1758 Synchronization bug in PostgreSQL bug occurs when we explicitly state the default schema as 'public'", () => {
 
-    let connections: Connection[];
-    before(async () => {
-        connections = await createTestingConnections({
-            entities: [__dirname + "/entity/*{.js,.ts}"],
-            enabledDrivers: ["postgres"],
-            schema: "public",
-            schemaCreate: true,
-            dropSchema: true,
+    describe("postgres, cockroachdb", () => {
+        let connections: Connection[];
+        before(async () => {
+            connections = await createTestingConnections({
+                entities: [__dirname + "/entity/*{.js,.ts}"],
+                enabledDrivers: ["postgres", "cockroachdb"],
+                schema: "public",
+                schemaCreate: true,
+                dropSchema: true,
+            });
         });
-    });
-    after(() => closeTestingConnections(connections));
+        after(() => closeTestingConnections(connections));
 
-    it("should correctly synchronize schema when we explicitly state the default schema as 'public'", () => Promise.all(connections.map(async connection => {
-        await connection.synchronize();
-    })));
+        it("should correctly synchronize schema when we explicitly state the default schema as 'public'", () => Promise.all(connections.map(async connection => {
+            await connection.synchronize();
+        })));
+    })
+
+    describe("mssql", () => {
+        let connections: Connection[];
+        before(async () => {
+            connections = await createTestingConnections({
+                entities: [__dirname + "/entity/*{.js,.ts}"],
+                enabledDrivers: ["mssql"],
+                schema: "dbo",
+                schemaCreate: true,
+                dropSchema: true,
+            });
+        });
+        after(() => closeTestingConnections(connections));
+
+        it("should correctly synchronize schema when we explicitly state the default schema as 'public'", () => Promise.all(connections.map(async connection => {
+            await connection.synchronize();
+        })));
+    })
 
 });
diff --git a/test/github-issues/7276/entity/TestMssql.ts b/test/github-issues/7276/entity/TestMssql.ts
new file mode 100644
index 000000000..d92d9f7e2
--- /dev/null
+++ b/test/github-issues/7276/entity/TestMssql.ts
@@ -0,0 +1,21 @@
+import {Column, Entity, Index} from "../../../../src";
+
+@Index("cluster_clu_created_fef900_idx", ["created_at"], {})
+@Index("cluster_cluster_pkey", ["uuid"], { unique: true })
+@Entity("cluster_cluster", { schema: "dbo" })
+export class ClusterCluster {
+    @Column("uuid", { primary: true, name: "uuid" })
+    uuid: string;
+
+    @Column({ name: "created_at" })
+    created_at: Date;
+
+    @Column({ name: "updated_at" })
+    updated_at: Date;
+
+    @Column({ name: "category", length: 30 })
+    category: string;
+
+    @Column({ name: "parent", length: 255 })
+    parent: string;
+}
diff --git a/test/github-issues/7276/entity/TestPostgres.ts b/test/github-issues/7276/entity/TestPostgres.ts
new file mode 100644
index 000000000..cea706250
--- /dev/null
+++ b/test/github-issues/7276/entity/TestPostgres.ts
@@ -0,0 +1,24 @@
+import {Column, Entity, Index} from "../../../../src";
+
+@Index("cluster_clu_created_fef900_idx", ["created_at"], {})
+@Index("cluster_cluster_pkey", ["uuid"], { unique: true })
+@Entity("cluster_cluster", { schema: "public" })
+export class ClusterCluster {
+    @Column("uuid", { primary: true, name: "uuid" })
+    uuid: string;
+
+    @Column("timestamp with time zone", { name: "created_at" })
+    created_at: Date;
+
+    @Column("timestamp with time zone", { name: "updated_at" })
+    updated_at: Date;
+
+    @Column("character varying", { name: "category", length: 30 })
+    category: string;
+
+    @Column("character varying", { name: "parent", length: 255 })
+    parent: string;
+
+    @Column("varchar", { name: "children", array: true })
+    children: string[];
+}
diff --git a/test/github-issues/7276/issue-7276.ts b/test/github-issues/7276/issue-7276.ts
new file mode 100644
index 000000000..ce5fa823a
--- /dev/null
+++ b/test/github-issues/7276/issue-7276.ts
@@ -0,0 +1,55 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {ClusterCluster as ClusterClusterPg} from "./entity/TestPostgres";
+import {ClusterCluster as ClusterClusterMssql} from "./entity/TestMssql";
+
+describe("github issues > #7276 Schema sync not able to find diff correctly and executes same queries on every run", () => {
+    describe("postgres", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["postgres"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [ClusterClusterPg],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+
+    describe("mssql", () => {
+        let connections: Connection[];
+        before(async () => connections = await createTestingConnections({
+            enabledDrivers: ["mssql"],
+            schemaCreate: false,
+            dropSchema: true,
+            entities: [ClusterClusterMssql],
+        }));
+        after(() => closeTestingConnections(connections));
+
+        it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.greaterThan(0);
+            sqlInMemory.downQueries.length.should.be.greaterThan(0);
+        })));
+
+        it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+            await connection.driver.createSchemaBuilder().build();
+            const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+            sqlInMemory.upQueries.length.should.be.equal(0);
+            sqlInMemory.downQueries.length.should.be.equal(0);
+        })));
+    })
+});
