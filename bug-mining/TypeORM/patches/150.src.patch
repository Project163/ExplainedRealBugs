diff --git a/docs/decorator-reference.md b/docs/decorator-reference.md
index 2f5f133ee..26b847764 100644
--- a/docs/decorator-reference.md
+++ b/docs/decorator-reference.md
@@ -539,6 +539,7 @@ Used for `many-to-many` relations and describes join columns of the "junction" t
 Junction table is a special, separate table created automatically by TypeORM with columns referenced to the related entities.
 You can change the name of the generated "junction" table, the column names inside the junction table, their referenced
 columns with the `joinColumn`- and `inverseJoinColumn` attributes, and the created foreign keys names.
+You can also set parameter `synchronize` to false to skip schema update(same way as in @Entity)
 
 Example:
 
@@ -558,6 +559,7 @@ export class Post {
             referencedColumnName: "id",
             foreignKeyConstraintName: "fk_question_categories_categoryId"
         },
+        synchronize: false,
     })
     categories: Category[]
 }
diff --git a/src/decorator/options/JoinTableMultipleColumnsOptions.ts b/src/decorator/options/JoinTableMultipleColumnsOptions.ts
index 18684bcc2..07147f167 100644
--- a/src/decorator/options/JoinTableMultipleColumnsOptions.ts
+++ b/src/decorator/options/JoinTableMultipleColumnsOptions.ts
@@ -31,4 +31,11 @@ export interface JoinTableMultipleColumnsOptions {
      * Works only in some databases (like postgres and mssql).
      */
     schema?: string
+
+    /**
+     * Indicates if schema synchronization is enabled or disabled junction table.
+     * If it will be set to false then schema sync will and migrations ignores junction table.
+     * By default schema synchronization is enabled.
+     */
+    readonly synchronize?: boolean
 }
diff --git a/src/decorator/options/JoinTableOptions.ts b/src/decorator/options/JoinTableOptions.ts
index b387a7748..d2b8aa5c3 100644
--- a/src/decorator/options/JoinTableOptions.ts
+++ b/src/decorator/options/JoinTableOptions.ts
@@ -31,4 +31,11 @@ export interface JoinTableOptions {
      * Works only in some databases (like postgres and mssql).
      */
     schema?: string
+
+    /**
+     * Indicates if schema synchronization is enabled or disabled junction table.
+     * If it will be set to false then schema sync will and migrations ignores junction table.
+     * By default schema synchronization is enabled.
+     */
+    synchronize?: boolean
 }
diff --git a/src/decorator/relations/JoinTable.ts b/src/decorator/relations/JoinTable.ts
index ad3e2e562..b609bce76 100644
--- a/src/decorator/relations/JoinTable.ts
+++ b/src/decorator/relations/JoinTable.ts
@@ -50,6 +50,7 @@ export function JoinTable(
             schema: options && options.schema ? options.schema : undefined,
             database:
                 options && options.database ? options.database : undefined,
+            synchronize: !(options && options.synchronize === false),
         } as JoinTableMetadataArgs)
     }
 }
diff --git a/src/metadata-args/JoinTableMetadataArgs.ts b/src/metadata-args/JoinTableMetadataArgs.ts
index aef86ca35..10d62cd74 100644
--- a/src/metadata-args/JoinTableMetadataArgs.ts
+++ b/src/metadata-args/JoinTableMetadataArgs.ts
@@ -41,4 +41,11 @@ export interface JoinTableMetadataArgs {
      * Works only in some databases (like postgres and mssql).
      */
     readonly schema?: string
+
+    /**
+     * Indicates if schema synchronization is enabled or disabled junction table.
+     * If it will be set to false then schema sync will and migrations ignores junction table.
+     * By default schema synchronization is enabled.
+     */
+    readonly synchronize?: boolean
 }
diff --git a/src/metadata-builder/JunctionEntityMetadataBuilder.ts b/src/metadata-builder/JunctionEntityMetadataBuilder.ts
index 889fa7e62..d80632198 100644
--- a/src/metadata-builder/JunctionEntityMetadataBuilder.ts
+++ b/src/metadata-builder/JunctionEntityMetadataBuilder.ts
@@ -59,6 +59,7 @@ export class JunctionEntityMetadataBuilder {
                 database:
                     joinTable.database || relation.entityMetadata.database,
                 schema: joinTable.schema || relation.entityMetadata.schema,
+                synchronize: joinTable.synchronize,
             },
         })
         entityMetadata.build()
diff --git a/test/github-issues/3443/entity/category.ts b/test/github-issues/3443/entity/category.ts
new file mode 100644
index 000000000..dcd85aabc
--- /dev/null
+++ b/test/github-issues/3443/entity/category.ts
@@ -0,0 +1,11 @@
+import { Entity, ManyToMany, PrimaryGeneratedColumn } from "../../../../src"
+import { Product } from "./product"
+
+@Entity({ name: "category" })
+export class Category {
+    @PrimaryGeneratedColumn()
+    id: string
+
+    @ManyToMany(() => Product, (product) => product.categories)
+    products: Product[]
+}
diff --git a/test/github-issues/3443/entity/product.ts b/test/github-issues/3443/entity/product.ts
new file mode 100644
index 000000000..712cfc844
--- /dev/null
+++ b/test/github-issues/3443/entity/product.ts
@@ -0,0 +1,17 @@
+import {
+    Entity,
+    JoinTable,
+    ManyToMany,
+    PrimaryGeneratedColumn,
+} from "../../../../src"
+import { Category } from "./category"
+
+@Entity({ name: "product" })
+export class Product {
+    @PrimaryGeneratedColumn()
+    id: string
+
+    @ManyToMany(() => Category, (category) => category.products)
+    @JoinTable({ name: "product_category", synchronize: false })
+    categories: Category[]
+}
diff --git a/test/github-issues/3443/issue-3443.ts b/test/github-issues/3443/issue-3443.ts
new file mode 100644
index 000000000..e2380ed78
--- /dev/null
+++ b/test/github-issues/3443/issue-3443.ts
@@ -0,0 +1,47 @@
+import "reflect-metadata"
+import {
+    createTestingConnections,
+    closeTestingConnections,
+    reloadTestingDatabases,
+} from "../../utils/test-utils"
+import { DataSource } from "../../../src/data-source/DataSource"
+import { expect } from "chai"
+
+describe("github issues > #3443 @JoinTable on entities without synchronization", () => {
+    let dataSources: DataSource[]
+    before(
+        async () =>
+            (dataSources = await createTestingConnections({
+                entities: [__dirname + "/entity/*{.js,.ts}"],
+                schemaCreate: true,
+                dropSchema: true,
+            })),
+    )
+    beforeEach(() => reloadTestingDatabases(dataSources))
+    after(() => closeTestingConnections(dataSources))
+
+    it("Should set synchronize: false for @JoinTable when passed to options", () =>
+        Promise.all(
+            dataSources.map(async (dataSource) => {
+                const PRODUCT_TABLE_NAME = "product"
+                const CATEGORY_TABLE_NAME = "category"
+                const PRODUCT_CATEGORY_TABLE_NAME = "product_category"
+
+                expect(() =>
+                    dataSource.getMetadata(PRODUCT_TABLE_NAME),
+                ).not.to.throw()
+                expect(() =>
+                    dataSource.getMetadata(CATEGORY_TABLE_NAME),
+                ).not.to.throw()
+                expect(() =>
+                    dataSource.getMetadata(PRODUCT_CATEGORY_TABLE_NAME),
+                ).not.to.throw()
+                expect(
+                    dataSource.getMetadata(PRODUCT_CATEGORY_TABLE_NAME)
+                        .synchronize,
+                ).to.equal(false)
+            }),
+        ))
+
+    // you can add additional tests if needed
+})
diff --git a/test/github-issues/9412/entity/Post.ts b/test/github-issues/9412/entity/Post.ts
index edad7e230..263907dbf 100644
--- a/test/github-issues/9412/entity/Post.ts
+++ b/test/github-issues/9412/entity/Post.ts
@@ -7,9 +7,9 @@ export class Post {
     @PrimaryGeneratedColumn()
     id: number
 
-    @Column({unique: true})
+    @Column({ unique: true })
     title: string
 
-    @Column({unique: true})
+    @Column({ unique: true })
     author: string
 }
diff --git a/test/github-issues/9412/issue-9412.ts b/test/github-issues/9412/issue-9412.ts
index 441da4730..e8122737e 100644
--- a/test/github-issues/9412/issue-9412.ts
+++ b/test/github-issues/9412/issue-9412.ts
@@ -1,45 +1,51 @@
-import 'reflect-metadata'
+import "reflect-metadata"
 import {
     closeTestingConnections,
     createTestingConnections,
     reloadTestingDatabases,
-} from '../../utils/test-utils'
-import { DataSource } from '../../../src/data-source/DataSource'
-import { Post } from './entity/Post'
-import { expect } from 'chai'
+} from "../../utils/test-utils"
+import { DataSource } from "../../../src/data-source/DataSource"
+import { Post } from "./entity/Post"
+import { expect } from "chai"
 
-describe('github issues > #9365 ', () => {
+describe("github issues > #9365 ", () => {
     let connections: DataSource[]
     before(
         async () =>
             (connections = await createTestingConnections({
-                entities: [ __dirname + '/entity/*{.js,.ts}' ],
-                enabledDrivers: [ 'postgres' ],
+                entities: [__dirname + "/entity/*{.js,.ts}"],
+                enabledDrivers: ["postgres"],
             })),
     )
     beforeEach(() => reloadTestingDatabases(connections))
     after(() => closeTestingConnections(connections))
 
-    it('should work with conflict path', () =>
+    it("should work with conflict path", () =>
         Promise.all(
             connections.map(async (connection) => {
                 const postRepository = connection.getRepository(Post)
 
                 const post1 = new Post()
-                post1.title = 'Test1'
-                post1.author = 'Test1'
+                post1.title = "Test1"
+                post1.author = "Test1"
                 await postRepository.save(post1)
 
                 const post2 = new Post()
-                post2.title = 'Test'
-                post2.author = 'Test2'
+                post2.title = "Test"
+                post2.author = "Test2"
 
-                await postRepository.upsert(post2, { conflictPaths: { author: true }, skipUpdateIfNoValuesChanged: true })
-                const allPostsAfterUpsert1= await postRepository.find()
+                await postRepository.upsert(post2, {
+                    conflictPaths: { author: true },
+                    skipUpdateIfNoValuesChanged: true,
+                })
+                const allPostsAfterUpsert1 = await postRepository.find()
                 expect(allPostsAfterUpsert1.length).equal(2)
 
-                await postRepository.upsert(post2, { conflictPaths: { title: true }, skipUpdateIfNoValuesChanged: true })
-                const allPostsAfterUpsert2= await postRepository.find()
+                await postRepository.upsert(post2, {
+                    conflictPaths: { title: true },
+                    skipUpdateIfNoValuesChanged: true,
+                })
+                const allPostsAfterUpsert2 = await postRepository.find()
                 expect(allPostsAfterUpsert2.length).equal(2)
             }),
         ))
