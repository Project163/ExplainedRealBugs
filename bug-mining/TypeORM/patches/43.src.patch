diff --git a/src/repository/TreeRepository.ts b/src/repository/TreeRepository.ts
index 33ad00c7b..9c2f178fd 100644
--- a/src/repository/TreeRepository.ts
+++ b/src/repository/TreeRepository.ts
@@ -253,10 +253,9 @@ export class TreeRepository<Entity> extends Repository<Entity> {
             const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;
             const id = rawResult[alias + "_" + this.metadata.primaryColumns[0].databaseName];
             const parentId = rawResult[alias + "_" + joinColumnName];
-            // CockroachDB returns numeric types as string
             return {
-                id: typeof id === "string" ? parseInt(id) : id,
-                parentId: typeof parentId === "string" ? parseInt(parentId) : parentId
+                id: this.manager.connection.driver.prepareHydratedValue(id, this.metadata.primaryColumns[0]),
+                parentId: this.manager.connection.driver.prepareHydratedValue(parentId, joinColumn),
             };
         });
     }
diff --git a/test/github-issues/3783/entity/Category.ts b/test/github-issues/3783/entity/Category.ts
new file mode 100644
index 000000000..56b818fa2
--- /dev/null
+++ b/test/github-issues/3783/entity/Category.ts
@@ -0,0 +1,24 @@
+import {PrimaryGeneratedColumn} from "../../../../src";
+import {Column} from "../../../../src";
+import {TreeParent} from "../../../../src";
+import {TreeChildren} from "../../../../src";
+import {Entity} from "../../../../src";
+import {Tree} from "../../../../src";
+
+@Entity()
+@Tree("closure-table")
+export class Category {
+
+    @PrimaryGeneratedColumn("uuid")
+    id: number;
+
+    @Column()
+    name: string;
+    
+    @TreeParent()
+    parentCategory: Category;
+
+    @TreeChildren({ cascade: true })
+    childCategories: Category[];
+
+}
diff --git a/test/github-issues/3783/issue-3783.ts b/test/github-issues/3783/issue-3783.ts
new file mode 100644
index 000000000..aaed7247c
--- /dev/null
+++ b/test/github-issues/3783/issue-3783.ts
@@ -0,0 +1,51 @@
+import "reflect-metadata";
+import {createTestingConnections, closeTestingConnections, reloadTestingDatabases} from "../../utils/test-utils";
+import {Connection} from "../../../src/connection/Connection";
+import {Category} from "./entity/Category";
+
+describe("github issues > #3783 Tree functionality broken", () => {
+
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [__dirname + "/entity/*{.js,.ts}"],
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    it("should work correctly", () => Promise.all(connections.map(async connection => {
+        const categoryRepository = connection.getTreeRepository(Category);
+
+        const a1 = new Category();
+        a1.name = "a1";
+
+        const b1 = new Category();
+        b1.name = "b1";
+
+        const c1 = new Category();
+        c1.name = "c1";
+
+        const c11 = new Category();
+        c11.name = "c11";
+
+        const c12 = new Category();
+        c12.name = "c12";
+
+        c11.parentCategory = c1;
+        c12.parentCategory = c1;
+
+        await categoryRepository.save(a1);
+        await categoryRepository.save(b1);
+        await categoryRepository.save(c1);
+        await categoryRepository.save(c11);
+        await categoryRepository.save(c12);
+
+        const roots = await categoryRepository.findRoots();
+        roots.length.should.be.eql(3);
+
+        const c1Tree = await categoryRepository.findDescendantsTree(c1);
+        c1Tree.should.be.equal(c1);
+        c1Tree!.childCategories.length.should.be.eql(2);
+
+    })));
+
+});
