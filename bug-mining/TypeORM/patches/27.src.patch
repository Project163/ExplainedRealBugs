diff --git a/src/connection/Connection.ts b/src/connection/Connection.ts
index a0a086238..3bb99ca3e 100644
--- a/src/connection/Connection.ts
+++ b/src/connection/Connection.ts
@@ -13,6 +13,7 @@ import {Logger} from "../logger/Logger";
 import {EntityMetadataNotFoundError} from "../error/EntityMetadataNotFoundError";
 import {MigrationInterface} from "../migration/MigrationInterface";
 import {MigrationExecutor} from "../migration/MigrationExecutor";
+import {Migration} from "../migration/Migration";
 import {MongoRepository} from "../repository/MongoRepository";
 import {MongoDriver} from "../driver/mongodb/MongoDriver";
 import {MongoEntityManager} from "../entity-manager/MongoEntityManager";
@@ -271,7 +272,7 @@ export class Connection {
      * Runs all pending migrations.
      * Can be used only after connection to the database is established.
      */
-    async runMigrations(options?: { transaction?: boolean }): Promise<void> {
+    async runMigrations(options?: { transaction?: boolean }): Promise<Migration[]> {
         if (!this.isConnected)
             throw new CannotExecuteNotConnectedError(this.name);
 
@@ -279,7 +280,8 @@ export class Connection {
         if (options && options.transaction === false) {
             migrationExecutor.transaction = false;
         }
-        await migrationExecutor.executePendingMigrations();
+        const successMigrations = await migrationExecutor.executePendingMigrations();
+        return successMigrations;
     }
 
     /**
diff --git a/src/migration/MigrationExecutor.ts b/src/migration/MigrationExecutor.ts
index 46543968e..a50699396 100644
--- a/src/migration/MigrationExecutor.ts
+++ b/src/migration/MigrationExecutor.ts
@@ -50,7 +50,7 @@ export class MigrationExecutor {
      * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
      * thus not saved in the database.
      */
-    async executePendingMigrations(): Promise<void> {
+    async executePendingMigrations(): Promise<Migration[]> {
 
         const queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
 
@@ -66,6 +66,9 @@ export class MigrationExecutor {
         // get all user's migrations in the source code
         const allMigrations = this.getMigrations();
 
+        // variable to store all migrations we did successefuly
+        const successMigrations: Migration[] = [];
+
         // find all migrations that needs to be executed
         const pendingMigrations = allMigrations.filter(migration => {
             // check if we already have executed migration
@@ -87,7 +90,7 @@ export class MigrationExecutor {
             // if query runner was created by us then release it
             if (!this.queryRunner)
                 await queryRunner.release();
-            return;
+            return [];
         }
 
         // log information about migration execution
@@ -112,6 +115,7 @@ export class MigrationExecutor {
                         return this.insertExecutedMigration(queryRunner, migration);
                     })
                     .then(() => { // informative log about migration success
+                        successMigrations.push(migration);
                         this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been executed successfully.`);
                     });
             });
@@ -135,6 +139,7 @@ export class MigrationExecutor {
             if (!this.queryRunner)
                 await queryRunner.release();
         }
+        return successMigrations;
 
     }
 
diff --git a/test/github-issues/2875/issue-2875.ts b/test/github-issues/2875/issue-2875.ts
new file mode 100644
index 000000000..6c385a891
--- /dev/null
+++ b/test/github-issues/2875/issue-2875.ts
@@ -0,0 +1,24 @@
+import "reflect-metadata";
+import {createTestingConnections, closeTestingConnections, reloadTestingDatabases} from "../../utils/test-utils";
+import {Connection} from "../../../src/connection/Connection";
+import {Migration} from "../../../src/migration/Migration";
+
+describe("github issues > #2875 runMigrations() function is not returning a list of migrated files", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [__dirname + "/entity/*{.js,.ts}"],
+        migrations: [__dirname + "/migration/*.js"],
+        enabledDrivers: ["postgres"],
+        schemaCreate: true,
+        dropSchema: true,
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    it("should be able to run all necessary migrations", () => Promise.all(connections.map(async connection => {
+        const mymigr: Migration[] = await connection.runMigrations();
+    
+        mymigr.length.should.be.equal(1);
+        mymigr[0].name.should.be.equal("InitUsers1530542855524");
+    })));
+ });
\ No newline at end of file
diff --git a/test/github-issues/2875/migration/1530542855524-CreateUsersSeq.ts b/test/github-issues/2875/migration/1530542855524-CreateUsersSeq.ts
new file mode 100644
index 000000000..606daecf4
--- /dev/null
+++ b/test/github-issues/2875/migration/1530542855524-CreateUsersSeq.ts
@@ -0,0 +1,18 @@
+import { MigrationInterface } from "../../../../src/migration/MigrationInterface";
+import { QueryRunner } from "../../../../src/query-runner/QueryRunner";
+
+export class InitUsers1530542855524 implements MigrationInterface {
+     public async up(queryRunner: QueryRunner): Promise<any> {
+        await queryRunner.query(`
+            CREATE SEQUENCE users_id_seq INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1
+        `);
+        await queryRunner.query(`
+            DROP SEQUENCE IF EXISTS users_id_seq
+        `);
+    }
+     public async down(queryRunner: QueryRunner): Promise<any> {
+        await queryRunner.query(`
+            DROP SEQUENCE IF EXISTS users_id_seq
+        `);
+    }
+}
diff --git a/test/utils/test-utils.ts b/test/utils/test-utils.ts
index 425dd3d57..a34e35f94 100644
--- a/test/utils/test-utils.ts
+++ b/test/utils/test-utils.ts
@@ -52,6 +52,12 @@ export interface TestingOptions {
      */
     entities?: (string|Function|EntitySchema<any>)[];
 
+
+    /**
+     * Migrations needs to be included in connection for the given test suite.
+     */
+    migrations?: string[];
+
     /**
      * Subscribers needs to be included in the connection for the given test suite.
      */
@@ -194,6 +200,7 @@ export function setupTestingConnections(options?: TestingOptions): ConnectionOpt
             let newOptions: any = Object.assign({}, connectionOptions as ConnectionOptions, {
                 name: options && options.name ? options.name : connectionOptions.name,
                 entities: options && options.entities ? options.entities : [],
+                migrations: options && options.migrations ? options.migrations : [],
                 subscribers: options && options.subscribers ? options.subscribers : [],
                 dropSchema: options && options.dropSchema !== undefined ? options.dropSchema : false,
                 cache: options ? options.cache : undefined,
@@ -208,6 +215,8 @@ export function setupTestingConnections(options?: TestingOptions): ConnectionOpt
                 newOptions.logging = options.logging;
             if (options && options.__dirname)
                 newOptions.entities = [options.__dirname + "/entity/*{.js,.ts}"];
+            if (options && options.__dirname)
+                newOptions.migrations = [options.__dirname + "/migration/*{.js,.ts}"];
             if (options && options.namingStrategy)
                 newOptions.namingStrategy = options.namingStrategy;
             return newOptions;
