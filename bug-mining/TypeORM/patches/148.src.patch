diff --git a/src/find-options/FindOperatorType.ts b/src/find-options/FindOperatorType.ts
index edda3a2f7..fcecf8fac 100644
--- a/src/find-options/FindOperatorType.ts
+++ b/src/find-options/FindOperatorType.ts
@@ -18,3 +18,4 @@ export type FindOperatorType =
     | "arrayContains"
     | "arrayContainedBy"
     | "arrayOverlap"
+    | "and"
diff --git a/src/find-options/operator/And.ts b/src/find-options/operator/And.ts
new file mode 100644
index 000000000..b2e9c1350
--- /dev/null
+++ b/src/find-options/operator/And.ts
@@ -0,0 +1,5 @@
+import { FindOperator } from "../FindOperator"
+
+export function And<T>(...values: FindOperator<T>[]): FindOperator<T> {
+    return new FindOperator("and", values as any, true, true)
+}
diff --git a/src/index.ts b/src/index.ts
index c7010c5f0..9a5ac5b35 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -66,6 +66,7 @@ export * from "./decorator/Check"
 export * from "./decorator/Exclusion"
 export * from "./decorator/Generated"
 export * from "./decorator/EntityRepository"
+export * from "./find-options/operator/And"
 export * from "./find-options/operator/Any"
 export * from "./find-options/operator/ArrayContainedBy"
 export * from "./find-options/operator/ArrayContains"
diff --git a/src/query-builder/QueryBuilder.ts b/src/query-builder/QueryBuilder.ts
index 56f13bf13..885a002a9 100644
--- a/src/query-builder/QueryBuilder.ts
+++ b/src/query-builder/QueryBuilder.ts
@@ -1055,6 +1055,8 @@ export abstract class QueryBuilder<Entity extends ObjectLiteral> {
                     condition.condition,
                     true,
                 )}`
+            case "and":
+                return condition.parameters.join(" AND ")
         }
 
         throw new TypeError(
@@ -1448,6 +1450,20 @@ export abstract class QueryBuilder<Entity extends ObjectLiteral> {
                         parameters: [aliasPath, ...parameters],
                     }
                 }
+            } else if (parameterValue.type === "and") {
+                const values: FindOperator<any>[] = parameterValue.value
+
+                return {
+                    operator: parameterValue.type,
+                    parameters: values.map((operator) =>
+                        this.createWhereConditionExpression(
+                            this.getWherePredicateCondition(
+                                aliasPath,
+                                operator,
+                            ),
+                        ),
+                    ),
+                }
             } else {
                 return {
                     operator: parameterValue.type,
diff --git a/src/query-builder/WhereClause.ts b/src/query-builder/WhereClause.ts
index e3abd102d..7631067c2 100644
--- a/src/query-builder/WhereClause.ts
+++ b/src/query-builder/WhereClause.ts
@@ -16,6 +16,7 @@ type PredicateOperator =
     | "arrayContains"
     | "arrayContainedBy"
     | "arrayOverlap"
+    | "and"
 
 export interface WherePredicateOperator {
     operator: PredicateOperator
diff --git a/test/github-issues/3113/entities/User.ts b/test/github-issues/3113/entities/User.ts
new file mode 100644
index 000000000..0a36572ea
--- /dev/null
+++ b/test/github-issues/3113/entities/User.ts
@@ -0,0 +1,13 @@
+import { Column, Entity, PrimaryGeneratedColumn } from "../../../../src"
+
+@Entity()
+export class User {
+    @PrimaryGeneratedColumn()
+    id: number
+
+    @Column()
+    name: string
+
+    @Column({ type: "int", nullable: true })
+    money: number | null
+}
diff --git a/test/github-issues/3113/issue-3113.ts b/test/github-issues/3113/issue-3113.ts
new file mode 100644
index 000000000..00f52845b
--- /dev/null
+++ b/test/github-issues/3113/issue-3113.ts
@@ -0,0 +1,63 @@
+import { And, DataSource, IsNull, LessThan, MoreThan, Not } from "../../../src"
+import {
+    closeTestingConnections,
+    createTestingConnections,
+    reloadTestingDatabases,
+} from "../../utils/test-utils"
+import { User } from "./entities/User"
+import { expect } from "chai"
+
+describe("github issues > #9316 specify how should interpret null and undefined values in conditions ", () => {
+    let dataSources: DataSource[]
+
+    before(async () => {
+        dataSources = await createTestingConnections({
+            entities: [User],
+            enabledDrivers: ["postgres", "mysql"],
+            schemaCreate: true,
+            dropSchema: true,
+        })
+    })
+
+    beforeEach(() => reloadTestingDatabases(dataSources))
+    after(() => closeTestingConnections(dataSources))
+
+    it("should find users what money is not null and money is more than 10 and money is less than 100", async () => {
+        await Promise.all(
+            dataSources.map(async (dataSource) => {
+                const foo = new User()
+                foo.name = "Foo"
+                foo.money = null
+
+                const john = new User()
+                john.name = "John"
+                john.money = 11
+
+                const jane = new User()
+                jane.name = "Jane"
+                jane.money = 90
+
+                const bar = new User()
+                bar.name = "Bar"
+                bar.money = 101
+
+                await dataSource.manager.save([foo, john, jane, bar])
+
+                const users = await dataSource.manager.find(User, {
+                    where: {
+                        money: And(Not(IsNull()), MoreThan(10), LessThan(100)),
+                    },
+                })
+
+                // assert users
+                expect(users).to.have.length(2)
+
+                expect(users.find((user) => user.name === "John")).to.be.not
+                    .undefined
+
+                expect(users.find((user) => user.name === "Jane")).to.be.not
+                    .undefined
+            }),
+        )
+    })
+})
