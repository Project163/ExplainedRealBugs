diff --git a/src/decorator/entity/ChildEntity.ts b/src/decorator/entity/ChildEntity.ts
index aee1b9746..2405e4305 100644
--- a/src/decorator/entity/ChildEntity.ts
+++ b/src/decorator/entity/ChildEntity.ts
@@ -15,7 +15,7 @@ export function ChildEntity(discriminatorValue?: any): ClassDecorator {
         } as TableMetadataArgs);
 
         // register discriminator value if it was provided
-        if (discriminatorValue) {
+        if (typeof discriminatorValue !== 'undefined') {
             getMetadataArgsStorage().discriminatorValues.push({
                 target: target,
                 value: discriminatorValue
diff --git a/src/metadata-builder/EntityMetadataBuilder.ts b/src/metadata-builder/EntityMetadataBuilder.ts
index ab5cf5d1f..cd8de9b57 100644
--- a/src/metadata-builder/EntityMetadataBuilder.ts
+++ b/src/metadata-builder/EntityMetadataBuilder.ts
@@ -335,7 +335,12 @@ export class EntityMetadataBuilder {
         const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);
 
         const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);
-        entityMetadata.discriminatorValue = discriminatorValue ? discriminatorValue.value : (entityMetadata.target as any).name; // todo: pass this to naming strategy to generate a name
+
+        if (typeof discriminatorValue !== "undefined") {
+            entityMetadata.discriminatorValue = discriminatorValue.value;
+        } else {
+            entityMetadata.discriminatorValue = (entityMetadata.target as any).name;
+        }
 
         // if single table inheritance is used, we need to mark all embedded columns as nullable
         entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree))
diff --git a/src/metadata-builder/EntityMetadataValidator.ts b/src/metadata-builder/EntityMetadataValidator.ts
index 41fc1b99b..9e3fe488d 100644
--- a/src/metadata-builder/EntityMetadataValidator.ts
+++ b/src/metadata-builder/EntityMetadataValidator.ts
@@ -62,8 +62,8 @@ export class EntityMetadataValidator {
             if (!entityMetadata.discriminatorColumn)
                 throw new Error(`Entity ${entityMetadata.name} using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?`);
 
-            if (["", undefined, null].indexOf(entityMetadata.discriminatorValue) !== -1)
-                throw new Error(`Entity ${entityMetadata.name} has empty discriminator value. Discriminator value should not be empty.`);
+            if (typeof entityMetadata.discriminatorValue === "undefined")
+                throw new Error(`Entity ${entityMetadata.name} has an undefined discriminator value. Discriminator value should be defined.`);
 
             const sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(metadata => {
                 return metadata !== entityMetadata
diff --git a/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts b/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts
index 05dc941ac..704842924 100644
--- a/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts
+++ b/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts
@@ -97,7 +97,7 @@ export class RawSqlResultsToEntityTransformer {
         if (metadata.discriminatorColumn) {
             const discriminatorValues = rawResults.map(result => result[DriverUtils.buildColumnAlias(this.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)]);
             const discriminatorMetadata = metadata.childEntityMetadatas.find(childEntityMetadata => {
-                return !!discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue);
+                return typeof discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue) !== 'undefined';
             });
             if (discriminatorMetadata)
                 metadata = discriminatorMetadata;
diff --git a/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/entity/Other.ts b/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/entity/Other.ts
new file mode 100644
index 000000000..4ef0c856c
--- /dev/null
+++ b/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/entity/Other.ts
@@ -0,0 +1,11 @@
+import {Column} from "../../../../../../src/decorator/columns/Column";
+import {ChildEntity} from "../../../../../../src/decorator/entity/ChildEntity";
+import {Person} from "./Person";
+
+@ChildEntity("")
+export class Other extends Person {
+
+    @Column()
+    mood: string;
+
+}
diff --git a/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/non-virtual-discriminator-column.ts b/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/non-virtual-discriminator-column.ts
index 700f9e616..a413b0b38 100644
--- a/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/non-virtual-discriminator-column.ts
+++ b/test/functional/table-inheritance/single-table/non-virtual-discriminator-column/non-virtual-discriminator-column.ts
@@ -3,7 +3,9 @@ import {closeTestingConnections, createTestingConnections, reloadTestingDatabase
 import {Connection} from "../../../../../src/connection/Connection";
 import {Student} from "./entity/Student";
 import {Employee} from "./entity/Employee";
+import {Other} from "./entity/Other";
 import {Person} from "./entity/Person";
+import {OracleDriver} from "../../../../../src/driver/oracle/OracleDriver";
 
 describe("table-inheritance > single-table > non-virtual-discriminator-column", () => {
 
@@ -30,6 +32,15 @@ describe("table-inheritance > single-table > non-virtual-discriminator-column",
         employee.salary = 1000;
         await connection.getRepository(Employee).save(employee);
 
+        if (!(connection.driver instanceof OracleDriver)) {
+            // In Oracle, empty string is a `null` so this isn't exactly possible there.
+
+            const other = new Other();
+            other.name = "Empty";
+            other.mood = "Happy"
+            await connection.getRepository(Other).save(other);
+        }
+
         // -------------------------------------------------------------------------
         // Select
         // -------------------------------------------------------------------------
@@ -47,6 +58,15 @@ describe("table-inheritance > single-table > non-virtual-discriminator-column",
         persons[1].type.should.be.equal("employee-type");
         persons[1].name.should.be.equal("Roger");
         (persons[1] as Employee).salary.should.be.equal(1000);
+
+        if (!(connection.driver instanceof OracleDriver)) {
+            // In Oracle, empty string is a `null` so this isn't exactly possible there.
+
+            persons[2].id.should.be.equal(3);
+            persons[2].type.should.be.equal("");
+            persons[2].name.should.be.equal("Empty");
+            (persons[2] as Other).mood.should.be.equal("Happy");
+        }
     })));
 
 });
diff --git a/test/functional/table-inheritance/single-table/numeric-types/entity/Person.ts b/test/functional/table-inheritance/single-table/numeric-types/entity/Person.ts
new file mode 100644
index 000000000..16ee3285a
--- /dev/null
+++ b/test/functional/table-inheritance/single-table/numeric-types/entity/Person.ts
@@ -0,0 +1,18 @@
+import {Column} from "../../../../../../src/decorator/columns/Column";
+import {TableInheritance} from "../../../../../../src/decorator/entity/TableInheritance";
+import {Entity} from "../../../../../../src/decorator/entity/Entity";
+import {PrimaryGeneratedColumn} from "../../../../../../src/decorator/columns/PrimaryGeneratedColumn";
+
+@Entity()
+@TableInheritance({ column: { name: "type", type: "int" } })
+export class Person {
+
+    @PrimaryGeneratedColumn()
+    id: number;
+
+    @Column()
+    name: string;
+
+    @Column()
+    type: number;
+}
diff --git a/test/functional/table-inheritance/single-table/numeric-types/entity/Student.ts b/test/functional/table-inheritance/single-table/numeric-types/entity/Student.ts
new file mode 100644
index 000000000..14f96bc3a
--- /dev/null
+++ b/test/functional/table-inheritance/single-table/numeric-types/entity/Student.ts
@@ -0,0 +1,11 @@
+import {Column} from "../../../../../../src/decorator/columns/Column";
+import {ChildEntity} from "../../../../../../src/decorator/entity/ChildEntity";
+import {Person} from "./Person";
+
+@ChildEntity(0)
+export class Student extends Person {
+
+    @Column()
+    faculty: string;
+
+}
diff --git a/test/functional/table-inheritance/single-table/numeric-types/entity/Teacher.ts b/test/functional/table-inheritance/single-table/numeric-types/entity/Teacher.ts
new file mode 100644
index 000000000..71657f528
--- /dev/null
+++ b/test/functional/table-inheritance/single-table/numeric-types/entity/Teacher.ts
@@ -0,0 +1,11 @@
+import {Column} from "../../../../../../src/decorator/columns/Column";
+import {ChildEntity} from "../../../../../../src/decorator/entity/ChildEntity";
+import {Person} from "./Person";
+
+@ChildEntity(1)
+export class Teacher extends Person {
+
+    @Column()
+    specialization: string;
+
+}
diff --git a/test/functional/table-inheritance/single-table/numeric-types/numeric-types.ts b/test/functional/table-inheritance/single-table/numeric-types/numeric-types.ts
new file mode 100644
index 000000000..4a603c230
--- /dev/null
+++ b/test/functional/table-inheritance/single-table/numeric-types/numeric-types.ts
@@ -0,0 +1,57 @@
+import "reflect-metadata";
+import {expect} from "chai";
+import {closeTestingConnections, createTestingConnections, reloadTestingDatabases} from "../../../../utils/test-utils";
+import {Connection} from "../../../../../src/connection/Connection";
+import {Student} from "./entity/Student";
+import {Teacher} from "./entity/Teacher";
+import {Person} from "./entity/Person";
+import {CockroachDriver} from "../../../../../src/driver/cockroachdb/CockroachDriver";
+
+describe("table-inheritance > single-table > numeric types", () => {
+
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        entities: [Person, Student, Teacher]
+    }));
+    beforeEach(() => reloadTestingDatabases(connections));
+    after(() => closeTestingConnections(connections));
+
+    it("should allow numeric types for the discriminator, including 0", () => Promise.all(connections.map(async connection => {
+        if (connection.driver instanceof CockroachDriver) {
+            return;
+        }
+
+        // -------------------------------------------------------------------------
+        // Create
+        // -------------------------------------------------------------------------
+
+        const student = new Student();
+        student.name = "Alice";
+        student.faculty = "Economics";
+        await connection.getRepository(Student).save(student);
+
+        const teacher = new Teacher();
+        teacher.name = "Roger";
+        teacher.specialization = "Math";
+        await connection.getRepository(Teacher).save(teacher);
+
+        // -------------------------------------------------------------------------
+        // Select
+        // -------------------------------------------------------------------------
+
+        let persons = await connection.manager
+            .createQueryBuilder(Person, "person")
+            .getMany();
+
+        expect(persons[0].id).to.be.equal(1);
+        expect(persons[0].type).to.be.equal(0);
+        expect(persons[0].name).to.be.equal("Alice");
+        expect((persons[0] as Student).faculty).to.be.equal("Economics");
+
+        expect(persons[1].id).to.be.equal(2);
+        expect(persons[1].type).to.be.equal(1);
+        expect(persons[1].name).to.be.equal("Roger");
+        expect((persons[1] as Teacher).specialization).to.be.equal("Math");
+    })));
+
+});
