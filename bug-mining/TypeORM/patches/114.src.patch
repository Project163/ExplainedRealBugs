diff --git a/src/driver/postgres/PostgresQueryRunner.ts b/src/driver/postgres/PostgresQueryRunner.ts
index 4f56a113f..d7e9bd531 100644
--- a/src/driver/postgres/PostgresQueryRunner.ts
+++ b/src/driver/postgres/PostgresQueryRunner.ts
@@ -562,9 +562,12 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         // rename ENUM types
         const enumColumns = newTable.columns.filter(column => column.type === "enum" || column.type === "simple-enum");
         for (let column of enumColumns) {
-            const oldEnumType = await this.getEnumTypeName(oldTable, column);
-            upQueries.push(new Query(`ALTER TYPE "${oldEnumType.enumTypeSchema}"."${oldEnumType.enumTypeName}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
-            downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.enumTypeName}"`));
+            // skip renaming for user-defined enum name
+            if (column.enumName) continue;
+
+            const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);
+            upQueries.push(new Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
+            downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.name}"`));
         }
         await this.executeQueries(upQueries, downQueries);
     }
@@ -698,9 +701,9 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
 
                 // rename ENUM type
                 if (oldColumn.type === "enum" || oldColumn.type === "simple-enum") {
-                    const oldEnumType = await this.getEnumTypeName(table, oldColumn);
-                    upQueries.push(new Query(`ALTER TYPE "${oldEnumType.enumTypeSchema}"."${oldEnumType.enumTypeName}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
-                    downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.enumTypeName}"`));
+                    const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);
+                    upQueries.push(new Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
+                    downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.name}"`));
                 }
 
                 // rename column primary key constraint
@@ -1045,8 +1048,8 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         if (column.type === "enum" || column.type === "simple-enum") {
             const hasEnum = await this.hasEnumType(table, column);
             if (hasEnum) {
-                const enumType = await this.getEnumTypeName(table, column);
-                const escapedEnumName = `"${enumType.enumTypeSchema}"."${enumType.enumTypeName}"`;
+                const enumType = await this.getUserDefinedTypeName(table, column);
+                const escapedEnumName = `"${enumType.schema}"."${enumType.name}"`;
                 upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));
                 downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));
             }
@@ -1495,24 +1498,17 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
          * pg_catalog.pg_attribute table to get column information.
          * @see https://stackoverflow.com/a/19541865
          */
-        const columnsSql = `
-            SELECT columns.*,
-              pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) AS description,
-              ('"' || "udt_schema" || '"."' || "udt_name" || '"')::"regtype" AS "regtype",
-              pg_catalog.format_type("col_attr"."atttypid", "col_attr"."atttypmod") AS "format_type"
-              FROM "information_schema"."columns"
-              LEFT JOIN "pg_catalog"."pg_attribute" AS "col_attr"
-              ON "col_attr"."attname" = "columns"."column_name"
-              AND "col_attr"."attrelid" = (
-                SELECT
-                  "cls"."oid" FROM "pg_catalog"."pg_class" AS "cls"
-                  LEFT JOIN "pg_catalog"."pg_namespace" AS "ns"
-                  ON "ns"."oid" = "cls"."relnamespace"
-                WHERE "cls"."relname" = "columns"."table_name"
-                AND "ns"."nspname" = "columns"."table_schema"
-              )
-            WHERE
-            ` + tablesCondition;
+        const columnsSql = `SELECT columns.*, pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) AS description, ` +
+                `('"' || "udt_schema" || '"."' || "udt_name" || '"')::"regtype" AS "regtype", pg_catalog.format_type("col_attr"."atttypid", "col_attr"."atttypmod") AS "format_type" ` +
+            `FROM "information_schema"."columns" ` +
+            `LEFT JOIN "pg_catalog"."pg_attribute" AS "col_attr" ON "col_attr"."attname" = "columns"."column_name" ` +
+                `AND "col_attr"."attrelid" = ( ` +
+                    `SELECT "cls"."oid" FROM "pg_catalog"."pg_class" AS "cls" ` +
+                    `LEFT JOIN "pg_catalog"."pg_namespace" AS "ns" ON "ns"."oid" = "cls"."relnamespace" ` +
+                    `WHERE "cls"."relname" = "columns"."table_name" ` +
+                    `AND "ns"."nspname" = "columns"."table_schema" `+
+                `) ` +
+            `WHERE ` + tablesCondition;
 
         const constraintsCondition = tableNames.map(tableName => {
             let [schema, name] = tableName.split(".");
@@ -1574,6 +1570,7 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
             `INNER JOIN "pg_class" "cl" ON "cl"."oid" = "con"."confrelid" ${isPartitionCondition}` +
             `INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" ` +
             `INNER JOIN "pg_attribute" "att2" ON "att2"."attrelid" = "con"."conrelid" AND "att2"."attnum" = "con"."parent"`;
+
         const [dbTables, dbColumns, dbConstraints, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([
             this.query(tablesSql),
             this.query(columnsSql),
@@ -1628,12 +1625,6 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
                         }
                     }
 
-                    if (dbColumn["data_type"].toLowerCase() === "array") {
-                        tableColumn.isArray = true;
-                        const type = tableColumn.type.replace("[]", "");
-                        tableColumn.type = this.connection.driver.normalizeType({type: type});
-                    }
-
                     if (tableColumn.type === "interval"
                         || tableColumn.type === "time without time zone"
                         || tableColumn.type === "time with time zone"
@@ -1642,20 +1633,33 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
                         tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["datetime_precision"]) ? dbColumn["datetime_precision"] : undefined;
                     }
 
-                    if (tableColumn.type.indexOf("enum") !== -1) {
+                    // check if column has user-defined data type.
+                    // NOTE: if ENUM type defined with "array:true" it comes with ARRAY type instead of USER-DEFINED
+                    if (dbColumn["data_type"] === "USER-DEFINED" || dbColumn["data_type"] === "ARRAY") {
+                        const { name } = await this.getUserDefinedTypeName(table, tableColumn)
+
                         // check if `enumName` is specified by user
-                        const { enumTypeName } = await this.getEnumTypeName(table, tableColumn)
                         const builtEnumName = this.buildEnumName(table, tableColumn, false, true)
-                        if (builtEnumName !== enumTypeName)
-                            tableColumn.enumName = enumTypeName
+                        const enumName = builtEnumName !== name ? name : undefined
 
-                        tableColumn.type = "enum";
+                        // check if type is ENUM
                         const sql = `SELECT "e"."enumlabel" AS "value" FROM "pg_enum" "e" ` +
-                        `INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" ` +
-                        `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" ` +
-                        `WHERE "n"."nspname" = '${dbTable["table_schema"]}' AND "t"."typname" = '${this.buildEnumName(table, tableColumn, false, true)}'`;
+                            `INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" ` +
+                            `INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" ` +
+                            `WHERE "n"."nspname" = '${dbTable["table_schema"]}' AND "t"."typname" = '${enumName || name}'`;
                         const results: ObjectLiteral[] = await this.query(sql);
-                        tableColumn.enum = results.map(result => result["value"]);
+
+                        if (results.length) {
+                            tableColumn.type = "enum";
+                            tableColumn.enum = results.map(result => result["value"]);
+                            tableColumn.enumName = enumName
+                        }
+
+                        if (dbColumn["data_type"] === "ARRAY") {
+                            tableColumn.isArray = true;
+                            const type = tableColumn.type.replace("[]", "");
+                            tableColumn.type = this.connection.driver.normalizeType({type: type});
+                        }
                     }
 
                     if (tableColumn.type === "geometry") {
@@ -2184,7 +2188,7 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
         }).join(".");
     }
 
-    protected async getEnumTypeName(table: Table, column: TableColumn) {
+    protected async getUserDefinedTypeName(table: Table, column: TableColumn) {
         const currentSchema = await this.getCurrentSchema()
         let [schema, name] = table.name.split(".");
         if (!name) {
@@ -2204,8 +2208,8 @@ export class PostgresQueryRunner extends BaseQueryRunner implements QueryRunner
             udtName = udtName.substr(1, udtName.length)
         }
         return {
-            enumTypeSchema: result[0]["udt_schema"],
-            enumTypeName: udtName
+            schema: result[0]["udt_schema"],
+            name: udtName
         };
     }
 
diff --git a/test/functional/database-schema/column-types/postgres-enum/entity/Post.ts b/test/functional/database-schema/column-types/postgres-enum/entity/Post.ts
index bb310dda3..968575b64 100644
--- a/test/functional/database-schema/column-types/postgres-enum/entity/Post.ts
+++ b/test/functional/database-schema/column-types/postgres-enum/entity/Post.ts
@@ -14,6 +14,9 @@ export class Post {
     @Column("enum", { enum: ["A", "B", "C"], array: true })
     enumArray: string[];
 
+    @Column("enum", { enum: ["A", "B", "C"], enumName: "enum_array", array: true })
+    enumArray2: string[];
+
     @Column("simple-enum", { enum: ["A", "B", "C"] })
     simpleEnum: string;
 
diff --git a/test/functional/database-schema/column-types/postgres-enum/postgres-enum.ts b/test/functional/database-schema/column-types/postgres-enum/postgres-enum.ts
index b2c1985e2..5e25f0d6b 100644
--- a/test/functional/database-schema/column-types/postgres-enum/postgres-enum.ts
+++ b/test/functional/database-schema/column-types/postgres-enum/postgres-enum.ts
@@ -27,6 +27,7 @@ describe("database schema > column types > postgres-enum", () => {
         const post = new Post();
         post.enum = "A";
         post.enumArray = ["A", "B"];
+        post.enumArray2 = ["A", "C"];
         post.simpleEnum = "A";
         post.name = "Post #1";
         await postRepository.save(post);
@@ -34,10 +35,12 @@ describe("database schema > column types > postgres-enum", () => {
         const loadedPost = (await postRepository.findOne(1))!;
         loadedPost.enum.should.be.equal(post.enum);
         loadedPost.enumArray.should.be.deep.equal(post.enumArray);
+        loadedPost.enumArray2.should.be.deep.equal(post.enumArray2);
         loadedPost.simpleEnum.should.be.equal(post.simpleEnum);
 
         table!.findColumnByName("enum")!.type.should.be.equal("enum");
         table!.findColumnByName("enumArray")!.type.should.be.equal("enum");
+        table!.findColumnByName("enumArray2")!.type.should.be.equal("enum");
         table!.findColumnByName("enumArray")!.isArray.should.be.true;
         table!.findColumnByName("simpleEnum")!.type.should.be.equal("enum");
     })));
diff --git a/test/functional/database-schema/column-types/postgres/entity/Post.ts b/test/functional/database-schema/column-types/postgres/entity/Post.ts
index a8a6610e3..50d598972 100644
--- a/test/functional/database-schema/column-types/postgres/entity/Post.ts
+++ b/test/functional/database-schema/column-types/postgres/entity/Post.ts
@@ -254,4 +254,4 @@ export class Post {
 
     @Column("simple-enum", { enum: ["A", "B", "C"] })
     simpleEnum: string;
-}
\ No newline at end of file
+}
diff --git a/test/github-issues/6540/entity/order-product.entity.ts.ts b/test/github-issues/6540/entity/order-product.entity.ts.ts
new file mode 100644
index 000000000..d94aab444
--- /dev/null
+++ b/test/github-issues/6540/entity/order-product.entity.ts.ts
@@ -0,0 +1,11 @@
+import {BaseEntity, Column, Entity, PrimaryGeneratedColumn} from "../../../../src";
+import {OrderStatus} from "./order.entity.ts";
+
+@Entity()
+export class OrderProduct extends BaseEntity {
+    @PrimaryGeneratedColumn("increment")
+    id: number
+
+    @Column({ type: "enum", enum: OrderStatus })
+    status: OrderStatus
+}
diff --git a/test/github-issues/6540/entity/order.entity.ts.ts b/test/github-issues/6540/entity/order.entity.ts.ts
new file mode 100644
index 000000000..4815f0699
--- /dev/null
+++ b/test/github-issues/6540/entity/order.entity.ts.ts
@@ -0,0 +1,19 @@
+import {BaseEntity, Column, Entity, PrimaryGeneratedColumn} from "../../../../src";
+
+export enum OrderStatus {
+    placed = "placed",
+    paid = "paid",
+    confirmed = "confirmed",
+    shipped = "shipped",
+    completed = "completed",
+    cancelled = "cancelled"
+}
+
+@Entity()
+export class Order extends BaseEntity {
+    @PrimaryGeneratedColumn("uuid")
+    id: string
+
+    @Column({ type: "enum", enum: OrderStatus })
+    status: OrderStatus
+}
diff --git a/test/github-issues/6540/issue-6540.ts b/test/github-issues/6540/issue-6540.ts
new file mode 100644
index 000000000..76aea0383
--- /dev/null
+++ b/test/github-issues/6540/issue-6540.ts
@@ -0,0 +1,29 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {Order} from "./entity/order.entity.ts";
+import {OrderProduct} from "./entity/order-product.entity.ts";
+
+describe("github issues > #6540 Enum not resolved if it is from an external file", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["mysql", "mariadb"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [Order, OrderProduct],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+});
diff --git a/test/github-issues/7541/entity/Test.ts b/test/github-issues/7541/entity/Test.ts
index c02dbd073..c88bba348 100644
--- a/test/github-issues/7541/entity/Test.ts
+++ b/test/github-issues/7541/entity/Test.ts
@@ -9,8 +9,17 @@ enum StandardSetType {
 @Entity()
 export class TestEntity {
     @PrimaryGeneratedColumn()
-    ud: number
+    id: number
 
     @Column("enum", { enum: StandardSetType, name: "type" })
     type: StandardSetType;
+
+    @Column({ type: "enum", enum: StandardSetType })
+    type2: StandardSetType;
+
+    @Column("enum", { enum: StandardSetType, enumName: "StandardSetType" })
+    type3: StandardSetType;
+
+    @Column({ type: "enum", enumName: "StandardSetType" })
+    type4: StandardSetType;
 }
diff --git a/test/github-issues/7614/entity/Test.ts b/test/github-issues/7614/entity/Test.ts
new file mode 100644
index 000000000..7786e192d
--- /dev/null
+++ b/test/github-issues/7614/entity/Test.ts
@@ -0,0 +1,17 @@
+import {Column, Entity, Index, PrimaryColumn} from "../../../../src";
+
+enum ExternalUserProvider {
+    A = "A",
+    B = "B",
+    C = "C",
+}
+
+@Entity()
+export class TestEntity {
+    @PrimaryColumn({ name: "provider", type: "enum", enumName: "external_user_provider", enum: ExternalUserProvider })
+    @Index()
+    public provider!: ExternalUserProvider;
+
+    @Column({ type: "enum", enumName: "external_user_provider", enum: ExternalUserProvider, array: true })
+    public provider2!: ExternalUserProvider;
+}
diff --git a/test/github-issues/7614/issue-7614.ts b/test/github-issues/7614/issue-7614.ts
new file mode 100644
index 000000000..3c63f601f
--- /dev/null
+++ b/test/github-issues/7614/issue-7614.ts
@@ -0,0 +1,28 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {TestEntity} from "./entity/Test";
+
+describe("github issues > #7614 Postgres: Custom enum name results in field recreate", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["postgres"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [TestEntity],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+});
diff --git a/test/github-issues/7647/entity/TaskNotification.ts b/test/github-issues/7647/entity/TaskNotification.ts
new file mode 100644
index 000000000..5b437ce9f
--- /dev/null
+++ b/test/github-issues/7647/entity/TaskNotification.ts
@@ -0,0 +1,19 @@
+import {Column, Entity, PrimaryColumn} from "../../../../src";
+
+export enum TaskNotificationType {
+    ASSIGNED
+}
+
+@Entity('taskNotifications')
+export class TaskNotification {
+    @PrimaryColumn()
+    id: number
+
+    @Column({
+        type: 'enum',
+        enum: TaskNotificationType,
+        enumName: 'TaskNotificationType',
+        default: TaskNotificationType.ASSIGNED,
+    })
+    type: TaskNotificationType;
+}
diff --git a/test/github-issues/7647/issue-7647.ts b/test/github-issues/7647/issue-7647.ts
new file mode 100644
index 000000000..74a10fb5e
--- /dev/null
+++ b/test/github-issues/7647/issue-7647.ts
@@ -0,0 +1,28 @@
+import "reflect-metadata";
+import {Connection} from "../../../src";
+import {closeTestingConnections, createTestingConnections} from "../../utils/test-utils";
+import {TaskNotification} from "./entity/TaskNotification";
+
+describe("github issues > #7647 Duplicate migrations when using 'enumName' ColumnOption in an 'enum' type Postgres", () => {
+    let connections: Connection[];
+    before(async () => connections = await createTestingConnections({
+        enabledDrivers: ["postgres"],
+        schemaCreate: false,
+        dropSchema: true,
+        entities: [TaskNotification],
+    }));
+    after(() => closeTestingConnections(connections));
+
+    it("should recognize model changes", () => Promise.all(connections.map(async connection => {
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.greaterThan(0);
+        sqlInMemory.downQueries.length.should.be.greaterThan(0);
+    })));
+
+    it("should not generate queries when no model changes", () => Promise.all(connections.map(async connection => {
+        await connection.driver.createSchemaBuilder().build();
+        const sqlInMemory = await connection.driver.createSchemaBuilder().log();
+        sqlInMemory.upQueries.length.should.be.equal(0);
+        sqlInMemory.downQueries.length.should.be.equal(0);
+    })));
+});
