diff --git a/src/Generator.php b/src/Generator.php
index 7c28df7ae..ce22885e7 100644
--- a/src/Generator.php
+++ b/src/Generator.php
@@ -1082,11 +1082,11 @@ private function getMethodParameters(ReflectionMethod $method, $forCall = false)
             $typeDeclaration = '';
 
             if (!$forCall) {
-                if ($parameter->hasType() && (string) $parameter->getType() !== 'self') {
-                    if (PHP_VERSION_ID >= 70100 && $parameter->allowsNull()) {
-                        $nullable = '?';
-                    }
+                if (PHP_VERSION_ID >= 70100 && $parameter->hasType() && $parameter->allowsNull()) {
+                    $nullable = '?';
+                }
 
+                if ($parameter->hasType() && (string) $parameter->getType() !== 'self') {
                     $typeDeclaration = (string) $parameter->getType() . ' ';
                 } elseif ($parameter->isArray()) {
                     $typeDeclaration = 'array ';
diff --git a/tests/Generator/397.phpt b/tests/Generator/397.phpt
new file mode 100644
index 000000000..1259e6f80
--- /dev/null
+++ b/tests/Generator/397.phpt
@@ -0,0 +1,98 @@
+--TEST--
+https://github.com/sebastianbergmann/phpunit-mock-objects/issues/397
+--FILE--
+<?php
+class C
+{
+    public function m(?self $other): self
+    {
+    }
+}
+
+require __DIR__ . '/../../vendor/autoload.php';
+
+$generator = new \PHPUnit\Framework\MockObject\Generator;
+
+$mock = $generator->generate(
+    C::class,
+    [],
+    'MockC',
+    true,
+    true
+);
+
+print $mock['code'];
+--EXPECTF--
+class MockC extends C implements PHPUnit\Framework\MockObject\MockObject
+{
+    private $__phpunit_invocationMocker;
+    private $__phpunit_originalObject;
+    private $__phpunit_configurable = ['m'];
+
+    public function __clone()
+    {
+        $this->__phpunit_invocationMocker = clone $this->__phpunit_getInvocationMocker();
+    }
+
+    public function m(?C $other): C
+    {
+        $arguments = array($other);
+        $count     = func_num_args();
+
+        if ($count > 1) {
+            $_arguments = func_get_args();
+
+            for ($i = 1; $i < $count; $i++) {
+                $arguments[] = $_arguments[$i];
+            }
+        }
+
+        $result = $this->__phpunit_getInvocationMocker()->invoke(
+            new \PHPUnit\Framework\MockObject\Invocation\ObjectInvocation(
+                'C', 'm', $arguments, 'C', $this, true
+            )
+        );
+
+        return $result;
+    }
+
+    public function expects(\PHPUnit\Framework\MockObject\Matcher\Invocation $matcher)
+    {
+        return $this->__phpunit_getInvocationMocker()->expects($matcher);
+    }
+
+    public function method()
+    {
+        $any = new \PHPUnit\Framework\MockObject\Matcher\AnyInvokedCount;
+        $expects = $this->expects($any);
+        return call_user_func_array(array($expects, 'method'), func_get_args());
+    }
+
+    public function __phpunit_setOriginalObject($originalObject)
+    {
+        $this->__phpunit_originalObject = $originalObject;
+    }
+
+    public function __phpunit_getInvocationMocker()
+    {
+        if ($this->__phpunit_invocationMocker === null) {
+            $this->__phpunit_invocationMocker = new \PHPUnit\Framework\MockObject\InvocationMocker($this->__phpunit_configurable);
+        }
+
+        return $this->__phpunit_invocationMocker;
+    }
+
+    public function __phpunit_hasMatchers()
+    {
+        return $this->__phpunit_getInvocationMocker()->hasMatchers();
+    }
+
+    public function __phpunit_verify($unsetInvocationMocker = true)
+    {
+        $this->__phpunit_getInvocationMocker()->verify();
+
+        if ($unsetInvocationMocker) {
+            $this->__phpunit_invocationMocker = null;
+        }
+    }
+}
