diff --git a/ChangeLog-7.5.md b/ChangeLog-7.5.md
index 75cc469bb..482771ec6 100644
--- a/ChangeLog-7.5.md
+++ b/ChangeLog-7.5.md
@@ -7,10 +7,12 @@ All notable changes of the PHPUnit 7.5 release series are documented in this fil
 ### Added
 
 * Implemented [#3340](https://github.com/sebastianbergmann/phpunit/issues/3340): Added `assertEqualsCanonicalizing()`, `assertEqualsIgnoringCase()`, `assertEqualsWithDelta()`, `assertNotEqualsCanonicalizing()`, `assertNotEqualsIgnoringCase()`, and `assertNotEqualsWithDelta()` as alternatives to using `assertEquals()` and `assertNotEquals()` with the `$delta`, `$canonicalize`, or `$ignoreCase` parameters
+* Implemented [#3368](https://github.com/sebastianbergmann/phpunit/issues/3368): Added `assertIsArray()`, `assertIsBool()`, `assertIsFloat()`, `assertIsInt()`, `assertIsNumeric()`, `assertIsObject()`, `assertIsResource()`, `assertIsString()`, `assertIsScalar()`, `assertIsCallable()`, `assertIsIterable()`, `assertIsNotArray()`, `assertIsNotBool()`, `assertIsNotFloat()`, `assertIsNotInt()`, `assertIsNotNumeric()`, `assertIsNotObject()`, `assertIsNotResource()`, `assertIsNotString()`, `assertIsNotScalar()`, `assertIsNotCallable()`, `assertIsNotIterable()` as alternatives to `assertInternalType()` and `assertNotInternalType()`
 
 ### Deprecated
 
 * The optional parameters `$delta`, `$maxDepth`, `$canonicalize`, and `$ignoreCase` of `assertEquals()`, and `assertNotEquals` are now deprecated. There is no behavioral change in this version of PHPUnit. Using these parameters will trigger a deprecation warning in PHPUnit 8 and in PHPUnit 9 these parameters will be removed.
+* The methods `assertInternalType()` and `assertNotInternalType()` are now deprecated. There is no behavioral change in this version of PHPUnit. Using these methods will trigger a deprecation warning in PHPUnit 8 and in PHPUnit 9 these methods will be removed.
 * The methods `assertAttributeContains()`, `assertAttributeNotContains()`, `assertAttributeContainsOnly()`, `assertAttributeNotContainsOnly()`, `assertAttributeCount()`, `assertAttributeNotCount()`, `assertAttributeEquals()`, `assertAttributeNotEquals()`, `assertAttributeEmpty()`, `assertAttributeNotEmpty()`, `assertAttributeGreaterThan()`, `assertAttributeGreaterThanOrEqual()`, `assertAttributeLessThan()`, `assertAttributeLessThanOrEqual()`, `assertAttributeSame()`, `assertAttributeNotSame()`, `assertAttributeInstanceOf()`, `assertAttributeNotInstanceOf()`, `assertAttributeInternalType()`, `assertAttributeNotInternalType()`, `attributeEqualTo()`, `readAttribute()`, `getStaticAttribute()`, and `getObjectAttribute()` are now deprecated. There is no behavioral change in this version of PHPUnit. Using these methods will trigger a deprecation warning in PHPUnit 8 and in PHPUnit 9 these methods will be removed.
 * The annotations `@expectedException`, `@expectedExceptionCode`, `@expectedExceptionMessage`, and `@expectedExceptionMessageRegExp` are now deprecated. There is no behavioral change in this version of PHPUnit. Using these annotations will trigger a deprecation warning in PHPUnit 8 and in PHPUnit 9 these annotations will be removed.
 
diff --git a/src/Framework/Assert.php b/src/Framework/Assert.php
index 9936ed0c4..b666c1023 100644
--- a/src/Framework/Assert.php
+++ b/src/Framework/Assert.php
@@ -1549,6 +1549,8 @@ public static function assertAttributeNotInstanceOf(string $expected, string $at
      *
      * @throws ExpectationFailedException
      * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
+     *
+     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/3369
      */
     public static function assertInternalType(string $expected, $actual, string $message = ''): void
     {
@@ -1578,11 +1580,145 @@ public static function assertAttributeInternalType(string $expected, string $att
         );
     }
 
+    /**
+     * Asserts that a variable is of type array.
+     */
+    public static function assertIsArray($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_ARRAY),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type bool.
+     */
+    public static function assertIsBool($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_BOOL),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type float.
+     */
+    public static function assertIsFloat($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_FLOAT),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type int.
+     */
+    public static function assertIsInt($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_INT),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type numeric.
+     */
+    public static function assertIsNumeric($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_NUMERIC),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type object.
+     */
+    public static function assertIsObject($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_OBJECT),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type resource.
+     */
+    public static function assertIsResource($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_RESOURCE),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type string.
+     */
+    public static function assertIsString($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_STRING),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type scalar.
+     */
+    public static function assertIsScalar($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_SCALAR),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type callable.
+     */
+    public static function assertIsCallable($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_CALLABLE),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is of type iterable.
+     */
+    public static function assertIsIterable($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new IsType(IsType::TYPE_ITERABLE),
+            $message
+        );
+    }
+
     /**
      * Asserts that a variable is not of a given type.
      *
      * @throws ExpectationFailedException
      * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
+     *
+     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/3369
      */
     public static function assertNotInternalType(string $expected, $actual, string $message = ''): void
     {
@@ -1595,6 +1731,138 @@ public static function assertNotInternalType(string $expected, $actual, string $
         );
     }
 
+    /**
+     * Asserts that a variable is not of type array.
+     */
+    public static function assertIsNotArray($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_ARRAY)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type bool.
+     */
+    public static function assertIsNotBool($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_BOOL)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type float.
+     */
+    public static function assertIsNotFloat($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_FLOAT)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type int.
+     */
+    public static function assertIsNotInt($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_INT)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type numeric.
+     */
+    public static function assertIsNotNumeric($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_NUMERIC)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type object.
+     */
+    public static function assertIsNotObject($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_OBJECT)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type resource.
+     */
+    public static function assertIsNotResource($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_RESOURCE)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type string.
+     */
+    public static function assertIsNotString($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_STRING)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type scalar.
+     */
+    public static function assertIsNotScalar($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_SCALAR)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type callable.
+     */
+    public static function assertIsNotCallable($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_CALLABLE)),
+            $message
+        );
+    }
+
+    /**
+     * Asserts that a variable is not of type iterable.
+     */
+    public static function assertIsNotIterable($actual, string $message = ''): void
+    {
+        static::assertThat(
+            $actual,
+            new LogicalNot(new IsType(IsType::TYPE_ITERABLE)),
+            $message
+        );
+    }
+
     /**
      * Asserts that an attribute is of a given type.
      *
diff --git a/tests/unit/Framework/AssertTest.php b/tests/unit/Framework/AssertTest.php
index 94c0daaaf..c1a7d28f5 100644
--- a/tests/unit/Framework/AssertTest.php
+++ b/tests/unit/Framework/AssertTest.php
@@ -2541,6 +2541,294 @@ public function testArraysCanBeComparedForEqualityWithCanonicalization(): void
         $this->assertNotEqualsCanonicalizing([3, 2, 1], [2, 3, 4]);
     }
 
+    public function testArrayTypeCanBeAsserted(): void
+    {
+        $this->assertIsArray([]);
+
+        try {
+            $this->assertIsArray(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testBoolTypeCanBeAsserted(): void
+    {
+        $this->assertIsBool(true);
+
+        try {
+            $this->assertIsBool(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testFloatTypeCanBeAsserted(): void
+    {
+        $this->assertIsFloat(0.0);
+
+        try {
+            $this->assertIsFloat(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testIntTypeCanBeAsserted(): void
+    {
+        $this->assertIsInt(1);
+
+        try {
+            $this->assertIsInt(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNumericTypeCanBeAsserted(): void
+    {
+        $this->assertIsNumeric('1.0');
+
+        try {
+            $this->assertIsNumeric('abc');
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testObjectTypeCanBeAsserted(): void
+    {
+        $this->assertIsObject(new \stdClass);
+
+        try {
+            $this->assertIsObject(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testResourceTypeCanBeAsserted(): void
+    {
+        $this->assertIsResource(\fopen(__FILE__, 'r'));
+
+        try {
+            $this->assertIsResource(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testStringTypeCanBeAsserted(): void
+    {
+        $this->assertIsString('');
+
+        try {
+            $this->assertIsString(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testScalarTypeCanBeAsserted(): void
+    {
+        $this->assertIsScalar(true);
+
+        try {
+            $this->assertIsScalar(new \stdClass);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testCallableTypeCanBeAsserted(): void
+    {
+        $this->assertIsCallable(function () {
+        });
+
+        try {
+            $this->assertIsCallable(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testIterableTypeCanBeAsserted(): void
+    {
+        $this->assertIsIterable([]);
+
+        try {
+            $this->assertIsIterable(null);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotArrayTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotArray(null);
+
+        try {
+            $this->assertIsNotArray([]);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotBoolTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotBool(null);
+
+        try {
+            $this->assertIsNotBool(true);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotFloatTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotFloat(null);
+
+        try {
+            $this->assertIsNotFloat(0.0);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotIntTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotInt(null);
+
+        try {
+            $this->assertIsNotInt(1);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotNumericTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotNumeric('abc');
+
+        try {
+            $this->assertIsNotNumeric('1.0');
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotObjectTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotObject(null);
+
+        try {
+            $this->assertIsNotObject(new \stdClass);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotResourceTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotResource(null);
+
+        try {
+            $this->assertIsNotResource(\fopen(__FILE__, 'r'));
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotScalarTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotScalar(new \stdClass);
+
+        try {
+            $this->assertIsNotScalar(true);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotStringTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotString(null);
+
+        try {
+            $this->assertIsNotString('');
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotCallableTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotCallable(null);
+
+        try {
+            $this->assertIsNotCallable(function () {
+            });
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
+    public function testNotIterableTypeCanBeAsserted(): void
+    {
+        $this->assertIsNotIterable(null);
+
+        try {
+            $this->assertIsNotIterable([]);
+        } catch (AssertionFailedError $e) {
+            return;
+        }
+
+        $this->fail();
+    }
+
     protected function sameValues(): array
     {
         $object   = new \SampleClass(4, 8, 15);
diff --git a/tests/unit/Framework/MockObject/MockObjectTest.php b/tests/unit/Framework/MockObject/MockObjectTest.php
index da9cd04e6..d43c46f79 100644
--- a/tests/unit/Framework/MockObject/MockObjectTest.php
+++ b/tests/unit/Framework/MockObject/MockObjectTest.php
@@ -1000,7 +1000,7 @@ public function testStringableClassDoesNotThrow(): void
         /** @var PHPUnit\Framework\MockObject\MockObject|StringableClass $mock */
         $mock = $this->getMockBuilder(StringableClass::class)->getMock();
 
-        $this->assertInternalType('string', (string) $mock);
+        $this->assertIsString((string) $mock);
     }
 
     public function testStringableClassCanBeMocked(): void
diff --git a/tests/unit/Framework/TestCaseTest.php b/tests/unit/Framework/TestCaseTest.php
index 874d4208c..b75829e3a 100644
--- a/tests/unit/Framework/TestCaseTest.php
+++ b/tests/unit/Framework/TestCaseTest.php
@@ -723,7 +723,7 @@ public function testProvidingOfAutoreferencedArray(): void
         $test = new \TestAutoreferenced('testJsonEncodeException', $this->getAutoreferencedArray());
         $test->runBare();
 
-        $this->assertInternalType('array', $test->myTestData);
+        $this->assertIsArray($test->myTestData);
         $this->assertArrayHasKey('data', $test->myTestData);
         $this->assertEquals($test->myTestData['data'][0], $test->myTestData['data']);
     }
@@ -739,7 +739,7 @@ public function testProvidingArrayThatMixesObjectsAndScalars(): void
         $test = new \TestAutoreferenced('testJsonEncodeException', [$data]);
         $test->runBare();
 
-        $this->assertInternalType('array', $test->myTestData);
+        $this->assertIsArray($test->myTestData);
         $this->assertSame($data, $test->myTestData);
     }
 
