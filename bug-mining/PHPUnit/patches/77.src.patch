diff --git a/PHPUnit/Framework/MockObject/Generator.php b/PHPUnit/Framework/MockObject/Generator.php
index 77e9bb122..0d6cf308b 100644
--- a/PHPUnit/Framework/MockObject/Generator.php
+++ b/PHPUnit/Framework/MockObject/Generator.php
@@ -105,12 +105,6 @@ protected static function generateMock($originalClassName, array $methods, $mock
         $templateDir   = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'Generator' . DIRECTORY_SEPARATOR;
         $classTemplate = new PHPUnit_Util_Template($templateDir . 'mocked_class.tpl');
 
-        if (!$callOriginalClone) {
-            $cloneTemplate = new PHPUnit_Util_Template($templateDir . 'mocked_clone.tpl');
-        } else {
-            $cloneTemplate = new PHPUnit_Util_Template($templateDir . 'unmocked_clone.tpl');
-        }
-
         $mockClassName = self::generateMockClassName(
           $originalClassName, $mockClassName
         );
@@ -147,6 +141,26 @@ protected static function generateMock($originalClassName, array $methods, $mock
             );
         }
 
+        $cloneTemplate = '';
+
+        if ($class->hasMethod('__clone')) {
+            $cloneMethod = $class->getMethod('__clone');
+
+            if (!$cloneMethod->isFinal()) {
+                if ($callOriginalClone) {
+                    $cloneTemplate = new PHPUnit_Util_Template($templateDir . 'unmocked_clone.tpl');
+                } else {
+                    $cloneTemplate = new PHPUnit_Util_Template($templateDir . 'mocked_clone.tpl');
+                }
+            }
+        } else {
+            $cloneTemplate = new PHPUnit_Util_Template($templateDir . 'mocked_clone.tpl');
+        }
+
+        if (is_object($cloneTemplate)) {
+            $cloneTemplate = $cloneTemplate->render();
+        }
+
         if (is_array($methods) && empty($methods) && ($isClass || $isInterface)) {
             $methods = get_class_methods($originalClassName);
         }
@@ -183,7 +197,7 @@ protected static function generateMock($originalClassName, array $methods, $mock
                                      $mockClassName['mockClassName'],
                                      $callOriginalConstructor
                                    ),
-            'clone'             => $cloneTemplate->render(),
+            'clone'             => $cloneTemplate,
             'mocked_methods'    => $mockedMethods
           )
         );
@@ -251,6 +265,15 @@ protected static function generateMockConstructor($templateDir, ReflectionClass
         $constructor            = $class->getConstructor();
         $constructorInInterface = FALSE;
 
+        if ($constructor !== NULL && $constructor->isFinal()) {
+            throw new RuntimeException(
+              sprintf(
+                'Constructor of class "%s" is declared "final". The class cannot be mocked.',
+                $mockedClassName
+              )
+            );
+        }
+
         if ($constructor !== NULL && $callOriginalConstructor) {
             $template = new PHPUnit_Util_Template($templateDir . 'unmocked_constructor.tpl');
         } else {
