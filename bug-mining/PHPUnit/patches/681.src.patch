diff --git a/.psalm/baseline.xml b/.psalm/baseline.xml
index a807920d2..800641644 100644
--- a/.psalm/baseline.xml
+++ b/.psalm/baseline.xml
@@ -487,6 +487,14 @@
       <code>$client-&gt;__getFunctions()</code>
     </PossiblyNullArgument>
   </file>
+  <file src="src/Framework/MockObject/Invocation.php">
+    <ArgumentTypeCoercion occurrences="1">
+      <code>$types</code>
+    </ArgumentTypeCoercion>
+    <MissingThrowsDocblock occurrences="1">
+      <code>throw $t;</code>
+    </MissingThrowsDocblock>
+  </file>
   <file src="src/Framework/MockObject/InvocationHandler.php">
     <MissingReturnType occurrences="1">
       <code>invoke</code>
diff --git a/ChangeLog-9.5.md b/ChangeLog-9.5.md
index e24826de5..9d8557d55 100644
--- a/ChangeLog-9.5.md
+++ b/ChangeLog-9.5.md
@@ -7,6 +7,7 @@ All notable changes of the PHPUnit 9.5 release series are documented in this fil
 ### Fixed
 
 * [#4929](https://github.com/sebastianbergmann/phpunit/issues/4929): Test Double code generator does not handle new expressions inside parameter default values
+* [#4932](https://github.com/sebastianbergmann/phpunit/issues/4932): Backport support for intersection types from PHPUnit 10 to PHPUnit 9.5
 * [#4933](https://github.com/sebastianbergmann/phpunit/issues/4933): Backport support for `never` type from PHPUnit 10 to PHPUnit 9.5
 
 ## [9.5.18] - 2022-03-08
diff --git a/src/Framework/MockObject/Generator.php b/src/Framework/MockObject/Generator.php
index cb8531cd3..5c347756b 100644
--- a/src/Framework/MockObject/Generator.php
+++ b/src/Framework/MockObject/Generator.php
@@ -171,6 +171,67 @@ public function getMock(string $type, $methods = [], array $arguments = [], stri
         );
     }
 
+    /**
+     * @psalm-param list<class-string> $interfaces
+     *
+     * @throws RuntimeException
+     * @throws UnknownTypeException
+     */
+    public function getMockForInterfaces(array $interfaces, bool $callAutoload = true): MockObject
+    {
+        if (count($interfaces) < 2) {
+            throw new RuntimeException('At least two interfaces must be specified');
+        }
+
+        foreach ($interfaces as $interface) {
+            if (!interface_exists($interface, $callAutoload)) {
+                throw new UnknownTypeException($interface);
+            }
+        }
+
+        sort($interfaces);
+
+        $methods = [];
+
+        foreach ($interfaces as $interface) {
+            $methods = array_merge($methods, $this->getClassMethods($interface));
+        }
+
+        if (count(array_unique($methods)) < count($methods)) {
+            throw new RuntimeException('Interfaces must not declare the same method');
+        }
+
+        $unqualifiedNames = [];
+
+        foreach ($interfaces as $interface) {
+            $parts              = explode('\\', $interface);
+            $unqualifiedNames[] = array_pop($parts);
+        }
+
+        sort($unqualifiedNames);
+
+        do {
+            $intersectionName = sprintf(
+                'Intersection_%s_%s',
+                implode('_', $unqualifiedNames),
+                substr(md5((string) mt_rand()), 0, 8)
+            );
+        } while (interface_exists($intersectionName, false));
+
+        $template = $this->getTemplate('intersection.tpl');
+
+        $template->setVar(
+            [
+                'intersection' => $intersectionName,
+                'interfaces'   => implode(', ', $interfaces),
+            ]
+        );
+
+        eval($template->render());
+
+        return $this->getMock($intersectionName);
+    }
+
     /**
      * Returns a mock object for the specified abstract class with all abstract
      * methods of the class mocked.
diff --git a/src/Framework/MockObject/Generator/intersection.tpl b/src/Framework/MockObject/Generator/intersection.tpl
new file mode 100644
index 000000000..75cd27a6c
--- /dev/null
+++ b/src/Framework/MockObject/Generator/intersection.tpl
@@ -0,0 +1,5 @@
+declare(strict_types=1);
+
+interface {intersection} extends {interfaces}
+{
+}
diff --git a/src/Framework/MockObject/Invocation.php b/src/Framework/MockObject/Invocation.php
index 392938347..0166c58cb 100644
--- a/src/Framework/MockObject/Invocation.php
+++ b/src/Framework/MockObject/Invocation.php
@@ -121,100 +121,141 @@ public function generateReturnValue()
             return null;
         }
 
-        $union = false;
+        $intersection = false;
+        $union        = false;
 
         if (strpos($this->returnType, '|') !== false) {
             $types = explode('|', $this->returnType);
             $union = true;
+        } elseif (strpos($this->returnType, '&') !== false) {
+            $types        = explode('&', $this->returnType);
+            $intersection = true;
         } else {
             $types = [$this->returnType];
         }
 
         $types = array_map('strtolower', $types);
 
-        if (in_array('', $types, true) ||
-            in_array('null', $types, true) ||
-            in_array('mixed', $types, true) ||
-            in_array('void', $types, true)) {
-            return null;
-        }
+        if (!$intersection) {
+            if (in_array('', $types, true) ||
+                in_array('null', $types, true) ||
+                in_array('mixed', $types, true) ||
+                in_array('void', $types, true)) {
+                return null;
+            }
 
-        if (in_array('false', $types, true) ||
-            in_array('bool', $types, true)) {
-            return false;
-        }
+            if (in_array('false', $types, true) ||
+                in_array('bool', $types, true)) {
+                return false;
+            }
 
-        if (in_array('float', $types, true)) {
-            return 0.0;
-        }
+            if (in_array('float', $types, true)) {
+                return 0.0;
+            }
 
-        if (in_array('int', $types, true)) {
-            return 0;
-        }
+            if (in_array('int', $types, true)) {
+                return 0;
+            }
 
-        if (in_array('string', $types, true)) {
-            return '';
-        }
+            if (in_array('string', $types, true)) {
+                return '';
+            }
 
-        if (in_array('array', $types, true)) {
-            return [];
-        }
+            if (in_array('array', $types, true)) {
+                return [];
+            }
 
-        if (in_array('static', $types, true)) {
-            try {
-                return (new Instantiator)->instantiate(get_class($this->object));
-            } catch (Throwable $t) {
-                throw new RuntimeException(
-                    $t->getMessage(),
-                    (int) $t->getCode(),
-                    $t
-                );
+            if (in_array('static', $types, true)) {
+                try {
+                    return (new Instantiator)->instantiate(get_class($this->object));
+                } catch (Throwable $t) {
+                    throw new RuntimeException(
+                        $t->getMessage(),
+                        (int) $t->getCode(),
+                        $t
+                    );
+                }
             }
-        }
 
-        if (in_array('object', $types, true)) {
-            return new stdClass;
-        }
+            if (in_array('object', $types, true)) {
+                return new stdClass;
+            }
 
-        if (in_array('callable', $types, true) ||
-            in_array('closure', $types, true)) {
-            return static function (): void
-            {
-            };
-        }
+            if (in_array('callable', $types, true) ||
+                in_array('closure', $types, true)) {
+                return static function (): void
+                {
+                };
+            }
 
-        if (in_array('traversable', $types, true) ||
-            in_array('generator', $types, true) ||
-            in_array('iterable', $types, true)) {
-            $generator = static function (): \Generator
-            {
-                yield from [];
-            };
+            if (in_array('traversable', $types, true) ||
+                in_array('generator', $types, true) ||
+                in_array('iterable', $types, true)) {
+                $generator = static function (): \Generator
+                {
+                    yield from [];
+                };
 
-            return $generator();
-        }
+                return $generator();
+            }
+
+            if (!$union) {
+                try {
+                    return (new Generator)->getMock($this->returnType, [], [], '', false);
+                } catch (Throwable $t) {
+                    if ($t instanceof Exception) {
+                        throw $t;
+                    }
 
-        if (!$union) {
-            try {
-                return (new Generator)->getMock($this->returnType, [], [], '', false);
-            } catch (Throwable $t) {
-                throw new RuntimeException(
-                    sprintf(
-                        'Return value for %s::%s() cannot be generated: %s',
-                        $this->className,
-                        $this->methodName,
+                    throw new RuntimeException(
                         $t->getMessage(),
-                    ),
-                    (int) $t->getCode(),
-                );
+                        (int) $t->getCode(),
+                        $t
+                    );
+                }
+            }
+        }
+
+        $reason = '';
+
+        if ($union) {
+            $reason = ' because the declared return type is a union';
+        } elseif ($intersection) {
+            $reason = ' because the declared return type is an intersection';
+
+            $onlyInterfaces = true;
+
+            foreach ($types as $type) {
+                if (!interface_exists($type)) {
+                    $onlyInterfaces = false;
+
+                    break;
+                }
+            }
+
+            if ($onlyInterfaces) {
+                try {
+                    return (new Generator)->getMockForInterfaces($types);
+                } catch (Throwable $t) {
+                    throw new RuntimeException(
+                        sprintf(
+                            'Return value for %s::%s() cannot be generated: %s',
+                            $this->className,
+                            $this->methodName,
+                            $t->getMessage(),
+                        ),
+                        (int) $t->getCode(),
+                    );
+                }
             }
         }
 
         throw new RuntimeException(
             sprintf(
-                'Return value for %s::%s() cannot be generated because the declared return type is a union, please configure a return value for this method',
+                'Return value for %s::%s() cannot be generated%s, please configure a return value for this method',
                 $this->className,
-                $this->methodName
+                $this->methodName,
+                $reason
             )
         );
     }
diff --git a/src/Framework/MockObject/MockMethod.php b/src/Framework/MockObject/MockMethod.php
index efa06f492..d3bd32669 100644
--- a/src/Framework/MockObject/MockMethod.php
+++ b/src/Framework/MockObject/MockMethod.php
@@ -23,6 +23,7 @@
 use function substr_count;
 use function trim;
 use function var_export;
+use ReflectionIntersectionType;
 use ReflectionMethod;
 use ReflectionNamedType;
 use ReflectionParameter;
@@ -32,7 +33,6 @@
 use SebastianBergmann\Type\ReflectionMapper;
 use SebastianBergmann\Type\Type;
 use SebastianBergmann\Type\UnknownType;
-use SebastianBergmann\Type\VoidType;
 
 /**
  * @internal This class is not covered by the backward compatibility promise for PHPUnit
@@ -309,7 +309,7 @@ private static function getMethodParametersForDeclaration(ReflectionMethod $meth
             }
 
             if ($type !== null) {
-                if ($typeName !== 'mixed' && $parameter->allowsNull() && !$type instanceof ReflectionUnionType) {
+                if ($typeName !== 'mixed' && $parameter->allowsNull() && !$type instanceof ReflectionIntersectionType && !$type instanceof ReflectionUnionType) {
                     $nullable = '?';
                 }
 
@@ -322,6 +322,8 @@ private static function getMethodParametersForDeclaration(ReflectionMethod $meth
                         $type,
                         $method->getDeclaringClass()->getName()
                     );
+                } elseif ($type instanceof ReflectionIntersectionType) {
+                    $typeDeclaration = self::intersectionTypeAsString($type);
                 }
             }
 
@@ -418,4 +420,15 @@ private static function unionTypeAsString(ReflectionUnionType $union, string $se
 
         return implode('|', $types) . ' ';
     }
+
+    private static function intersectionTypeAsString(ReflectionIntersectionType $intersection): string
+    {
+        $types = [];
+
+        foreach ($intersection->getTypes() as $type) {
+            $types[] = $type;
+        }
+
+        return implode('&', $types) . ' ';
+    }
 }
diff --git a/tests/_files/mock-object/InterfaceWithMethodReturningIntersection.php b/tests/_files/mock-object/InterfaceWithMethodReturningIntersection.php
new file mode 100644
index 000000000..434f9440b
--- /dev/null
+++ b/tests/_files/mock-object/InterfaceWithMethodReturningIntersection.php
@@ -0,0 +1,15 @@
+<?php declare(strict_types=1);
+/*
+ * This file is part of PHPUnit.
+ *
+ * (c) Sebastian Bergmann <sebastian@phpunit.de>
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+namespace PHPUnit\TestFixture\MockObject;
+
+interface InterfaceWithMethodReturningIntersection
+{
+    public function method(): AnInterface & AnotherInterface;
+}
diff --git a/tests/end-to-end/mock-objects/generator/intersection_type_parameter.phpt b/tests/end-to-end/mock-objects/generator/intersection_type_parameter.phpt
new file mode 100644
index 000000000..b82be7d08
--- /dev/null
+++ b/tests/end-to-end/mock-objects/generator/intersection_type_parameter.phpt
@@ -0,0 +1,68 @@
+--TEST--
+\PHPUnit\Framework\MockObject\Generator::generate('Foo', [], 'MockFoo', true, true)
+--SKIPIF--
+<?php declare(strict_types=1);
+if (version_compare('8.1.0-dev', PHP_VERSION, '>')) {
+    print 'skip: PHP 8.1 is required.';
+}
+--FILE--
+<?php declare(strict_types=1);
+interface AnInterface
+{
+}
+
+interface AnotherInterface
+{
+}
+
+class Foo
+{
+    public function bar(AnInterface&AnotherInterface $baz)
+    {
+    }
+}
+
+require_once __DIR__ . '/../../../../vendor/autoload.php';
+
+$generator = new \PHPUnit\Framework\MockObject\Generator;
+
+$mock = $generator->generate(
+    Foo::class,
+    [],
+    'MockFoo',
+    true,
+    true
+);
+
+print $mock->getClassCode();
+--EXPECTF--
+declare(strict_types=1);
+
+class MockFoo extends Foo implements PHPUnit\Framework\MockObject\MockObject
+{
+    use \PHPUnit\Framework\MockObject\Api;
+    use \PHPUnit\Framework\MockObject\Method;
+    use \PHPUnit\Framework\MockObject\MockedCloneMethod;
+
+    public function bar(AnInterface&AnotherInterface $baz)
+    {
+        $__phpunit_arguments = [$baz];
+        $__phpunit_count     = func_num_args();
+
+        if ($__phpunit_count > 1) {
+            $__phpunit_arguments_tmp = func_get_args();
+
+            for ($__phpunit_i = 1; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
+                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
+            }
+        }
+
+        $__phpunit_result = $this->__phpunit_getInvocationHandler()->invoke(
+            new \PHPUnit\Framework\MockObject\Invocation(
+                'Foo', 'bar', $__phpunit_arguments, '', $this, true
+            )
+        );
+
+        return $__phpunit_result;
+    }
+}
diff --git a/tests/end-to-end/mock-objects/generator/intersection_type_return.phpt b/tests/end-to-end/mock-objects/generator/intersection_type_return.phpt
new file mode 100644
index 000000000..e3aec85fc
--- /dev/null
+++ b/tests/end-to-end/mock-objects/generator/intersection_type_return.phpt
@@ -0,0 +1,68 @@
+--TEST--
+\PHPUnit\Framework\MockObject\Generator::generate('Foo', [], 'MockFoo', true, true)
+--SKIPIF--
+<?php declare(strict_types=1);
+if (version_compare('8.1.0-dev', PHP_VERSION, '>')) {
+    print 'skip: PHP 8.1 is required.';
+}
+--FILE--
+<?php declare(strict_types=1);
+interface AnInterface
+{
+}
+
+interface AnotherInterface
+{
+}
+
+class Foo
+{
+    public function bar(): AnInterface&AnotherInterface
+    {
+    }
+}
+
+require_once __DIR__ . '/../../../../vendor/autoload.php';
+
+$generator = new \PHPUnit\Framework\MockObject\Generator;
+
+$mock = $generator->generate(
+    Foo::class,
+    [],
+    'MockFoo',
+    true,
+    true
+);
+
+print $mock->getClassCode();
+--EXPECTF--
+declare(strict_types=1);
+
+class MockFoo extends Foo implements PHPUnit\Framework\MockObject\MockObject
+{
+    use \PHPUnit\Framework\MockObject\Api;
+    use \PHPUnit\Framework\MockObject\Method;
+    use \PHPUnit\Framework\MockObject\MockedCloneMethod;
+
+    public function bar(): AnInterface&AnotherInterface
+    {
+        $__phpunit_arguments = [];
+        $__phpunit_count     = func_num_args();
+
+        if ($__phpunit_count > 0) {
+            $__phpunit_arguments_tmp = func_get_args();
+
+            for ($__phpunit_i = 0; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
+                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
+            }
+        }
+
+        $__phpunit_result = $this->__phpunit_getInvocationHandler()->invoke(
+            new \PHPUnit\Framework\MockObject\Invocation(
+                'Foo', 'bar', $__phpunit_arguments, 'AnInterface&AnotherInterface', $this, true
+            )
+        );
+
+        return $__phpunit_result;
+    }
+}
diff --git a/tests/unit/Framework/MockObject/GeneratorTest.php b/tests/unit/Framework/MockObject/GeneratorTest.php
index d1417be34..b93a4e72f 100644
--- a/tests/unit/Framework/MockObject/GeneratorTest.php
+++ b/tests/unit/Framework/MockObject/GeneratorTest.php
@@ -17,7 +17,9 @@
 use Exception;
 use PHPUnit\Framework\TestCase;
 use PHPUnit\TestFixture\AbstractTrait;
+use PHPUnit\TestFixture\AnInterface;
 use PHPUnit\TestFixture\AnInterfaceWithReturnType;
+use PHPUnit\TestFixture\AnotherInterface;
 use PHPUnit\TestFixture\ClassWithVariadicArgumentMethod;
 use PHPUnit\TestFixture\ExceptionWithThrowable;
 use PHPUnit\TestFixture\FinalClass;
@@ -322,4 +324,23 @@ public function testCannotMockFinalClass(): void
         /* @noinspection ClassMockingCorrectnessInspection */
         $this->createMock(FinalClass::class);
     }
+
+    public function testCanDoubleIntersectionOfMultipleInterfaces(): void
+    {
+        $stub = $this->generator->getMockForInterfaces(
+            [
+                AnInterface::class,
+                AnotherInterface::class,
+            ]
+        );
+
+        $this->assertInstanceOf(AnInterface::class, $stub);
+        $this->assertInstanceOf(AnotherInterface::class, $stub);
+
+        $stub->method('doSomething')->willReturn(true);
+        $stub->method('doSomethingElse')->willReturn(false);
+
+        $this->assertTrue($stub->doSomething());
+        $this->assertFalse($stub->doSomethingElse());
+    }
 }
diff --git a/tests/unit/Framework/MockObject/MockObjectTest.php b/tests/unit/Framework/MockObject/MockObjectTest.php
index 61f7158f1..a945b775d 100644
--- a/tests/unit/Framework/MockObject/MockObjectTest.php
+++ b/tests/unit/Framework/MockObject/MockObjectTest.php
@@ -32,6 +32,7 @@
 use PHPUnit\TestFixture\MethodCallback;
 use PHPUnit\TestFixture\MethodCallbackByReference;
 use PHPUnit\TestFixture\MockObject\AbstractMockTestClass;
+use PHPUnit\TestFixture\MockObject\InterfaceWithMethodReturningIntersection;
 use PHPUnit\TestFixture\PartialMockTestClass;
 use PHPUnit\TestFixture\SomeClass;
 use PHPUnit\TestFixture\StringableClass;
@@ -1275,6 +1276,18 @@ public function testMethodThatReturnsBoolCanBeStubbed(): void
         $this->assertFalse($i->returnsBool());
     }
 
+    /**
+     * @requires PHP 8.1
+     */
+    public function testReturnValueCannotBeAutomaticallyGeneratedForMethodThatReturnsIntersection(): void
+    {
+        $stub = $this->createStub(InterfaceWithMethodReturningIntersection::class);
+
+        $this->expectException(\PHPUnit\Framework\MockObject\RuntimeException::class);
+
+        $stub->method();
+    }
+
     private function resetMockObjects(): void
     {
         $refl = new ReflectionObject($this);
