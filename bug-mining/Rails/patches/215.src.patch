diff --git a/activerecord/lib/active_record/connection_adapters/postgresql/quoting.rb b/activerecord/lib/active_record/connection_adapters/postgresql/quoting.rb
index 5b6ab83725..9ee31bff84 100644
--- a/activerecord/lib/active_record/connection_adapters/postgresql/quoting.rb
+++ b/activerecord/lib/active_record/connection_adapters/postgresql/quoting.rb
@@ -205,7 +205,17 @@ def encode_array(array_data)
           end
 
           def encode_range(range)
-            "[#{type_cast_range_value(range.begin)},#{type_cast_range_value(range.end)}#{range.exclude_end? ? ')' : ']'}"
+            lower_bound = type_cast_range_value(range.begin)
+            upper_bound = if date_or_time_range?(range)
+              # Postgres will convert `[today,]` to `[today,)`, making it exclusive.
+              # We can use the special timestamp value `infinity` to force inclusion.
+              # https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-INFINITE
+              range.end.nil? ? "infinity" : type_cast(range.end)
+            else
+              type_cast_range_value(range.end)
+            end
+
+            "[#{lower_bound},#{upper_bound}#{range.exclude_end? ? ')' : ']'}"
           end
 
           def determine_encoding_of_strings_in_array(value)
@@ -229,6 +239,10 @@ def type_cast_range_value(value)
           def infinity?(value)
             value.respond_to?(:infinite?) && value.infinite?
           end
+
+          def date_or_time_range?(range)
+            [range.begin.class, range.end.class].intersect?([Date, DateTime, Time])
+          end
       end
     end
   end
diff --git a/activerecord/test/cases/adapters/postgresql/range_test.rb b/activerecord/test/cases/adapters/postgresql/range_test.rb
index 0d789d26fb..7f5bd44cf2 100644
--- a/activerecord/test/cases/adapters/postgresql/range_test.rb
+++ b/activerecord/test/cases/adapters/postgresql/range_test.rb
@@ -196,14 +196,14 @@ def test_timezone_awareness_endless_tzrange
       time_string = Time.current.to_s
       time = Time.zone.parse(time_string)
 
-      record = PostgresqlRange.new(tstz_range: time_string...)
-      assert_equal time..., record.tstz_range
+      record = PostgresqlRange.new(tstz_range: time_string..)
+      assert_equal time.., record.tstz_range
       assert_equal ActiveSupport::TimeZone[tz], record.tstz_range.begin.time_zone
 
       record.save!
       record.reload
 
-      assert_equal time..., record.tstz_range
+      assert_equal time.., record.tstz_range
       assert_equal ActiveSupport::TimeZone[tz], record.tstz_range.begin.time_zone
     end
   end
@@ -302,9 +302,12 @@ def test_escaped_tsrange
   end
 
   def test_unbounded_tsrange
-    tz = ::ActiveRecord.default_timezone
-    assert_equal_round_trip @first_range, :ts_range, Time.public_send(tz, 2010, 1, 1, 14, 30, 0)...nil
-    assert_equal_round_trip @first_range, :ts_range, nil..Time.public_send(tz, 2010, 1, 1, 14, 30, 0)
+    time = Time.public_send(::ActiveRecord.default_timezone, 2010, 1, 1, 14, 30, 0)
+
+    assert_equal_round_trip @first_range, :ts_range, time..nil
+    assert_equal_round_trip @first_range, :ts_range, time...nil
+    assert_equal_round_trip @first_range, :ts_range, nil..time
+    assert_equal_round_trip @first_range, :ts_range, nil...time
   end
 
   def test_timezone_awareness_tsrange
