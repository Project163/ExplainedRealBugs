diff --git a/activerecord/lib/active_record/reflection.rb b/activerecord/lib/active_record/reflection.rb
index 70344b8424..f4d196332c 100644
--- a/activerecord/lib/active_record/reflection.rb
+++ b/activerecord/lib/active_record/reflection.rb
@@ -425,10 +425,14 @@ def compute_class(name)
 
         begin
           klass = active_record.send(:compute_type, name)
-        rescue NameError
-          message = "Missing model class #{name} for the #{active_record}##{self.name} association."
-          message += " You can specify a different model class with the :class_name option." unless options[:class_name]
-          raise NameError, message
+        rescue NameError => error
+          if error.name.match?(/(?:\A|::)#{name}\z/)
+            message = "Missing model class #{name} for the #{active_record}##{self.name} association."
+            message += " You can specify a different model class with the :class_name option." unless options[:class_name]
+            raise NameError.new(message, name)
+          else
+            raise
+          end
         end
 
         unless klass < ActiveRecord::Base
@@ -619,7 +623,9 @@ def automatic_inverse_of
 
             begin
               reflection = klass._reflect_on_association(inverse_name)
-            rescue NameError
+            rescue NameError => error
+              raise unless error.name.to_s == class_name
+
               # Give up: we couldn't compute the klass type so we won't be able
               # to find any associations either.
               reflection = false
diff --git a/activerecord/test/cases/reflection_test.rb b/activerecord/test/cases/reflection_test.rb
index 77e3b7a887..6bc3443165 100644
--- a/activerecord/test/cases/reflection_test.rb
+++ b/activerecord/test/cases/reflection_test.rb
@@ -143,6 +143,7 @@ def test_reflection_klass_not_found_with_no_class_name_option
       UserWithInvalidRelation.reflect_on_association(:not_a_class).klass
     end
 
+    assert_equal "NotAClass", error.name
     assert_match %r/missing/i, error.message
     assert_match "NotAClass", error.message
     assert_match "UserWithInvalidRelation#not_a_class", error.message
@@ -154,6 +155,7 @@ def test_reflection_klass_not_found_with_pointer_to_non_existent_class_name
       UserWithInvalidRelation.reflect_on_association(:class_name_provided_not_a_class).klass
     end
 
+    assert_equal "NotAClass", error.name
     assert_match %r/missing/i, error.message
     assert_match %r/\bNotAClass\b/, error.message
     assert_match "UserWithInvalidRelation#class_name_provided_not_a_class", error.message
@@ -560,11 +562,41 @@ def test_reflect_on_association_accepts_strings
     end
   end
 
+  def test_name_error_from_incidental_code_is_not_converted_to_name_error_for_association
+    UserWithInvalidRelation.stub(:const_missing, proc { oops }) do
+      reflection = UserWithInvalidRelation.reflect_on_association(:not_a_class)
+
+      error = assert_raises(NameError) do
+        reflection.klass
+      end
+
+      assert_equal :oops, error.name
+      assert_match "oops", error.message
+      assert_no_match "NotAClass", error.message
+      assert_no_match "not_a_class", error.message
+    end
+  end
+
   def test_automatic_inverse_suppresses_name_error_for_association
     reflection = UserWithInvalidRelation.reflect_on_association(:not_a_class)
     assert_not reflection.dup.has_inverse? # dup to prevent global memoization
   end
 
+  def test_automatic_inverse_does_not_suppress_name_error_from_incidental_code
+    UserWithInvalidRelation.stub(:const_missing, proc { oops }) do
+      reflection = UserWithInvalidRelation.reflect_on_association(:not_a_class)
+
+      error = assert_raises(NameError) do
+        reflection.dup.has_inverse? # dup to prevent global memoization
+      end
+
+      assert_equal :oops, error.name
+      assert_match "oops", error.message
+      assert_no_match "NotAClass", error.message
+      assert_no_match "not_a_class", error.message
+    end
+  end
+
   private
     def assert_reflection(klass, association, options)
       assert reflection = klass.reflect_on_association(association)
