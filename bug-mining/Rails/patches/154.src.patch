diff --git a/activerecord/lib/active_record/enum.rb b/activerecord/lib/active_record/enum.rb
index 96e53432c4..02ebbc1992 100644
--- a/activerecord/lib/active_record/enum.rb
+++ b/activerecord/lib/active_record/enum.rb
@@ -213,74 +213,79 @@ def assert_valid_value(value)
         attr_reader :name, :mapping
     end
 
-    def enum(name, values, prefix: nil, suffix: nil, scopes: true, instance_methods: true, validate: false, **options)
-      assert_valid_enum_definition_values(values)
-      assert_valid_enum_options(options)
+    def enum(name, values = nil, **options)
+      values, options = options, {} unless values
+      _enum(name, values, **options)
+    end
 
-      # statuses = { }
-      enum_values = ActiveSupport::HashWithIndifferentAccess.new
-      name = name.to_s
+    private
+      def _enum(name, values, prefix: nil, suffix: nil, scopes: true, instance_methods: true, validate: false, **options)
+        assert_valid_enum_definition_values(values)
+        assert_valid_enum_options(options)
 
-      # def self.statuses() statuses end
-      detect_enum_conflict!(name, name.pluralize, true)
-      singleton_class.define_method(name.pluralize) { enum_values }
-      defined_enums[name] = enum_values
+        # statuses = { }
+        enum_values = ActiveSupport::HashWithIndifferentAccess.new
+        name = name.to_s
 
-      detect_enum_conflict!(name, name)
-      detect_enum_conflict!(name, "#{name}=")
+        # def self.statuses() statuses end
+        detect_enum_conflict!(name, name.pluralize, true)
+        singleton_class.define_method(name.pluralize) { enum_values }
+        defined_enums[name] = enum_values
 
-      attribute(name, **options)
+        detect_enum_conflict!(name, name)
+        detect_enum_conflict!(name, "#{name}=")
 
-      decorate_attributes([name]) do |_name, subtype|
-        if subtype == ActiveModel::Type.default_value
-          raise "Undeclared attribute type for enum '#{name}' in #{self.name}. Enums must be" \
-            " backed by a database column or declared with an explicit type" \
-            " via `attribute`."
-        end
+        attribute(name, **options)
 
-        subtype = subtype.subtype if EnumType === subtype
-        EnumType.new(name, enum_values, subtype, raise_on_invalid_values: !validate)
-      end
+        decorate_attributes([name]) do |_name, subtype|
+          if subtype == ActiveModel::Type.default_value
+            raise "Undeclared attribute type for enum '#{name}' in #{self.name}. Enums must be" \
+              " backed by a database column or declared with an explicit type" \
+              " via `attribute`."
+          end
 
-      value_method_names = []
-      _enum_methods_module.module_eval do
-        prefix = if prefix
-          prefix == true ? "#{name}_" : "#{prefix}_"
+          subtype = subtype.subtype if EnumType === subtype
+          EnumType.new(name, enum_values, subtype, raise_on_invalid_values: !validate)
         end
 
-        suffix = if suffix
-          suffix == true ? "_#{name}" : "_#{suffix}"
-        end
+        value_method_names = []
+        _enum_methods_module.module_eval do
+          prefix = if prefix
+            prefix == true ? "#{name}_" : "#{prefix}_"
+          end
+
+          suffix = if suffix
+            suffix == true ? "_#{name}" : "_#{suffix}"
+          end
 
-        pairs = values.respond_to?(:each_pair) ? values.each_pair : values.each_with_index
-        pairs.each do |label, value|
-          enum_values[label] = value
-          label = label.to_s
+          pairs = values.respond_to?(:each_pair) ? values.each_pair : values.each_with_index
+          pairs.each do |label, value|
+            enum_values[label] = value
+            label = label.to_s
 
-          value_method_name = "#{prefix}#{label}#{suffix}"
-          value_method_names << value_method_name
-          define_enum_methods(name, value_method_name, value, scopes, instance_methods)
+            value_method_name = "#{prefix}#{label}#{suffix}"
+            value_method_names << value_method_name
+            define_enum_methods(name, value_method_name, value, scopes, instance_methods)
 
-          method_friendly_label = label.gsub(/[\W&&[:ascii:]]+/, "_")
-          value_method_alias = "#{prefix}#{method_friendly_label}#{suffix}"
+            method_friendly_label = label.gsub(/[\W&&[:ascii:]]+/, "_")
+            value_method_alias = "#{prefix}#{method_friendly_label}#{suffix}"
 
-          if value_method_alias != value_method_name && !value_method_names.include?(value_method_alias)
-            value_method_names << value_method_alias
-            define_enum_methods(name, value_method_alias, value, scopes, instance_methods)
+            if value_method_alias != value_method_name && !value_method_names.include?(value_method_alias)
+              value_method_names << value_method_alias
+              define_enum_methods(name, value_method_alias, value, scopes, instance_methods)
+            end
           end
         end
-      end
-      detect_negative_enum_conditions!(value_method_names) if scopes
+        detect_negative_enum_conditions!(value_method_names) if scopes
 
-      if validate
-        validate = {} unless Hash === validate
-        validates_inclusion_of name, in: enum_values.keys, **validate
-      end
+        if validate
+          validate = {} unless Hash === validate
+          validates_inclusion_of name, in: enum_values.keys, **validate
+        end
 
-      enum_values.freeze
-    end
+        enum_values.freeze
+      end
 
-    private
       def inherited(base)
         base.defined_enums = defined_enums.deep_dup
         super
diff --git a/activerecord/test/cases/enum_test.rb b/activerecord/test/cases/enum_test.rb
index b5ed00d4eb..1de1dad266 100644
--- a/activerecord/test/cases/enum_test.rb
+++ b/activerecord/test/cases/enum_test.rb
@@ -446,7 +446,7 @@ def self.name; "Book"; end
       end
     end
 
-    assert_match(/wrong number of arguments/, e.message)
+    assert_match(/must not be empty\.$/, e.message)
 
     e = assert_raises(ArgumentError) do
       Class.new(ActiveRecord::Base) do
@@ -892,10 +892,21 @@ def self.name; "Book"; end
     assert_respond_to book, :easy_to_read?
   end
 
+  test "enum labels as keyword arguments" do
+    klass = Class.new(ActiveRecord::Base) do
+      self.table_name = "books"
+      enum :status, active: 0, archived: 1
+    end
+
+    book = klass.new
+    assert_predicate book, :active?
+    assert_not_predicate book, :archived?
+  end
+
   test "option names can be used as label" do
     klass = Class.new(ActiveRecord::Base) do
       self.table_name = "books"
-      enum :status, { default: 0, scopes: 1, prefix: 2, suffix: 3 }
+      enum :status, default: 0, scopes: 1, prefix: 2, suffix: 3
     end
 
     book = klass.new
