diff --git a/activesupport/CHANGELOG.md b/activesupport/CHANGELOG.md
index 46b4400c76..d11614b14a 100644
--- a/activesupport/CHANGELOG.md
+++ b/activesupport/CHANGELOG.md
@@ -1,3 +1,7 @@
+*   `ActiveSupport::FileUpdateChecker` does not depend on `Time.now` to prevent unecessary reloads with time travel test helpers
+
+    *Jan Grodowski*
+
 ## Rails 8.1.0.beta1 (September 04, 2025) ##
 
 *   Add `ActiveSupport::Cache::Store#namespace=` and `#namespace`.
diff --git a/activesupport/lib/active_support/file_update_checker.rb b/activesupport/lib/active_support/file_update_checker.rb
index 5fc9be8341..93acc09cbc 100644
--- a/activesupport/lib/active_support/file_update_checker.rb
+++ b/activesupport/lib/active_support/file_update_checker.rb
@@ -123,7 +123,7 @@ def updated_at(paths)
       # healthy to consider this edge case because with mtimes in the future
       # reloading is not triggered.
       def max_mtime(paths)
-        time_now = Time.now
+        time_now = Time.at(0, Process.clock_gettime(Process::CLOCK_REALTIME, :nanosecond), :nanosecond)
         max_mtime = nil
 
         # Time comparisons are performed with #compare_without_coercion because
diff --git a/activesupport/test/file_update_checker_test.rb b/activesupport/test/file_update_checker_test.rb
index 987cb56672..1c9abfb160 100644
--- a/activesupport/test/file_update_checker_test.rb
+++ b/activesupport/test/file_update_checker_test.rb
@@ -14,4 +14,35 @@ def touch(files)
     sleep 0.1 # let's wait a bit to ensure there's a new mtime
     super
   end
+
+  test "should not reload files that appear in the future due to time travel" do
+    i = 0
+
+    checker = new_checker(tmpfiles) { i += 1 }
+    touch(tmpfiles)
+
+    assert checker.execute_if_updated
+    assert_equal 1, i
+
+    original_last_update_at = checker.instance_variable_get(:@last_update_at)
+    assert original_last_update_at > Time.utc(2020, 1, 1), "Expected @last_update_at to be recent"
+
+    # Travel to the past, making current files appear to be in the future
+    travel_to Time.utc(2020, 1, 1) do
+      # With the old implementation with Time.new, this would corrupt @last_update_at to Time.at(0)
+      # because max_mtime would use stubbed Time.now and skip all files as "future" in max_mtime, returning nil.
+      # With Process.clock_gettime, the state should be preserved during time travel.
+      checker.execute
+    end
+
+    assert_not checker.updated?, "Should not reload after time travel when state is preserved"
+
+    final_state = checker.instance_variable_get(:@last_update_at)
+    assert_not_equal Time.at(0), final_state,
+      "State should not be corrupted after time travel"
+
+    touch(tmpfiles)
+    assert checker.execute_if_updated
+    assert_equal 3, i
+  end
 end
