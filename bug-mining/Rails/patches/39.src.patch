diff --git a/activerecord/CHANGELOG.md b/activerecord/CHANGELOG.md
index 92248e9011..6736358d08 100644
--- a/activerecord/CHANGELOG.md
+++ b/activerecord/CHANGELOG.md
@@ -1,3 +1,20 @@
+*   Discard connections which may have been left in a transaction.
+
+    There are cases where, due to an error, `within_new_transaction` may unexpectedly leave a connection in an open transaction. In these cases the connection may be reused, and the following may occur:
+    - Writes appear to fail when they actually succeed.
+    - Writes appear to succeed when they actually fail.
+    - Reads return stale or uncommitted data.
+
+    Previously, the following case was detected:
+    - An error is encountered during the transaction, then another error is encountered while attempting to roll it back.
+
+    Now, the following additional cases are detected:
+    - An error is encountered just after successfully beginning a transaction.
+    - An error is encountered while committing a transaction, then another error is encountered while attempting to roll it back.
+    - An error is encountered while rolling back a transaction.
+
+    *Nick Dower*
+
 *   Active Record query cache now evicts least recently used entries
 
     By default it only keeps the `100` most recently used queries.
diff --git a/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb b/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb
index fcab8efef7..d41311c4a0 100644
--- a/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb
+++ b/activerecord/lib/active_record/connection_adapters/abstract/transaction.rb
@@ -487,23 +487,17 @@ def rollback_transaction(transaction = nil)
       def within_new_transaction(isolation: nil, joinable: true)
         @connection.lock.synchronize do
           transaction = begin_transaction(isolation: isolation, joinable: joinable)
-          ret = yield
-          completed = true
-          ret
-        rescue Exception => error
-          if transaction
+          begin
+            ret = yield
+            completed = true
+            ret
+          rescue Exception => error
             rollback_transaction
             after_failure_actions(transaction, error)
-          end
 
-          raise
-        ensure
-          if transaction
-            if error
-              # @connection still holds an open or invalid transaction, so we must not
-              # put it back in the pool for reuse.
-              @connection.throw_away! unless transaction.state.rolledback?
-            else
+            raise
+          ensure
+            unless error
               if Thread.current.status == "aborting"
                 rollback_transaction
               elsif !completed && transaction.written
@@ -540,6 +534,10 @@ def within_new_transaction(isolation: nil, joinable: true)
               end
             end
           end
+        rescue Exception
+          @connection.throw_away! unless transaction&.state&.completed?
+
+          raise
         end
       end
 
diff --git a/activerecord/test/cases/transactions_test.rb b/activerecord/test/cases/transactions_test.rb
index 7a18b71da4..1be04071a5 100644
--- a/activerecord/test/cases/transactions_test.rb
+++ b/activerecord/test/cases/transactions_test.rb
@@ -80,6 +80,64 @@ def test_rollback_dirty_changes_even_with_raise_during_rollback_doesnt_commit_tr
     ensure
       ActiveRecord::Base.connection_handler.clear_all_connections!(:all)
     end
+
+    def test_connection_removed_from_pool_when_commit_raises_and_rollback_raises
+      connection = Topic.connection
+
+      # Update commit_transaction to raise the first time it is called.
+      Topic.connection.transaction_manager.class_eval do
+        alias :real_commit_transaction :commit_transaction
+        define_method(:commit_transaction) do
+          raise "commit failed"
+        end
+      end
+
+      # Update rollback_transaction to raise.
+      Topic.connection.transaction_manager.class_eval do
+        alias :real_rollback_transaction :rollback_transaction
+        define_method(:rollback_transaction) do |*_args|
+          raise "rollback failed"
+        end
+      end
+
+      # Start a transaction and update a record. The commit and rollback will fail.
+      topic = topics(:fifth)
+      exception = assert_raises(RuntimeError) do
+        ActiveRecord::Base.transaction do
+          topic.update(title: "Updated title")
+        end
+      end
+      assert_equal "rollback failed", exception.message
+      assert_not connection.active?
+      assert_not Topic.connection_pool.connections.include?(connection)
+      assert_equal "The Fifth Topic of the day", topic.reload.title
+    ensure
+      ActiveRecord::Base.connection_handler.clear_all_connections!(:all)
+    end
+
+    def test_connection_removed_from_pool_when_begin_raises_after_successfully_beginning_a_transaction
+      connection = Topic.connection
+      # Disable lazy transactions so that we will begin a transaction before attempting to write.
+      connection.disable_lazy_transactions!
+
+      # Update begin_db_transaction to successfully begin a transaction, then raise.
+      Topic.connection.class_eval do
+        alias :real_begin_db_transaction :begin_db_transaction
+        define_method(:begin_db_transaction) do |*_args|
+          raise "begin failed"
+        end
+      end
+
+      # Attempt to begin a transaction. This will raise, causing a rollback.
+      exception = assert_raises(RuntimeError) do
+        ActiveRecord::Base.transaction { }
+      end
+      assert_equal "begin failed", exception.message
+      assert_not connection.active?
+      assert_not Topic.connection_pool.connections.include?(connection)
+    ensure
+      ActiveRecord::Base.connection_handler.clear_all_connections!(:all)
+    end
   end
 
   def test_rollback_dirty_changes_multiple_saves
