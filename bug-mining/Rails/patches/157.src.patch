diff --git a/activerecord/lib/active_record/railties/databases.rake b/activerecord/lib/active_record/railties/databases.rake
index 9af73c6e69..38946929f7 100644
--- a/activerecord/lib/active_record/railties/databases.rake
+++ b/activerecord/lib/active_record/railties/databases.rake
@@ -87,22 +87,7 @@ db_namespace = namespace :db do
 
   desc "Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)."
   task migrate: :load_config do
-    db_configs = ActiveRecord::Base.configurations.configs_for(env_name: ActiveRecord::Tasks::DatabaseTasks.env)
-
-    if db_configs.size == 1 && db_configs.first.primary?
-      ActiveRecord::Tasks::DatabaseTasks.migrate
-    else
-      mapped_versions = ActiveRecord::Tasks::DatabaseTasks.db_configs_with_versions
-
-      mapped_versions.sort.each do |version, db_configs|
-        db_configs.each do |db_config|
-          ActiveRecord::Tasks::DatabaseTasks.with_temporary_connection(db_config) do
-            ActiveRecord::Tasks::DatabaseTasks.migrate(version)
-          end
-        end
-      end
-    end
-
+    ActiveRecord::Tasks::DatabaseTasks.migrate_all
     db_namespace["_dump"].invoke
   end
 
diff --git a/activerecord/lib/active_record/tasks/database_tasks.rb b/activerecord/lib/active_record/tasks/database_tasks.rb
index 2b8ff3ad4b..029256c8ff 100644
--- a/activerecord/lib/active_record/tasks/database_tasks.rb
+++ b/activerecord/lib/active_record/tasks/database_tasks.rb
@@ -240,13 +240,32 @@ def truncate_all(environment = env)
         end
       end
 
-      def migrate(version = nil)
+      def migrate_all
+        db_configs = ActiveRecord::Base.configurations.configs_for(env_name: ActiveRecord::Tasks::DatabaseTasks.env)
+        db_configs.each { |db_config| initialize_database(db_config) }
+
+        if db_configs.size == 1 && db_configs.first.primary?
+          ActiveRecord::Tasks::DatabaseTasks.migrate(skip_initialize: true)
+        else
+          mapped_versions = ActiveRecord::Tasks::DatabaseTasks.db_configs_with_versions
+
+          mapped_versions.sort.each do |version, db_configs|
+            db_configs.each do |db_config|
+              ActiveRecord::Tasks::DatabaseTasks.with_temporary_connection(db_config) do
+                ActiveRecord::Tasks::DatabaseTasks.migrate(version, skip_initialize: true)
+              end
+            end
+          end
+        end
+      end
+
+      def migrate(version = nil, skip_initialize: false)
         scope = ENV["SCOPE"]
         verbose_was, Migration.verbose = Migration.verbose, verbose?
 
         check_target_version
 
-        initialize_database(migration_connection_pool.db_config)
+        initialize_database(migration_connection_pool.db_config) unless skip_initialize
 
         migration_connection_pool.migration_context.migrate(target_version) do |migration|
           if version.blank?
diff --git a/railties/test/application/rake/dbs_test.rb b/railties/test/application/rake/dbs_test.rb
index 9a8e6c3764..aa181f1851 100644
--- a/railties/test/application/rake/dbs_test.rb
+++ b/railties/test/application/rake/dbs_test.rb
@@ -363,6 +363,37 @@ def db_migrate_and_status(expected_database)
         assert_equal "[\"ar_internal_metadata\", \"comments\", \"schema_migrations\"]", list_tables[]
       end
 
+      test "db:migrate on multiple new dbs loads schema" do
+        File.write("#{app_path}/config/database.yml", <<~YAML)
+          development:
+            primary:
+              adapter: sqlite3
+              database: storage/test.sqlite3
+            queue:
+              adapter: sqlite3
+              database: storage/test_queue.sqlite3
+        YAML
+
+        app_file "db/schema.rb", <<-RUBY
+          ActiveRecord::Schema.define(version: 20140423102712) do
+            create_table(:comments) {}
+          end
+        RUBY
+
+        app_file "db/queue_schema.rb", <<-RUBY
+          ActiveRecord::Schema.define(version: 20141016001513) do
+            create_table(:executions) {}
+          end
+        RUBY
+
+        rails "db:migrate"
+        primary_tables = lambda { rails("runner", "p ActiveRecord::Base.lease_connection.tables.sort").strip }
+        queue_tables = lambda { rails("runner", "p ActiveRecord::Base.connects_to(database: { writing: :queue }).first.lease_connection.tables.sort").strip }
+
+        assert_equal "[\"ar_internal_metadata\", \"comments\", \"schema_migrations\"]", primary_tables[]
+        assert_equal "[\"ar_internal_metadata\", \"executions\", \"schema_migrations\"]", queue_tables[]
+      end
+
       test "db:migrate:reset regenerates the schema from migrations" do
         app_file "db/migrate/01_a_migration.rb", <<-MIGRATION
           class AMigration < ActiveRecord::Migration::Current
