diff --git a/activemodel/lib/active_model/attribute.rb b/activemodel/lib/active_model/attribute.rb
index 3561c5207e..f5965ba577 100644
--- a/activemodel/lib/active_model/attribute.rb
+++ b/activemodel/lib/active_model/attribute.rb
@@ -178,11 +178,11 @@ def type_cast(value)
         def forgetting_assignment
           # If this attribute was not persisted (with a `value_for_database`
           # that might differ from `value_before_type_cast`) and `value` has not
-          # changed in place, we can simply dup this attribute to avoid
-          # deserialize / cast / serialize calls from computing the new
+          # changed in place, we can use the existing `value_before_type_cast`
+          # to avoid deserialize / cast / serialize calls from computing the new
           # attribute's `value_before_type_cast`.
           if !defined?(@value_for_database) && !changed_in_place?
-            dup
+            with_value_from_database(value_before_type_cast)
           else
             super
           end
diff --git a/activemodel/test/cases/attribute_test.rb b/activemodel/test/cases/attribute_test.rb
index a17485c63b..d3adec9fb7 100644
--- a/activemodel/test/cases/attribute_test.rb
+++ b/activemodel/test/cases/attribute_test.rb
@@ -285,6 +285,27 @@ def assert_valid_value(*)
       assert_not_predicate forgotten, :changed?
     end
 
+    test "#forgetting_assignment on an unchanged .from_database attribute re-deserializes its value" do
+      deserialized_value_class = Struct.new(:id) do
+        def initialize_dup(*)
+          self.id = nil # a la ActiveRecord::Base#dup
+        end
+      end
+
+      type = Type::Value.new
+      type.define_singleton_method(:deserialize) do |value|
+        deserialized_value_class.new(value)
+      end
+
+      original = Attribute.from_database(:foo, 123, type)
+      assert_equal 123, original.value.id
+
+      forgotten = original.forgetting_assignment
+      assert_equal 123, forgotten.value.id
+
+      assert_not_same original.value, forgotten.value
+    end
+
     test "with_value_from_user validates the value" do
       type = Type::Value.new
       type.define_singleton_method(:assert_valid_value) do |value|
