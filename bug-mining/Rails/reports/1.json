{"url":"https://api.github.com/repos/rails/rails/issues/46044","repository_url":"https://api.github.com/repos/rails/rails","labels_url":"https://api.github.com/repos/rails/rails/issues/46044/labels{/name}","comments_url":"https://api.github.com/repos/rails/rails/issues/46044/comments","events_url":"https://api.github.com/repos/rails/rails/issues/46044/events","html_url":"https://github.com/rails/rails/issues/46044","id":1374793684,"node_id":"I_kwDNIULOUfGv1A","number":46044,"title":"Querying with mutable bound parameters can produce false-positive query cache hits","user":{"login":"rnubel","id":850438,"node_id":"MDQ6VXNlcjg1MDQzOA==","avatar_url":"https://avatars.githubusercontent.com/u/850438?v=4","gravatar_id":"","url":"https://api.github.com/users/rnubel","html_url":"https://github.com/rnubel","followers_url":"https://api.github.com/users/rnubel/followers","following_url":"https://api.github.com/users/rnubel/following{/other_user}","gists_url":"https://api.github.com/users/rnubel/gists{/gist_id}","starred_url":"https://api.github.com/users/rnubel/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rnubel/subscriptions","organizations_url":"https://api.github.com/users/rnubel/orgs","repos_url":"https://api.github.com/users/rnubel/repos","events_url":"https://api.github.com/users/rnubel/events{/privacy}","received_events_url":"https://api.github.com/users/rnubel/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":107191,"node_id":"MDU6TGFiZWwxMDcxOTE=","url":"https://api.github.com/repos/rails/rails/labels/activerecord","name":"activerecord","color":"0b02e1","default":false,"description":null},{"id":126910270,"node_id":"MDU6TGFiZWwxMjY5MTAyNzA=","url":"https://api.github.com/repos/rails/rails/labels/With%20reproduction%20steps","name":"With reproduction steps","color":"009800","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2022-09-15T16:25:49Z","updated_at":"2022-09-19T08:37:40Z","closed_at":"2022-09-19T08:37:40Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"In production at Enova, in one of our apps, we were seeing an _incredibly_ rare issue where sometimes a query would improperly perform a cache load from the query cache and return the wrong value. After several days of debugging and load-testing and more debugging, I was eventually able to track down the issue to a place in our code where we doing, essentially:\r\n\r\n```\r\nsearch = { key: \"value\" }\r\nr = Record.where(criteria: search).first\r\n# ...\r\nsearch.merge!(key2: \"value2\")\r\nr2 = Record.where(criteria: search).first\r\n```\r\n\r\nAs it turns out, the mutation of the search key produces a situation where -- _occasionally_, as demonstrated below -- the query cache returns the wrong value. The root cause is how Ruby hashes work internally: objects are hashed into a bucket in the internal structure based on a modulus of their numerical hash, and retrieved by searching the list of objects in the matching bucket for an equal object. When we mutate the search object, it is possible that the new numerical hash still falls into the **same** bucket, and because the key is a pointer to the object, the `==` check passes and the old object is returned.\r\n\r\nIn normal Ruby code, it would be obvious to an experienced Ruby developer that using a mutable hash key (and then mutating it) is a bad idea. Since the Rails query cache is under the covers, however, it is not obvious to a developer that the code above would be problematic. And because it happens so rarely, I suspect this is occurring in many Rails applications across the world without anyone noticing (other than the occasional head-scratching Sentry error, perhaps).\r\n\r\nI do have a possible fix for this, which I'll add in a comment below.\r\n\r\n### Steps to reproduce\r\n```ruby\r\n# frozen_string_literal: true\r\n\r\nrequire \"bundler/inline\"\r\n\r\ngemfile(true) do\r\n  source \"https://rubygems.org\"\r\n\r\n  git_source(:github) { |repo| \"https://github.com/#{repo}.git\" }\r\n\r\n  gem \"rails\", github: \"rails/rails\", branch: \"main\"\r\n  gem \"sqlite3\"\r\nend\r\n\r\nrequire \"active_record\"\r\nrequire \"minitest/autorun\"\r\nrequire \"logger\"\r\n\r\n# This connection will do for database-independent bug reports.\r\nActiveRecord::Base.establish_connection(adapter: \"sqlite3\", database: \":memory:\", prepared_statements: true)\r\n# ActiveRecord::Base.logger = Logger.new(STDOUT) # you can enable this to see the cache loads, but it's noisy\r\n\r\nActiveRecord::Schema.define do\r\n  create_table :my_records, force: true do |t|\r\n    t.json :value\r\n    t.text :description\r\n  end\r\nend\r\n\r\nclass MyRecord < ActiveRecord::Base; end\r\n\r\nclass QueryCacheMutableSearchTest < Minitest::Test\r\n  def test_bug\r\n    iterations = 10000\r\n    false_positives = 0\r\n\r\n    MyRecord.connection.enable_query_cache!\r\n\r\n    iterations.times do\r\n      key, val = rand(100000), rand(100000)\r\n\r\n      record = MyRecord.create(value: { key => val }, description: \"The record we want to find\")\r\n\r\n      search = { key => val }\r\n      the_record = MyRecord.where(value: search).first # this should populate the cache\r\n      assert the_record.present?\r\n\r\n      # cache now looks like this, essentially:\r\n      #  { \"SELECT * FROM my_records WHERE value = $1\" =>\r\n      #    { [search] => the_record }\r\n      #  }\r\n\r\n      new_val = rand(100000) until new_val != val\r\n\r\n      search.merge!(key => new_val) # this mutates the key inside the query cache\r\n\r\n      # normally: because the hash of the key has changed, this is a cache miss\r\n      # however, if the new hash key's numerical hash falls into the same bucket\r\n      # as the original, the hash lookup will a) find the first query's entry and\r\n      # b) use it, because the objects are equal b/c the `search` hash was mutated\r\n      # is equal to key_obj (since it's a reference)\r\n\r\n      should_not_exist = MyRecord.where(value: search).first # this SHOULD not return a value\r\n      false_positives += 1 if should_not_exist.present?\r\n\r\n      record.destroy\r\n      MyRecord.connection.clear_query_cache\r\n    end\r\n\r\n    assert_equal 0, false_positives\r\n  end\r\nend\r\n```\r\n\r\n### Expected behavior\r\nThe second query should never return a value, since the value it's supposed to look for does not exist in the database.\r\n\r\n### Actual behavior\r\nThe second query **sometimes** performs a `CACHE MyRecord Load` and returns the original record, incorrectly:\r\n\r\n```\r\nFailure:\r\nQueryCacheMutableSearchTest#test_bug [minimal_case.rb:69]:\r\nExpected: 0\r\n  Actual: 43\r\n```\r\n\r\nThis happens because the mutated `search` hash inside the query cache ends up a) hashing into the same bucket as the original `search` hash did inside the query cache's hash, and b) still remains equivalent to the original search hash since the query cache stores a reference to it. Technically, the query cache is keying off of the list of binds which is a list of objects like `ActiveRecord::QueryAttribute`, but ultimately they end up with a reference to the `search` variable itself and thus the problem still manifests.\r\n\r\n\r\n### System configuration\r\n**Rails version**: edge (7.1.0.alpha), also occurs in 6.x and probably older versions as well\r\n**Ruby version**: 2.7.6\r\n","closed_by":{"login":"byroot","id":44640,"node_id":"MDQ6VXNlcjQ0NjQw","avatar_url":"https://avatars.githubusercontent.com/u/44640?v=4","gravatar_id":"","url":"https://api.github.com/users/byroot","html_url":"https://github.com/byroot","followers_url":"https://api.github.com/users/byroot/followers","following_url":"https://api.github.com/users/byroot/following{/other_user}","gists_url":"https://api.github.com/users/byroot/gists{/gist_id}","starred_url":"https://api.github.com/users/byroot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/byroot/subscriptions","organizations_url":"https://api.github.com/users/byroot/orgs","repos_url":"https://api.github.com/users/byroot/repos","events_url":"https://api.github.com/users/byroot/events{/privacy}","received_events_url":"https://api.github.com/users/byroot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rails/rails/issues/46044/reactions","total_count":5,"+1":5,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rails/rails/issues/46044/timeline","performed_via_github_app":null,"state_reason":"completed"}