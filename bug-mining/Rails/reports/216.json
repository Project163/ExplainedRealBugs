{"url":"https://api.github.com/repos/rails/rails/issues/52530","repository_url":"https://api.github.com/repos/rails/rails","labels_url":"https://api.github.com/repos/rails/rails/issues/52530/labels{/name}","comments_url":"https://api.github.com/repos/rails/rails/issues/52530/comments","events_url":"https://api.github.com/repos/rails/rails/issues/52530/events","html_url":"https://github.com/rails/rails/issues/52530","id":2453364344,"node_id":"I_kwDNIULOkjteeA","number":52530,"title":"adding merge of an or to a scope widens the scope if the scope contains a sequal string","user":{"login":"markijbema","id":624143,"node_id":"MDQ6VXNlcjYyNDE0Mw==","avatar_url":"https://avatars.githubusercontent.com/u/624143?v=4","gravatar_id":"","url":"https://api.github.com/users/markijbema","html_url":"https://github.com/markijbema","followers_url":"https://api.github.com/users/markijbema/followers","following_url":"https://api.github.com/users/markijbema/following{/other_user}","gists_url":"https://api.github.com/users/markijbema/gists{/gist_id}","starred_url":"https://api.github.com/users/markijbema/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markijbema/subscriptions","organizations_url":"https://api.github.com/users/markijbema/orgs","repos_url":"https://api.github.com/users/markijbema/repos","events_url":"https://api.github.com/users/markijbema/events{/privacy}","received_events_url":"https://api.github.com/users/markijbema/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":107191,"node_id":"MDU6TGFiZWwxMDcxOTE=","url":"https://api.github.com/repos/rails/rails/labels/activerecord","name":"activerecord","color":"0b02e1","default":false,"description":null},{"id":126910270,"node_id":"MDU6TGFiZWwxMjY5MTAyNzA=","url":"https://api.github.com/repos/rails/rails/labels/With%20reproduction%20steps","name":"With reproduction steps","color":"009800","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2024-08-07T12:28:59Z","updated_at":"2025-07-18T10:32:16Z","closed_at":"2025-07-17T13:41:24Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Steps to reproduce\r\n<!-- (Guidelines for creating a bug report are [available\r\nhere](https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#creating-a-bug-report)) -->\r\n\r\n<!-- Paste your executable test case created from one of the scripts found [here](https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#create-an-executable-test-case) below: -->\r\n```ruby\r\n# frozen_string_literal: true\r\n\r\nrequire \"bundler/inline\"\r\n\r\ngemfile(true) do\r\n  source \"https://rubygems.org\"\r\n\r\n  #gem \"rails\"\r\n  # If you want to test against edge Rails replace the previous line with this:\r\n  gem \"rails\", github: \"rails/rails\", branch: \"main\"\r\n\r\n  gem \"sqlite3\"\r\nend\r\n\r\nrequire \"active_record\"\r\nrequire \"minitest/autorun\"\r\nrequire \"logger\"\r\n\r\n# This connection will do for database-independent bug reports.\r\nActiveRecord::Base.establish_connection(adapter: \"sqlite3\", database: \":memory:\")\r\nActiveRecord::Base.logger = Logger.new(STDOUT)\r\n\r\nActiveRecord::Schema.define do\r\n  create_table :users, force: true do |t|\r\n  end\r\n\r\n  create_table :comments, force: true do |t|\r\n    t.integer :user_id\r\n    t.integer :blog_post_id\r\n\r\n    t.boolean :recent\r\n    t.boolean :is_laugh_worthy\r\n\r\n    t.boolean :has_funny_blogpost\r\n  end\r\n\r\n  create_table :blog_posts, force: true do |t|\r\n    t.boolean :is_funny\r\n  end\r\n  \r\nend\r\n\r\nclass User < ActiveRecord::Base\r\n    has_many :comments\r\nend\r\n\r\nclass Comment < ActiveRecord::Base\r\n  belongs_to :user\r\n  belongs_to :blog_post\r\n\r\n  scope :for_laughing, -> {   \r\n    joins(:blog_post).merge(\r\n      where(is_laugh_worthy: true).or(BlogPost.where(is_funny: true))\r\n    )\r\n  }\r\n\r\n  scope :for_laughing_and, -> {   \r\n    joins(:blog_post).and(\r\n      where(is_laugh_worthy: true).or(BlogPost.where(is_funny: true))\r\n    )\r\n  }\r\n\r\n  scope :for_laughing_same_table, -> {   \r\n    joins(:blog_post).and(\r\n      where(is_laugh_worthy: true).or(Comment.where(has_funny_blogpost: true))\r\n    )\r\n  }\r\n\r\n  scope :laugh_worthy, -> { joins(:blog_post).merge(where(is_laugh_worthy: true)) }\r\n  scope :funny_blogpost, -> { joins(:blog_post).merge(BlogPost.where(is_funny: true)) }\r\nend\r\n\r\nclass BlogPost < ActiveRecord::Base\r\nend\r\n\r\ndef comments_for_laughing(scope)\r\n  scope.joins(:blog_post)\r\n    .merge(\r\n      scope.where(is_laugh_worthy: true)\r\n        .or(BlogPost.where(is_funny: true))\r\n    )\r\nend\r\n\r\nclass BugTest < Minitest::Test\r\n  def test_association_stuff\r\n    user1 = User.create!\r\n    user1.comments << Comment.create!(blog_post: BlogPost.create!(is_funny: true), is_laugh_worthy: true, has_funny_blogpost: true, recent: true)\r\n\r\n    user2 = User.create!\r\n    user2.comments << Comment.create!(blog_post: BlogPost.create!(is_funny: true), is_laugh_worthy: true, has_funny_blogpost: true, recent: true)\r\n\r\n    # To make it easy to to see what is going on all asserts in this file succeed\r\n\r\n\r\n    # The bug:\r\n    # I would never expect user2 comments when asking for user.comments:\r\n    assert_equal [user1.comments.sole, user2.comments.sole], user1.comments.where(\"recent = 1\").for_laughing.to_a.sort # should be refute!\r\n    \r\n    # Generated SQL:\r\n    # SELECT \"comments\".*\r\n    # FROM \"comments\" INNER JOIN \"blog_posts\" ON \"blog_posts\".\"id\" = \"comments\".\"blog_post_id\"\r\n    # WHERE (recent = 1) AND (\"comments\".\"user_id\" = ? AND (recent = 1) AND \"comments\".\"is_laugh_worthy\" = ? OR \"blog_posts\".\"is_funny\" = ?)  \r\n\r\n    # small changes which avoid the bug:\r\n\r\n    # * adding the 'raw' SQL last\r\n    assert_equal [user1.comments.sole], user1.comments.for_laughing.where(\"recent = 1\").to_a.sort\r\n\r\n    # * not using 'raw' SQL\r\n    assert_equal [user1.comments.sole], user1.comments.where(recent: true).for_laughing.to_a.sort\r\n\r\n    # * using 'and' instead of 'merge'\r\n    assert_equal [user1.comments.sole], user1.comments.where(\"recent = 1\").for_laughing_and.to_a.sort\r\n\r\n    # * using the same table in the or clause\r\n    assert_equal [user1.comments.sole], user1.comments.where(\"recent = 1\").for_laughing_same_table.to_a.sort\r\n    \r\n    \r\n    \r\n    # Some more succeeding asserts to ensure there are no confounders:\r\n\r\n    # nothing special about using scope on model, if the same scope is\r\n    # constructed manually we have the same problem\r\n    assert_equal [user1.comments.sole, user2.comments.sole], comments_for_laughing(user1.comments.where(\"recent = 1\")).to_a.sort\r\n    assert_equal [user1.comments.sole], comments_for_laughing(user1.comments.where(recent: true)).to_a.sort\r\n\r\n    # seperate parts of the or work as expected\r\n    assert_equal [user1.comments.sole], user1.comments.where(\"recent = 1\").laugh_worthy.to_a.sort\r\n    assert_equal [user1.comments.sole], user1.comments.where(recent: true).laugh_worthy.to_a.sort\r\n    assert_equal [user1.comments.sole], user1.comments.where(\"recent = 1\").funny_blogpost.to_a.sort\r\n    assert_equal [user1.comments.sole], user1.comments.where(recent: true).funny_blogpost.to_a.sort\r\n  end\r\nend\r\n\r\n```\r\n\r\n### Expected behavior\r\n\r\n`user.comments.whatever` only returns comments of the user\r\n\r\n### Actual behavior\r\n`user.comments.whatever` also returns comments of other users in the following (very specific) case:\r\n\r\nthe `whatever` scope containts:\r\n* a `where` with a string containing sql (content unimportant, can be 1=1)\r\n* a `merge` on a scope, with an `or`` containing:\r\n  * a condition on the scope on which the merge is added\r\n  * a condition on another table\r\n\r\n(see the assertion below `    # The bug:` in the attached reproduction, and espacially the generated SQL just below it)\r\n\r\n### System configuration\r\n**Rails version**:\r\n7.1.3 and current main branch of rails\r\n\r\n**Ruby version**:\r\n3.2.0","closed_by":{"login":"byroot","id":44640,"node_id":"MDQ6VXNlcjQ0NjQw","avatar_url":"https://avatars.githubusercontent.com/u/44640?v=4","gravatar_id":"","url":"https://api.github.com/users/byroot","html_url":"https://github.com/byroot","followers_url":"https://api.github.com/users/byroot/followers","following_url":"https://api.github.com/users/byroot/following{/other_user}","gists_url":"https://api.github.com/users/byroot/gists{/gist_id}","starred_url":"https://api.github.com/users/byroot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/byroot/subscriptions","organizations_url":"https://api.github.com/users/byroot/orgs","repos_url":"https://api.github.com/users/byroot/repos","events_url":"https://api.github.com/users/byroot/events{/privacy}","received_events_url":"https://api.github.com/users/byroot/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rails/rails/issues/52530/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rails/rails/issues/52530/timeline","performed_via_github_app":null,"state_reason":"completed"}