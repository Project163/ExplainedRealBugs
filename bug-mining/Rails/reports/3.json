{"url":"https://api.github.com/repos/rails/rails/issues/46196","repository_url":"https://api.github.com/repos/rails/rails","labels_url":"https://api.github.com/repos/rails/rails/issues/46196/labels{/name}","comments_url":"https://api.github.com/repos/rails/rails/issues/46196/comments","events_url":"https://api.github.com/repos/rails/rails/issues/46196/events","html_url":"https://github.com/rails/rails/issues/46196","id":1396882504,"node_id":"I_kwDNIULOU0K8SA","number":46196,"title":"remove_index raises an error when using column: keyword argument that should have been avoided with if_exists: true","user":{"login":"packrat386","id":3507058,"node_id":"MDQ6VXNlcjM1MDcwNTg=","avatar_url":"https://avatars.githubusercontent.com/u/3507058?v=4","gravatar_id":"","url":"https://api.github.com/users/packrat386","html_url":"https://github.com/packrat386","followers_url":"https://api.github.com/users/packrat386/followers","following_url":"https://api.github.com/users/packrat386/following{/other_user}","gists_url":"https://api.github.com/users/packrat386/gists{/gist_id}","starred_url":"https://api.github.com/users/packrat386/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/packrat386/subscriptions","organizations_url":"https://api.github.com/users/packrat386/orgs","repos_url":"https://api.github.com/users/packrat386/repos","events_url":"https://api.github.com/users/packrat386/events{/privacy}","received_events_url":"https://api.github.com/users/packrat386/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2022-10-04T21:49:04Z","updated_at":"2022-10-06T22:43:16Z","closed_at":"2022-10-06T20:52:28Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Steps to reproduce\r\n\r\n```ruby\r\n# frozen_string_literal: true\r\n\r\nrequire \"bundler/inline\"\r\n\r\ngemfile(true) do\r\n  source \"https://rubygems.org\"\r\n\r\n  git_source(:github) { |repo| \"https://github.com/#{repo}.git\" }\r\n\r\n  # Activate the gem you are reporting the issue against.\r\n  gem \"activerecord\", \"= 7.0.4\"\r\n  gem \"sqlite3\"\r\nend\r\n\r\nrequire \"active_record\"\r\nrequire \"minitest/autorun\"\r\nrequire \"logger\"\r\n\r\n# This connection will do for database-independent bug reports.\r\nActiveRecord::Base.establish_connection(adapter: \"sqlite3\", database: \":memory:\")\r\nActiveRecord::Base.logger = Logger.new(STDOUT)\r\n\r\nActiveRecord::Schema.define do\r\n  create_table :payments, force: true do |t|\r\n    t.decimal :amount, precision: 10, scale: 0, default: 0, null: false\r\n    t.string :memo, null: false\r\n    t.string :payer, null: false\r\n    t.string :payee, null: false\r\n\r\n    t.index [:memo, :payer], unique: true\r\n  end\r\nend\r\n\r\nclass Payment < ActiveRecord::Base\r\nend\r\n\r\nclass RemoveIndexIfNotExistsFailure < ActiveRecord::Migration[7.0]\r\n  def change\r\n    # the index that actually exists is just [:memo, :payer]\r\n    remove_index :payments, column: [:memo, :payer, :amount], unique: true, if_exists: true\r\n  end\r\nend\r\n\r\nclass RemoveIndexIfNotExistsSuccess < ActiveRecord::Migration[7.0]\r\n  def change\r\n    if index_exists?(:payments, [:memo, :payer, :amount], unique: true)\r\n      remove_index :payments, column: [:memo, :payer, :amount], unique: true\r\n    end\r\n  end\r\nend\r\n\r\nclass BugTest < Minitest::Test\r\n  def test_migration_if_not_exist_failure\r\n    assert !ActiveRecord::Migration.connection.index_exists?(:payments, [:memo, :payer, :amount], unique: true)\r\n    RemoveIndexIfNotExistsFailure.migrate(:up)\r\n  rescue StandardError => e\r\n    flunk e.message\r\n  end\r\n\r\n  def test_migration_if_not_exist_success\r\n    assert !ActiveRecord::Migration.connection.index_exists?(:payments, [:memo, :payer, :amount], unique: true)\r\n    RemoveIndexIfNotExistsSuccess.migrate(:up)\r\n  rescue StandardError => e\r\n    flunk e.message\r\n  end\r\nend\r\n```\r\n\r\n### Expected behavior\r\nBoth of these migrations should do nothing.\r\n\r\n### Actual behavior\r\nThe first migration raises an error because it cannot find an index that matches the constraints.\r\n\r\n```\r\n# Running:\r\n\r\n==  RemoveIndexIfNotExistsSuccess: migrating ==================================\r\n-- index_exists?(:payments, [:memo, :payer, :amount], {:unique=>true})\r\n   -> 0.0001s\r\n==  RemoveIndexIfNotExistsSuccess: migrated (0.0001s) =========================\r\n\r\n.==  RemoveIndexIfNotExistsFailure: migrating ==================================\r\n-- remove_index(:payments, {:column=>[:memo, :payer, :amount], :unique=>true, :if_exists=>true})\r\nF\r\n\r\nFinished in 0.001106s, 1808.3182 runs/s, 2712.4773 assertions/s.\r\n\r\n  1) Failure:\r\nBugTest#test_migration_if_not_exist_failure [active_record_migrations_gem.rb:57]:\r\nNo indexes found on payments with the options provided.\r\n\r\n2 runs, 3 assertions, 1 failures, 0 errors, 0 skips\r\n```\r\n\r\n### System configuration\r\n**Rails version**: activerecord version 7.0.4\r\n\r\n**Ruby version**: `ruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [arm64-darwin21]`\r\n\r\n### Investigation\r\n\r\n`remove_index` first checks if `index_exists?` if the `if_exists: true` option is passed, then calls `index_name_for_remove`, which is where the error message we get bubbles up from.\r\n\r\nhttps://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb#L894-L900\r\n\r\n`index_exists?` looks only at the positional `column_name` argument, which can be either a single name (string/symbol) or an array of column names. It also looks at the keyword arguments `unique: <boolean>` and `name: <string>`. It returns true if something matches all of those criteria.\r\n\r\nhttps://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb#L99-L111\r\n\r\n`index_name_for_remove` however looks at either the positional `column_name` _or_ the keyword `column: <name or array of names>`. If it finds no matching columns it raises an error.\r\n\r\nhttps://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb#L1436-L1466\r\n\r\n`remove_index` supports the `columns:` keyword arg per [the api docs](https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_index) but because `index_exists?` ignores it, you can get weird errors when combined with `if_exists: true`. In this case `index_exists?` succeeds because the only criterion that it is looking at is `unique: true` (we didn't supply `column_name` or the `name: ` keyword argument) and there _is_ a unique index on this table (on a different set of columns). If you manually check `index_exists?` with the positional argument you can avoid the error.\r\n\r\nIn the event that this is in fact a bug, I'd be happy to attempt to contribute a fix. It seems like `index_exists?` just needs to also support the `column:` keyword argument, probably to be implemented the same way `index_name_for_remove` does here: https://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb#L1445","closed_by":{"login":"eileencodes","id":1080678,"node_id":"MDQ6VXNlcjEwODA2Nzg=","avatar_url":"https://avatars.githubusercontent.com/u/1080678?v=4","gravatar_id":"","url":"https://api.github.com/users/eileencodes","html_url":"https://github.com/eileencodes","followers_url":"https://api.github.com/users/eileencodes/followers","following_url":"https://api.github.com/users/eileencodes/following{/other_user}","gists_url":"https://api.github.com/users/eileencodes/gists{/gist_id}","starred_url":"https://api.github.com/users/eileencodes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eileencodes/subscriptions","organizations_url":"https://api.github.com/users/eileencodes/orgs","repos_url":"https://api.github.com/users/eileencodes/repos","events_url":"https://api.github.com/users/eileencodes/events{/privacy}","received_events_url":"https://api.github.com/users/eileencodes/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rails/rails/issues/46196/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rails/rails/issues/46196/timeline","performed_via_github_app":null,"state_reason":"completed"}