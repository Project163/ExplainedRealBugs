{"url":"https://api.github.com/repos/rails/rails/issues/48164","repository_url":"https://api.github.com/repos/rails/rails","labels_url":"https://api.github.com/repos/rails/rails/issues/48164/labels{/name}","comments_url":"https://api.github.com/repos/rails/rails/issues/48164/comments","events_url":"https://api.github.com/repos/rails/rails/issues/48164/events","html_url":"https://github.com/rails/rails/issues/48164","id":1699572304,"node_id":"I_kwDNIULOZU1qUA","number":48164,"title":"ActiveRecord Transaction Unexpectedly Left Open","user":{"login":"nicholasdower","id":9117775,"node_id":"MDQ6VXNlcjkxMTc3NzU=","avatar_url":"https://avatars.githubusercontent.com/u/9117775?v=4","gravatar_id":"","url":"https://api.github.com/users/nicholasdower","html_url":"https://github.com/nicholasdower","followers_url":"https://api.github.com/users/nicholasdower/followers","following_url":"https://api.github.com/users/nicholasdower/following{/other_user}","gists_url":"https://api.github.com/users/nicholasdower/gists{/gist_id}","starred_url":"https://api.github.com/users/nicholasdower/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nicholasdower/subscriptions","organizations_url":"https://api.github.com/users/nicholasdower/orgs","repos_url":"https://api.github.com/users/nicholasdower/repos","events_url":"https://api.github.com/users/nicholasdower/events{/privacy}","received_events_url":"https://api.github.com/users/nicholasdower/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":107191,"node_id":"MDU6TGFiZWwxMDcxOTE=","url":"https://api.github.com/repos/rails/rails/labels/activerecord","name":"activerecord","color":"0b02e1","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2023-05-08T05:51:18Z","updated_at":"2023-05-14T06:24:08Z","closed_at":"2023-05-14T02:48:33Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Dear Rails folks,\r\n\r\nI recently encountered an issue where an error occurred during an ActiveRecord transaction and the transaction was not successfully rolled back. During subsequent requests which reused this connection, writes were silently added to the previous transaction without being committed. Eventually, the connection was closed and all of the writes were discarded.\r\n\r\nI found that a similar issue was addressed in https://github.com/rails/rails/pull/40541, but I believe it is still possible for a connection to get into an unexpected state when, for instance:\r\n- Committing a transaction raises, then rolling it back raises.\r\n- Rolling back a transaction raises, then discarding the connection raises.\r\n- Beginning a transaction succeeds but the begin method raises.\r\n\r\nOnce a connection gets into such a state, I believe the following unexpected outcomes are possible:\r\n- Previous writes, which should have been rolled back, are actually committed.\r\n- Subsequent writes on the connection appear to succeed but are eventually discarded when the connection is closed.\r\n- Subsequent writes on the connection appear to succeed but are actually pending until a new transaction is committed.\r\n\r\nFYI, I have proposed an improvement in #48200 (Previously #48165).\r\n\r\n### Steps to reproduce\r\n```ruby\r\n# frozen_string_literal: true\r\n\r\nrequire 'bundler/inline'\r\n\r\ngemfile(true) do\r\n  source 'https://rubygems.org'\r\n\r\n  git_source(:github) { |repo| \"https://github.com/#{repo}.git\" }\r\n\r\n  gem 'activerecord', '7.0.4.3'\r\n  gem 'minitest-reporters'\r\n  gem 'mysql2'\r\nend\r\n\r\nrequire 'active_record'\r\nrequire 'logger'\r\nrequire 'minitest/autorun'\r\nrequire 'minitest/reporters'\r\n\r\nMinitest::Reporters.use! [Minitest::Reporters::SpecReporter.new()]\r\n\r\n# Using the MySQL DB used by the repo unit tests.\r\nActiveRecord::Base.establish_connection(\r\n  adapter:             'mysql2',\r\n  host:                '127.0.0.1',\r\n  port:                3306,\r\n  username:            'root',\r\n  database:            'activerecord_unittest',\r\n  prepared_statements: false\r\n)\r\n\r\nActiveRecord::Base.logger = Logger.new(STDOUT)\r\n\r\nclass Topic < ActiveRecord::Base; end\r\n\r\nclass OpenTransactionsTest < Minitest::Test\r\n  def self.test_order; :alpha;end\r\n\r\n  def setup\r\n    ActiveRecord::Schema.define do\r\n      create_table :topics, force: true do |t|\r\n         t.string :title\r\n         t.string :author_name\r\n      end\r\n    end\r\n    Topic.create(id: 1, title: 'Original title', author_name: 'Original author')\r\n  end\r\n\r\n  # Test for the case where a rollback fails, then we fail to discard the transaction. The\r\n  # transaction is unexpectedly left open and will be committed if another transaction is\r\n  # attempted on the same connection.\r\n  #\r\n  # Output:\r\n  #   Topic Load (0.4ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   TRANSACTION (0.1ms)   BEGIN\r\n  #   Topic Update (0.3ms)  UPDATE `topics` SET `topics`.`title` = 'Updated title' WHERE `topics`.`id` = 1\r\n  #   Topic Load (0.1ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   SQL (11.6ms)          SELECT title from topics where id = 1\r\n  #   TRANSACTION (0.5ms)   BEGIN\r\n  #   Topic Update (0.9ms)  UPDATE `topics` SET `topics`.`author_name` = 'Updated author' WHERE `topics`.`id` = 1\r\n  #   TRANSACTION (0.4ms)   COMMIT\r\n  #   Topic Load (0.7ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  def test_aborted_transaction_committed_when_rollback_raises_and_throw_away_raises\r\n    connection = Topic.connection\r\n    topic = Topic.find(1)\r\n\r\n    # Update rollback_db_transaction to raise.\r\n    Topic.connection.singleton_class.class_eval do\r\n      alias :real_rollback_db_transaction :rollback_db_transaction\r\n      define_method(:rollback_db_transaction) do\r\n        raise 'rollback failed'\r\n      end\r\n    end\r\n\r\n    # Update throw_away! to raise. Maybe unlikely, but possible.\r\n    Topic.connection.singleton_class.class_eval do\r\n      alias :real_throw_away! :throw_away!\r\n      define_method(:throw_away!) do\r\n        raise 'throw away failed'\r\n      end\r\n    end\r\n\r\n    # Start a transaction, update a record, then roll back. The rollback and connection removal will fail.\r\n    exception = assert_raises(RuntimeError) do\r\n      ActiveRecord::Base.transaction do\r\n        topic.update(title: 'Updated title')\r\n        raise ActiveRecord::Rollback\r\n      end\r\n    end\r\n    assert_equal \"throw away failed\", exception.message\r\n    assert connection.active?\r\n    assert Topic.connection_pool.connections.include?(connection)\r\n\r\n    # Any requests reusing the connection will see the uncommitted data.\r\n    assert_equal 'Updated title', topic.reload.title\r\n\r\n    # Any requests using a different connection will not see the uncommitted data.\r\n    persisted_title = ActiveRecord::Base.connection_pool.checkout.exec_query(\r\n      \"SELECT title from topics where id = #{topic.id}\"\r\n    ).first['title']\r\n    assert_equal 'Original title', persisted_title\r\n\r\n    # Perform a new transaction. This will also commit the previously uncommitted changes.\r\n    ActiveRecord::Base.transaction do\r\n      topic.update(author_name: 'Updated author')\r\n    end\r\n\r\n    # Discard the connection to ensure anything we read was actually written to the database.\r\n    Topic.connection.real_throw_away!\r\n\r\n    # Both transactions were committed.\r\n    assert_equal 'Updated title', topic.reload.title\r\n    assert_equal 'Updated author', topic.author_name\r\n  ensure\r\n    ActiveRecord::Base.connection_handler.clear_all_connections!(:all)\r\n  end\r\n\r\n  # Test for the case where a commit fails, then the rollback fails. The transaction is\r\n  # unexpectedly left open and will be committed if another transaction is attempted on\r\n  # the same connection.\r\n  #\r\n  # Output:\r\n  #   Topic Load (0.4ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   TRANSACTION (0.1ms)   BEGIN\r\n  #   Topic Update (0.8ms)  UPDATE `topics` SET `topics`.`title` = 'Updated title' WHERE `topics`.`id` = 1\r\n  #   Topic Load (0.2ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   SQL (14.2ms)          SELECT title from topics where id = 1\r\n  #   TRANSACTION (0.5ms)   BEGIN\r\n  #   Topic Update (0.2ms)  UPDATE `topics` SET `topics`.`author_name` = 'Updated author' WHERE `topics`.`id` = 1\r\n  #   TRANSACTION (0.4ms)   COMMIT\r\n  #   Topic Load (0.2ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  def test_failed_transaction_committed_when_commit_raises_and_rollback_raises\r\n    connection = Topic.connection\r\n    topic = Topic.find(1)\r\n\r\n    # Update commit_db_transaction to raise the first time it is called.\r\n    Topic.connection.singleton_class.class_eval do\r\n      alias :real_commit_db_transaction :commit_db_transaction\r\n      define_method(:commit_db_transaction) do\r\n        unless @ran_once\r\n          @ran_once = true\r\n          raise 'commit failed'\r\n        end\r\n        real_commit_db_transaction\r\n      end\r\n    end\r\n\r\n    # Update rollback_transaction to raise.\r\n    Topic.connection.transaction_manager.singleton_class.class_eval do\r\n      alias :real_rollback_transaction :rollback_transaction\r\n      define_method(:rollback_transaction) do |*_args|\r\n        raise 'rollback failed'\r\n      end\r\n    end\r\n\r\n    # Start a transaction and update a record. The commit and rollback will fail.\r\n    exception = assert_raises(RuntimeError) do\r\n      ActiveRecord::Base.transaction do\r\n        topic.update(title: 'Updated title')\r\n      end\r\n    end\r\n    assert_equal \"rollback failed\", exception.message\r\n    assert connection.active?\r\n    assert Topic.connection_pool.connections.include?(connection)\r\n\r\n    # Any request reusing the connection will see the uncommitted data.\r\n    assert_equal 'Updated title', topic.reload.title\r\n\r\n    # Any requests using a different connection will not see the uncommitted data.\r\n    persisted_title = ActiveRecord::Base.connection_pool.checkout.exec_query(\r\n      \"SELECT title from topics where id = #{topic.id}\"\r\n    ).first['title']\r\n    assert_equal 'Original title', persisted_title\r\n\r\n    # Perform a new transaction. This will also commit the previously uncommitted changes.\r\n    ActiveRecord::Base.transaction do\r\n      topic.update(author_name: 'Updated author')\r\n    end\r\n\r\n    # Discard the connection to ensure anything we read was actually written to the databse.\r\n    Topic.connection.throw_away!\r\n\r\n    # Both transactions were committed.\r\n    assert_equal 'Updated title', topic.reload.title\r\n    assert_equal 'Updated author', topic.author_name\r\n  ensure\r\n    ActiveRecord::Base.connection_handler.clear_all_connections!(:all)\r\n  end\r\n\r\n  # Test for the case where a rollback fails, then we fail to discard the transaction. The\r\n  # transaction is unexpectedly left open, allowing subsequent transactions to be silently\r\n  # discarded.\r\n  #\r\n  # Output:\r\n  #   Topic Load (0.2ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   TRANSACTION (0.1ms)   BEGIN\r\n  #   Topic Update (0.2ms)  UPDATE `topics` SET `topics`.`title` = 'Updated title' WHERE `topics`.`id` = 1\r\n  #   Topic Load (0.2ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   SQL (11.1ms)          SELECT title from topics where id = 1\r\n  #   Topic Update (0.2ms)  UPDATE `topics` SET `topics`.`author_name` = 'Updated author' WHERE `topics`.`id` = 1\r\n  #   Topic Load (0.3ms)    SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  def test_subsequent_transaction_silently_discarded_after_rollback_raises_and_throw_away_raises\r\n    connection = Topic.connection\r\n    topic = Topic.find(1)\r\n\r\n    # Update rollback_transaction to raise.\r\n    Topic.connection.transaction_manager.singleton_class.class_eval do\r\n      alias :real_rollback_transaction :rollback_transaction\r\n      define_method(:rollback_transaction) do\r\n        raise 'rollback failed'\r\n      end\r\n    end\r\n\r\n    # Update throw_away! to raise. Maybe unlikely, but possible.\r\n    Topic.connection.singleton_class.class_eval do\r\n      alias :real_throw_away! :throw_away!\r\n      define_method(:throw_away!) do\r\n        raise 'throw away failed'\r\n      end\r\n    end\r\n\r\n    # Start a transaction, update a record, then roll back. The rollback and connection removal will fail.\r\n    exception = assert_raises(RuntimeError) do\r\n      ActiveRecord::Base.transaction do\r\n        topic.update(title: 'Updated title')\r\n        raise ActiveRecord::Rollback\r\n      end\r\n    end\r\n    assert_equal \"throw away failed\", exception.message\r\n    assert connection.active?\r\n    assert Topic.connection_pool.connections.include?(connection)\r\n\r\n    # Any request reusing the connection will see the uncommitted data.\r\n    assert_equal 'Updated title', topic.reload.title\r\n\r\n    # Any requests using a different connection will not see the uncommitted data.\r\n    persisted_title = ActiveRecord::Base.connection_pool.checkout.exec_query(\r\n      \"SELECT title from topics where id = #{topic.id}\"\r\n    ).first['title']\r\n    assert_equal 'Original title', persisted_title\r\n\r\n    # Perform a new transaction. This will not be committed because we are still in the previous transaction.\r\n    ActiveRecord::Base.transaction do\r\n      topic.update(author_name: 'Updated author')\r\n    end\r\n\r\n    # Discard the connection to ensure anything we read was actually written to the databse.\r\n    Topic.connection.real_throw_away!\r\n\r\n    # Nothing was committed.\r\n    assert_equal 'Original title', topic.reload.title\r\n    assert_equal 'Original author', topic.author_name\r\n  ensure\r\n    ActiveRecord::Base.connection_handler.clear_all_connections!(:all)\r\n  end\r\n\r\n  # Test for the case where beginning a transaction succeeds, but then the begin method\r\n  # raises. The transaction is unexpectedly left open, allowing subsequent writes to\r\n  # silently fail.\r\n  #\r\n  # Output:\r\n  #   Topic Load (0.2ms)   SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   TRANSACTION (0.1ms)  BEGIN\r\n  #    (0.2ms)             UPDATE topics SET title = 'Updated title' WHERE id = 1;\r\n  #   Topic Load (0.2ms)   SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  #   SQL (12.6ms)         SELECT title from topics where id = 1\r\n  #   Topic Load (0.3ms)   SELECT `topics`.* FROM `topics` WHERE `topics`.`id` = 1 LIMIT 1\r\n  def test_write_silently_discarded_after_beginning_a_transaction_then_raising\r\n    connection = Topic.connection\r\n    topic = Topic.find(1)\r\n\r\n    # Disable lazy transactions so that we will begin a transaction immediately, before writing.\r\n    connection.disable_lazy_transactions!\r\n\r\n    # Update begin_transaction to raise after successfully beginning a transaction.\r\n    Topic.connection.transaction_manager.singleton_class.class_eval do\r\n      alias :real_begin_transaction :begin_transaction\r\n      define_method(:begin_transaction) do |*_args|\r\n        real_begin_transaction\r\n        raise 'begin failed'\r\n      end\r\n    end\r\n\r\n    # Begin a transaction. This will raise but no rollback will be performed and the connection will not be removed.\r\n    exception = assert_raises(RuntimeError) do\r\n      ActiveRecord::Base.transaction { }\r\n    end\r\n    assert_equal \"begin failed\", exception.message\r\n    assert connection.active?\r\n    assert Topic.connection_pool.connections.include?(connection)\r\n\r\n    # Use the connection to execute a statement. Since we are still in a transaction, this will not be committed.\r\n    Topic.connection.execute(\"UPDATE topics SET title = 'Updated title' WHERE id = #{topic.id};\")\r\n\r\n    # Any request reusing the connection will see the uncommitted data.\r\n    assert_equal 'Updated title', topic.reload.title\r\n\r\n    # Any requests using a different connection will not see the uncommitted data.\r\n    persisted_title = ActiveRecord::Base.connection_pool.checkout.exec_query(\r\n      \"SELECT title from topics where id = #{topic.id}\"\r\n    ).first['title']\r\n    assert_equal 'Original title', persisted_title\r\n\r\n    # Discard the connection.\r\n    Topic.connection.throw_away!\r\n\r\n    # Nothing was committed.\r\n    assert_equal 'Original title', topic.reload.title\r\n  ensure\r\n    ActiveRecord::Base.connection_handler.clear_all_connections!(:all)\r\n  end\r\nend\r\n```\r\n\r\n### Expected behavior\r\nA connection should not be reused if an error occurs which may have left it in transaction.\r\n\r\n### Actual behavior\r\nA connection is reused after an error occurs which may have left it in a transaction.\r\n\r\n### System configuration\r\n**Rails version**: `7.1.0-alpha`\r\n\r\n**Ruby version**: `ruby 3.0.5p211 (2022-11-24 revision ba5cf0f7c5) [x86_64-darwin22]`\r\n","closed_by":{"login":"guilleiguaran","id":160941,"node_id":"MDQ6VXNlcjE2MDk0MQ==","avatar_url":"https://avatars.githubusercontent.com/u/160941?v=4","gravatar_id":"","url":"https://api.github.com/users/guilleiguaran","html_url":"https://github.com/guilleiguaran","followers_url":"https://api.github.com/users/guilleiguaran/followers","following_url":"https://api.github.com/users/guilleiguaran/following{/other_user}","gists_url":"https://api.github.com/users/guilleiguaran/gists{/gist_id}","starred_url":"https://api.github.com/users/guilleiguaran/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/guilleiguaran/subscriptions","organizations_url":"https://api.github.com/users/guilleiguaran/orgs","repos_url":"https://api.github.com/users/guilleiguaran/repos","events_url":"https://api.github.com/users/guilleiguaran/events{/privacy}","received_events_url":"https://api.github.com/users/guilleiguaran/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rails/rails/issues/48164/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rails/rails/issues/48164/timeline","performed_via_github_app":null,"state_reason":"completed"}