<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 19:57:07 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[JENA-244] Deadlock during SPARQL execution on an inference model</title>
                <link>https://issues.apache.org/jira/browse/JENA-244</link>
                <project id="12311220" key="JENA">Apache Jena</project>
                    <description></description>
                <environment></environment>
        <key id="12554481">JENA-244</key>
            <summary>Deadlock during SPARQL execution on an inference model</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="andy">Andy Seaborne</assignee>
                                    <reporter username="stephen.owens">Stephen Owens</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 May 2012 12:56:53 +0000</created>
                <updated>Fri, 7 Dec 2012 13:13:03 +0000</updated>
                            <resolved>Fri, 7 Dec 2012 13:12:57 +0000</resolved>
                                                    <fixVersion>Jena 2.10.0</fixVersion>
                                    <component>Jena</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13271403" author="stephen.owens" created="Wed, 9 May 2012 13:29:52 +0000"  >&lt;p&gt;Versions involved:&lt;br/&gt;
==============&lt;br/&gt;
jena-arq-2.9.0-incubating.jar&lt;br/&gt;
jena-core-2.7.0-incubating.jar&lt;/p&gt;


&lt;p&gt;We discovered a Jena deadlock during some long running stability tests. Jena is being used in a service accessed by a web application so there were multiple web threads accessing the same underlying model. The model was protected by the standard enterCriticalSection calls, set for read because we were just querying. This worked perfectly until we switched to an RDFS model. The RDFS model exhibited occasional deadlocks. &lt;/p&gt;

&lt;p&gt;The deadlock appears to be an issue with out of order lock acquisition. The first thread acquired a lock on LPTopGoalIterator and then tried to get a lock LPBRuleEngine, the second thread had a lock on LPBRuleEngine and tried to get a lock on LPTopGoalIterator with the expected result that nobody is going anywhere from that point forward. I traced through the relevant Jena code and the issue seems to be that one of the two queries is the first query against that model and so is triggering the inferencing model to add rules to the model. In that first query the following sequence happens:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Because it is the first query against an inference model the FBRuleInfGraph.prepare method triggers the addition of inferences to the model which turns the read only execution of the query into an update of the model.&lt;/li&gt;
	&lt;li&gt;The update uses the LPBRuleEngine.addRule method which is synchronized thus acquiring a lock on LPBRuleEngine.&lt;/li&gt;
	&lt;li&gt;Before trying to update it calls LPBRuleEngine.checkSafeToUpdate to see if there are any outstanding queries.&lt;/li&gt;
	&lt;li&gt;Surprisingly, at least to me in reviewing the code, checkSafeToUpdate tries to close any statement iterators it finds open. I don&apos;t see how this could be a safe thing to do in a multi-threaded environment but I don&apos;t understand the code well enough to be sure.&lt;/li&gt;
	&lt;li&gt;That close operation calls LPTopGoalIterator.close which is a synchronized method and waits at that point until it can acquire a lock on LPTopGoalIterator.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Meanwhile a separate thread executing a query is doing this:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Using LPTopGoalIterator.moveForward to move through its goals.&lt;/li&gt;
	&lt;li&gt;Since this is a synchronized method it acquires a lock on LPTopGoalIterator&lt;/li&gt;
	&lt;li&gt;That method synchronizes on its LPBRuleEngine and waits until it can acquire the lock.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;And at this point we&apos;re in a deadlock. &lt;/p&gt;

&lt;p&gt;In terms of a work around I can probably call prepare before querying the model the first time. That will likely work as long as I&apos;m not planning to write to the model after the initial prepare since any write would invalidate the preparation and leave it prone to deadlock again. In my particular case the information is likely static so that might work. &lt;/p&gt;

&lt;p&gt;The longer term fix will require a change to the lock acquisition strategy. the LPTopGoalIterator.hasNext method could synchronize on the engine before calling moveForward, moveForward could become not synchronized and internally synchronize on LPBRuleEngine first and only after it acquires that synchronize on itself. Alternately the checkSafeToUpdate could stop trying to close external iterators and either throw an exception or wait and retry if it finds any open iterators. In the case I&apos;m seeing I doubt the retry strategy would be viable since neither thread yet have a valid model. &lt;/p&gt;

&lt;p&gt;I suspect that the right solution may be much further up the stack. Maybe the model preparation should be done higher before it gets so deep into the SPARQL execution phase. That might allow for a cleaner locking strategy that doesn&apos;t allow multiple SPARQL evaluations to start until the model is stable. Maybe all the way up at com.hp.hpl.jena.sparql.engine.QueryExecutionBase.execConstruct()? At this point I&apos;m just guessing because I don&apos;t know that section of the code well enough. I&apos;m not submitting a patch because I&apos;d like feedback from someone that knows this code well on their suggested approach. &lt;/p&gt;


&lt;p&gt;Here&apos;s the trace of a deadlock:&lt;/p&gt;

&lt;p&gt;        at com.hp.hpl.jena.reasoner.rulesys.impl.LPTopGoalIterator.moveForward(LPTopGoalIterator.java:83)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting to lock &amp;lt;0x0000000779070940&amp;gt; (a com.hp.hpl.jena.reasoner.rulesys.impl.LPBRuleEngine)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x0000000776153ff0&amp;gt; (a com.hp.hpl.jena.reasoner.rulesys.impl.LPTopGoalIterator)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.impl.LPTopGoalIterator.hasNext(LPTopGoalIterator.java:196)&lt;br/&gt;
        at com.hp.hpl.jena.util.iterator.WrappedIterator.hasNext(WrappedIterator.java:76)&lt;br/&gt;
        at com.hp.hpl.jena.util.iterator.WrappedIterator.hasNext(WrappedIterator.java:76)&lt;br/&gt;
        at com.hp.hpl.jena.util.iterator.UniqueExtendedIterator.hasNext(UniqueExtendedIterator.java:78)&lt;br/&gt;
        at com.hp.hpl.jena.util.iterator.WrappedIterator.hasNext(WrappedIterator.java:76)&lt;br/&gt;
        at com.hp.hpl.jena.util.iterator.FilterIterator.hasNext(FilterIterator.java:55)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterTriplePattern$TripleMapper.hasNextBinding(QueryIterTriplePattern.java:151)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.hasNextBinding(QueryIterRepeatApply.java:79)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterBlockTriples.hasNextBinding(QueryIterBlockTriples.java:64)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterProcessBinding.hasNextBinding(QueryIterProcessBinding.java:60)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorWrapper.hasNextBinding(QueryIteratorWrapper.java:40)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorWrapper.hasNextBinding(QueryIteratorWrapper.java:40)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.QueryExecutionBase.execConstruct(QueryExecutionBase.java:254)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.QueryExecutionBase.execConstruct(QueryExecutionBase.java:223)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;&quot;http-8080-9&quot;:&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.impl.LPTopGoalIterator.close(LPTopGoalIterator.java:169)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting to lock &amp;lt;0x0000000776153ff0&amp;gt; (a com.hp.hpl.jena.reasoner.rulesys.impl.LPTopGoalIterator)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.impl.LPBRuleEngine.checkSafeToUpdate(LPBRuleEngine.java:235)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.impl.LPBRuleEngine.addRule(LPBRuleEngine.java:129)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x0000000779070940&amp;gt; (a com.hp.hpl.jena.reasoner.rulesys.impl.LPBRuleEngine)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.FBRuleInfGraph.addBRules(FBRuleInfGraph.java:290)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.FBRuleInfGraph.preloadDeductions(FBRuleInfGraph.java:903)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.FBRuleInfGraph.prepare(FBRuleInfGraph.java:483)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x0000000778e81270&amp;gt; (a com.hp.hpl.jena.reasoner.rulesys.RDFSRuleInfGraph)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.FBRuleInfGraph.findWithContinuation(FBRuleInfGraph.java:574)&lt;br/&gt;
        at com.hp.hpl.jena.reasoner.rulesys.FBRuleInfGraph.graphBaseFind(FBRuleInfGraph.java:606)&lt;br/&gt;
        at com.hp.hpl.jena.graph.impl.GraphBase.find(GraphBase.java:285)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterTriplePattern$TripleMapper.&amp;lt;init&amp;gt;(QueryIterTriplePattern.java:80)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterTriplePattern.nextStage(QueryIterTriplePattern.java:53)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.makeNextStage(QueryIterRepeatApply.java:113)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.hasNextBinding(QueryIterRepeatApply.java:65)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.makeNextStage(QueryIterRepeatApply.java:106)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.hasNextBinding(QueryIterRepeatApply.java:65)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterBlockTriples.hasNextBinding(QueryIterBlockTriples.java:64)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.makeNextStage(QueryIterRepeatApply.java:106)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.hasNextBinding(QueryIterRepeatApply.java:65)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.makeNextStage(QueryIterRepeatApply.java:106)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIterRepeatApply.hasNextBinding(QueryIterRepeatApply.java:65)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorWrapper.hasNextBinding(QueryIteratorWrapper.java:40)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorWrapper.hasNextBinding(QueryIteratorWrapper.java:40)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.iterator.QueryIteratorBase.hasNext(QueryIteratorBase.java:108)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.QueryExecutionBase.execConstruct(QueryExecutionBase.java:254)&lt;br/&gt;
        at com.hp.hpl.jena.sparql.engine.QueryExecutionBase.execConstruct(QueryExecutionBase.java:223)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13271551" author="der" created="Wed, 9 May 2012 16:30:45 +0000"  >&lt;p&gt;Thanks for the clear and detailed analysis.&lt;/p&gt;

&lt;p&gt;I agree that the lock acquisition strategy probably needs to move up, at least to hasNext and possibly up to prepare itself. I also agree that the iterator closing needs to reviewed, doesn&apos;t sound right.&lt;/p&gt;

&lt;p&gt;I&apos;m less convinced about moving prepare calls up the query level. Any deadlock you can provoke via ARQ you could also provoke via straight API calls so it would still need fixing at the engine level anyway. It seems preferable if ARQ doesn&apos;t need to take any special actions when querying an InfGraph. &lt;/p&gt;

&lt;p&gt;This is probably one I should take on but I can&apos;t do that in the immediate future. Is your work around of pre-emptively called prepare() sufficient for your application?&lt;/p&gt;

&lt;p&gt;Dave&lt;/p&gt;</comment>
                            <comment id="13271560" author="der" created="Wed, 9 May 2012 16:35:36 +0000"  >&lt;p&gt;If the pre-emptive prepare() work around does not work then another possible workaround might be to switch to a pure forward-chaining RDFS config e.g. &lt;a href=&quot;http://incubator.apache.org/jena/documentation/inference/#RDFSPlusRules&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://incubator.apache.org/jena/documentation/inference/#RDFSPlusRules&lt;/a&gt; &lt;/p&gt;</comment>
                            <comment id="13271599" author="stephen.owens" created="Wed, 9 May 2012 17:05:49 +0000"  >&lt;p&gt;Dave,&lt;/p&gt;

&lt;p&gt;Good point about API calls triggering the same behaviour. You&apos;re right that there shouldn&apos;t be special action from ARQ, the graph should be able to protect itself. &lt;/p&gt;

&lt;p&gt;Once I&apos;ve tried the work around I&apos;ll let you know. I&apos;m just trying to create a reproducible test case that shows the behaviour so I can verify. &lt;/p&gt;

&lt;p&gt;Thanks for the pointer on the forward chaining, I don&apos;t see why that wouldn&apos;t work in terms of the rules I need. I think that this is the relevant statement that makes this a preferable alternative for consistency in execution?&lt;/p&gt;

&lt;p&gt;&quot;Once the preparation phase is complete the inference graph will act as if it were the union of all the statements in the original model together with all the statements in the internal deductions graph generated by the rule firings. All queries will see all of these statements and will be of similar speed to normal model accesses. It is possible to separately access the original raw data and the set of deduced statements if required, see above.&quot;&lt;/p&gt;


&lt;p&gt;Given that it is the prepare call that is responsible for both forward and backward chaining additions (I think) then would I still need to ensure that I call prepare before any queries are submitted? Or because forward chaining adds rules to the internal deductions graph is the lock strategy different enough that this issue wouldn&apos;t be a problem?&lt;/p&gt;</comment>
                            <comment id="13271778" author="der" created="Wed, 9 May 2012 20:36:29 +0000"  >&lt;p&gt;Yes, once the forward chaining is done, and so long as you are not changing the underlying data, the models might as well then be static.&lt;/p&gt;

&lt;p&gt;You shouldn&apos;t &lt;b&gt;need&lt;/b&gt; to call the explicit pre-prepare in that case (it&apos;s a long time since I looked at that code so there may be problems there, but at least different ones). If that doesn&apos;t work then the explicit pre-prepare should definitely work whereas with the hybrid/backward chaining it may not.&lt;/p&gt;

&lt;p&gt;If you can get a minimal reproducible test case that you could share that would be fantastic!&lt;/p&gt;

&lt;p&gt;Dave&lt;/p&gt;</comment>
                            <comment id="13272049" author="stephen.owens" created="Thu, 10 May 2012 03:12:18 +0000"  >&lt;p&gt;Thanks for the confirmation. &lt;/p&gt;

&lt;p&gt;I&apos;m working on a reproducible case and I think I have it failing reliably. I&apos;ll polish that up a bit and should be able to submit tomorrow.&lt;/p&gt;</comment>
                            <comment id="13272276" author="stephen.owens" created="Thu, 10 May 2012 12:28:52 +0000"  >&lt;p&gt;I&apos;ve attached a minimal test case that reproduces the deadlock condition. It&apos;s still a little more complicated than I&apos;d like, the overhead of threading and detecting the deadlock expanded it a bit. This fails reliably on my machine and is safe to run interactively since it detects its own deadlocks and interrupts the offending threads. I think this will work only on JDK 1.6+ due to the deadlock detection. With fewer threads / loops I&apos;ve seen this occasionally succeed. &lt;/p&gt;

&lt;p&gt;I think I&apos;ve removed all dependencies but let me know if you have any questions or problems getting it to run, or getting it to fail. I&apos;m now going to use this as a framework to test out some of the work arounds. &lt;/p&gt;</comment>
                            <comment id="13274792" author="stephen.owens" created="Mon, 14 May 2012 17:44:36 +0000"  >&lt;p&gt;I&apos;ve attached an update to the test case that shows all three potential work arounds. All three seem to work. There are four tests in the attached, the ignored test is the failure case that shows the deadlock, the other three all succeed against the same thread use because they employ one of three work around strategies for the bug.&lt;/p&gt;

&lt;p&gt;1) Do a &apos;warmup&apos; query on the model before accessing it from multiple threads. This only works if you have a section of code that is thread safe running it and only if you don&apos;t subsequently change the model. The warmup query itself doesn&apos;t seem to matter. This has the advantage that you don&apos;t need to know if the model is inferencing or not to run it.&lt;/p&gt;

&lt;p&gt;2) Do a &apos;prepare&apos; on the model before accessing it from multiple threads. This also only works if you have a section of code that is thread safe running it and only if you don&apos;t subsequently change the model. This requires you to test the model to see if it is inferencing since the standard model interface doesn&apos;t support the prepare method.&lt;/p&gt;

&lt;p&gt;3) Use forward instead of backward chaining when you create the inference model. Unless you need backward chaining for a specific reason this is the number one choice. As far as I know it doesn&apos;t matter if you subsequently change the model and this can be used without a thread safe starting point. Perhaps this should become the default behaviour for the convenience method that creates an RDFS model in the future? &lt;/p&gt;</comment>
                            <comment id="13453644" author="stephen.owens" created="Wed, 12 Sep 2012 02:15:28 +0000"  >&lt;p&gt;Just retested this with 2.9.3, the deadlock is still reproducible with the test case. &lt;/p&gt;</comment>
                            <comment id="13453983" author="shelsen" created="Wed, 12 Sep 2012 13:29:21 +0000"  >&lt;p&gt;Have you tested this with a snapshot 2.7.4 build?&lt;/p&gt;</comment>
                            <comment id="13453997" author="der" created="Wed, 12 Sep 2012 13:53:46 +0000"  >&lt;p&gt;Stephen - yes, no work has been done on this bug. Too much &quot;day job&quot; in the way.&lt;/p&gt;</comment>
                            <comment id="13525992" author="stephen.owens" created="Thu, 6 Dec 2012 23:21:33 +0000"  >&lt;p&gt;Found a way that the work around is not safe. I had ended up doing a pre-emptive prepare and all was well for a while, as long as you don&apos;t need to trigger a new dynamic prepare in a multi-threaded use case. It turns out however that removing anything from the model triggers the need for the prepare and my &apos;static&apos; model wasn&apos;t perfectly static. Back to occasional deadlocks. &lt;/p&gt;

&lt;p&gt;I&apos;ve tried this in 2.7.4 and it is still a current issue, reviewing the code further and I&apos;ll post back if I find something. &lt;/p&gt;</comment>
                            <comment id="13526264" author="hudson" created="Fri, 7 Dec 2012 09:51:22 +0000"  >&lt;p&gt;Integrated in Jena__Development_Test #319 (See &lt;a href=&quot;https://builds.apache.org/job/Jena__Development_Test/319/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Jena__Development_Test/319/&lt;/a&gt;)&lt;br/&gt;
    Fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/JENA-244&quot; title=&quot;Deadlock during SPARQL execution on an inference model&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JENA-244&quot;&gt;&lt;del&gt;JENA-244&lt;/del&gt;&lt;/a&gt; integrated into trunk for testing. (Revision 1418235)&lt;/p&gt;

&lt;p&gt;     Result = SUCCESS&lt;br/&gt;
andy : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/jena/trunk/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/impl/LPTopGoalIterator.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13526274" author="andy.seaborne" created="Fri, 7 Dec 2012 10:11:47 +0000"  >&lt;p&gt;Stephen - I recently (last weekend) came across this situation in the Jena Test Suite itself.  I believe I have a fix and would be grateful if you could test it.&lt;/p&gt;

&lt;p&gt;There is a separate branch &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; of jena-core where I have been stripping out several unused features.  While these features don&apos;t directly affect the reasoner system, they do seem to have caused a timing change and a concurrency test started failing with a deadlock very like the one you have reported here.&lt;/p&gt;

&lt;p&gt;There is a fix in the branch.  For I now, I have retrofitted the fit to jena-core trunk.&lt;/p&gt;

&lt;p&gt;Would you be able to try the development build? &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;  Either copy the jar there, or the latest apache-jena build, or a dependency on jena-core-2.7.5-SNAPSHOT.&lt;/p&gt;

&lt;p&gt;I ran your test example but wasn&apos;t getting failures with jena-core trunk before retrofitting the possible fix.  However, precise timing does affect the situation so different machines may act differently.&lt;/p&gt;

&lt;p&gt;I plan to propose to the team that this branch becomes jena-core trunk but integration is not a simple replacement because it changes some internal APIs (in fairly trivial ways) so ARQ, TDB and SDB need updates at the same time.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://svn.apache.org/repos/asf/jena/branches/jena-core-simplified/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/repos/asf/jena/branches/jena-core-simplified/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://repository.apache.org/content/groups/snapshots/org/apache/jena/jena-core/2.7.5-SNAPSHOT/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://repository.apache.org/content/groups/snapshots/org/apache/jena/jena-core/2.7.5-SNAPSHOT/&lt;/a&gt;&lt;br/&gt;
at least increment 46&lt;/p&gt;</comment>
                            <comment id="13526343" author="stephen.owens" created="Fri, 7 Dec 2012 12:18:58 +0000"  >&lt;p&gt;Definitely, I&apos;ll give it a try and let you know the results. &lt;/p&gt;</comment>
                            <comment id="13526344" author="stephen.owens" created="Fri, 7 Dec 2012 12:27:55 +0000"  >&lt;p&gt;I re-ran my test with 2.7.5-SNAPSHOT and it ran clean. When I fall back to 2.7.4 I can get it to fail reliably. I tried increasing the thread count and the number of threads to add more stress and was not able to get it to fail. I also did a quick review of your change and it looks good, it directly addresses the issue I was seeing. Thanks!&lt;/p&gt;

&lt;p&gt;I&apos;m surprised you weren&apos;t getting the failure before your patch. Were you able to see the failure against 2.7.4? &lt;/p&gt;</comment>
                            <comment id="13526363" author="andy.seaborne" created="Fri, 7 Dec 2012 13:11:14 +0000"  >&lt;p&gt;Good to hear.&lt;/p&gt;

&lt;p&gt;I didn&apos;t get failures but my experience of other similar incidents is that machine, OS, and java version can all play into the probability a test failing. Usually once it is seen to fails, it often/always fails, but it will run clean on another system on the same code.  Hence, they sometimes only get solved by code analysis of possible causes.&lt;/p&gt;

&lt;p&gt;With that positive confirmation, I&apos;ll close this JIRA.  Thanks.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12526785" name="JenaDeadLockTest.java" size="11336" author="stephen.owens" created="Mon, 14 May 2012 17:44:36 +0000"/>
                            <attachment id="12526334" name="JenaDeadLockTest.java" size="7702" author="stephen.owens" created="Thu, 10 May 2012 12:28:52 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>238723</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 50 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1494n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>232942</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>