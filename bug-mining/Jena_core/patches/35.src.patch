diff --git a/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java b/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
index 084e5dd545..d591c9e65a 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
@@ -140,10 +140,25 @@ public class XSDDateTime extends AbstractDateTime {
         data[AbstractDateTime.h] = cal.get(Calendar.HOUR_OF_DAY);
         data[AbstractDateTime.m] = cal.get(Calendar.MINUTE);
         data[AbstractDateTime.s] = cal.get(Calendar.SECOND);
-        int ms = cal.get(Calendar.MILLISECOND);
-        data[AbstractDateTime.ms] = ms;
-        data[AbstractDateTime.msscale] = (ms == 0) ? 0 : 3;
         data[AbstractDateTime.utc] = 'Z';
+
+        int ms = cal.get(Calendar.MILLISECOND);
+        // Store value in a canonical form - no scale for trailing zeros.
+        // This must align with the string parsing code.
+        if ( ms == 0 ) {
+            data[AbstractDateTime.ms] = 0 ;
+            data[AbstractDateTime.msscale] = 0 ;
+        } else if ( ms % 100 == 0 ) {
+            data[AbstractDateTime.ms] = ms/100;
+            data[AbstractDateTime.msscale] = 1 ;
+        } else if ( ms % 10 == 0 ) {
+            data[AbstractDateTime.ms] = ms/10;
+            data[AbstractDateTime.msscale] = 2 ;
+        } else {
+            data[AbstractDateTime.ms] = ms;
+            data[AbstractDateTime.msscale] = 3;
+        }
+        
         return data;
     }
 
diff --git a/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestDateTime.java b/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestDateTime.java
index f013af4d2d..a98e974e16 100644
--- a/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestDateTime.java
+++ b/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestDateTime.java
@@ -21,18 +21,16 @@ package com.hp.hpl.jena.graph.test;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.Calendar;
+import java.util.GregorianCalendar ;
 
 import com.hp.hpl.jena.datatypes.xsd.AbstractDateTime;
 import com.hp.hpl.jena.datatypes.xsd.XSDDatatype;
 import com.hp.hpl.jena.datatypes.xsd.XSDDateTime;
-import com.hp.hpl.jena.rdf.model.Literal;
-import com.hp.hpl.jena.rdf.model.Model;
-import com.hp.hpl.jena.rdf.model.ModelFactory;
-import com.hp.hpl.jena.rdf.model.Property;
-import com.hp.hpl.jena.rdf.model.Resource;
+import com.hp.hpl.jena.rdf.model.* ;
 
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
+import org.junit.Assert ;
 
 /**
  * Tests behaviour of the AbstractDateTime support, specifically for 
@@ -100,7 +98,7 @@ public class TestDateTime extends TestCase {
 
     }
     
-    public void testRoundTripping() {
+    public void testRoundTripping1() {
         Model m = ModelFactory.createDefaultModel();
         Property startTime = m.createProperty("http://jena.hpl.hp.com/test#startTime");
 
@@ -121,6 +119,34 @@ public class TestDateTime extends TestCase {
 
         Literal xsdlit1 = m1.listStatements().next().getObject().as(Literal.class);
         assertEquals(xsdlit0, xsdlit1);
+    }
+    
+    // Test that the string and calendar versions are the same.  
+    public void testRoundTripping2() {
+        //String lex = "2013-04-16T15:40:07.3Z" ;
+        testCalendarRT(1366126807300L);
+    }
+    
+    public void testRoundTripping3() {
+        //String lex = "2013-04-16T15:40:07.31Z" ;
+        testCalendarRT(1366126807310L);
+    }
 
+    public void testRoundTripping4() {
+        //String lex = "2013-04-16T15:40:07.301Z" ;
+        testCalendarRT(1366126807301L);
     }
+
+    private static void testCalendarRT(long value)
+    {
+        Calendar cal=GregorianCalendar.getInstance();
+        cal.setTimeInMillis(value);
+        Literal lit1 = ResourceFactory.createTypedLiteral(cal) ;
+        Literal lit2 = ResourceFactory.createTypedLiteral(lit1.getLexicalForm(), lit1.getDatatype()) ;
+
+        Assert.assertEquals("equals: ", lit1, lit2) ;
+        Assert.assertEquals("hash code: ", lit1.hashCode(), lit2.hashCode()); 
+    }
+    
+
 }
