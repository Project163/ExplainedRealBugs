diff --git a/jena-core/src/main/java/org/apache/jena/reasoner/rulesys/Util.java b/jena-core/src/main/java/org/apache/jena/reasoner/rulesys/Util.java
index 95cfb9b324..1da287f272 100755
--- a/jena-core/src/main/java/org/apache/jena/reasoner/rulesys/Util.java
+++ b/jena-core/src/main/java/org/apache/jena/reasoner/rulesys/Util.java
@@ -19,6 +19,8 @@
 package org.apache.jena.reasoner.rulesys;
 
 import java.io.*;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.*;
 
 import org.apache.jena.datatypes.xsd.XSDDateTime ;
@@ -51,6 +53,25 @@ public class Util {
         return ((Number)n.getLiteralValue()).intValue();
     }
 
+    /**
+     * Check whether a Node is an Instant (DateTime) value
+     */
+    public static boolean isInstant(Node n) {
+        if (n.isLiteral()) {
+            Object o = n.getLiteralValue();
+            return (o instanceof XSDDateTime);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Test if two literals are comparable by an order operator (both numbers or both times)
+     */
+    public static boolean comparable(Node n1, Node n2) {
+       return (isNumeric(n1) && isNumeric(n2)) || (isInstant(n1) && isInstant(n2));
+    }
+
     /**
      * Compare two numeric nodes.
      * @param n1 the first numeric valued literal node
@@ -63,31 +84,78 @@ public class Util {
             Object v1 = n1.getLiteralValue();
             Object v2 = n2.getLiteralValue();
             if (v1 instanceof Number && v2 instanceof Number) {
-                if (v1 instanceof Float || v1 instanceof Double
-                        || v2 instanceof Float || v2 instanceof Double) {
-                            double d1 = ((Number)v1).doubleValue();
-                            double d2 = ((Number)v2).doubleValue();
-                            return (d1 < d2) ? -1 : ( (d1 == d2) ? 0 : +1 );
-                } else {
-                    long l1 = ((Number)v1).longValue();
-                    long l2 = ((Number)v2).longValue();
-                    return (l1 < l2) ? -1 : ( (l1 == l2) ? 0 : +1 );
-                }
+                Number num1 = (Number)v1;
+                Number num2 = (Number)v2;
+                return compareNumbers(num1, num2);
             }
         }
         throw new ClassCastException("Non-numeric literal in compareNumbers");
     }
 
-    /**
-     * Check whether a Node is an Instant (DateTime) value
-     */
-    public static boolean isInstant(Node n) {
-        if (n.isLiteral()) {
-            Object o = n.getLiteralValue();
-            return (o instanceof XSDDateTime);
-        } else {
-            return false;
+    /*package*/ static int compareNumbers(Number num1, Number num2) {
+        // Comparing java.lang.Number.
+        //
+        // Check whether the two numbers are of the same primitive kind (both long
+        // or both double valued) and, if so, compare. Do the same for BigDecimal
+        // and BigInteger.
+        //
+        // If all that fails, convert to BigDecimal and compare.
+
+        // Wrapped primitives, with integer values.
+        if ( valueIsLong(num1) && valueIsLong(num2) ) {
+            long z1 = num1.longValue();
+            long z2 = num2.longValue();
+            return Long.compare(z1, z2);
+        }
+        // Wrapped primitives, with floating point values.
+        if ( valueIsDouble(num1) && valueIsDouble(num2) ) {
+            double d1 = num1.doubleValue();
+            double d2 = num2.doubleValue();
+            return Double.compare(d1, d2);
         }
+        // Both BigDecimal
+        if ( num1 instanceof BigDecimal && num2 instanceof BigDecimal ) {
+            BigDecimal dec1 = (BigDecimal)num1;
+            BigDecimal dec2 = (BigDecimal)num2;
+            return dec1.compareTo(dec2); 
+        }
+        // Both BigInteger
+        if ( num1 instanceof BigInteger && num2 instanceof BigInteger ) {
+            BigInteger int1 = (BigInteger)num1;
+            BigInteger int2 = (BigInteger)num2;
+            return int1.compareTo(int2); 
+        }
+
+        // Mixed. Includes comparing BigInteger and BigDecimal and comparing
+        // BigInteger or BigDecimal with a wrapped primitive.
+        BigDecimal dec1 = convertToBigDecimal(num1);
+        BigDecimal dec2 = convertToBigDecimal(num2);
+        return dec1.compareTo(dec2);
+    }
+    
+    private static BigDecimal convertToBigDecimal(Number num) {
+        if ( num instanceof BigDecimal )
+            return (BigDecimal)num ;
+        if ( valueIsLong(num) )
+            return new BigDecimal(num.longValue()) ;
+        if ( num instanceof BigInteger )
+            return new BigDecimal((BigInteger)num) ;
+        // double and float.
+        return new BigDecimal(num.doubleValue()) ;
+    }
+
+    private static boolean valueIsLong(Number v) {
+        if ( v instanceof Long ) return true;
+        if ( v instanceof Integer ) return true;
+        if ( v instanceof Short ) return true;
+        if ( v instanceof Byte ) return true;
+        return false;
+    }
+
+    private static boolean valueIsDouble(Number v) {
+        if ( v instanceof Double ) return true;
+        if ( v instanceof Float ) return true;
+        return false;
     }
 
     /**
@@ -113,43 +181,23 @@ public class Util {
     /**
      * General order comparator for typed literal nodes, works for all numbers and
      * for date times.
-     *
      */
-    // Thanks to Bradley Schatz (Bradley@greystate.com) for the original suggestions
-    // for datetime comparison. This code is a rewrite based on those suggestions.
     public static int compareTypedLiterals(Node n1, Node n2) {
         if (n1.isLiteral() && n2.isLiteral()) {
             Object v1 = n1.getLiteralValue();
             Object v2 = n2.getLiteralValue();
+            if (v1 instanceof Number && v2 instanceof Number) {
+                return compareNumbers((Number)v1, (Number)v2);
+            }
             if (v1 instanceof XSDDateTime && v2 instanceof XSDDateTime) {
                 XSDDateTime a = (XSDDateTime) v1;
                 XSDDateTime b = (XSDDateTime) v2;
                 return a.compare(b);
-            } else {
-                if (v1 instanceof Number && v2 instanceof Number) {
-                    if (v1 instanceof Float || v1 instanceof Double
-                            || v2 instanceof Float || v2 instanceof Double) {
-                                double d1 = ((Number)v1).doubleValue();
-                                double d2 = ((Number)v2).doubleValue();
-                                return (d1 < d2) ? -1 : ( (d1 == d2) ? 0 : +1 );
-                    } else {
-                        long l1 = ((Number)v1).longValue();
-                        long l2 = ((Number)v2).longValue();
-                        return (l1 < l2) ? -1 : ( (l1 == l2) ? 0 : +1 );
-                    }
-                }
             }
         }
         throw new ClassCastException("Compare typed literals can only compare numbers and datetimes");
     }
 
-    /**
-     * Test if two literals are comparable by an order operator (both numbers or both times)
-     */
-    public static boolean comparable(Node n1, Node n2) {
-       return (isNumeric(n1) && isNumeric(n2)) || (isInstant(n1) && isInstant(n2));
-    }
-
     /**
      * Helper - returns the (singleton) value for the given property on the given
      * root node in the data graph.
diff --git a/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/TestRuleUtil.java b/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/TestRuleUtil.java
new file mode 100644
index 0000000000..e22568b7c7
--- /dev/null
+++ b/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/TestRuleUtil.java
@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.reasoner.rulesys;
+
+import static org.junit.Assert.assertEquals;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.apache.jena.datatypes.xsd.XSDDatatype;
+import org.apache.jena.graph.Node;
+import org.apache.jena.graph.NodeFactory;
+import org.junit.Test;
+
+public class TestRuleUtil {
+    @Test public void cmp1() {
+        compare("1", XSDDatatype.XSDdecimal, "2", XSDDatatype.XSDdecimal, -1);
+    }
+
+    // JENA-1583
+    @Test public void cmp2() {
+        compare("1", XSDDatatype.XSDdecimal, "1.5", XSDDatatype.XSDdecimal, -1);
+    }
+
+
+    // JENA-1583
+    @Test public void cmp3() {
+        compare("10000000000000000000000000000000", XSDDatatype.XSDinteger, "10000000000000000000000000000000", XSDDatatype.XSDdecimal, 0);
+    }
+
+    @Test public void cmp4() {
+        compare("10000000000000000000000000000000", XSDDatatype.XSDdecimal, "10000000000000000000000000000000.1", XSDDatatype.XSDdecimal, -1);
+    }
+
+    @Test public void cmp5() {
+        compare("10000000000000000000000000000000.1", XSDDatatype.XSDdecimal, "10000000000000000000000000000000", XSDDatatype.XSDdecimal, +1);
+    }
+    
+    private void compare(String lex1, XSDDatatype dt1, String lex2, XSDDatatype dt2, int outcome) {
+        Node n1 = NodeFactory.createLiteral(lex1, dt1);
+        Node n2 = NodeFactory.createLiteral(lex2, dt2);
+        int z = Util.compareNumbers(n1, n2);
+        assertEquals(outcome, z);
+    }
+    
+    // Directly test the number comparision code.  
+    
+    private void compare(Number num1, Number num2, int outcome) {
+        int z1 = Util.compareNumbers(num1, num2);
+        assertEquals("compare(num1,num2)", outcome, z1);
+        // reverse
+        int z2 = Util.compareNumbers(num2, num1);
+        assertEquals("compare(num2,num1)", outcome, -1 * z2);
+        
+    }
+
+    @Test public void cmp_num1() {
+        compare(new BigDecimal("1"), new BigDecimal("1.0"), 0);
+    }
+
+    @Test public void cmp_num2() {
+        compare(new BigDecimal("1"), new BigDecimal("1.5"), -1);
+    }
+
+
+    @Test public void cmp_num3() {
+        compare(new BigDecimal("10000000000000000000000000000000"), new BigDecimal("10000000000000000000000000000000.0"), 0);
+    }
+
+    @Test public void cmp_num4() {
+        compare(new BigDecimal("10000000000000000000000000000000"), new BigDecimal("10000000000000000000000000000000.00000000000000000001"), -1);
+    }
+
+    @Test public void cmp_num5() {
+        compare(new BigInteger("10000000000000000000000000000000"), new BigDecimal("0.00000000000000000001"), +1);
+    }
+
+    @Test public void cmp_num10() {
+        compare(Long.valueOf("1"), new BigDecimal("1.5"), -1);
+    }
+
+    @Test public void cmp_num11() {
+        compare(Long.valueOf(Long.MIN_VALUE+100), Double.parseDouble("1.5e0"), -1);
+    }
+
+    @Test public void cmp_num12() {
+        compare(Byte.valueOf("1"), Double.parseDouble("1.5"), -1);
+    }
+    
+    @Test public void cmp_num13() {
+        compare(Double.parseDouble("-0.5"), Byte.valueOf("-1"), 1);
+    }
+
+
+}
diff --git a/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/test/TestPackage.java b/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/test/TestPackage.java
index ad8e26a9a8..c2aeb3f578 100755
--- a/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/test/TestPackage.java
+++ b/jena-core/src/test/java/org/apache/jena/reasoner/rulesys/test/TestPackage.java
@@ -19,14 +19,14 @@
 package org.apache.jena.reasoner.rulesys.test;
 
 
+import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite ;
-
+import org.apache.jena.reasoner.rulesys.TestRuleUtil;
+import org.apache.jena.reasoner.rulesys.impl.TestLPBRuleEngine;
+import org.apache.jena.reasoner.rulesys.impl.TestLPBRuleEngineLeak;
 import org.slf4j.Logger ;
 import org.slf4j.LoggerFactory ;
 
-import org.apache.jena.reasoner.rulesys.impl.TestLPBRuleEngineLeak;
-import org.apache.jena.reasoner.rulesys.impl.TestLPBRuleEngine;
-
 /**
  * Aggregate tester that runs all the test associated with the rulesys package.
  */
@@ -42,6 +42,7 @@ public class TestPackage extends TestSuite {
     /** Creates new TestPackage */
     private TestPackage() {
         super("RuleSys");
+        addTest(new JUnit4TestAdapter(TestRuleUtil.class));
 
         addTestSuite( TestConfigVocabulary.class );
         addTestSuite( TestGenericRuleReasonerConfig.class );
@@ -60,6 +61,8 @@ public class TestPackage extends TestSuite {
         addTest( "TestOWLMisc", TestOWLMisc.suite() );
         addTest( "TestComparatorBuiltins", TestComparatorBuiltins.suite() );
         addTest( "FRuleEngineIFactoryTest", FRuleEngineIFactoryTest.suite() );
+        // Must reside in same package as util.
+        addTest(new JUnit4TestAdapter(TestRuleUtil.class));
         //addTest ("TestRuleLoader", TestRuleLoader.suite() );
 
         try {
@@ -84,5 +87,4 @@ public class TestPackage extends TestSuite {
         tc.setName(name);
         addTest(tc);
     }
-
 }
