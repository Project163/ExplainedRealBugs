diff --git a/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java b/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
index bf6d9b7b9c..5585bc0745 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/datatypes/xsd/XSDDateTime.java
@@ -131,13 +131,23 @@ public class XSDDateTime extends AbstractDateTime {
     private static int[] convertCalendar(Calendar date) {
         int[] data = new int[TOTAL_SIZE];
 
-        int offset = date.get(Calendar.ZONE_OFFSET) + date.get(Calendar.DST_OFFSET);
-                                        //  Thanks to Greg Shueler for pointing out need for DST offset
-        Calendar cal = date;
-        if (offset != 0) {
-            cal = (Calendar)date.clone();
-            cal.add(Calendar.MILLISECOND, -offset);
-        }
+        // JENA-247
+        // code from jena 2.7.1 -- remove if you see this -- commented out, 
+        // not deleted just because it was close to a release and a pragmatic,
+        // Java bug (?) avoiding hack was used.  
+//        int offset = date.get(Calendar.ZONE_OFFSET) + date.get(Calendar.DST_OFFSET);
+//                                        //  Thanks to Greg Shueler for pointing out need for DST offset
+//        Calendar cal = date;
+//        if (offset != 0) {
+//            cal = (Calendar)date.clone();
+//            cal.add(Calendar.MILLISECOND, -offset);
+//        }
+        
+        Calendar cal = (Calendar)date.clone();
+        // By observation (Sun Java 6), this is necesary (to force internal calculations presumably) ...
+        cal.get(Calendar.ZONE_OFFSET) ;
+        // ... then we can rebase the calendar
+        cal.setTimeZone(TimeZone.getTimeZone("GMT")); 
         
         data[AbstractDateTime.CY] = cal.get(Calendar.YEAR);
         data[AbstractDateTime.M] = cal.get(Calendar.MONTH) + 1;
diff --git a/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestTypedLiterals.java b/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestTypedLiterals.java
index 850468d0b0..14b6bf076b 100644
--- a/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestTypedLiterals.java
+++ b/jena-core/src/test/java/com/hp/hpl/jena/graph/test/TestTypedLiterals.java
@@ -21,11 +21,13 @@ package com.hp.hpl.jena.graph.test;
 import java.io.* ;
 import java.math.BigDecimal ;
 import java.math.BigInteger ;
+import java.text.SimpleDateFormat ;
 import java.util.* ;
 
 import junit.framework.TestCase ;
 import junit.framework.TestSuite ;
 import org.apache.xerces.impl.dv.util.HexBin ;
+import org.junit.Assert ;
 
 import com.hp.hpl.jena.datatypes.BaseDatatype ;
 import com.hp.hpl.jena.datatypes.DatatypeFormatException ;
@@ -1023,6 +1025,82 @@ public class TestTypedLiterals extends TestCase {
         checkSerialization("---12", XSDDatatype.XSDgDay);
     }
     
+    private static Date getDateFromPattern(String ts, String format, String timezoneid) throws Exception {
+        return getDateFromPattern(ts, new String[]{format}, TimeZone.getTimeZone(timezoneid));
+    }
+
+    private static Date getDateFromPattern(String ts, String[] formats, TimeZone tz) throws Exception {
+        java.util.Date date = null;
+        java.text.DateFormat sdf = java.text.DateFormat.getInstance();
+        {
+            sdf.setTimeZone(tz == null ? java.util.TimeZone.getDefault() : tz);
+            for (int i=0; date == null && i<formats.length;i++){
+                ((java.text.SimpleDateFormat)sdf).applyPattern(formats[i]);
+                try {
+                    date = sdf.parse(ts);
+                } catch (java.text.ParseException pe){} // keep trying
+            }
+        }
+        return date;
+    }
+    
+    public void testDateTimeBug2() throws Exception {
+        String[] timezonelist = {
+            "GMT",
+            "America/New_York",
+            "America/Chicago",
+        };
+
+        for (String timezoneid : timezonelist) {
+            TimeZone tz = TimeZone.getTimeZone(timezoneid);
+            String[] sampletimelist = {
+                "03/10/2012 01:29", 
+                // 03/11/2012 DST time change at 2 am
+                "03/11/2012 00:29",
+                "03/11/2012 01:29",
+                "03/11/2012 02:29",
+                "03/11/2012 03:29",
+                "03/11/2012 04:29",
+
+                "03/12/2012 01:29",
+                "11/03/2012 23:29",
+                // 11/04/2012 standard time change at 2 am
+                "11/04/2012 00:29",
+                "11/04/2012 01:29",
+                "11/04/2012 02:29",
+                "11/04/2012 03:29",
+            };
+
+
+
+            String format = "MM/dd/yyy HH:mm";
+            for (String tstr : sampletimelist){
+                Date dt=getDateFromPattern(tstr, format, timezoneid);
+                SimpleDateFormat df = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss z");
+                df.setTimeZone(tz);
+                Calendar cal = Calendar.getInstance();
+                cal.setTimeZone(tz);
+                cal.setTime(dt);
+                XSDDateTime xdt = new XSDDateTime(cal);
+                int offset = tz.getOffset(dt.getTime()) /( 60 * 60 * 1000);
+                int xhr = xdt.getHours();
+                int dhr = cal.get(Calendar.HOUR_OF_DAY);
+                int dif = (xhr -dhr + offset) % 24;
+                Assert.assertEquals("Difference between cal and xdt", 0, dif) ;
+                
+//                //System.out.println("xhr="+xhr+",dhr="+dhr+",dif="+dif);
+//                System.out.println(""
+//                    +"tstr="+tstr
+//                    +"\tdate="+df.format(dt)
+//                    +(dif==0?"\t ":"\tX")
+//                    +" xsddt="+xdt
+//                    +"\toffset="+offset);
+            }
+            //System.out.println();
+        }
+    }
+    
+    
     /**
      * Test global parameter flags.
      */
