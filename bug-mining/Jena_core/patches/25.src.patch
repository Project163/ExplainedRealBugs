diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/BaseInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/BaseInfGraph.java
index febca0bda8..df1e510308 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/BaseInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/BaseInfGraph.java
@@ -40,7 +40,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
     protected boolean recordDerivations;
 
     /** Flag to record if the preparation call has been made and so the graph is ready for queries */
-    protected boolean isPrepared = false;
+    private volatile boolean isPrepared = false;
 
     /** version count */
     protected volatile int version = 0;
@@ -236,7 +236,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
      * @param data the new raw data graph
      */
     @Override
-    public void rebind(Graph data) {
+    public synchronized void rebind(Graph data) {
         fdata = new FGraph(data);
         isPrepared = false;
     }
@@ -249,7 +249,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
      * the changed data.
      */
     @Override
-    public void rebind() {
+    public synchronized void rebind() {
         version++;
         isPrepared = false;
     }
@@ -274,7 +274,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
      * this prepration is done.
      */
     @Override
-    public void prepare() {
+    public synchronized void prepare() {
         // Default is to do no preparation
         isPrepared = true;
     }
@@ -475,7 +475,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
     @Override
     public synchronized void performAdd(Triple t) {
         version++;
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         fdata.getGraph().add(t);
     }
 
@@ -485,7 +485,7 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
     @Override
     public void performDelete(Triple t) {
         version++;
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         fdata.getGraph().delete(t);
     }
 
@@ -524,7 +524,13 @@ public abstract class BaseInfGraph extends GraphBase implements InfGraph {
          Answer true iff this graph has been through the <code>prepare()</code> step.
          For testing purposes.
     */
-    public boolean isPrepared()
+    public synchronized boolean isPrepared()
         { return isPrepared;  }
 
+    /**
+     * Reset prepared state to false
+     */
+    protected synchronized void setPreparedState(boolean state) {
+        this.isPrepared = state;
+    }
 }
diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/BasicForwardRuleInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/BasicForwardRuleInfGraph.java
index 1d55ac3757..31b22da662 100755
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/BasicForwardRuleInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/BasicForwardRuleInfGraph.java
@@ -170,7 +170,7 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
     @Override
     public void rebind() {
         version++;
-        isPrepared = false;
+        this.setPreparedState(false);
     }
 
     /**
@@ -191,8 +191,9 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
      */
     @Override
     public synchronized void prepare() {
-        if (isPrepared) return;
-        isPrepared = true;
+        if (this.isPrepared()) return;
+        this.setPreparedState(true);
+        
         // initilize the deductions graph
         fdeductions = new FGraph( createDeductionsGraph() );
         boolean rulesLoaded = false;
@@ -268,7 +269,7 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
      */
     private ExtendedIterator<Triple> findWithContinuation(TriplePattern pattern, Finder continuation, boolean filter) {
         checkOpen();
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         ExtendedIterator<Triple> result = null;
         if (fdata == null) {
             result = fdeductions.findWithContinuation(pattern, continuation);
@@ -318,7 +319,7 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
     public synchronized void performAdd(Triple t) {
         version++;
         fdata.getGraph().add(t);
-        if (isPrepared) {
+        if (this.isPrepared()) {
             engine.add(t);
         }
     }
@@ -329,7 +330,7 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
     @Override
     public int graphBaseSize() {
         checkOpen();
-        if (!isPrepared) {
+        if (!this.isPrepared()) {
             prepare();
         }
         int baseSize = fdata.getGraph().size();
@@ -350,7 +351,7 @@ public class BasicForwardRuleInfGraph extends BaseInfGraph implements ForwardRul
                 data.delete(t);
             }
         }
-        if (isPrepared) {
+        if (!this.isPrepared()) {
             fdeductions.getGraph().delete(t);
         }
     }
diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/FBRuleInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/FBRuleInfGraph.java
index 9510388670..b5884b1dfb 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/FBRuleInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/FBRuleInfGraph.java
@@ -393,105 +393,104 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
      */
     @Override
     public synchronized void prepare() {
-        if (!isPrepared) {
-            isPrepared = true;
-            
-            // Restore the original pre-hookProcess rules
-            rules = rawRules;
-            
-            // Is there any data to bind in yet?
-            Graph data = null;
-            if (fdata != null) data = fdata.getGraph();
+        if (this.isPrepared()) return;
+        
+        this.setPreparedState(true);
+                    
+        // Restore the original pre-hookProcess rules
+        rules = rawRules;
+        
+        // Is there any data to bind in yet?
+        Graph data = null;
+        if (fdata != null) data = fdata.getGraph();
+        
+        // initilize the deductions graph
+        if (fdeductions != null) {
+            Graph oldDeductions = (fdeductions).getGraph();
+            oldDeductions.clear();
+        } else {
+            fdeductions = new FGraph( createDeductionsGraph() );
+        }
+        dataFind = (data == null) ? fdeductions :  FinderUtil.cascade(fdeductions, fdata);
+        Finder dataSource = fdata;
+        
+        // Initialize the optional TGC caches
+        if (useTGCCaching) {
+            resetTGCCache();
+            if (schemaGraph != null) {
+                // Check if we can just reuse the copy of the raw 
+                if (
+                    (transitiveEngine.checkOccurance(TransitiveReasoner.subPropertyOf, data) ||
+                     transitiveEngine.checkOccurance(TransitiveReasoner.subClassOf, data) ||
+                     transitiveEngine.checkOccurance(RDFS.domain.asNode(), data) ||
+                     transitiveEngine.checkOccurance(RDFS.range.asNode(), data) )) {
             
-            // initilize the deductions graph
-            if (fdeductions != null) {
-                Graph oldDeductions = (fdeductions).getGraph();
-                oldDeductions.clear();
+                    // The data graph contains some ontology knowledge so split the caches
+                    // now and rebuild them using merged data
+                    transitiveEngine.insert(((FBRuleInfGraph)schemaGraph).fdata, fdata);
+                }     
             } else {
-                fdeductions = new FGraph( createDeductionsGraph() );
-            }
-            dataFind = (data == null) ? fdeductions :  FinderUtil.cascade(fdeductions, fdata);
-            Finder dataSource = fdata;
-            
-            // Initialize the optional TGC caches
-            if (useTGCCaching) {
-                resetTGCCache();
-                if (schemaGraph != null) {
-                    // Check if we can just reuse the copy of the raw 
-                    if (
-                        (transitiveEngine.checkOccurance(TransitiveReasoner.subPropertyOf, data) ||
-                         transitiveEngine.checkOccurance(TransitiveReasoner.subClassOf, data) ||
-                         transitiveEngine.checkOccurance(RDFS.domain.asNode(), data) ||
-                         transitiveEngine.checkOccurance(RDFS.range.asNode(), data) )) {
-                
-                        // The data graph contains some ontology knowledge so split the caches
-                        // now and rebuild them using merged data
-                        transitiveEngine.insert(((FBRuleInfGraph)schemaGraph).fdata, fdata);
-                    }     
-                } else {
-                    if (data != null) {
-                        transitiveEngine.insert(null, fdata);
-                    }
+                if (data != null) {
+                    transitiveEngine.insert(null, fdata);
                 }
-                // Insert any axiomatic statements into the caches
-                for (Iterator<Rule> i = rules.iterator(); i.hasNext(); ) {
-                    Rule r = i.next();
-                    if (r.bodyLength() == 0) {
-                        // An axiom
-                        for (int j = 0; j < r.headLength(); j++) {
-                            Object head = r.getHeadElement(j);
-                            if (head instanceof TriplePattern) {
-                                TriplePattern h = (TriplePattern) head;
-                                transitiveEngine.add(h.asTriple());
-                            }
+            }
+            // Insert any axiomatic statements into the caches
+            for (Iterator<Rule> i = rules.iterator(); i.hasNext(); ) {
+                Rule r = i.next();
+                if (r.bodyLength() == 0) {
+                    // An axiom
+                    for (int j = 0; j < r.headLength(); j++) {
+                        Object head = r.getHeadElement(j);
+                        if (head instanceof TriplePattern) {
+                            TriplePattern h = (TriplePattern) head;
+                            transitiveEngine.add(h.asTriple());
                         }
                     }
                 }
+            }
 
-                transitiveEngine.setCaching(true, true);
+            transitiveEngine.setCaching(true, true);
 //                dataFind = FinderUtil.cascade(subClassCache, subPropertyCache, dataFind);
-                dataFind = FinderUtil.cascade(dataFind, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
-                
-                // Without the next statement then the transitive closures are not seen by the forward rules
-                dataSource = FinderUtil.cascade(dataSource, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
-            }
+            dataFind = FinderUtil.cascade(dataFind, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
             
-            // Make sure there are no Brules left over from pior runs
-            bEngine.deleteAllRules();
+            // Without the next statement then the transitive closures are not seen by the forward rules
+            dataSource = FinderUtil.cascade(dataSource, transitiveEngine.getSubClassCache(), transitiveEngine.getSubPropertyCache());
+        }
+        
+        // Make sure there are no Brules left over from pior runs
+        bEngine.deleteAllRules();
 
-            // Call any optional preprocessing hook
-            if (preprocessorHooks != null && preprocessorHooks.size() > 0) {
-                Graph inserts = Factory.createGraphMem();
-                for (Iterator<RulePreprocessHook> i = preprocessorHooks.iterator(); i.hasNext(); ) {
-                    RulePreprocessHook hook = i.next();
-                    hook.run(this, dataFind, inserts);
-                }
-                if (inserts.size() > 0) {
-                    FGraph finserts = new FGraph(inserts);
-                    dataSource = FinderUtil.cascade(fdata, finserts);
-                    dataFind = FinderUtil.cascade(dataFind, finserts);
-                }
+        // Call any optional preprocessing hook
+        if (preprocessorHooks != null && preprocessorHooks.size() > 0) {
+            Graph inserts = Factory.createGraphMem();
+            for (Iterator<RulePreprocessHook> i = preprocessorHooks.iterator(); i.hasNext(); ) {
+                RulePreprocessHook hook = i.next();
+                hook.run(this, dataFind, inserts);
             }
-            
-            boolean rulesLoaded = false;
-            if (schemaGraph != null) {
-                Graph rawPreload = ((InfGraph)schemaGraph).getRawGraph();
-                if (rawPreload != null) {
-                    dataFind = FinderUtil.cascade(dataFind, new FGraph(rawPreload));
-                }
-                rulesLoaded = preloadDeductions(schemaGraph);
+            if (inserts.size() > 0) {
+                FGraph finserts = new FGraph(inserts);
+                dataSource = FinderUtil.cascade(fdata, finserts);
+                dataFind = FinderUtil.cascade(dataFind, finserts);
             }
-            if (rulesLoaded) {
-                engine.fastInit(dataSource);
-            } else {
-                // No preload so do the rule separation
-                addBRules(extractPureBackwardRules(rules));
-                engine.init(true, dataSource);
+        }
+        
+        boolean rulesLoaded = false;
+        if (schemaGraph != null) {
+            Graph rawPreload = ((InfGraph)schemaGraph).getRawGraph();
+            if (rawPreload != null) {
+                dataFind = FinderUtil.cascade(dataFind, new FGraph(rawPreload));
             }
-            // Prepare the context for builtins run in backwards engine
-            context = new BBRuleContext(this);
-            
+            rulesLoaded = preloadDeductions(schemaGraph);
+        }
+        if (rulesLoaded) {
+            engine.fastInit(dataSource);
+        } else {
+            // No preload so do the rule separation
+            addBRules(extractPureBackwardRules(rules));
+            engine.init(true, dataSource);
         }
+        // Prepare the context for builtins run in backwards engine
+        context = new BBRuleContext(this);
     }
     
     /**
@@ -505,7 +504,7 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
     public void rebind() {
         version++;
         if (bEngine != null) bEngine.reset();
-        isPrepared = false;
+        this.setPreparedState(false);
     }
     
     /**
@@ -570,7 +569,7 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
     @Override
     public ExtendedIterator<Triple> findWithContinuation(TriplePattern pattern, Finder continuation) {
         checkOpen();
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         ExtendedIterator<Triple> result =bEngine.find(pattern).filterKeep( new UniqueFilter<Triple>());
         if (continuation != null) {
             result = result.andThen(continuation.find(pattern));
@@ -591,7 +590,7 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
      */
     public ExtendedIterator<Triple> findFull(TriplePattern pattern) {
         checkOpen();
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
        return bEngine.find(pattern).filterKeep( new UniqueFilter<Triple>());
     }
    
@@ -622,10 +621,10 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
      * Flush out all cached results. Future queries have to start from scratch.
      */
     @Override
-    public void reset() {
+    public synchronized void reset() {
         version++;
         bEngine.reset();
-        isPrepared = false;
+        this.setPreparedState(false);
     }
 
     /**
@@ -637,9 +636,9 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
         version++;
         fdata.getGraph().add(t);
         if (useTGCCaching) {
-            if (transitiveEngine.add(t)) isPrepared = false;
+            if (transitiveEngine.add(t)) this.setPreparedState(false);
         }
-        if (isPrepared) {
+        if (this.isPrepared()) {
             boolean needReset = false;
             if (preprocessorHooks != null && preprocessorHooks.size() > 0) {
                 if (preprocessorHooks.size() > 1) {
@@ -653,7 +652,7 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
                 }
             }
             if (needReset) {
-                isPrepared = false;
+                this.setPreparedState(false);
             } else {
                 engine.add(t);
             }
@@ -671,19 +670,19 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
         fdata.getGraph().delete(t);
         if (useTGCCaching) {
             if (transitiveEngine.delete(t)) {
-                if (isPrepared) {
+                if (this.isPrepared()) {
                     bEngine.deleteAllRules();
                 }
-                isPrepared = false;
+                this.setPreparedState(false);
             }
         } 
         // Full incremental remove processing requires reference counting
         // of all deductions. It's not clear the cost of maintaining the
         // reference counts is worth it so the current implementation
         // forces a recompute if any external deletes are performed.
-        if (isPrepared) {
+        if (this.isPrepared()) {
             bEngine.deleteAllRules();
-            isPrepared = false;
+            this.setPreparedState(false);
             // Re-enable the code below when/if ref counting is added and remove above
             // if (removeIsFromBase) engine.delete(t);
         }
@@ -747,7 +746,7 @@ public class FBRuleInfGraph  extends BasicForwardRuleInfGraph implements Backwar
         // We sneak this switch directly into the engine to avoid contaminating the
         // real data - this is only possible only the forward engine has been prepared
 //      add(validateOn);
-        if (!isPrepared) {
+        if (!this.isPrepared()) {
             prepare();
         }
         engine.add(validateOn); 
diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/LPBackwardRuleInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/LPBackwardRuleInfGraph.java
index 4f8b49cec2..aa7eaba490 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/LPBackwardRuleInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/LPBackwardRuleInfGraph.java
@@ -98,20 +98,20 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
      * this prepration is done.
      */
     @Override
-    public void prepare() {
-        if (!isPrepared) {
-            fdeductions = new FGraph( Factory.createGraphMem() );
-            extractAxioms();
-            dataFind = fdata;
-            if (fdeductions != null) {
-                dataFind = FinderUtil.cascade(dataFind, fdeductions);
-            }
-            if (fschema != null) {
-                dataFind = FinderUtil.cascade(dataFind, fschema);
-            }
+    public synchronized void prepare() {
+        if (this.isPrepared()) return;
+        
+        fdeductions = new FGraph( Factory.createGraphMem() );
+        extractAxioms();
+        dataFind = fdata;
+        if (fdeductions != null) {
+            dataFind = FinderUtil.cascade(dataFind, fdeductions);
+        }
+        if (fschema != null) {
+            dataFind = FinderUtil.cascade(dataFind, fschema);
         }
         
-        isPrepared = true;
+        this.setPreparedState(true);
     }
 
     /**
@@ -125,7 +125,7 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
     public synchronized void rebind(Graph data) {
         engine.checkSafeToUpdate();
         fdata = new FGraph(data);
-        isPrepared = false;
+        this.setPreparedState(false);
     }
     
     /**
@@ -139,7 +139,7 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
     public synchronized void rebind() {
         version++;
         engine.checkSafeToUpdate();
-        isPrepared = false;
+        this.setPreparedState(false);
     }
 
     /**
@@ -166,7 +166,7 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
     @Override
     public synchronized ExtendedIterator<Triple> findWithContinuation(TriplePattern pattern, Finder continuation) {
         checkOpen();
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         ExtendedIterator<Triple> result = engine.find(pattern).filterKeep( new UniqueFilter<Triple>());
         if (continuation != null) {
             result = result.andThen(continuation.find(pattern));
@@ -206,7 +206,7 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
         version++;
         engine.checkSafeToUpdate();
         fdata.getGraph().add(t);
-        isPrepared = false;
+        this.setPreparedState(false);
     }
      
     /** 
@@ -217,7 +217,7 @@ public class LPBackwardRuleInfGraph extends BaseInfGraph implements BackwardRule
         version++;
         engine.checkSafeToUpdate();
         fdata.getGraph().delete(t);
-        isPrepared = false;
+        this.setPreparedState(false);
     }
        
     /**
diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/RETERuleInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/RETERuleInfGraph.java
index 514e43c272..6ed9e49ea2 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/RETERuleInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/rulesys/RETERuleInfGraph.java
@@ -91,7 +91,7 @@ public class RETERuleInfGraph extends BasicForwardRuleInfGraph {
      */
     @Override
     public synchronized void performAdd(Triple t) {
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         fdata.getGraph().add(t);
         engine.add(t);
     }
@@ -101,7 +101,7 @@ public class RETERuleInfGraph extends BasicForwardRuleInfGraph {
      */   
     @Override
     public void performDelete(Triple t) {
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         if (fdata != null) {
             Graph data = fdata.getGraph();
             if (data != null) {
diff --git a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/transitiveReasoner/TransitiveInfGraph.java b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/transitiveReasoner/TransitiveInfGraph.java
index 1b211c029a..e8cab7cae4 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/reasoner/transitiveReasoner/TransitiveInfGraph.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/reasoner/transitiveReasoner/TransitiveInfGraph.java
@@ -65,7 +65,9 @@ public class TransitiveInfGraph extends BaseInfGraph {
      * this prepration is done.
      */
     @Override
-    public void prepare() {
+    public synchronized void prepare() {
+        if (this.isPrepared()) return;
+        
         tbox = ((TransitiveReasoner)reasoner).getTbox();
         // Initially just point to the reasoner's precached information
         transitiveEngine = new TransitiveEngine(((TransitiveReasoner)reasoner).getSubClassCache().deepCopy(),
@@ -78,7 +80,7 @@ public class TransitiveInfGraph extends BaseInfGraph {
         dataFind = transitiveEngine.insert(tbox, fdata);
         transitiveEngine.setCaching(true, true);
         
-        isPrepared = true;
+        this.setPreparedState(true);
     }
 
     /**
@@ -107,7 +109,7 @@ public class TransitiveInfGraph extends BaseInfGraph {
      */
     @Override public ExtendedIterator<Triple> findWithContinuation(TriplePattern pattern, Finder continuation) {
         checkOpen();
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         Finder cascade = transitiveEngine.getFinder(pattern, FinderUtil.cascade(tbox, continuation));
         return cascade.find(pattern).filterKeep( new UniqueFilter<Triple>());
     }
@@ -135,7 +137,7 @@ public class TransitiveInfGraph extends BaseInfGraph {
      */
     @Override
     public synchronized void performAdd(Triple t) {
-        if (!isPrepared) prepare();
+        if (!this.isPrepared()) prepare();
         fdata.getGraph().add(t);
         transitiveEngine.add(t);
     }
@@ -144,9 +146,9 @@ public class TransitiveInfGraph extends BaseInfGraph {
      * Removes the triple t (if possible) from the set belonging to this graph.
      */   
     @Override
-    public void performDelete(Triple t) {
+    public synchronized void performDelete(Triple t) {
         fdata.getGraph().delete(t);
-        if (isPrepared) {
+        if (this.isPrepared()) {
             transitiveEngine.delete(t);
         }
     }
