diff --git a/jena-core/src/main/java/com/hp/hpl/jena/graph/GraphUtil.java b/jena-core/src/main/java/com/hp/hpl/jena/graph/GraphUtil.java
index e96cfa4b65..58b503d6a7 100644
--- a/jena-core/src/main/java/com/hp/hpl/jena/graph/GraphUtil.java
+++ b/jena-core/src/main/java/com/hp/hpl/jena/graph/GraphUtil.java
@@ -68,8 +68,7 @@ public class GraphUtil
      * @param o Object  - may be Node.ANY
      * @return  ExtendedIterator
      */
-    public static ExtendedIterator<Node> listSubjects(Graph g, Node p, Node o)
-    {
+    public static ExtendedIterator<Node> listSubjects(Graph g, Node p, Node o) { 
         // Restore a minimal QueryHandler?
         ExtendedIterator<Triple> iter = g.find(Node.ANY, p, o) ;
         Set<Node> nodes = iter.mapWith(mapSubject).toSet() ;
@@ -83,8 +82,7 @@ public class GraphUtil
      * @param o Object  - may be Node.ANY
      * @return  ExtendedIterator
      */
-    public static ExtendedIterator<Node> listPredicates(Graph g, Node s, Node o)
-    {
+    public static ExtendedIterator<Node> listPredicates(Graph g, Node s, Node o) {
         ExtendedIterator<Triple> iter = g.find(s,Node.ANY, o) ;
         Set<Node> nodes = iter.mapWith(mapPredicate).toSet() ;
         return WrappedIterator.createNoRemove(nodes.iterator()) ;
@@ -97,16 +95,14 @@ public class GraphUtil
      * @param p Predicate  - may be Node.ANY
      * @return  ExtendedIterator
      */
-    public static ExtendedIterator<Node> listObjects(Graph g, Node s, Node p)
-    {
+    public static ExtendedIterator<Node> listObjects(Graph g, Node s, Node p) {
         ExtendedIterator<Triple> iter = g.find(s, p, Node.ANY) ;
         Set<Node> nodes = iter.mapWith(mapObject).toSet() ;
         return WrappedIterator.createNoRemove(nodes.iterator()) ;
     }
     
     /** Does the graph use the node anywhere as a subject, predciate or object? */
-    public static boolean containsNode(Graph graph, Node node)
-    {
+    public static boolean containsNode(Graph graph, Node node) {
         return
             graph.contains(node, Node.ANY, Node.ANY) ||
             graph.contains(Node.ANY, Node.ANY, node) ||
@@ -123,13 +119,11 @@ public class GraphUtil
      *            the graph from which to extract triples
      * @return an iterator over all the graph's triples
      */
-    public static ExtendedIterator<Triple> findAll(Graph g)
-    {
+    public static ExtendedIterator<Triple> findAll(Graph g) {
         return g.find(Triple.ANY) ;
     }
     
-    public static void add(Graph graph, Triple[] triples)
-    {
+    public static void add(Graph graph, Triple[] triples) {
         if ( OldStyle && graph instanceof GraphWithPerform )
         {
             GraphWithPerform g = (GraphWithPerform)graph ;
@@ -144,8 +138,7 @@ public class GraphUtil
         }
     }
         
-    public static void add(Graph graph, List<Triple> triples)
-    {
+    public static void add(Graph graph, List<Triple> triples) {
         if ( OldStyle && graph instanceof GraphWithPerform )
         {
             GraphWithPerform g = (GraphWithPerform)graph ;
@@ -159,8 +152,7 @@ public class GraphUtil
         }
     }
         
-    public static void add(Graph graph, Iterator<Triple> it)
-    {
+    public static void add(Graph graph, Iterator<Triple> it) {
         // Materialize to avoid ConcurrentModificationException.
         List<Triple> s = IteratorCollection.iteratorToList(it) ;
         if ( OldStyle && graph instanceof GraphWithPerform )
@@ -178,14 +170,13 @@ public class GraphUtil
     }
     
     /** Add triples into the destination (arg 1) from the source (arg 2)*/
-    public static void addInto(Graph dstGraph, Graph srcGraph )
-    {
+    public static void addInto(Graph dstGraph, Graph srcGraph ) {
+        dstGraph.getPrefixMapping().setNsPrefixes(srcGraph.getPrefixMapping()) ;
         addIteratorWorker(dstGraph, GraphUtil.findAll( srcGraph ));  
         dstGraph.getEventManager().notifyAddGraph( dstGraph, srcGraph );
     }
     
-    private static void addIteratorWorker( Graph graph, Iterator<Triple> it )
-    { 
+    private static void addIteratorWorker( Graph graph, Iterator<Triple> it ) { 
         List<Triple> s = IteratorCollection.iteratorToList( it );
         if ( OldStyle && graph instanceof GraphWithPerform )
         {
@@ -200,35 +191,28 @@ public class GraphUtil
         }
     }
 
-    public static void delete(Graph graph, Triple[] triples)
-    {
-        if ( OldStyle && graph instanceof GraphWithPerform )
-        {
+    public static void delete(Graph graph, Triple[] triples) {
+        if ( OldStyle && graph instanceof GraphWithPerform ) {
             GraphWithPerform g = (GraphWithPerform)graph ;
-            for (Triple t : triples )
+            for ( Triple t : triples )
                 g.performDelete(t) ;
             graph.getEventManager().notifyDeleteArray(graph, triples) ;
-        }
-        else
-        {
-            for (Triple t : triples )
-                graph.delete(t) ; 
+        } else {
+            for ( Triple t : triples )
+                graph.delete(t) ;
         }
     }
     
     public static void delete(Graph graph, List<Triple> triples)
-    {
-        if ( OldStyle && graph instanceof GraphWithPerform )
-        {
+ {
+        if ( OldStyle && graph instanceof GraphWithPerform ) {
             GraphWithPerform g = (GraphWithPerform)graph ;
-            for (Triple t : triples )
+            for ( Triple t : triples )
                 g.performDelete(t) ;
             graph.getEventManager().notifyDeleteList(graph, triples) ;
-        }
-        else
-        {
-            for (Triple t : triples )
-                graph.delete(t) ; 
+        } else {
+            for ( Triple t : triples )
+                graph.delete(t) ;
         }
     }
     
@@ -236,75 +220,64 @@ public class GraphUtil
     {
         // Materialize to avoid ConcurrentModificationException.
         List<Triple> s = IteratorCollection.iteratorToList(it) ;
-        if ( OldStyle && graph instanceof GraphWithPerform )
-        {
+        if ( OldStyle && graph instanceof GraphWithPerform ) {
             GraphWithPerform g = (GraphWithPerform)graph ;
-            for (Triple t : s)
+            for ( Triple t : s )
                 g.performDelete(t) ;
             graph.getEventManager().notifyDeleteIterator(graph, s) ;
-        } 
-        else
-        {
-            for (Triple t : s)
+        } else {
+            for ( Triple t : s )
                 graph.delete(t) ;
         }
     }
     
     /** Delete triples the destination (arg 1) as given in the source (arg 2) */
-    public static void deleteFrom(Graph dstGraph, Graph srcGraph)
-    {
-        deleteIteratorWorker(dstGraph, GraphUtil.findAll( srcGraph ));  
-        dstGraph.getEventManager().notifyDeleteGraph( dstGraph, srcGraph );
+    public static void deleteFrom(Graph dstGraph, Graph srcGraph) {
+        deleteIteratorWorker(dstGraph, GraphUtil.findAll(srcGraph)) ;
+        dstGraph.getEventManager().notifyDeleteGraph(dstGraph, srcGraph) ;
     }
-    
-    private static void deleteIteratorWorker( Graph graph, Iterator<Triple> it )
-    { 
-        List<Triple> s = IteratorCollection.iteratorToList( it );
-        if ( OldStyle && graph instanceof GraphWithPerform )
-        {
+
+    private static void deleteIteratorWorker(Graph graph, Iterator<Triple> it) {
+        List<Triple> s = IteratorCollection.iteratorToList(it) ;
+        if ( OldStyle && graph instanceof GraphWithPerform ) {
             GraphWithPerform g = (GraphWithPerform)graph ;
-            for (Triple t : s )
+            for ( Triple t : s )
                 g.performDelete(t) ;
-        }
-        else
-        {
-            for (Triple t : s )
+        } else {
+            for ( Triple t : s )
                 graph.delete(t) ;
         }
     }
-    
+
     private static final int sliceSize = 1000 ;
     /** A safe and cautious remve() function.
      *  To avoid any possible ConcurrentModificationExceptions,
      *  it finds batches of triples, deletes them and tries again until
      *  no change occurs. 
      */
-    public static void remove(Graph g, Node s, Node p, Node o)
-    {
+    public static void remove(Graph g, Node s, Node p, Node o) {
         // Beware of ConcurrentModificationExceptions.
         // Delete in batches.
-        // That way, there is no active iterator when a delete 
+        // That way, there is no active iterator when a delete
         // from the indexes happens.
-        
+
         Triple[] array = new Triple[sliceSize] ;
-        
-        while (true)
-        {
+
+        while (true) {
             // Convert/cache s,p,o?
-            // The Node Cache will catch these so don't worry unduely. 
-            ExtendedIterator<Triple> iter = g.find(s,p,o) ;
-            
+            // The Node Cache will catch these so don't worry unduely.
+            ExtendedIterator<Triple> iter = g.find(s, p, o) ;
+
             // Get a slice
             int len = 0 ;
-            for ( ; len < sliceSize ; len++ )
-            {
-                if ( !iter.hasNext() ) break ;
+            for ( ; len < sliceSize ; len++ ) {
+                if ( !iter.hasNext() )
+                    break ;
                 array[len] = iter.next() ;
             }
-            
+
             // Delete them.
-            for ( int i = 0 ; i < len ; i++ )
-            {
+            for ( int i = 0 ; i < len ; i++ ) {
                 g.delete(array[i]) ;
                 array[i] = null ;
             }
