diff --git a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDBaseNumericType.java b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDBaseNumericType.java
index fca5dabced..abbab9d3f1 100644
--- a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDBaseNumericType.java
+++ b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDBaseNumericType.java
@@ -29,8 +29,8 @@ import org.apache.jena.shared.impl.JenaParameters ;
 /**
  * Base implementation for all numeric datatypes derived from
  * xsd:decimal. The only purpose of this place holder is
- * to support the isValidLiteral tests across numeric types. Note
- * that float and double are not included in this set.
+ * to support the isValidLiteral tests across numeric types. 
+ *  * <p>Note that float and double are not included in this set.
  */
 public class XSDBaseNumericType extends XSDDatatype {
 
@@ -87,7 +87,7 @@ public class XSDBaseNumericType extends XSDDatatype {
     @Override
     public boolean isValidValue(Object valueForm) {
         if (valueForm instanceof Number) {
-            return isValid(valueForm.toString());
+            return isValid(unparse(valueForm));
         } else {
             return false;
         }
@@ -118,7 +118,6 @@ public class XSDBaseNumericType extends XSDDatatype {
      */
     private Object cannonicalizeDecimal(BigDecimal value) {
         // This could can be simplified by using toBigIntegerExact
-        // once we drop Java 1.4 support
         if (value.scale() > 0) {
             // Check if we can strip off any trailing zeros after decimal point
             BigInteger i = value.unscaledValue();
@@ -162,6 +161,20 @@ public class XSDBaseNumericType extends XSDDatatype {
         return super.parse(lexicalForm);
     }
     
+    /**
+     * Convert a value of this datatype to lexical form.
+     * Certain forms are not a simple matter of java's toString on the Number object. 
+     */
+    @Override
+    public String unparse(Object value) {
+        if ( value instanceof BigDecimal )
+            // Avoid exponent usage.
+            return ((BigDecimal)value).toPlainString() ;
+        // See also for XSDfloat and XSDdouble. 
+        // Integer hierarchy is OK.
+        return value.toString();
+    }
+    
     /**
      * Check for whitespace violations.
      * Turned off by default.
diff --git a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDDouble.java b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDDouble.java
index fe866addc3..d09088c7e1 100644
--- a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDDouble.java
+++ b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDDouble.java
@@ -80,6 +80,22 @@ public class XSDDouble extends XSDDatatype {
          return super.parse(lexicalForm);
      }
 
+     @Override
+     public String unparse(Object value) {
+         if ( value instanceof Double ) {
+             // Java has "Infinity" and -"Infinity" but XSD has "INF" and "-INF"
+             Double d = (Double) value ;
+             if ( Double.isInfinite(d) ) {
+                 if ( d < 0 )
+                     return "-INF" ;
+                 return "INF" ;
+             }
+             return d.toString() ;
+         }
+         return super.unparse(value) ;
+     }
+
+     
     /**
      * Parse a validated lexical form. Subclasses which use the default
      * parse implementation and are not convered by the explicit convertValidatedData
diff --git a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDFloat.java b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDFloat.java
index 6e1965c10b..39ca1bd1f9 100644
--- a/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDFloat.java
+++ b/jena-core/src/main/java/org/apache/jena/datatypes/xsd/impl/XSDFloat.java
@@ -52,7 +52,7 @@ public class XSDFloat extends XSDDatatype {
     
 //     /**
 //      * Test whether the given LiteralLabel is a valid instance
-//      * of this datatype. This takes into accound typing information
+//      * of this datatype. This takes into account typing information
 //      * as well as lexical form - for example an xsd:string is
 //      * never considered valid as an xsd:integer (even if it is
 //      * lexically legal like "1").
@@ -80,6 +80,21 @@ public class XSDFloat extends XSDDatatype {
          return super.parse(lexicalForm);
      }
 
+     @Override
+     public String unparse(Object value) {
+         if ( value instanceof Float ) {
+             // Java has "Infinity" and -"Infinity" but XSD has "INF" and "-INF"
+             Float f = (Float) value ;
+             if ( Float.isInfinite(f) ) {
+                 if ( f < 0 )
+                     return "-INF" ;
+                 return "INF" ;
+             }
+             return f.toString() ;
+         }
+         return super.unparse(value) ;
+     }
+     
     /**
      * Parse a validated lexical form. Subclasses which use the default
      * parse implementation and are not convered by the explicit convertValidatedData
diff --git a/jena-core/src/test/java/org/apache/jena/datatypes/TestDatatypes.java b/jena-core/src/test/java/org/apache/jena/datatypes/TestDatatypes.java
index 575189a114..91dd857ec2 100644
--- a/jena-core/src/test/java/org/apache/jena/datatypes/TestDatatypes.java
+++ b/jena-core/src/test/java/org/apache/jena/datatypes/TestDatatypes.java
@@ -22,7 +22,11 @@ import static org.junit.Assert.assertEquals ;
 import static org.junit.Assert.assertFalse ;
 import static org.junit.Assert.assertNotNull ;
 import static org.junit.Assert.assertTrue ;
+
+import java.math.BigDecimal ;
+
 import org.apache.jena.datatypes.xsd.XSDDatatype ;
+import org.apache.jena.graph.Node ;
 import org.apache.jena.graph.NodeFactory ;
 import org.apache.jena.rdf.model.Resource ;
 import org.apache.jena.vocabulary.XSD ;
@@ -141,6 +145,43 @@ public class TestDatatypes {
         invalid(xsdDayTimeDuration, "P1DT") ;
     }
 
+    @Test public void valueToLex_bigdecimal_01() {
+        testValueToLex(new BigDecimal("0.004"), XSDDatatype.XSDdecimal) ;
+    }
+
+    @Test public void valueToLex_bigdecimal_02() {
+        testValueToLex(new BigDecimal("1E21"), XSDDatatype.XSDdecimal) ;
+    }
+
+    @Test public void valueToLex_double_01() {
+        testValueToLex(new Double("1E21"), XSDDatatype.XSDdouble) ;
+    }
+
+    @Test public void valueToLex_double_02() {
+        testValueToLex(Double.POSITIVE_INFINITY, XSDDatatype.XSDdouble) ;
+    }
+
+    @Test public void valueToLex_double_03() {
+        testValueToLex(Double.NEGATIVE_INFINITY, XSDDatatype.XSDdouble) ;
+    }
+
+    @Test public void valueToLex_float_01() {
+        testValueToLex(new Float("1E21"), XSDDatatype.XSDfloat) ;
+    }
+
+    @Test public void valueToLex_float_02() {
+        testValueToLex(Float.POSITIVE_INFINITY, XSDDatatype.XSDfloat) ;
+    }
+
+    @Test public void valueToLex_float_03() {
+        testValueToLex(Float.NEGATIVE_INFINITY, XSDDatatype.XSDfloat) ;
+    }
+
+    private void testValueToLex(Object value, XSDDatatype datatype) {
+        Node node = NodeFactory.createLiteralByValue(value, datatype) ;
+        assertTrue("Not valid lexical form "+value+" -> "+node, datatype.isValid(node.getLiteralLexicalForm())) ;
+    }
+
     private void valid(XSDDatatype xsddatatype, String string) {
         assertTrue("Expected valid: "+string, xsddatatype.isValid(string)) ;
     }
