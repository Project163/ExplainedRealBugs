diff --git a/jena-core/src/main/java/org/apache/jena/util/PrefixMappingUtils.java b/jena-core/src/main/java/org/apache/jena/util/PrefixMappingUtils.java
index bf3d680d52..1f50e791d6 100644
--- a/jena-core/src/main/java/org/apache/jena/util/PrefixMappingUtils.java
+++ b/jena-core/src/main/java/org/apache/jena/util/PrefixMappingUtils.java
@@ -19,13 +19,13 @@
 package org.apache.jena.util;
 
 import java.util.* ;
-import java.util.function.Consumer ;
 import java.util.stream.Collectors ;
 
 import org.apache.jena.atlas.lib.SetUtils ;
 import org.apache.jena.atlas.lib.Trie ;
 import org.apache.jena.graph.Graph ;
 import org.apache.jena.graph.Node ;
+import org.apache.jena.graph.Node_Triple;
 import org.apache.jena.graph.Triple ;
 import org.apache.jena.graph.impl.WrappedGraph;
 import org.apache.jena.rdf.model.Model ;
@@ -42,7 +42,7 @@ public class PrefixMappingUtils {
      * Later changes to the prefix mapping of the original graph are not reflected in the returned graph.
      * Modifications to the triples contained in the underlying graph are reflected.   
      */
-    public static Graph graphInUsePrefixMapping(Graph graph) {
+    public static Graph graphxInUsePrefixMapping(Graph graph) {
         final PrefixMapping prefixMapping = calcInUsePrefixMapping(graph) ;
         prefixMapping.lock() ;
         Graph graph2 = new WrappedGraph(graph) {
@@ -95,7 +95,6 @@ public class PrefixMappingUtils {
      * @see #calcInUsePrefixMappingTTL(Graph, PrefixMapping)
      */
     public static PrefixMapping calcInUsePrefixMapping(Graph graph, PrefixMapping prefixMapping) {
-        
         /* Method:
          * 
          * For each URI in the data, look it up in the trie.
@@ -116,25 +115,9 @@ public class PrefixMappingUtils {
         // (URIs if "add(uri, uri)")
         Set<String> inUse = new HashSet<>() ;
         
-        // Process to apply to each node
-        // Accumulate any prefixes into 'inUse' if the data URI
-        // is partially matched by a prefix URIs in the trie.  
-        Consumer<Node> process = (node)->{
-            if ( ! node.isURI() )
-                return ;
-            String uri = node.getURI() ;
-            // Get all prefixes whose URIs are candidates 
-            List<String> hits = trie.partialSearch(uri) ;
-            if ( hits.isEmpty() )
-                return ;
-            inUse.addAll(hits) ;
-        } ;
-        
         while(iter.hasNext()) {
             Triple triple = iter.next() ;
-            process.accept(triple.getSubject()) ;
-            process.accept(triple.getPredicate()) ;
-            process.accept(triple.getObject()) ; 
+            process(triple, inUse, trie);
             if ( pmap.size() == inUse.size() )
                 break ;
         }
@@ -148,6 +131,36 @@ public class PrefixMappingUtils {
         return pmap2 ;
     }
 
+    // Step for each Triple
+    private static void process(Triple triple, Set<String> inUse, Trie<String> trie) {
+        process(triple.getSubject(),   inUse, trie); 
+        process(triple.getPredicate(), inUse, trie);
+        process(triple.getObject(),    inUse, trie);
+    }
+    
+    // Step for each Node.
+    // Process to apply to each node
+    // Accumulate any prefixes into 'inUse' if the data URI
+    // is partially matched by a prefix URIs in the trie.  
+    private static void process(Node node, Set<String> inUse, Trie<String> trie) {
+        String uri;
+        if ( node.isURI() )
+            uri = node.getURI();
+        else if ( node.isLiteral() )
+            uri = node.getLiteralDatatypeURI();
+        else if ( node.isNodeTriple() ) {
+            process(Node_Triple.triple(node), inUse, trie);
+            return ;
+        }
+        else
+            return;
+        // Get all prefixes whose URIs are candidates 
+        List<String> hits = trie.partialSearch(uri) ;
+        if ( hits.isEmpty() )
+            return ;
+        inUse.addAll(hits) ;
+    }
+    
     /**
      * Analyse the graph to see which prefixes of the graph are in use.
      * <p>
@@ -195,27 +208,11 @@ public class PrefixMappingUtils {
         
         // Prefixes used.
         Set<String> inUse = new HashSet<>() ;
-        // Process to be applied to each node in the graph.
-        Consumer<Node> process = (node) -> {
-            if ( ! node.isURI() )
-                return ;
-            String uri = node.getURI() ;
-            
-            int idx = SplitIRI.splitpoint(uri) ;
-            if ( idx < 0 )
-                return ;
-            String nsURI = SplitIRI.namespaceTTL(uri) ;
-            String prefix = prefixMapping.getNsURIPrefix(nsURI) ;
-            if ( prefix != null )
-                inUse.add(prefix) ;
-        } ;
         
         Iterator<Triple> iter = graph.find(null, null, null) ;
         while(iter.hasNext()) {
             Triple triple = iter.next() ;
-            process.accept(triple.getSubject()) ; 
-            process.accept(triple.getPredicate()) ;
-            process.accept(triple.getObject()) ; 
+            processTTL(triple, inUse, prefixMapping);
             if ( inUse.size() == prefixURIs.size() )
                 // Fast exit.
                 break ;
@@ -229,6 +226,36 @@ public class PrefixMappingUtils {
         inUse.forEach((prefix)-> pmap2.setNsPrefix(prefix, prefixMapping.getNsPrefixURI(prefix)) ) ;
         return pmap2 ;
     }
+
+    // Step for each Triple
+    private static void processTTL(Triple triple, Set<String> inUse, PrefixMapping prefixMapping) {
+        processTTL(triple.getSubject(),   inUse, prefixMapping); 
+        processTTL(triple.getPredicate(), inUse, prefixMapping);
+        processTTL(triple.getObject(),    inUse, prefixMapping);
+    }
+    
+    // Step for each Node.
+    private static void processTTL(Node node, Set<String> inUse, PrefixMapping prefixMapping) {
+        String uri;
+        if ( node.isURI() )
+            uri = node.getURI();
+        else if ( node.isLiteral() )
+            uri = node.getLiteralDatatypeURI();
+        else if ( node.isNodeTriple() ) {
+            processTTL(Node_Triple.triple(node), inUse, prefixMapping);
+            return ;
+        }
+        else
+            return;
+        // URI case.
+        int idx = SplitIRI.splitpoint(uri) ;
+        if ( idx < 0 )
+            return ;
+        String nsURI = SplitIRI.namespaceTTL(uri) ;
+        String prefix = prefixMapping.getNsURIPrefix(nsURI) ;
+        if ( prefix != null )
+            inUse.add(prefix) ;
+    }
     
     /** Check every URI as a possible use of a prefix */ 
     private static Set<String> fullMethod(Model m) {
diff --git a/jena-core/src/test/java/org/apache/jena/util/TestPrefixMappingUtils.java b/jena-core/src/test/java/org/apache/jena/util/TestPrefixMappingUtils.java
index 5931d5a53a..e4dc395b10 100644
--- a/jena-core/src/test/java/org/apache/jena/util/TestPrefixMappingUtils.java
+++ b/jena-core/src/test/java/org/apache/jena/util/TestPrefixMappingUtils.java
@@ -28,6 +28,7 @@ import org.apache.jena.rdf.model.Model;
 import org.apache.jena.rdf.model.ModelFactory;
 import org.apache.jena.shared.PrefixMapping ;
 import org.apache.jena.shared.impl.PrefixMappingImpl ;
+import org.apache.jena.vocabulary.XSD;
 import org.junit.Assert ;
 import org.junit.Test ;
 
@@ -50,17 +51,20 @@ public class TestPrefixMappingUtils {
     
     @Test public void prefixes1() {
         // All prefixes used.
+        // Note: XSD as well.
         String data1 = StrUtils.strjoinNL
             ("@prefix : <http://example/> ." ,
              "@prefix ex: <http://example/ex#> ." ,
+             "@prefix xsd: <"+XSD.getURI()+"> .",
              "" ,
              ":s1 :p :x1 ." ,
-             ":s1 ex:p :x1 ."
+             ":s1 ex:p :x1 .",
+             ":s1 ex:p 1 ."
              ) ;
         Graph graph1 = create(data1) ;
         PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMapping(graph1) ;
         PrefixMapping pmapExpected = graph1.getPrefixMapping() ;
-        Assert.assertEquals(2, size(pmap)) ;
+        Assert.assertEquals(3, size(pmap)) ;
         Assert.assertEquals(pmapExpected, pmap) ; 
     }
     
@@ -114,6 +118,7 @@ public class TestPrefixMappingUtils {
     
     @Test public void prefixesN() {
         // All combinations.
+        // No "@prefix xsd: <"+XSD.getURI()+"> ." so not in output.
         String data = StrUtils.strjoinNL
             ("@prefix : <http://example/> ." ,
              "@prefix ex: <http://example/ex#> ." ,
@@ -141,14 +146,125 @@ public class TestPrefixMappingUtils {
         Graph graph = create(data) ;
         PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMapping(graph) ;
         PrefixMapping pmapExpected = new PrefixMappingImpl() ;
-     	pmapExpected.setNsPrefix("", "http://example/") ;
-		pmapExpected.setNsPrefix("ex", "http://example/ex#") ;
-		pmapExpected.setNsPrefix("indirect", "urn:foo:") ;
-		pmapExpected.setNsPrefix("ns", "http://host/ns") ;
-		pmapExpected.setNsPrefix("ns1", "http://host/ns1") ;
-		pmapExpected.setNsPrefix("indirectx", "urn:x:") ;
-		//print("Expected:", pmapExpected) ;
-		//print("Got:", pmap) ;
+        pmapExpected.setNsPrefix("", "http://example/") ;
+        pmapExpected.setNsPrefix("ex", "http://example/ex#") ;
+        pmapExpected.setNsPrefix("indirect", "urn:foo:") ;
+        pmapExpected.setNsPrefix("ns", "http://host/ns") ;
+        pmapExpected.setNsPrefix("ns1", "http://host/ns1") ;
+        pmapExpected.setNsPrefix("indirectx", "urn:x:") ;
+        //print("Expected:", pmapExpected) ;
+        //print("Got:", pmap) ;
+        Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;
+        Assert.assertTrue(pmap.getNsPrefixURI("notinuse") == null) ;
+    }
+
+    @Test public void prefixesTTL1() {
+        // All prefixes used.
+        // Note: XSD as well.
+        String data1 = StrUtils.strjoinNL
+            ("@prefix : <http://example/> ." ,
+             "@prefix ex: <http://example/ex#> ." ,
+             "@prefix xsd: <"+XSD.getURI()+"> .",
+             "" ,
+             ":s1 :p :x1 ." ,
+             ":s1 ex:p :x1 .",
+             ":s1 ex:p 1 ."
+             ) ;
+        Graph graph1 = create(data1) ;
+        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMappingTTL(graph1) ;
+        PrefixMapping pmapExpected = graph1.getPrefixMapping() ;
+        Assert.assertEquals(3, size(pmap)) ;
+        Assert.assertEquals(pmapExpected, pmap) ; 
+    }
+    
+    @Test public void prefixesTTL2() {
+        // Some prefixes used
+        String data2 = StrUtils.strjoinNL
+            ("@prefix : <http://example/> ." ,
+             "@prefix ex: <http://example/ex#> ." ,
+             "@prefix notinuse: <http://example/whatever/> ." ,
+             "" ,
+             ":s1 :p :x1 ." ,
+             ":s1 ex:p :x1 ."
+             ) ;
+        
+        Graph graph1 = create(data2) ;
+        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMappingTTL(graph1) ;
+        PrefixMapping pmapExpected = new PrefixMappingImpl() ;
+        pmapExpected.setNsPrefix("", "http://example/") ;
+        pmapExpected.setNsPrefix("ex", "http://example/ex#") ;
+        Assert.assertEquals(2, size(pmap)) ;
+        Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;
+        Assert.assertTrue(pmap.getNsPrefixURI("notinuse") == null) ;
+    }
+
+    @Test public void prefixesTTL3() {
+        // Some URIs without prefixes.
+        String data = StrUtils.strjoinNL
+            ("@prefix : <http://example/> ." ,
+             "" ,
+             "<http://other/s1> :p :x1 ."
+             ) ;
+        Graph graph1 = create(data) ;
+        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMappingTTL(graph1) ;
+        PrefixMapping pmapExpected = new PrefixMappingImpl() ;
+        pmapExpected.setNsPrefix("", "http://example/") ;
+        Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;
+    }
+    
+    @Test public void prefixesTTL4() {
+        // No prefixes.
+        String data = StrUtils.strjoinNL
+            (
+             "<http://other/s1> <http://example/p> 123 ."
+             ) ;
+        Graph graph1 = create(data) ;
+        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMappingTTL(graph1) ;
+        Assert.assertEquals(0, size(pmap)) ;
+        PrefixMapping pmapExpected = new PrefixMappingImpl() ;
+        Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;
+    }
+    
+    // No <<>> parser in jena-core.
+    @Test public void prefixesTTL() {
+        // All combinations.
+        // No "@prefix xsd: <"+XSD.getURI()+"> ." so not in output.
+        String data = StrUtils.strjoinNL
+            ("@prefix : <http://example/> ." ,
+             "@prefix ex: <http://example/ex#> ." ,
+             "@prefix notinuse: <http://example/whatever/> ." ,
+             "@prefix indirect: <urn:foo:> ." ,
+             "@prefix indirectx: <urn:x:> ." ,
+
+             "@prefix ns: <http://host/ns> ." ,
+             "@prefix ns1: <http://host/ns1> ." ,
+             "@prefix ns2: <http://host/nspace> ." ,
+             "" ,
+             ":s1 :p :x1 ." ,
+             ":s1 ex:p :x1 ." ,
+
+             "<urn:foo:bar> :p 1 . ",
+             "<urn:x:a:b> :p 2 . ",
+
+             "<urn:verybad#.> :p 1 . ",
+
+             "ns:x ns1:p 'ns1' . ",
+
+             "<http://examp/abberev> indirect:p 'foo' . "
+             ) ;
+        
+        Graph graph = create(data) ;
+        
+        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMappingTTL(graph) ;
+        PrefixMapping pmapExpected = new PrefixMappingImpl() ;
+        pmapExpected.setNsPrefix("", "http://example/") ;
+        pmapExpected.setNsPrefix("ex", "http://example/ex#") ;
+        pmapExpected.setNsPrefix("indirect", "urn:foo:") ;
+        // No : not a / or # split          :: pmapExpected.setNsPrefix("ns", "http://host/ns") ;
+        // No : not a / or # split          :: pmapExpected.setNsPrefix("ns1", "http://host/ns1") ;
+        // No : not a match: split is wrong :: pmapExpected.setNsPrefix("indirectx", "urn:x:") ;
+//        print("Expected:", pmapExpected) ;
+//        print("Got:", pmap) ;
         Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;
         Assert.assertTrue(pmap.getNsPrefixURI("notinuse") == null) ;
     }
