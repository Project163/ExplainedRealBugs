diff --git a/jena-core/src/main/resources/etc/owl-fb-mini.rules b/jena-core/src/main/resources/etc/owl-fb-mini.rules
index 7ddef6816f..786e89ef52 100644
--- a/jena-core/src/main/resources/etc/owl-fb-mini.rules
+++ b/jena-core/src/main/resources/etc/owl-fb-mini.rules
@@ -34,7 +34,7 @@
 -> (rdf:predicate  rdf:type  rdf:Property).
 -> (rdf:first      rdf:type  rdf:Property).
 -> (rdf:rest       rdf:type  rdf:Property).
-        
+
 -> (rdfs:subPropertyOf rdfs:domain rdf:Property).
 -> (rdfs:subClassOf rdfs:domain rdfs:Class).
 -> (rdfs:domain rdfs:domain rdf:Property).
@@ -72,18 +72,18 @@
 #[rdf1and4: (?x ?p ?y) -> (?p rdf:type rdf:Property), (?x rdf:type rdfs:Resource), (?y rdf:type rdfs:Resource)]
 [rdf4: (?x ?p ?y) -> (?p rdf:type rdf:Property)]
 
-[rdfs7b: (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf rdfs:Resource)] 
+[rdfs7b: (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf rdfs:Resource)]
 
-[rdfs2:  (?p rdfs:domain ?c) -> [(?x rdf:type ?c) <- (?x ?p ?y)] ] 
-[rdfs3:  (?p rdfs:range ?c)  -> [(?y rdf:type ?c) <- (?x ?p ?y), notFunctor(?y)] ] 
-[rdfs5a: (?a rdfs:subPropertyOf ?b), (?b rdfs:subPropertyOf ?c) -> (?a rdfs:subPropertyOf ?c)] 
-#[rdfs5b: (?a rdf:type rdf:Property) -> (?a rdfs:subPropertyOf ?a)] 
-[rdfs5b: (?a rdfs:subPropertyOf ?a) <- (?a rdf:type rdf:Property)] 
-[rdfs6:  (?p rdfs:subPropertyOf ?q), notEqual(?p,?q) -> [ (?a ?q ?b) <- (?a ?p ?b)] ] 
+[rdfs2:  (?p rdfs:domain ?c) -> [(?x rdf:type ?c) <- (?x ?p ?y)] ]
+[rdfs3:  (?p rdfs:range ?c)  -> [(?y rdf:type ?c) <- (?x ?p ?y), notFunctor(?y)] ]
+[rdfs5a: (?a rdfs:subPropertyOf ?b), (?b rdfs:subPropertyOf ?c) -> (?a rdfs:subPropertyOf ?c)]
+#[rdfs5b: (?a rdf:type rdf:Property) -> (?a rdfs:subPropertyOf ?a)]
+[rdfs5b: (?a rdfs:subPropertyOf ?a) <- (?a rdf:type rdf:Property)]
+[rdfs6:  (?p rdfs:subPropertyOf ?q), notEqual(?p,?q) -> [ (?a ?q ?b) <- (?a ?p ?b)] ]
 [rdfs7:  (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf ?a)]
-# omit rdfs8, derivable from rdfs9 and prototype2 
-[rdfs9:  (?x rdfs:subClassOf ?y), notEqual(?x,?y) -> [ (?a rdf:type ?y) <- (?a rdf:type ?x)] ] 
-[rdfs10: (?x rdf:type rdfs:ContainerMembershipProperty) -> (?x rdfs:subPropertyOf rdfs:member)] 
+# omit rdfs8, derivable from rdfs9 and prototype2
+[rdfs9:  (?x rdfs:subClassOf ?y), notEqual(?x,?y) -> [ (?a rdf:type ?y) <- (?a rdf:type ?x)] ]
+[rdfs10: (?x rdf:type rdfs:ContainerMembershipProperty) -> (?x rdfs:subPropertyOf rdfs:member)]
 
 [rdfs2-partial: (?p rdfs:domain ?c) -> (?c rdf:type rdfs:Class)]
 [rdfs3-partial: (?p rdfs:range ?c)  -> (?c rdf:type rdfs:Class)]
@@ -199,54 +199,54 @@
 [earlyTypeProp3: (?C rdf:type owl:Class) -> (?C rdf:type rdfs:Class) ]
 
 [prototype1: (?c rdf:type owl:Class), noValue(?c, rb:prototype), notEqual(?c, owl:Nothing), makeTemp(?t), hide(?t)
-  	    				-> (?c rb:prototype ?t), (?t rdf:type ?c) ]
-    
+                -> (?c rb:prototype ?t), (?t rdf:type ?c) ]
+
 [prototype2: (?c rb:prototype ?p) ->
-                [prototype2b: (?c rdfs:subClassOf ?d) <- (?p rdf:type ?d)] ]                
+                [prototype2b: (?c rdfs:subClassOf ?d) <- (?p rdf:type ?d)] ]
 
 #------------------------------------------------------------------
 # Identify restriction assertions
 #------------------------------------------------------------------
 
 [restriction1: (?C owl:onProperty ?P), (?C owl:someValuesFrom ?D)
-	-> (?C owl:equivalentClass some(?P, ?D))]
-		
+  -> (?C owl:equivalentClass some(?P, ?D))]
+
 [restriction2: (?C owl:onProperty ?P), (?C owl:allValuesFrom ?D)
-	-> (?C owl:equivalentClass all(?P, ?D))]
-		
+  -> (?C owl:equivalentClass all(?P, ?D))]
+
 [restriction3: (?C owl:onProperty ?P), (?C owl:minCardinality ?X)
-	-> (?C owl:equivalentClass min(?P, ?X))]
-		
+  -> (?C owl:equivalentClass min(?P, ?X))]
+
 [restriction4: (?C owl:onProperty ?P), (?C owl:maxCardinality ?X)
-	-> (?C owl:equivalentClass max(?P, ?X)) ]
-		
+  -> (?C owl:equivalentClass max(?P, ?X)) ]
+
 [restriction5: (?C owl:onProperty ?P), (?C owl:cardinality ?X)
-	-> (?C owl:equivalentClass card(?P, ?X)), 
-	   (?C rdfs:subClassOf min(?P, ?X)), 
-	   (?C rdfs:subClassOf max(?P, ?X)) ]
-		
-[restriction6: (?C rdfs:subClassOf min(?P, ?X)), (?C rdfs:subClassOf max(?P, ?X)) 
-       					-> (?C rdfs:subClassOf card(?P, ?X))]
+  -> (?C owl:equivalentClass card(?P, ?X)),
+     (?C rdfs:subClassOf min(?P, ?X)),
+     (?C rdfs:subClassOf max(?P, ?X)) ]
+
+[restriction6: (?C rdfs:subClassOf min(?P, ?X)), (?C rdfs:subClassOf max(?P, ?X))
+                 -> (?C rdfs:subClassOf card(?P, ?X))]
 
 # Could limit the work done here by inserting an isFunctor guard?
-[restrictionPropagate1: (?C owl:equivalentClass ?R), (?D rdfs:subClassOf ?C) 
+[restrictionPropagate1: (?C owl:equivalentClass ?R), (?D rdfs:subClassOf ?C)
                                 -> (?D rdfs:subClassOf ?R) ]
-[restrictionPropagate2: (?C owl:equivalentClass ?R), (?D owl:equivalentClass ?C) 
+[restrictionPropagate2: (?C owl:equivalentClass ?R), (?D owl:equivalentClass ?C)
                                 -> (?D owl:equivalentClass ?R) ]
 
-# Needed for the case where ?R is a restriction literal 
+# Needed for the case where ?R is a restriction literal
 # and so does not appear in the subject position
 [restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) ->
        [restrictionSubclass1b: (?X rdf:type ?D) <- (?X rdf:type ?R)] ]
- 
-# This is redundant because equivalentClass is symmetric anyway      
+
+# This is redundant because equivalentClass is symmetric anyway
 #[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) ->
 #       [restrictionSubclass2b: (?X rdf:type ?R) <- (?X rdf:type ?D)] ]
-       
-# Temp trial - might replace above       
+
+# Temp trial - might replace above
 #[restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?R) -> (?X rdf:type ?D)]
 #[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?D) -> (?X rdf:type ?R)]
-						
+
 #------------------------------------------------------------------
 # min cardinality
 #------------------------------------------------------------------
@@ -254,9 +254,9 @@
 [minRec: (?C owl:equivalentClass min(?P, 1)), notEqual(?P, rdf:type) ->
     [min2b: (?X rdf:type ?C) <- (?X ?P ?Y)] ]
 
-[restriction-inter-MnS: (?P rdfs:range ?D), (?C rdfs:subClassOf min(?P, 1)) 
-						-> (?C rdfs:subClassOf some(?P, ?D)) ]
-        
+[restriction-inter-MnS: (?P rdfs:range ?D), (?C rdfs:subClassOf min(?P, 1))
+            -> (?C rdfs:subClassOf some(?P, ?D)) ]
+
 #------------------------------------------------------------------
 # max cardinality 1
 #------------------------------------------------------------------
@@ -266,7 +266,7 @@
 #    [max1b: (?Y1 owl:sameAs ?Y2) <- bound(?Y1),   (?X ?P ?Y1), (?X rdf:type ?C), (?X ?P ?Y2), notEqual(?Y1, ?Y2)]
 #    [max1b: (?Y1 owl:sameAs ?Y2) <- unbound(?Y1), (?X ?P ?Y2), (?X rdf:type ?C), (?X ?P ?Y1), notEqual(?Y1, ?Y2)]
 #    ]
-    
+
 [maxRec: (?C owl:equivalentClass max(?P, 1)), (?P rdf:type owl:FunctionalProperty) ->
     [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]
 
@@ -276,13 +276,13 @@
 
 # For completeness this requires iff version of rdfs:domain working forwards which it does not just now
 [maxRec2: (?C owl:equivalentClass max(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
-	-> (?E owl:equivalentClass ?C)]
-	
+    -> (?E rdfs:subClassOf ?C)]
+
 [cardRec1: (?C owl:equivalentClass card(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
-	-> (?E owl:equivalentClass ?C)]
-	
+    -> (?E rdfs:subClassOf ?C)]
+
 [cardRec3: (?C owl:equivalentClass card(?P, 0)) ->
-	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type max(?P, 0))] ]
+  [cardRec2b: (?X rdf:type ?C) <- (?X rdf:type max(?P, 0))] ]
 
 #------------------------------------------------------------------
 # cardinality 1
@@ -292,7 +292,7 @@
      (?C owl:equivalentClass min(?P, 1)) ]
 
 [cardRec2: (?C owl:equivalentClass card(?P, 1)) ->
-	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type min(?P, 1)), (?X rdf:type max(?P, 1)) ] ]
+  [cardRec2b: (?X rdf:type ?C) <- (?X rdf:type min(?P, 1)), (?X rdf:type max(?P, 1)) ] ]
 
 #------------------------------------------------------------------
 # someValuesFrom
@@ -300,69 +300,69 @@
 
 #[someRec: (?C owl:equivalentClass some(?P, ?D)), (?P rdfs:range ?D) ->
 #     [someRecb: (?X rdf:type ?C) <- (?X ?P ?A) ] ]
-    
+
 [someRec2: (?C owl:equivalentClass some(?P, ?D)) ->
      [someRec2b: (?X rdf:type ?C) <- (?X ?P ?A) (?A rdf:type ?D) ] ]
-    
+
 [someRec2b: (?C owl:equivalentClass some(?P, ?D)), (?D rdf:type rdfs:Datatype)->
      [someRec2b: (?X rdf:type ?C) <- (?X ?P ?A), isDType(?A, ?D) ] ]
-    
+
 #------------------------------------------------------------------
 # allValuesFrom
 #------------------------------------------------------------------
 
 [all1: (?C rdfs:subClassOf all(?P, ?D)), notEqual(?P, rdf:type), notEqual(?C, ?D) ->
-		[all1b: (?Y rdf:type ?D) <- (?X ?P ?Y), (?X rdf:type ?C) ] ]
+    [all1b: (?Y rdf:type ?D) <- (?X ?P ?Y), (?X rdf:type ?C) ] ]
 
 [allRec1: (?C rdfs:subClassOf max(?P, 1)), (?C rdfs:subClassOf some(?P, ?D))
-						-> (?C rdfs:subClassOf all(?P, ?D)) ]
+            -> (?C rdfs:subClassOf all(?P, ?D)) ]
 
 [allRec2: (?P rdf:type owl:FunctionalProperty), (?C rdfs:subClassOf some(?P, ?C))
-						 -> (?C rdfs:subClassOf all(?P, ?C)) ]
-    
+             -> (?C rdfs:subClassOf all(?P, ?C)) ]
+
 [allRec3: (?C owl:equivalentClass all(?P, ?D)), (?P rdfs:range ?D) ->
     [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]
 
 [allRec4: (?P rdf:type owl:FunctionalProperty), (?C owl:equivalentClass all(?P, ?D))
                          -> [ (?X rdf:type ?C) <- (?X ?P ?Y) (?Y rdf:type ?D) ] ]
-    
+
 [allRec5: (?C rdfs:subClassOf max(?P, 1)) (?C owl:equivalentClass all(?P, ?D))
                          -> [ (?X rdf:type ?C) <- (?X ?P ?Y) (?Y rdf:type ?D) ] ]
-    
-[restriction-inter-RA-T: (?P rdfs:range ?C), (?D owl:equivalentClass all(?P, ?C)) 
-						-> (owl:Thing rdfs:subClassOf ?D) ]
-						
-[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf all(?P, ?C)) 
-						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
+
+[restriction-inter-RA-T: (?P rdfs:range ?C), (?D owl:equivalentClass all(?P, ?C))
+            -> (owl:Thing rdfs:subClassOf ?D) ]
+
+[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf all(?P, ?C))
+            -> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
 
 # This version looks strange but we are experimenting with droping the direct
 # subclass transitive closure and inferring from prototypes, but that is being
 # done backwards for forwards subclass relationships are handled as special cases
-#[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf ?D) (?D owl:equivalentClass all(?P, ?C)) 
+#[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf ?D) (?D owl:equivalentClass all(?P, ?C))
 #						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
-    
+
 #------------------------------------------------------------------
 # Nothing
 #------------------------------------------------------------------
-    
+
 [nothing1: (?C rdfs:subClassOf min(?P, ?n)) (?C rdfs:subClassOf max(?P, ?x))
            lessThan(?x, ?n)  ->  (?C owl:equivalentClass owl:Nothing) ]
-           
+
 [nothing2: (?C rdfs:subClassOf ?D) (?C rdfs:subClassOf ?E) (?D owl:disjointWith ?E)
            ->  (?C owl:equivalentClass owl:Nothing) ]
-           
+
 [nothing3: (?C rdfs:subClassOf owl:Nothing) ->  (?C owl:equivalentClass owl:Nothing) ]
 
 [nothing4: (?C owl:oneOf rdf:nil) -> (?C owl:equivalentClass owl:Nothing) ]
-           
+
 #------------------------------------------------------------------
 # Disjointness
 #------------------------------------------------------------------
 
-#[distinct1: (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D) 
+#[distinct1: (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D)
 #						-> (?X owl:differentFrom ?Y) ]
 
-[distinct1: (?X owl:differentFrom ?Y) <- 
+[distinct1: (?X owl:differentFrom ?Y) <-
     (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D)   ]
 
 # Exploding the pairwise assertions is simply done procedurally here.
@@ -374,14 +374,14 @@
 #------------------------------------------------------------------
 
 # equivalentClass
-[equivalentClass1: (?P owl:equivalentClass ?Q) 
-						-> (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
-						
+[equivalentClass1: (?P owl:equivalentClass ?Q)
+            -> (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
+
 [equivalentClass2: (?P owl:equivalentClass ?Q) <-  (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
-						
-[equivalentClass3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Class), (?Q rdf:type rdfs:Class) 
-						-> (?P owl:equivalentClass ?Q) ]
-						
+
+[equivalentClass3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Class), (?Q rdf:type rdfs:Class)
+            -> (?P owl:equivalentClass ?Q) ]
+
 #------------------------------------------------------------------
 # Instance equality
 #------------------------------------------------------------------
@@ -389,17 +389,17 @@
 # sameAs
 
 #[sameAs1: (?P rdf:type owl:FunctionalProperty) ->
-#      [sameAs1b: (?B owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?A ?P ?C) ] 
-#      [sameAs1b: (?B owl:sameAs ?C) <-   bound(?C), (?A ?P ?C), (?A ?P ?B) ] 
+#      [sameAs1b: (?B owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?A ?P ?C) ]
+#      [sameAs1b: (?B owl:sameAs ?C) <-   bound(?C), (?A ?P ?C), (?A ?P ?B) ]
 #      ]
-#                    
-#[sameAs2: (?P rdf:type owl:InverseFunctionalProperty) -> 
-#      [sameAs2b: (?A owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?C ?P ?B) ] 
-#      [sameAs2b: (?A owl:sameAs ?C) <-   bound(?C), (?C ?P ?B), (?A ?P ?B) ] 
+#
+#[sameAs2: (?P rdf:type owl:InverseFunctionalProperty) ->
+#      [sameAs2b: (?A owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?C ?P ?B) ]
+#      [sameAs2b: (?A owl:sameAs ?C) <-   bound(?C), (?C ?P ?B), (?A ?P ?B) ]
 #      ]
-#      
-##[sameAs3: (?X owl:sameAs ?Y), (?X rdf:type owl:Thing), (?Y rdf:type owl:Thing) 
-##                    -> (?X owl:sameAs ?Y) ]                    
+#
+##[sameAs3: (?X owl:sameAs ?Y), (?X rdf:type owl:Thing), (?Y rdf:type owl:Thing)
+##                    -> (?X owl:sameAs ?Y) ]
 #
 #[sameAs4a: (?Y ?P ?V) <- unbound(?V), (?X owl:sameAs ?Y), notEqual(?X,?Y), (?X ?P ?V) ]
 #[sameAs4c: (?Y ?P ?V) <- bound(?V), (?X ?P ?V), notEqual(?X,?Y), (?X owl:sameAs ?Y)  ]
@@ -416,31 +416,31 @@
 # sameAs recognition rules - forward version
 
 [fp1: (?P rdf:type owl:FunctionalProperty), (?A ?P ?B), notLiteral(?B), (?A ?P ?C), notLiteral(?C)
-					notEqual(?B, ?C) -> (?B owl:sameAs ?C) ]
+          notEqual(?B, ?C) -> (?B owl:sameAs ?C) ]
 
-[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?P ?B) 
-					notEqual(?A, ?C) -> (?A owl:sameAs ?C) ]
+[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?P ?B)
+          notEqual(?A, ?C) -> (?A owl:sameAs ?C) ]
 
 [fp1: (?P rdf:type owl:FunctionalProperty), (?A ?P ?B), notLiteral(?B), (?A ?Q ?C), notLiteral(?C),
-					notEqual(?B, ?C), (?Q rdfs:subPropertyOf ?P) -> (?B owl:sameAs ?C) ]
+          notEqual(?B, ?C), (?Q rdfs:subPropertyOf ?P) -> (?B owl:sameAs ?C) ]
+
+[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?Q ?B)
+          notEqual(?A, ?C), (?Q rdfs:subPropertyOf ?P)  -> (?A owl:sameAs ?C) ]
+
+[fpEarlyProp: (?P rdf:type owl:FunctionalProperty) (?Q rdfs:subPropertyOf ?P) ->
+          (?Q rdf:type owl:FunctionalProperty) ]
 
-[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?Q ?B) 
-					notEqual(?A, ?C), (?Q rdfs:subPropertyOf ?P)  -> (?A owl:sameAs ?C) ]
+[ifpEarlyProp: (?P rdf:type owl:InverseFunctionalProperty) (?Q rdfs:subPropertyOf ?P) ->
+          (?Q rdf:type owl:InverseFunctionalProperty) ]
 
-[fpEarlyProp: (?P rdf:type owl:FunctionalProperty) (?Q rdfs:subPropertyOf ?P) -> 
-					(?Q rdf:type owl:FunctionalProperty) ]
-					
-[ifpEarlyProp: (?P rdf:type owl:InverseFunctionalProperty) (?Q rdfs:subPropertyOf ?P) -> 
-					(?Q rdf:type owl:InverseFunctionalProperty) ]
-					
 # This rule is not sufficient if the type inference is being done backwards
 [max1: (?C rdfs:subClassOf max(?P, 1)), (?X ?P ?Y1), notLiteral(?Y1), (?X rdf:type ?C), (?X ?P ?Y2), notLiteral(?Y2),
-					notEqual(?Y1, ?Y2) -> (?Y1 owl:sameAs ?Y2) ]					
+          notEqual(?Y1, ?Y2) -> (?Y1 owl:sameAs ?Y2) ]
 
 # Subclass inheritance not normally availabe forward which causes problems for max1,
 # patch this but just for restrictions to limit costs
 [subClassTemp: (?C rdfs:subClassOf ?R), isFunctor(?R), (?B rdfs:subClassOf ?C) -> (?B rdfs:subClassOf ?R) ]
-					
+
 # sameAs propagation rules - forward version
 
 [sameAs1: (?A owl:sameAs ?B) -> (?B owl:sameAs ?A) ]
@@ -458,31 +458,31 @@
 # Equality processing rules
 
 [equality1: (?X owl:sameAs ?Y), notEqual(?X,?Y) ->
-		[(?X ?P ?V) <- (?Y ?P ?V)]
-		[(?V ?P ?X) <- (?V ?P ?Y)] ]
+    [(?X ?P ?V) <- (?Y ?P ?V)]
+    [(?V ?P ?X) <- (?V ?P ?Y)] ]
 
 [equality2: (?X owl:sameAs ?Y), (?X rdf:type owl:Class) -> (?X owl:equivalentClass ?Y) ]
 
 [equality3: (?X owl:sameAs ?Y), (?X rdf:type rdf:Property) -> (?X owl:equivalentProperty ?Y) ]
-		
+
 #------------------------------------------------------------------
 # Property rules
 #------------------------------------------------------------------
 
-# EquivalentProperty 
+# EquivalentProperty
+
+[equivalentProperty1: (?P owl:equivalentProperty ?Q)
+            -> (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) ]
 
-[equivalentProperty1: (?P owl:equivalentProperty ?Q) 
-						-> (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) ]
-						
-[equivalentProperty2: (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) 
-						-> (?P owl:equivalentProperty ?Q) ]
-						
-[equivalentProperty3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Property), (?Q rdf:type rdfs:Property) 
-						-> (?P owl:equivalentProperty ?Q) ]
+[equivalentProperty2: (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P)
+            -> (?P owl:equivalentProperty ?Q) ]
+
+[equivalentProperty3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Property), (?Q rdf:type rdfs:Property)
+            -> (?P owl:equivalentProperty ?Q) ]
 
 # SymmetricProperty
 
-[symmetricProperty1: (?P rdf:type owl:SymmetricProperty) -> 
+[symmetricProperty1: (?P rdf:type owl:SymmetricProperty) ->
                      [symmetricProperty1b: (?X ?P ?Y) <- (?Y ?P ?X)] ]
 
 
@@ -491,11 +491,11 @@
 
 [inverseOf2: (?P owl:inverseOf ?Q) -> [inverseOf2b: (?X ?P ?Y) <- (?Y ?Q ?X)] ]
 
-[inverseOf3: (?P owl:inverseOf ?Q), (?P rdf:type owl:FunctionalProperty) 
-						-> (?Q rdf:type owl:InverseFunctionalProperty) ]
-		
-[inverseOf4: (?P owl:inverseOf ?Q), (?P rdf:type owl:InverseFunctionalProperty) 
-						-> (?Q rdf:type owl:FunctionalProperty) ]
+[inverseOf3: (?P owl:inverseOf ?Q), (?P rdf:type owl:FunctionalProperty)
+            -> (?Q rdf:type owl:InverseFunctionalProperty) ]
+
+[inverseOf4: (?P owl:inverseOf ?Q), (?P rdf:type owl:InverseFunctionalProperty)
+            -> (?Q rdf:type owl:FunctionalProperty) ]
 
 [inverseof5:  (?P owl:inverseOf ?Q) (?P rdfs:range ?C) -> (?Q rdfs:domain ?C)]
 [inverseof6:  (?P owl:inverseOf ?Q) (?P rdfs:domain ?C) -> (?Q rdfs:range ?C)]
@@ -504,52 +504,52 @@
 
 [transitiveProperty1: (?P rdf:type owl:TransitiveProperty) ->
 #			[transitiveProperty1b:  (?A ?P ?C) <- (?A ?P ?B), (?B ?P ?C)] ]
-			[transitiveProperty1b:  (?A ?P ?C) <- bound (?C), (?B ?P ?C), (?A ?P ?B)] 
-			[transitiveProperty1b:  (?A ?P ?C) <- unbound (?C), (?A ?P ?B) (?B ?P ?C)] 
-			]
+      [transitiveProperty1b:  (?A ?P ?C) <- bound (?C), (?B ?P ?C), (?A ?P ?B)]
+      [transitiveProperty1b:  (?A ?P ?C) <- unbound (?C), (?A ?P ?B) (?B ?P ?C)]
+      ]
 
-# Object properties 
+# Object properties
 
 [objectProperty: (?P rdf:type owl:ObjectProperty) ->
-						(?P rdfs:domain owl:Thing) (?P rdfs:range owl:Thing) ]
-						
+            (?P rdfs:domain owl:Thing) (?P rdfs:range owl:Thing) ]
+
 #------------------------------------------------------------------
 # Restricted support for hasValue, even though that is beyond OWL/lite
 #------------------------------------------------------------------
 
 # hasValue
 [hasValueRec: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P), (?C owl:hasValue ?V)
-						-> (?C owl:equivalentClass hasValue(?P, ?V)) ]
-						
-[hasValueIF: (?C owl:equivalentClass hasValue(?P, ?V)) -> 
-								[ (?x ?P ?V) <- (?x rdf:type ?C) ]
-								[ (?x rdf:type ?C) <- (?x ?P ?V) ]
-								]
-
-[hasValueProp: (?P rdf:type owl:FunctionalProperty) (?Q rdf:type owl:FunctionalProperty) 
+            -> (?C owl:equivalentClass hasValue(?P, ?V)) ]
+
+[hasValueIF: (?C owl:equivalentClass hasValue(?P, ?V)) ->
+                [ (?x ?P ?V) <- (?x rdf:type ?C) ]
+                [ (?x rdf:type ?C) <- (?x ?P ?V) ]
+                ]
+
+[hasValueProp: (?P rdf:type owl:FunctionalProperty) (?Q rdf:type owl:FunctionalProperty)
                (?P rdfs:domain ?D) (?Q rdfs:domain ?D)
                (?D owl:equivalentClass hasValue(?P, ?V))
                (?D owl:equivalentClass hasValue(?Q, ?V))
                -> (?P owl:equivalentProperty ?Q)]
-               
+
 
 #------------------------------------------------------------------
 # Restricted support for oneOf, even though that is beyond OWL/lite
 #------------------------------------------------------------------
 
 [oneOfFP: (?P rdfs:range ?C) (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil)
-				-> (?P rdf:type owl:FunctionalProperty) ]
-				
+        -> (?P rdf:type owl:FunctionalProperty) ]
+
 [oneOfIFP: (?P rdfs:domain ?C) (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil)
-				-> (?P rdf:type owl:InverseFunctionalProperty) ]
+        -> (?P rdf:type owl:InverseFunctionalProperty) ]
 
 [oneOf1: (?C owl:oneOf ?l) -> listMapAsSubject(?l, rdf:type, ?C) ]
-				
+
 [oneOf2: (?C owl:oneOf ?l1) (?D owl:oneOf ?l2) notEqual(?l1, ?l2) listEqual(?l1, ?l2) -> (?C owl:equivalentClass ?D) ]
 
 [oneOf3: (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil) 	->
-				[ (?Y ?P ?x)  <- (?Y ?P ?I) (?I rdf:type ?C)  ] ]
-					
+        [ (?Y ?P ?x)  <- (?Y ?P ?I) (?I rdf:type ?C)  ] ]
+
 #------------------------------------------------------------------
 # Declaration of main XSD datatypes
 #------------------------------------------------------------------
@@ -618,7 +618,7 @@
 -> (xsd:int     rb:xsdRange xsd(xsd:integer,1,32)).
 -> (xsd:long    rb:xsdRange xsd(xsd:integer,1,64)).
 -> (xsd:integer rb:xsdRange xsd(xsd:integer,1,65)).
-							
+
 -> (xsd:unsignedByte    rb:xsdRange xsd(xsd:integer,0,8)).
 -> (xsd:unsignedShort   rb:xsdRange xsd(xsd:integer,0,16)).
 -> (xsd:unsignedInt     rb:xsdRange xsd(xsd:integer,0,32)).
@@ -627,17 +627,17 @@
 
 # Some XSD support may be disabled temporarily during performance checking
 
-[xsd1: (?X rdfs:subClassOf ?Y) <- 
+[xsd1: (?X rdfs:subClassOf ?Y) <-
         (?X rb:xsdRange xsd(?B, 0, ?L)) (?Y rb:xsdRange xsd(?B, ?S, ?L2)) le(?L, ?L2)]
 
-[xsd2: (?X rdfs:subClassOf ?Y) <- 
+[xsd2: (?X rdfs:subClassOf ?Y) <-
         (?X rb:xsdRange xsd(?B, 1, ?L)) (?Y rb:xsdRange xsd(?B, 1, ?L2)) le(?L, ?L2)]
 
 [range2: (?P rdfs:range xsd:byte) <- (?P rdfs:range xsd:nonNegativeInteger),
-					(?P rdfs:range xsd:nonPositiveInteger)]
+          (?P rdfs:range xsd:nonPositiveInteger)]
 
-[range3: (?P rdfs:range owl:Nothing) <- (?P rdfs:range ?C), (?P rdfs:range ?D), notEqual(?C, ?D) 
-							 (?C owl:disjointWith ?D) ]
+[range3: (?P rdfs:range owl:Nothing) <- (?P rdfs:range ?C), (?P rdfs:range ?D), notEqual(?C, ?D)
+               (?C owl:disjointWith ?D) ]
 
 [xsd3: (?C owl:disjointWith ?D) <- (?C rb:xsdBase ?BC), (?D rb:xsdBase ?BD), notEqual(?BC, ?BD) ]
 
@@ -653,80 +653,80 @@
     (?P rb:violation error('inconsistent property definition', 'Property defined with domain which has a max(0) restriction for that property (domain)', ?C) )
 ]
 
-[validationMax0: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 0))  -> 
+[validationMax0: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 0))  ->
     [max2b: (?X rb:violation error('too many values', 'Value for max-0 property (prop, class)', ?P, ?C))
-    			<- (?X rdf:type ?C), (?X ?P ?Y) ] ]
+          <- (?X rdf:type ?C), (?X ?P ?Y) ] ]
 
 [validationMaxN: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, ?N)) ->
     [max2b: (?X rb:violation error('too many values', 'Too many values on max-N property (prop, class)', ?P, ?C))
-    			<- (?X rdf:type ?C), countLiteralValues(?X, ?P, ?M), lessThan(?N, ?M)  ] ]
+          <- (?X rdf:type ?C), countLiteralValues(?X, ?P, ?M), lessThan(?N, ?M)  ] ]
 
 [validationFP: (?v rb:validation on()), (?P rdf:type owl:FunctionalProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing literal values for functional property', ?P, ?V, ?U))
-    			<- (?X ?P ?V), countLiteralValues(?X, ?P, ?M), greaterThan(?M, 1) ] ]
+          <- (?X ?P ?V), countLiteralValues(?X, ?P, ?M), greaterThan(?M, 1) ] ]
 
 [validationMax1I: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 1)) (?P rdf:type owl:ObjectProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing individual  values for card1 property', ?P, ?V, ?U))
-    			<- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U), (?U owl:differentFrom ?V) ] ]
+          <- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U), (?U owl:differentFrom ?V) ] ]
 
 [validationFPI: (?v rb:validation on()), (?P rdf:type owl:FunctionalProperty) (?P rdf:type owl:ObjectProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing individual values for functional property', ?P, ?V, ?U))
-    			<- (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U),  (?U owl:differentFrom ?V) ] ]
+          <- (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U),  (?U owl:differentFrom ?V) ] ]
 
 
 [validationIndiv: (?v rb:validation on())  ->
-	[validationIndiv: (?X rb:violation error('conflict', 'Two individuals both same and different, may be due to disjoint classes or functional properties', ?Y)) 
-				<- (?X owl:differentFrom ?Y), (?X owl:sameAs ?Y), noValue(?T, rb:prototype ?X) ] ]
-				
-[validationIndiv2: (?v rb:validation on()) (?X owl:disjointWith ?Y) -> 
-	[validationIndiv: (?I rb:violation error('conflict', 'Individual a member of disjoint classes', ?X, ?Y)) 
-				<- (?I rdf:type ?X), (?I rdf:type ?Y) noValue(?T rb:prototype ?I)] ]
+  [validationIndiv: (?X rb:violation error('conflict', 'Two individuals both same and different, may be due to disjoint classes or functional properties', ?Y))
+        <- (?X owl:differentFrom ?Y), (?X owl:sameAs ?Y), noValue(?T, rb:prototype ?X) ] ]
+
+[validationIndiv2: (?v rb:validation on()) (?X owl:disjointWith ?Y) ->
+  [validationIndiv: (?I rb:violation error('conflict', 'Individual a member of disjoint classes', ?X, ?Y))
+        <- (?I rdf:type ?X), (?I rdf:type ?Y) noValue(?T rb:prototype ?I)] ]
 
 [validationIndiv3: (?v rb:validation on()) ->
-	[validationIndiv: (?I rb:violation error('conflict', 'Individual a member of Nothing', ?I)) 
-				<- (?I rdf:type owl:Nothing) noValue(?T rb:prototype ?I) ] ]
+  [validationIndiv: (?I rb:violation error('conflict', 'Individual a member of Nothing', ?I))
+        <- (?I rdf:type owl:Nothing) noValue(?T rb:prototype ?I) ] ]
 
 [validationDisjoint: (?v rb:validation on()) (?X owl:disjointWith ?Y)  ->
-	[validationIndiv: (?X rb:violation warn('Inconsistent class', 'Two classes related by both subclass and disjoint relations', ?Y)) 
-				<- (?X owl:disjointWith ?Y), (?X rdfs:subClassOf ?Y) ] ]
+  [validationIndiv: (?X rb:violation warn('Inconsistent class', 'Two classes related by both subclass and disjoint relations', ?Y))
+        <- (?X owl:disjointWith ?Y), (?X rdfs:subClassOf ?Y) ] ]
 
 [validationDisjoint2: (?v rb:validation on()) (?X owl:disjointWith ?Y) ->
-	[validationIndiv: (?C rb:violation warn('Inconsistent class', 'subclass of two disjoint classes', ?X, ?Y)) 
-				<- (?X owl:disjointWith ?Y), (?C rdfs:subClassOf ?X) (?C rdfs:subClassOf ?Y) notEqual(?C, owl:Nothing) ] ]
+  [validationIndiv: (?C rb:violation warn('Inconsistent class', 'subclass of two disjoint classes', ?X, ?Y))
+        <- (?X owl:disjointWith ?Y), (?C rdfs:subClassOf ?X) (?C rdfs:subClassOf ?Y) notEqual(?C, owl:Nothing) ] ]
 
 [validationDTP: (?v rb:validation on()), (?P rdf:type owl:DatatypeProperty) ->
-	[validationDTP: (?X rb:violation error('range check', 'Object value for datatype property (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
+  [validationDTP: (?X rb:violation error('range check', 'Object value for datatype property (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
 
 [validationOP: (?v rb:validation on()), (?P rdf:type owl:ObjectProperty) ->
-	[validationDTP: (?X rb:violation warn('range check', 'Literal value for object property (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), isLiteral(?V) ] ]
+  [validationDTP: (?X rb:violation warn('range check', 'Literal value for object property (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), isLiteral(?V) ] ]
 
 [validationDTRange: (?v rb:validation on()), (?P rdfs:range ?R) (?R rdf:type rdfs:Datatype) ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notDType(?V, ?R)  ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notDType(?V, ?R)  ] ]
 
 [validationDTRange: (?v rb:validation on()), (?P rdfs:range rdfs:Literal)  ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range rdsf:Literal (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range rdsf:Literal (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
 
 [validationAllFrom: (?v rb:validation on()), (?C rdfs:subClassOf all(?P, ?R)) (?R rdf:type rdfs:Datatype) ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, ?R) ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, ?R) ] ]
 
-[validationAllFrom: (?v rb:validation on()), (?C owl:equivalentClass all(?P, rdfs:Literal)) -> 
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom rdfs:Literal (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, rdfs:Literal) 
-				 ] ]
+[validationAllFrom: (?v rb:validation on()), (?C owl:equivalentClass all(?P, rdfs:Literal)) ->
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom rdfs:Literal (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, rdfs:Literal)
+         ] ]
 
-[validationNothing: (?v rb:validation on()), (?C owl:equivalentClass owl:Nothing) notEqual(?C, owl:Nothing) -> 
-	(?C rb:violation warn('Inconsistent class', 'Class cannot be instantiated, probably subclass of a disjoint classes or of an empty restriction'))
+[validationNothing: (?v rb:validation on()), (?C owl:equivalentClass owl:Nothing) notEqual(?C, owl:Nothing) ->
+  (?C rb:violation warn('Inconsistent class', 'Class cannot be instantiated, probably subclass of a disjoint classes or of an empty restriction'))
 ]
 
-[validationRangeNothing: (?v rb:validation on()), (?P rdfs:range owl:Nothing) -> 
-	(?C rb:violation warn('Inconsistent property', 'Property cannot be instantiated, probably due to multiple disjoint range declarations'))
+[validationRangeNothing: (?v rb:validation on()), (?P rdfs:range owl:Nothing) ->
+  (?C rb:violation warn('Inconsistent property', 'Property cannot be instantiated, probably due to multiple disjoint range declarations'))
 ]
 
 [validationOneOf: (?v rb:validation on()) (?C owl:oneOf ?L) ->
-	[validationIndiv: (?X rb:violation warn('possible oneof violation', 'Culprit is deduced to be of enumerated type (implicicated class) but is not one of the enumerations\n This may be due to aliasing.', ?Y)) 
-				<- (?X rdf:type ?C), notBNode(?X), listNotContains(?L, ?X) ] ]
+  [validationIndiv: (?X rb:violation warn('possible oneof violation', 'Culprit is deduced to be of enumerated type (implicicated class) but is not one of the enumerations\n This may be due to aliasing.', ?Y))
+        <- (?X rdf:type ?C), notBNode(?X), listNotContains(?L, ?X) ] ]
diff --git a/jena-core/src/main/resources/etc/owl-fb.rules b/jena-core/src/main/resources/etc/owl-fb.rules
index dd756a6b49..af0e672290 100644
--- a/jena-core/src/main/resources/etc/owl-fb.rules
+++ b/jena-core/src/main/resources/etc/owl-fb.rules
@@ -37,7 +37,7 @@
 -> (rdf:predicate  rdf:type  rdf:Property).
 -> (rdf:first      rdf:type  rdf:Property).
 -> (rdf:rest       rdf:type  rdf:Property).
-        
+
 -> (rdfs:subPropertyOf rdfs:domain rdf:Property).
 -> (rdfs:subClassOf rdfs:domain rdfs:Class).
 -> (rdfs:domain rdfs:domain rdf:Property).
@@ -75,18 +75,18 @@
 #[rdf1and4: (?x ?p ?y) -> (?p rdf:type rdf:Property), (?x rdf:type rdfs:Resource), (?y rdf:type rdfs:Resource)]
 [rdf4: (?x ?p ?y) -> (?p rdf:type rdf:Property)]
 
-[rdfs7b: (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf rdfs:Resource)] 
+[rdfs7b: (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf rdfs:Resource)]
 
-[rdfs2:  (?p rdfs:domain ?c) -> [(?x rdf:type ?c) <- (?x ?p ?y)] ] 
-[rdfs3:  (?p rdfs:range ?c)  -> [(?y rdf:type ?c) <- (?x ?p ?y), notFunctor(?y)] ] 
-[rdfs5a: (?a rdfs:subPropertyOf ?b), (?b rdfs:subPropertyOf ?c) -> (?a rdfs:subPropertyOf ?c)] 
-#[rdfs5b: (?a rdf:type rdf:Property) -> (?a rdfs:subPropertyOf ?a)] 
-[rdfs5b: (?a rdfs:subPropertyOf ?a) <- (?a rdf:type rdf:Property)] 
-[rdfs6:  (?p rdfs:subPropertyOf ?q), notEqual(?p,?q) -> [ (?a ?q ?b) <- (?a ?p ?b)] ] 
+[rdfs2:  (?p rdfs:domain ?c) -> [(?x rdf:type ?c) <- (?x ?p ?y)] ]
+[rdfs3:  (?p rdfs:range ?c)  -> [(?y rdf:type ?c) <- (?x ?p ?y), notFunctor(?y)] ]
+[rdfs5a: (?a rdfs:subPropertyOf ?b), (?b rdfs:subPropertyOf ?c) -> (?a rdfs:subPropertyOf ?c)]
+#[rdfs5b: (?a rdf:type rdf:Property) -> (?a rdfs:subPropertyOf ?a)]
+[rdfs5b: (?a rdfs:subPropertyOf ?a) <- (?a rdf:type rdf:Property)]
+[rdfs6:  (?p rdfs:subPropertyOf ?q), notEqual(?p,?q) -> [ (?a ?q ?b) <- (?a ?p ?b)] ]
 [rdfs7:  (?a rdf:type rdfs:Class) -> (?a rdfs:subClassOf ?a)]
-# omit rdfs8, derivable from rdfs9 and prototype2 
-[rdfs9:  (?x rdfs:subClassOf ?y), notEqual(?x,?y) -> [ (?a rdf:type ?y) <- (?a rdf:type ?x)] ] 
-[rdfs10: (?x rdf:type rdfs:ContainerMembershipProperty) -> (?x rdfs:subPropertyOf rdfs:member)] 
+# omit rdfs8, derivable from rdfs9 and prototype2
+[rdfs9:  (?x rdfs:subClassOf ?y), notEqual(?x,?y) -> [ (?a rdf:type ?y) <- (?a rdf:type ?x)] ]
+[rdfs10: (?x rdf:type rdfs:ContainerMembershipProperty) -> (?x rdfs:subPropertyOf rdfs:member)]
 
 [rdfs2-partial: (?p rdfs:domain ?c) -> (?c rdf:type rdfs:Class)]
 [rdfs3-partial: (?p rdfs:range ?c)  -> (?c rdf:type rdfs:Class)]
@@ -194,68 +194,68 @@
 [earlyTypeProp3: (?C rdf:type owl:Class) -> (?C rdf:type rdfs:Class) ]
 
 [prototype1: (?c rdf:type owl:Class), noValue(?c, rb:prototype), notEqual(?c, owl:Nothing), makeTemp(?t), hide(?t)
-  	    				-> (?c rb:prototype ?t), (?t rdf:type ?c) ]
-    
+                -> (?c rb:prototype ?t), (?t rdf:type ?c) ]
+
 [prototype2: (?c rb:prototype ?p) ->
-                [prototype2b: (?c rdfs:subClassOf ?d) <- (?p rdf:type ?d)] ]                
+                [prototype2b: (?c rdfs:subClassOf ?d) <- (?p rdf:type ?d)] ]
 
 #------------------------------------------------------------------
 # Identify restriction assertions
 #------------------------------------------------------------------
 
-[restriction1: (?C owl:onProperty ?P), (?C owl:someValuesFrom ?D) 
+[restriction1: (?C owl:onProperty ?P), (?C owl:someValuesFrom ?D)
     -> (?C owl:equivalentClass some(?P, ?D))]
-		
+
 [restriction2: (?C owl:onProperty ?P), (?C owl:allValuesFrom ?D)
-	-> (?C owl:equivalentClass all(?P, ?D))]
-		
+  -> (?C owl:equivalentClass all(?P, ?D))]
+
 [restriction3: (?C owl:onProperty ?P), (?C owl:minCardinality ?X)
-	-> (?C owl:equivalentClass min(?P, ?X))]
-		
+  -> (?C owl:equivalentClass min(?P, ?X))]
+
 [restriction4: (?C owl:onProperty ?P), (?C owl:maxCardinality ?X)
-	-> (?C owl:equivalentClass max(?P, ?X)) ]
-		
+  -> (?C owl:equivalentClass max(?P, ?X)) ]
+
 [restriction5: (?C owl:onProperty ?P), (?C owl:cardinality ?X)
-	-> (?C owl:equivalentClass card(?P, ?X)), 
-	   (?C rdfs:subClassOf min(?P, ?X)), 
-	   (?C rdfs:subClassOf max(?P, ?X)) ]
-		
-[restriction6: (?C rdfs:subClassOf min(?P, ?X)), (?C rdfs:subClassOf max(?P, ?X)) 
+  -> (?C owl:equivalentClass card(?P, ?X)),
+     (?C rdfs:subClassOf min(?P, ?X)),
+     (?C rdfs:subClassOf max(?P, ?X)) ]
+
+[restriction6: (?C rdfs:subClassOf min(?P, ?X)), (?C rdfs:subClassOf max(?P, ?X))
     -> (?C rdfs:subClassOf card(?P, ?X))]
 
 # Could limit the work done here by inserting an isFunctor guard?
-[restrictionPropagate1: (?C owl:equivalentClass ?R), (?D rdfs:subClassOf ?C) 
+[restrictionPropagate1: (?C owl:equivalentClass ?R), (?D rdfs:subClassOf ?C)
                                 -> (?D rdfs:subClassOf ?R) ]
-[restrictionPropagate2: (?C owl:equivalentClass ?R), (?D owl:equivalentClass ?C) 
+[restrictionPropagate2: (?C owl:equivalentClass ?R), (?D owl:equivalentClass ?C)
                                 -> (?D owl:equivalentClass ?R) ]
 
-# Needed for the case where ?R is a restriction literal 
+# Needed for the case where ?R is a restriction literal
 # and so does not appear in the subject position
 [restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) ->
        [restrictionSubclass1b: (?X rdf:type ?D) <- (?X rdf:type ?R)] ]
- 
-# This is redundant because equivalentClass is symmetric anyway      
+
+# This is redundant because equivalentClass is symmetric anyway
 #[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) ->
 #       [restrictionSubclass2b: (?X rdf:type ?R) <- (?X rdf:type ?D)] ]
-       
-# Temp trial - might replace above       
+
+# Temp trial - might replace above
 #[restrictionSubclass1: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?R) -> (?X rdf:type ?D)]
 #[restrictionSubclass2: (?D owl:equivalentClass ?R), isFunctor(?R) , (?X rdf:type ?D) -> (?X rdf:type ?R)]
-						
+
 #------------------------------------------------------------------
 # min cardinality
 #------------------------------------------------------------------
 
-[min: (?C rdfs:subClassOf min(?P, 1)) -> 
-    [min1b: (?X ?P ?T) <- (?X rdf:type ?C), noValue(?X, ?P), makeInstance(?X, ?P, ?T)] 
+[min: (?C rdfs:subClassOf min(?P, 1)) ->
+    [min1b: (?X ?P ?T) <- (?X rdf:type ?C), noValue(?X, ?P), makeInstance(?X, ?P, ?T)]
     ]
 
 [minRec: (?C owl:equivalentClass min(?P, 1)), notEqual(?P, rdf:type) ->
     [min2b: (?X rdf:type ?C) <- (?X ?P ?Y)] ]
 
-[restriction-inter-MnS: (?P rdfs:range ?D), (?C rdfs:subClassOf min(?P, 1)) 
-						-> (?C rdfs:subClassOf some(?P, ?D)) ]
-        
+[restriction-inter-MnS: (?P rdfs:range ?D), (?C rdfs:subClassOf min(?P, 1))
+            -> (?C rdfs:subClassOf some(?P, ?D)) ]
+
 #------------------------------------------------------------------
 # max cardinality 1
 #------------------------------------------------------------------
@@ -265,7 +265,7 @@
 #    [max1b: (?Y1 owl:sameAs ?Y2) <- bound(?Y1),   (?X ?P ?Y1), (?X rdf:type ?C), (?X ?P ?Y2), notEqual(?Y1, ?Y2)]
 #    [max1b: (?Y1 owl:sameAs ?Y2) <- unbound(?Y1), (?X ?P ?Y2), (?X rdf:type ?C), (?X ?P ?Y1), notEqual(?Y1, ?Y2)]
 #    ]
-    
+
 [maxRec: (?C owl:equivalentClass max(?P, 1)), (?P rdf:type owl:FunctionalProperty) ->
     [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]
 
@@ -275,13 +275,13 @@
 
 # For completeness this requires iff version of rdfs:domain working forwards which it does not just now
 [maxRec2: (?C owl:equivalentClass max(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
-	-> (?E owl:equivalentClass ?C)]
-	
+    -> (?E rdfs:subClassOf ?C)]
+
 [cardRec1: (?C owl:equivalentClass card(?P, 0)), (?P rdfs:domain ?D), (?E owl:disjointWith ?D)
-	-> (?E owl:equivalentClass ?C)]
-	
+    -> (?E rdfs:subClassOf ?C)]
+
 [cardRec3: (?C owl:equivalentClass card(?P, 0)) ->
-	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type max(?P, 0))] ]
+  [cardRec2b: (?X rdf:type ?C) <- (?X rdf:type max(?P, 0))] ]
 
 #------------------------------------------------------------------
 # cardinality 1
@@ -291,7 +291,7 @@
      (?C owl:equivalentClass min(?P, 1)) ]
 
 [cardRec2: (?C owl:equivalentClass card(?P, 1)) ->
-	[cardRec2b: (?X rdf:type ?C) <- (?X rdf:type min(?P, 1)), (?X rdf:type max(?P, 1)) ] ]
+  [cardRec2b: (?X rdf:type ?C) <- (?X rdf:type min(?P, 1)), (?X rdf:type max(?P, 1)) ] ]
 
 #------------------------------------------------------------------
 # someValuesFrom
@@ -299,64 +299,64 @@
 
 [some1: (?C rdfs:subClassOf some(?P, ?D)), noValue(?D rdfs:subClassOf ?C)
    ->
-    [some1b: (?X ?P ?T) <- (?X rdf:type ?C),  noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
-    [some1b2: (?T rdf:type ?D) <- (?X rdf:type ?C), makeInstance(?X, ?P, ?D, ?T) ] 
-    
-#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
-#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ] 
-#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ] 
-#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ] 
+    [some1b: (?X ?P ?T) <- (?X rdf:type ?C),  noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ]
+    [some1b2: (?T rdf:type ?D) <- (?X rdf:type ?C), makeInstance(?X, ?P, ?D, ?T) ]
+
+#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ]
+#    [some1b: (?X ?P ?T) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ]
+#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), unbound(?T), noValue(?X, ?P), makeInstance(?X, ?P, ?D, ?T) ]
+#    [some1b: (?T rdf:type ?D) <- (?X rdf:type ?C), bound(?T), makeInstance(?X, ?P, ?D, ?T) ]
     ]
 
 # Variant on the normal someValuesFrom rule from the case of recursive restrictions
 # will only handle ground queries to avoid infinite models.
 [some1x: (?C rdfs:subClassOf some(?P, ?D)) (?D rdfs:subClassOf ?C)
    ->
-    [some1b: (?X ?P ?T) <- (?X rdf:type ?C),  noValue(?X, ?P), makeInstance(?X, ?P, ?C, ?T) ] 
-    [some1b2: (?T rdf:type ?C) <- bound(?T) (?X rdf:type ?C), makeInstance(?X, ?P, ?D, ?T) ] 
+    [some1b: (?X ?P ?T) <- (?X rdf:type ?C),  noValue(?X, ?P), makeInstance(?X, ?P, ?C, ?T) ]
+    [some1b2: (?T rdf:type ?C) <- bound(?T) (?X rdf:type ?C), makeInstance(?X, ?P, ?D, ?T) ]
 ]
-    
+
 #[someRec: (?C owl:equivalentClass some(?P, ?D)), (?P rdfs:range ?D) ->
 #     [someRecb: (?X rdf:type ?C) <- (?X ?P ?A) ] ]
-    
+
 [someRec2: (?C owl:equivalentClass some(?P, ?D)) ->
      [someRec2b: (?X rdf:type ?C) <- (?X ?P ?A) (?A rdf:type ?D) ] ]
-    
+
 [someRec2b: (?C owl:equivalentClass some(?P, ?D)), (?D rdf:type rdfs:Datatype)->
      [someRec2b: (?X rdf:type ?C) <- (?X ?P ?A), isDType(?A, ?D) ] ]
-    
+
 #------------------------------------------------------------------
 # allValuesFrom
 #------------------------------------------------------------------
 
 [all1: (?C rdfs:subClassOf all(?P, ?D)), notEqual(?P, rdf:type), notEqual(?C, ?D) ->
-		[all1b: (?Y rdf:type ?D) <- (?X ?P ?Y), (?X rdf:type ?C) ] ]
+    [all1b: (?Y rdf:type ?D) <- (?X ?P ?Y), (?X rdf:type ?C) ] ]
 
 [allRec1: (?C rdfs:subClassOf max(?P, 1)), (?C rdfs:subClassOf some(?P, ?D))
-						-> (?C rdfs:subClassOf all(?P, ?D)) ]
+            -> (?C rdfs:subClassOf all(?P, ?D)) ]
 
 [allRec2: (?P rdf:type owl:FunctionalProperty), (?C rdfs:subClassOf some(?P, ?C))
-						 -> (?C rdfs:subClassOf all(?P, ?C)) ]
-    
+             -> (?C rdfs:subClassOf all(?P, ?C)) ]
+
 [allRec3: (?C owl:equivalentClass all(?P, ?D)), (?P rdfs:range ?D) ->
     [ (?X rdf:type ?C) <- (?X rdf:type owl:Thing)] ]
 
 [allRec4: (?P rdf:type owl:FunctionalProperty), (?C owl:equivalentClass all(?P, ?D))
                          -> [ (?X rdf:type ?C) <- (?X ?P ?Y) (?Y rdf:type ?D) ] ]
-    
+
 [allRec5: (?C rdfs:subClassOf max(?P, 1)) (?C owl:equivalentClass all(?P, ?D))
                          -> [ (?X rdf:type ?C) <- (?X ?P ?Y) (?Y rdf:type ?D) ] ]
-    
-[restriction-inter-RA-T: (?P rdfs:range ?C), (?D owl:equivalentClass all(?P, ?C)) 
-						-> (owl:Thing rdfs:subClassOf ?D) ]
-						
-[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf all(?P, ?C)) 
-						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
+
+[restriction-inter-RA-T: (?P rdfs:range ?C), (?D owl:equivalentClass all(?P, ?C))
+            -> (owl:Thing rdfs:subClassOf ?D) ]
+
+[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf all(?P, ?C))
+            -> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
 
 # This version looks strange but we are experimenting with droping the direct
 # subclass transitive closure and inferring from prototypes, but that is being
 # done backwards for forwards subclass relationships are handled as special cases
-#[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf ?D) (?D owl:equivalentClass all(?P, ?C)) 
+#[restriction-inter-AT-R: (owl:Thing rdfs:subClassOf ?D) (?D owl:equivalentClass all(?P, ?C))
 #						-> (?P rdfs:range ?C), (?P rdf:type owl:ObjectProperty) ]
 
 #------------------------------------------------------------------
@@ -366,29 +366,29 @@
 [unionOf1:  (?C owl:unionOf ?L) -> listMapAsSubject(?L, rdfs:subClassOf ?C) ]
 
 # Note could also add relation between two unionOf's if we add a listSubsumes primitive
-    
+
 #------------------------------------------------------------------
 # Nothing
 #------------------------------------------------------------------
-    
+
 [nothing1: (?C rdfs:subClassOf min(?P, ?n)) (?C rdfs:subClassOf max(?P, ?x))
            lessThan(?x, ?n)  ->  (?C owl:equivalentClass owl:Nothing) ]
-           
+
 [nothing2: (?C rdfs:subClassOf ?D) (?C rdfs:subClassOf ?E) (?D owl:disjointWith ?E)
            ->  (?C owl:equivalentClass owl:Nothing) ]
-           
+
 [nothing3: (?C rdfs:subClassOf owl:Nothing) ->  (?C owl:equivalentClass owl:Nothing) ]
 
 [nothing4: (?C owl:oneOf rdf:nil) -> (?C owl:equivalentClass owl:Nothing) ]
-           
+
 #------------------------------------------------------------------
 # Disjointness
 #------------------------------------------------------------------
 
-#[distinct1: (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D) 
+#[distinct1: (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D)
 #						-> (?X owl:differentFrom ?Y) ]
 
-[distinct1: (?X owl:differentFrom ?Y) <- 
+[distinct1: (?X owl:differentFrom ?Y) <-
     (?C owl:disjointWith ?D), (?X rdf:type ?C), (?Y rdf:type ?D)   ]
 
 # Exploding the pairwise assertions is simply done procedurally here.
@@ -400,14 +400,14 @@
 #------------------------------------------------------------------
 
 # equivalentClass
-[equivalentClass1: (?P owl:equivalentClass ?Q) 
-						-> (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
-						
+[equivalentClass1: (?P owl:equivalentClass ?Q)
+            -> (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
+
 [equivalentClass2: (?P owl:equivalentClass ?Q) <-  (?P rdfs:subClassOf ?Q), (?Q rdfs:subClassOf ?P) ]
-						
-[equivalentClass3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Class), (?Q rdf:type rdfs:Class) 
-						-> (?P owl:equivalentClass ?Q) ]
-						
+
+[equivalentClass3: (?P owl:sameAs ?Q), (?P rdf:type rdfs:Class), (?Q rdf:type rdfs:Class)
+            -> (?P owl:equivalentClass ?Q) ]
+
 #------------------------------------------------------------------
 # Instance equality
 #------------------------------------------------------------------
@@ -415,17 +415,17 @@
 # sameAs
 
 #[sameAs1: (?P rdf:type owl:FunctionalProperty) ->
-#      [sameAs1b: (?B owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?A ?P ?C) ] 
-#      [sameAs1b: (?B owl:sameAs ?C) <-   bound(?C), (?A ?P ?C), (?A ?P ?B) ] 
+#      [sameAs1b: (?B owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?A ?P ?C) ]
+#      [sameAs1b: (?B owl:sameAs ?C) <-   bound(?C), (?A ?P ?C), (?A ?P ?B) ]
 #      ]
-#                    
-#[sameAs2: (?P rdf:type owl:InverseFunctionalProperty) -> 
-#      [sameAs2b: (?A owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?C ?P ?B) ] 
-#      [sameAs2b: (?A owl:sameAs ?C) <-   bound(?C), (?C ?P ?B), (?A ?P ?B) ] 
+#
+#[sameAs2: (?P rdf:type owl:InverseFunctionalProperty) ->
+#      [sameAs2b: (?A owl:sameAs ?C) <- unbound(?C), (?A ?P ?B), (?C ?P ?B) ]
+#      [sameAs2b: (?A owl:sameAs ?C) <-   bound(?C), (?C ?P ?B), (?A ?P ?B) ]
 #      ]
-#      
-##[sameAs3: (?X owl:sameAs ?Y), (?X rdf:type owl:Thing), (?Y rdf:type owl:Thing) 
-##                    -> (?X owl:sameAs ?Y) ]                    
+#
+##[sameAs3: (?X owl:sameAs ?Y), (?X rdf:type owl:Thing), (?Y rdf:type owl:Thing)
+##                    -> (?X owl:sameAs ?Y) ]
 #
 #[sameAs4a: (?Y ?P ?V) <- unbound(?V), (?X owl:sameAs ?Y), notEqual(?X,?Y), (?X ?P ?V) ]
 #[sameAs4c: (?Y ?P ?V) <- bound(?V), (?X ?P ?V), notEqual(?X,?Y), (?X owl:sameAs ?Y)  ]
@@ -442,31 +442,31 @@
 # sameAs recognition rules - forward version
 
 [fp1: (?P rdf:type owl:FunctionalProperty), (?A ?P ?B), notLiteral(?B), (?A ?P ?C), notLiteral(?C)
-					notEqual(?B, ?C) -> (?B owl:sameAs ?C) ]
+          notEqual(?B, ?C) -> (?B owl:sameAs ?C) ]
 
-[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?P ?B) 
-					notEqual(?A, ?C) -> (?A owl:sameAs ?C) ]
+[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?P ?B)
+          notEqual(?A, ?C) -> (?A owl:sameAs ?C) ]
 
 [fp1: (?P rdf:type owl:FunctionalProperty), (?A ?P ?B), notLiteral(?B), (?A ?Q ?C), notLiteral(?C),
-					notEqual(?B, ?C), (?Q rdfs:subPropertyOf ?P) -> (?B owl:sameAs ?C) ]
+          notEqual(?B, ?C), (?Q rdfs:subPropertyOf ?P) -> (?B owl:sameAs ?C) ]
 
-[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?Q ?B) 
-					notEqual(?A, ?C), (?Q rdfs:subPropertyOf ?P)  -> (?A owl:sameAs ?C) ]
+[ifp1: (?P rdf:type owl:InverseFunctionalProperty), (?A ?P ?B), (?C ?Q ?B)
+          notEqual(?A, ?C), (?Q rdfs:subPropertyOf ?P)  -> (?A owl:sameAs ?C) ]
+
+[fpEarlyProp: (?P rdf:type owl:FunctionalProperty) (?Q rdfs:subPropertyOf ?P) ->
+          (?Q rdf:type owl:FunctionalProperty) ]
+
+[ifpEarlyProp: (?P rdf:type owl:InverseFunctionalProperty) (?Q rdfs:subPropertyOf ?P) ->
+          (?Q rdf:type owl:InverseFunctionalProperty) ]
 
-[fpEarlyProp: (?P rdf:type owl:FunctionalProperty) (?Q rdfs:subPropertyOf ?P) -> 
-					(?Q rdf:type owl:FunctionalProperty) ]
-					
-[ifpEarlyProp: (?P rdf:type owl:InverseFunctionalProperty) (?Q rdfs:subPropertyOf ?P) -> 
-					(?Q rdf:type owl:InverseFunctionalProperty) ]
-					
 # This rule is not sufficient if the type inference is being done backwards
 [max1: (?C rdfs:subClassOf max(?P, 1)), (?X ?P ?Y1), notLiteral(?Y1), (?X rdf:type ?C), (?X ?P ?Y2), notLiteral(?Y2),
-					notEqual(?Y1, ?Y2) -> (?Y1 owl:sameAs ?Y2) ]					
+          notEqual(?Y1, ?Y2) -> (?Y1 owl:sameAs ?Y2) ]
 
 # Subclass inheritance not normally availabe forward which causes problems for max1,
 # patch this but just for restrictions to limit costs
 [subClassTemp: (?C rdfs:subClassOf ?R), isFunctor(?R), (?B rdfs:subClassOf ?C) -> (?B rdfs:subClassOf ?R) ]
-					
+
 # sameAs propagation rules - forward version
 
 [sameAs1: (?A owl:sameAs ?B) -> (?B owl:sameAs ?A) ]
@@ -484,31 +484,31 @@
 # Equality processing rules
 
 [equality1: (?X owl:sameAs ?Y), notEqual(?X,?Y) ->
-		[(?X ?P ?V) <- (?Y ?P ?V)]
-		[(?V ?P ?X) <- (?V ?P ?Y)] ]
+    [(?X ?P ?V) <- (?Y ?P ?V)]
+    [(?V ?P ?X) <- (?V ?P ?Y)] ]
 
 [equality2: (?X owl:sameAs ?Y), (?X rdf:type owl:Class) -> (?X owl:equivalentClass ?Y) ]
 
 [equality3: (?X owl:sameAs ?Y), (?X rdf:type rdf:Property) -> (?X owl:equivalentProperty ?Y) ]
-		
+
 #------------------------------------------------------------------
 # Property rules
 #------------------------------------------------------------------
 
-# EquivalentProperty 
+# EquivalentProperty
+
+[equivalentProperty1: (?P owl:equivalentProperty ?Q)
+            -> (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) ]
+
+[equivalentProperty2: (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P)
+            -> (?P owl:equivalentProperty ?Q) ]
 
-[equivalentProperty1: (?P owl:equivalentProperty ?Q) 
-						-> (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) ]
-						
-[equivalentProperty2: (?P rdfs:subPropertyOf ?Q), (?Q rdfs:subPropertyOf ?P) 
-						-> (?P owl:equivalentProperty ?Q) ]
-						
-[equivalentProperty3: (?P owl:sameAs ?Q), (?P rdf:type rdf:Property), (?Q rdf:type rdf:Property) 
-						-> (?P owl:equivalentProperty ?Q) ]
+[equivalentProperty3: (?P owl:sameAs ?Q), (?P rdf:type rdf:Property), (?Q rdf:type rdf:Property)
+            -> (?P owl:equivalentProperty ?Q) ]
 
 # SymmetricProperty
 
-[symmetricProperty1: (?P rdf:type owl:SymmetricProperty) -> 
+[symmetricProperty1: (?P rdf:type owl:SymmetricProperty) ->
                      [symmetricProperty1b: (?X ?P ?Y) <- (?Y ?P ?X)] ]
 
 
@@ -517,11 +517,11 @@
 
 [inverseOf2: (?P owl:inverseOf ?Q) -> [inverseOf2b: (?X ?P ?Y) <- (?Y ?Q ?X)] ]
 
-[inverseOf3: (?P owl:inverseOf ?Q), (?P rdf:type owl:FunctionalProperty) 
-						-> (?Q rdf:type owl:InverseFunctionalProperty) ]
-		
-[inverseOf4: (?P owl:inverseOf ?Q), (?P rdf:type owl:InverseFunctionalProperty) 
-						-> (?Q rdf:type owl:FunctionalProperty) ]
+[inverseOf3: (?P owl:inverseOf ?Q), (?P rdf:type owl:FunctionalProperty)
+            -> (?Q rdf:type owl:InverseFunctionalProperty) ]
+
+[inverseOf4: (?P owl:inverseOf ?Q), (?P rdf:type owl:InverseFunctionalProperty)
+            -> (?Q rdf:type owl:FunctionalProperty) ]
 
 [inverseof5:  (?P owl:inverseOf ?Q) (?P rdfs:range ?C) -> (?Q rdfs:domain ?C)]
 [inverseof6:  (?P owl:inverseOf ?Q) (?P rdfs:domain ?C) -> (?Q rdfs:range ?C)]
@@ -530,52 +530,52 @@
 
 [transitiveProperty1: (?P rdf:type owl:TransitiveProperty) ->
 #			[transitiveProperty1b:  (?A ?P ?C) <- (?A ?P ?B), (?B ?P ?C)] ]
-			[transitiveProperty1b:  (?A ?P ?C) <- bound (?C), (?B ?P ?C), (?A ?P ?B)] 
-			[transitiveProperty1b:  (?A ?P ?C) <- unbound (?C), (?A ?P ?B) (?B ?P ?C)] 
-			]
+      [transitiveProperty1b:  (?A ?P ?C) <- bound (?C), (?B ?P ?C), (?A ?P ?B)]
+      [transitiveProperty1b:  (?A ?P ?C) <- unbound (?C), (?A ?P ?B) (?B ?P ?C)]
+      ]
 
-# Object properties 
+# Object properties
 
 [objectProperty: (?P rdf:type owl:ObjectProperty) ->
-						(?P rdfs:domain owl:Thing) (?P rdfs:range owl:Thing) ]
-						
+            (?P rdfs:domain owl:Thing) (?P rdfs:range owl:Thing) ]
+
 #------------------------------------------------------------------
 # Restricted support for hasValue, even though that is beyond OWL/lite
 #------------------------------------------------------------------
 
 # hasValue
 [hasValueRec: (?C owl:onProperty ?P), (?C owl:hasValue ?V)
-						-> (?C owl:equivalentClass hasValue(?P, ?V)) ]
-						
-[hasValueIF: (?C owl:equivalentClass hasValue(?P, ?V)) -> 
-								[ (?x ?P ?V) <- (?x rdf:type ?C) ]
-								[ (?x rdf:type ?C) <- (?x ?P ?V) ]
-								]
-
-[hasValueProp: (?P rdf:type owl:FunctionalProperty) (?Q rdf:type owl:FunctionalProperty) 
+            -> (?C owl:equivalentClass hasValue(?P, ?V)) ]
+
+[hasValueIF: (?C owl:equivalentClass hasValue(?P, ?V)) ->
+                [ (?x ?P ?V) <- (?x rdf:type ?C) ]
+                [ (?x rdf:type ?C) <- (?x ?P ?V) ]
+                ]
+
+[hasValueProp: (?P rdf:type owl:FunctionalProperty) (?Q rdf:type owl:FunctionalProperty)
                (?P rdfs:domain ?D) (?Q rdfs:domain ?D)
                (?D owl:equivalentClass hasValue(?P, ?V))
                (?D owl:equivalentClass hasValue(?Q, ?V))
                -> (?P owl:equivalentProperty ?Q)]
-               
+
 
 #------------------------------------------------------------------
 # Restricted support for oneOf, even though that is beyond OWL/lite
 #------------------------------------------------------------------
 
 [oneOfFP: (?P rdfs:range ?C) (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil)
-				-> (?P rdf:type owl:FunctionalProperty) ]
-				
+        -> (?P rdf:type owl:FunctionalProperty) ]
+
 [oneOfIFP: (?P rdfs:domain ?C) (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil)
-				-> (?P rdf:type owl:InverseFunctionalProperty) ]
+        -> (?P rdf:type owl:InverseFunctionalProperty) ]
 
 [oneOf1: (?C owl:oneOf ?l) -> listMapAsSubject(?l, rdf:type, ?C) ]
-				
+
 [oneOf2: (?C owl:oneOf ?l1) (?D owl:oneOf ?l2) notEqual(?l1, ?l2) listEqual(?l1, ?l2) -> (?C owl:equivalentClass ?D) ]
 
 [oneOf3: (?C owl:oneOf ?l) (?l rdf:first ?x) (?l rdf:rest rdf:nil) 	->
-				[ (?Y ?P ?x)  <- (?Y ?P ?I) (?I rdf:type ?C)  ] ]
-					
+        [ (?Y ?P ?x)  <- (?Y ?P ?I) (?I rdf:type ?C)  ] ]
+
 #------------------------------------------------------------------
 # Declaration of main XSD datatypes
 #------------------------------------------------------------------
@@ -644,7 +644,7 @@
 -> (xsd:int     rb:xsdRange xsd(xsd:integer,1,32)).
 -> (xsd:long    rb:xsdRange xsd(xsd:integer,1,64)).
 -> (xsd:integer rb:xsdRange xsd(xsd:integer,1,65)).
-							
+
 -> (xsd:unsignedByte    rb:xsdRange xsd(xsd:integer,0,8)).
 -> (xsd:unsignedShort   rb:xsdRange xsd(xsd:integer,0,16)).
 -> (xsd:unsignedInt     rb:xsdRange xsd(xsd:integer,0,32)).
@@ -653,31 +653,31 @@
 
 # Some XSD support may be disabled temporarily during performance checking
 
-[xsd1: (?X rdfs:subClassOf ?Y) <- 
+[xsd1: (?X rdfs:subClassOf ?Y) <-
         (?X rb:xsdRange xsd(?B, 0, ?L)) (?Y rb:xsdRange xsd(?B, ?S, ?L2)) le(?L, ?L2)]
 
-[xsd2: (?X rdfs:subClassOf ?Y) <- 
+[xsd2: (?X rdfs:subClassOf ?Y) <-
         (?X rb:xsdRange xsd(?B, 1, ?L)) (?Y rb:xsdRange xsd(?B, 1, ?L2)) le(?L, ?L2)]
 
-[range1: (?P rdfs:range ?C) <- 
-			(?P rdfs:range ?D), (?D rb:xsdRange xsd(?B, ?S1, ?L1)), 
-			(?P rdfs:range ?E), notEqual(?D, ?E), 
-			(?E rb:xsdRange xsd(?B, ?S2, ?L2)), 
-			min(?S1, ?S2, ?S3),
-			min(?L1, ?L2, ?L3),
-			(?C rb:xsdRange xsd(?B, ?S3, ?L3)),
-			]
+[range1: (?P rdfs:range ?C) <-
+      (?P rdfs:range ?D), (?D rb:xsdRange xsd(?B, ?S1, ?L1)),
+      (?P rdfs:range ?E), notEqual(?D, ?E),
+      (?E rb:xsdRange xsd(?B, ?S2, ?L2)),
+      min(?S1, ?S2, ?S3),
+      min(?L1, ?L2, ?L3),
+      (?C rb:xsdRange xsd(?B, ?S3, ?L3)),
+      ]
 
 [range2: (?P rdfs:range xsd:byte) <- (?P rdfs:range xsd:nonNegativeInteger),
-					(?P rdfs:range xsd:nonPositiveInteger)]
+          (?P rdfs:range xsd:nonPositiveInteger)]
 
-[range3: (?P rdfs:range owl:Nothing) <- (?P rdfs:range ?C), (?P rdfs:range ?D), notEqual(?C, ?D) 
-							 (?C owl:disjointWith ?D) ]
+[range3: (?P rdfs:range owl:Nothing) <- (?P rdfs:range ?C), (?P rdfs:range ?D), notEqual(?C, ?D)
+               (?C owl:disjointWith ?D) ]
 
 [xsd3: (?C owl:disjointWith ?D) <- (?C rb:xsdBase ?BC), (?D rb:xsdBase ?BD), notEqual(?BC, ?BD) ]
 
 [range4: (?P rdfs:subPropertyOf ?Q) <- (?P rdfs:range owl:Nothing) (?Q rdf:type rdf:Property)]
-										
+
 
 #------------------------------------------------------------------
 # Validation rules. These are dormant by default but are triggered
@@ -688,83 +688,83 @@
     (?P rb:violation error('inconsistent property definition', 'Property defined with domain which has a max(0) restriction for that property (domain)', ?C) )
 ]
 
-[validationMax0: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 0))  -> 
+[validationMax0: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 0))  ->
     [max2b: (?X rb:violation error('too many values', 'Value for max-0 property (prop, class)', ?P, ?C))
-    			<- (?X rdf:type ?C), (?X ?P ?Y) ] ]
+          <- (?X rdf:type ?C), (?X ?P ?Y) ] ]
 
 [validationMaxN: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, ?N)) greaterThan(?N, 1) (?P rdf:type owl:DatatypeProperty) ->
     [max2b: (?X rb:violation error('too many values', 'Too many values on max-N property (prop, class)', ?P, ?C))
-    			<- (?X rdf:type ?C), countLiteralValues(?X, ?P, ?M), lessThan(?N, ?M)  ] ]
-    			
+          <- (?X rdf:type ?C), countLiteralValues(?X, ?P, ?M), lessThan(?N, ?M)  ] ]
+
 [validationMax1: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 1)) (?P rdf:type owl:DatatypeProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing literal values for card1 property', ?P, ?V, ?U))
-    			<- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), isLiteral(?V), isLiteral(?U), notEqual(?V, ?U) ] ]
+          <- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), isLiteral(?V), isLiteral(?U), notEqual(?V, ?U) ] ]
 
 [validationFP: (?v rb:validation on()), (?P rdf:type owl:FunctionalProperty) (?P rdf:type owl:DatatypeProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing literal values for functional property', ?P, ?V, ?U))
-    			<- (?X ?P ?V), (?X ?P ?U), isLiteral(?V), isLiteral(?U), notEqual(?V, ?U) ] ]
+          <- (?X ?P ?V), (?X ?P ?U), isLiteral(?V), isLiteral(?U), notEqual(?V, ?U) ] ]
 
 [validationMax1I: (?v rb:validation on()), (?C rdfs:subClassOf max(?P, 1)) (?P rdf:type owl:ObjectProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing individual  values for card1 property', ?P, ?V, ?U))
-    			<- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U), (?U owl:differentFrom ?V) ] ]
+          <- (?X rdf:type ?C) (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U), (?U owl:differentFrom ?V) ] ]
 
 [validationFPI: (?v rb:validation on()), (?P rdf:type owl:FunctionalProperty) (?P rdf:type owl:ObjectProperty) ->
     [fpb: (?X rb:violation error('too many values', 'Clashing individual values for functional property', ?P, ?V, ?U))
-    			<- (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U),  (?U owl:differentFrom ?V) ] ]
+          <- (?X ?P ?V), (?X ?P ?U), notEqual(?V, ?U),  (?U owl:differentFrom ?V) ] ]
 
 [validationIndiv: (?v rb:validation on())  ->
-	[validationIndiv: (?X rb:violation error('conflict', 'Two individuals both same and different, may be due to disjoint classes or functional properties', ?Y)) 
-				<- (?X owl:differentFrom ?Y), (?X owl:sameAs ?Y), noValue(?T, rb:prototype ?X) ] ]
-				
-[validationIndiv2: (?v rb:validation on()) (?X owl:disjointWith ?Y) -> 
-	[validationIndiv: (?I rb:violation error('conflict', 'Individual a member of disjoint classes', ?X, ?Y)) 
-				<- (?I rdf:type ?X), (?I rdf:type ?Y) noValue(?T rb:prototype ?I)] ]
+  [validationIndiv: (?X rb:violation error('conflict', 'Two individuals both same and different, may be due to disjoint classes or functional properties', ?Y))
+        <- (?X owl:differentFrom ?Y), (?X owl:sameAs ?Y), noValue(?T, rb:prototype ?X) ] ]
+
+[validationIndiv2: (?v rb:validation on()) (?X owl:disjointWith ?Y) ->
+  [validationIndiv: (?I rb:violation error('conflict', 'Individual a member of disjoint classes', ?X, ?Y))
+        <- (?I rdf:type ?X), (?I rdf:type ?Y) noValue(?T rb:prototype ?I)] ]
 
 [validationIndiv3: (?v rb:validation on()) ->
-	[validationIndiv: (?I rb:violation error('conflict', 'Individual a member of Nothing', ?I)) 
-				<- (?I rdf:type owl:Nothing) noValue(?T rb:prototype ?I) ] ]
+  [validationIndiv: (?I rb:violation error('conflict', 'Individual a member of Nothing', ?I))
+        <- (?I rdf:type owl:Nothing) noValue(?T rb:prototype ?I) ] ]
 
 [validationDisjoint: (?v rb:validation on()) (?X owl:disjointWith ?Y)  ->
-	[validationIndiv: (?X rb:violation warn('Inconsistent class', 'Two classes related by both subclass and disjoint relations', ?Y)) 
-				<- (?X owl:disjointWith ?Y), (?X rdfs:subClassOf ?Y) ] ]
+  [validationIndiv: (?X rb:violation warn('Inconsistent class', 'Two classes related by both subclass and disjoint relations', ?Y))
+        <- (?X owl:disjointWith ?Y), (?X rdfs:subClassOf ?Y) ] ]
 
 [validationDisjoint2: (?v rb:validation on()) (?X owl:disjointWith ?Y) ->
-	[validationIndiv: (?C rb:violation warn('Inconsistent class', 'subclass of two disjoint classes', ?X, ?Y)) 
-				<- (?X owl:disjointWith ?Y), (?C rdfs:subClassOf ?X) (?C rdfs:subClassOf ?Y) notEqual(?C, owl:Nothing) ] ]
+  [validationIndiv: (?C rb:violation warn('Inconsistent class', 'subclass of two disjoint classes', ?X, ?Y))
+        <- (?X owl:disjointWith ?Y), (?C rdfs:subClassOf ?X) (?C rdfs:subClassOf ?Y) notEqual(?C, owl:Nothing) ] ]
 
 [validationDTP: (?v rb:validation on()), (?P rdf:type owl:DatatypeProperty) ->
-	[validationDTP: (?X rb:violation error('range check', 'Object value for datatype property (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
+  [validationDTP: (?X rb:violation error('range check', 'Object value for datatype property (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
 
 [validationOP: (?v rb:validation on()), (?P rdf:type owl:ObjectProperty) ->
-	[validationDTP: (?X rb:violation warn('range check', 'Literal value for object property (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), isLiteral(?V) ] ]
+  [validationDTP: (?X rb:violation warn('range check', 'Literal value for object property (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), isLiteral(?V) ] ]
 
 [validationDTRange: (?v rb:validation on()), (?P rdfs:range ?R) (?R rdf:type rdfs:Datatype) ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notDType(?V, ?R)  ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notDType(?V, ?R)  ] ]
 
 [validationDTRange: (?v rb:validation on()), (?P rdfs:range rdfs:Literal)  ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range rdsf:Literal (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to range rdsf:Literal (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), notLiteral(?V), notBNode(?V) ] ]
 
 [validationAllFrom: (?v rb:validation on()), (?C rdfs:subClassOf all(?P, ?R)) (?R rdf:type rdfs:Datatype) ->
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, ?R) ] ]
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, ?R) ] ]
 
-[validationAllFrom: (?v rb:validation on()), (?C owl:equivalentClass all(?P, rdfs:Literal)) -> 
-	[validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom rdfs:Literal (prop, value)', ?P, ?V))
-				<- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, rdfs:Literal) 
-				 ] ]
+[validationAllFrom: (?v rb:validation on()), (?C owl:equivalentClass all(?P, rdfs:Literal)) ->
+  [validationDTRange: (?X rb:violation error('range check', 'Incorrectly typed literal due to allValuesFrom rdfs:Literal (prop, value)', ?P, ?V))
+        <- (?X ?P ?V), (?X rdf:type ?C), notDType(?V, rdfs:Literal)
+         ] ]
 
-[validationNothing: (?v rb:validation on()), (?C owl:equivalentClass owl:Nothing) notEqual(?C, owl:Nothing) -> 
-	(?C rb:violation warn('Inconsistent class', 'Class cannot be instantiated, probably subclass of a disjoint classes or of an empty restriction'))
+[validationNothing: (?v rb:validation on()), (?C owl:equivalentClass owl:Nothing) notEqual(?C, owl:Nothing) ->
+  (?C rb:violation warn('Inconsistent class', 'Class cannot be instantiated, probably subclass of a disjoint classes or of an empty restriction'))
 ]
 
-[validationRangeNothing: (?v rb:validation on()), (?P rdfs:range owl:Nothing) -> 
-	(?C rb:violation warn('Inconsistent property', 'Property cannot be instantiated, probably due to multiple disjoint range declarations'))
+[validationRangeNothing: (?v rb:validation on()), (?P rdfs:range owl:Nothing) ->
+  (?C rb:violation warn('Inconsistent property', 'Property cannot be instantiated, probably due to multiple disjoint range declarations'))
 ]
 
 [validationOneOf: (?v rb:validation on()) (?C owl:oneOf ?L) ->
-	[validationIndiv: (?X rb:violation warn('possible oneof violation', 'Culprit is deduced to be of enumerated type (implicicated class) but is not one of the enumerations\n This may be due to aliasing.', ?Y)) 
-				<- (?X rdf:type ?C), notBNode(?X), listNotContains(?L, ?X) ] ]
+  [validationIndiv: (?X rb:violation warn('possible oneof violation', 'Culprit is deduced to be of enumerated type (implicicated class) but is not one of the enumerations\n This may be due to aliasing.', ?Y))
+        <- (?X rdf:type ?C), notBNode(?X), listNotContains(?L, ?X) ] ]
diff --git a/jena-core/src/test/java/com/hp/hpl/jena/reasoner/rulesys/test/TestBugs.java b/jena-core/src/test/java/com/hp/hpl/jena/reasoner/rulesys/test/TestBugs.java
index 12b37bb351..5a06ad4fc2 100644
--- a/jena-core/src/test/java/com/hp/hpl/jena/reasoner/rulesys/test/TestBugs.java
+++ b/jena-core/src/test/java/com/hp/hpl/jena/reasoner/rulesys/test/TestBugs.java
@@ -870,5 +870,25 @@ public class TestBugs extends TestCase {
 //            System.out.println(" - " + i.next());
 //        }
 //    }
+    
+    /**
+     * Potential problem in handling of maxCardinality(0) assertions in the
+     * presence of disjointness.
+     */
+    public void testMaxCard2() {
+        doTestmaxCard2(OntModelSpec.OWL_MEM_MINI_RULE_INF);
+        doTestmaxCard2(OntModelSpec.OWL_MEM_RULE_INF);
+    }
+    
+    
+    private void doTestmaxCard2(OntModelSpec spec) {
+        String NS = "http://jena.hpl.hp.com/eg#";
+        Model base = FileManager.get().loadModel("testing/reasoners/bugs/terrorism.owl");
+        OntModel model = ModelFactory.createOntologyModel(spec, base);
+        OntClass event = model.getOntClass(NS + "Event");
+        List<OntClass> subclasses = event.listSubClasses().toList();
+        assertFalse( subclasses.contains( OWL.Nothing ) );
+        assertEquals(3, subclasses.size());
+    }
 
 }
diff --git a/jena-core/testing/reasoners/bugs/terrorism.owl b/jena-core/testing/reasoners/bugs/terrorism.owl
new file mode 100644
index 0000000000..c381532008
--- /dev/null
+++ b/jena-core/testing/reasoners/bugs/terrorism.owl
@@ -0,0 +1,49 @@
+<!DOCTYPE rdf:RDF [
+    <!ENTITY xsd  "http://www.w3.org/2001/XMLSchema#" >
+    <!ENTITY owl  "http://www.w3.org/2002/07/owl#" >
+    <!ENTITY rdf  "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
+]>
+
+
+<rdf:RDF xmlns="http://jena.hpl.hp.com/eg#"
+    xmlns:terror="http://jena.hpl.hp.com/eg#" xml:base="http://jena.hpl.hp.com/eg"
+    xmlns:owl="http://www.w3.org/2002/07/owl#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#">
+
+    <owl:Class rdf:ID="Event">
+        <owl:disjointWith rdf:resource="#Person" />
+    </owl:Class>
+
+    <owl:Class rdf:ID="NewsOrganization">
+        <rdfs:subClassOf>
+            <owl:Restriction>
+                <owl:onProperty rdf:resource="#associatedWith" />
+                <owl:maxCardinality rdf:datatype="&xsd;nonNegativeInteger">0
+                </owl:maxCardinality>
+            </owl:Restriction>
+        </rdfs:subClassOf>
+    </owl:Class>
+
+    <owl:Class rdf:ID="Killing">
+        <rdfs:subClassOf rdf:resource="#Event" />
+    </owl:Class>
+
+    <owl:Class rdf:ID="TerrorAttack">
+        <rdfs:subClassOf rdf:resource="#Killing" />
+    </owl:Class>
+
+    <owl:Class rdf:ID="AircraftHijacking">
+        <rdfs:subClassOf rdf:resource="#TerrorAttack" />
+    </owl:Class>
+
+    <owl:Class rdf:ID="NewsTopic">
+        <owl:disjointWith rdf:resource="#Person" />
+        <owl:disjointWith rdf:resource="#Event" />
+    </owl:Class>
+
+
+    <owl:ObjectProperty rdf:ID="associatedWith">
+        <rdfs:domain rdf:resource="#Person" />
+    </owl:ObjectProperty>
+
+</rdf:RDF>
