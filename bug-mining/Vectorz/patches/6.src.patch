diff --git a/src/main/java/mikera/vectorz/AVector.java b/src/main/java/mikera/vectorz/AVector.java
index 4ff11a48..a0b08c82 100644
--- a/src/main/java/mikera/vectorz/AVector.java
+++ b/src/main/java/mikera/vectorz/AVector.java
@@ -43,10 +43,10 @@ import mikera.vectorz.util.VectorzException;
 
 /**
  * Main abstract base class for all types of vector
- * 
+ *
  * Contains default implementations for most vector operations which can be
  * overriden to achieve better performance in derived classes.
- * 
+ *
  * @author Mike
  *
  */
@@ -61,10 +61,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 
 	@Override
 	public abstract double get(int i);
-	
+
 	@Override
 	public abstract void set(int i, double value);
-	
+
 	// ================================================
 	// Standard implementations
 
@@ -73,17 +73,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if ((i<0)||(i>=length())) throw new IndexOutOfBoundsException(ErrorMessages.invalidIndex(this, i));
 		return unsafeGet((int)i);
 	}
-	
+
 	public void set(long i, double value) {
 		if ((i<0)||(i>=length())) throw new IndexOutOfBoundsException(ErrorMessages.invalidIndex(this, i));
 		unsafeSet((int)i,value);
 	}
-	
+
 	@Override
 	public final double getElement(long i) {
 		return get(i);
 	}
-	
+
 	@Override
 	public void set(int[] indexes, double value) {
 		if (indexes.length==1) {
@@ -92,7 +92,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			throw new UnsupportedOperationException(""+indexes.length+"D set not supported on AVector");
 		}
 	}
-	
+
 	@Override
 	public void set(long[] indexes, double value) {
 		if (indexes.length==1) {
@@ -101,10 +101,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			throw new UnsupportedOperationException(""+indexes.length+"D set not supported on AVector");
 		}
 	}
-	
+
 	/**
 	 * Like set, but performs no bounds checking.
-	 * 
+	 *
 	 * Results are undefined if the index is out of range
 	 * @param i
 	 * @param value
@@ -112,87 +112,87 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void unsafeSet(int i, double value) {
 		set(i,value);
 	}
-	
+
 	/**
 	 * Like get, but performs no bounds checking.
-	 * 
+	 *
 	 * Results are undefined if the index is out of range
 	 * @param i
 	 * @param value
-	 */	
+	 */
 	public double unsafeGet(int i) {
 		return get(i);
 	}
-	
+
 	@Override
 	public final double get(int x, int y) {
 		throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, x,y));
 	}
-	
+
 	@Override
 	public final int dimensionality() {
 		return 1;
 	}
-	
+
 	@Override
 	public final double get(int... indexes) {
 		if (indexes.length!=1) throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, indexes));
 		return get(indexes[0]);
 	}
-	
+
 	@Override
 	public final double get(long[] indexes) {
 		if (indexes.length!=1) throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, indexes));
 		return get(Tools.toInt(indexes[0]));
 	}
-	
+
 	@Override
 	public final double get(AIndex ix) {
 		if (ix.length()!=1) throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, ix));
 		return get(ix.get(0));
 	}
-	
+
 	@Override
 	public double get() {
 		throw new UnsupportedOperationException("Can't do 0-d get on a vector!");
 	}
-	
+
 	@Override
 	public AScalar slice(int position) {
 		return VectorIndexScalar.wrap(this,position);
 	}
-	
+
 	@Override
 	public Object sliceValue(int i) {
 		return get(i);
 	}
-	
+
 	@Override
 	public AScalar slice(int dimension, int index) {
 		checkDimension(dimension);
-		return slice(index);	
-	}	
-	
+		return slice(index);
+	}
+
 	@Override
 	public int sliceCount() {
 		return length();
 	}
-	
+
 	@Override
 	public List<Double> getSlices() {
 		return new ListWrapper(this);
 	}
-	
+
 	@Override
 	public int[] getShape() {
 		return new int[] {length()};
 	}
-	
+
 	@Override
 	public int[] getShapeClone() {
 		return new int[] {length()};
 	}
-	
+
 	@Override
 	public final int getShape(int dim) {
 		if (dim==0) {
@@ -202,17 +202,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 	}
 
-	
+
 	@Override
 	public long[] getLongShape() {
 		return new long[] {length()};
 	}
-		
+
 	@Override
 	public long elementCount() {
 		return length();
 	}
-	
+
 	@Override
 	public long nonZeroCount() {
 		int n=length();
@@ -222,10 +222,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Return an double array specifying the values in this vector which are non-zero
-	 * 
+	 *
 	 * @return
 	 */
 	public double[] nonZeroValues() {
@@ -233,7 +233,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int n=(int)nonZeroCount();
 		if (n==0) return DoubleArrays.EMPTY;
 		double[] vs=new double[n];
-		
+
 		int vi=0;
 		for (int i=0; i<len; i++) {
 			double d=unsafeGet(i);
@@ -244,37 +244,37 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return vs;
 	}
-	
+
 	@Override
 	public AVector subArray(int[] offsets, int[] shape) {
 		if (offsets.length!=1) throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, offsets));
 		if (shape.length!=1) throw new IllegalArgumentException(ErrorMessages.invalidIndex(this, offsets));
 		return subVector(offsets[0],shape[0]);
 	}
-	
-	
+
+
 	@Override
 	public INDArray rotateView(int dimension, int shift) {
 		checkDimension(dimension);
 		return rotateView(shift);
 	}
-	
+
 	@Override
 	public AVector rotateView(int shift) {
 		int n=length();
 		if (n==0) return this;
-		
+
 		shift = Maths.mod(shift,n);
 		if (shift==0) return this;
-			
+
 		return subVector(shift,n-shift).join(subVector(0,shift));
-	}	
-	
+	}
+
 	@Override
 	public AVector rotateCopy(int shift) {
 		return rotateView(shift).copy();
-	}	
-	
+	}
+
 	/**
 	 * Obtains a sub-vector view that refers to this vector.
 	 * Changes to the sub-vector will be reflected in this vector
@@ -284,15 +284,15 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 
 		if (length==0) return Vector0.INSTANCE;
 		if (length==len) return this;
-		
+
 		return WrappedSubVector.wrap(this,offset,length);
 	}
 
 	/**
 	 * Returns a new vector that refers to this vector joined to a second vector.
-	 * 
+	 *
 	 * Optimises the type of the returned vector to be as efficient as possible.
-	 * 
+	 *
 	 * @param second
 	 * @return
 	 */
@@ -301,24 +301,24 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (b.dimensionality()!=1) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, b));
 		return join(b.asVector());
 	}
-	
+
 	public AVector join(AVector second) {
 		if (second.length()==0) return this;
 		AVector ej=tryEfficientJoin(second);
 		if (ej!=null) return ej;
 		return JoinedVector.joinVectors(this,second);
 	}
-	
+
 	/**
-	 * Attempts to perform an efficient join with a second vector. An efficient join is guaranteed 
-	 * to be better than a simple JoinedVector(left,right) 
-	 * 
+	 * Attempts to perform an efficient join with a second vector. An efficient join is guaranteed
+	 * to be better than a simple JoinedVector(left,right)
+	 *
 	 * If possible, returns the joined vector. If not, returns null
 	 */
 	public AVector tryEfficientJoin(AVector second) {
 		return null;
 	}
-	
+
 	@Override
 	public INDArray join(INDArray a, int dimension) {
 		checkDimension(dimension);
@@ -328,7 +328,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (a.dimensionality()!=1) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, a));
 		return join(a.asVector());
 	}
-	
+
 	@Override
 	public int compareTo(INDArray a) {
 		if (a instanceof AVector) {
@@ -339,20 +339,20 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return compareTo(a.asVector());
 		}
 	}
-	
+
 	/**
 	 * Compares this vector to another vector
 	 */
 	public int compareTo(AVector a) {
 		int len=checkSameLength(a);
-		
+
 		for (int i=0; i<len; i++) {
 			int r= Double.compare(unsafeGet(i),a.unsafeGet(i));
 			if (r!=0) return r;
 		}
 		return 0;
 	}
-	
+
 	/**
 	 * Test for equality on vectors. Returns true iff all values in the vector
 	 * are identical
@@ -363,7 +363,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (o instanceof INDArray) return equals((INDArray)o);
 		return false;
 	}
-	
+
 	@Override
 	public boolean equals(AVector v) {
 		if (this==v) return true;
@@ -380,21 +380,21 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return true;
 	}
-	
+
 	@Override
 	public boolean equals(INDArray v) {
 		if (v instanceof AVector) return equals((AVector)v);
 		if (v.dimensionality()!=1) return false;
 		int len=length();
 		if (len != v.getShape(0)) return false;
-		
+
 		for (int i = 0; i < len; i++) {
 			if (unsafeGet(i) != v.get(i))
 				return false;
 		}
 		return true;
 	}
-	
+
 	/**
 	 * Returns true if this vector exactly matches a double[] array.
 	 * @param data
@@ -405,7 +405,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (length()!=data.length) return false;
 		return equalsArray(data,0);
 	}
-	
+
 	@Override
 	public boolean elementsEqual(double value) {
 		int length=length();
@@ -414,11 +414,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return true;
 	}
-	
+
 	/**
 	 * Returns true if this vector exactly matches the elements in double[] array, starting
 	 * from the specified offset
-	 * 
+	 *
 	 * @param data
 	 * @return
 	 */
@@ -430,7 +430,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return true;
 	}
-	
+
 	/**
 	 * Returns a java.util.List instance containing all elements of this vector
 	 * @return
@@ -444,7 +444,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return al;
 	}
-	
+
 	@Override
 	public boolean epsilonEquals(INDArray a, double tolerance) {
 		if (a instanceof AVector) return epsilonEquals((AVector)a,tolerance);
@@ -453,10 +453,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (len!=a.getShape(0)) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, a));
 		for (int i = 0; i < len; i++) {
 			if (!Tools.epsilonEquals(unsafeGet(i), a.get(i), tolerance)) return false;
-		}		
+		}
 		return true;
 	}
-		
+
 	/**
 	 * Returns true if this vector is approximately equal to another vector.
 	 * A small default tolerance is used.
@@ -466,22 +466,22 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean epsilonEquals(AVector v) {
 		return epsilonEquals(v,Vectorz.TEST_EPSILON);
 	}
-	
+
 	@Override
 	public boolean epsilonEquals(AVector v,double tolerance) {
 		if (this == v) return true;
 		int len=checkSameLength(v);
-		
+
 		for (int i = 0; i < len; i++) {
 			if (!Tools.epsilonEquals(unsafeGet(i), v.unsafeGet(i), tolerance)) return false;
 		}
 		return true;
 	}
-	
+
 	/**
 	 * Computes the hashcode of a vector.
-	 * 
-	 * Currently defined to be equal to List.hashCode for a equivalent list of Double values, 
+	 *
+	 * Currently defined to be equal to List.hashCode for a equivalent list of Double values,
 	 * this may change in future versions.
 	 */
 	@Override
@@ -493,14 +493,14 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return hashCode;
 	}
-		
+
 	@Override
 	public double[] toDoubleArray() {
 		double[] result=new double[length()];
 		getElements(result,0);
 		return result;
 	}
-	
+
 	@Override
 	public INDArray[] toSliceArray() {
 		int n=sliceCount();
@@ -510,12 +510,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return al;
 	}
-	
+
 	@Override
 	public double[] asDoubleArray() {
 		return null;
 	}
-	
+
 	@Override
 	public void toDoubleBuffer(DoubleBuffer dest) {
 		int len=length();
@@ -523,21 +523,21 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			dest.put(unsafeGet(i));
 		}
 	}
-	
+
 	/**
 	 * Copies a the contents of a vector to a vector at the specified offset
 	 */
 	public void copyTo(AVector dest, int destOffset) {
 		copyTo(0,dest,destOffset,length());
 	}
-	
+
 	/**
 	 * Copies a the contents of a vector to a vector at the specified offset
 	 */
 	public void copyTo(ADenseArrayVector dest, int destOffset) {
 		getElements(dest.getArray(),dest.getArrayOffset()+destOffset);
 	}
-	
+
 	/**
 	 * Copies a subset of this vector to a vector at the specified offset
 	 */
@@ -548,7 +548,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			dest.unsafeSet(destOffset+i,unsafeGet(offset+i));
 		}
 	}
-	
+
 	/**
 	 * Copies a subset of this vector to a specified destination array offset
 	 */
@@ -557,11 +557,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			dest[destOffset+i]=unsafeGet(i+offset);
 		}
 	}
-	
+
 	/**
 	 * Copies a subset of this vector to a specified destination array offset
 	 * using the given stride.
-	 * 
+	 *
 	 * Unsafe operation: performs no bounds checking
 	 */
 	public void copyTo(int offset, double[] dest, int destOffset, int length, int stride) {
@@ -581,11 +581,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			unsafeSet(i,value);
 		}
 	}
-	
+
 	public void fillRange(int offset, int length, double value) {
 		subVector(offset,length).fill(value);
 	}
-	
+
 	/**
 	 * Clamps all values in the vector to a given range
 	 * @param value
@@ -602,7 +602,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			}
 		}
 	}
-	
+
 	public void clampMax(double max) {
 		int len=length();
 		for (int i = 0; i < len; i++) {
@@ -612,17 +612,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			}
 		}
 	}
-	
+
 	public void clampMin(double min) {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			double v=unsafeGet(i);
 			if (v<min) {
 				unsafeSet(i,min);
-			} 
+			}
 		}
 	}
-	
+
 	/**
 	 * Multiplies the vector by a constant factor
 	 * @param factor Factor by which to multiply each component of the vector
@@ -632,9 +632,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			unsafeSet(i,unsafeGet(i)*factor);
-		}	
+		}
 	}
-	
+
 	@Override
 	public void multiply(INDArray a) {
 		if (a instanceof AVector) {
@@ -650,7 +650,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			}
 		}
 	}
-	
+
 	/**
 	 * Multiplies this vector by another vector, elementwise.
 	 * @param v
@@ -661,18 +661,18 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return;
 		}
 		int len=checkSameLength(v);
-		
+
 		for (int i = 0; i < len; i++) {
 			unsafeSet(i,unsafeGet(i)*v.unsafeGet(i));
-		}	
+		}
 	}
-	
+
 	public final void multiply(ADenseArrayVector v) {
 		checkSameLength(v);
-		
+
 		multiply(v.getArray(),v.getArrayOffset());
 	}
-	
+
 	/**
 	 * Multiplies the elements in this vector by corresponding elements in the target array
 	 * @param data
@@ -682,9 +682,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			unsafeSet(i,unsafeGet(i)*data[i+offset]);
-		}	
+		}
 	}
-	
+
 	/**
 	 * Multiplies the elements in the target array by corresponding elements in this vector
 	 * @param data
@@ -694,23 +694,23 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			dest[i+offset]*=unsafeGet(i);
-		}	
+		}
 	}
-	
+
 	@Override
 	public AVector multiplyCopy(double d) {
 		AVector r= clone();
 		r.multiply(d);
 		return r;
 	}
-	
+
 	@Override
 	public AVector divideCopy(double d) {
 		AVector r = clone();
 		r.multiply(1.0/d);
 		return r;
 	}
-	
+
 	@Override
 	public INDArray multiplyCopy(INDArray a) {
 		if (a instanceof AVector) {
@@ -721,14 +721,14 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return multiplyCopy(a.broadcastLike(this));
 		}
 	}
-	
+
 	@Override
 	public AVector multiplyCopy(AVector a) {
 		AVector r=this.clone();
 		r.multiply(a);
 		return r;
 	}
-	
+
 	@Override
 	public INDArray divideCopy(INDArray a) {
 		int adims=a.dimensionality();
@@ -742,19 +742,19 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return divideCopy(a.broadcastLike(this));
 		}
 	}
-	
+
 	@Override
 	public AVector divideCopy(AVector a) {
 		AVector r=this.clone();
 		r.divide(a);
 		return r;
 	}
-	
+
 	@Override
 	public void divide(double factor) {
 		multiply(1.0/factor);
 	}
-	
+
 	@Override
 	public void divide(INDArray a) {
 		if (a instanceof AVector) {
@@ -763,14 +763,14 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			super.divide(a);
 		}
 	}
-	
+
 	public void divide(AVector v) {
 		int len=checkSameLength(v);
 		for (int i = 0; i < len; i++) {
 			unsafeSet(i,unsafeGet(i)/v.unsafeGet(i));
-		}	
+		}
 	}
-	
+
 	/**
 	 * Divides the elements in this vector by corresponding elements in the target array
 	 * @param data
@@ -780,9 +780,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			unsafeSet(i,unsafeGet(i)/data[i+offset]);
-		}	
+		}
 	}
-	
+
 	/**
 	 * Divides the elements in the target array by corresponding elements in this vector
 	 * @param data
@@ -792,21 +792,21 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i = 0; i < len; i++) {
 			data[i+offset]/=unsafeGet(i);
-		}	
+		}
 	}
-	
+
 	@Override
 	public void abs() {
 		applyOp(Ops.ABS);
 	}
-	
+
 	@Override
 	public AVector absCopy() {
 		AVector result=clone();
 		result.abs();
 		return result;
 	}
-	
+
 	@Override
 	public void absDiff(INDArray a) {
 		if (a instanceof AVector) {
@@ -817,34 +817,34 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			absDiff(a.asVector());
 		}
 	}
-	
+
 	public void absDiff(AVector a) {
 		sub(a);
 		abs();
 	}
-	
+
 	public void absDiff(double v) {
 		sub(v);
 		abs();
 	}
-	
+
 	@Override
 	public INDArray absDiffCopy(INDArray a) {
 		INDArray res=subCopy(a).mutable();
 		res.abs();
 		return res;
 	}
-	
+
 	@Override
 	public void log() {
 		applyOp(Ops.LOG);
 	}
-	
+
 	@Override
 	public void signum() {
 		applyOp(Ops.SIGNUM);
 	}
-	
+
 	/**
 	 * Computes the softmax function over this vector, returning a new mutable vector
 	 */
@@ -853,7 +853,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		result.softmax();
 		return result;
 	}
-	
+
 	/**
 	 * Computes the softmax function over this vector, mutating this vector
 	 */
@@ -863,26 +863,26 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		applyOp(Ops.EXP);
 		divide(elementSum());
 	}
-	
+
 	@Override
 	public void square() {
 		applyOp(Ops.SQUARE);
 	}
-	
+
 	@Override
 	public AVector squareCopy() {
 		AVector r=clone();
 		r.square();
 		return r;
 	}
-	
+
 	@Override
 	public AVector sqrtCopy() {
 		AVector r=clone();
 		r.square();
 		return r;
 	}
-	
+
     /**
      * Computes the tanh of every element in this vector. Mutates this vector.
      */
@@ -891,9 +891,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		for (int i=0; i<len; i++) {
 			double x=unsafeGet(i);
 			unsafeSet(i,Math.tanh(x));
-		}			
+		}
 	}
-	
+
     /**
      * Computes the logistic function for every element in this vector. Mutates this vector.
      */
@@ -902,9 +902,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		for (int i=0; i<len; i++) {
 			double x=unsafeGet(i);
 			unsafeSet(i,Logistic.logisticFunction(x));
-		}			
+		}
 	}
-	
+
 	/**
 	 * Computes the reciprocal of all elements in this vector. Mutates this vector
 	 */
@@ -912,7 +912,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void reciprocal() {
 		applyOp(Ops.RECIPROCAL);
 	}
-	
+
 	/**
 	 * Computes the reciprocal of all elements in this vector. Mutates this vector
 	 */
@@ -922,7 +922,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		result.reciprocal();
 		return result;
 	}
-	
+
 	/**
 	 * Scales the vector by another vector of the same size
 	 * @param v
@@ -930,7 +930,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final void scale(AVector v) {
 		multiply(v);
 	}
-	
+
 	/**
 	 * Scales the vector up to a specific target magnitude
 	 * @return the old magnitude of the vector
@@ -940,7 +940,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		multiply(targetMagnitude/oldMagnitude);
 		return oldMagnitude;
 	}
-	
+
 	/**
 	 * Scales this vector then adds another vector
 	 * @param factor
@@ -950,22 +950,22 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		multiply(factor);
 		add(v);
 	}
-	
+
 	/**
 	 * Interpolates between this vector and a second vector, according to the ratio alpha.
-	 * alpha = 0.0 returns this vector. 
+	 * alpha = 0.0 returns this vector.
 	 * alpha = 1.0 returns the other vector
 	 * Other values perform linear interpolation.
-	 * 
+	 *
 	 * Stores the result in this vector
-	 * 
+	 *
 	 * @param v
 	 * @param alpha
 	 */
 	public void interpolate(AVector v, double alpha) {
 		scaleAdd(1.0-alpha,v,alpha,0.0);
 	}
-	
+
 	/**
 	 * Computes the squared magnitude (sum of squares) for this vector
 	 * @return
@@ -973,18 +973,18 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final double magnitudeSquared() {
 		return elementSquaredSum();
 	}
-	
+
 	@Override
 	public final AVector getTranspose() {return this;}
-	
+
 	@Override
 	public AVector getTransposeCopy() {
 		return clone();
 	}
-	
+
 	@Override
 	public final AVector getTransposeView() {return this;}
-	
+
 	/**
 	 * Selects a subset of indices from a vector
 	 * @param indices
@@ -999,9 +999,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return selectView(indices);
 		} else {
 			return selectClone(indices);
-		}		
+		}
 	}
-	
+
 	/**
 	 * Selects a subset of indices from a vector, returning a view
 	 * @param indices
@@ -1014,12 +1014,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return IndexedSubVector.wrap(this, indices.clone());
 	}
-	
+
 	/**
 	 * Selects a subset of indices from a vector, returning a mutable clone of data
 	 * @param indices
 	 * @return a new mutable vector containing the selected indices
-	 */	
+	 */
 	public AVector selectClone(int... inds) {
 		Vector v=Vector.createLength(inds.length);
 		double[] tdata=v.getArray();
@@ -1030,9 +1030,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return v;
 	}
-	
+
 	/**
-	 * Computes the outer product of this vector with another vector 
+	 * Computes the outer product of this vector with another vector
 	 * @param a
 	 * @return a matrix representing the outer product
 	 */
@@ -1046,7 +1046,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return m;
 	}
-	
+
 	@Override
 	public final INDArray outerProduct(INDArray a) {
 		if (a instanceof AVector) {
@@ -1054,7 +1054,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return super.outerProduct(a);
 	}
-	
+
 	/**
 	 * Computes the inner product of this vector with another vector
 	 * @return an AScalar instance representing the inner product
@@ -1074,7 +1074,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		checkLength(v.length());
 		return Scalar.create(dotProduct(v.getArray(),v.getArrayOffset()));
 	}
-	
+
 	/**
 	 * Computes the inner product of this vector with a matrix
 	 * @param m
@@ -1090,9 +1090,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			double v=this.dotProduct(cols.get(i));
 			r.unsafeSet(i,v);
 		}
-		return r;		
+		return r;
 	}
-	
+
 	/**
 	 * Computes the inner product of this vector with a scalar
 	 * @param s A scalar instance
@@ -1102,7 +1102,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final AVector innerProduct(AScalar s) {
 		return scaleCopy(s.get());
 	}
-	
+
 	@Override
 	public INDArray innerProduct(INDArray a) {
 		if (a instanceof AVector) {
@@ -1123,17 +1123,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	@Override
 	public final AVector innerProduct(double a) {
 		return multiplyCopy(a);
 	}
-	
+
 	/**
 	 * Returns the dot product of this vector with another vector
-	 * 
+	 *
 	 * The vectors must have the same length: if not the result is undefined
-	 * 
+	 *
 	 * @param v
 	 * @return
 	 */
@@ -1147,10 +1147,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return total;
 	}
-	
+
 	/**
 	 * Returns the dot product of this vector with a target ADenseArrayVector.
-	 * 
+	 *
 	 * @param v
 	 * @return
 	 */
@@ -1158,10 +1158,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		v.checkLength(length());
 		return dotProduct(v.getArray(), v.getArrayOffset());
 	}
-	
+
 	/**
 	 * Returns the dotProduct of this vector with the elements of another vector mapped to specified indexes in this vector.
-	 * 
+	 *
 	 * @param v
 	 * @param ix
 	 * @return
@@ -1175,17 +1175,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	/**
-	 * Fast dot product with a double[] array. Performs no bounds checking. 
-	 * 
+	 * Fast dot product with a double[] array. Performs no bounds checking.
+	 *
 	 * Likely to be faster than most other dot product operations
 	 */
 	public abstract double dotProduct(double[] data, int offset);
-	
+
 	/**
-	 * Fast dot product with a double[] array and a stride. Performs no bounds checking. 
-	 * 
+	 * Fast dot product with a double[] array and a stride. Performs no bounds checking.
+	 *
 	 * Likely to be faster than other dot product operations
 	 */
 	public double dotProduct(double[] data, int offset, int stride) {
@@ -1198,12 +1198,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Computes the crossProduct of this vector with another vector, and stores the result in this vector.
-	 * 
+	 *
 	 * Both vectors must have length 3.
-	 * 
+	 *
 	 * @param a
 	 */
 	public void crossProduct(AVector a) {
@@ -1216,17 +1216,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		double z2=a.unsafeGet(2);
 		double tx=y*z2-z*y2;
 		double ty=z*x2-x*z2;
-		double tz=x*y2-y*x2;			
+		double tz=x*y2-y*x2;
 		unsafeSet(0,tx);
 		unsafeSet(1,ty);
-		unsafeSet(2,tz);		
+		unsafeSet(2,tz);
 	}
-	
+
 	/**
 	 * Computes the crossProduct of this vector with another vector, and stores the result in this vector.
-	 * 
+	 *
 	 * Both vectors must have length 3.
-	 * 
+	 *
 	 * @param a
 	 */
 	public void crossProduct(Vector3 a) {
@@ -1239,12 +1239,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		double z2=a.z;
 		double tx=y*z2-z*y2;
 		double ty=z*x2-x*z2;
-		double tz=x*y2-y*x2;			
+		double tz=x*y2-y*x2;
 		unsafeSet(0,tx);
 		unsafeSet(1,ty);
-		unsafeSet(2,tz);		
+		unsafeSet(2,tz);
 	}
-	
+
 	/**
 	 * Returns the magnitude (Euclidean length) of the vector
 	 * @return
@@ -1252,7 +1252,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public double magnitude() {
 		return Math.sqrt(magnitudeSquared());
 	}
-	
+
 	/**
 	 * Returns the squared Euclidean distance to another vector.
 	 * @param v
@@ -1262,7 +1262,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		// we rely on the identity:  (a-b)^2  = a^2 + b^2 - 2a.b
 		return this.elementSquaredSum()+v.elementSquaredSum()-2*v.dotProduct(this);
 	}
-	
+
 	/**
 	 * Returns the Euclidean distance to another vector.
 	 * @param v
@@ -1271,10 +1271,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public double distance(AVector v) {
 		return Math.sqrt(distanceSquared(v));
 	}
-	
+
 	/**
 	 * Returns the distance from this vector to another vector according to the L1 (Taxicab) norm.
-	 * 
+	 *
 	 * @param v
 	 * @return
 	 */
@@ -1283,10 +1283,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		t.abs();
 		return t.elementSum();
 	}
-	
+
 	/**
 	 * Returns the distance from this vector to another vector according to the Linf norm.
-	 * 
+	 *
 	 * @param v
 	 * @return
 	 */
@@ -1294,7 +1294,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		AVector t=this.subCopy(v);
 		return t.maxAbsElement();
 	}
-	
+
 	/**
 	 * Returns the maximum absolute element value of a vector
 	 * @return
@@ -1307,11 +1307,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			double comp=Math.abs(unsafeGet(i));
 			if (comp>result) {
 				result=comp;
-			} 
-		}		
+			}
+		}
 		return result;
 	}
-	
+
 	/**
 	 * Returns the index of the maximum absolute element of a vector
 	 * @return
@@ -1326,11 +1326,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			if (comp>best) {
 				result=i;
 				best=comp;
-			} 
-		}		
+			}
+		}
 		return result;
 	}
-	
+
 	/**
 	 * Returns the maximum element value in a vector. Synonym for elementMax()
 	 * @return
@@ -1338,7 +1338,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final double maxElement() {
 		return elementMax();
 	}
-	
+
 	/**
 	 * Returns the index of the maximum element of a vector
 	 * @return
@@ -1353,18 +1353,18 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			if (comp>best) {
 				result=i;
 				best=comp;
-			} 
-		}		
+			}
+		}
 		return result;
 	}
-	
+
 	/**
 	 * Returns the minimum element value in a vector. Synonym for elementMin()
 	 */
 	public final double minElement() {
 		return elementMin();
 	}
-	
+
 	/**
 	 * Returns the index of the minimum element of a vector
 	 */
@@ -1378,11 +1378,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			if (comp<best) {
 				result=i;
 				best=comp;
-			} 
-		}		
+			}
+		}
 		return result;
 	}
-	
+
 	/**
 	 * Normalises so that the maximum absolute element is 1.0
 	 * Returns the previous maximum absolute element.
@@ -1392,7 +1392,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (scale!=0.0) scale(1.0/scale);
 		return scale;
 	}
-	
+
 	/**
 	 * Returns the sum of all elements in a vector
 	 * @return
@@ -1403,25 +1403,25 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		double result=0.0;
 		for (int i=0; i<len; i++) {
 			result+=unsafeGet(i);
-		}		
+		}
 		return result;
 	}
-	
+
 	@Override
 	public double elementProduct() {
 		int len=length();
 		double result=1.0;
 		for (int i=0; i<len; i++) {
 			result*=unsafeGet(i);
-		}		
+		}
 		return result;
 	}
-	
+
 	@Override
 	public double elementMax(){
 		return unsafeGet(maxElementIndex());
 	}
-	
+
 	/**
 	 * Returns the maximum absolute element value in this vector. Throws an error if there are no elements.
 	 */
@@ -1429,12 +1429,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final double elementMaxAbs() {
 		return maxAbsElement();
 	}
-	
+
 	@Override
 	public double elementMin(){
 		return unsafeGet(minElementIndex());
 	}
-	
+
 	@Override
 	public double elementSquaredSum() {
 		double result=0.0;
@@ -1445,7 +1445,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	@Override
 	public double elementPowSum(double exponent) {
 		int n=length();
@@ -1456,7 +1456,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	@Override
 	public double elementAbsPowSum(double exponent) {
 		int n=length();
@@ -1467,20 +1467,20 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Returns the Euclidean angle between this vector and another vector
 	 * @return angle in radians
 	 */
 	public double angle(AVector v) {
-		return Math.acos(dotProduct(v)/(v.magnitude()*this.magnitude()));
+		return Math.acos(Math.max(-1.0, Math.min(1.0, this.dotProduct(v)/(this.magnitude()*v.magnitude()))));
 	}
-	
+
 	/**
 	 * Normalises this vector to a magnitude of 1.0
-	 * 
+	 *
 	 * Has no effect on a zero-length vector (i.e. it will remain zero)
-	 * 
+	 *
 	 * @return the magnitude of the original vector
 	 */
 	@Override
@@ -1489,10 +1489,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (d>0) multiply(1.0/d);
 		return d;
 	}
-	
+
 	/**
 	 * Returns a copy of this vector normalised to a Euclidean length of 1.0
-	 * 
+	 *
 	 * Has no effect on a zero-length vector (i.e. it will return a zero length vector)
 	 */
 	@Override
@@ -1501,7 +1501,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (d>0.0) return multiplyCopy(1.0/d);
 		return copy();
 	}
-	
+
 	/**
 	 * Negates all emlements of this vector in place.
 	 */
@@ -1509,17 +1509,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void negate() {
 		multiply(-1.0);
 	}
-	
+
 	@Override
 	public AVector negateCopy() {
 		return multiplyCopy(-1.0);
 	}
-	
+
 	@Override
 	public final AVector scaleCopy(double d) {
 		return multiplyCopy(d);
 	}
-	
+
 	@Override
 	public AVector shiftCopy(int shift) {
 		if (shift==0) return copy();
@@ -1533,7 +1533,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return v;
 	}
-	
+
 	@Override
 	public void pow(double exponent) {
 		if (exponent==1.0) return;
@@ -1549,9 +1549,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int len=length();
 		for (int i=0; i<len; i++) {
 			unsafeSet(i,Math.pow(unsafeGet(i),exponent));
-		}				
+		}
 	}
-	
+
 	/**
 	 * Sets the vector to equal the value of another vector
 	 */
@@ -1566,7 +1566,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			}
 		}
 	}
-	
+
 	/**
 	 * Sets the vector equal to the value of an ADenseArrayVector
 	 * @param v
@@ -1575,33 +1575,33 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		v.checkLength(length());
 		setElements(v.getArray(),v.getArrayOffset());
 	}
-	
+
 	@Override
 	public final void set(double a) {
 		fill(a);
 	}
-		
+
 	@Override
 	public void setElements(double... data) {
 		checkLength(data.length);
 		setElements(data,0);
 	}
-	
+
 	@Override
 	public void setElements(double[] data,int offset) {
 		setElements(0,data,offset,length());
 	}
-	
+
 	@Override
 	public void set(INDArray a) {
 		if (a instanceof AVector) {set((AVector)a); return;}
 		if (a.dimensionality()==1) {
-			setElements(a.getElements());	
+			setElements(a.getElements());
 		} else {
 			throw new IllegalArgumentException("Cannot set vector using array of dimensonality: "+a.dimensionality());
 		}
 	}
-	
+
 	@Override
 	public void setElements(int pos,double[] values, int offset, int length) {
 		checkRange(pos,length);
@@ -1609,12 +1609,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			unsafeSet(i+pos,values[offset+i]);
 		}
 	}
-	
+
 	@Override
 	public void getElements(double[] dest, int offset) {
 		copyTo(0,dest,offset,length());
 	}
-	
+
 	@Override
 	public void getElements(Object[] dest, int offset) {
 		int n=length();
@@ -1622,9 +1622,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			dest[offset+i]=Double.valueOf(get(i));
 		}
 	}
-	
+
 	/**
-	 * Gets the elements in this vector from the specified indices, storing at the specified 
+	 * Gets the elements in this vector from the specified indices, storing at the specified
 	 * offset in the destination array
 	 * @param dest
 	 * @param destOffset
@@ -1636,19 +1636,19 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			dest[destOffset+i]=unsafeGet(indices[i]);
 		}
 	}
-	
+
 	/**
 	 * Set the vector equal to an offset into another vector
 	 */
 	public void set(AVector src, int srcOffset) {
 		set(src.subVector(srcOffset,length()));
 	}
-	
+
 	/**
-	 * Clones the vector, creating a new mutable copy of all data. 
-	 * 
+	 * Clones the vector, creating a new mutable copy of all data.
+	 *
 	 * The clone is:
-	 *  - not guaranteed to be of the same type. 
+	 *  - not guaranteed to be of the same type.
 	 *  - guaranteed to be fully mutable
 	 *  - guaranteed not to contain a reference (i.e. is a full deep copy)
 	 */
@@ -1656,13 +1656,13 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public AVector clone() {
 		return Vector.create(this);
 	}
-	
+
 	@Override
 	public AVector copy() {
 		if (!isMutable()) return this;
 		return clone();
 	}
-	
+
 	/**
 	 * Clones the vector into a sparse mutable format
 	 */
@@ -1670,12 +1670,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public AVector sparseClone() {
 		return Vectorz.createSparseMutable(this);
 	}
-	
+
 	@Override
 	public final AVector asVector() {
 		return this;
 	}
-	
+
 	@Override
 	public INDArray reshape(int... dimensions) {
 		int ndims=dimensions.length;
@@ -1687,18 +1687,18 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return Arrayz.createFromVector(this,dimensions);
 		}
 	}
-	
+
 	@Override
 	public final AVector reorder(int[] order) {
-		return select(order);	
-	}	
-	
+		return select(order);
+	}
+
 	@Override
 	public final AVector reorder(int dim, int[] order) {
 		checkDimension(dim);
 		return reorder(order);
-	}	
-	
+	}
+
 	/**
 	 * Returns true if this vector is of a view type that references other vectors / data.
 	 */
@@ -1706,7 +1706,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean isView() {
 		return true;
 	}
-	
+
 	/**
 	 * Returns true if this vector is mutable.
 	 */
@@ -1714,13 +1714,13 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean isMutable() {
 		return true;
 	}
-	
+
 	@Override
 	public boolean isElementConstrained() {
 		return false;
 	}
-	
-	
+
+
 	/**
 	 * Returns true if this vector is fully mutable, i.e. can contain any unconstrained double values
 	 */
@@ -1728,7 +1728,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean isFullyMutable() {
 		return isMutable();
 	}
-	
+
 	/**
 	 * Adds another vector to this one
 	 */
@@ -1742,7 +1742,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addAt(i,v.unsafeGet(i));
 		}
 	}
-	
+
 	/**
 	 * Add a DenseArrayVector to this vector
 	 * @param v
@@ -1751,7 +1751,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		checkSameLength(v);
 		add(v.getArray(),v.getArrayOffset());
 	}
-	
+
 	@Override
 	public final void add(INDArray a) {
 		if (a instanceof AVector) {
@@ -1762,7 +1762,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			super.add(a);
 		}
 	}
-	
+
 	@Override
 	public final INDArray addCopy(INDArray a) {
 		if (a instanceof AVector) {
@@ -1776,7 +1776,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return a.addCopy(this);
 		}
 	}
-	
+
 	@Override
 	public AVector addCopy(AVector a) {
 		// clone ensures mutability
@@ -1784,7 +1784,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.add(a);
 		return r;
 	}
-	
+
 	@Override
 	public AVector addCopy(double a) {
 		// clone ensures mutability
@@ -1792,7 +1792,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.add(a);
 		return r;
 	}
-	
+
 	@Override
 	public final INDArray subCopy(INDArray a) {
 		if (a instanceof AVector) {
@@ -1805,7 +1805,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return this.broadcastLike(a).subCopy(a);
 		}
 	}
-	
+
 	@Override
 	public AVector subCopy(AVector a) {
 		// clone ensures mutability
@@ -1813,7 +1813,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.sub(a);
 		return r;
 	}
-	
+
 	@Override
 	public void sub(INDArray a) {
 		if (a instanceof AVector) {
@@ -1822,9 +1822,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			add(-a.get());
 		}else {
 			super.sub(a);
-		}	
+		}
 	}
-	
+
 	/**
 	 * Adds part another vector to this one, starting at the specified offset in the source vector
 	 * @param src
@@ -1836,7 +1836,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addAt(i,src.unsafeGet(srcOffset+i));
 		}
 	}
-	
+
 	/**
 	 * Adds another vector into this one, at the specified offset
 	 * @param offset
@@ -1845,7 +1845,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final void add(int offset, AVector src) {
 		add(offset,src,0,src.length());
 	}
-	
+
 	/**
 	 * Adds a segment of another vector into this one, at the specified offset
 	 * @param offset
@@ -1854,9 +1854,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void add(int offset, AVector src, int srcOffset, int length) {
 		for (int i = 0; i < length; i++) {
 			addAt(offset+i,src.unsafeGet(i+srcOffset));
-		}		
+		}
 	}
-	
+
 	/**
 	 * Adds the element-wise product of two vectors to this vector. Mutates this vector.
 	 * @param a
@@ -1865,7 +1865,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addProduct(AVector a, AVector b) {
 		addProduct(a,b,1.0);
 	}
-	
+
 	/**
 	 * Adds the element-wise product of two vectors to this vector.
 	 * @param a
@@ -1877,7 +1877,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.addProduct(a,b);
 		return r;
 	}
-	
+
 	/**
 	 * Adds the element-wise product of two vectors and a constant factor to this vector.
 	 * @param a
@@ -1889,9 +1889,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.addProduct(a,b,factor);
 		return r;
 	}
-	
+
 	/**
-	 * Adds the element-wise product of two vectors and a constant factor to this vector. 
+	 * Adds the element-wise product of two vectors and a constant factor to this vector.
 	 * Mutates this vector.
 	 * @param a
 	 * @param b
@@ -1899,7 +1899,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addProduct(AVector a, AVector b, double factor) {
 		checkSameLength(a,b);
 		if (factor==0.0) return;
-		
+
 		if (a.isSparse()||b.isSparse()) {
 			AVector t=a.multiplyCopy(b);
 			addMultiple(t,factor);
@@ -1907,7 +1907,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addProduct(a,0,b,0,factor);
 		}
 	}
-	
+
 	/**
 	 * Checks that a vector is the specified length, throws an exception if not.
 	 * @param length
@@ -1918,14 +1918,14 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (len!=length) throw new IllegalArgumentException("Vector length mismatch, expected length = "+length+", but got length = "+len);
 		return len;
 	}
-	
+
 	@Override
 	protected final void checkDimension(int dimension) {
 		if (dimension !=0) {
 			throw new IndexOutOfBoundsException(ErrorMessages.invalidDimension(this,dimension));
 		}
 	}
-	
+
 	@Override
 	public void addMultiple(INDArray src, double factor) {
 		addMultiple(src.broadcastLike(this),factor);
@@ -1937,13 +1937,13 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	 */
 	public void addMultiple(AVector src, double factor) {
 		if (src instanceof ASparseVector) {
-			addMultiple(((ASparseVector)src).toSparseIndexedVector(),factor); 
+			addMultiple(((ASparseVector)src).toSparseIndexedVector(),factor);
 			return;
 		}
 		checkSameLength(src);
 		addMultiple(src,0,factor);
 	}
-	
+
 	/**
 	 * Adds a scaled multiple of a sparse indexed vector to this vector
 	 * @param src
@@ -1951,16 +1951,16 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addMultiple(SparseIndexedVector src, double factor) {
 		checkSameLength(src);
         if (factor==0.0) return;
-		Index srcIndex=src.nonSparseIndex();	
+		Index srcIndex=src.nonSparseIndex();
 		if (srcIndex.length()==0) return;
 		Vector nonSparseValues=src.nonSparseValues();
 		int n=srcIndex.length();
 		for (int i=0; i<n; i++) {
 			int ix=srcIndex.get(i);
 			addAt(ix,nonSparseValues.unsafeGet(i)*factor);
-		}	
+		}
 	}
-	
+
 	/**
 	 * Returns the sum of this vector with a scaled multiple of a second vector.
 	 * @param src
@@ -1972,10 +1972,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		r.addMultiple(src, factor);
 		return r;
 	}
-	
+
 	/**
 	 * Adds a multiple of a subvector of another vector to this vector.
-	 * 
+	 *
 	 * Useful as a specialised override for joined vectors etc.
 	 * @param src
 	 * @param srcOffset
@@ -1984,7 +1984,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addMultiple(AVector src, int srcOffset, double factor) {
 		addMultiple(0,src,srcOffset,length(),factor);
 	}
-	
+
 	public void addMultiple(int offset, AVector src, int srcOffset, int length, double factor) {
 		checkRange(offset,length);
 		src.checkRange(srcOffset, length);
@@ -1997,11 +1997,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			}
 		}
 	}
-	
+
 	public final void addMultiple(int offset, AVector v, double factor) {
 		addMultiple(offset,v,0,v.length(),factor);
 	}
-	
+
 	/**
 	 * Updates a weighted average of this vector with another vector
 	 * @param v
@@ -2009,7 +2009,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final void addWeighted(AVector v, double factor) {
 		scaleAdd(1.0-factor,v,factor,0.0);
 	}
-	
+
 	@Override
 	public final void scaleAdd(double factor, INDArray b, double bfactor, double constant) {
 		switch (b.dimensionality()) {
@@ -2018,9 +2018,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		default: throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, b));
 		}
 	}
-	
+
 	/**
-	 * Scales all elements of the array by a given double value, adds a 
+	 * Scales all elements of the array by a given double value, adds a
 	 * scaled second vector and adds a constant value
 	 * @param factor
 	 * @param b
@@ -2034,7 +2034,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		if (constant!=0.0) add(constant);
 	}
-	
+
 
 	@Override
 	public void addPower(INDArray src, double exponent) {
@@ -2060,7 +2060,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			add(tmp);
 		}
 	}
-	
+
 	/**
 	 * Adds a multiple of the source vector raised to the specified power to this vector
 	 * @param src
@@ -2072,7 +2072,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		tmp.pow(exponent);
 		addMultiple(tmp,factor);
 	}
-	
+
 	/**
 	 * Subtracts a vector from this vector
 	 * @param v
@@ -2080,17 +2080,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void sub(AVector v) {
 		addMultiple(v,-1.0);
 	}
-	
+
 	/**
 	 * Subtracts a value from the specified element in this vector.
-	 * 
+	 *
 	 * @param i
 	 * @param v
 	 */
 	public final void subAt(int i, double v) {
 		addAt(i,-v);
 	}
-	
+
 	/**
 	 * Returns true if this vector is a zero vector (all components zero)
 	 * @return
@@ -2099,12 +2099,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean isZero() {
 		return isRangeZero(0,length());
 	}
-	
+
 	/**
 	 * Returns true if a sub-vector range is completely zero.
-	 * 
+	 *
 	 * Unsafe operation - does not perform bounds checking, results are undefined if sub-vector is out of range
-	 * 
+	 *
 	 * @param start
 	 * @param length
 	 * @return
@@ -2115,7 +2115,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return true;
 	}
-	
+
 	/**
 	 * Returns true if the vector has unit length
 	 * @return
@@ -2123,7 +2123,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public boolean isUnitLengthVector() {
 		return isUnitLengthVector(Vectorz.TEST_EPSILON);
 	}
-	
+
 	/**
 	 * Returns true if the vector has unit length with the given tolerance
 	 * @return
@@ -2132,43 +2132,43 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		double mag=magnitudeSquared();
 		return Math.abs(mag-1.0)<=tolerance;
 	}
-	
+
 	@Override
 	public final boolean isSameShape(INDArray a) {
 		if (a instanceof AVector) return isSameShape((AVector)a);
 		if (a.dimensionality()!=1) return false;
 		return length()==a.getShape(0);
 	}
-	
+
 	@Override
 	public boolean isSameShape(AVector a) {
 		return length()==a.length();
 	}
-	
+
 	/**
 	 * Utility function to check vector length and throw an exception if not same shape.
 	 * @return The length of both vectors (which must be equals)
 	 */
 	protected int checkSameLength(AVector v) {
 		int len=length();
-		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));		
+		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));
 		return len;
 	}
-	
+
 	/**
 	 * Utility function to check vector length and throw an exception if not same shape.
 	 * @return The length of both vectors (which must be equals)
 	 */
 	protected int checkSameLength(AVector v, AVector w) {
 		int len=length();
-		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));		
-		if (len!=w.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, w));		
+		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));
+		if (len!=w.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, w));
 		return len;
 	}
-	
+
 	/**
 	 * Utility function to check vector range and throw an exception if not valid.
-	 * 
+	 *
 	 * Returns the length of this vector
 	 */
 	public int checkRange(int offset, int length) {
@@ -2179,7 +2179,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return len;
 	}
-	
+
 	/**
 	 * Utility function to check an index and throw an exception in not in bounds.
 	 * Returns the vector length
@@ -2189,24 +2189,24 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if ((i<0)||(i>=len)) throw new IndexOutOfBoundsException(ErrorMessages.invalidIndex(this, i));
 		return len;
 	}
-	
+
 	protected int checkSameLength(ASizedVector v) {
 		int len=length();
-		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));		
+		if (len!=v.length()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, v));
 		return len;
 	}
-	
+
 	/**
 	 * Projects the vector to the plane defined by: x.normal=distance
 	 * @param normal A Vector of unit length
-	 * @param distance 
+	 * @param distance
 	 */
 	public void projectToPlane(AVector normal, double distance) {
 		assert(Tools.epsilonEquals(normal.magnitude(), 1.0));
 		double d=dotProduct(normal);
 		addMultiple(normal,distance-d);
 	}
-	
+
 	/**
 	 * Subtracts a scaled multiple of another vector from this vector
 	 * @param v
@@ -2214,7 +2214,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void subMultiple(AVector v, double factor) {
 		addMultiple(v,-factor);
 	}
-	
+
 	@Override
 	public String toString() {
 		if (elementCount()>Constants.PRINT_THRESHOLD) {
@@ -2223,7 +2223,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return toStringFull();
 	}
-	
+
 	@Override
 	public String toStringFull() {
 		StringBuilder sb=new StringBuilder();
@@ -2239,10 +2239,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		sb.append(']');
 		return sb.toString();
 	}
-	
+
 	/**
 	 * Coerces this vector to the standard dense Vector format.
-	 * 
+	 *
 	 * May return the same vector is this is already a dense Vector, otherwise returns a Vector
 	 * containing a new clone of the vector elements.
 	 */
@@ -2250,7 +2250,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public Vector toVector() {
 		return Vector.create(this);
 	}
-	
+
 	/**
 	 * Creates an immutable copy of a vector
 	 * @return
@@ -2260,7 +2260,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (!isMutable()) return this;
 		return ImmutableVector.create(this);
 	}
-	
+
 	/**
 	 * Coerces to a mutable version of a vector. May or may not be a copy,
 	 * but guaranteed to be fully mutable
@@ -2274,26 +2274,26 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return this.clone();
 		}
 	}
-	
+
 	@Override
 	public AVector sparse() {
 		if (this instanceof ISparse) return this;
 		return Vectorz.createSparse(this);
 	}
-	
+
 	@Override
 	public AVector dense() {
 		return denseClone();
 	}
-	
+
 	@Override
 	public final Vector denseClone() {
 		return Vector.wrap(this.toDoubleArray());
 	}
-	
+
 	/**
 	 * Creates a new mutable vector representing the normalised value of this vector
-	 * 
+	 *
 	 * Returns null if the vector cannot be normalised (i.e. is a zero length vector)
 	 * @return
 	 */
@@ -2302,17 +2302,17 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		if (dd==0.0) return null;
 		return scaleCopy(1.0/Math.sqrt(dd));
 	}
-	
+
 	@Override
 	public List<Double> asElementList() {
 		return new ListWrapper(this);
 	}
-	
+
 	@Override
 	public Iterator<Double> iterator() {
 		return new VectorIterator(this);
 	}
-	
+
 	@Override
 	public final Iterator<Double> elementIterator() {
 		return iterator();
@@ -2333,12 +2333,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			this.addAt(j,data[i]*factor);
 		}
 	}
-	
+
 	@Override
 	public void addSparse(double c) {
 		add(c);
 	}
-	
+
 	/**
 	 * Adds the corresponding elements of the source vector to the non-sparse elements of this vector
 	 * @param v
@@ -2346,7 +2346,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addSparse(AVector v) {
 		add(v);
 	}
-	
+
 	@Override
 	public void setSparse(INDArray src) {
 		int sdims=src.dimensionality();
@@ -2356,7 +2356,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			super.setSparse(src);
 		}
 	}
-	
+
 	/**
 	 * Sets the non-sparse elements of this vector to the corresponding elements of another vector
 	 * @param v
@@ -2364,18 +2364,18 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void setSparse(AVector src) {
 		set(src);
 	}
-	
+
 	@Override
  	public void setSparse(double v) {
 		set(v);
 	}
-	
+
 	@Override
 	public void addMultipleSparse(INDArray a, double factor) {
 		if (a instanceof AVector) {
 			addMultipleSparse((AVector)a,factor);
 			return;
-		} 
+		}
 		int dims=a.dimensionality();
 		if (dims==0) {
 			addSparse(factor*a.get());
@@ -2385,7 +2385,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, a));
 		}
 	}
-	
+
 	/**
 	 * Adds a multiple of a source vector to the non-sparse elements of this vector only
 	 * @param v
@@ -2395,7 +2395,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		// default is just a simple addMultiple
 		addMultiple(v,factor);
 	}
-	
+
 	/**
 	 * Adds a source vector to this vector at the specified indexes which should map from source->this
 	 * @param source
@@ -2417,7 +2417,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public final void set(AVector source, Index indexes) {
 		set(source,indexes.data);
 	}
-	
+
 	/**
 	 * sets the vector using values indexed from another vector
 	 */
@@ -2428,10 +2428,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			unsafeSet(i, source.get(indexes[i]));
 		}
 	}
-	
+
 	/**
 	 * Adds this vector to a double[] array, starting at the specified offset.
-	 * 
+	 *
 	 * @param array
 	 * @param offset
 	 */
@@ -2439,7 +2439,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addToArray(double[] array, int offset) {
 		addToArray(0,array,offset,length());
 	}
-	
+
 	/**
 	 * Adds this vector to a double[] array, using the specified offset and stride into the destination array
 	 */
@@ -2463,7 +2463,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			array[i+arrayOffset]+=unsafeGet(i+offset);
 		}
 	}
-	
+
 	/**
 	 * Adds a multiple of this vector into a double array at the specified offset
 	 * @param offset
@@ -2474,7 +2474,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	public void addMultipleToArray(double factor, double[] array, int arrayOffset) {
 		addMultipleToArray(factor,0,array,arrayOffset,length());
 	}
-	
+
 	/**
 	 * Adds a multiple of a subvector of this vector into a double array at the specified offset
 	 * @param offset
@@ -2488,7 +2488,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			array[i+arrayOffset]+=factor*unsafeGet(i+offset);
 		}
 	}
-	
+
 	public void addProductToArray(double factor, int offset, AVector other,int otherOffset, double[] array, int arrayOffset, int length) {
 		if (other instanceof ADenseArrayVector) {
 			addProductToArray(factor,offset,(ADenseArrayVector)other,otherOffset,array,arrayOffset,length);
@@ -2497,9 +2497,9 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		checkRange(offset,length);
 		for (int i=0; i<length; i++) {
 			array[i+arrayOffset]+=factor*unsafeGet(i+offset)*other.unsafeGet(i+otherOffset);
-		}		
+		}
 	}
-	
+
 	/**
 	 * Adds the scaled elementwise product of this vector and another vector to the destimation array
 	 * @param factor
@@ -2517,7 +2517,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int otherArrayOffset=otherOffset+other.getArrayOffset();
 		for (int i=0; i<length; i++) {
 			dest[i+destOffset]+=factor*unsafeGet(i+offset)*otherArray[i+otherArrayOffset];
-		}		
+		}
 	}
 
 	/**
@@ -2536,7 +2536,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addAt(i, (a.unsafeGet(i+aOffset)* b.unsafeGet(i+bOffset)*factor));
 		}
 	}
-	
+
 	@Override
 	public final void setInnerProduct(INDArray a, INDArray b) {
 		if ((a instanceof AMatrix)&&(b instanceof AVector)) {
@@ -2549,13 +2549,13 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		set(a.innerProduct(b));
 	}
-	
+
 	@Override
 	public void addInnerProduct(AMatrix a, INDArray b) {
 		if (b.dimensionality()!=1) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, b));
 		addInnerProduct(a,b.asVector());
-	}	
-	
+	}
+
 	@Override
 	public final void addInnerProduct(INDArray a, INDArray b) {
 		if ((a instanceof AMatrix)&&(b instanceof AVector)) {
@@ -2569,10 +2569,10 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 
 		super.addInnerProduct(a, b);
 	}
-	
+
 	/**
 	 * Adds the inner product of the arguments (matrix a and vector b) to this vector.
-	 * 
+	 *
 	 * @param a A matrix with the same number or rows as this vector
 	 * @param b A vector with the same lengths as the number of columns in the parameter a
 	 */
@@ -2580,43 +2580,43 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		int length=this.length();
 		if (length!=a.rowCount()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, a));
 		if (b.length()!=a.columnCount()) throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(a, b));
-		
+
 		for (int i=0; i<length; i++) {
 			double v=a.rowDotProduct(i,b);
 			addAt(i,v);
 		}
 	}
-	
+
 	/**
 	 * Adds the inner product of the arguments (vector a and matrix b) to this vector.
-	 * 
+	 *
 	 * @param a A vector with the same lengths as the number of rows in the matrix parameter b
 	 * @param b A matrix with the same number of columns as this vector
 	 */
 	public void addInnerProduct(AVector a, AMatrix b) {
 		addInnerProduct(b.getTranspose(),a);
 	}
-	
+
 	/**
 	 * Sets this vector to the inner product of the arguments (matrix a and vector b).
-	 * 
+	 *
 	 * @param a A matrix with the same number or rows as this vector
 	 * @param b A vector with the same lengths as the number of columns in the parameter a
 	 */
 	public void setInnerProduct(AMatrix a, AVector b) {
 		a.transform(b, this);
 	}
-	
+
 	/**
 	 * Sets this vector to the inner product of the arguments (vector a and matrix b) to this vector.
-	 * 
+	 *
 	 * @param a A vector with the same lengths as the number of rows in the matrix parameter b
 	 * @param b A matrix with the same number of columns as this vector
 	 */
 	public void setInnerProduct(AVector a, AMatrix b) {
 		setInnerProduct(b.getTranspose(),a);
 	}
-	
+
 	@Override
 	public final void setMultiple(INDArray a, INDArray b) {
 		int bdims=b.dimensionality();
@@ -2629,7 +2629,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			multiply(b);
 		}
 	}
-	
+
 	/**
 	 * Sets this vector to the element-wise product of two otehr vectors
 	 * @param a
@@ -2651,7 +2651,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			scale(b);
 		}
 	}
-	
+
 	/**
 	 * Sets this vector to be a multiple of another vector
 	 * @param a
@@ -2680,7 +2680,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			unsafeSet(i,op.apply(unsafeGet(i)));
 		}
 	}
-	
+
 	@Override
 	public void applyOp(Op2 op, INDArray b) {
 		int dims=b.dimensionality();
@@ -2690,7 +2690,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		   default: throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, b));
 		}
 	}
-	
+
 	/**
 	 * Applies a binary operator to this vector and a second vector
 	 * @param op
@@ -2705,7 +2705,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			if (v!=nv) this.unsafeSet(i,nv);
 		}
 	}
-	
+
 	@Override
 	public void applyOp(Op2 op, double b) {
 		int len=length();
@@ -2715,14 +2715,14 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			if (v!=nv) unsafeSet(i,nv);
 		}
 	}
-	
+
 	@Override
 	public AVector applyOpCopy(Op op) {
 		AVector r=clone();
 		r.applyOp(op);
 		return r;
 	}
-	
+
 	@Override
 	public final void setApplyOp(Op op, INDArray a) {
 		int dims=a.dimensionality();
@@ -2732,7 +2732,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			default: throw new IllegalArgumentException(ErrorMessages.incompatibleShapes(this, a));
 		}
 	}
-	
+
 	/**
 	 * Sets this vector to the result of applying an operator to another vector
 	 * @param op
@@ -2743,7 +2743,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		set(a);
 		applyOp(op);
 	}
-	
+
 	/**
 	 * Sets this vector to the result of applying an operator to a double value
 	 * @param op
@@ -2759,7 +2759,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			fill(op.apply(a));
 		}
 	}
-	
+
 	@Override
 	public double reduce(Op2 op, double init) {
 		int n=length();
@@ -2769,7 +2769,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	@Override
 	public double reduce(Op2 op) {
 		int n=length();
@@ -2779,12 +2779,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	@Override
 	public final AVector reduceSlices(Op2 op) {
 		return this.clone();
 	}
-	
+
 	@Override
 	public AVector reduceSlices(Op2 op, double init) {
 		AVector result=clone();
@@ -2794,12 +2794,12 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Adds a value to a specific element of the vector
-	 * 
+	 *
 	 * This function does not perform bounds checking, i.e. is an unsafe operation
-	 * 
+	 *
 	 * @param i
 	 * @param v
 	 */
@@ -2823,7 +2823,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		} else {
 			if (factor!=1.0) multiply(factor);
 			if (constant!=0.0) add(constant);
-		} 
+		}
 	}
 
 	@Override
@@ -2834,7 +2834,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addAt(i,constant);
 		}
 	}
-	
+
 	/**
 	 * Adds to this vector from a given double array.
 	 * @param data
@@ -2847,7 +2847,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			addAt(i,v);
 		}
 	}
-	
+
 	/**
 	 * Adds the values from a double[] array to this vector
 	 * @param data
@@ -2856,19 +2856,19 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		checkLength(data.length);
 		add(data,0);
 	}
-	
+
 	/**
 	 * Returns an exact clone of this vector, i.e. of the same type
 	 * @return
 	 */
 	@Override
 	public abstract AVector exactClone();
-	
+
 	@Override
 	public INDArray broadcast(int... targetShape) {
 		int tdims=targetShape.length;
 		if (tdims==0) throw new IllegalArgumentException(ErrorMessages.incompatibleBroadcast(this, targetShape));
-		
+
 		int len=this.length();
 		if (targetShape[tdims-1]!=len) throw new IllegalArgumentException(ErrorMessages.incompatibleBroadcast(this, targetShape));
 
@@ -2883,7 +2883,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			return SliceArray.repeat(s,n);
 		}
 	}
-	
+
 	@Override
 	public INDArray broadcastLike(INDArray target) {
 		if (target instanceof AVector) {
@@ -2893,7 +2893,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 		}
 		return broadcast(target.getShape());
 	}
-	
+
 	@Override
 	public AVector broadcastLike(AVector target) {
 		if (this.length()==target.length()) {
@@ -2902,7 +2902,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			throw new IllegalArgumentException(ErrorMessages.incompatibleBroadcast(this, target));
 		}
 	}
-	
+
 	@Override
 	public AMatrix broadcastLike(AMatrix target) {
 		int cc=target.columnCount();
@@ -2914,7 +2914,7 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 			throw new IllegalArgumentException(ErrorMessages.incompatibleBroadcast(this, target));
 		}
 	}
-	
+
 	@Override
 	public void validate() {
 		if (length()<0) throw new VectorzException("Illegal length! Length = "+length());
@@ -2923,19 +2923,19 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 
 	/**
 	 * Returns an Index indicating which elements of this vector are defined as non-sparse.
-	 * 
+	 *
 	 * A sparse index must be zero. A non-sparse element may be zero, but is typically expected be non-zero.
-	 * 
+	 *
 	 * @return
 	 */
 	public Index nonSparseIndex(){
 		// by default we just use the non-zero indices
 		return Index.of(nonZeroIndices());
 	}
-	
+
 	/**
 	 * Return an int array specifying the positions in this vector which are non-zero
-	 * 
+	 *
 	 * @return
 	 */
 	public int[] nonZeroIndices() {
@@ -2964,11 +2964,11 @@ public abstract class AVector extends AbstractArray<Double> implements IVector {
 	}
 
 	/**
-	 * Visits all non-zero elements of this vector. 
-	 * 
+	 * Visits all non-zero elements of this vector.
+	 *
 	 * Visitor may return a non-zero value to terminate early, which will return the given value.
 	 * Returns 0.0 otherwise.
-	 * 
+	 *
 	 * @param elementVisitor
 	 */
 	public abstract double visitNonZero(IndexedElementVisitor elementVisitor);
diff --git a/src/test/java/mikera/vectorz/TestVectorMath.java b/src/test/java/mikera/vectorz/TestVectorMath.java
index 3bcc2c91..7092fad4 100644
--- a/src/test/java/mikera/vectorz/TestVectorMath.java
+++ b/src/test/java/mikera/vectorz/TestVectorMath.java
@@ -6,7 +6,7 @@ import static org.junit.jupiter.api.Assertions.*;
 import mikera.indexz.Index;
 
 public class TestVectorMath {
-	
+
 	@Test public void testBasicAddCopy() {
 		assertEquals(Vector.of(3.0),Vector1.of(1.0).addCopy(Vector1.of(2.0)));
 	}
@@ -15,67 +15,67 @@ public class TestVectorMath {
 		Vector v1=Vector.of(0,1,2,3,4,5,6,7,8,9);
 		Vector v2=Vector.of(1,2,3);
 		Index ix=Index.of (2,7,4);
-		
+
 		assertEquals((1*2)+(2*7)+(3*4),v1.dotProduct(v2,ix),0.0);
 	}
-	
+
 	@Test public void testSubVectorMultiply() {
 		Vector v1=Vector.of(1,2,3,4,5);
 		Vector v2=Vector.of(2,3,4,5,6);
-		
+
 		AVector a=v1.subVector(2, 2);
 		AVector b=v2.subVector(3, 2);
 		a.multiply(b);
 		assertEquals(15.0,v1.get(2),0.0);
 		assertEquals(24.0,v1.get(3),0.0);
-		
+
 		assertEquals(Vector.of(5,6),b);
-		
+
 		v1=Vector.of(1,2,3,4,5);
 		v1.multiply(v2);
 		assertEquals(Vector.of(2,6,12,20,30),v1);
 		assertEquals(Vector.of(2,3,4,5,6),v2);
 	}
-	
+
 	@Test public void testSubVectorMultiply2() {
 		Vector v1=Vector.of(1,2,3);
 		AVector v2=Vector.of(1,2,3,4,5).subVector(1, 3);
-		
+
 		v1.multiply(v2);
 		assertEquals(Vector.of(2,6,12),v1);
 		assertEquals(Vector.of(2,3,4),v2);
 	}
-	
+
 	@Test public void testDotProduct() {
 		assertEquals(10.0,new Vector3(1,2,3).dotProduct(new Vector3(3,2,1)),0.000001);
 	}
-	
+
 	@Test public void testProjection() {
 		Vector3 v=Vector3.of(1,2,3);
 		v.projectToPlane(Vector3.of(1,0,0), 10);
 		assertTrue(Vector3.of(10,2,3).epsilonEquals(v));
 	}
-	
+
 	@Test public void testMagnitude() {
 		assertEquals(14.0,new Vector3(1,-2,3).magnitudeSquared(),0.000001);
 		assertEquals(5.0,new Vector2(3,4).magnitude(),0.000001);
 	}
-	
-	
+
+
 	public void doMultiplyTests(AVector v) {
 		v=v.exactClone();
 		if (!v.isFullyMutable()) return;
 		double m=v.magnitude();
 		v.multiply(2.0);
 		assertEquals(m*2.0, v.magnitude(),0.0001);
-		
+
 		AVector vv=v.exactClone();
 		vv.set(0.5);
 		v.multiply(vv);
-		
+
 		assertEquals(m, v.magnitude(),0.0001);
 	}
-	
+
 	public void doNormaliseTests(AVector v) {
 		v=v.clone();
 		v.normalise();
@@ -83,56 +83,56 @@ public class TestVectorMath {
 			assertEquals(1.0,v.magnitude(),0.0001);
 		}
 	}
-	
+
 	public void doFillTests(AVector v) {
 		v=v.clone();
 		v.fill(13.0);
 		int len=v.length();
 		for (int i=0; i<len; i++) {
 			assertEquals(13.0,v.get(i),0.0);
-		}	
+		}
 	}
-	
+
 	public void doAdditionTests(AVector v) {
 		v=v.clone();
 		AVector ones=v.clone();
 		ones.fill(1.0);
-		
+
 		AVector av=v.clone();
 		av.add(ones);
 		av.addMultiple(ones,1.5);
-		
+
 		int len=v.length();
 		for (int i=0; i<len; i++) {
 			assertEquals(v.get(i)+2.5,av.get(i),0.0001);
 		}
 	}
-	
+
 	public void doWeightedTests(AVector v) {
 		v=v.clone();
-		
+
 		AVector a=v.clone();
 		Vectorz.fillRandom(a);
 		AVector b=a.clone();
-		
+
 		b.addWeighted(v,0.0);
 		assertTrue(b.epsilonEquals(a));
-		
+
 		b.addWeighted(v,1.0);
 		assertTrue(b.epsilonEquals(v));
 
 	}
-	
+
 	public void doSubtractionTests(AVector v) {
 		v=v.clone();
 		AVector ones=v.clone();
 		ones.fill(1.0);
-		
+
 		AVector av=v.clone();
 		av.add(ones);
 		av.sub(ones);
 		assertEquals(v,av);
-		
+
 		av.addMultiple(ones,4);
 		av.subMultiple(ones,1.5);
 
@@ -141,10 +141,10 @@ public class TestVectorMath {
 			assertEquals(v.get(i)+2.5,av.get(i),0.0001);
 		}
 	}
-	
+
 	private void doMagnitudeTests(AVector v) {
 		assertEquals(v.magnitude(),Vectorz.create(v).magnitude(),0.000001);
-		
+
 	}
 	public void doGenericMaths(AVector v) {
 		doFillTests(v);
@@ -155,7 +155,7 @@ public class TestVectorMath {
 		doNormaliseTests(v);
 		doMagnitudeTests(v);
 	}
-	
+
 
 
 	@Test public void testGenericMaths() {
@@ -163,30 +163,37 @@ public class TestVectorMath {
 		doGenericMaths(Vectorz.create(1,2,3,4,5,6,7));
 		doGenericMaths(Vectorz.join(new Vector2(1.0,2.0),Vectorz.create(1,2,3,4,5,6,7)));
 		doGenericMaths(Vectorz.create(1,2,3,4,5,6,7).subVector(2,3));
-		
+
 		for (int dim=0; dim<10; dim++) {
 			AVector v=Vectorz.newVector(dim);
 			doGenericMaths(v);
 		}
 
 	}
-	
+
 	@Test public void test3DMath() {
 		Vector3 v=Vector3.of(1,2,3);
-		
+
 		Vector3 v2=v.clone();
 		v2.add(v);
 		v2.multiply(0.5);
-		
+
 		assertTrue(v.epsilonEquals(v2));
 	}
-	
+
 	@Test public void testAngle() {
 		Vector3 v=Vector3.of(1,2,3);
 		assertEquals(0.0, v.angle(v),0.0001);
-		
+
 		Vector3 v2=v.clone();
 		v2.negate();
 		assertEquals(Math.PI, v.angle(v2),0.0001);
 	}
+
+	@Test public void testNumericalstability() {
+		Vector v1 = Vector.of(-0.014672474935650826,-0.060921479016542435,0.10087049007415771,0.0153540950268507,0.03956206887960434,-0.07762990891933441,0.004401583690196276,-0.00851432979106903,-0.016627691686153412,-0.06950952857732773,0.01648535020649433,-0.021116597577929497,-0.06405960768461227,0.061415478587150574,-0.01646127924323082,0.03241392597556114,-0.0034250104799866676,0.08757651597261429,0.011445310898125172,-0.034614745527505875,0.03787026181817055,0.01969301886856556,-0.03634876385331154,-0.07617232948541641,-0.04989750683307648,0.018605932593345642,-0.0054916515946388245,0.029090989381074905,-0.01033382024616003,-0.0642751082777977,0.008981575258076191,0.03339681774377823,0.07036326825618744,-7.910212152637541E-4,0.025490863248705864,-0.03419310599565506,-0.02896084450185299,-0.04614390805363655,0.025531871244311333,-0.04316532984375954,-0.06870091706514359,-0.05159005895256996,-0.07589735835790634,-0.049602098762989044,0.02724762074649334,0.044040169566869736,0.030480124056339264,0.03235642611980438,0.03056095726788044,0.024091778323054314,-6.371267954818904E-4,0.02347361110150814,-0.002501036738976836,0.027920207008719444,-0.07511789351701736,0.012127351947128773,0.020146096125245094,0.006251493003219366,0.038035549223423004,-0.006672256626188755,0.031211068853735924,0.014829334802925587,-0.05150032788515091,-0.020497363060712814,0.04383742809295654,-0.03431278094649315,-0.03843933716416359,0.0150043535977602,-0.04187929630279541,0.059227555990219116,0.004107493907213211,-0.03497280925512314,-0.029103528708219528,0.003289624350145459,-0.08881937712430954,-0.008961683139204979,0.004717086907476187,0.02223982661962509,0.055549900978803635,-0.0161878764629364,0.024245597422122955,-0.01717694289982319,0.022717108950018883,0.06829257309436798,0.0635230541229248,0.004510267172008753,-0.06420350074768066,0.07498708367347717,0.07041779160499573,-0.06608670949935913,-0.043637268245220184,0.04252871870994568,0.013332311064004898,-0.008025133982300758,-0.030660146847367287,0.04573838785290718,-0.05960845202207565,0.020646514371037483,-0.05503839626908302,0.04121457040309906,0.08484749495983124,0.009258708916604519,0.01025861781090498,0.018627909943461418,-0.018932437524199486,0.008254818618297577,-0.02264932170510292,0.033970367163419724,0.06495217978954315,0.01382463425397873,0.0036916856188327074,-0.04240090772509575,-0.0912410244345665,-0.02600041963160038,0.02177176997065544,-0.014709528535604477,-0.02155478112399578,-0.04020718112587929,0.022628022357821465,-0.0989045575261116,0.009882892481982708,0.018138116225600243,0.03373369202017784,-0.06884878128767014,0.012620066292583942,-0.025955509394407272,-0.05680656433105469,0.0826617032289505,-0.05149027332663536,0.006291543133556843,0.025192342698574066,0.018419062718749046,-0.015112343244254589,0.023220116272568703,0.052635300904512405,0.005093525629490614,0.0545252189040184,0.039942674338817596,-0.019692622125148773,-0.03734058514237404,0.0588541179895401,-0.04563178867101669,0.04373469948768616,-0.04543791711330414,-0.05744180083274841,0.01720317266881466,-0.0854082927107811,-0.03623298183083534,-0.019212469458580017,0.05736434832215309,0.056226328015327454,0.004107156302779913,-0.027757612988352776,-0.03962142392992973,-0.04337155818939209,0.0029392745345830917,0.0712227076292038,-0.0540006048977375,0.01963852345943451,-0.05356534570455551,-0.052014924585819244,0.08905542641878128,0.017454756423830986,-0.011507829651236534,0.03509567677974701,0.0125507777556777,0.03138379380106926,0.024216271936893463,-0.050657689571380615,-0.025456245988607407,-0.01472635380923748,-0.08422835916280746,-0.09253020584583282,0.06076696142554283,-0.05572471395134926,0.013225755654275417,0.04623087868094444,0.01793598011136055,0.07384555786848068,0.008312879130244255,-0.0380166620016098,-0.046949807554483414,-0.05824628472328186,0.004187663085758686,-0.02620762400329113,-0.017816975712776184,0.03054753504693508,0.009359095245599747,0.011434297077357769,0.04951866343617439,-0.05787675082683563,0.03459971770644188,-0.07160191982984543,0.0027130518574267626,0.04751984775066376,-0.010564509779214859,0.08280697464942932,0.0769881084561348,-0.0314154289662838,0.04879987612366676,-0.013131959363818169,0.02883918583393097,-0.03760639578104019,-0.028443802148103714,-0.006969589274376631,-0.0415022112429142,0.018564512953162193,0.0040444862097501755,0.020479293540120125,-0.014797110110521317,0.048078637570142746,-0.07342076301574707,0.040382057428359985,0.06267718225717545,-0.03097708337008953,0.08996868133544922,0.026140186935663223,0.006135874427855015,0.10458917915821075,-0.0499354749917984,0.05887168273329735,0.0037474457640200853,-0.07183420658111572,-0.09926125407218933,-0.01864713430404663,-0.0078071593306958675,-0.009292719885706902,0.03932597488164902,0.06689969450235367,0.05718696862459183,0.04907668009400368,0.013830272480845451,-0.02062700130045414,0.06239774078130722,0.05830024927854538,-0.09595858305692673,0.027675090357661247,-0.033106349408626556,0.026968302205204964,0.054775115102529526,-0.03282015025615692,0.004955218639224768,-0.02857114002108574,-0.0373460091650486,0.06969446688890457,-0.029710909351706505,-0.03563770279288292,0.04336013272404671,-0.041999753564596176,-0.11235130578279495,0.027443813160061836,-0.01919204369187355,-5.070360493846238E-4,0.0020254417322576046,-0.043836191296577454,0.048074278980493546,-0.07363380491733551,0.07570996135473251,-0.01560026966035366,-0.062470607459545135,0.006533526815474033,0.003846443723887205,-0.058247700333595276,-0.03624064475297928,0.055345263332128525,0.036538902670145035,0.08495946228504181,-0.0964236706495285,0.006666433997452259,0.07158039510250092,0.0941976010799408,-0.02965710312128067,-0.04879981651902199,0.024249060079455376,0.04123895987868309,0.03856048732995987,-0.018006760627031326,-0.07077029347419739,0.034668929874897,-0.001403667381964624,0.08379256725311279,0.0028605484403669834,-0.013252174481749535,0.01622060313820839,-0.041202399879693985,-0.01771884225308895,-0.05962781980633736,0.05389392748475075,0.035289160907268524,-0.03918454051017761,0.011331198737025261,0.04514545947313309,-0.04957684874534607,-0.07102601230144501,0.035673972219228745,-0.008051143027842045,-0.06581827998161316,0.053875528275966644,-0.027136625722050667,0.011802584864199162,-0.012990973889827728,-0.07318586111068726,0.006141304038465023,-0.004976529162377119,0.017841869965195656,0.019139785319566727,-0.023918459191918373,0.03851857781410217,-0.05198444053530693,0.023321101441979408,0.008677342906594276,-0.057300787419080734,-0.04280127212405205,-0.04708677530288696,0.030500398948788643,-0.054328154772520065,-0.042221568524837494,0.046578165143728256,-0.028197424486279488,-0.05499295890331268,-0.010021836496889591,0.017890794202685356,0.03439932316541672,-0.026512403041124344,-0.0027062806766480207,0.02413947321474552,-0.018246743828058243,-0.010374336503446102,0.031514525413513184,0.08428751677274704,-0.017485179007053375,-0.04065853729844093,-0.028235774487257004,0.08206970989704132,0.012247757986187935,0.02642357163131237,0.06565714627504349,-0.06611126661300659,0.014827042818069458,0.09523377567529678,-0.013245407491922379,-0.024334093555808067,0.014618813060224056,-0.043163593858480453,-0.005913678091019392,-0.031274858862161636,-0.013277742080390453,0.047811511904001236,0.04316306859254837,0.06522604823112488,0.08264916390180588,0.013731591403484344,-0.04609978199005127,-0.056467678397893906,0.009641322307288647,0.014174544252455235,0.0187104232609272,0.0374431349337101,0.035957034677267075,0.021461954340338707,0.004401089157909155,-0.03889656439423561,-0.04913324490189552,-0.016310976818203926,-0.02966526336967945,0.01092937309294939,-0.05317120999097824,0.02729460783302784,-0.06934302300214767,-0.03283608332276344,0.012706915847957134,-0.07476099580526352,-0.07970266789197922,0.01850113272666931,0.035026825964450836,0.011481347493827343,-0.06983351707458496,0.06622762978076935,-0.004287383519113064,0.02485404536128044,0.013271123170852661,-0.009022021666169167,-0.05084630846977234,0.033457107841968536,-0.03561608865857124,0.003862060373649001,0.023318462073802948,-0.013211940415203571,-0.035802725702524185,-0.031690169125795364,0.11517245322465897,0.027899883687496185,0.09763495624065399,-0.01473498810082674,0.014655828475952148,-0.03888535499572754,0.05403246730566025,-0.01882738061249256,0.042323723435401917,-0.07802210748195648,-0.03363383561372757,-0.013654928654432297,0.0669025406241417,-0.006674893666058779,0.058964330703020096,0.07374133169651031,9.022817830555141E-4,-0.022628292441368103,0.016833335161209106,-0.029718732461333275,0.09526200592517853,0.017205052077770233,-0.03896680846810341,-0.042477115988731384,-0.016174279153347015,-0.007498868275433779,-0.010973247699439526,0.016591034829616547,0.007044659461826086,-0.026406990364193916,-0.026990795508027077,-0.01155818346887827,0.07962888479232788,0.02354908175766468,0.0635179951786995,0.049256835132837296,0.07857359200716019,-0.056579213589429855,-0.05932610109448433,0.006638250779360533,-0.0982515886425972,0.0035712309181690216,-0.028197873383760452,0.04056137055158615,0.0012351424666121602,0.02043057791888714,0.04588925838470459,-0.015251804143190384,0.04060744121670723,-0.025710562244057655,-0.03255010023713112,-0.07972458750009537,-0.021347513422369957,-0.047134578227996826,0.051518622785806656,0.14302733540534973,0.009764489717781544,-0.02981240302324295,0.020388782024383545,-0.006143294274806976,0.037423934787511826,-0.027064388617873192,0.01941872574388981,-0.014085566624999046,-0.004230785649269819,0.03489984944462776,0.019423896446824074,-0.010913330130279064,0.09083493798971176,0.057052984833717346,0.053897421807050705,0.02968442067503929,0.01682092808187008,-0.0473734475672245,-0.04326784610748291,-0.020668303593993187,-0.09364580363035202,0.027292029932141304,0.026699630543589592,0.08270170539617538,-0.0019637837540358305,-0.056955430656671524,0.0663859024643898,0.02924281917512417,-0.014903588220477104,-0.026133503764867783,0.033078085631132126,-0.012578188441693783,0.02650442160665989,-0.01001475378870964,-0.03540857136249542,0.018923230469226837,0.030105605721473694,-0.018976612016558647,0.04063315689563751,-0.006093418225646019,0.02502141334116459,-0.012332930229604244,-0.08086052536964417,4.161320684943348E-4,0.026283031329512596,-0.030388372018933296,-0.019412634894251823,-0.03689391165971756,0.018925093114376068,-0.03397482633590698,-0.07999216765165329,-0.04230911657214165,-0.025142911821603775,-0.006846408359706402,0.05908743292093277,-0.022003985941410065,0.040133245289325714,0.031386807560920715,-0.010388287715613842,0.05719384923577309,-0.005330725573003292,5.002868711017072E-4,-0.01610071398317814,-7.851929403841496E-4,-0.046576034277677536,0.03963885456323624);
+		Vector v2 = Vector.of(-0.014672474935650826,-0.060921479016542435,0.10087049007415771,0.0153540950268507,0.03956206887960434,-0.07762990891933441,0.004401583690196276,-0.00851432979106903,-0.016627691686153412,-0.06950952857732773,0.01648535020649433,-0.021116597577929497,-0.06405960768461227,0.061415478587150574,-0.01646127924323082,0.03241392597556114,-0.0034250104799866676,0.08757651597261429,0.011445310898125172,-0.034614745527505875,0.03787026181817055,0.01969301886856556,-0.03634876385331154,-0.07617232948541641,-0.04989750683307648,0.018605932593345642,-0.0054916515946388245,0.029090989381074905,-0.01033382024616003,-0.0642751082777977,0.008981575258076191,0.03339681774377823,0.07036326825618744,-7.910212152637541E-4,0.025490863248705864,-0.03419310599565506,-0.02896084450185299,-0.04614390805363655,0.025531871244311333,-0.04316532984375954,-0.06870091706514359,-0.05159005895256996,-0.07589735835790634,-0.049602098762989044,0.02724762074649334,0.044040169566869736,0.030480124056339264,0.03235642611980438,0.03056095726788044,0.024091778323054314,-6.371267954818904E-4,0.02347361110150814,-0.002501036738976836,0.027920207008719444,-0.07511789351701736,0.012127351947128773,0.020146096125245094,0.006251493003219366,0.038035549223423004,-0.006672256626188755,0.031211068853735924,0.014829334802925587,-0.05150032788515091,-0.020497363060712814,0.04383742809295654,-0.03431278094649315,-0.03843933716416359,0.0150043535977602,-0.04187929630279541,0.059227555990219116,0.004107493907213211,-0.03497280925512314,-0.029103528708219528,0.003289624350145459,-0.08881937712430954,-0.008961683139204979,0.004717086907476187,0.02223982661962509,0.055549900978803635,-0.0161878764629364,0.024245597422122955,-0.01717694289982319,0.022717108950018883,0.06829257309436798,0.0635230541229248,0.004510267172008753,-0.06420350074768066,0.07498708367347717,0.07041779160499573,-0.06608670949935913,-0.043637268245220184,0.04252871870994568,0.013332311064004898,-0.008025133982300758,-0.030660146847367287,0.04573838785290718,-0.05960845202207565,0.020646514371037483,-0.05503839626908302,0.04121457040309906,0.08484749495983124,0.009258708916604519,0.01025861781090498,0.018627909943461418,-0.018932437524199486,0.008254818618297577,-0.02264932170510292,0.033970367163419724,0.06495217978954315,0.01382463425397873,0.0036916856188327074,-0.04240090772509575,-0.0912410244345665,-0.02600041963160038,0.02177176997065544,-0.014709528535604477,-0.02155478112399578,-0.04020718112587929,0.022628022357821465,-0.0989045575261116,0.009882892481982708,0.018138116225600243,0.03373369202017784,-0.06884878128767014,0.012620066292583942,-0.025955509394407272,-0.05680656433105469,0.0826617032289505,-0.05149027332663536,0.006291543133556843,0.025192342698574066,0.018419062718749046,-0.015112343244254589,0.023220116272568703,0.052635300904512405,0.005093525629490614,0.0545252189040184,0.039942674338817596,-0.019692622125148773,-0.03734058514237404,0.0588541179895401,-0.04563178867101669,0.04373469948768616,-0.04543791711330414,-0.05744180083274841,0.01720317266881466,-0.0854082927107811,-0.03623298183083534,-0.019212469458580017,0.05736434832215309,0.056226328015327454,0.004107156302779913,-0.027757612988352776,-0.03962142392992973,-0.04337155818939209,0.0029392745345830917,0.0712227076292038,-0.0540006048977375,0.01963852345943451,-0.05356534570455551,-0.052014924585819244,0.08905542641878128,0.017454756423830986,-0.011507829651236534,0.03509567677974701,0.0125507777556777,0.03138379380106926,0.024216271936893463,-0.050657689571380615,-0.025456245988607407,-0.01472635380923748,-0.08422835916280746,-0.09253020584583282,0.06076696142554283,-0.05572471395134926,0.013225755654275417,0.04623087868094444,0.01793598011136055,0.07384555786848068,0.008312879130244255,-0.0380166620016098,-0.046949807554483414,-0.05824628472328186,0.004187663085758686,-0.02620762400329113,-0.017816975712776184,0.03054753504693508,0.009359095245599747,0.011434297077357769,0.04951866343617439,-0.05787675082683563,0.03459971770644188,-0.07160191982984543,0.0027130518574267626,0.04751984775066376,-0.010564509779214859,0.08280697464942932,0.0769881084561348,-0.0314154289662838,0.04879987612366676,-0.013131959363818169,0.02883918583393097,-0.03760639578104019,-0.028443802148103714,-0.006969589274376631,-0.0415022112429142,0.018564512953162193,0.0040444862097501755,0.020479293540120125,-0.014797110110521317,0.048078637570142746,-0.07342076301574707,0.040382057428359985,0.06267718225717545,-0.03097708337008953,0.08996868133544922,0.026140186935663223,0.006135874427855015,0.10458917915821075,-0.0499354749917984,0.05887168273329735,0.0037474457640200853,-0.07183420658111572,-0.09926125407218933,-0.01864713430404663,-0.0078071593306958675,-0.009292719885706902,0.03932597488164902,0.06689969450235367,0.05718696862459183,0.04907668009400368,0.013830272480845451,-0.02062700130045414,0.06239774078130722,0.05830024927854538,-0.09595858305692673,0.027675090357661247,-0.033106349408626556,0.026968302205204964,0.054775115102529526,-0.03282015025615692,0.004955218639224768,-0.02857114002108574,-0.0373460091650486,0.06969446688890457,-0.029710909351706505,-0.03563770279288292,0.04336013272404671,-0.041999753564596176,-0.11235130578279495,0.027443813160061836,-0.01919204369187355,-5.070360493846238E-4,0.0020254417322576046,-0.043836191296577454,0.048074278980493546,-0.07363380491733551,0.07570996135473251,-0.01560026966035366,-0.062470607459545135,0.006533526815474033,0.003846443723887205,-0.058247700333595276,-0.03624064475297928,0.055345263332128525,0.036538902670145035,0.08495946228504181,-0.0964236706495285,0.006666433997452259,0.07158039510250092,0.0941976010799408,-0.02965710312128067,-0.04879981651902199,0.024249060079455376,0.04123895987868309,0.03856048732995987,-0.018006760627031326,-0.07077029347419739,0.034668929874897,-0.001403667381964624,0.08379256725311279,0.0028605484403669834,-0.013252174481749535,0.01622060313820839,-0.041202399879693985,-0.01771884225308895,-0.05962781980633736,0.05389392748475075,0.035289160907268524,-0.03918454051017761,0.011331198737025261,0.04514545947313309,-0.04957684874534607,-0.07102601230144501,0.035673972219228745,-0.008051143027842045,-0.06581827998161316,0.053875528275966644,-0.027136625722050667,0.011802584864199162,-0.012990973889827728,-0.07318586111068726,0.006141304038465023,-0.004976529162377119,0.017841869965195656,0.019139785319566727,-0.023918459191918373,0.03851857781410217,-0.05198444053530693,0.023321101441979408,0.008677342906594276,-0.057300787419080734,-0.04280127212405205,-0.04708677530288696,0.030500398948788643,-0.054328154772520065,-0.042221568524837494,0.046578165143728256,-0.028197424486279488,-0.05499295890331268,-0.010021836496889591,0.017890794202685356,0.03439932316541672,-0.026512403041124344,-0.0027062806766480207,0.02413947321474552,-0.018246743828058243,-0.010374336503446102,0.031514525413513184,0.08428751677274704,-0.017485179007053375,-0.04065853729844093,-0.028235774487257004,0.08206970989704132,0.012247757986187935,0.02642357163131237,0.06565714627504349,-0.06611126661300659,0.014827042818069458,0.09523377567529678,-0.013245407491922379,-0.024334093555808067,0.014618813060224056,-0.043163593858480453,-0.005913678091019392,-0.031274858862161636,-0.013277742080390453,0.047811511904001236,0.04316306859254837,0.06522604823112488,0.08264916390180588,0.013731591403484344,-0.04609978199005127,-0.056467678397893906,0.009641322307288647,0.014174544252455235,0.0187104232609272,0.0374431349337101,0.035957034677267075,0.021461954340338707,0.004401089157909155,-0.03889656439423561,-0.04913324490189552,-0.016310976818203926,-0.02966526336967945,0.01092937309294939,-0.05317120999097824,0.02729460783302784,-0.06934302300214767,-0.03283608332276344,0.012706915847957134,-0.07476099580526352,-0.07970266789197922,0.01850113272666931,0.035026825964450836,0.011481347493827343,-0.06983351707458496,0.06622762978076935,-0.004287383519113064,0.02485404536128044,0.013271123170852661,-0.009022021666169167,-0.05084630846977234,0.033457107841968536,-0.03561608865857124,0.003862060373649001,0.023318462073802948,-0.013211940415203571,-0.035802725702524185,-0.031690169125795364,0.11517245322465897,0.027899883687496185,0.09763495624065399,-0.01473498810082674,0.014655828475952148,-0.03888535499572754,0.05403246730566025,-0.01882738061249256,0.042323723435401917,-0.07802210748195648,-0.03363383561372757,-0.013654928654432297,0.0669025406241417,-0.006674893666058779,0.058964330703020096,0.07374133169651031,9.022817830555141E-4,-0.022628292441368103,0.016833335161209106,-0.029718732461333275,0.09526200592517853,0.017205052077770233,-0.03896680846810341,-0.042477115988731384,-0.016174279153347015,-0.007498868275433779,-0.010973247699439526,0.016591034829616547,0.007044659461826086,-0.026406990364193916,-0.026990795508027077,-0.01155818346887827,0.07962888479232788,0.02354908175766468,0.0635179951786995,0.049256835132837296,0.07857359200716019,-0.056579213589429855,-0.05932610109448433,0.006638250779360533,-0.0982515886425972,0.0035712309181690216,-0.028197873383760452,0.04056137055158615,0.0012351424666121602,0.02043057791888714,0.04588925838470459,-0.015251804143190384,0.04060744121670723,-0.025710562244057655,-0.03255010023713112,-0.07972458750009537,-0.021347513422369957,-0.047134578227996826,0.051518622785806656,0.14302733540534973,0.009764489717781544,-0.02981240302324295,0.020388782024383545,-0.006143294274806976,0.037423934787511826,-0.027064388617873192,0.01941872574388981,-0.014085566624999046,-0.004230785649269819,0.03489984944462776,0.019423896446824074,-0.010913330130279064,0.09083493798971176,0.057052984833717346,0.053897421807050705,0.02968442067503929,0.01682092808187008,-0.0473734475672245,-0.04326784610748291,-0.020668303593993187,-0.09364580363035202,0.027292029932141304,0.026699630543589592,0.08270170539617538,-0.0019637837540358305,-0.056955430656671524,0.0663859024643898,0.02924281917512417,-0.014903588220477104,-0.026133503764867783,0.033078085631132126,-0.012578188441693783,0.02650442160665989,-0.01001475378870964,-0.03540857136249542,0.018923230469226837,0.030105605721473694,-0.018976612016558647,0.04063315689563751,-0.006093418225646019,0.02502141334116459,-0.012332930229604244,-0.08086052536964417,4.161320684943348E-4,0.026283031329512596,-0.030388372018933296,-0.019412634894251823,-0.03689391165971756,0.018925093114376068,-0.03397482633590698,-0.07999216765165329,-0.04230911657214165,-0.025142911821603775,-0.006846408359706402,0.05908743292093277,-0.022003985941410065,0.040133245289325714,0.031386807560920715,-0.010388287715613842,0.05719384923577309,-0.005330725573003292,5.002868711017072E-4,-0.01610071398317814,-7.851929403841496E-4,-0.046576034277677536,0.03963885456323624);
+
+		assertEquals(0.0, v1.angle(v2));
+	}
 }
