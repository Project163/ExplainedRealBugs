diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index ae109af8..e937b98f 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -49,6 +49,8 @@ jobs:
         if: matrix.os == 'ubuntu-latest'
       - uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3
         if: matrix.os == 'ubuntu-latest'
+        with:
+          driver-opts: network=host
       - name: setup-snapcraft
         if: matrix.os == 'ubuntu-latest'
         run: sudo snap install snapcraft --classic
diff --git a/.goreleaser.yaml b/.goreleaser.yaml
index 797087eb..fb66eb39 100644
--- a/.goreleaser.yaml
+++ b/.goreleaser.yaml
@@ -112,74 +112,27 @@ changelog:
     - title: Other work
       order: 9999
 
-dockers:
-  - image_templates:
-      - "goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-amd64"
-    dockerfile: Dockerfile
-    use: buildx
-    build_flag_templates:
-      - "--pull"
-      - "--label=io.artifacthub.package.readme-url=https://raw.githubusercontent.com/goreleaser/goreleaser/main/README.md"
-      - "--label=io.artifacthub.package.logo-url=https://goreleaser.com/static/avatar.png"
-      - '--label=io.artifacthub.package.maintainers=[{"name":"Carlos Alexandro Becker","email":"carlos@carlosbecker.dev"}]'
-      - "--label=io.artifacthub.package.license=MIT"
-      - "--label=org.opencontainers.image.description=Release engineering, simplified"
-      - "--label=org.opencontainers.image.created={{.Date}}"
-      - "--label=org.opencontainers.image.name={{.ProjectName}}"
-      - "--label=org.opencontainers.image.revision={{.FullCommit}}"
-      - "--label=org.opencontainers.image.version={{.Version}}"
-      - "--label=org.opencontainers.image.source={{.GitURL}}"
-      - "--platform=linux/amd64"
+dockers_v2:
+  - images:
+      - "goreleaser/goreleaser"
+      - "ghcr.io/goreleaser/goreleaser"
+    tags:
+      - "v{{ .Version }}"
+      - "{{ if .IsNightly }}nightly{{ end }}"
+      - "{{ if not .IsNightly }}latest{{ end }}"
     extra_files:
       - scripts/entrypoint.sh
-  - image_templates:
-      - "goreleaser/goreleaser:v{{ .Version }}-arm64"
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-arm64"
-    dockerfile: Dockerfile
-    use: buildx
-    build_flag_templates:
-      - "--pull"
-      - "--label=io.artifacthub.package.readme-url=https://raw.githubusercontent.com/goreleaser/goreleaser/main/README.md"
-      - "--label=io.artifacthub.package.logo-url=https://goreleaser.com/static/avatar.png"
-      - '--label=io.artifacthub.package.maintainers=[{"name":"Carlos Alexandro Becker","email":"carlos@carlosbecker.dev"}]'
-      - "--label=io.artifacthub.package.license=MIT"
-      - "--label=org.opencontainers.image.description=Release engineering, simplified"
-      - "--label=org.opencontainers.image.created={{.Date}}"
-      - "--label=org.opencontainers.image.name={{.ProjectName}}"
-      - "--label=org.opencontainers.image.revision={{.FullCommit}}"
-      - "--label=org.opencontainers.image.version={{.Version}}"
-      - "--label=org.opencontainers.image.source={{.GitURL}}"
-      - "--platform=linux/arm64"
-    goarch: arm64
-    extra_files:
-      - scripts/entrypoint.sh
-
-docker_manifests:
-  - name_template: "goreleaser/goreleaser:v{{ .Version }}"
-    image_templates:
-      - "goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "goreleaser/goreleaser:v{{ .Version }}-arm64"
-  - name_template: "ghcr.io/goreleaser/goreleaser:v{{ .Version }}"
-    image_templates:
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-arm64"
-  - name_template: "{{ if not .IsNightly }}goreleaser/goreleaser:latest{{ end }}"
-    image_templates:
-      - "goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "goreleaser/goreleaser:v{{ .Version }}-arm64"
-  - name_template: "{{ if not .IsNightly }}ghcr.io/goreleaser/goreleaser:latest{{ end }}"
-    image_templates:
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-arm64"
-  - name_template: "{{ if .IsNightly }}goreleaser/goreleaser:nightly{{ end }}"
-    image_templates:
-      - "goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "goreleaser/goreleaser:v{{ .Version }}-arm64"
-  - name_template: "{{ if .IsNightly }}ghcr.io/goreleaser/goreleaser:nightly{{ end }}"
-    image_templates:
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-amd64"
-      - "ghcr.io/goreleaser/goreleaser:v{{ .Version }}-arm64"
+    labels:
+      "io.artifacthub.package.readme-url": "https://raw.githubusercontent.com/goreleaser/goreleaser/main/README.md"
+      "io.artifacthub.package.logo-url": "https://goreleaser.com/static/avatar.png"
+      "io.artifacthub.package.maintainers": '[{"name":"Carlos Alexandro Becker","email":"carlos@carlosbecker.dev"}]'
+      "io.artifacthub.package.license": "MIT"
+      "org.opencontainers.image.description": "Release engineering, simplified"
+      "org.opencontainers.image.created": "{{.Date}}"
+      "org.opencontainers.image.name": "{{.ProjectName}}"
+      "org.opencontainers.image.revision": "{{.FullCommit}}"
+      "org.opencontainers.image.version": "{{.Version}}"
+      "org.opencontainers.image.source": "{{.GitURL}}"
 
 archives:
   - name_template: >-
diff --git a/Dockerfile b/Dockerfile
index 964c904f..32672cc3 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,5 +1,7 @@
 FROM golang:1.25.0-alpine@sha256:f18a072054848d87a8077455f0ac8a25886f2397f88bfdd222d6fafbb5bba440
 
+ARG TARGETPLATFORM
+
 RUN apk add --no-cache bash \
 	build-base \
 	curl \
@@ -21,5 +23,5 @@ CMD [ "-h" ]
 COPY scripts/entrypoint.sh /entrypoint.sh
 RUN chmod +x /entrypoint.sh
 
-COPY goreleaser_*.apk /tmp/
+COPY $TARGETPLATFORM/goreleaser_*.apk /tmp/
 RUN apk add --no-cache --allow-untrusted /tmp/goreleaser_*.apk
diff --git a/Taskfile.yml b/Taskfile.yml
index 31303e9d..034c7df2 100644
--- a/Taskfile.yml
+++ b/Taskfile.yml
@@ -20,6 +20,7 @@ tasks:
   docker:setup:
     desc: Setup Docker for multi-arch image builds
     cmds:
+      - "docker buildx create --name=goreleaser --driver-opt network=host --use || true"
       - docker run --privileged --rm tonistiigi/binfmt --install all
 
   build:
diff --git a/cmd/healthcheck.go b/cmd/healthcheck.go
index 54e85955..adca24a1 100644
--- a/cmd/healthcheck.go
+++ b/cmd/healthcheck.go
@@ -1,9 +1,11 @@
 package cmd
 
 import (
+	stdctx "context"
 	"errors"
 	"io"
 	"os/exec"
+	"strings"
 	"sync"
 
 	"github.com/caarlos0/log"
@@ -56,7 +58,7 @@ func newHealthcheckCmd() *healthcheckCmd {
 			for _, hc := range healthcheck.Healthcheckers {
 				_ = skip.Maybe(hc, func(ctx *context.Context) error {
 					for _, tool := range hc.Dependencies(ctx) {
-						if err := checkPath(tool); err != nil {
+						if err := checkPath(ctx, tool); err != nil {
 							errs = append(errs, err)
 						}
 					}
@@ -84,15 +86,23 @@ func newHealthcheckCmd() *healthcheckCmd {
 
 var toolsChecked = &sync.Map{}
 
-func checkPath(tool string) error {
+func checkPath(ctx stdctx.Context, tool string) error {
 	if _, ok := toolsChecked.LoadOrStore(tool, true); ok {
 		return nil
 	}
-	if _, err := exec.LookPath(tool); err != nil {
+	args := strings.Fields(tool)
+	if _, err := exec.LookPath(args[0]); err != nil {
 		st := log.Styles[log.ErrorLevel]
 		log.Warnf("%s %s - %s", st.Render("⚠"), codeStyle.Render(tool), st.Render("not present in path"))
 		return err
 	}
+	if len(args) > 1 {
+		if err := exec.CommandContext(ctx, args[0], args[1:]...).Run(); err != nil {
+			st := log.Styles[log.ErrorLevel]
+			log.Warnf("%s %s - %s", st.Render("⚠"), codeStyle.Render(tool), st.Render("command failed"))
+			return err
+		}
+	}
 	st := lipgloss.NewStyle().Foreground(lipgloss.Color("2")).Bold(true)
 	log.Infof("%s %s", st.Render("✓"), codeStyle.Render(tool))
 	return nil
diff --git a/cmd/healthcheck_test.go b/cmd/healthcheck_test.go
index 78fc9ac4..a3313154 100644
--- a/cmd/healthcheck_test.go
+++ b/cmd/healthcheck_test.go
@@ -30,3 +30,10 @@ func TestHealthcheckQuier(t *testing.T) {
 	cmd.cmd.SetArgs([]string{"-f", "testdata/good.yml", "--quiet"})
 	require.NoError(t, cmd.cmd.Execute())
 }
+
+func TestCheckPath(t *testing.T) {
+	require.NoError(t, checkPath(t.Context(), "go"))
+	require.NoError(t, checkPath(t.Context(), "docker buildx"))
+	require.Error(t, checkPath(t.Context(), "docker something-inalid"))
+	require.Error(t, checkPath(t.Context(), "some invalid command"))
+}
diff --git a/internal/artifact/artifact.go b/internal/artifact/artifact.go
index 2d6fd199..e2719da9 100644
--- a/internal/artifact/artifact.go
+++ b/internal/artifact/artifact.go
@@ -105,6 +105,8 @@ const (
 	PySdist
 	// Metadata is an internal goreleaser metadata JSON file.
 	Metadata
+	// DockerImageV2 is a container image in OCI format.
+	DockerImageV2
 	// lastMarker is used in tests to denote the last valid type.
 	// always add new types before this one.
 	lastMarker
@@ -134,7 +136,7 @@ func (t Type) String() string {
 		return "Binary"
 	case LinuxPackage:
 		return "Linux Package"
-	case PublishableDockerImage:
+	case PublishableDockerImage, DockerImageV2:
 		return "Docker Image"
 	case DockerImage:
 		return "Published Docker Image"
@@ -488,7 +490,7 @@ func relPath(a *Artifact) (string, error) {
 
 func shouldRelPath(a *Artifact) bool {
 	switch a.Type {
-	case DockerImage, DockerManifest, PublishableDockerImage:
+	case DockerImage, DockerManifest, PublishableDockerImage, DockerImageV2:
 		return false
 	default:
 		return filepath.IsAbs(a.Path)
diff --git a/internal/pipe/docker/docker.go b/internal/pipe/docker/docker.go
index bcc99a18..5fcb7ebf 100644
--- a/internal/pipe/docker/docker.go
+++ b/internal/pipe/docker/docker.go
@@ -12,6 +12,7 @@ import (
 	"path/filepath"
 	"slices"
 	"strings"
+	"sync"
 	"time"
 
 	"github.com/avast/retry-go/v4"
@@ -20,6 +21,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/experimental"
 	"github.com/goreleaser/goreleaser/v2/internal/gio"
 	"github.com/goreleaser/goreleaser/v2/internal/ids"
+	"github.com/goreleaser/goreleaser/v2/internal/logext"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe"
 	"github.com/goreleaser/goreleaser/v2/internal/semerrgroup"
 	"github.com/goreleaser/goreleaser/v2/internal/skips"
@@ -58,8 +60,23 @@ func (Pipe) Dependencies(ctx *context.Context) []string {
 
 // Default sets the pipe defaults.
 func (Pipe) Default(ctx *context.Context) error {
+	var warnOnce sync.Once
 	ids := ids.New("dockers")
 	for i := range ctx.Config.Dockers {
+		// TODO: properly deprecate this.
+		warnOnce.Do(func() {
+			log.Warn(
+				logext.Keyword("dockers") +
+					logext.Warning(" and ") +
+					logext.Keyword("docker_manifests") +
+					logext.Warning(" are being phased out and will eventually be replaced by ") +
+					logext.Keyword("dockers_v2") +
+					logext.Warning(", check ") +
+					logext.URL("https://goreleaser.com/deprecations#dockers") +
+					logext.Warning(" for more info"),
+			)
+		})
+
 		docker := &ctx.Config.Dockers[i]
 
 		if docker.ID != "" {
diff --git a/internal/pipe/docker/docker_test.go b/internal/pipe/docker/docker_test.go
index 317068f8..8d7396c9 100644
--- a/internal/pipe/docker/docker_test.go
+++ b/internal/pipe/docker/docker_test.go
@@ -36,7 +36,7 @@ func start(tb testing.TB) {
 // TODO: this test is too big... split in smaller tests? Mainly the manifest ones...
 func TestRunPipe(t *testing.T) {
 	testlib.CheckDocker(t)
-	testlib.SkipIfWindows(t, "images only available for windows")
+	testlib.SkipIfWindows(t, "registry images only available for windows")
 	type errChecker func(*testing.T, error)
 	shouldErr := func(msg string) errChecker {
 		return func(t *testing.T, err error) {
diff --git a/internal/pipe/docker/manifest.go b/internal/pipe/docker/manifest.go
index 3b85cc7f..5f1cdfd7 100644
--- a/internal/pipe/docker/manifest.go
+++ b/internal/pipe/docker/manifest.go
@@ -7,6 +7,7 @@ import (
 	"math"
 	"slices"
 	"strings"
+	"sync"
 	"time"
 
 	"github.com/agnivade/levenshtein"
@@ -14,6 +15,7 @@ import (
 	"github.com/caarlos0/log"
 	"github.com/goreleaser/goreleaser/v2/internal/artifact"
 	"github.com/goreleaser/goreleaser/v2/internal/ids"
+	"github.com/goreleaser/goreleaser/v2/internal/logext"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe"
 	"github.com/goreleaser/goreleaser/v2/internal/semerrgroup"
 	"github.com/goreleaser/goreleaser/v2/internal/skips"
@@ -46,8 +48,22 @@ func (ManifestPipe) Dependencies(ctx *context.Context) []string {
 
 // Default sets the pipe defaults.
 func (ManifestPipe) Default(ctx *context.Context) error {
+	var warnOnce sync.Once
 	ids := ids.New("docker_manifests")
 	for i := range ctx.Config.DockerManifests {
+		// TODO: properly deprecate this.
+		warnOnce.Do(func() {
+			log.Warn(
+				logext.Keyword("dockers") +
+					logext.Warning(" and ") +
+					logext.Keyword("docker_manifests") +
+					logext.Warning(" are being phased out and will eventually be replaced by ") +
+					logext.Keyword("dockers_v2") +
+					logext.Warning(", check ") +
+					logext.URL("https://goreleaser.com/deprecations#dockers") +
+					logext.Warning(" for more info"),
+			)
+		})
 		manifest := &ctx.Config.DockerManifests[i]
 		if manifest.ID != "" {
 			ids.Inc(manifest.ID)
diff --git a/internal/pipe/docker/v2/docker.go b/internal/pipe/docker/v2/docker.go
new file mode 100644
index 00000000..24f26d9e
--- /dev/null
+++ b/internal/pipe/docker/v2/docker.go
@@ -0,0 +1,414 @@
+// Package docker provides the v2 of GoReleaser's docker pipe.
+package docker
+
+import (
+	"bytes"
+	"cmp"
+	"fmt"
+	"io"
+	"maps"
+	"os"
+	"os/exec"
+	"path"
+	"path/filepath"
+	"regexp"
+	"runtime"
+	"slices"
+	"strings"
+	"time"
+
+	"github.com/avast/retry-go/v4"
+	"github.com/caarlos0/log"
+	"github.com/goreleaser/goreleaser/v2/internal/artifact"
+	"github.com/goreleaser/goreleaser/v2/internal/gerrors"
+	"github.com/goreleaser/goreleaser/v2/internal/gio"
+	"github.com/goreleaser/goreleaser/v2/internal/ids"
+	"github.com/goreleaser/goreleaser/v2/internal/logext"
+	"github.com/goreleaser/goreleaser/v2/internal/pipe"
+	"github.com/goreleaser/goreleaser/v2/internal/semerrgroup"
+	"github.com/goreleaser/goreleaser/v2/internal/skips"
+	"github.com/goreleaser/goreleaser/v2/internal/tmpl"
+	"github.com/goreleaser/goreleaser/v2/pkg/config"
+	"github.com/goreleaser/goreleaser/v2/pkg/context"
+)
+
+var dockerDigestPattern = regexp.MustCompile("sha256:[a-z0-9]{64}")
+
+// Pipe v2 of dockers pipe.
+type Pipe struct{}
+
+// String implements pipeline.Piper.
+func (p Pipe) String() string { return "docker images (v2)" }
+
+// Dependencies implements healthcheck.Healthchecker.
+func (Pipe) Dependencies(*context.Context) []string { return []string{"docker buildx"} }
+
+// Skip implements Skipper.
+func (Pipe) Skip(ctx *context.Context) bool {
+	return len(ctx.Config.DockersV2) == 0 || skips.Any(ctx, skips.Docker)
+}
+
+// Default implements defaults.Defaulter.
+func (Pipe) Default(ctx *context.Context) error {
+	ids := ids.New("dockersv2")
+	for i := range ctx.Config.DockersV2 {
+		docker := &ctx.Config.DockersV2[i]
+		if docker.ID == "" {
+			docker.ID = ctx.Config.ProjectName
+		}
+		if docker.Dockerfile == "" {
+			docker.Dockerfile = "Dockerfile"
+		}
+		if len(docker.Tags) == 0 {
+			docker.Tags = []string{"{{.Tag}}"}
+		}
+		if len(docker.Platforms) == 0 {
+			docker.Platforms = []string{"linux/amd64", "linux/arm64"}
+		}
+		docker.Retry.Attempts = cmp.Or(docker.Retry.Attempts, 10)
+		docker.Retry.Delay = cmp.Or(docker.Retry.Delay, 10*time.Second)
+		docker.Retry.MaxDelay = cmp.Or(docker.Retry.MaxDelay, 5*time.Minute)
+		ids.Inc(docker.ID)
+	}
+	return ids.Validate()
+}
+
+// Run implements pipeline.Piper.
+func (p Pipe) Run(ctx *context.Context) error {
+	if !ctx.Snapshot {
+		return pipe.Skip("non-snapshot build")
+	}
+
+	warnExperimental()
+	log.Warn("snapshot build: will not push or load any images")
+
+	if runtime.GOOS == "windows" {
+		return pipe.Skip("library/registry is not available for windows")
+	}
+
+	g := semerrgroup.NewSkipAware(semerrgroup.New(ctx.Parallelism))
+	for _, d := range ctx.Config.DockersV2 {
+		g.Go(func() error {
+			// XXX: could potentially use `--output=type=local,dest=./dist/dockers/id/` to output the file tree?
+			// Not sure if useful or not...
+			return buildAndPublish(ctx, d)
+		})
+	}
+	return g.Wait()
+}
+
+// Publish implements publish.Publisher.
+func (Pipe) Publish(ctx *context.Context) error {
+	warnExperimental()
+	g := semerrgroup.NewSkipAware(semerrgroup.New(ctx.Parallelism))
+	for _, d := range ctx.Config.DockersV2 {
+		g.Go(func() error {
+			return buildAndPublish(ctx, d, "--push")
+		})
+	}
+	return g.Wait()
+}
+
+func buildAndPublish(ctx *context.Context, d config.DockerV2, extraArgs ...string) error {
+	if len(d.Platforms) == 0 {
+		return pipe.Skip("no platforms to build")
+	}
+
+	arg, images, err := makeArgs(ctx, d, extraArgs)
+	if err != nil {
+		return err
+	}
+
+	wd, err := makeContext(d, contextArtifacts(ctx, d))
+	if err != nil {
+		return err
+	}
+	defer os.RemoveAll(wd)
+
+	out, err := retry.DoWithData(
+		func() (string, error) {
+			log.WithField("id", d.ID).
+				Infof("creating %d images", len(images))
+			cmd := exec.CommandContext(ctx, "docker", arg...)
+			cmd.Dir = wd
+			cmd.Env = append(ctx.Env.Strings(), cmd.Environ()...)
+			var b bytes.Buffer
+			w := gio.Safe(&b)
+			cmd.Stderr = io.MultiWriter(logext.NewWriter(), w)
+			cmd.Stdout = io.MultiWriter(logext.NewWriter(), w)
+			if err := cmd.Run(); err != nil {
+				return "", gerrors.Wrap(
+					err,
+					"could not build and publish docker image",
+					"args", strings.Join(cmd.Args, " "),
+					"id", d.ID,
+					"image", images[0],
+					"output", b.String(),
+				)
+			}
+			return b.String(), nil
+		},
+		retry.RetryIf(isRetriableManifestCreate),
+		retry.Attempts(d.Retry.Attempts),
+		retry.Delay(d.Retry.Delay),
+		retry.MaxDelay(d.Retry.MaxDelay),
+		retry.LastErrorOnly(true),
+	)
+	if err != nil {
+		return err
+	}
+
+	digest := dockerDigestPattern.FindString(out)
+	if digest == "" {
+		return gerrors.Wrap(
+			err,
+			"could not find digest in output",
+			"id", d.ID,
+			"image", images[0],
+			"output", out,
+		)
+	}
+
+	for _, img := range images {
+		log.WithField("image", img).
+			WithField("id", d.ID).
+			WithField("digest", digest).
+			Info("created image")
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name: img,
+			Path: img,
+			Type: artifact.DockerImageV2,
+			Extra: map[string]any{
+				artifact.ExtraID:     d.ID,
+				artifact.ExtraDigest: digest,
+			},
+		})
+
+		// XXX: should we extract the SBOM and add its artifact as well?
+		// https://docs.docker.com/build/metadata/attestations/sbom/#inspecting-sboms
+	}
+
+	return nil
+}
+
+func makeArgs(ctx *context.Context, d config.DockerV2, extraArgs []string) ([]string, []string, error) {
+	tpl := tmpl.New(ctx)
+	if err := tpl.ApplyAll(
+		&d.Dockerfile,
+	); err != nil {
+		return nil, nil, fmt.Errorf("invalid dockerfile: %w", err)
+	}
+	if strings.TrimSpace(d.Dockerfile) == "" {
+		return nil, nil, pipe.Skip("no dockerfile")
+	}
+	images, err := tpl.Slice(d.Images, tmpl.NonEmpty())
+	if err != nil {
+		return nil, nil, fmt.Errorf("invalid images: %w", err)
+	}
+	if len(images) == 0 {
+		return nil, nil, pipe.Skip("no images")
+	}
+	tags, err := tpl.Slice(d.Tags, tmpl.NonEmpty())
+	if err != nil {
+		return nil, nil, fmt.Errorf("invalid tags: %w", err)
+	}
+	if len(tags) == 0 {
+		tags = []string{"latest"}
+	}
+	allImages := makeImageList(images, tags)
+
+	labelFlags, err := tplMapFlags(tpl, "--label", d.Labels)
+	if err != nil {
+		return nil, nil, fmt.Errorf("invalid labels: %w", err)
+	}
+
+	buildFlags, err := tplMapFlags(tpl, "--build-arg", d.BuildArgs)
+	if err != nil {
+		return nil, nil, fmt.Errorf("invalid build args: %w", err)
+	}
+
+	arg := []string{
+		"buildx",
+		"build",
+		"--platform", strings.Join(d.Platforms, ","),
+		"--attest=type=sbom",
+	}
+	for _, img := range allImages {
+		arg = append(arg, "-t", img)
+	}
+	arg = append(arg, extraArgs...)
+	arg = append(arg, labelFlags...)
+	arg = append(arg, buildFlags...)
+	arg = append(arg, ".")
+	return arg, allImages, nil
+}
+
+func makeImageList(imgs, tags []string) []string {
+	result := map[string]struct{}{}
+	for _, i := range imgs {
+		for _, t := range tags {
+			result[i+":"+t] = struct{}{}
+		}
+	}
+	keys := slices.Collect(maps.Keys(result))
+	slices.Sort(keys)
+	return keys
+}
+
+// makeContext creates a new temporary directory, copies the artifacts and any
+// extra files, returning its path.
+//
+// The caller is responsible for removing the temporary directory.
+func makeContext(d config.DockerV2, artifacts []*artifact.Artifact) (string, error) {
+	if len(artifacts) == 0 {
+		log.Warn("no binaries or packages found for the given platform - COPY/ADD may not work")
+	}
+
+	tmp, err := os.MkdirTemp("", "goreleaserdocker")
+	if err != nil {
+		return "", fmt.Errorf("failed to create temporary dir: %w", err)
+	}
+
+	if err := gio.Copy(d.Dockerfile, filepath.Join(tmp, "Dockerfile")); err != nil {
+		return "", fmt.Errorf("failed to copy dockerfile: %w: %s", err, d.ID)
+	}
+
+	for _, file := range d.ExtraFiles {
+		if err := os.MkdirAll(filepath.Join(tmp, filepath.Dir(file)), 0o755); err != nil {
+			return "", fmt.Errorf("failed to copy extra file '%s': %w", file, err)
+		}
+		if err := gio.Copy(file, filepath.Join(tmp, file)); err != nil {
+			return "", fmt.Errorf("failed to copy extra file '%s': %w", file, err)
+		}
+	}
+
+	for _, art := range artifacts {
+		plat, err := toPlatform(art)
+		if err != nil {
+			return "", fmt.Errorf("failed to make dir for artifact: %w", err)
+		}
+
+		target := filepath.Join(tmp, plat, art.Name)
+		if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil {
+			return "", fmt.Errorf("failed to make dir for artifact: %w", err)
+		}
+
+		if err := gio.Copy(art.Path, target); err != nil {
+			return "", fmt.Errorf("failed to copy artifact: %w", err)
+		}
+	}
+
+	return tmp, nil
+}
+
+func contextArtifacts(ctx *context.Context, d config.DockerV2) []*artifact.Artifact {
+	var platFilters []artifact.Filter
+	for _, p := range d.Platforms {
+		plat := parsePlatform(p)
+		filters := []artifact.Filter{
+			artifact.ByGoos(plat.os),
+			artifact.ByGoarch(plat.arch),
+		}
+		if plat.arm != "" {
+			filters = append(filters, artifact.ByGoarm(plat.arm))
+		}
+		platFilters = append(platFilters, artifact.And(filters...))
+	}
+
+	filters := []artifact.Filter{
+		artifact.Or(platFilters...),
+		artifact.Or(
+			artifact.ByType(artifact.Binary),
+			artifact.ByType(artifact.LinuxPackage),
+			artifact.ByType(artifact.CArchive),
+			artifact.ByType(artifact.CShared),
+		),
+	}
+	if len(d.IDs) > 0 {
+		filters = append(filters, artifact.ByIDs(d.IDs...))
+	}
+
+	artifacts := ctx.Artifacts.Filter(
+		artifact.Or(
+			artifact.And(filters...),
+			artifact.ByType(artifact.PyWheel),
+		),
+	)
+
+	return artifacts.List()
+}
+
+func toPlatform(a *artifact.Artifact) (string, error) {
+	var parts []string
+	switch a.Goos {
+	case "linux", "darwin", "windows":
+		parts = append(parts, a.Goos)
+	default:
+		return "", fmt.Errorf("unsupported OS: %q", a.Goos)
+	}
+	switch a.Goarch {
+	case "amd64", "arm64", "386", "ppc64le", "s390x", "riscv64":
+		parts = append(parts, a.Goarch)
+	case "arm":
+		parts = append(parts, a.Goarch)
+		switch a.Goarm {
+		case "6", "7":
+			parts = append(parts, "v"+a.Goarm)
+		default:
+			return "", fmt.Errorf("unsupported arch: arm/v%q", a.Goarm)
+		}
+	default:
+		return "", fmt.Errorf("unsupported arch: %q", a.Goarch)
+	}
+	return path.Join(parts...), nil
+}
+
+type platform struct {
+	os, arch string
+	arm      string
+}
+
+func parsePlatform(p string) platform {
+	parts := strings.Split(p, "/")
+	result := platform{
+		os:   parts[0],
+		arch: parts[1],
+	}
+	if len(parts) == 3 {
+		result.arm = strings.TrimPrefix(parts[2], "v")
+	}
+	return result
+}
+
+// tplMapFlags templates all keys and values in the given map, returning a
+// slice of them with the [flag] prefix.
+//
+// It'll also sort keys so the resulting slice is always in the same order.
+// Finally, it will also skip entries with either an empty key or value.
+func tplMapFlags(tpl *tmpl.Template, flag string, m map[string]string) ([]string, error) {
+	var result []string
+	keys := slices.Collect(maps.Keys(m))
+	slices.Sort(keys)
+	for _, k := range keys {
+		v := m[k]
+		if err := tpl.ApplyAll(&k, &v); err != nil {
+			return nil, fmt.Errorf("docker: %w", err)
+		}
+		if strings.TrimSpace(k) == "" || strings.TrimSpace(v) == "" {
+			continue
+		}
+		result = append(result, flag, k+"="+v)
+	}
+	return result, nil
+}
+
+func isRetriableManifestCreate(err error) bool {
+	out := gerrors.DetailsOf(err)["output"].(string)
+	return strings.Contains(out, "manifest verification failed for digest")
+}
+
+func warnExperimental() {
+	log.WithField("details", `Keep an eye on the release notes if you wish to rely on this for production builds.
+Please provide any feedback you might have at https://github.com/orgs/goreleaser/discussions/6005`).
+		Warn(logext.Warning("dockers_v2 is experimental and subject to change"))
+}
diff --git a/internal/pipe/docker/v2/docker_integration_test.go b/internal/pipe/docker/v2/docker_integration_test.go
new file mode 100644
index 00000000..c22b6780
--- /dev/null
+++ b/internal/pipe/docker/v2/docker_integration_test.go
@@ -0,0 +1,167 @@
+package docker
+
+import (
+	"os"
+	"path/filepath"
+	"slices"
+	"testing"
+
+	"github.com/goreleaser/goreleaser/v2/internal/artifact"
+	"github.com/goreleaser/goreleaser/v2/internal/gerrors"
+	"github.com/goreleaser/goreleaser/v2/internal/gio"
+	"github.com/goreleaser/goreleaser/v2/internal/testctx"
+	"github.com/goreleaser/goreleaser/v2/internal/testlib"
+	"github.com/goreleaser/goreleaser/v2/pkg/config"
+	"github.com/stretchr/testify/require"
+)
+
+const expectedDigest = "sha256:4bcff63911fcb4448bd4fdacec207030997caf25e9bea4045fa6c8c44de311d1"
+
+func TestRun(t *testing.T) {
+	testlib.CheckDocker(t)
+	testlib.SkipIfWindows(t, "registry images only available for windows")
+
+	dist := t.TempDir()
+	binpath := filepath.Join(dist, "mybin")
+	require.NoError(t, os.WriteFile(binpath, []byte("#!/bin/sh\necho hi"), 0o755))
+	require.NoError(t, gio.Copy("./testdata/Dockerfile", filepath.Join(dist, "Dockerfile")))
+	ctx := testctx.NewWithCfg(config.Project{
+		ProjectName: "dockerv2",
+		Dist:        dist,
+		DockersV2: []config.DockerV2{
+			{
+				ID:         "myimg",
+				Dockerfile: "./testdata/Dockerfile",
+				Images:     []string{"image1", "image2"},
+				Tags:       []string{"tag1", "tag2"},
+				ExtraFiles: []string{"./testdata/foo.conf"},
+				IDs:        []string{"id1"},
+			},
+			{
+				ID:         "clean",
+				Dockerfile: "./testdata/Dockerfile.clean",
+				Images:     []string{"image3", "image4"},
+				Tags:       []string{"tag3"},
+				ExtraFiles: []string{"./testdata/foo.conf"},
+				IDs:        []string{"nopenopenope"},
+			},
+		},
+	}, testctx.Snapshot)
+	for _, arch := range []string{"amd64", "arm64"} {
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name:   "mybin",
+			Path:   binpath,
+			Goos:   "linux",
+			Goarch: arch,
+			Type:   artifact.Binary,
+			Extra: artifact.Extras{
+				artifact.ExtraID: "id1",
+			},
+		})
+	}
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	err := Pipe{}.Run(ctx)
+	require.NoError(t, err, "message: %s, output: %v", gerrors.MessageOf(err), gerrors.DetailsOf(err))
+
+	images := ctx.Artifacts.Filter(
+		artifact.And(
+			artifact.ByType(artifact.DockerImageV2),
+			artifact.ByIDs("myimg"),
+		),
+	).List()
+	require.Len(t, images, 4)
+	require.Equal(t, []string{
+		"image1:tag1",
+		"image1:tag2",
+		"image2:tag1",
+		"image2:tag2",
+	}, names(images))
+	for _, img := range images {
+		require.Equal(t, expectedDigest, artifact.ExtraOr(*img, artifact.ExtraDigest, ""))
+	}
+
+	require.Equal(t, []string{
+		"image3:tag3",
+		"image4:tag3",
+	}, names(
+		ctx.Artifacts.Filter(
+			artifact.And(
+				artifact.ByType(artifact.DockerImageV2),
+				artifact.ByIDs("clean"),
+			),
+		).List(),
+	))
+}
+
+func TestPublish(t *testing.T) {
+	testlib.CheckDocker(t)
+	testlib.SkipIfWindows(t, "registry images only available for windows")
+
+	testlib.StartRegistry(t, "registry-v2", "5060")
+	testlib.StartRegistry(t, "alt_registry-v2", "5061")
+
+	dist := t.TempDir()
+	binpath := filepath.Join(dist, "mybin")
+	require.NoError(t, os.WriteFile(binpath, []byte("#!/bin/sh\necho hi"), 0o755))
+	require.NoError(t, gio.Copy("./testdata/Dockerfile", filepath.Join(dist, "Dockerfile")))
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			ProjectName: "dockerv2",
+			Dist:        dist,
+			DockersV2: []config.DockerV2{
+				{
+					ID:         "myimg",
+					Dockerfile: "./testdata/Dockerfile",
+					Images:     []string{"localhost:5060/foo", "localhost:5061/bar"},
+					Tags:       []string{"latest", "v{{.Version}}", "{{if .IsNightly}}nightly{{end}}"},
+					ExtraFiles: []string{"./testdata/foo.conf"},
+					IDs:        []string{"id1"},
+				},
+			},
+		},
+		testctx.WithVersion("1.0.0"),
+		testctx.WithCurrentTag("v1.0.0"),
+		testctx.WithCommit("a1b2c3d4"),
+		testctx.WithSemver(1, 0, 0, ""),
+	)
+	for _, arch := range []string{"amd64", "arm64"} {
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name:   "mybin",
+			Path:   binpath,
+			Goos:   "linux",
+			Goarch: arch,
+			Type:   artifact.Binary,
+			Extra: artifact.Extras{
+				artifact.ExtraID: "id1",
+			},
+		})
+	}
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	testlib.AssertSkipped(t, Pipe{}.Run(ctx)) // should be skipped in non-snapshot builds
+	err := Pipe{}.Publish(ctx)
+	require.NoError(t, err, "message: %s, output: %v", gerrors.MessageOf(err), gerrors.DetailsOf(err))
+
+	images := ctx.Artifacts.Filter(artifact.ByType(artifact.DockerImageV2)).List()
+	require.Len(t, images, 4)
+	require.Equal(t, []string{
+		"localhost:5060/foo:latest",
+		"localhost:5060/foo:v1.0.0",
+		"localhost:5061/bar:latest",
+		"localhost:5061/bar:v1.0.0",
+	}, names(images))
+
+	for _, img := range images {
+		require.Equal(t, expectedDigest, artifact.ExtraOr(*img, artifact.ExtraDigest, ""))
+	}
+}
+
+func names(in []*artifact.Artifact) []string {
+	out := make([]string, 0, len(in))
+	for _, art := range in {
+		out = append(out, art.Name)
+	}
+	slices.Sort(out)
+	return out
+}
diff --git a/internal/pipe/docker/v2/docker_test.go b/internal/pipe/docker/v2/docker_test.go
new file mode 100644
index 00000000..f9a18878
--- /dev/null
+++ b/internal/pipe/docker/v2/docker_test.go
@@ -0,0 +1,258 @@
+package docker
+
+import (
+	"testing"
+	"time"
+
+	"github.com/goreleaser/goreleaser/v2/internal/artifact"
+	"github.com/goreleaser/goreleaser/v2/internal/skips"
+	"github.com/goreleaser/goreleaser/v2/internal/testctx"
+	"github.com/goreleaser/goreleaser/v2/internal/testlib"
+	"github.com/goreleaser/goreleaser/v2/pkg/config"
+	"github.com/stretchr/testify/require"
+)
+
+func TestString(t *testing.T) {
+	require.NotEmpty(t, Pipe{}.String())
+}
+
+func TestDependencies(t *testing.T) {
+	require.Equal(t, []string{"docker buildx"}, Pipe{}.Dependencies(nil))
+}
+
+func TestSkip(t *testing.T) {
+	t.Run("set", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			DockersV2: []config.DockerV2{{}},
+		}, testctx.Skip(skips.Docker))
+		require.True(t, Pipe{}.Skip(ctx))
+	})
+	t.Run("no dockers", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{})
+		require.True(t, Pipe{}.Skip(ctx))
+	})
+	t.Run("don't skip", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			DockersV2: []config.DockerV2{{}},
+		})
+		require.False(t, Pipe{}.Skip(ctx))
+	})
+}
+
+func TestDefault(t *testing.T) {
+	ctx := testctx.NewWithCfg(config.Project{
+		ProjectName: "dockerv2",
+		DockersV2:   []config.DockerV2{{}},
+	})
+	require.NoError(t, Pipe{}.Default(ctx))
+	d := ctx.Config.DockersV2[0]
+	require.NotEmpty(t, d.ID)
+	require.NotEmpty(t, d.Dockerfile)
+	require.NotEmpty(t, d.Tags)
+	require.NotEmpty(t, d.Platforms)
+}
+
+func TestMakeArgs(t *testing.T) {
+	t.Run("tmpl error", func(t *testing.T) {
+		for name, mod := range map[string]func(d *config.DockerV2){
+			"dockerfile": func(d *config.DockerV2) { d.Dockerfile = "{{.Nope}}" },
+			"images":     func(d *config.DockerV2) { d.Images = []string{"{{.Nope}}"} },
+			"tags":       func(d *config.DockerV2) { d.Tags = []string{"{{.Nope}}"} },
+			"labels":     func(d *config.DockerV2) { d.Labels = map[string]string{"foo": "{{.Nope}}"} },
+			"build args": func(d *config.DockerV2) { d.BuildArgs = map[string]string{"{{.Nope}}": "bar"} },
+		} {
+			t.Run(name, func(t *testing.T) {
+				ctx := testctx.New()
+				d := config.DockerV2{
+					Dockerfile: "Dockerfile",
+					Images:     []string{"ghcr.io/foo/bar"},
+					Tags:       []string{"latest", "v{{.Version}}"},
+				}
+				mod(&d)
+				_, _, err := makeArgs(ctx, d, nil)
+				testlib.RequireTemplateError(t, err)
+			})
+		}
+	})
+	t.Run("no dockerfile", func(t *testing.T) {
+		_, _, err := makeArgs(testctx.New(), config.DockerV2{}, nil)
+		testlib.AssertSkipped(t, err)
+	})
+	t.Run("no images", func(t *testing.T) {
+		_, _, err := makeArgs(testctx.New(), config.DockerV2{
+			Dockerfile: "a",
+		}, nil)
+		testlib.AssertSkipped(t, err)
+	})
+	t.Run("no tags", func(t *testing.T) {
+		_, images, err := makeArgs(testctx.New(), config.DockerV2{
+			Dockerfile: "a",
+			Images:     []string{"ghcr.io/foo/bar"},
+		}, nil)
+		require.NoError(t, err)
+		require.Equal(t, []string{"ghcr.io/foo/bar:latest"}, images)
+	})
+	t.Run("simple", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(
+			config.Project{
+				ProjectName: "dockerv2",
+			},
+			testctx.WithEnv(map[string]string{"FOO": "bar"}),
+			testctx.WithDate(time.Date(2025, 8, 19, 0, 0, 0, 0, time.UTC)),
+		)
+		args, images, err := makeArgs(ctx, config.DockerV2{
+			ID:         "test",
+			IDs:        []string{"test"},
+			Dockerfile: "{{.Env.FOO}}.dockerfile",
+			Images:     []string{"{{.Env.FOO}}/bar", "ghcr.io/foo/bar"},
+			Tags:       []string{"latest", "v{{.Version}}", "{{ if .IsNightly }}nightly{{ end }}"},
+			Labels: map[string]string{
+				"date":    "{{.Date}}",
+				"ignored": "  ",
+				"  ":      "also ignored",
+				"name":    "{{.ProjectName}}",
+			},
+			Platforms: []string{"linux/amd64", "linux/arm64"},
+			BuildArgs: map[string]string{
+				"FOO":     "{{.Env.FOO}}",
+				"ignored": "  ",
+				"  ":      "also ignored",
+			},
+		}, []string{"--push"})
+		require.NoError(t, err)
+		require.Equal(
+			t,
+			[]string{
+				"buildx", "build",
+				"--platform", "linux/amd64,linux/arm64",
+				"--attest=type=sbom",
+				"-t", "bar/bar:latest",
+				"-t", "bar/bar:v",
+				"-t", "ghcr.io/foo/bar:latest",
+				"-t", "ghcr.io/foo/bar:v",
+				"--push",
+				"--label", "date=2025-08-19T00:00:00Z",
+				"--label", "name=dockerv2",
+				"--build-arg", "FOO=bar",
+				".",
+			},
+			args,
+		)
+		require.Equal(
+			t,
+			[]string{
+				"bar/bar:latest",
+				"bar/bar:v",
+				"ghcr.io/foo/bar:latest",
+				"ghcr.io/foo/bar:v",
+			},
+			images,
+		)
+	})
+}
+
+func TestPlatform(t *testing.T) {
+	for expected, art := range map[string]artifact.Artifact{
+		"darwin/amd64": {
+			Goos:   "darwin",
+			Goarch: "amd64",
+		},
+		"darwin/arm64": {
+			Goos:   "darwin",
+			Goarch: "arm64",
+		},
+		"windows/amd64": {
+			Goos:   "windows",
+			Goarch: "amd64",
+		},
+		"windows/arm64": {
+			Goos:   "windows",
+			Goarch: "arm64",
+		},
+		"linux/amd64": {
+			Goos:   "linux",
+			Goarch: "amd64",
+		},
+		"linux/arm64": {
+			Goos:   "linux",
+			Goarch: "arm64",
+		},
+		"linux/arm/v7": {
+			Goos:   "linux",
+			Goarch: "arm",
+			Goarm:  "7",
+		},
+		"linux/arm/v6": {
+			Goos:   "linux",
+			Goarch: "arm",
+			Goarm:  "6",
+		},
+		"linux/386": {
+			Goos:   "linux",
+			Goarch: "386",
+		},
+		"linux/ppc64le": {
+			Goos:   "linux",
+			Goarch: "ppc64le",
+		},
+		"linux/s390x": {
+			Goos:   "linux",
+			Goarch: "s390x",
+		},
+		"linux/riscv64": {
+			Goos:   "linux",
+			Goarch: "riscv64",
+		},
+	} {
+		t.Run(expected, func(t *testing.T) {
+			plat, err := toPlatform(&art)
+			require.NoError(t, err)
+			require.Equal(t, expected, plat)
+		})
+	}
+}
+
+func TestParsePlatform(t *testing.T) {
+	for input, output := range map[string]platform{
+		"linux/amd64":  {os: "linux", arch: "amd64"},
+		"linux/arm/v6": {os: "linux", arch: "arm", arm: "6"},
+	} {
+		t.Run(input, func(t *testing.T) {
+			require.Equal(t, output, parsePlatform(input))
+		})
+	}
+}
+
+func TestContextArtifacts(t *testing.T) {
+	ctx := testctx.NewWithCfg(config.Project{
+		ProjectName: "dockerv2",
+	})
+
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:   "mybin",
+		Goos:   "linux",
+		Goarch: "arm",
+		Goarm:  "7",
+		Type:   artifact.Binary,
+		Extra: artifact.Extras{
+			artifact.ExtraID: "id1",
+		},
+	})
+	for _, arch := range []string{"amd64", "arm64"} {
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name:   "mybin",
+			Goos:   "linux",
+			Goarch: arch,
+			Type:   artifact.Binary,
+			Extra: artifact.Extras{
+				artifact.ExtraID: "id1",
+			},
+		})
+	}
+
+	arts := contextArtifacts(ctx, config.DockerV2{
+		Platforms: []string{"linux/arm/v7", "linux/amd64", "linux/arm64"},
+		IDs:       []string{"id1"},
+	})
+	require.Len(t, arts, 3)
+}
diff --git a/internal/pipe/docker/v2/testdata/Dockerfile b/internal/pipe/docker/v2/testdata/Dockerfile
new file mode 100644
index 00000000..f129fbd7
--- /dev/null
+++ b/internal/pipe/docker/v2/testdata/Dockerfile
@@ -0,0 +1,4 @@
+FROM alpine@sha256:4bcff63911fcb4448bd4fdacec207030997caf25e9bea4045fa6c8c44de311d1
+ARG TARGETPLATFORM
+COPY ./testdata/foo.conf /etc/
+COPY $TARGETPLATFORM/* /bin/
diff --git a/internal/pipe/docker/v2/testdata/Dockerfile.clean b/internal/pipe/docker/v2/testdata/Dockerfile.clean
new file mode 100644
index 00000000..8d80e28a
--- /dev/null
+++ b/internal/pipe/docker/v2/testdata/Dockerfile.clean
@@ -0,0 +1,2 @@
+FROM alpine@sha256:4bcff63911fcb4448bd4fdacec207030997caf25e9bea4045fa6c8c44de311d1
+COPY ./testdata/foo.conf /etc/
diff --git a/internal/pipe/docker/v2/testdata/foo.conf b/internal/pipe/docker/v2/testdata/foo.conf
new file mode 100644
index 00000000..66276003
--- /dev/null
+++ b/internal/pipe/docker/v2/testdata/foo.conf
@@ -0,0 +1 @@
+fake conf
diff --git a/internal/pipe/dockerdigest/digest.go b/internal/pipe/dockerdigest/digest.go
index c009f6a5..32f253d4 100644
--- a/internal/pipe/dockerdigest/digest.go
+++ b/internal/pipe/dockerdigest/digest.go
@@ -43,7 +43,7 @@ func (Pipe) Default(ctx *context.Context) error {
 func (Pipe) Publish(ctx *context.Context) error {
 	images := ctx.Artifacts.Filter(
 		artifact.Or(
-			// TODO: artifact.ByType(artifact.DockerImageV2),
+			artifact.ByType(artifact.DockerImageV2),
 			artifact.ByType(artifact.DockerImage),
 			artifact.ByType(artifact.DockerManifest),
 		),
diff --git a/internal/pipe/dockerdigest/digest_test.go b/internal/pipe/dockerdigest/digest_test.go
index 13a38399..24f22cf6 100644
--- a/internal/pipe/dockerdigest/digest_test.go
+++ b/internal/pipe/dockerdigest/digest_test.go
@@ -53,7 +53,7 @@ func TestRun(t *testing.T) {
 	})
 	ctx.Artifacts.Add(&artifact.Artifact{
 		Name:  "img2",
-		Type:  artifact.DockerImage, // TODO: V2
+		Type:  artifact.DockerImageV2,
 		Extra: artifact.Extras{artifact.ExtraDigest: "sha512:digest2"},
 	})
 	ctx.Artifacts.Add(&artifact.Artifact{
diff --git a/internal/pipe/publish/publish.go b/internal/pipe/publish/publish.go
index 5c598113..e184456d 100644
--- a/internal/pipe/publish/publish.go
+++ b/internal/pipe/publish/publish.go
@@ -16,6 +16,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/chocolatey"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/custompublishers"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/docker"
+	dockerv2 "github.com/goreleaser/goreleaser/v2/internal/pipe/docker/v2"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/dockerdigest"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/ko"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/krew"
@@ -48,6 +49,7 @@ func New() Pipe {
 			artifactory.Pipe{},
 			docker.Pipe{},
 			docker.ManifestPipe{},
+			dockerv2.Pipe{},
 			dockerdigest.Pipe{},
 			ko.Pipe{},
 			sign.DockerPipe{},
diff --git a/internal/pipe/sign/sign_docker.go b/internal/pipe/sign/sign_docker.go
index 083d637d..9a595eee 100644
--- a/internal/pipe/sign/sign_docker.go
+++ b/internal/pipe/sign/sign_docker.go
@@ -39,9 +39,6 @@ func (DockerPipe) Default(ctx *context.Context) error {
 		if len(cfg.Args) == 0 {
 			cfg.Args = []string{"sign", "--key=cosign.key", "${artifact}@${digest}", "--yes"}
 		}
-		if cfg.Artifacts == "" {
-			cfg.Artifacts = "none"
-		}
 		if cfg.ID == "" {
 			cfg.ID = "default"
 		}
@@ -59,16 +56,25 @@ func (DockerPipe) Publish(ctx *context.Context) error {
 			var filters []artifact.Filter
 			switch cfg.Artifacts {
 			case "images":
-				filters = append(filters, artifact.ByType(artifact.DockerImage))
+				filters = append(filters, artifact.Or(
+					artifact.ByType(artifact.DockerImage),
+					artifact.ByType(artifact.DockerImageV2),
+				))
 			case "manifests":
-				filters = append(filters, artifact.ByType(artifact.DockerManifest))
+				filters = append(filters, artifact.Or(
+					artifact.ByType(artifact.DockerManifest),
+					artifact.ByType(artifact.DockerImageV2),
+				))
 			case "all":
 				filters = append(filters, artifact.Or(
 					artifact.ByType(artifact.DockerImage),
 					artifact.ByType(artifact.DockerManifest),
+					artifact.ByType(artifact.DockerImageV2),
 				))
 			case "none": // TODO(caarlos0): remove this
 				return pipe.ErrSkipSignEnabled
+			case "":
+				filters = append(filters, artifact.ByType(artifact.DockerImageV2))
 			default:
 				return fmt.Errorf("invalid list of artifacts to sign: %s", cfg.Artifacts)
 			}
diff --git a/internal/pipe/sign/sign_docker_test.go b/internal/pipe/sign/sign_docker_test.go
index c957d511..088d03d7 100644
--- a/internal/pipe/sign/sign_docker_test.go
+++ b/internal/pipe/sign/sign_docker_test.go
@@ -28,7 +28,6 @@ func TestDockerSignDefault(t *testing.T) {
 	require.Equal(t, "cosign", ctx.Config.DockerSigns[0].Cmd)
 	require.Empty(t, ctx.Config.DockerSigns[0].Signature)
 	require.Equal(t, []string{"sign", "--key=cosign.key", "${artifact}@${digest}", "--yes"}, ctx.Config.DockerSigns[0].Args)
-	require.Equal(t, "none", ctx.Config.DockerSigns[0].Artifacts)
 }
 
 func TestDockerSignDisabled(t *testing.T) {
@@ -65,10 +64,12 @@ func TestDockerSignArtifacts(t *testing.T) {
 	man1 := "ghcr.io/caarlos0/goreleaser-docker-manifest-actions-example:1.2.1"
 	man1Digest := "sha256:b5db21408555f1ef5d68008a0a03a7caba3f29b62c64f1404e139b005a20bf03"
 
-	for name, cfg := range map[string]struct {
+	type testcase struct {
 		Signs    []config.Sign
 		Expected []string
-	}{
+	}
+
+	v1Cases := map[string]testcase{
 		"no signature file": {
 			Expected: nil, // no sigs
 			Signs: []config.Sign{
@@ -153,59 +154,124 @@ func TestDockerSignArtifacts(t *testing.T) {
 			},
 		},
 		// TODO: keyless test?
-	} {
+	}
+
+	v2Cases := map[string]testcase{
+		"empty": {
+			Expected: []string{"manifests_man1.sig"},
+			Signs: []config.Sign{
+				{
+					Stdin:     &password,
+					Signature: "manifests_${artifactID}.sig",
+					Cmd:       cmd,
+					Args:      args,
+				},
+			},
+		},
+		"images": {
+			Expected: []string{"manifests_man1.sig"},
+			Signs: []config.Sign{
+				{
+					Artifacts: "images",
+					Stdin:     &password,
+					Signature: "manifests_${artifactID}.sig",
+					Cmd:       cmd,
+					Args:      args,
+				},
+			},
+		},
+		"manifests": {
+			Expected: []string{"manifests_man1.sig"},
+			Signs: []config.Sign{
+				{
+					Artifacts: "manifests",
+					Stdin:     &password,
+					Signature: "manifests_${artifactID}.sig",
+					Cmd:       cmd,
+					Args:      args,
+				},
+			},
+		},
+	}
+
+	testWithArtifacts := func(tb testing.TB, cfg testcase, arts []artifact.Artifact) {
+		tb.Helper()
+		ctx := testctx.NewWithCfg(config.Project{
+			DockerSigns: cfg.Signs,
+		})
+		wd, err := os.Getwd()
+		require.NoError(tb, err)
+		tmp := testlib.Mktmp(tb)
+		require.NoError(tb, gio.Copy(filepath.Join(wd, "testdata/cosign/"), tmp))
+		ctx.Config.Dist = "dist"
+		require.NoError(tb, os.Mkdir("dist", 0o755))
+
+		for _, art := range arts {
+			ctx.Artifacts.Add(&art)
+		}
+
+		require.NoError(tb, DockerPipe{}.Default(ctx))
+		require.NoError(tb, DockerPipe{}.Publish(ctx))
+		var sigs []string
+		for _, sig := range ctx.Artifacts.Filter(
+			artifact.Or(
+				artifact.ByType(artifact.Signature),
+				artifact.ByType(artifact.Certificate),
+			),
+		).List() {
+			sigs = append(sigs, sig.Name)
+			require.Truef(tb, strings.HasPrefix(sig.Path, ctx.Config.Dist), "signature %q is not in dist dir %q", sig.Path, ctx.Config.Dist)
+		}
+		require.Equal(tb, cfg.Expected, sigs)
+	}
+
+	for name, cfg := range v1Cases {
 		t.Run(name, func(t *testing.T) {
-			ctx := testctx.NewWithCfg(config.Project{
-				DockerSigns: cfg.Signs,
-			})
-			wd, err := os.Getwd()
-			require.NoError(t, err)
-			tmp := testlib.Mktmp(t)
-			require.NoError(t, gio.Copy(filepath.Join(wd, "testdata/cosign/"), tmp))
-			ctx.Config.Dist = "dist"
-			require.NoError(t, os.Mkdir("dist", 0o755))
-
-			ctx.Artifacts.Add(&artifact.Artifact{
-				Name: img1,
-				Path: img1,
-				Type: artifact.DockerImage,
-				Extra: map[string]any{
-					artifact.ExtraID:     "img1",
-					artifact.ExtraDigest: img1Digest,
+			testWithArtifacts(t, cfg, []artifact.Artifact{
+				{
+					Name: img1,
+					Path: img1,
+					Type: artifact.DockerImage,
+					Extra: map[string]any{
+						artifact.ExtraID:     "img1",
+						artifact.ExtraDigest: img1Digest,
+					},
 				},
-			})
-			ctx.Artifacts.Add(&artifact.Artifact{
-				Name: img2,
-				Path: img2,
-				Type: artifact.DockerImage,
-				Extra: map[string]any{
-					artifact.ExtraID:     "img2",
-					artifact.ExtraDigest: img2Digest,
+				{
+					Name: img2,
+					Path: img2,
+					Type: artifact.DockerImage,
+					Extra: map[string]any{
+						artifact.ExtraID:     "img2",
+						artifact.ExtraDigest: img2Digest,
+					},
 				},
-			})
-			ctx.Artifacts.Add(&artifact.Artifact{
-				Name: man1,
-				Path: man1,
-				Type: artifact.DockerManifest,
-				Extra: map[string]any{
-					artifact.ExtraID:     "man1",
-					artifact.ExtraDigest: man1Digest,
+				{
+					Name: man1,
+					Path: man1,
+					Type: artifact.DockerManifest,
+					Extra: map[string]any{
+						artifact.ExtraID:     "man1",
+						artifact.ExtraDigest: man1Digest,
+					},
 				},
 			})
+		})
+	}
 
-			require.NoError(t, DockerPipe{}.Default(ctx))
-			require.NoError(t, DockerPipe{}.Publish(ctx))
-			var sigs []string
-			for _, sig := range ctx.Artifacts.Filter(
-				artifact.Or(
-					artifact.ByType(artifact.Signature),
-					artifact.ByType(artifact.Certificate),
-				),
-			).List() {
-				sigs = append(sigs, sig.Name)
-				require.Truef(t, strings.HasPrefix(sig.Path, ctx.Config.Dist), "signature %q is not in dist dir %q", sig.Path, ctx.Config.Dist)
-			}
-			require.Equal(t, cfg.Expected, sigs)
+	for name, cfg := range v2Cases {
+		t.Run(name, func(t *testing.T) {
+			testWithArtifacts(t, cfg, []artifact.Artifact{
+				{
+					Name: man1,
+					Path: man1,
+					Type: artifact.DockerImageV2,
+					Extra: map[string]any{
+						artifact.ExtraID:     "man1",
+						artifact.ExtraDigest: man1Digest,
+					},
+				},
+			})
 		})
 	}
 }
diff --git a/internal/pipeline/pipeline.go b/internal/pipeline/pipeline.go
index 377a6312..3f8b9491 100644
--- a/internal/pipeline/pipeline.go
+++ b/internal/pipeline/pipeline.go
@@ -18,6 +18,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/defaults"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/dist"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/docker"
+	dockerv2 "github.com/goreleaser/goreleaser/v2/internal/pipe/docker/v2"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/effectiveconfig"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/env"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/git"
@@ -153,6 +154,7 @@ var Pipeline = append(
 	reportsizes.Pipe{},
 	// create and push docker images
 	docker.Pipe{},
+	dockerv2.Pipe{},
 	// create and push docker images using ko
 	ko.Pipe{},
 	// publishes artifacts
diff --git a/internal/testlib/docker.go b/internal/testlib/docker.go
index 32a573f7..30662000 100644
--- a/internal/testlib/docker.go
+++ b/internal/testlib/docker.go
@@ -75,7 +75,7 @@ func StartRegistry(tb testing.TB, name, port string) {
 	resource, err := pool.RunWithOptions(&dockertest.RunOptions{
 		Name:       name,
 		Repository: "registry",
-		Tag:        "2",
+		Tag:        "3",
 		PortBindings: map[docker.Port][]docker.PortBinding{
 			docker.Port("5000/tcp"): {{HostPort: port}},
 		},
diff --git a/pkg/config/config.go b/pkg/config/config.go
index ef05a753..0a720a5a 100644
--- a/pkg/config/config.go
+++ b/pkg/config/config.go
@@ -1025,6 +1025,7 @@ type Retry struct {
 }
 
 // Docker image config.
+// Deprecated: use [DockerV2] instead.
 type Docker struct {
 	ID                 string   `yaml:"id,omitempty" json:"id,omitempty"`
 	IDs                []string `yaml:"ids,omitempty" json:"ids,omitempty"`
@@ -1043,6 +1044,7 @@ type Docker struct {
 }
 
 // DockerManifest config.
+// Deprecated: use [DockerV2] instead.
 type DockerManifest struct {
 	ID             string   `yaml:"id,omitempty" json:"id,omitempty"`
 	NameTemplate   string   `yaml:"name_template,omitempty" json:"name_template,omitempty"`
@@ -1054,6 +1056,20 @@ type DockerManifest struct {
 	Retry          Retry    `yaml:"retry,omitempty" json:"retry,omitempty"`
 }
 
+// DockerV2 is the new Docker build pipe options.
+type DockerV2 struct {
+	ID         string            `yaml:"id,omitempty" json:"id,omitempty"`
+	IDs        []string          `yaml:"ids,omitempty" json:"ids,omitempty"`
+	Dockerfile string            `yaml:"dockerfile,omitempty" json:"dockerfile,omitempty"`
+	Images     []string          `yaml:"images,omitempty" json:"images,omitempty"`
+	Tags       []string          `yaml:"tags,omitempty" json:"tags,omitempty"`
+	Labels     map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
+	ExtraFiles []string          `yaml:"extra_files,omitempty" json:"extra_files,omitempty"`
+	Platforms  []string          `yaml:"platforms,omitempty" json:"platforms,omitempty"`
+	BuildArgs  map[string]string `yaml:"build_args,omitempty" json:"build_args,omitempty"`
+	Retry      Retry             `yaml:"retry,omitempty" json:"retry,omitempty"`
+}
+
 // DockerDigest config.
 type DockerDigest struct {
 	Disable      string `yaml:"disable,omitempty" json:"disable,omitempty" jsonschema:"oneof_type=string;boolean"`
@@ -1189,6 +1205,7 @@ type Project struct {
 	Snapshot        Snapshot         `yaml:"snapshot,omitempty" json:"snapshot,omitempty"`
 	Checksum        Checksum         `yaml:"checksum,omitempty" json:"checksum,omitempty"`
 	Dockers         []Docker         `yaml:"dockers,omitempty" json:"dockers,omitempty"`
+	DockersV2       []DockerV2       `yaml:"dockers_v2,omitempty" json:"dockers_v2,omitempty"`
 	DockerDigest    DockerDigest     `yaml:"docker_digest,omitempty" json:"docker_digest,omitempty"`
 	DockerManifests []DockerManifest `yaml:"docker_manifests,omitempty" json:"docker_manifests,omitempty"`
 	Artifactories   []Upload         `yaml:"artifactories,omitempty" json:"artifactories,omitempty"`
diff --git a/pkg/defaults/defaults.go b/pkg/defaults/defaults.go
index 0c4d4848..b46dd14b 100644
--- a/pkg/defaults/defaults.go
+++ b/pkg/defaults/defaults.go
@@ -20,6 +20,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/discord"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/dist"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/docker"
+	dockerv2 "github.com/goreleaser/goreleaser/v2/internal/pipe/docker/v2"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/dockerdigest"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/gomod"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/ko"
@@ -87,6 +88,7 @@ var Defaulters = []Defaulter{
 	sign.DockerPipe{},
 	sbom.Pipe{},
 	docker.Pipe{},
+	dockerv2.Pipe{},
 	docker.ManifestPipe{},
 	dockerdigest.Pipe{},
 	artifactory.Pipe{},
diff --git a/pkg/healthcheck/healthcheck.go b/pkg/healthcheck/healthcheck.go
index 4f15fa74..62bdc3d3 100644
--- a/pkg/healthcheck/healthcheck.go
+++ b/pkg/healthcheck/healthcheck.go
@@ -7,6 +7,7 @@ import (
 
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/chocolatey"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/docker"
+	dockerv2 "github.com/goreleaser/goreleaser/v2/internal/pipe/docker/v2"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/nix"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/sbom"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/sign"
@@ -36,6 +37,7 @@ var Healthcheckers = []Healthchecker{
 	sbom.Pipe{},
 	docker.Pipe{},
 	docker.ManifestPipe{},
+	dockerv2.Pipe{},
 	chocolatey.Pipe{},
 	nix.New(),
 }
diff --git a/www/docs/customization/docker.md b/www/docs/customization/docker.md
index e092f816..d35f315c 100644
--- a/www/docs/customization/docker.md
+++ b/www/docs/customization/docker.md
@@ -1,4 +1,7 @@
-# Docker Images
+# Docker Images (deprecated)
+
+> [Deprecated](./../deprecations.md#dockers) in v2.12-unreleased.
+> [Docker Images v2](./dockers_v2.md) should be used instead.
 
 GoReleaser can build and push Docker images.
 Let's see how it works.
diff --git a/www/docs/customization/docker_manifest.md b/www/docs/customization/docker_manifest.md
index ab69b2d9..54082237 100644
--- a/www/docs/customization/docker_manifest.md
+++ b/www/docs/customization/docker_manifest.md
@@ -1,4 +1,7 @@
-# Docker Manifests
+# Docker Manifests (deprecated)
+
+> [Deprecated](./../deprecations.md#dockers) in v2.12-unreleased.
+> [Docker Images v2](./dockers_v2.md) should be used instead.
 
 GoReleaser can also create and push Docker multi-platform images using the
 `docker manifest` tool.
diff --git a/www/docs/customization/docker_sign.md b/www/docs/customization/docker_sign.md
index 774ce8d1..726904bb 100644
--- a/www/docs/customization/docker_sign.md
+++ b/www/docs/customization/docker_sign.md
@@ -41,8 +41,9 @@ docker_signs:
     #   none:      no signing
     #   images:    only docker images
     #   manifests: only docker manifests
+    #   '':        images built by dockers_v2
     #
-    # Default: 'none'.
+    # Default: ''.
     artifacts: all
 
     # IDs of the artifacts to sign.
diff --git a/www/docs/customization/dockers_v2.md b/www/docs/customization/dockers_v2.md
new file mode 100644
index 00000000..f6e7384a
--- /dev/null
+++ b/www/docs/customization/dockers_v2.md
@@ -0,0 +1,199 @@
+# Dockers (v2)
+
+<!-- md:version v2.12-unreleased -->
+
+!!! warning "alpha "
+
+    This feature is in *alpha* state.
+    It will be improved until its deemed stable, at which point we'll
+    officially deprecate `dockers` and `docker_manifests` in preparations for
+    GoReleaser v3, which should take over both of them.
+
+This feature uses `docker buildx` to build multi-arch manifests,
+reusing the previously built binaries and/or packages.
+
+## Customization
+
+Here's a commented out configuration:
+
+```yaml title=".goreleaser.yaml"
+dockers_v2:
+  # You can have multiple Docker images.
+  - #
+    # ID of the image, needed if you want to filter by it later on (e.g. on custom publishers).
+    # Default: project name
+    id: myimg
+
+    # Path to the Dockerfile (from the project root).
+    #
+    # Default: 'Dockerfile'.
+    # Templates: allowed.
+    dockerfile: "{{ .Env.DOCKERFILE }}"
+
+    # IDs to filter the binaries/packages.
+    #
+    # Make sure to only include the IDs of binaries you want to `COPY` in your
+    # Dockerfile.
+    #
+    # If you include IDs that don't exist or are not available for the current
+    # architecture being built, the build of the image will be skipped.
+    ids:
+      - mybuild
+      - mynfpm
+
+    # Image names.
+    #
+    # Empty image names are ignored.
+    #
+    # Templates: allowed.
+    image:
+      - "myuser/myimage"
+      - "gcr.io/myuser/myimage"
+
+    # Tag names.
+    #
+    # Empty tags are ignored.
+    #
+    # Templates: allowed.
+    tags:
+      - "v{{ .Version }}"
+      - "{{ if .IsNightly }}nightly{{ end }}"
+      - "{{ if not .IsNightly }}latest{{ end }}"
+
+    # If your Dockerfile copies files other than binaries and packages,
+    # you should list them here as well.
+    # Note that GoReleaser will create the same structure inside a temporary
+    # directory, so if you add `foo/bar.json` here, on your Dockerfile you can
+    # `COPY foo/bar.json /whatever.json`.
+    # Also note that the paths here are relative to the directory in which
+    # GoReleaser is being run (usually the repository root directory).
+    # This field does not support wildcards, you can add an entire directory here
+    # and use wildcards when you `COPY`/`ADD` in your Dockerfile.
+    extra_files:
+      - config.yml
+
+    # Labels to be added to the image.
+    labels:
+      "org.opencontainers.image.description": "My software"
+      "org.opencontainers.image.created": "{{.Date}}"
+      "org.opencontainers.image.name": "{{.ProjectName}}"
+      "org.opencontainers.image.revision": "{{.FullCommit}}"
+      "org.opencontainers.image.version": "{{.Version}}"
+      "org.opencontainers.image.source": "{{.GitURL}}"
+
+    # Platforms to build.
+    #
+    # Default: [ linux/amd64 linux/arm64 ]
+    platforms:
+      - linux/amd64
+      - linux/arm64
+
+    # Additional `--build-arg`s to be passed.
+    #
+    # Templates: allowed.
+    build_args:
+      FOO: bar
+
+    # Retry configuration.
+    retry:
+      # Attempts of retry.
+      #
+      # Default: 10.
+      attempts: 5
+
+      # Delay between retry attempts.
+      #
+      # Default: 10s.
+      delay: 5s
+
+      # Maximum delay between retry attempts.
+      #
+      # Default: 5m.
+      max_delay: 2m
+```
+
+!!! important "dockers_v2"
+
+    The `dockers_v2` name is provisional.
+
+    It will replace `dockers` and `docker_manifests` in GoReleaser v3 (no ETA),
+    and will be called only `dockers`.
+
+    It is been done this way to prevent breaking changes in feature releases.
+
+<!-- md:templates -->
+
+## How it works
+
+You can declare multiple Docker images.
+They will be matched against the binaries generated by your `builds` section and
+packages generated by your `nfpms` section.
+
+If you have only one item in the `builds` list,
+the configuration can be as easy as adding the
+name and tags of your images to your `.goreleaser.yaml` file:
+
+```yaml
+dockers_v2:
+  - images:
+      - user/repo
+```
+
+You also need to create a `Dockerfile` in your project's root directory:
+
+```dockerfile
+FROM scratch
+ARG TARGETPLATFORM
+ENTRYPOINT ["/usr/bin/myprogram"]
+COPY $TARGETPLATFORM/myprogram /usr/bin/
+```
+
+This configuration will build and push a Docker image named `user/repo:tagname`.
+
+### The Docker build context
+
+Note that we are not building any go files in the Docker build phase, we are
+merely copying the binary to a `scratch` image and setting up the `entrypoint`.
+
+The idea is that you reuse the previously built binaries instead of building
+them again when creating the Docker image.
+
+The build context itself is a temporary directory which contains the binaries
+and packages for the target platforms, which you can `COPY` into your image
+(mind the use of `$TARGETPLATFORM` above).
+
+A corollary of that is that **the context does not contain the source files**.
+If you need to add some other file that is in your source directory, you'll need
+to add it to the `files` property, so it'll get copied into the context.
+
+All that being said, your Docker build context will usually look like this:
+
+```sh
+temp-context-dir
+├── Dockerfile
+├── linux/arm64/myprogram
+├── linux/arm64/myprogram.rpm
+├── linux/arm64/myprogram.apk
+├── linux/arm64/myprogram.deb
+├── linux/amd64/myprogram
+├── linux/amd64/myprogram.rpm
+├── linux/amd64/myprogram.apk
+└── linux/amd64/myprogram.deb
+```
+
+`myprogram` would actually be your binary name, and the Linux package names
+would follow their respective configuration's names.
+
+## Setting up a builder
+
+For buildx to work, you'll need to have a builder that supports multi-platform
+builds set up.
+
+On Linux, you can do it with:
+
+```sh
+docker buildx create --name=goreleaser --use
+docker run --privileged --rm tonistiigi/binfmt --install all
+```
+
+For what it's worth, this feature was built and tested with buildx v0.24.0.
diff --git a/www/docs/deprecations.md b/www/docs/deprecations.md
index 398835f3..ed7feffb 100644
--- a/www/docs/deprecations.md
+++ b/www/docs/deprecations.md
@@ -41,6 +41,157 @@ PS: Don't forget to add it to cmd/mcp.go as well!
 
 -->
 
+### dockers
+
+We're re-implementing the docker feature from the ground up.
+
+The configuration now is way more concise, and the implementation is simpler as
+well.
+
+Before, you would have to setup `dockers` and `docker_manifests`, now, only
+`dockers` (provisionally being called `dockers_v2`) is needed to achieve the
+same things.
+
+Then, instead of building the images, pushing them, and then building the
+manifests and pushing them, we will now run a single `docker buildx build` with
+the given platforms, which will build and publish the manifest and SBOM.
+
+=== "Before"
+
+    ```yaml
+    dockers:
+      - image_templates:
+          - "foo/bar:v{{ .Version }}-amd64"
+          - "ghcr.io/foo/bar:v{{ .Version }}-amd64"
+        dockerfile: Dockerfile
+        use: buildx
+        build_flag_templates:
+          - "--pull"
+          - "--label=org.opencontainers.image.description=Foo bar"
+          - "--label=org.opencontainers.image.created={{.Date}}"
+          - "--label=org.opencontainers.image.name={{.ProjectName}}"
+          - "--label=org.opencontainers.image.revision={{.FullCommit}}"
+          - "--label=org.opencontainers.image.version={{.Version}}"
+          - "--label=org.opencontainers.image.source={{.GitURL}}"
+          - "--platform=linux/amd64"
+      - image_templates:
+          - "foo/bar:v{{ .Version }}-arm64"
+          - "ghcr.io/foo/bar:v{{ .Version }}-arm64"
+        dockerfile: Dockerfile
+        use: buildx
+        build_flag_templates:
+          - "--pull"
+          - "--label=org.opencontainers.image.description=Foo bar"
+          - "--label=org.opencontainers.image.created={{.Date}}"
+          - "--label=org.opencontainers.image.name={{.ProjectName}}"
+          - "--label=org.opencontainers.image.revision={{.FullCommit}}"
+          - "--label=org.opencontainers.image.version={{.Version}}"
+          - "--label=org.opencontainers.image.source={{.GitURL}}"
+          - "--platform=linux/arm64"
+        goarch: arm64
+
+    docker_manifests:
+      - name_template: "foo/bar:v{{ .Version }}"
+        image_templates:
+          - "foo/bar:v{{ .Version }}-amd64"
+          - "foo/bar:v{{ .Version }}-arm64"
+      - name_template: "ghcr.io/foo/bar:v{{ .Version }}"
+        image_templates:
+          - "ghcr.io/foo/bar:v{{ .Version }}-amd64"
+          - "ghcr.io/foo/bar:v{{ .Version }}-arm64"
+      - name_template: "{{ if not .IsNightly }}foo/bar:latest{{ end }}"
+        image_templates:
+          - "foo/bar:v{{ .Version }}-amd64"
+          - "foo/bar:v{{ .Version }}-arm64"
+      - name_template: "{{ if not .IsNightly }}ghcr.io/foo/bar:latest{{ end }}"
+        image_templates:
+          - "ghcr.io/foo/bar:v{{ .Version }}-amd64"
+          - "ghcr.io/foo/bar:v{{ .Version }}-arm64"
+      - name_template: "{{ if .IsNightly }}foo/bar:nightly{{ end }}"
+        image_templates:
+          - "foo/bar:v{{ .Version }}-amd64"
+          - "foo/bar:v{{ .Version }}-arm64"
+      - name_template: "{{ if .IsNightly }}ghcr.io/foo/bar:nightly{{ end }}"
+        image_templates:
+          - "ghcr.io/foo/bar:v{{ .Version }}-amd64"
+          - "ghcr.io/foo/bar:v{{ .Version }}-arm64"
+    ```
+
+=== "After"
+
+    ```yaml
+    dockers_v2:
+      - images:
+          - "foo/bar"
+          - "ghcr.io/foo/bar"
+        tags:
+          - "v{{ .Version }}"
+          - "{{ if .IsNightly }}nightly{{ end }}"
+          - "{{ if not .IsNightly }}latest{{ end }}"
+        labels:
+          "org.opencontainers.image.description": "Foo bar"
+          "org.opencontainers.image.created": "{{.Date}}"
+          "org.opencontainers.image.name": "{{.ProjectName}}"
+          "org.opencontainers.image.revision": "{{.FullCommit}}"
+          "org.opencontainers.image.version": "{{.Version}}"
+          "org.opencontainers.image.source": "{{.GitURL}}"
+    ```
+
+As you can see, it's a lot simpler.
+The resulting images are the same, a combination of all the non-empty images
+with all the non-empty tags.
+
+This will also require a small change in your `Dockerfile` when copying from the
+context:
+
+=== "Before"
+
+    ```dockerfile
+    FROM alpine
+    COPY my-binary /usr/bin
+    ```
+
+=== "After"
+
+    ```dockerfile
+    FROM alpine
+    ARG TARGETPLATFORM
+    COPY $TARGETPLATFORM/my-binary /usr/bin
+    ```
+
+GoReleaser will automatically setup the context in such a way that all the
+artifacts for the given target platform will be located within
+`$TARGETPLATFORM/`.
+
+One side effect of this new feature is that builds with `--snapshot` will
+produce images that cannot be ran - it only tests that the `docker build`
+succeeds.
+This is something we'll need to improve in future versions.
+
+Feel free to suggest improvements
+[here](https://github.com/orgs/goreleaser/discussions/6005).
+
+Regarding signing, you may also remove the `artifacts` option from you
+`docker_signs`:
+
+=== "Before"
+
+    ```yaml
+    docker_signs:
+      - artifacts: images
+        # etc..
+    ```
+
+=== "After"
+
+    ```yaml
+    docker_signs:
+      - # etc..
+    ```
+
+Since in the future we'll only have the docker image type, the `artifacts`
+property will eventually be deprecated and removed.
+
 ### homebrew_casks.conflicts.formula
 
 > since v2.12-unreleased
diff --git a/www/mkdocs.yml b/www/mkdocs.yml
index a15e02b3..37758950 100644
--- a/www/mkdocs.yml
+++ b/www/mkdocs.yml
@@ -147,8 +147,9 @@ nav:
           - customization/checksum.md
           - Snaps: customization/snapcraft.md
           - Chocolatey: customization/chocolatey.md
-          - Docker: customization/docker.md
-          - Docker Manifests: customization/docker_manifest.md
+          - customization/dockers_v2.md
+          - customization/docker.md
+          - customization/docker_manifest.md
           - customization/docker_digests.md
           - Ko: customization/ko.md
       - SBOMs: customization/sbom.md
