diff --git a/internal/pipe/aursources/aursources.go b/internal/pipe/aursources/aursources.go
new file mode 100644
index 00000000..bf94772a
--- /dev/null
+++ b/internal/pipe/aursources/aursources.go
@@ -0,0 +1,379 @@
+package aursources
+
+import (
+	"bufio"
+	"bytes"
+	"crypto/sha256"
+	"errors"
+	"fmt"
+	"os"
+	"path"
+	"path/filepath"
+	"sort"
+	"strings"
+	"text/template"
+
+	"github.com/caarlos0/log"
+	"github.com/goreleaser/goreleaser/v2/internal/artifact"
+	"github.com/goreleaser/goreleaser/v2/internal/client"
+	"github.com/goreleaser/goreleaser/v2/internal/commitauthor"
+	"github.com/goreleaser/goreleaser/v2/internal/pipe"
+	"github.com/goreleaser/goreleaser/v2/internal/skips"
+	"github.com/goreleaser/goreleaser/v2/internal/tmpl"
+	"github.com/goreleaser/goreleaser/v2/pkg/config"
+	"github.com/goreleaser/goreleaser/v2/pkg/context"
+)
+
+const (
+	aurExtra         = "AURSourcesConfig"
+	defaultCommitMsg = "Update to {{ .Tag }}"
+)
+
+var ErrNoArchivesFound = errors.New("no linux archives found")
+
+// Pipe for arch linux's AUR pkgbuild.
+type Pipe struct{}
+
+func (Pipe) String() string        { return "arch user repositories (sources)" }
+func (Pipe) ContinueOnError() bool { return true }
+func (Pipe) Skip(ctx *context.Context) bool {
+	return skips.Any(ctx, skips.AURSource) || len(ctx.Config.AURSources) == 0
+}
+
+func (Pipe) Default(ctx *context.Context) error {
+	for i := range ctx.Config.AURSources {
+		pkg := &ctx.Config.AURSources[i]
+
+		pkg.CommitAuthor = commitauthor.Default(pkg.CommitAuthor)
+		if pkg.CommitMessageTemplate == "" {
+			pkg.CommitMessageTemplate = defaultCommitMsg
+		}
+		if pkg.Name == "" {
+			pkg.Name = ctx.Config.ProjectName
+		}
+		pkg.Name = trimBin(pkg.Name)
+		if len(pkg.Arches) == 0 {
+			pkg.Arches = []string{"x86_64", "aarch64"}
+		}
+		if len(pkg.Conflicts) == 0 {
+			pkg.Conflicts = []string{ctx.Config.ProjectName}
+		}
+		if len(pkg.Provides) == 0 {
+			pkg.Provides = []string{ctx.Config.ProjectName}
+		}
+		if len(pkg.MakeDepends) == 0 {
+			pkg.MakeDepends = []string{"go", "git"}
+		}
+		if pkg.Rel == "" {
+			pkg.Rel = "1"
+		}
+		if pkg.Goamd64 == "" {
+			pkg.Goamd64 = "v1"
+		}
+	}
+
+	return nil
+}
+
+func trimBin(s string) string {
+	if strings.HasSuffix(s, "-bin") {
+		return trimBin(strings.TrimSuffix(s, "-bin"))
+	}
+
+	return s
+}
+
+func (Pipe) Run(ctx *context.Context) error {
+	cli, err := client.NewReleaseClient(ctx)
+	if err != nil {
+		return err
+	}
+
+	return runAll(ctx, cli)
+}
+
+func runAll(ctx *context.Context, cli client.ReleaseURLTemplater) error {
+	for _, aur := range ctx.Config.AURSources {
+		err := doRun(ctx, aur, cli)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func doRun(ctx *context.Context, aur config.AURSource, cl client.ReleaseURLTemplater) error {
+	if err := tmpl.New(ctx).ApplyAll(
+		&aur.Name,
+		&aur.Directory,
+	); err != nil {
+		return err
+	}
+
+	filters := []artifact.Filter{
+		artifact.ByType(artifact.UploadableSourceArchive),
+	}
+	if len(aur.IDs) > 0 {
+		filters = append(filters, artifact.ByIDs(aur.IDs...))
+	}
+
+	archives := ctx.Artifacts.Filter(artifact.And(filters...)).List()
+	if len(archives) == 0 {
+		return ErrNoArchivesFound
+	}
+
+	pkg, err := tmpl.New(ctx).Apply(aur.Package)
+	if err != nil {
+		return err
+	}
+
+	aur.Package = pkg
+
+	for _, info := range []struct {
+		name, tpl, ext string
+		kind           artifact.Type
+	}{
+		{
+			name: "PKGBUILD",
+			tpl:  aurTemplateData,
+			ext:  ".pkgbuild",
+			kind: artifact.PkgBuild,
+		},
+		{
+			name: ".SRCINFO",
+			tpl:  srcInfoTemplate,
+			ext:  ".srcinfo",
+			kind: artifact.SrcInfo,
+		},
+	} {
+		pkgContent, err := buildPkgFile(ctx, aur, cl, archives, info.tpl)
+		if err != nil {
+			return err
+		}
+
+		path := filepath.Join(ctx.Config.Dist, "aur", aur.Name+info.ext)
+		if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
+			return fmt.Errorf("failed to write %s: %w", info.kind, err)
+		}
+		log.WithField("file", path).Info("writing")
+		if err := os.WriteFile(path, []byte(pkgContent), 0o644); err != nil { //nolint:gosec
+			return fmt.Errorf("failed to write %s: %w", info.kind, err)
+		}
+
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name: info.name,
+			Path: path,
+			Type: info.kind,
+			Extra: map[string]interface{}{
+				aurExtra:         aur,
+				artifact.ExtraID: aur.Name,
+			},
+		})
+	}
+
+	return nil
+}
+
+func buildPkgFile(ctx *context.Context, pkg config.AURSource, client client.ReleaseURLTemplater, artifacts []*artifact.Artifact, tpl string) (string, error) {
+	data, err := dataFor(ctx, pkg, client, artifacts)
+	if err != nil {
+		return "", err
+	}
+	return applyTemplate(ctx, tpl, data)
+}
+
+func fixLines(s string) string {
+	lines := strings.Split(s, "\n")
+	var result []string
+	for _, line := range lines {
+		l := strings.TrimSpace(line)
+		if l == "" {
+			result = append(result, "")
+			continue
+		}
+		result = append(result, "  "+l)
+	}
+	return strings.Join(result, "\n")
+}
+
+func quoteField(v string) string {
+	simpleQuote := strings.Contains(v, `'`)
+	doubleQuote := strings.Contains(v, `"`)
+
+	switch {
+	case simpleQuote && doubleQuote:
+		return `"` + strings.ReplaceAll(v, `"`, `'`) + `"`
+	case simpleQuote:
+		return `"` + v + `"`
+	default:
+		return `'` + v + `'`
+	}
+}
+
+func applyTemplate(ctx *context.Context, tpl string, data templateData) (string, error) {
+	t := template.Must(
+		template.New(data.Name).
+			Funcs(template.FuncMap{
+				"fixLines":   fixLines,
+				"pkgArray":   toPkgBuildArray,
+				"quoteField": quoteField,
+			}).
+			Parse(tpl),
+	)
+
+	var out bytes.Buffer
+	if err := t.Execute(&out, data); err != nil {
+		return "", err
+	}
+
+	content, err := tmpl.New(ctx).Apply(out.String())
+	if err != nil {
+		return "", err
+	}
+	out.Reset()
+
+	// Sanitize the template output and get rid of trailing whitespace.
+	var (
+		r = strings.NewReader(content)
+		s = bufio.NewScanner(r)
+	)
+	for s.Scan() {
+		l := strings.TrimRight(s.Text(), " ")
+		_, _ = out.WriteString(l)
+		_ = out.WriteByte('\n')
+	}
+	if err := s.Err(); err != nil {
+		return "", err
+	}
+
+	return out.String(), nil
+}
+
+func toPkgBuildArray(ss []string) string {
+	result := make([]string, 0, len(ss))
+	for _, s := range ss {
+		result = append(result, fmt.Sprintf("'%s'", s))
+	}
+	return strings.Join(result, " ")
+}
+
+func dataFor(ctx *context.Context, cfg config.AURSource, cl client.ReleaseURLTemplater, artifacts []*artifact.Artifact) (templateData, error) {
+	result := templateData{
+		Name:         cfg.Name,
+		Desc:         cfg.Description,
+		Homepage:     cfg.Homepage,
+		Version:      fmt.Sprintf("%d.%d.%d", ctx.Semver.Major, ctx.Semver.Minor, ctx.Semver.Patch),
+		License:      cfg.License,
+		Rel:          cfg.Rel,
+		Maintainers:  cfg.Maintainers,
+		Contributors: cfg.Contributors,
+		Provides:     cfg.Provides,
+		Conflicts:    cfg.Conflicts,
+		Backup:       cfg.Backup,
+		Depends:      cfg.Depends,
+		OptDepends:   cfg.OptDepends,
+		MakeDepends:  cfg.MakeDepends,
+		Prepare:      cfg.Prepare,
+		Build:        cfg.Build,
+		Package:      cfg.Package,
+		Arches:       cfg.Arches,
+	}
+
+	for _, art := range artifacts {
+		sum, err := art.Checksum("sha256")
+		if err != nil {
+			return result, err
+		}
+
+		if cfg.URLTemplate == "" {
+			url, err := cl.ReleaseURLTemplate(ctx)
+			if err != nil {
+				return result, err
+			}
+			cfg.URLTemplate = url
+		}
+		url, err := tmpl.New(ctx).WithArtifact(art).Apply(cfg.URLTemplate)
+		if err != nil {
+			return result, err
+		}
+
+		result.Sources = sources{
+			DownloadURL: url,
+			SHA256:      sum,
+			Format:      artifact.ExtraOr(*art, artifact.ExtraFormat, ""),
+		}
+	}
+
+	sort.Strings(result.Arches)
+
+	return result, nil
+}
+
+// Publish the PKGBUILD and .SRCINFO files to the AUR repository.
+func (Pipe) Publish(ctx *context.Context) error {
+	skips := pipe.SkipMemento{}
+	for _, pkgs := range ctx.Artifacts.Filter(
+		artifact.Or(
+			artifact.ByType(artifact.PkgBuild),
+			artifact.ByType(artifact.SrcInfo),
+		),
+	).GroupByID() {
+		err := doPublish(ctx, pkgs)
+		if err != nil && pipe.IsSkip(err) {
+			skips.Remember(err)
+			continue
+		}
+		if err != nil {
+			return err
+		}
+	}
+	return skips.Evaluate()
+}
+
+func doPublish(ctx *context.Context, pkgs []*artifact.Artifact) error {
+	cfg, err := artifact.Extra[config.AURSource](*pkgs[0], aurExtra)
+	if err != nil {
+		return err
+	}
+
+	if strings.TrimSpace(cfg.SkipUpload) == "true" {
+		return pipe.Skip("aur.skip_upload is set")
+	}
+
+	if strings.TrimSpace(cfg.SkipUpload) == "auto" && ctx.Semver.Prerelease != "" {
+		return pipe.Skip("prerelease detected with 'auto' upload, skipping aur publish")
+	}
+
+	author, err := commitauthor.Get(ctx, cfg.CommitAuthor)
+	if err != nil {
+		return err
+	}
+
+	msg, err := tmpl.New(ctx).Apply(cfg.CommitMessageTemplate)
+	if err != nil {
+		return err
+	}
+
+	cli := client.NewGitUploadClient("master")
+	repo := client.RepoFromRef(config.RepoRef{
+		Git: config.GitRepoRef{
+			PrivateKey: cfg.PrivateKey,
+			URL:        cfg.GitURL,
+			SSHCommand: cfg.GitSSHCommand,
+		},
+		Name: fmt.Sprintf("%x", sha256.Sum256([]byte(cfg.GitURL))),
+	})
+
+	files := make([]client.RepoFile, 0, len(pkgs))
+	for _, pkg := range pkgs {
+		content, err := os.ReadFile(pkg.Path)
+		if err != nil {
+			return err
+		}
+		files = append(files, client.RepoFile{
+			Path:    path.Join(cfg.Directory, pkg.Name),
+			Content: content,
+		})
+	}
+	return cli.CreateFiles(ctx, author, repo, msg, files)
+}
diff --git a/internal/pipe/aursources/aursources_test.go b/internal/pipe/aursources/aursources_test.go
new file mode 100644
index 00000000..713fc40d
--- /dev/null
+++ b/internal/pipe/aursources/aursources_test.go
@@ -0,0 +1,807 @@
+package aursources
+
+import (
+	"fmt"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/goreleaser/goreleaser/v2/internal/artifact"
+	"github.com/goreleaser/goreleaser/v2/internal/client"
+	"github.com/goreleaser/goreleaser/v2/internal/git"
+	"github.com/goreleaser/goreleaser/v2/internal/golden"
+	"github.com/goreleaser/goreleaser/v2/internal/skips"
+	"github.com/goreleaser/goreleaser/v2/internal/testctx"
+	"github.com/goreleaser/goreleaser/v2/internal/testlib"
+	"github.com/goreleaser/goreleaser/v2/pkg/config"
+	"github.com/goreleaser/goreleaser/v2/pkg/context"
+	"github.com/stretchr/testify/require"
+)
+
+func TestContinueOnError(t *testing.T) {
+	require.True(t, Pipe{}.ContinueOnError())
+}
+
+func TestDescription(t *testing.T) {
+	require.NotEmpty(t, Pipe{}.String())
+}
+
+func createTemplateData() templateData {
+	return templateData{
+		Name:        "test",
+		Desc:        "Some desc",
+		Homepage:    "https://example.com",
+		Conflicts:   []string{"nope"},
+		Depends:     []string{"nope"},
+		Arches:      []string{"x86_64", "i686", "aarch64", "armv6h", "armv7h"},
+		Rel:         "1",
+		Provides:    []string{"test"},
+		OptDepends:  []string{"nfpm"},
+		MakeDepends: []string{"git"},
+		Backup: []string{
+			"/etc/mypkg.conf",
+			"/var/share/mypkg",
+		},
+		Maintainers: []string{
+			"Ciclano <ciclano@example.com>",
+			"Cicrano <cicrano@example.com>",
+		},
+		Contributors: []string{
+			"Fulano <fulano@example.com>",
+			"Beltrano <beltrano@example.com>",
+		},
+		License: "MIT",
+		Version: "0.1.3",
+		Prepare: `cd "${pkgname}_${pkgver}"
+		# download dependencies
+		go mod download`,
+		Build: `  cd "${pkgname}_${pkgver}"
+	  	export CGO_CPPFLAGS="${CPPFLAGS}"
+	  	export CGO_CFLAGS="${CFLAGS}"
+	  	export CGO_CXXFLAGS="${CXXFLAGS}"
+	  	export CGO_LDFLAGS="${LDFLAGS}"
+	  	export GOFLAGS="-buildmode=pie -trimpath -mod=readonly -modcacherw"
+	  	go build -ldflags="-w -s -buildid='' -linkmode=external -X main.version=${pkgver}" .
+	  	chmod +x "./${pkgname}"`,
+		Package: `cd "${pkgname}_${pkgver}"
+		install -Dsm755 ./goreleaser "${pkgdir}/usr/bin/goreleaser"
+		mkdir -p "${pkgdir}/usr/share/bash-completion/completions/"
+		mkdir -p "${pkgdir}/usr/share/zsh/site-functions/"
+		mkdir -p "${pkgdir}/usr/share/fish/vendor_completions.d/"
+		./goreleaser completion bash > "${pkgdir}/usr/share/bash-completion/completions/goreleaser"
+		./goreleaser completion zsh > "${pkgdir}/usr/share/zsh/site-functions/_goreleaser"
+		./goreleaser completion fish > "${pkgdir}/usr/share/fish/vendor_completions.d/goreleaser.fish"`,
+		Sources: sources{
+			DownloadURL: "https://github.com/caarlos0/test/releases/download/v0.1.3/test_Linux_x86_64.tar.gz",
+			SHA256:      "1633f61598ab0791e213135923624eb342196b3494909c91899bcd0560f84c67",
+			Format:      "tar.gz",
+		},
+	}
+}
+
+func TestFullAur(t *testing.T) {
+	data := createTemplateData()
+	pkg, err := applyTemplate(testctx.NewWithCfg(config.Project{
+		ProjectName: "foo",
+	}), aurTemplateData, data)
+	require.NoError(t, err)
+
+	golden.RequireEqual(t, []byte(pkg))
+}
+
+func TestAurSimple(t *testing.T) {
+	pkg, err := applyTemplate(testctx.New(), aurTemplateData, createTemplateData())
+	require.NoError(t, err)
+	require.Contains(t, pkg, `# Maintainer: Ciclano <ciclano@example.com>`)
+	require.Contains(t, pkg, `# Maintainer: Cicrano <cicrano@example.com>`)
+	require.Contains(t, pkg, `# Contributor: Fulano <fulano@example.com>`)
+	require.Contains(t, pkg, `# Contributor: Beltrano <beltrano@example.com>`)
+	require.Contains(t, pkg, `pkgname='test'`)
+	require.Contains(t, pkg, `url='https://example.com'`)
+	require.Contains(t, pkg, `source=("${pkgname}_${pkgver}.tar.gz::https://github.com/caarlos0/test/releases/download/v0.1.3/test_Linux_x86_64.tar.gz")`)
+	require.Contains(t, pkg, `sha256sums=('1633f61598ab0791e213135923624eb342196b3494909c91899bcd0560f84c67')`)
+	require.Contains(t, pkg, `pkgver=0.1.3`)
+}
+
+func TestFullSrcInfo(t *testing.T) {
+	data := createTemplateData()
+	data.License = "MIT"
+	pkg, err := applyTemplate(testctx.NewWithCfg(config.Project{
+		ProjectName: "foo",
+	}), srcInfoTemplate, data)
+	require.NoError(t, err)
+
+	golden.RequireEqual(t, []byte(pkg))
+}
+
+func TestSrcInfoSimple(t *testing.T) {
+	pkg, err := applyTemplate(testctx.New(), srcInfoTemplate, createTemplateData())
+	require.NoError(t, err)
+	require.Contains(t, pkg, `pkgbase = test`)
+	require.Contains(t, pkg, `pkgname = test`)
+	require.Contains(t, pkg, `url = https://example.com`)
+	require.Contains(t, pkg, `source = https://github.com/caarlos0/test/releases/download/v0.1.3/test_Linux_x86_64.tar.gz`)
+	require.Contains(t, pkg, `sha256sums = 1633f61598ab0791e213135923624eb342196b3494909c91899bcd0560f84c67`)
+	require.Contains(t, pkg, `pkgver = 0.1.3`)
+}
+
+func TestFullPipe(t *testing.T) {
+	type testcase struct {
+		prepare                   func(ctx *context.Context)
+		expectedRunError          string
+		expectedRunErrorCheck     func(testing.TB, error)
+		expectedPublishError      string
+		expectedPublishErrorIs    error
+		expectedPublishErrorCheck func(testing.TB, error)
+	}
+	for name, tt := range map[string]testcase{
+		"default": {
+			prepare: func(ctx *context.Context) {
+				ctx.TokenType = context.TokenTypeGitHub
+				ctx.Config.AURSources[0].Homepage = "https://github.com/goreleaser"
+			},
+		},
+		"custom-dir": {
+			prepare: func(ctx *context.Context) {
+				ctx.TokenType = context.TokenTypeGitHub
+				ctx.Config.AURSources[0].Homepage = "https://github.com/goreleaser"
+				ctx.Config.AURSources[0].Directory = "foo"
+			},
+		},
+		"with-more-opts": {
+			prepare: func(ctx *context.Context) {
+				ctx.TokenType = context.TokenTypeGitHub
+				ctx.Config.AURSources[0].Homepage = "https://github.com/goreleaser"
+				ctx.Config.AURSources[0].Maintainers = []string{"me"}
+				ctx.Config.AURSources[0].Contributors = []string{"me as well"}
+				ctx.Config.AURSources[0].Depends = []string{"curl", "bash"}
+				ctx.Config.AURSources[0].OptDepends = []string{"wget: stuff", "foo: bar"}
+				ctx.Config.AURSources[0].Provides = []string{"git", "svn"}
+				ctx.Config.AURSources[0].Conflicts = []string{"libcurl", "cvs", "blah"}
+			},
+		},
+		"default-gitlab": {
+			prepare: func(ctx *context.Context) {
+				ctx.TokenType = context.TokenTypeGitLab
+				ctx.Config.AURSources[0].Homepage = "https://gitlab.com/goreleaser"
+			},
+		},
+		"invalid-name-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].Name = "{{ .Asdsa }"
+			},
+			expectedRunErrorCheck: testlib.RequireTemplateError,
+		},
+		"invalid-package-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].Package = "{{ .Asdsa }"
+			},
+			expectedRunErrorCheck: testlib.RequireTemplateError,
+		},
+		"invalid-commit-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].CommitMessageTemplate = "{{ .Asdsa }"
+			},
+			expectedPublishErrorCheck: testlib.RequireTemplateError,
+		},
+		"invalid-key-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].PrivateKey = "{{ .Asdsa }"
+			},
+			expectedPublishErrorCheck: testlib.RequireTemplateError,
+		},
+		"no-key": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].PrivateKey = ""
+			},
+			expectedPublishError: `private_key is empty`,
+		},
+		"key-not-found": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].PrivateKey = "testdata/nope"
+			},
+			expectedPublishErrorIs: os.ErrNotExist,
+		},
+		"invalid-git-url-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].GitURL = "{{ .Asdsa }"
+			},
+			expectedPublishErrorCheck: testlib.RequireTemplateError,
+		},
+		"no-git-url": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].GitURL = ""
+			},
+			expectedPublishError: `url is empty`,
+		},
+		"invalid-ssh-cmd-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].GitSSHCommand = "{{ .Asdsa }"
+			},
+			expectedPublishErrorCheck: testlib.RequireTemplateError,
+		},
+		"invalid-commit-author-template": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].CommitAuthor.Name = "{{ .Asdsa }"
+			},
+			expectedPublishErrorCheck: testlib.RequireTemplateError,
+		},
+		"simple-quote-inside-description": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].Description = "Let's go"
+			},
+		},
+		"double-quote-inside-description": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].Description = `This is a "test"`
+			},
+		},
+		"mixed-quote-inside-description": {
+			prepare: func(ctx *context.Context) {
+				ctx.Config.AURSources[0].Description = `Let's go, this is a "test"`
+			},
+		},
+	} {
+		t.Run(name, func(t *testing.T) {
+			url := testlib.GitMakeBareRepository(t)
+			key := testlib.MakeNewSSHKey(t, "")
+
+			folder := t.TempDir()
+			ctx := testctx.NewWithCfg(
+				config.Project{
+					Dist:        folder,
+					ProjectName: name,
+					AURSources: []config.AURSource{
+						{
+							Name:        name,
+							IDs:         []string{"foo"},
+							PrivateKey:  key,
+							License:     "MIT",
+							GitURL:      url,
+							Description: "A run pipe test fish food and FOO={{ .Env.FOO }}",
+						},
+					},
+					Env: []string{"FOO=foo_is_bar"},
+				},
+				testctx.WithCurrentTag("v1.0.1-foo"),
+				testctx.WithSemver(1, 0, 1, "foo"),
+				testctx.WithVersion("1.0.1-foo"),
+			)
+
+			tt.prepare(ctx)
+			ctx.Artifacts.Add(&artifact.Artifact{
+				Name:    "should-be-ignored.tar.gz",
+				Path:    "doesnt matter",
+				Goos:    "linux",
+				Goarch:  "amd64",
+				Goamd64: "v3",
+				Type:    artifact.UploadableArchive,
+				Extra: map[string]interface{}{
+					artifact.ExtraID:       "bar",
+					artifact.ExtraFormat:   "tar.gz",
+					artifact.ExtraBinaries: []string{"bar"},
+				},
+			})
+			ctx.Artifacts.Add(&artifact.Artifact{
+				Name:    "bar_bin.tar.gz",
+				Path:    "doesnt matter",
+				Goos:    "linux",
+				Goarch:  "amd64",
+				Goamd64: "v1",
+				Type:    artifact.UploadableArchive,
+				Extra: map[string]interface{}{
+					artifact.ExtraID:       "bar",
+					artifact.ExtraFormat:   "tar.gz",
+					artifact.ExtraBinaries: []string{"bar"},
+				},
+			})
+			path := filepath.Join(folder, "sources.tar.gz")
+
+			ctx.Artifacts.Add(&artifact.Artifact{
+				Name: "sources.tar.gz",
+				Path: path,
+				Type: artifact.UploadableSourceArchive,
+				Extra: map[string]interface{}{
+					artifact.ExtraID:       "foo",
+					artifact.ExtraFormat:   "tar.gz",
+					artifact.ExtraBinaries: []string{"name"},
+				},
+			})
+
+			f, err := os.Create(path)
+			require.NoError(t, err)
+			require.NoError(t, f.Close())
+			client := client.NewMock()
+
+			require.NoError(t, Pipe{}.Default(ctx))
+
+			if tt.expectedRunError != "" {
+				require.EqualError(t, runAll(ctx, client), tt.expectedRunError)
+				return
+			}
+			if tt.expectedRunErrorCheck != nil {
+				tt.expectedRunErrorCheck(t, runAll(ctx, client))
+				return
+			}
+			require.NoError(t, runAll(ctx, client))
+
+			if tt.expectedPublishError != "" {
+				require.EqualError(t, Pipe{}.Publish(ctx), tt.expectedPublishError)
+				return
+			}
+
+			if tt.expectedPublishErrorIs != nil {
+				require.ErrorIs(t, Pipe{}.Publish(ctx), tt.expectedPublishErrorIs)
+				return
+			}
+
+			if tt.expectedPublishErrorCheck != nil {
+				tt.expectedPublishErrorCheck(t, Pipe{}.Publish(ctx))
+				return
+			}
+
+			require.NoError(t, Pipe{}.Publish(ctx))
+
+			requireEqualRepoFiles(t, folder, ctx.Config.AURSources[0].Directory, name, url)
+		})
+	}
+}
+
+func TestRunPipe(t *testing.T) {
+	url := testlib.GitMakeBareRepository(t)
+	key := testlib.MakeNewSSHKey(t, "")
+
+	folder := t.TempDir()
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			Dist:        folder,
+			ProjectName: "foo",
+			AURSources: []config.AURSource{
+				{
+					License:     "MIT",
+					Description: "A run pipe test aur and FOO={{ .Env.FOO }}",
+					Homepage:    "https://github.com/goreleaser",
+					IDs:         []string{"foo"},
+					GitURL:      url,
+					PrivateKey:  key,
+				},
+			},
+			GitHubURLs: config.GitHubURLs{
+				Download: "https://github.com",
+			},
+			Release: config.Release{
+				GitHub: config.Repo{
+					Owner: "test",
+					Name:  "test",
+				},
+			},
+			Env: []string{"FOO=foo_is_bar"},
+		},
+		testctx.GitHubTokenType,
+		testctx.WithCurrentTag("v1.0.1"),
+		testctx.WithSemver(1, 0, 1, ""),
+		testctx.WithVersion("1.0.1"),
+	)
+
+	for _, a := range []struct {
+		name string
+	}{
+		{
+			name: "source",
+		},
+	} {
+		path := filepath.Join(folder, fmt.Sprintf("%s.tar.gz", a.name))
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name:    fmt.Sprintf("%s.tar.gz", a.name),
+			Path:    path,
+			Goamd64: "v1",
+			Type:    artifact.UploadableSourceArchive,
+			Extra: map[string]interface{}{
+				artifact.ExtraID:       "foo",
+				artifact.ExtraFormat:   "tar.gz",
+				artifact.ExtraBinaries: []string{"foo"},
+			},
+		})
+		f, err := os.Create(path)
+		require.NoError(t, err)
+		require.NoError(t, f.Close())
+	}
+
+	client := client.NewMock()
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	require.NoError(t, runAll(ctx, client))
+	require.NoError(t, Pipe{}.Publish(ctx))
+
+	requireEqualRepoFiles(t, folder, ".", "foo", url)
+}
+
+func TestRunPipeMultipleConfigurations(t *testing.T) {
+	url := testlib.GitMakeBareRepository(t)
+	key := testlib.MakeNewSSHKey(t, "")
+
+	folder := t.TempDir()
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			Dist:        folder,
+			ProjectName: "foo",
+			AURSources: []config.AURSource{
+				{
+					Name:        "foo",
+					IDs:         []string{"foo"},
+					PrivateKey:  key,
+					License:     "MIT",
+					GitURL:      url,
+					Description: "The foo aur",
+					Directory:   "foo",
+				},
+				{
+					Name:        "bar",
+					IDs:         []string{"bar"},
+					PrivateKey:  key,
+					License:     "MIT",
+					GitURL:      url,
+					Description: "The bar aur",
+					Directory:   "bar",
+				},
+			},
+		},
+		testctx.WithCurrentTag("v1.0.1-foo"),
+		testctx.WithSemver(1, 0, 1, "foo"),
+		testctx.WithVersion("1.0.1-foo"),
+	)
+
+	path := filepath.Join(folder, "source.tar.gz")
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:    "source_bin.tar.gz",
+		Path:    path,
+		Goamd64: "v1",
+		Type:    artifact.UploadableSourceArchive,
+		Extra: map[string]interface{}{
+			artifact.ExtraID:       "bar",
+			artifact.ExtraFormat:   "tar.gz",
+			artifact.ExtraBinaries: []string{"bar"},
+		},
+	})
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:    "source.tar.gz",
+		Path:    path,
+		Goos:    "linux",
+		Goarch:  "amd64",
+		Goamd64: "v1",
+		Type:    artifact.UploadableSourceArchive,
+		Extra: map[string]interface{}{
+			artifact.ExtraID:       "foo",
+			artifact.ExtraFormat:   "tar.gz",
+			artifact.ExtraBinaries: []string{"name"},
+		},
+	})
+
+	f, err := os.Create(path)
+	require.NoError(t, err)
+	require.NoError(t, f.Close())
+	client := client.NewMock()
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	require.NoError(t, runAll(ctx, client))
+	require.NoError(t, Pipe{}.Publish(ctx))
+
+	dir := t.TempDir()
+	_, err = git.Run(testctx.New(), "-C", dir, "clone", url, "repo")
+	require.NoError(t, err)
+
+	require.FileExists(t, filepath.Join(dir, "repo", "foo", ".SRCINFO"))
+	require.FileExists(t, filepath.Join(dir, "repo", "foo", "PKGBUILD"))
+	require.FileExists(t, filepath.Join(dir, "repo", "bar", ".SRCINFO"))
+	require.FileExists(t, filepath.Join(dir, "repo", "bar", "PKGBUILD"))
+}
+
+func TestRunPipeNoBuilds(t *testing.T) {
+	ctx := testctx.NewWithCfg(config.Project{
+		ProjectName: "foo",
+		AURSources:  []config.AURSource{{}},
+	}, testctx.GitHubTokenType)
+	client := client.NewMock()
+	require.NoError(t, Pipe{}.Default(ctx))
+	require.Equal(t, ErrNoArchivesFound, runAll(ctx, client))
+	require.False(t, client.CreatedFile)
+}
+
+func TestRunPipeWrappedInDirectory(t *testing.T) {
+	url := testlib.GitMakeBareRepository(t)
+	key := testlib.MakeNewSSHKey(t, "")
+	folder := t.TempDir()
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			Dist:        folder,
+			ProjectName: "foo",
+			AURSources: []config.AURSource{{
+				GitURL:     url,
+				PrivateKey: key,
+			}},
+		},
+		testctx.WithVersion("1.2.1"),
+		testctx.WithCurrentTag("v1.2.1"),
+		testctx.WithSemver(1, 2, 1, ""),
+	)
+
+	path := filepath.Join(folder, "dist/sources/foo")
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:    "source.tar.gz",
+		Path:    path,
+		Goamd64: "v1",
+		Type:    artifact.UploadableSourceArchive,
+		Extra: map[string]interface{}{
+			artifact.ExtraID:        "foo",
+			artifact.ExtraFormat:    "tar.gz",
+			artifact.ExtraBinaries:  []string{"foo"},
+			artifact.ExtraWrappedIn: "foo",
+		},
+	})
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	require.NoError(t, os.MkdirAll(filepath.Dir(path), 0o755))
+	f, err := os.Create(path)
+	require.NoError(t, err)
+	require.NoError(t, f.Close())
+
+	client := client.NewMock()
+	require.NoError(t, runAll(ctx, client))
+	require.NoError(t, Pipe{}.Publish(ctx))
+
+	requireEqualRepoFiles(t, folder, ".", "foo", url)
+}
+
+func TestRunPipeBinaryRelease(t *testing.T) {
+	url := testlib.GitMakeBareRepository(t)
+	key := testlib.MakeNewSSHKey(t, "")
+	folder := t.TempDir()
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			Dist:        folder,
+			ProjectName: "foo",
+			AURSources: []config.AURSource{{
+				GitURL:     url,
+				PrivateKey: key,
+			}},
+		},
+		testctx.WithVersion("1.2.1"),
+		testctx.WithCurrentTag("v1.2.1"),
+		testctx.WithSemver(1, 2, 1, ""),
+	)
+
+	path := filepath.Join(folder, "dist/sources/foo")
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:    "sources",
+		Path:    path,
+		Goamd64: "v1",
+		Type:    artifact.UploadableSourceArchive,
+		Extra: map[string]interface{}{
+			artifact.ExtraID:     "foo",
+			artifact.ExtraFormat: "binary",
+			artifact.ExtraBinary: "foo",
+		},
+	})
+
+	require.NoError(t, Pipe{}.Default(ctx))
+	require.NoError(t, os.MkdirAll(filepath.Dir(path), 0o755))
+	f, err := os.Create(path)
+	require.NoError(t, err)
+	require.NoError(t, f.Close())
+
+	client := client.NewMock()
+	require.NoError(t, runAll(ctx, client))
+	require.NoError(t, Pipe{}.Publish(ctx))
+
+	requireEqualRepoFiles(t, folder, ".", "foo", url)
+}
+
+func TestRunPipeNoUpload(t *testing.T) {
+	folder := t.TempDir()
+	testPublish := func(tb testing.TB, modifier func(ctx *context.Context)) {
+		tb.Helper()
+		ctx := testctx.NewWithCfg(
+			config.Project{
+				Dist:        folder,
+				ProjectName: "foo",
+				Release:     config.Release{},
+				AURSources:  []config.AURSource{{}},
+			},
+			testctx.GitHubTokenType,
+			testctx.WithCurrentTag("v1.0.1"),
+			testctx.WithSemver(1, 0, 1, ""),
+		)
+
+		path := filepath.Join(folder, "whatever.tar.gz")
+		f, err := os.Create(path)
+		require.NoError(t, err)
+		require.NoError(t, f.Close())
+		ctx.Artifacts.Add(&artifact.Artifact{
+			Name:    "source",
+			Path:    path,
+			Goamd64: "v1",
+			Type:    artifact.UploadableSourceArchive,
+			Extra: map[string]interface{}{
+				artifact.ExtraID:       "foo",
+				artifact.ExtraFormat:   "tar.gz",
+				artifact.ExtraBinaries: []string{"foo"},
+			},
+		})
+
+		modifier(ctx)
+
+		require.NoError(t, Pipe{}.Default(ctx))
+		client := client.NewMock()
+		require.NoError(t, runAll(ctx, client))
+		t.Log(Pipe{}.Publish(ctx))
+		testlib.AssertSkipped(t, Pipe{}.Publish(ctx))
+		require.False(t, client.CreatedFile)
+	}
+
+	t.Run("skip upload true", func(t *testing.T) {
+		testPublish(t, func(ctx *context.Context) {
+			ctx.Config.AURSources[0].SkipUpload = "true"
+			ctx.Semver.Prerelease = ""
+		})
+	})
+	t.Run("skip upload auto", func(t *testing.T) {
+		testPublish(t, func(ctx *context.Context) {
+			ctx.Config.AURSources[0].SkipUpload = "auto"
+			ctx.Semver.Prerelease = "beta1"
+		})
+	})
+}
+
+func TestRunEmptyTokenType(t *testing.T) {
+	folder := t.TempDir()
+	ctx := testctx.NewWithCfg(
+		config.Project{
+			Dist:        folder,
+			ProjectName: "foo",
+			Release:     config.Release{},
+			AURSources: []config.AURSource{
+				{},
+			},
+		},
+		testctx.WithGitInfo(context.GitInfo{CurrentTag: "v1.0.1"}),
+		testctx.WithSemver(1, 0, 1, ""),
+	)
+	path := filepath.Join(folder, "whatever.tar.gz")
+	f, err := os.Create(path)
+	require.NoError(t, err)
+	require.NoError(t, f.Close())
+	ctx.Artifacts.Add(&artifact.Artifact{
+		Name:   "source",
+		Path:   path,
+		Goos:   "linux",
+		Goarch: "amd64",
+		Type:   artifact.UploadableSourceArchive,
+		Extra: map[string]interface{}{
+			artifact.ExtraID:       "foo",
+			artifact.ExtraFormat:   "tar.gz",
+			artifact.ExtraBinaries: []string{"foo"},
+		},
+	})
+	client := client.NewMock()
+	require.NoError(t, runAll(ctx, client))
+}
+
+func TestDefault(t *testing.T) {
+	t.Run("empty", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			ProjectName: "myproject",
+			AURSources:  []config.AURSource{{}},
+		}, testctx.GitHubTokenType)
+		require.NoError(t, Pipe{}.Default(ctx))
+		require.Equal(t, config.AURSource{
+			Name:                  "myproject",
+			Conflicts:             []string{"myproject"},
+			Provides:              []string{"myproject"},
+			Arches:                []string{"x86_64", "aarch64"},
+			MakeDepends:           []string{"go", "git"},
+			Rel:                   "1",
+			CommitMessageTemplate: defaultCommitMsg,
+			Goamd64:               "v1",
+			CommitAuthor: config.CommitAuthor{
+				Name:  "goreleaserbot",
+				Email: "bot@goreleaser.com",
+			},
+		}, ctx.Config.AURSources[0])
+	})
+
+	t.Run("name-with-bin-suffix", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			ProjectName: "myproject-bin",
+			AURSources: []config.AURSource{
+				{
+					Name: "foo",
+				},
+			},
+		}, testctx.GitHubTokenType)
+		require.NoError(t, Pipe{}.Default(ctx))
+		require.Equal(t, config.AURSource{
+			Name:                  "foo",
+			Conflicts:             []string{"myproject-bin"}, // TODO(ldez) not sure about that.
+			Provides:              []string{"myproject-bin"}, // TODO(ldez) not sure about that.
+			Arches:                []string{"x86_64", "aarch64"},
+			MakeDepends:           []string{"go", "git"},
+			Rel:                   "1",
+			CommitMessageTemplate: defaultCommitMsg,
+			Goamd64:               "v1",
+			CommitAuthor: config.CommitAuthor{
+				Name:  "goreleaserbot",
+				Email: "bot@goreleaser.com",
+			},
+		}, ctx.Config.AURSources[0])
+	})
+
+	t.Run("partial", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			ProjectName: "myproject",
+			AURSources: []config.AURSource{
+				{
+					Conflicts: []string{"somethingelse"},
+					Goamd64:   "v3",
+				},
+			},
+		}, testctx.GitHubTokenType)
+		require.NoError(t, Pipe{}.Default(ctx))
+		require.Equal(t, config.AURSource{
+			Name:                  "myproject",
+			Conflicts:             []string{"somethingelse"},
+			Provides:              []string{"myproject"},
+			Arches:                []string{"x86_64", "aarch64"},
+			MakeDepends:           []string{"go", "git"},
+			Rel:                   "1",
+			CommitMessageTemplate: defaultCommitMsg,
+			Goamd64:               "v3",
+			CommitAuthor: config.CommitAuthor{
+				Name:  "goreleaserbot",
+				Email: "bot@goreleaser.com",
+			},
+		}, ctx.Config.AURSources[0])
+	})
+}
+
+func TestSkip(t *testing.T) {
+	t.Run("skip", func(t *testing.T) {
+		require.True(t, Pipe{}.Skip(testctx.New()))
+	})
+	t.Run("skip flag", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			AURSources: []config.AURSource{
+				{},
+			},
+		}, testctx.Skip(skips.AURSource))
+		require.True(t, Pipe{}.Skip(ctx))
+	})
+	t.Run("dont skip", func(t *testing.T) {
+		ctx := testctx.NewWithCfg(config.Project{
+			AURSources: []config.AURSource{
+				{},
+			},
+		})
+		require.False(t, Pipe{}.Skip(ctx))
+	})
+}
+
+func requireEqualRepoFiles(tb testing.TB, distDir, repoDir, name, url string) {
+	tb.Helper()
+	dir := tb.TempDir()
+	_, err := git.Run(testctx.New(), "-C", dir, "clone", url, "repo")
+	require.NoError(tb, err)
+
+	for reponame, ext := range map[string]string{
+		"PKGBUILD": ".pkgbuild",
+		".SRCINFO": ".srcinfo",
+	} {
+		path := filepath.Join(distDir, "aur", name+ext)
+		bts, err := os.ReadFile(path)
+		require.NoError(tb, err)
+		golden.RequireEqualExt(tb, bts, ext)
+
+		bts, err = os.ReadFile(filepath.Join(dir, "repo", repoDir, reponame))
+		require.NoError(tb, err)
+		golden.RequireEqualExt(tb, bts, ext)
+	}
+}
diff --git a/internal/pipe/aursources/doc.go b/internal/pipe/aursources/doc.go
new file mode 100644
index 00000000..88d88841
--- /dev/null
+++ b/internal/pipe/aursources/doc.go
@@ -0,0 +1,2 @@
+// Package aursources provides the Arch User Repository (AUR) integration to GoReleaser.
+package aursources
diff --git a/internal/pipe/aursources/testdata/TestFullAur.golden b/internal/pipe/aursources/testdata/TestFullAur.golden
new file mode 100644
index 00000000..2d191b86
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullAur.golden
@@ -0,0 +1,45 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+# Maintainer: Ciclano <ciclano@example.com>
+# Maintainer: Cicrano <cicrano@example.com>
+# Contributor: Fulano <fulano@example.com>
+# Contributor: Beltrano <beltrano@example.com>
+
+pkgname='test'
+pkgver=0.1.3
+pkgrel=1
+pkgdesc='Some desc'
+url='https://example.com'
+arch=('x86_64' 'i686' 'aarch64' 'armv6h' 'armv7h')
+license=('MIT')
+provides=('test')
+conflicts=('nope')
+depends=('nope')
+makedepends=('git')
+optdepends=('nfpm')
+backup=('/etc/mypkg.conf' '/var/share/mypkg')
+source=("${pkgname}_${pkgver}.tar.gz::https://github.com/caarlos0/test/releases/download/v0.1.3/test_Linux_x86_64.tar.gz")
+sha256sums=('1633f61598ab0791e213135923624eb342196b3494909c91899bcd0560f84c67')prepare() {
+  cd "${pkgname}_${pkgver}"
+  # download dependencies
+  go mod download
+}
+build() {
+  cd "${pkgname}_${pkgver}"
+  export CGO_CPPFLAGS="${CPPFLAGS}"
+  export CGO_CFLAGS="${CFLAGS}"
+  export CGO_CXXFLAGS="${CXXFLAGS}"
+  export CGO_LDFLAGS="${LDFLAGS}"
+  export GOFLAGS="-buildmode=pie -trimpath -mod=readonly -modcacherw"
+  go build -ldflags="-w -s -buildid='' -linkmode=external -X main.version=${pkgver}" .
+  chmod +x "./${pkgname}"
+}
+package() {
+  cd "${pkgname}_${pkgver}"
+  install -Dsm755 ./goreleaser "${pkgdir}/usr/bin/goreleaser"
+  mkdir -p "${pkgdir}/usr/share/bash-completion/completions/"
+  mkdir -p "${pkgdir}/usr/share/zsh/site-functions/"
+  mkdir -p "${pkgdir}/usr/share/fish/vendor_completions.d/"
+  ./goreleaser completion bash > "${pkgdir}/usr/share/bash-completion/completions/goreleaser"
+  ./goreleaser completion zsh > "${pkgdir}/usr/share/zsh/site-functions/_goreleaser"
+  ./goreleaser completion fish > "${pkgdir}/usr/share/fish/vendor_completions.d/goreleaser.fish"
+}
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.pkgbuild.golden
new file mode 100644
index 00000000..27f3bb58
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='custom-dir'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='A run pipe test fish food and FOO=foo_is_bar'
+url='https://github.com/goreleaser'
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('custom-dir')
+conflicts=('custom-dir')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.srcinfo.golden
new file mode 100644
index 00000000..0afadd84
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/custom-dir.srcinfo.golden
@@ -0,0 +1,17 @@
+pkgbase = custom-dir
+	pkgdesc = A run pipe test fish food and FOO=foo_is_bar
+	pkgver = 1.0.1
+	pkgrel = 1
+	url = https://github.com/goreleaser
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = custom-dir
+	provides = custom-dir
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = custom-dir
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.pkgbuild.golden
new file mode 100644
index 00000000..0ba07ebd
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='default-gitlab'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='A run pipe test fish food and FOO=foo_is_bar'
+url='https://gitlab.com/goreleaser'
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('default-gitlab')
+conflicts=('default-gitlab')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.srcinfo.golden
new file mode 100644
index 00000000..a7151501
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/default-gitlab.srcinfo.golden
@@ -0,0 +1,17 @@
+pkgbase = default-gitlab
+	pkgdesc = A run pipe test fish food and FOO=foo_is_bar
+	pkgver = 1.0.1
+	pkgrel = 1
+	url = https://gitlab.com/goreleaser
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = default-gitlab
+	provides = default-gitlab
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = default-gitlab
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/default.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/default.pkgbuild.golden
new file mode 100644
index 00000000..f06ff367
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/default.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='default'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='A run pipe test fish food and FOO=foo_is_bar'
+url='https://github.com/goreleaser'
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('default')
+conflicts=('default')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/default.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/default.srcinfo.golden
new file mode 100644
index 00000000..1b71dd53
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/default.srcinfo.golden
@@ -0,0 +1,17 @@
+pkgbase = default
+	pkgdesc = A run pipe test fish food and FOO=foo_is_bar
+	pkgver = 1.0.1
+	pkgrel = 1
+	url = https://github.com/goreleaser
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = default
+	provides = default
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = default
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.pkgbuild.golden
new file mode 100644
index 00000000..525321c6
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='double-quote-inside-description'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='This is a "test"'
+url=''
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('double-quote-inside-description')
+conflicts=('double-quote-inside-description')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.srcinfo.golden
new file mode 100644
index 00000000..cd71b9c9
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/double-quote-inside-description.srcinfo.golden
@@ -0,0 +1,16 @@
+pkgbase = double-quote-inside-description
+	pkgdesc = This is a "test"
+	pkgver = 1.0.1
+	pkgrel = 1
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = double-quote-inside-description
+	provides = double-quote-inside-description
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = double-quote-inside-description
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.pkgbuild.golden
new file mode 100644
index 00000000..74982ee4
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='mixed-quote-inside-description'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc="Let's go, this is a 'test'"
+url=''
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('mixed-quote-inside-description')
+conflicts=('mixed-quote-inside-description')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.srcinfo.golden
new file mode 100644
index 00000000..501c64a0
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/mixed-quote-inside-description.srcinfo.golden
@@ -0,0 +1,16 @@
+pkgbase = mixed-quote-inside-description
+	pkgdesc = Let's go, this is a "test"
+	pkgver = 1.0.1
+	pkgrel = 1
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = mixed-quote-inside-description
+	provides = mixed-quote-inside-description
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = mixed-quote-inside-description
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.pkgbuild.golden
new file mode 100644
index 00000000..b6db63c7
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='simple-quote-inside-description'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc="Let's go"
+url=''
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('simple-quote-inside-description')
+conflicts=('simple-quote-inside-description')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.srcinfo.golden
new file mode 100644
index 00000000..238613f8
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/simple-quote-inside-description.srcinfo.golden
@@ -0,0 +1,16 @@
+pkgbase = simple-quote-inside-description
+	pkgdesc = Let's go
+	pkgver = 1.0.1
+	pkgrel = 1
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = simple-quote-inside-description
+	provides = simple-quote-inside-description
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = simple-quote-inside-description
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.pkgbuild.golden b/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.pkgbuild.golden
new file mode 100644
index 00000000..4a53ca82
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.pkgbuild.golden
@@ -0,0 +1,18 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+# Maintainer: me
+# Contributor: me as well
+
+pkgname='with-more-opts'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='A run pipe test fish food and FOO=foo_is_bar'
+url='https://github.com/goreleaser'
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('git' 'svn')
+conflicts=('libcurl' 'cvs' 'blah')
+depends=('curl' 'bash')
+makedepends=('go' 'git')
+optdepends=('wget: stuff' 'foo: bar')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1-foo/sources.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.srcinfo.golden b/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.srcinfo.golden
new file mode 100644
index 00000000..d56d88c0
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullPipe/with-more-opts.srcinfo.golden
@@ -0,0 +1,24 @@
+pkgbase = with-more-opts
+	pkgdesc = A run pipe test fish food and FOO=foo_is_bar
+	pkgver = 1.0.1
+	pkgrel = 1
+	url = https://github.com/goreleaser
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	optdepends = wget: stuff
+	optdepends = foo: bar
+	depends = curl
+	depends = bash
+	makedepends = go
+	makedepends = git
+	conflicts = libcurl
+	conflicts = cvs
+	conflicts = blah
+	provides = git
+	provides = svn
+	
+	source = https://dummyhost/download/v1.0.1-foo/sources.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = with-more-opts
diff --git a/internal/pipe/aursources/testdata/TestFullSrcInfo.golden b/internal/pipe/aursources/testdata/TestFullSrcInfo.golden
new file mode 100644
index 00000000..3c77289d
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestFullSrcInfo.golden
@@ -0,0 +1,21 @@
+pkgbase = test
+	pkgdesc = Some desc
+	pkgver = 0.1.3
+	pkgrel = 1
+	url = https://example.com
+	arch = x86_64
+	arch = i686
+	arch = aarch64
+	arch = armv6h
+	arch = armv7h
+	license = MIT
+	optdepends = nfpm
+	depends = nope
+	makedepends = git
+	conflicts = nope
+	provides = test
+	
+	source = https://github.com/caarlos0/test/releases/download/v0.1.3/test_Linux_x86_64.tar.gz
+	sha256sums = 1633f61598ab0791e213135923624eb342196b3494909c91899bcd0560f84c67
+	
+pkgname = test
diff --git a/internal/pipe/aursources/testdata/TestRunPipe.pkgbuild.golden b/internal/pipe/aursources/testdata/TestRunPipe.pkgbuild.golden
new file mode 100644
index 00000000..66f57520
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipe.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='foo'
+pkgver=1.0.1
+pkgrel=1
+pkgdesc='A run pipe test aur and FOO=foo_is_bar'
+url='https://github.com/goreleaser'
+arch=('aarch64' 'x86_64')
+license=('MIT')
+provides=('foo')
+conflicts=('foo')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.0.1/source.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestRunPipe.srcinfo.golden b/internal/pipe/aursources/testdata/TestRunPipe.srcinfo.golden
new file mode 100644
index 00000000..2a4eb6a2
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipe.srcinfo.golden
@@ -0,0 +1,17 @@
+pkgbase = foo
+	pkgdesc = A run pipe test aur and FOO=foo_is_bar
+	pkgver = 1.0.1
+	pkgrel = 1
+	url = https://github.com/goreleaser
+	arch = aarch64
+	arch = x86_64
+	license = MIT
+	makedepends = go
+	makedepends = git
+	conflicts = foo
+	provides = foo
+	
+	source = https://dummyhost/download/v1.0.1/source.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = foo
diff --git a/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.pkgbuild.golden b/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.pkgbuild.golden
new file mode 100644
index 00000000..5a7e69c3
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='foo'
+pkgver=1.2.1
+pkgrel=1
+pkgdesc=''
+url=''
+arch=('aarch64' 'x86_64')
+license=('')
+provides=('foo')
+conflicts=('foo')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.binary::https://dummyhost/download/v1.2.1/sources")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.srcinfo.golden b/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.srcinfo.golden
new file mode 100644
index 00000000..d2154d3e
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipeBinaryRelease.srcinfo.golden
@@ -0,0 +1,15 @@
+pkgbase = foo
+	pkgdesc =
+	pkgver = 1.2.1
+	pkgrel = 1
+	arch = aarch64
+	arch = x86_64
+	makedepends = go
+	makedepends = git
+	conflicts = foo
+	provides = foo
+	
+	source = https://dummyhost/download/v1.2.1/sources
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = foo
diff --git a/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.pkgbuild.golden b/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.pkgbuild.golden
new file mode 100644
index 00000000..7b82c4ca
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.pkgbuild.golden
@@ -0,0 +1,14 @@
+# This file was generated by GoReleaser. DO NOT EDIT.
+
+pkgname='foo'
+pkgver=1.2.1
+pkgrel=1
+pkgdesc=''
+url=''
+arch=('aarch64' 'x86_64')
+license=('')
+provides=('foo')
+conflicts=('foo')
+makedepends=('go' 'git')
+source=("${pkgname}_${pkgver}.tar.gz::https://dummyhost/download/v1.2.1/source.tar.gz")
+sha256sums=('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')
diff --git a/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.srcinfo.golden b/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.srcinfo.golden
new file mode 100644
index 00000000..3cdd65b7
--- /dev/null
+++ b/internal/pipe/aursources/testdata/TestRunPipeWrappedInDirectory.srcinfo.golden
@@ -0,0 +1,15 @@
+pkgbase = foo
+	pkgdesc =
+	pkgver = 1.2.1
+	pkgrel = 1
+	arch = aarch64
+	arch = x86_64
+	makedepends = go
+	makedepends = git
+	conflicts = foo
+	provides = foo
+	
+	source = https://dummyhost/download/v1.2.1/source.tar.gz
+	sha256sums = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
+	
+pkgname = foo
diff --git a/internal/pipe/aursources/tmpl.go b/internal/pipe/aursources/tmpl.go
new file mode 100644
index 00000000..6d4db67a
--- /dev/null
+++ b/internal/pipe/aursources/tmpl.go
@@ -0,0 +1,123 @@
+package aursources
+
+type templateData struct {
+	Name         string
+	Desc         string
+	Homepage     string
+	Version      string
+	License      string
+	Sources      sources
+	Maintainers  []string
+	Contributors []string
+	Provides     []string
+	Conflicts    []string
+	Backup       []string
+	Depends      []string
+	OptDepends   []string
+	MakeDepends  []string
+	Arches       []string
+	Rel          string
+	Prepare      string
+	Build        string
+	Package      string
+}
+
+type sources struct {
+	DownloadURL string
+	SHA256      string
+	Format      string
+}
+
+const aurTemplateData = `# This file was generated by GoReleaser. DO NOT EDIT.
+
+{{- range .Maintainers }}
+# Maintainer: {{ . }}
+{{- end }}
+{{- range .Contributors }}
+# Contributor: {{ . }}
+{{- end }}
+
+pkgname='{{ .Name }}'
+pkgver={{ .Version }}
+pkgrel={{ .Rel }}
+pkgdesc={{ quoteField .Desc }}
+url='{{ .Homepage }}'
+arch=({{ pkgArray .Arches }})
+license=('{{ .License }}')
+{{- with .Provides }}
+provides=({{ pkgArray . }})
+{{- end }}
+{{- with .Conflicts }}
+conflicts=({{ pkgArray . }})
+{{- end }}
+{{- with .Depends }}
+depends=({{ pkgArray . }})
+{{- end }}
+{{- with .MakeDepends }}
+makedepends=({{ pkgArray . }})
+{{- end }}
+{{- with .OptDepends }}
+optdepends=({{ pkgArray . }})
+{{- end }}
+{{- with .Backup }}
+backup=({{ pkgArray . }})
+{{- end }}
+
+{{- with .Sources }}
+source=("${pkgname}_${pkgver}.{{ .Format }}::{{ .DownloadURL }}")
+sha256sums=('{{ .SHA256 }}')
+{{- end }}
+
+{{-  with .Prepare -}}
+prepare() {
+{{ fixLines . }}
+}
+{{ end }}
+
+{{-  with .Build -}}
+build() {
+{{ fixLines . }}
+}
+{{ end }}
+
+{{-  with .Package -}}
+package() {
+{{ fixLines . }}
+}
+{{ end }}`
+
+const srcInfoTemplate = `pkgbase = {{ .Name }}
+	pkgdesc = {{ .Desc }}
+	pkgver = {{ .Version }}
+	pkgrel = {{ .Rel }}
+	{{ with .Homepage -}}
+	url = {{ . }}
+	{{ end -}}
+	{{ range .Arches -}}
+	arch = {{ . }}
+	{{ end -}}
+	{{ with .License -}}
+	license = {{ . }}
+	{{ end -}}
+	{{ range .OptDepends -}}
+	optdepends = {{ . }}
+	{{ end -}}
+	{{ range .Depends -}}
+	depends = {{ . }}
+	{{ end -}}
+	{{ range .MakeDepends -}}
+	makedepends = {{ . }}
+	{{ end -}}
+	{{ range .Conflicts -}}
+	conflicts = {{ . }}
+	{{ end -}}
+	{{ range .Provides -}}
+	provides = {{ . }}
+	{{ end -}}
+	{{- with .Sources }}
+	source = {{ .DownloadURL }}
+	sha256sums = {{ .SHA256 }}
+	{{ end -}}
+{{ printf "\n" -}}
+pkgname = {{ .Name }}
+`
diff --git a/internal/pipe/publish/publish.go b/internal/pipe/publish/publish.go
index 8537b61b..61b4c926 100644
--- a/internal/pipe/publish/publish.go
+++ b/internal/pipe/publish/publish.go
@@ -9,6 +9,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/middleware/skip"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/artifactory"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/aur"
+	"github.com/goreleaser/goreleaser/v2/internal/pipe/aursources"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/blob"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/brew"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/chocolatey"
@@ -56,6 +57,7 @@ func New() Pipe {
 			winget.Pipe{},
 			brew.Pipe{},
 			aur.Pipe{},
+			aursources.Pipe{},
 			krew.Pipe{},
 			scoop.Pipe{},
 			chocolatey.Pipe{},
diff --git a/internal/pipeline/pipeline.go b/internal/pipeline/pipeline.go
index 78b0982d..e1ebb360 100644
--- a/internal/pipeline/pipeline.go
+++ b/internal/pipeline/pipeline.go
@@ -7,6 +7,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/announce"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/archive"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/aur"
+	"github.com/goreleaser/goreleaser/v2/internal/pipe/aursources"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/before"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/brew"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/build"
@@ -131,6 +132,8 @@ var Pipeline = append(
 	sign.Pipe{},
 	// create arch linux aur pkgbuild
 	aur.Pipe{},
+	// create arch linux aur pkgbuild (sources)
+	aursources.Pipe{},
 	// create nixpkgs
 	nix.NewBuild(),
 	// winget installers
diff --git a/internal/skips/skips.go b/internal/skips/skips.go
index 8c63dd57..77985ec2 100644
--- a/internal/skips/skips.go
+++ b/internal/skips/skips.go
@@ -29,6 +29,7 @@ const (
 	Homebrew       Key = "homebrew"
 	Nix            Key = "nix"
 	AUR            Key = "aur"
+	AURSource      Key = "aur-source"
 	NFPM           Key = "nfpm"
 	Chocolatey     Key = "chocolatey"
 	Notarize       Key = "notarize"
@@ -116,6 +117,7 @@ var Release = Keys{
 	Homebrew,
 	Nix,
 	AUR,
+	AURSource,
 	NFPM,
 	Before,
 	Notarize,
diff --git a/internal/skips/skips_test.go b/internal/skips/skips_test.go
index e1a4638e..b751f4ba 100644
--- a/internal/skips/skips_test.go
+++ b/internal/skips/skips_test.go
@@ -56,7 +56,7 @@ func TestSetAllowed(t *testing.T) {
 func TestComplete(t *testing.T) {
 	require.Equal(
 		t,
-		[]string{"announce", "archive", "aur"},
+		[]string{"announce", "archive", "aur", "aur-source"},
 		skips.Release.Complete("a"),
 	)
 }
diff --git a/pkg/config/config.go b/pkg/config/config.go
index 15f66889..3eb9967f 100644
--- a/pkg/config/config.go
+++ b/pkg/config/config.go
@@ -222,6 +222,36 @@ type AUR struct {
 	Directory             string       `yaml:"directory,omitempty" json:"directory,omitempty"`
 }
 
+type AURSource struct {
+	Name                  string       `yaml:"name,omitempty" json:"name,omitempty"`
+	IDs                   []string     `yaml:"ids,omitempty" json:"ids,omitempty"`
+	CommitAuthor          CommitAuthor `yaml:"commit_author,omitempty" json:"commit_author,omitempty"`
+	CommitMessageTemplate string       `yaml:"commit_msg_template,omitempty" json:"commit_msg_template,omitempty"`
+	Description           string       `yaml:"description,omitempty" json:"description,omitempty"`
+	Homepage              string       `yaml:"homepage,omitempty" json:"homepage,omitempty"`
+	License               string       `yaml:"license,omitempty" json:"license,omitempty"`
+	SkipUpload            string       `yaml:"skip_upload,omitempty" json:"skip_upload,omitempty" jsonschema:"oneof_type=string;boolean"`
+	URLTemplate           string       `yaml:"url_template,omitempty" json:"url_template,omitempty"`
+	Maintainers           []string     `yaml:"maintainers,omitempty" json:"maintainers,omitempty"`
+	Contributors          []string     `yaml:"contributors,omitempty" json:"contributors,omitempty"`
+	Arches                []string     `yaml:"arches,omitempty" json:"arches,omitempty"`
+	Provides              []string     `yaml:"provides,omitempty" json:"provides,omitempty"`
+	Conflicts             []string     `yaml:"conflicts,omitempty" json:"conflicts,omitempty"`
+	Depends               []string     `yaml:"depends,omitempty" json:"depends,omitempty"`
+	OptDepends            []string     `yaml:"optdepends,omitempty" json:"optdepends,omitempty"`
+	MakeDepends           []string     `yaml:"makedepends,omitempty" json:"makedepends,omitempty"`
+	Backup                []string     `yaml:"backup,omitempty" json:"backup,omitempty"`
+	Rel                   string       `yaml:"rel,omitempty" json:"rel,omitempty"`
+	Prepare               string       `yaml:"prepare,omitempty" json:"prepare,omitempty"`
+	Build                 string       `yaml:"build,omitempty" json:"build,omitempty"`
+	Package               string       `yaml:"package,omitempty" json:"package,omitempty"`
+	GitURL                string       `yaml:"git_url,omitempty" json:"git_url,omitempty"`
+	GitSSHCommand         string       `yaml:"git_ssh_command,omitempty" json:"git_ssh_command,omitempty"`
+	PrivateKey            string       `yaml:"private_key,omitempty" json:"private_key,omitempty"`
+	Goamd64               string       `yaml:"goamd64,omitempty" json:"goamd64,omitempty"`
+	Directory             string       `yaml:"directory,omitempty" json:"directory,omitempty"`
+}
+
 // Homebrew contains the brew section.
 type Homebrew struct {
 	Name                  string               `yaml:"name,omitempty" json:"name,omitempty"`
@@ -1243,6 +1273,7 @@ type Project struct {
 	Nix             []Nix            `yaml:"nix,omitempty" json:"nix,omitempty"`
 	Winget          []Winget         `yaml:"winget,omitempty" json:"winget,omitempty"`
 	AURs            []AUR            `yaml:"aurs,omitempty" json:"aurs,omitempty"`
+	AURSources      []AURSource      `yaml:"aur_sources,omitempty" json:"aur_sources,omitempty"`
 	Krews           []Krew           `yaml:"krews,omitempty" json:"krews,omitempty"`
 	Kos             []Ko             `yaml:"kos,omitempty" json:"kos,omitempty"`
 	Scoops          []Scoop          `yaml:"scoops,omitempty" json:"scoops,omitempty"`
diff --git a/pkg/defaults/defaults.go b/pkg/defaults/defaults.go
index 0bc5cc3a..98314ba5 100644
--- a/pkg/defaults/defaults.go
+++ b/pkg/defaults/defaults.go
@@ -8,6 +8,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/archive"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/artifactory"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/aur"
+	"github.com/goreleaser/goreleaser/v2/internal/pipe/aursources"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/blob"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/bluesky"
 	"github.com/goreleaser/goreleaser/v2/internal/pipe/brew"
@@ -89,6 +90,7 @@ var Defaulters = []Defaulter{
 	blob.Pipe{},
 	upload.Pipe{},
 	aur.Pipe{},
+	aursources.Pipe{},
 	nix.Pipe{},
 	winget.Pipe{},
 	brew.Pipe{},
diff --git a/www/docs/cmd/goreleaser_release.md b/www/docs/cmd/goreleaser_release.md
index 6601cd5e..a1e542c0 100644
--- a/www/docs/cmd/goreleaser_release.md
+++ b/www/docs/cmd/goreleaser_release.md
@@ -27,7 +27,7 @@ goreleaser release [flags]
       --release-notes string         Load custom release notes from a markdown file (will skip GoReleaser changelog generation)
       --release-notes-tmpl string    Load custom release notes from a templated markdown file (overrides --release-notes)
       --single-target                Builds only for current GOOS and GOARCH, regardless of what's set in the configuration file (implies --skip=publish) (Pro only)
-      --skip strings                 Skip the given options (valid options are: after, announce, archive, aur, before, before-publish, chocolatey, cloudsmith, dmg, docker, dockerhub, fury, homebrew, ko, msi, nfpm, nix, notarize, publish, report-sizes, sbom, scoop, sign, snapcraft, validate, winget)
+      --skip strings                 Skip the given options (valid options are: after, announce, archive, aur, aur-source, before, before-publish, chocolatey, cloudsmith, dmg, docker, dockerhub, fury, homebrew, ko, msi, nfpm, nix, notarize, publish, report-sizes, sbom, scoop, sign, snapcraft, validate, winget)
       --snapshot                     Generate an unversioned snapshot release, skipping all validations and without publishing any artifacts (implies --skip=announce,publish,validate)
       --split                        Split the build so it can be merged and published later (implies --prepare) (Pro only)
       --timeout duration             Timeout to the entire release process (default 30m0s)
diff --git a/www/docs/customization/aursources.md b/www/docs/customization/aursources.md
new file mode 100644
index 00000000..b6700bc4
--- /dev/null
+++ b/www/docs/customization/aursources.md
@@ -0,0 +1,175 @@
+# Arch User Repositories (Sources)
+
+After releasing to GitHub, GitLab, or Gitea, GoReleaser can generate and publish
+a `PKGBUILD` to an _Arch User Repository_ based on sources.
+
+!!! warning
+
+    Before going further on this, make sure to read
+    [AUR's Submission Guidelines](https://wiki.archlinux.org/title/AUR_submission_guidelines).
+
+This page describes the available options.
+
+```yaml
+# .goreleaser.yaml
+aur_sources:
+  - # The package name.
+    #
+    # Note that since this integration creates a PKGBUILD to build from
+    # source, per Arch's guidelines.
+    # That said, GoReleaser will remove `-bin` suffix if its present.
+    #
+    # Default: ProjectName.
+    name: package
+
+    # Artifact IDs to filter for.
+    # Empty means all IDs (no filter).
+    ids:
+      - foo
+      - bar
+
+    # Your app's homepage.
+    #
+    # Default: inferred from global metadata.
+    homepage: "https://example.com/"
+
+    # Your app's description.
+    #
+    # Templates: allowed.
+    # Default: inferred from global metadata.
+    description: "Software to create fast and easy drum rolls."
+
+    # The maintainers of the package.
+    #
+    # Default: inferred from global metadata.
+    maintainers:
+      - "Foo Bar <foo at bar dot com>"
+
+    # The contributors of the package.
+    contributors:
+      - "Foo Zaz <foo at zaz dot com>"
+
+    # SPDX identifier of your app's license.
+    #
+    # Default: inferred from global metadata.
+    license: "MIT"
+
+    # The SSH private key that should be used to commit to the Git repository.
+    # This can either be a path or the key contents.
+    #
+    # IMPORTANT: the key must not be password-protected.
+    #
+    # WARNING: do not expose your private key in the configuration file!
+    private_key: "{{ .Env.AUR_KEY }}"
+
+    # The AUR Git URL for this package.
+    # Publish is skipped if empty.
+    git_url: "ssh://aur@aur.archlinux.org/mypackage.git"
+
+    # Setting this will prevent goreleaser to actually try to commit the updated
+    # formula - instead, the formula file will be stored on the dist directory
+    # only, leaving the responsibility of publishing it to the user.
+    #
+    # If set to auto, the release will not be uploaded to the AUR repo
+    # in case there is an indicator for prerelease in the tag e.g. v1.0.0-rc1.
+    skip_upload: true
+
+    # List of additional packages that the software provides the features of.
+    #
+    # Default: the project name.
+    provides:
+      - myapp
+
+    # List of packages that conflict with, or cause problems with the package.
+    #
+    # Default: the project name.
+    conflicts:
+      - myapp
+
+    # List of packages that must be installed to install this.
+    depends:
+      - curl
+
+    # List of packages that are not needed for the software to function,
+    # but provide additional features.
+    #
+    # Must be in the format `package: short description of the extra functionality`.
+    optdepends:
+      - "wget: for downloading things"
+
+    # List of packages that must be installed to build this.
+    # Default: ["go", "git"]
+    makedepends:
+      - make
+
+    # List of files that can contain user-made changes and should be preserved
+    # during package upgrades and removals.
+    backup:
+      - /etc/foo.conf
+
+    # Custom prepare instructions.
+    prepare: |-
+      cd "${pkgname}_${pkgver}"
+      go mod download
+
+    # Custom build instructions.
+    build: |-
+      cd "${pkgname}_${pkgver}"
+      export CGO_CPPFLAGS="${CPPFLAGS}"
+      export CGO_CFLAGS="${CFLAGS}"
+      export CGO_CXXFLAGS="${CXXFLAGS}"
+      export CGO_LDFLAGS="${LDFLAGS}"
+      export GOFLAGS="-buildmode=pie -trimpath -mod=readonly -modcacherw"
+      go build -ldflags="-w -s -buildid='' -linkmode=external -X main.version=${pkgver}" .
+      chmod +x ./goreleaser
+
+    # Custom package instructions.
+    package: |-
+      cd "${pkgname}_${pkgver}"
+      install -Dsm755 ./myapp "${pkgdir}/usr/bin/myapp"
+
+  # Git author used to commit to the repository.
+    commit_author:
+      name: goreleaserbot
+      email: bot@goreleaser.com
+
+    # Commit message.
+    #
+    # Default: 'Update to {{ .Tag }}'.
+    # Templates: allowed.
+    commit_msg_template: "pkgbuild updates"
+
+    # If you build for multiple GOAMD64 versions, you may use this to choose which one to use.
+    #
+    # Default: 'v1'.
+    goamd64: v2
+
+    # The value to be passed to `GIT_SSH_COMMAND`.
+    # This is mainly used to specify the SSH private key used to pull/push to
+    # the Git URL.
+    #
+    # Default: 'ssh -i {{ .KeyPath }} -o StrictHostKeyChecking=accept-new -F /dev/null'.
+    git_ssh_command: "ssh -i {{ .Env.KEY }} -o SomeOption=yes"
+
+    # URL which is determined by the given Token
+    # (github, gitlab or gitea).
+    #
+    # Default: depends on the client.
+    # Templates: allowed.
+    url_template: "http://github.mycompany.com/foo/bar/releases/{{ .Tag }}/{{ .ArtifactName }}"
+
+    # Directory in which the files will be created inside the repository.
+    # Only useful if you're creating your own AUR with multiple packages in a
+    # single repository.
+    #
+    # Default: '.'.
+    # Templates: allowed.
+    directory: "."
+```
+
+<!-- md:templates -->
+
+!!! tip
+
+    For more info about what each field does, please refer to
+    [Arch's PKGBUILD reference](https://wiki.archlinux.org/title/PKGBUILD).
diff --git a/www/mkdocs.yml b/www/mkdocs.yml
index a9335af5..1b35f314 100644
--- a/www/mkdocs.yml
+++ b/www/mkdocs.yml
@@ -153,6 +153,7 @@ nav:
           - customization/winget.md
           - NUR: customization/nix.md
           - AUR: customization/aur.md
+          - AURSources: customization/aursources.md
           - Krew: customization/krew.md
           - Scoop: customization/scoop.md
           - customization/changelog.md
