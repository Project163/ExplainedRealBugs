diff --git a/cmd/build.go b/cmd/build.go
index 039d7de6..c1402971 100644
--- a/cmd/build.go
+++ b/cmd/build.go
@@ -205,7 +205,9 @@ func setupBuildContext(ctx *context.Context, options buildOpts) error {
 	ctx.Clean = options.clean || options.rmDist
 
 	if options.singleTarget {
-		setupBuildSingleTarget(ctx)
+		if err := setupBuildSingleTarget(ctx); err != nil {
+			return err
+		}
 	}
 
 	if len(options.ids) > 0 {
@@ -224,7 +226,7 @@ func setupBuildContext(ctx *context.Context, options buildOpts) error {
 	return nil
 }
 
-func setupBuildSingleTarget(ctx *context.Context) {
+func setupBuildSingleTarget(ctx *context.Context) error {
 	goos := os.Getenv("GOOS")
 	if goos == "" {
 		goos = runtime.GOOS
@@ -250,8 +252,15 @@ func setupBuildSingleTarget(ctx *context.Context) {
 		build.Targets = nil
 		keep = append(keep, build)
 	}
+
 	ctx.Config.Builds = keep
 	ctx.Config.UniversalBinaries = nil
+
+	if len(keep) == 0 {
+		return fmt.Errorf("no builds matching --single-target %s/%s", goos, goarch)
+	}
+
+	return nil
 }
 
 func shouldBuild(build config.Build, goos, goarch string) bool {
diff --git a/cmd/build_test.go b/cmd/build_test.go
index ca330a0c..d97de541 100644
--- a/cmd/build_test.go
+++ b/cmd/build_test.go
@@ -201,6 +201,17 @@ func TestBuildFlags(t *testing.T) {
 			require.Equal(t, []string{runtime.GOARCH}, result.Config.Builds[0].Goarch)
 		})
 
+		t.Run("no matches", func(t *testing.T) {
+			t.Setenv("GOOS", "windows")
+			t.Setenv("GOARCH", "arm64")
+			ctx := testctx.NewWithCfg(config.Project{
+				Builds: []config.Build{{
+					Goos: []string{"linux"},
+				}},
+			})
+			require.EqualError(t, setupBuildContext(ctx, opts), "no builds matching --single-target windows/arm64")
+		})
+
 		t.Run("default config", func(t *testing.T) {
 			ctx := testctx.NewWithCfg(config.Project{
 				Builds: []config.Build{{}},
@@ -352,7 +363,7 @@ func TestBuildSingleTargetNoMatch(t *testing.T) {
 
 	t.Setenv("GOOS", "windows")
 	t.Setenv("GOARCH", "amd64")
-	setupBuildSingleTarget(ctx)
+	require.Error(t, setupBuildSingleTarget(ctx))
 	require.Empty(t, ctx.Config.Builds)
 }
 
