diff --git a/internal/http/http.go b/internal/http/http.go
index 3c90df68..90cb66f6 100644
--- a/internal/http/http.go
+++ b/internal/http/http.go
@@ -102,16 +102,24 @@ func CheckConfig(ctx *context.Context, upload *config.Upload, kind string) error
 		return misconfigured(kind, upload, "mode must be 'binary' or 'archive'")
 	}
 
-	username := getUsername(ctx, upload, kind)
-	password := getPassword(ctx, upload, kind)
+	username, err := getUsername(ctx, upload, kind)
+	if err != nil {
+		return fmt.Errorf("%s: could not get username: %w", upload.Name, err)
+	}
+
+	password, err := getPassword(ctx, upload, kind)
+	if err != nil {
+		return fmt.Errorf("%s: could not get password: %w", upload.Name, err)
+	}
+
 	passwordEnv := fmt.Sprintf("%s_%s_SECRET", strings.ToUpper(kind), strings.ToUpper(upload.Name))
 
 	if password != "" && username == "" {
-		return misconfigured(kind, upload, fmt.Sprintf("'username' is required when '%s' environment variable is set", passwordEnv))
+		return misconfigured(kind, upload, fmt.Sprintf("'username' is required when 'password' or the '%s' environment variable are set", passwordEnv))
 	}
 
 	if username != "" && password == "" {
-		return misconfigured(kind, upload, fmt.Sprintf("environment variable '%s' is required when 'username' is set", passwordEnv))
+		return misconfigured(kind, upload, fmt.Sprintf("either 'password' or environment variable '%s' are required when 'username' is set", passwordEnv))
 	}
 
 	if upload.TrustedCerts != "" && !x509.NewCertPool().AppendCertsFromPEM([]byte(upload.TrustedCerts)) {
@@ -135,19 +143,29 @@ func CheckConfig(ctx *context.Context, upload *config.Upload, kind string) error
 }
 
 // username is optional
-func getUsername(ctx *context.Context, upload *config.Upload, kind string) string {
-	if upload.Username != "" {
-		return upload.Username
+func getUsername(ctx *context.Context, upload *config.Upload, kind string) (string, error) {
+	username, err := tmpl.New(ctx).Apply(upload.Username)
+	if err != nil {
+		return "", err
+	}
+	if username != "" {
+		return username, nil
 	}
-
 	key := fmt.Sprintf("%s_%s_USERNAME", strings.ToUpper(kind), strings.ToUpper(upload.Name))
-	return ctx.Env[key]
+	return ctx.Env[key], nil
 }
 
 // password is optional
-func getPassword(ctx *context.Context, upload *config.Upload, kind string) string {
+func getPassword(ctx *context.Context, upload *config.Upload, kind string) (string, error) {
+	password, err := tmpl.New(ctx).Apply(upload.Password)
+	if err != nil {
+		return "", err
+	}
+	if password != "" {
+		return password, nil
+	}
 	key := fmt.Sprintf("%s_%s_SECRET", strings.ToUpper(kind), strings.ToUpper(upload.Name))
-	return ctx.Env[key]
+	return ctx.Env[key], nil
 }
 
 func misconfigured(kind string, upload *config.Upload, reason string) error {
@@ -265,8 +283,14 @@ func uploadWithFilter(ctx *context.Context, upload *config.Upload, filter artifa
 func uploadAsset(ctx *context.Context, upload *config.Upload, artifact *artifact.Artifact, kind string, check ResponseChecker) error {
 	// username and secret are optional since the server may not support/need
 	// basic authentication always
-	username := getUsername(ctx, upload, kind)
-	secret := getPassword(ctx, upload, kind)
+	username, err := getUsername(ctx, upload, kind)
+	if err != nil {
+		return fmt.Errorf("%s: could not get username: %w", upload.Name, err)
+	}
+	secret, err := getPassword(ctx, upload, kind)
+	if err != nil {
+		return fmt.Errorf("%s: could not get password: %w", upload.Name, err)
+	}
 
 	// Generate the target url
 	targetURL, err := tmpl.New(ctx).WithArtifact(artifact).Apply(upload.Target)
diff --git a/internal/http/http_test.go b/internal/http/http_test.go
index 03437c9f..762693b6 100644
--- a/internal/http/http_test.go
+++ b/internal/http/http_test.go
@@ -99,11 +99,14 @@ func TestCheckConfig(t *testing.T) {
 		wantErr bool
 	}{
 		{"ok", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe", Mode: ModeArchive}, "test"}, false},
+		{"ok password", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe", Password: "pass", Mode: ModeArchive}, "test"}, false},
 		{"secret missing", args{ctx, &config.Upload{Name: "b", Target: "http://blabla", Username: "pepe", Mode: ModeArchive}, "test"}, true},
 		{"target missing", args{ctx, &config.Upload{Name: "a", Username: "pepe", Mode: ModeArchive}, "test"}, true},
 		{"name missing", args{ctx, &config.Upload{Target: "http://blabla", Username: "pepe", Mode: ModeArchive}, "test"}, true},
 		{"username missing", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Mode: ModeArchive}, "test"}, true},
 		{"username present", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe", Mode: ModeArchive}, "test"}, false},
+		{"invalid username template", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "{{ .pepe }}", Mode: ModeArchive}, "test"}, true},
+		{"invalid password template", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Password: "{{ .pepe }}", Mode: ModeArchive}, "test"}, true},
 		{"mode missing", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe"}, "test"}, true},
 		{"mode invalid", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe", Mode: "blabla"}, "test"}, true},
 		{"cert invalid", args{ctx, &config.Upload{Name: "a", Target: "http://blabla", Username: "pepe", Mode: ModeBinary, TrustedCerts: "bad cert!"}, "test"}, true},
diff --git a/pkg/config/config.go b/pkg/config/config.go
index ba5aa491..31790d78 100644
--- a/pkg/config/config.go
+++ b/pkg/config/config.go
@@ -1120,6 +1120,9 @@ type Upload struct {
 	ExtraFiles         []ExtraFile       `yaml:"extra_files,omitempty" json:"extra_files,omitempty"`
 	ExtraFilesOnly     bool              `yaml:"extra_files_only,omitempty" json:"extra_files_only,omitempty"`
 	Skip               string            `yaml:"skip,omitempty" json:"skip,omitempty" jsonschema:"oneof_type=string;boolean"`
+
+	// Since v2.12
+	Password string `yaml:"password,omitempty" json:"password,omitempty"`
 }
 
 // Publisher configuration.
diff --git a/www/docs/customization/artifactory.md b/www/docs/customization/artifactory.md
index 04137a8a..111d9c40 100644
--- a/www/docs/customization/artifactory.md
+++ b/www/docs/customization/artifactory.md
@@ -197,9 +197,17 @@ artifactories:
     # Tells goreleaser not to append the artifact name to the target URL. You must do this manually
     custom_artifact_name: true
 
-    # User that will be used for the deployment
+    # An optional username that will be used for the deployment for basic auth.
+    #
+    # Templates: allowed (since v2.12-unreleased).
     username: deployuser
 
+    # An optional password that will be used for the deployment for basic auth.
+    #
+    # Templates: allowed.
+    # <!-- md:inline_version v2.12-unreleased -->.
+    password: '{{ readFile "~/.config/foo" }}'
+
     # Client certificate and key (when provided, added as client cert to TLS connections)
     client_x509_cert: /path/to/client.cert.pem
     client_x509_key: /path/to/client.key.pem
diff --git a/www/docs/customization/upload.md b/www/docs/customization/upload.md
index f608a033..5cb441c3 100644
--- a/www/docs/customization/upload.md
+++ b/www/docs/customization/upload.md
@@ -203,9 +203,17 @@ uploads:
     # target: https://some.server/some/path/example-repo-local/{{ .ArtifactName }};deb.distribution=xenial
     custom_artifact_name: true
 
-    # An optional username that will be used for the deployment for basic authn
+    # An optional username that will be used for the deployment for basic auth.
+    #
+    # Templates: allowed (since v2.12-unreleased).
     username: deployuser
 
+    # An optional password that will be used for the deployment for basic auth.
+    #
+    # Templates: allowed.
+    # <!-- md:inline_version v2.12-unreleased -->.
+    password: '{{ readFile "~/.config/foo" }}'
+
     # Client certificate and key (when provided, added as client cert to TLS connections)
     client_x509_cert: /path/to/client.cert.pem
     client_x509_key: /path/to/client.key.pem
