diff --git a/internal/pipe/blob/blob_minio_test.go b/internal/pipe/blob/blob_minio_test.go
index b15be0d4..4b326db4 100644
--- a/internal/pipe/blob/blob_minio_test.go
+++ b/internal/pipe/blob/blob_minio_test.go
@@ -29,6 +29,9 @@ const (
 var listen string
 
 func TestMain(m *testing.M) {
+	if !testlib.InPath("docker") {
+		os.Exit(m.Run())
+	}
 	prepareEnv()
 
 	requireNoErr := func(err error) {
@@ -71,6 +74,7 @@ func TestMain(m *testing.M) {
 }
 
 func TestMinioUpload(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	name := "basic"
 	directory := t.TempDir()
 	srcpath := filepath.Join(directory, "source.tar.gz")
@@ -176,6 +180,7 @@ func TestMinioUpload(t *testing.T) {
 }
 
 func TestMinioUploadCustomBucketID(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	name := "fromenv"
 	directory := t.TempDir()
 	tgzpath := filepath.Join(directory, "bin.tar.gz")
@@ -212,6 +217,7 @@ func TestMinioUploadCustomBucketID(t *testing.T) {
 }
 
 func TestMinioUploadExtraFilesOnly(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	name := "only-extra-files"
 	directory := t.TempDir()
 	tgzpath := filepath.Join(directory, "bin.tar.gz")
@@ -257,6 +263,7 @@ func TestMinioUploadExtraFilesOnly(t *testing.T) {
 }
 
 func TestMinioUploadRootDirectory(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	name := "rootdir"
 	directory := t.TempDir()
 	tgzpath := filepath.Join(directory, "bin.tar.gz")
@@ -292,6 +299,7 @@ func TestMinioUploadRootDirectory(t *testing.T) {
 }
 
 func TestMinioUploadInvalidCustomBucketID(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	directory := t.TempDir()
 	tgzpath := filepath.Join(directory, "bin.tar.gz")
 	debpath := filepath.Join(directory, "bin.deb")
@@ -324,6 +332,7 @@ func TestMinioUploadInvalidCustomBucketID(t *testing.T) {
 }
 
 func TestMinioUploadSkip(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	name := "basic"
 	directory := t.TempDir()
 	debpath := filepath.Join(directory, "bin.deb")
diff --git a/internal/pipe/ko/ko_test.go b/internal/pipe/ko/ko_test.go
index 53e789d3..9a1bd2d2 100644
--- a/internal/pipe/ko/ko_test.go
+++ b/internal/pipe/ko/ko_test.go
@@ -155,6 +155,7 @@ func TestPublishPipeNoMatchingBuild(t *testing.T) {
 }
 
 func TestPublishPipeSuccess(t *testing.T) {
+	testlib.CheckPath(t, "docker")
 	testlib.StartRegistry(t, "ko_registry", registryPort)
 
 	chainguardStaticLabels := map[string]string{
diff --git a/internal/pipe/sign/sign_binary_test.go b/internal/pipe/sign/sign_binary_test.go
index 6ce7c96e..13aad167 100644
--- a/internal/pipe/sign/sign_binary_test.go
+++ b/internal/pipe/sign/sign_binary_test.go
@@ -8,6 +8,7 @@ import (
 	"github.com/goreleaser/goreleaser/v2/internal/artifact"
 	"github.com/goreleaser/goreleaser/v2/internal/skips"
 	"github.com/goreleaser/goreleaser/v2/internal/testctx"
+	"github.com/goreleaser/goreleaser/v2/internal/testlib"
 	"github.com/goreleaser/goreleaser/v2/pkg/config"
 	"github.com/stretchr/testify/require"
 )
@@ -79,6 +80,7 @@ func TestBinaryDependencies(t *testing.T) {
 }
 
 func TestBinarySign(t *testing.T) {
+	testlib.CheckPath(t, "gpg")
 	doTest := func(tb testing.TB, sign config.Sign) []*artifact.Artifact {
 		tb.Helper()
 		tmpdir := tb.TempDir()
diff --git a/internal/pipe/sign/sign_test.go b/internal/pipe/sign/sign_test.go
index 32a8826a..d3454ec9 100644
--- a/internal/pipe/sign/sign_test.go
+++ b/internal/pipe/sign/sign_test.go
@@ -528,6 +528,7 @@ func TestSignArtifacts(t *testing.T) {
 		}
 
 		t.Run(test.desc, func(t *testing.T) {
+			testlib.CheckPath(t, "gpg")
 			testSign(
 				t,
 				test.ctx,
diff --git a/internal/testlib/path.go b/internal/testlib/path.go
index 8db76871..90c790dc 100644
--- a/internal/testlib/path.go
+++ b/internal/testlib/path.go
@@ -6,14 +6,19 @@ import (
 	"testing"
 )
 
-// CheckPath skips the test if the binary is not in the PATH.
+// CheckPath skips the test if the binary is not in the PATH, or if CI is true.
 func CheckPath(tb testing.TB, cmd string) {
 	tb.Helper()
-	if os.Getenv("CI") == "true" {
-		// never skip on CI
-		return
-	}
-	if _, err := exec.LookPath(cmd); err != nil {
+	if !InPath(cmd) {
 		tb.Skipf("%s not in PATH", cmd)
 	}
 }
+
+// InPath returns true if the given cmd is in the PATH, or if CI is true.
+func InPath(cmd string) bool {
+	if os.Getenv("CI") == "true" {
+		return true
+	}
+	_, err := exec.LookPath(cmd)
+	return err == nil
+}
