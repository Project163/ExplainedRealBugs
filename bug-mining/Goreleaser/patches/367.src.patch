diff --git a/internal/pipe/ko/ko.go b/internal/pipe/ko/ko.go
index 5ca2819e..b8193ba9 100644
--- a/internal/pipe/ko/ko.go
+++ b/internal/pipe/ko/ko.go
@@ -15,9 +15,11 @@ import (
 	"time"
 
 	"github.com/awslabs/amazon-ecr-credential-helper/ecr-login"
+	"github.com/caarlos0/log"
 	"github.com/chrismellard/docker-credential-acr-env/pkg/credhelper"
 	"github.com/google/go-containerregistry/pkg/authn"
 	"github.com/google/go-containerregistry/pkg/authn/github"
+	"github.com/google/go-containerregistry/pkg/crane"
 	"github.com/google/go-containerregistry/pkg/name"
 	v1 "github.com/google/go-containerregistry/pkg/v1"
 	"github.com/google/go-containerregistry/pkg/v1/google"
@@ -50,7 +52,7 @@ var (
 		azureKeychain,
 	)
 
-	errNoRepository      = errors.New("ko: missing repository: please set either the repository field or a $KO_DOCKER_REPO environment variable")
+	errNoRepositories    = errors.New("ko: missing repositories: please set either the repository field or a $KO_DOCKER_REPO environment variable")
 	errInvalidMainPath   = errors.New("ko: invalid Main path: ko.main (or build.main if ko.main is not set) should be a relative path")
 	errInvalidMainGoPath = errors.New("ko: invalid Main path: your path should point to a directory instead of a .go file")
 )
@@ -125,12 +127,17 @@ func (Pipe) Default(ctx *context.Context) error {
 			ko.SBOM = "spdx"
 		}
 
+		if ko.Repository != "" {
+			ko.Repositories = append(ko.Repositories, ko.Repository)
+			deprecate.Notice(ctx, "kos.repository")
+		}
+
 		if repo := ctx.Env["KO_DOCKER_REPO"]; repo != "" {
-			ko.Repository = repo
+			ko.Repositories = []string{repo}
 		}
 
-		if ko.Repository == "" {
-			return errNoRepository
+		if len(ko.Repositories) == 0 {
+			return errNoRepositories
 		}
 
 		ids.Inc(ko.ID)
@@ -161,7 +168,7 @@ type buildOptions struct {
 	main                string
 	flags               []string
 	env                 []string
-	imageRepo           string
+	imageRepos          []string
 	workingDir          string
 	platforms           []string
 	baseImage           string
@@ -267,7 +274,7 @@ func doBuild(ctx *context.Context, ko config.Ko) func() error {
 		}
 
 		po := &options.PublishOptions{
-			DockerRepo:          opts.imageRepo,
+			DockerRepo:          opts.imageRepos[0],
 			Bare:                opts.bare,
 			PreserveImportPaths: opts.preserveImportPaths,
 			BaseImportPaths:     opts.baseImportPaths,
@@ -284,7 +291,7 @@ func doBuild(ctx *context.Context, ko config.Ko) func() error {
 			)
 		} else {
 			p, err = publish.NewDefault(
-				opts.imageRepo,
+				opts.imageRepos[0],
 				publish.WithTags(opts.tags),
 				publish.WithNamer(options.MakeNamer(po)),
 				publish.WithAuthFromKeychain(keychain),
@@ -302,19 +309,30 @@ func doBuild(ctx *context.Context, ko config.Ko) func() error {
 			return fmt.Errorf("close: %w", err)
 		}
 
-		art := &artifact.Artifact{
-			Type:  artifact.DockerManifest,
-			Name:  ref.Name(),
-			Path:  ref.Name(),
-			Extra: map[string]interface{}{},
-		}
-		if ko.ID != "" {
-			art.Extra[artifact.ExtraID] = ko.ID
+		ctx.Artifacts.Add(makeArtifact(
+			ko.ID,
+			ref.Name(),
+			ref.Context().Digest(ref.Identifier()).DigestStr(),
+		))
+
+		if ctx.Snapshot || len(opts.imageRepos) == 1 {
+			// do not copy images when snapshoting, as these images will be
+			// local only anyway.
+			return nil
 		}
-		if digest := ref.Context().Digest(ref.Identifier()).DigestStr(); digest != "" {
-			art.Extra[artifact.ExtraDigest] = digest
+
+		src := ref.Name()
+		for i := 1; i < len(opts.imageRepos); i++ {
+			for _, tag := range opts.tags {
+				dst := opts.imageRepos[i] + ":" + tag
+				digest, err := copyImage(src, dst)
+				if err != nil {
+					return err
+				}
+				ctx.Artifacts.Add(makeArtifact(ko.ID, dst, digest))
+			}
 		}
-		ctx.Artifacts.Add(art)
+
 		return nil
 	}
 }
@@ -363,7 +381,7 @@ func buildBuildOptions(ctx *context.Context, cfg config.Ko) (*buildOptions, erro
 		baseImage:           cfg.BaseImage,
 		platforms:           cfg.Platforms,
 		sbom:                cfg.SBOM,
-		imageRepo:           cfg.Repository,
+		imageRepos:          cfg.Repositories,
 		user:                cfg.User,
 	}
 
@@ -493,3 +511,33 @@ func validateMainPath(path string) error {
 	}
 	return nil
 }
+
+func copyImage(src, dst string) (string, error) {
+	log.WithField("src", src).
+		WithField("dst", dst).
+		Info("copying manifest")
+	if err := crane.Copy(src, dst, crane.WithAuthFromKeychain(keychain)); err != nil {
+		return "", fmt.Errorf("ko: could not copy %q to %q: %w", src, dst, err)
+	}
+	digest, err := crane.Digest(dst, crane.WithAuthFromKeychain(keychain))
+	if err != nil {
+		return "", fmt.Errorf("ko: could not get digest of %q: %w", dst, err)
+	}
+	return digest, nil
+}
+
+func makeArtifact(id, name, digest string) *artifact.Artifact {
+	art := &artifact.Artifact{
+		Type:  artifact.DockerManifest,
+		Name:  name,
+		Path:  name,
+		Extra: map[string]interface{}{},
+	}
+	if id != "" {
+		art.Extra[artifact.ExtraID] = id
+	}
+	if digest != "" {
+		art.Extra[artifact.ExtraDigest] = digest
+	}
+	return art
+}
diff --git a/internal/pipe/ko/ko_test.go b/internal/pipe/ko/ko_test.go
index 6a6531f0..0ceedf21 100644
--- a/internal/pipe/ko/ko_test.go
+++ b/internal/pipe/ko/ko_test.go
@@ -22,15 +22,17 @@ import (
 )
 
 const (
-	registryPort = "5052"
-	registry     = "localhost:5052/"
+	registry1Port = "5052"
+	registry1     = "localhost:5052/"
+	registry2Port = "5053"
+	registry2     = "localhost:5053/"
 )
 
 func TestDefault(t *testing.T) {
 	ctx := testctx.NewWithCfg(config.Project{
 		Env: []string{
-			"KO_DOCKER_REPO=" + registry,
-			"COSIGN_REPOSITORY=" + registry,
+			"KO_DOCKER_REPO=" + registry1,
+			"COSIGN_REPOSITORY=" + registry1,
 			"LDFLAGS=foobar",
 			"FLAGS=barfoo",
 			"LE_ENV=test",
@@ -53,24 +55,24 @@ func TestDefault(t *testing.T) {
 	})
 	require.NoError(t, Pipe{}.Default(ctx))
 	require.Equal(t, config.Ko{
-		ID:         "test",
-		Build:      "test",
-		BaseImage:  chainguardStatic,
-		Repository: registry,
-		Platforms:  []string{"linux/amd64"},
-		SBOM:       "spdx",
-		Tags:       []string{"latest"},
-		WorkingDir: ".",
-		Ldflags:    []string{"{{.Env.LDFLAGS}}"},
-		Flags:      []string{"{{.Env.FLAGS}}"},
-		Env:        []string{"SOME_ENV={{.Env.LE_ENV}}"},
+		ID:           "test",
+		Build:        "test",
+		BaseImage:    chainguardStatic,
+		Repositories: []string{registry1},
+		Platforms:    []string{"linux/amd64"},
+		SBOM:         "spdx",
+		Tags:         []string{"latest"},
+		WorkingDir:   ".",
+		Ldflags:      []string{"{{.Env.LDFLAGS}}"},
+		Flags:        []string{"{{.Env.FLAGS}}"},
+		Env:          []string{"SOME_ENV={{.Env.LE_ENV}}"},
 	}, ctx.Config.Kos[0])
 }
 
 func TestDefaultCycloneDX(t *testing.T) {
 	ctx := testctx.NewWithCfg(config.Project{
 		ProjectName: "test",
-		Env:         []string{"KO_DOCKER_REPO=" + registry},
+		Env:         []string{"KO_DOCKER_REPO=" + registry1},
 		Kos: []config.Ko{
 			{SBOM: "cyclonedx"},
 		},
@@ -86,7 +88,7 @@ func TestDefaultCycloneDX(t *testing.T) {
 func TestDefaultGoVersionM(t *testing.T) {
 	ctx := testctx.NewWithCfg(config.Project{
 		ProjectName: "test",
-		Env:         []string{"KO_DOCKER_REPO=" + registry},
+		Env:         []string{"KO_DOCKER_REPO=" + registry1},
 		Kos: []config.Ko{
 			{SBOM: "go.version-m"},
 		},
@@ -111,7 +113,7 @@ func TestDefaultNoImage(t *testing.T) {
 			{},
 		},
 	})
-	require.ErrorIs(t, Pipe{}.Default(ctx), errNoRepository)
+	require.ErrorIs(t, Pipe{}.Default(ctx), errNoRepositories)
 }
 
 func TestDescription(t *testing.T) {
@@ -158,7 +160,8 @@ func TestPublishPipeNoMatchingBuild(t *testing.T) {
 func TestPublishPipeSuccess(t *testing.T) {
 	testlib.SkipIfWindows(t, "ko doesn't work in windows")
 	testlib.CheckPath(t, "docker")
-	testlib.StartRegistry(t, "ko_registry", registryPort)
+	testlib.StartRegistry(t, "ko_registry1", registry1Port)
+	testlib.StartRegistry(t, "ko_registry2", registry2Port)
 
 	chainguardStaticLabels := map[string]string{
 		"dev.chainguard.package.main":      "",
@@ -242,7 +245,10 @@ func TestPublishPipeSuccess(t *testing.T) {
 		},
 	}
 
-	repository := fmt.Sprintf("%sgoreleasertest/testapp", registry)
+	repositories := []string{
+		fmt.Sprintf("%sgoreleasertest/testapp", registry1),
+		fmt.Sprintf("%sgoreleasertest/testapp", registry2),
+	}
 
 	for _, table := range table {
 		t.Run(table.Name, func(t *testing.T) {
@@ -267,7 +273,7 @@ func TestPublishPipeSuccess(t *testing.T) {
 						Build:              "foo",
 						WorkingDir:         "./testdata/app/",
 						BaseImage:          table.BaseImage,
-						Repository:         repository,
+						Repositories:       repositories,
 						Labels:             table.Labels,
 						Annotations:        table.Annotations,
 						User:               table.User,
@@ -293,7 +299,7 @@ func TestPublishPipeSuccess(t *testing.T) {
 			require.NoError(t, Pipe{}.Publish(ctx))
 
 			manifests := ctx.Artifacts.Filter(artifact.ByType(artifact.DockerManifest)).List()
-			require.Len(t, manifests, 1)
+			require.Len(t, manifests, 2) // both registries
 			require.NotEmpty(t, manifests[0].Name)
 			require.Equal(t, manifests[0].Name, manifests[0].Path)
 			require.NotEmpty(t, manifests[0].Extra[artifact.ExtraDigest])
@@ -304,6 +310,7 @@ func TestPublishPipeSuccess(t *testing.T) {
 			tags = removeEmpty(tags)
 			require.Len(t, tags, 1)
 
+			repository := repositories[0]
 			ref, err := name.ParseReference(
 				fmt.Sprintf("%s:latest", repository),
 				name.Insecure,
@@ -318,6 +325,13 @@ func TestPublishPipeSuccess(t *testing.T) {
 			)
 			require.NoError(t, err)
 
+			repository2 := repositories[1]
+			_, err = name.ParseReference(
+				fmt.Sprintf("%s:%s", repository2, tags[0]),
+				name.Insecure,
+			)
+			require.NoError(t, err)
+
 			index, err := remote.Index(ref)
 			if len(table.Platforms) > 1 {
 				require.NoError(t, err)
diff --git a/pkg/config/config.go b/pkg/config/config.go
index 3eb9967f..27988232 100644
--- a/pkg/config/config.go
+++ b/pkg/config/config.go
@@ -401,7 +401,8 @@ type Ko struct {
 	Labels              map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`
 	Annotations         map[string]string `yaml:"annotations,omitempty" json:"annotations,omitempty"`
 	User                string            `yaml:"user,omitempty" json:"user,omitempty"`
-	Repository          string            `yaml:"repository,omitempty" json:"repository,omitempty"`
+	Repository          string            `yaml:"repository,omitempty" json:"repository,omitempty" jsonschema:"deprecated=true"` // Deprecated: use [Repositories].
+	Repositories        []string          `yaml:"repositories,omitempty" json:"repositories,omitempty"`
 	Platforms           []string          `yaml:"platforms,omitempty" json:"platforms,omitempty"`
 	Tags                []string          `yaml:"tags,omitempty" json:"tags,omitempty"`
 	CreationTime        string            `yaml:"creation_time,omitempty" json:"creation_time,omitempty"`
diff --git a/www/docs/customization/ko.md b/www/docs/customization/ko.md
index 70b21718..d3cba799 100644
--- a/www/docs/customization/ko.md
+++ b/www/docs/customization/ko.md
@@ -52,9 +52,20 @@ kos:
     # The default user the image should be run as.
     user: "1234:1234"
 
+    # Repositories to push to.
+    #
+    # First one will be used on Ko build, the other ones will be copied from the
+    # first one using crane.
+    #
+    # Default: [ '$KO_DOCKER_REPO' ].
+    repositories:
+      - ghcr.io/foo/bar
+      - foo/bar
+
     # Repository to push to.
     #
     # Default: '$KO_DOCKER_REPO'.
+    # Deprecated: use 'repositories' instead.
     repository: ghcr.io/foo/bar
 
     # Platforms to build and publish.
diff --git a/www/docs/deprecations.md b/www/docs/deprecations.md
index 27e7c573..1688795d 100644
--- a/www/docs/deprecations.md
+++ b/www/docs/deprecations.md
@@ -39,6 +39,28 @@ Description.
 
 -->
 
+### kos.repository
+
+> since v2.5
+
+Use `repositories` instead. It allows to create multiple images with Ko, without
+having to rebuild each of them.
+
+=== "Before"
+
+    ```yaml
+    kos:
+      - repository: foo/bar
+    ```
+
+=== "After"
+
+    ```yaml
+    kos:
+      - repositories:
+          - foo/bar
+    ```
+
 ### builds.gobinary
 
 > since v2.5
