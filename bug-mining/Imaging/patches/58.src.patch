diff --git a/src/main/java/org/apache/commons/imaging/ColorTools.java b/src/main/java/org/apache/commons/imaging/ColorTools.java
index 7f50f649..31a45826 100644
--- a/src/main/java/org/apache/commons/imaging/ColorTools.java
+++ b/src/main/java/org/apache/commons/imaging/ColorTools.java
@@ -34,7 +34,7 @@ import java.io.IOException;
 /**
  * A selection of tools for evaluating and manipulating color
  * spaces, color values, etc.
- * <p>The Javadoc provided in the original code gave the 
+ * <p>The Javadoc provided in the original code gave the
  * following notation:<br><br>
  *
  * &nbsp;&nbsp;&nbsp; "This class is a mess and needs to be cleaned up."
@@ -203,7 +203,7 @@ public class ColorTools {
                 RenderingHints.VALUE_RENDER_QUALITY);
         hints.put(RenderingHints.KEY_COLOR_RENDERING,
                 RenderingHints.VALUE_COLOR_RENDER_QUALITY);
-        hints.put(RenderingHints.KEY_DITHERING, 
+        hints.put(RenderingHints.KEY_DITHERING,
                 RenderingHints.VALUE_DITHER_ENABLE);
 
         // bi = relabelColorSpace(bi, cs);
diff --git a/src/main/java/org/apache/commons/imaging/FormatCompliance.java b/src/main/java/org/apache/commons/imaging/FormatCompliance.java
index 21071c6d..26704dc8 100644
--- a/src/main/java/org/apache/commons/imaging/FormatCompliance.java
+++ b/src/main/java/org/apache/commons/imaging/FormatCompliance.java
@@ -25,7 +25,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
- * Provides information about the compliance of a specified data 
+ * Provides information about the compliance of a specified data
  * source (byte array, file, etc&#46;) to an image format.
  */
 public class FormatCompliance {
diff --git a/src/main/java/org/apache/commons/imaging/ImageFormat.java b/src/main/java/org/apache/commons/imaging/ImageFormat.java
index 0e0c3227..c733432a 100644
--- a/src/main/java/org/apache/commons/imaging/ImageFormat.java
+++ b/src/main/java/org/apache/commons/imaging/ImageFormat.java
@@ -23,14 +23,14 @@ public interface ImageFormat {
 
     /**
      * Get the name of this {@link ImageFormat}.
-     * 
+     *
      * @return String name
      */
     String getName();
 
     /**
      * Get the file extension associated with this {@link ImageFormat}.
-     * 
+     *
      * @return String extension
      */
     String getExtension();
diff --git a/src/main/java/org/apache/commons/imaging/ImageInfo.java b/src/main/java/org/apache/commons/imaging/ImageInfo.java
index b85e7491..94ce62c5 100644
--- a/src/main/java/org/apache/commons/imaging/ImageInfo.java
+++ b/src/main/java/org/apache/commons/imaging/ImageInfo.java
@@ -156,7 +156,7 @@ public class ImageInfo {
      * Returns the image file format, ie. ImageFormat.IMAGE_FORMAT_PNG.
      * <p/>
      * Returns ImageFormat.IMAGE_FORMAT_UNKNOWN if format is unknown.
-     * 
+     *
      * @return A constant defined in ImageFormat.
      * @see ImageFormats
      */
@@ -166,7 +166,7 @@ public class ImageInfo {
 
     /**
      * Returns a string with the name of the image file format.
-     * 
+     *
      * @see #getFormat()
      */
     public String getFormatName() {
@@ -175,7 +175,7 @@ public class ImageInfo {
 
     /**
      * Returns the height of the image in pixels.
-     * 
+     *
      * @see #getWidth()
      */
     public int getHeight() {
@@ -184,7 +184,7 @@ public class ImageInfo {
 
     /**
      * Returns the MIME type of the image.
-     * 
+     *
      * @see #getFormat()
      */
     public String getMimeType() {
@@ -207,7 +207,7 @@ public class ImageInfo {
      * Applies to TIFF (optional), BMP (always), GIF (constant: 72), Jpeg
      * (optional), PNG (optional), PNM (constant: 72), PSD/Photoshop (constant:
      * 72).
-     * 
+     *
      * @return returns -1 if not present.
      */
     public int getPhysicalHeightDpi() {
@@ -220,7 +220,7 @@ public class ImageInfo {
      * Applies to TIFF (optional), BMP (always), GIF (constant: 72), Jpeg
      * (optional), PNG (optional), PNM (constant: 72), PSD/Photoshop (constant:
      * 72).
-     * 
+     *
      * @return returns -1 if not present.
      */
     public float getPhysicalHeightInch() {
@@ -233,7 +233,7 @@ public class ImageInfo {
      * Applies to TIFF (optional), BMP (always), GIF (constant: 72), Jpeg
      * (optional), PNG (optional), PNM (constant: 72), PSD/Photoshop (constant:
      * 72).
-     * 
+     *
      * @return returns -1 if not present.
      */
     public int getPhysicalWidthDpi() {
@@ -246,7 +246,7 @@ public class ImageInfo {
      * Applies to TIFF (optional), BMP (always), GIF (constant: 72), Jpeg
      * (optional), PNG (optional), PNM (constant: 72), PSD/Photoshop (constant:
      * 72).
-     * 
+     *
      * @return returns -1 if not present.
      */
     public float getPhysicalWidthInch() {
@@ -255,7 +255,7 @@ public class ImageInfo {
 
     /**
      * Returns the width of the image in pixels.
-     * 
+     *
      * @see #getHeight()
      */
     public int getWidth() {
diff --git a/src/main/java/org/apache/commons/imaging/ImageParser.java b/src/main/java/org/apache/commons/imaging/ImageParser.java
index 673ac47c..9367158b 100644
--- a/src/main/java/org/apache/commons/imaging/ImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/ImageParser.java
@@ -59,18 +59,18 @@ import org.apache.commons.imaging.formats.xpm.XpmImageParser;
  * class providing logic for identifying and processing data in their
  * own specific format.   Specific implementations are found
  * under the com.apache.commons.imaging.formats package.
- * 
+ *
  * <h3>Application Notes</h3>
- * 
+ *
  * <h4>Format support</h4>
- * 
+ *
  * For the most recent information on format support for the
  * Apache Commons Imaging package, refer to
  * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
  * at the main project development web site.
- * 
+ *
  * <h4>On the accuracy of this Javadoc</h4>
- * 
+ *
  * The original authors of this class did not supply documentation.
  * The Javadoc for this class is based on inspection of the
  * source code.  In some cases, the purpose and usage for particular
@@ -78,9 +78,9 @@ import org.apache.commons.imaging.formats.xpm.XpmImageParser;
  * the intentions of the original. Therefore, you should not assume
  * that the documentation is perfect, especially in the more obscure
  * and specialized areas of implementation.
- * 
+ *
  * <h4>The "Map params" argument</h4>
- * 
+ *
  * Many of the methods specified by this class accept an argument of
  * type Map giving a list of parameters to be used when processing an
  * image. For example, some of the output formats permit the specification
@@ -93,7 +93,7 @@ import org.apache.commons.imaging.formats.xpm.XpmImageParser;
  * Therefore, a prudent programmer will always supply an valid, though
  * empty instance of a Map implementation when calling such methods.
  * Generally, the java HashMap class is useful for this purpose.
- * 
+ *
  * <p>Additionally, developers creating or enhancing classes derived
  * from ImageParser are encouraged to include such checks in their code.
  */
@@ -153,7 +153,7 @@ public abstract class ImageParser extends BinaryFileParser {
      * ImageParser implementations are expected to return a valid
      * IImageMetadata object or to throw an ImageReadException if unable
      * to process the specified byte source.
-     * 
+     *
      * <p>The params argument provides a mechanism for individual
      * implementations to pass optional information into the parser.
      * Not all formats will require this capability.  Because the
@@ -200,7 +200,7 @@ public abstract class ImageParser extends BinaryFileParser {
      * ImageParser implementations are expected to return a valid
      * IImageMetadata object or to throw an ImageReadException if unable
      * to process the specified data.
-     * 
+     *
      * <p>The params argument provides a mechanism for individual
      * implementations to pass optional information into the parser.
      * Not all formats will require this capability.  Because the
@@ -248,7 +248,7 @@ public abstract class ImageParser extends BinaryFileParser {
      * ImageParser implementations are expected to return a valid
      * IImageMetadata object or to throw an ImageReadException if unable
      * to process the specified data.
-     * 
+     *
      * <p>The params argument provides a mechanism for individual
      * implementations to pass optional information into the parser.
      * Not all formats will require this capability.  Because the
@@ -286,7 +286,7 @@ public abstract class ImageParser extends BinaryFileParser {
      * ImageParser implementations are expected to return a valid
      * ImageInfo object or to throw an ImageReadException if unable
      * to process the specified data.
-     * 
+     *
      * <p>The params argument provides a mechanism for individual
      * implementations to pass optional information into the parser.
      * Not all formats will require this capability.  Because the
@@ -559,7 +559,7 @@ public abstract class ImageParser extends BinaryFileParser {
     /**
      * Writes the content of a BufferedImage to the specified output
      * stream.
-     * 
+     *
      * <p>The params argument provides a mechanism for individual
      * implementations to pass optional information into the parser.
      * Not all formats will support this capability.  Currently,
diff --git a/src/main/java/org/apache/commons/imaging/Imaging.java b/src/main/java/org/apache/commons/imaging/Imaging.java
index 6420779f..3dc064ad 100644
--- a/src/main/java/org/apache/commons/imaging/Imaging.java
+++ b/src/main/java/org/apache/commons/imaging/Imaging.java
@@ -53,7 +53,7 @@ import org.apache.commons.imaging.icc.IccProfileParser;
  * Almost all of the Apache Commons Imaging library's core functionality can
  * be accessed through the methods provided by this class.
  * The use of the Imaging class is similar to the Java API's ImageIO class,
- * though Imaging supports formats and options not included in the standard 
+ * though Imaging supports formats and options not included in the standard
  * Java API.
  * </p>
  *
@@ -93,9 +93,9 @@ import org.apache.commons.imaging.icc.IccProfileParser;
  *
  * <p>
  * Optional parameters are specified using a Map object (typically,
- * a Java HashMap) to specify a set of keys and values for input.  
- * The specification for support keys is provided by the ImagingConstants 
- * interface as well as by format-specific interfaces such as 
+ * a Java HashMap) to specify a set of keys and values for input.
+ * The specification for support keys is provided by the ImagingConstants
+ * interface as well as by format-specific interfaces such as
  * JpegContants or TiffConstants.
  * </p>
  *
@@ -137,13 +137,13 @@ public final class Imaging {
     }
 
     /**
-     * Attempts to determine if a file contains an image recorded in 
-     * a supported graphics format based on its file-name extension 
-     * (for example "&#46jpg", "&#46;gif", "&#46;png", etc&#46;). 
-     * 
-     * @param file A valid File object providing a reference to 
+     * Attempts to determine if a file contains an image recorded in
+     * a supported graphics format based on its file-name extension
+     * (for example "&#46jpg", "&#46;gif", "&#46;png", etc&#46;).
+     *
+     * @param file A valid File object providing a reference to
      * a file that may contain an image.
-     * @return true if the file-name includes a supported image 
+     * @return true if the file-name includes a supported image
      * format file extension; otherwise, false.
      */
     public static boolean hasImageFileExtension(final File file) {
@@ -154,11 +154,11 @@ public final class Imaging {
     }
 
     /**
-     * Attempts to determine if a file contains an image recorded in 
-     * a supported graphics format based on its file-name extension 
-     * (for example "&#46jpg", "&#46;gif", "&#46;png", etc&#46;). 
-     * 
-     * @param filename  A valid string representing name of file 
+     * Attempts to determine if a file contains an image recorded in
+     * a supported graphics format based on its file-name extension
+     * (for example "&#46jpg", "&#46;gif", "&#46;png", etc&#46;).
+     *
+     * @param filename  A valid string representing name of file
      * which may contain an image.
      * @return true if the filename has an image format file extension.
      */
@@ -182,14 +182,14 @@ public final class Imaging {
 
     /**
      * Attempts to determine the image format of a file based on its
-     * "magic numbers," the first bytes of the data.  
-     * <p>Many graphics format specify identifying byte 
+     * "magic numbers," the first bytes of the data.
+     * <p>Many graphics format specify identifying byte
      * values that appear at the beginning of the data file.  This method
-     * checks for such identifying elements and returns a ImageFormat 
-     * enumeration indicating what it detects. Note that this 
+     * checks for such identifying elements and returns a ImageFormat
+     * enumeration indicating what it detects. Note that this
      * method can return "false positives" in cases where non-image files
      * begin with the specified byte values.
-     * 
+     *
      * @param bytes  Byte array containing an image file.
      * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns
      *         ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be
@@ -202,14 +202,14 @@ public final class Imaging {
 
     /**
      * Attempts to determine the image format of a file based on its
-     * "magic numbers," the first bytes of the data.  
-     * <p>Many graphics formats specify identifying byte 
+     * "magic numbers," the first bytes of the data.
+     * <p>Many graphics formats specify identifying byte
      * values that appear at the beginning of the data file.  This method
-     * checks for such identifying elements and returns a ImageFormat 
-     * enumeration indicating what it detects. Note that this 
+     * checks for such identifying elements and returns a ImageFormat
+     * enumeration indicating what it detects. Note that this
      * method can return "false positives" in cases where non-image files
      * begin with the specified byte values.
-     * 
+     *
      * @param file  File containing image data.
      * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns
      *         ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be
@@ -227,23 +227,23 @@ public final class Imaging {
         return (a[0] == b[0]) && (a[1] == b[1]);
     }
 
-    
+
     /**
      * Attempts to determine the image format of a file based on its
-     * "magic numbers," the first bytes of the data.  
-     * <p>Many graphics formats specify identifying byte 
+     * "magic numbers," the first bytes of the data.
+     * <p>Many graphics formats specify identifying byte
      * values that appear at the beginning of the data file.  This method
-     * checks for such identifying elements and returns a ImageFormat 
-     * enumeration indicating what it detects. Note that this 
+     * checks for such identifying elements and returns a ImageFormat
+     * enumeration indicating what it detects. Note that this
      * method can return "false positives" in cases where non-image files
      * begin with the specified byte values.
-     * 
-     * @param byteSource a valid ByteSource object potentially supplying 
+     *
+     * @param byteSource a valid ByteSource object potentially supplying
      * data for an image.
      * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns
      *         ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be
      *         determined.
-     * @throws ImageReadException in the event of an unsuccessful 
+     * @throws ImageReadException in the event of an unsuccessful
      * attempt to read the image data
      * @throws IOException in the event of an unrecoverable I/O condition.
      */
@@ -253,7 +253,7 @@ public final class Imaging {
         if (byteSource == null) {
             return ImageFormats.UNKNOWN;
         }
-        
+
         try (InputStream is = byteSource.getInputStream()) {
             final int i1 = is.read();
             final int i2 = is.read();
@@ -328,7 +328,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return An instance of ICC_Profile or null if the image contains no ICC
@@ -343,7 +343,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -360,7 +360,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -377,7 +377,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -396,7 +396,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return An instance of ICC_Profile or null if the image contains no ICC
@@ -411,7 +411,7 @@ public final class Imaging {
      * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and
      * TIFF images.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -450,7 +450,7 @@ public final class Imaging {
      * To parse the result use IccProfileParser or
      * ICC_Profile.getInstance(bytes).
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return A byte array.
@@ -469,7 +469,7 @@ public final class Imaging {
      * To parse the result use IccProfileParser or
      * ICC_Profile.getInstance(bytes).
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -490,7 +490,7 @@ public final class Imaging {
      * To parse the result use IccProfileParser or
      * ICC_Profile.getInstance(bytes).
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return A byte array.
@@ -509,7 +509,7 @@ public final class Imaging {
      * To parse the result use IccProfileParser or
      * ICC_Profile.getInstance(bytes).
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -538,7 +538,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param filename
      *            String.
      * @param bytes
@@ -561,7 +561,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param filename
      *            String.
      * @param bytes
@@ -582,7 +582,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -603,7 +603,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -626,7 +626,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return An instance of ImageInfo.
@@ -645,7 +645,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -666,7 +666,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -687,7 +687,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image metadata."
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return An instance of ImageInfo.
@@ -734,7 +734,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -749,7 +749,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -766,7 +766,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return The width and height of the image.
@@ -779,7 +779,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -794,7 +794,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image file.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return The width and height of the image.
@@ -807,7 +807,7 @@ public final class Imaging {
     /**
      * Determines the width and height of an image file.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -829,7 +829,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -844,7 +844,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -861,7 +861,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return Xmp Xml as String, if present. Otherwise, returns null.
@@ -874,7 +874,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -889,7 +889,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return Xmp Xml as String, if present. Otherwise, returns null.
@@ -902,7 +902,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -917,7 +917,7 @@ public final class Imaging {
     /**
      * Extracts the embedded XML metadata as an XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
@@ -943,7 +943,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @return An instance of IImageMetadata.
@@ -966,7 +966,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param bytes
      *            Byte array containing an image file.
      * @param params
@@ -991,7 +991,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -1016,7 +1016,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param is
      *            InputStream from which to read image data.
      * @param filename
@@ -1043,7 +1043,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @return An instance of IImageMetadata.
@@ -1066,7 +1066,7 @@ public final class Imaging {
      * <p>
      * Not to be confused with "image info."
      * <p>
-     * 
+     *
      * @param file
      *            File containing image data.
      * @param params
@@ -1091,7 +1091,7 @@ public final class Imaging {
      * content of the specified byte array to a string.
      * @param bytes A valid array of bytes.
      * @return A valid string.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -1107,7 +1107,7 @@ public final class Imaging {
      * content of the specified file to a string.
      * @param file A valid file reference.
      * @return A valid string.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -1126,7 +1126,7 @@ public final class Imaging {
     }
 
     /**
-     * Attempts to determine the image format of the specified data and 
+     * Attempts to determine the image format of the specified data and
      * evaluates its format compliance.   This method
      * returns a FormatCompliance object which includes information
      * about the data's compliance to a specific format.
@@ -1141,7 +1141,7 @@ public final class Imaging {
     }
 
     /**
-     * Attempts to determine the image format of the specified data and 
+     * Attempts to determine the image format of the specified data and
      * evaluates its format compliance.   This method
      * returns a FormatCompliance object which includes information
      * about the data's compliance to a specific format.
@@ -1163,11 +1163,11 @@ public final class Imaging {
     }
 
     /**
-     * Gets all images specified by the InputStream  (some 
+     * Gets all images specified by the InputStream  (some
      * formats may include multiple images within a single data source).
      * @param is A valid InputStream
      * @return A valid (potentially empty) list of BufferedImage objects.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -1179,11 +1179,11 @@ public final class Imaging {
     }
 
     /**
-     * Gets all images specified by the byte array (some 
+     * Gets all images specified by the byte array (some
      * formats may include multiple images within a single data source).
      * @param bytes a valid array of bytes
      * @return A valid (potentially empty) list of BufferedImage objects.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -1195,11 +1195,11 @@ public final class Imaging {
     }
 
    /**
-     * Gets all images specified by the file (some 
+     * Gets all images specified by the file (some
      * formats may include multiple images within a single data source).
      * @param file A reference to a valid data file.
      * @return A valid (potentially empty) list of BufferedImage objects.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -1210,7 +1210,7 @@ public final class Imaging {
         return getAllBufferedImages(new ByteSourceFile(file));
     }
 
-    
+
     private static List<BufferedImage> getAllBufferedImages(
             final ByteSource byteSource) throws ImageReadException, IOException {
         final ImageParser imageParser = getImageParser(byteSource);
@@ -1220,13 +1220,13 @@ public final class Imaging {
 
 
     /**
-     * Reads the first image from an InputStream. 
+     * Reads the first image from an InputStream.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param is a valid ImageStream from which to read data.
      * @return if successful, a valid buffered image
@@ -1240,20 +1240,20 @@ public final class Imaging {
         return getBufferedImage(is, null);
     }
 
-    
-    
+
+
     /**
-     * Reads the first image from an InputStream 
+     * Reads the first image from an InputStream
      * using data-processing options specified through a parameters
-     * map.  Options may be configured using the ImagingContants 
+     * map.  Options may be configured using the ImagingContants
      * interface or the various format-specific implementations provided
      * by this package.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param is a valid ImageStream from which to read data.
      * @param params an optional parameters map specifying options
@@ -1272,13 +1272,13 @@ public final class Imaging {
     }
 
     /**
-     * Reads the first image from a byte array. 
+     * Reads the first image from a byte array.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param bytes a valid array of bytes from which to read data.
      * @return if successful, a valid buffered image
@@ -1291,19 +1291,19 @@ public final class Imaging {
         return getBufferedImage(new ByteSourceArray(bytes), null);
     }
 
-   
+
     /**
      * Reads the first image from a byte array
      * using data-processing options specified through a parameters
-     * map.  Options may be configured using the ImagingContants 
+     * map.  Options may be configured using the ImagingContants
      * interface or the various format-specific implementations provided
      * by this package.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param bytes a valid array of bytes from which to read data.
      * @param params an optional parameters map specifying options.
@@ -1311,23 +1311,23 @@ public final class Imaging {
      * @throws ImageReadException in the event of a processing error
      * while reading an image (i.e. a format violation, etc.).
      * @throws IOException  in the event of an unrecoverable I/O exception.
-     */ 
+     */
     public static BufferedImage getBufferedImage(final byte[] bytes, final Map<String, Object> params)
             throws ImageReadException, IOException {
         return getBufferedImage(new ByteSourceArray(bytes), params);
     }
 
 
-    
-    
+
+
     /**
-     * Reads the first image from a file. 
+     * Reads the first image from a file.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param file a valid reference to a file containing image data.
      * @return if successful, a valid buffered image
@@ -1340,19 +1340,19 @@ public final class Imaging {
         return getBufferedImage(new ByteSourceFile(file), null);
     }
 
-    
+
     /**
      * Reads the first image from a file
      * using data-processing options specified through a parameters
-     * map.  Options may be configured using the ImagingContants 
+     * map.  Options may be configured using the ImagingContants
      * interface or the various format-specific implementations provided
      * by this package.
      * <p>
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param file a valid reference to a file containing image data.
      * @return if successful, a valid buffered image
@@ -1365,8 +1365,8 @@ public final class Imaging {
         return getBufferedImage(new ByteSourceFile(file), params);
     }
 
-    
-    
+
+
     private static BufferedImage getBufferedImage(final ByteSource byteSource,
             Map<String, Object> params) throws ImageReadException, IOException {
         final ImageParser imageParser = getImageParser(byteSource);
@@ -1378,7 +1378,7 @@ public final class Imaging {
     }
 
      /**
-     * Writes the content of a BufferedImage to a file using the specified 
+     * Writes the content of a BufferedImage to a file using the specified
      * image format.  Specifications for storing the file (such as data compression,
      * color models, metadata tags, etc.) may be specified using an optional
      * parameters map. These specifications are defined in the ImagingConstants
@@ -1388,8 +1388,8 @@ public final class Imaging {
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param src a valid BufferedImage object
      * @param file the file to which the output image is to be written
@@ -1399,7 +1399,7 @@ public final class Imaging {
      * unsupported image format, etc.
      * @throws IOException in the event of an unrecoverable I/O exception.
      * @see ImagingConstants
-     */    
+     */
     public static void writeImage(final BufferedImage src, final File file,
             final ImageFormat format, final Map<String, Object> params) throws ImageWriteException,
             IOException {
@@ -1409,9 +1409,9 @@ public final class Imaging {
         }
     }
 
-    
+
     /**
-     * Writes the content of a BufferedImage to a byte array using the specified 
+     * Writes the content of a BufferedImage to a byte array using the specified
      * image format.  Specifications for storing the file (such as data compression,
      * color models, metadata tags, etc.) may be specified using an optional
      * parameters map. These specifications are defined in the ImagingConstants
@@ -1421,8 +1421,8 @@ public final class Imaging {
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param src a valid BufferedImage object
      * @param format the format in which the output image is to be written
@@ -1432,7 +1432,7 @@ public final class Imaging {
      * unsupported image format, etc.
      * @throws IOException in the event of an unrecoverable I/O exception.
      * @see ImagingConstants
-     */   
+     */
     public static byte[] writeImageToBytes(final BufferedImage src,
             final ImageFormat format, final Map<String, Object> params) throws ImageWriteException,
             IOException {
@@ -1445,7 +1445,7 @@ public final class Imaging {
 
 
      /**
-     * Writes the content of a BufferedImage to an OutputStream using the specified 
+     * Writes the content of a BufferedImage to an OutputStream using the specified
      * image format.  Specifications for storing the file (such as data compression,
      * color models, metadata tags, etc.) may be specified using an optional
      * parameters map. These specifications are defined in the ImagingConstants
@@ -1455,8 +1455,8 @@ public final class Imaging {
      * For the most recent information on support for specific formats, refer to
      * <a href="http://commons.apache.org/imaging/formatsupport.html">Format Support</a>
      * at the main project development web site.   While the Apache Commons
-     * Imaging package does not fully support all formats, it  can read 
-     * image info, metadata and ICC profiles from all image formats that 
+     * Imaging package does not fully support all formats, it  can read
+     * image info, metadata and ICC profiles from all image formats that
      * provide this data.
      * @param src a valid BufferedImage object
      * @param os the OutputStream to which the output image is to be written
@@ -1466,7 +1466,7 @@ public final class Imaging {
      * unsupported image format, etc.
      * @throws IOException in the event of an unrecoverable I/O exception.
      * @see ImagingConstants
-     */    
+     */
     public static void writeImage(final BufferedImage src, final OutputStream os,
             final ImageFormat format, Map<String, Object> params) throws ImageWriteException,
             IOException {
diff --git a/src/main/java/org/apache/commons/imaging/ImagingConstants.java b/src/main/java/org/apache/commons/imaging/ImagingConstants.java
index 91819cff..476900cc 100644
--- a/src/main/java/org/apache/commons/imaging/ImagingConstants.java
+++ b/src/main/java/org/apache/commons/imaging/ImagingConstants.java
@@ -17,14 +17,14 @@
 package org.apache.commons.imaging;
 
 /**
- * Defines constants that may be used in passing options to 
+ * Defines constants that may be used in passing options to
  * ImageParser read/write implementations, the utility routines
  * implemented in the Imaging class, and throughout the
- * Apache Commons Imaging package.  Individual ImageParser 
+ * Apache Commons Imaging package.  Individual ImageParser
  * implementations may define their own format-specific options.
  */
 public final class ImagingConstants {
-    
+
     /**
      * Parameter key. Used to hint the filename when reading from a byte array
      * or InputStream. The filename hint can help disambiguate what file the
@@ -34,7 +34,7 @@ public final class ImagingConstants {
      * <p>
      * Valid values: filename as string
      * <p>
-     * 
+     *
      * @see java.io.InputStream
      */
     public static final String PARAM_KEY_FILENAME = "FILENAME";
@@ -45,7 +45,7 @@ public final class ImagingConstants {
      * Valid values: Any format defined in ImageFormat, such as
      * ImageFormat.IMAGE_FORMAT_PNG.
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.ImageFormats
      */
     public static final String PARAM_KEY_FORMAT = "FORMAT";
@@ -61,7 +61,7 @@ public final class ImagingConstants {
      * TiffConstants.TIFF_COMPRESSION_LZW,
      * TiffConstants.TIFF_COMPRESSION_PACKBITS.
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.formats.tiff.constants.TiffConstants
      */
     public static final String PARAM_KEY_COMPRESSION = "COMPRESSION";
@@ -75,7 +75,7 @@ public final class ImagingConstants {
      * <p>
      * Valid values: Boolean.TRUE and Boolean.FALSE.
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.formats.tiff.constants.TiffConstants
      */
     public static final String PARAM_KEY_READ_THUMBNAILS = "READ_THUMBNAILS";
@@ -87,26 +87,26 @@ public final class ImagingConstants {
      * Valid values: Boolean.TRUE and Boolean.FALSE. Default value:
      * Boolean.FALSE.
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.formats.tiff.constants.TiffConstants
      */
     public static final String PARAM_KEY_STRICT = "STRICT";
 
     /**
      * Parameter key.
-     * 
+     *
      * Only used when writing images.
      * <p>
      * Valid values: TiffOutputSet to write into the image's EXIF metadata.
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.formats.tiff.write.TiffOutputSet
      */
     public static final String PARAM_KEY_EXIF = "EXIF";
 
     /**
      * Parameter key.
-     * 
+     *
      * Only used when writing images.
      * <p>
      * Valid values: String of XMP XML.
@@ -120,7 +120,7 @@ public final class ImagingConstants {
      * <p>
      * Valid values: PixelDensity
      * <p>
-     * 
+     *
      * @see org.apache.commons.imaging.PixelDensity
      */
     public static final String PARAM_KEY_PIXEL_DENSITY = "PIXEL_DENSITY";
diff --git a/src/main/java/org/apache/commons/imaging/ImagingException.java b/src/main/java/org/apache/commons/imaging/ImagingException.java
index 1c5f9fb7..1d651100 100644
--- a/src/main/java/org/apache/commons/imaging/ImagingException.java
+++ b/src/main/java/org/apache/commons/imaging/ImagingException.java
@@ -17,7 +17,7 @@
 package org.apache.commons.imaging;
 
 /**
- * The base class for implementing custom exceptions in the 
+ * The base class for implementing custom exceptions in the
  * Apache Commons Imaging package.
  */
 public class ImagingException extends Exception {
diff --git a/src/main/java/org/apache/commons/imaging/color/ColorCmy.java b/src/main/java/org/apache/commons/imaging/color/ColorCmy.java
index f2e8281b..39f0f237 100644
--- a/src/main/java/org/apache/commons/imaging/color/ColorCmy.java
+++ b/src/main/java/org/apache/commons/imaging/color/ColorCmy.java
@@ -17,7 +17,7 @@
 package org.apache.commons.imaging.color;
 
 public final class ColorCmy {
-    
+
     /**
      * A constant for color cyan. Color components are:
      * <pre>
diff --git a/src/main/java/org/apache/commons/imaging/color/ColorConversions.java b/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
index 608313a1..397bd739 100644
--- a/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
+++ b/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
@@ -21,7 +21,7 @@ public final class ColorConversions {
     private static final double REF_X = 95.047;  // Observer= 2°, Illuminant= D65
     private static final double REF_Y = 100.000;
     private static final double REF_Z = 108.883;
-    
+
     private ColorConversions() {
     }
 
@@ -316,7 +316,7 @@ public final class ColorConversions {
         // Debug.debug("del_Max", del_Max);
         if (del_Max == 0) {
             // This is a gray, no chroma...
-        
+
             H = 0; // HSL results = 0 ÷ 1
             S = 0;
         } else {
diff --git a/src/main/java/org/apache/commons/imaging/common/BasicCParser.java b/src/main/java/org/apache/commons/imaging/common/BasicCParser.java
index 10eb9c6a..4ab7e5ae 100644
--- a/src/main/java/org/apache/commons/imaging/common/BasicCParser.java
+++ b/src/main/java/org/apache/commons/imaging/common/BasicCParser.java
@@ -200,7 +200,7 @@ public class BasicCParser {
                         throw new ImageReadException("Bad preprocessor directive");
                     }
                     if (!tokens[0].equals("define")) {
-                        throw new ImageReadException("Invalid/unsupported " 
+                        throw new ImageReadException("Invalid/unsupported "
                                 + "preprocessor directive '" + tokens[0] + "'");
                     }
                     defines.put(tokens[1], (tokens.length == 3) ? tokens[2]
diff --git a/src/main/java/org/apache/commons/imaging/common/BinaryFunctions.java b/src/main/java/org/apache/commons/imaging/common/BinaryFunctions.java
index c452cb91..fd0021d5 100644
--- a/src/main/java/org/apache/commons/imaging/common/BinaryFunctions.java
+++ b/src/main/java/org/apache/commons/imaging/common/BinaryFunctions.java
@@ -36,7 +36,7 @@ public final class BinaryFunctions {
 
     private BinaryFunctions() {
     }
-    
+
     public static boolean startsWith(final byte[] haystack, final byte[] needle) {
         if (needle == null) {
             return false;
@@ -237,14 +237,14 @@ public final class BinaryFunctions {
         if ((byte0 | byte1) < 0) {
             throw new IOException(exception);
         }
-        
+
         final int result;
         if (byteOrder == ByteOrder.BIG_ENDIAN) {
             result = (byte0 << 8) | byte1;
         } else {
             result = (byte1 << 8) | byte0;
         }
-        
+
         return result;
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/common/BinaryOutputStream.java b/src/main/java/org/apache/commons/imaging/common/BinaryOutputStream.java
index 202dfb06..1d393d9a 100644
--- a/src/main/java/org/apache/commons/imaging/common/BinaryOutputStream.java
+++ b/src/main/java/org/apache/commons/imaging/common/BinaryOutputStream.java
@@ -54,23 +54,23 @@ public class BinaryOutputStream extends OutputStream {
         os.write(bytes, 0, bytes.length);
         count += bytes.length;
     }
-    
+
     @Override
     public final void write(final byte[] bytes, final int offset, final int length) throws IOException {
         os.write(bytes, offset, length);
         count += length;
     }
-    
+
     @Override
     public void flush() throws IOException {
         os.flush();
     }
-    
+
     @Override
     public void close() throws IOException {
         os.close();
     }
-    
+
     public int getByteCount() {
         return count;
     }
diff --git a/src/main/java/org/apache/commons/imaging/common/ByteConversions.java b/src/main/java/org/apache/commons/imaging/common/ByteConversions.java
index 10b83337..c282f951 100644
--- a/src/main/java/org/apache/commons/imaging/common/ByteConversions.java
+++ b/src/main/java/org/apache/commons/imaging/common/ByteConversions.java
@@ -25,13 +25,13 @@ import java.nio.ByteOrder;
 public final class ByteConversions {
     private ByteConversions() {
     }
-    
+
     public static byte[] toBytes(final short value, final ByteOrder byteOrder) {
         final byte[] result = new byte[2];
         toBytes(value, byteOrder, result, 0);
         return result;
     }
-    
+
     public static byte[] toBytes(final short[] values, final ByteOrder byteOrder) {
         return toBytes(values, 0, values.length, byteOrder);
     }
@@ -59,7 +59,7 @@ public final class ByteConversions {
         toBytes(value, byteOrder, result, 0);
         return result;
     }
-    
+
     public static byte[] toBytes(final int[] values, final ByteOrder byteOrder) {
         return toBytes(values, 0, values.length, byteOrder);
     }
@@ -71,7 +71,7 @@ public final class ByteConversions {
         }
         return result;
     }
-    
+
     private static void toBytes(final int value, final ByteOrder byteOrder, final byte[] result, final int offset) {
         if (byteOrder == ByteOrder.BIG_ENDIAN) {
             result[offset + 0] = (byte) (value >> 24);
@@ -237,7 +237,7 @@ public final class ByteConversions {
             return ((byte1 << 8) | byte0);
         }
     }
-    
+
     public static int[] toUInt16s(final byte[] bytes, final ByteOrder byteOrder) {
         return toUInt16s(bytes, 0, bytes.length, byteOrder);
     }
@@ -302,7 +302,7 @@ public final class ByteConversions {
         return toFloats(bytes, 0, bytes.length, byteOrder);
     }
 
-    private static float[] toFloats(final byte[] bytes, final int offset, 
+    private static float[] toFloats(final byte[] bytes, final int offset,
             final int length, final ByteOrder byteOrder) {
         final float[] result = new float[length / 4];
         for (int i = 0; i < result.length; i++) {
@@ -379,7 +379,7 @@ public final class ByteConversions {
         return toRationals(bytes, 0, bytes.length, byteOrder);
     }
 
-    private static RationalNumber[] toRationals(final byte[] bytes, 
+    private static RationalNumber[] toRationals(final byte[] bytes,
             final int offset, final int length, final ByteOrder byteOrder) {
         final RationalNumber[] result = new RationalNumber[length / 8];
         for (int i = 0; i < result.length; i++) {
diff --git a/src/main/java/org/apache/commons/imaging/common/ImageBuilder.java b/src/main/java/org/apache/commons/imaging/common/ImageBuilder.java
index fe060306..f31c254b 100644
--- a/src/main/java/org/apache/commons/imaging/common/ImageBuilder.java
+++ b/src/main/java/org/apache/commons/imaging/common/ImageBuilder.java
@@ -25,18 +25,18 @@
  * in Apache Sanselan.
  *   This increase is attained because ImageBuilder is a highly specialized
  * class that does not need to perform the general-purpose logic required
- * for BufferedImage.  If you need to modify this class to add new 
+ * for BufferedImage.  If you need to modify this class to add new
  * image formats or functionality, keep in mind that some of its methods
- * are invoked literally millions of times when building an image. 
+ * are invoked literally millions of times when building an image.
  * Since even the introduction of something as small as a single conditional
  * inside of setRGB could result in a noticeable increase in the
  * time to read a file, changes should be made with care.
  *    During development, I experimented with inlining the setRGB logic
  * in some of the code that uses it. This approach did not significantly
  * improve performance, leading me to speculate that the Java JIT compiler
- * might have inlined the method at run time.  Further investigation 
+ * might have inlined the method at run time.  Further investigation
  * is required.
- * 
+ *
  */
 package org.apache.commons.imaging.common;
 
@@ -74,7 +74,7 @@ public class ImageBuilder {
         if (height <= 0) {
             throw new RasterFormatException("zero or negative height value");
         }
-            
+
         data = new int[width * height];
         this.width = width;
         this.height = height;
@@ -130,7 +130,7 @@ public class ImageBuilder {
     public BufferedImage getBufferedImage() {
         return makeBufferedImage(data, width, height, hasAlpha);
     }
-    
+
     /**
      * Gets a subimage from the ImageBuilder using the specified parameters.
      * If the parameters specify a rectangular region that is not entirely
@@ -138,15 +138,15 @@ public class ImageBuilder {
      * throw a RasterFormatException.  This runtime-exception behavior
      * is consistent with the behavior of the getSubimage method
      * provided by BufferdImage.
-     * @param x the X coordinate of the upper-left corner of the 
+     * @param x the X coordinate of the upper-left corner of the
      *          specified rectangular region
-     * @param y the Y coordinate of the upper-left corner of the 
+     * @param y the Y coordinate of the upper-left corner of the
      *          specified rectangular region
      * @param w the width of the specified rectangular region
      * @param h the height of the specified rectangular region
      * @return a BufferedImage that constructed from the deta within the
      *           specified rectangular region
-     * @throws RasterFormatException f the specified area is not contained 
+     * @throws RasterFormatException f the specified area is not contained
      *         within this ImageBuilder
      */
     public BufferedImage getSubimage(final int x, final int y, final int w, final int h) {
@@ -172,7 +172,7 @@ public class ImageBuilder {
         }
 
 
-        // Transcribe the data to an output image array  
+        // Transcribe the data to an output image array
         final int[] argb = new int[w * h];
         int k = 0;
         for (int iRow = 0; iRow < h; iRow++) {
diff --git a/src/main/java/org/apache/commons/imaging/common/PackBits.java b/src/main/java/org/apache/commons/imaging/common/PackBits.java
index c700de32..53a538f2 100644
--- a/src/main/java/org/apache/commons/imaging/common/PackBits.java
+++ b/src/main/java/org/apache/commons/imaging/common/PackBits.java
@@ -110,7 +110,7 @@ public class PackBits {
             int ptr = 0;
             while (ptr < bytes.length) {
                 int dup = findNextDuplicate(bytes, ptr);
-    
+
                 if (dup == ptr) {
                     // write run length
                     final int len = findRunLength(bytes, dup);
@@ -121,7 +121,7 @@ public class PackBits {
                 } else {
                     // write literals
                     int len = dup - ptr;
-    
+
                     if (dup > 0) {
                         final int runlen = findRunLength(bytes, dup);
                         if (runlen < 3) {
@@ -135,12 +135,12 @@ public class PackBits {
                             }
                         }
                     }
-    
+
                     if (dup < 0) {
                         len = bytes.length - ptr;
                     }
                     final int actualLen = Math.min(len, 128);
-    
+
                     baos.write(actualLen - 1);
                     for (int i = 0; i < actualLen; i++) {
                         baos.write(bytes[ptr]);
diff --git a/src/main/java/org/apache/commons/imaging/common/RationalNumber.java b/src/main/java/org/apache/commons/imaging/common/RationalNumber.java
index 4d7c756e..3b553b7c 100644
--- a/src/main/java/org/apache/commons/imaging/common/RationalNumber.java
+++ b/src/main/java/org/apache/commons/imaging/common/RationalNumber.java
@@ -23,7 +23,7 @@ import java.text.NumberFormat;
  */
 public class RationalNumber extends Number {
 
-    private static final long serialVersionUID = -8412262656468158691L;    
+    private static final long serialVersionUID = -8412262656468158691L;
 
     // int-precision tolerance
     private static final double TOLERANCE = 1E-8;
diff --git a/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSource.java b/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSource.java
index fa95b831..49385607 100644
--- a/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSource.java
+++ b/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSource.java
@@ -48,7 +48,7 @@ public abstract class ByteSource {
     public byte[] getBlock(final int start, final int length) throws IOException {
         return getBlock(0xFFFFffffL & start, length);
     }
-    
+
     public abstract byte[] getBlock(long start, int length) throws IOException;
 
     public abstract byte[] getAll() throws IOException;
diff --git a/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSourceInputStream.java b/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSourceInputStream.java
index b5603dcf..2398fac8 100644
--- a/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSourceInputStream.java
+++ b/src/main/java/org/apache/commons/imaging/common/bytesource/ByteSourceInputStream.java
@@ -91,7 +91,7 @@ public class ByteSourceInputStream extends ByteSource {
         private CacheBlock block;
         private boolean readFirst;
         private int blockIndex;
-        
+
         @Override
         public int read() throws IOException {
             if (null == block) {
@@ -158,7 +158,7 @@ public class ByteSourceInputStream extends ByteSource {
             blockIndex += readSize;
             return readSize;
         }
-        
+
         @Override
         public long skip(final long n) throws IOException {
 
diff --git a/src/main/java/org/apache/commons/imaging/common/itu_t4/HuffmanTree.java b/src/main/java/org/apache/commons/imaging/common/itu_t4/HuffmanTree.java
index 92ef423e..8e42f23a 100644
--- a/src/main/java/org/apache/commons/imaging/common/itu_t4/HuffmanTree.java
+++ b/src/main/java/org/apache/commons/imaging/common/itu_t4/HuffmanTree.java
@@ -25,7 +25,7 @@ import java.util.List;
  */
 class HuffmanTree<T> {
     private final List<Node<T>> nodes = new ArrayList<>();
-    
+
     private static final class Node<T> {
         boolean empty = true;
         T value;
diff --git a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
index c27bb5db..e737a2b3 100644
--- a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
+++ b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
@@ -79,7 +79,7 @@ public final class T4AndT6Compression {
             throws ImageWriteException {
         int color = WHITE;
         int runLength = 0;
-        
+
         for (int x = 0; x < width; x++) {
             try {
                 final int nextColor = inputStream.readBits(1);
@@ -97,7 +97,7 @@ public final class T4AndT6Compression {
                 throw new ImageWriteException("Error reading image to compress", ioException);
             }
         }
-        
+
         writeRunLength(outputStream, runLength, color);
     }
 
@@ -105,7 +105,7 @@ public final class T4AndT6Compression {
      * Compressed with the "Modified Huffman" encoding of section 10 in the
      * TIFF6 specification. No EOLs, no RTC, rows are padded to end on a byte
      * boundary.
-     * 
+     *
      * @param uncompressed
      * @param width
      * @param height
@@ -129,7 +129,7 @@ public final class T4AndT6Compression {
      * Decompresses the "Modified Huffman" encoding of section 10 in the TIFF6
      * specification. No EOLs, no RTC, rows are padded to end on a byte
      * boundary.
-     * 
+     *
      * @param compressed
      * @param width
      * @param height
@@ -152,7 +152,7 @@ public final class T4AndT6Compression {
                     color = 1 - color;
                     rowLength += runLength;
                 }
-    
+
                 if (rowLength == width) {
                     inputStream.flushCache();
                     outputStream.flush();
@@ -200,7 +200,7 @@ public final class T4AndT6Compression {
     /**
      * Decompresses T.4 1D encoded data. EOL at the beginning and after each
      * row, can be preceded by fill bits to fit on a byte boundary, no RTC.
-     * 
+     *
      * @param compressed
      * @param width
      * @param height
@@ -230,7 +230,7 @@ public final class T4AndT6Compression {
                 } catch (final HuffmanTreeException huffmanException) {
                     throw new ImageReadException("Decompression error", huffmanException);
                 }
-    
+
                 if (rowLength == width) {
                     outputStream.flush();
                 } else if (rowLength > width) {
@@ -241,7 +241,7 @@ public final class T4AndT6Compression {
             return ret;
         }
     }
- 
+
     private static int compressT(final int a0, final int a1, final int b1, final BitArrayOutputStream outputStream,final  int codingA0Color, final int[] codingLine ){
           final int a1b1 = a1 - b1;
           if (-3 <= a1b1 && a1b1 <= 3) {
@@ -263,7 +263,7 @@ public final class T4AndT6Compression {
               }
               entry.writeBits(outputStream);
               return a1;
-              
+
           } else {
               final int a2 = nextChangingElement(codingLine, 1 - codingA0Color, a1 + 1);
               final int a0a1 = a1 - a0;
@@ -287,7 +287,7 @@ public final class T4AndT6Compression {
         } else {
             T4_T6_Tables.EOL.writeBits(outputStream);
         }
-        
+
         for (int y = 0; y < height; y++) {
             if (kCounter > 0) {
                 // 2D
@@ -349,7 +349,7 @@ public final class T4AndT6Compression {
             }
             inputStream.flushCache();
         }
-        
+
         return outputStream.toByteArray();
     }
 
@@ -358,7 +358,7 @@ public final class T4AndT6Compression {
      * row, can be preceded by fill bits to fit on a byte boundary, and is
      * succeeded by a tag bit determining whether the next line is encoded using
      * 1D or 2D. No RTC.
-     * 
+     *
      * @param compressed
      * @param width
      * @param height
@@ -458,7 +458,7 @@ public final class T4AndT6Compression {
                 throw new ImageReadException("Unrecoverable row length error in image row " + y);
             }
         }
-        
+
         return outputStream.toByteArray();
     }
 
@@ -520,7 +520,7 @@ public final class T4AndT6Compression {
      * Decompress T.6 encoded data. No EOLs, except for 2 consecutive ones at
      * the end (the EOFB, end of fax block). No RTC. No fill bits anywhere. All
      * data is 2D encoded.
-     * 
+     *
      * @param compressed
      * @param width
      * @param height
@@ -598,7 +598,7 @@ public final class T4AndT6Compression {
                 throw new ImageReadException("Unrecoverable row length error in image row " + y);
             }
         }
-        
+
         return outputStream.toByteArray();
     }
 
@@ -657,11 +657,11 @@ public final class T4AndT6Compression {
                 first = middle + 1;
             }
         } while (first < last);
-        
+
         return entries[first];
     }
 
-    private static int readTotalRunLength(final BitInputStreamFlexible bitStream, 
+    private static int readTotalRunLength(final BitInputStreamFlexible bitStream,
             final int color) throws ImageReadException {
         try {
             int totalLength = 0;
@@ -693,7 +693,7 @@ public final class T4AndT6Compression {
                 && line[position] == currentColour; position++) {
             // noop
         }
-        
+
         return position < line.length ? position : line.length;
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4_T6_Tables.java b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4_T6_Tables.java
index f396c3d6..69c848e7 100644
--- a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4_T6_Tables.java
+++ b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4_T6_Tables.java
@@ -239,7 +239,7 @@ class T4_T6_Tables {
     public static final Entry VL1 = new Entry("010", 0);
     public static final Entry VL2 = new Entry("000010", 0);
     public static final Entry VL3 = new Entry("0000010", 0);
-    
+
     public static class Entry {
         String bitString;
         Integer value;
diff --git a/src/main/java/org/apache/commons/imaging/common/mylzw/MyBitOutputStream.java b/src/main/java/org/apache/commons/imaging/common/mylzw/MyBitOutputStream.java
index 5b90cb0e..d4480889 100644
--- a/src/main/java/org/apache/commons/imaging/common/mylzw/MyBitOutputStream.java
+++ b/src/main/java/org/apache/commons/imaging/common/mylzw/MyBitOutputStream.java
@@ -83,7 +83,7 @@ public class MyBitOutputStream extends OutputStream {
             final int bitMask = (1 << bitsInCache) - 1;
             int b = bitMask & bitCache;
 
-            if (byteOrder == ByteOrder.BIG_ENDIAN) { 
+            if (byteOrder == ByteOrder.BIG_ENDIAN) {
                 // MSB, so write from left
                 b <<= 8 - bitsInCache; // left align fragment.
                 os.write(b);
diff --git a/src/main/java/org/apache/commons/imaging/formats/bmp/BmpImageParser.java b/src/main/java/org/apache/commons/imaging/formats/bmp/BmpImageParser.java
index f1e696c2..e0b015d1 100644
--- a/src/main/java/org/apache/commons/imaging/formats/bmp/BmpImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/bmp/BmpImageParser.java
@@ -763,7 +763,7 @@ public class BmpImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserBitFields.java b/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserBitFields.java
index f02abb14..037b344a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserBitFields.java
+++ b/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserBitFields.java
@@ -36,7 +36,7 @@ class PixelParserBitFields extends PixelParserSimple {
     private final int alphaMask;
 
     private int bytecount;
-    
+
     public PixelParserBitFields(final BmpHeaderInfo bhi, final byte[] colorTable, final byte[] imageData) {
         super(bhi, colorTable, imageData);
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserRgb.java b/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserRgb.java
index 34062ad9..14750898 100644
--- a/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserRgb.java
+++ b/src/main/java/org/apache/commons/imaging/formats/bmp/PixelParserRgb.java
@@ -36,7 +36,7 @@ class PixelParserRgb extends PixelParserSimple {
     @Override
     public int getNextRGB() throws ImageReadException, IOException {
 
-        if ((bhi.bitsPerPixel == 1) 
+        if ((bhi.bitsPerPixel == 1)
                 || (bhi.bitsPerPixel == 4)) { // always grayscale?
             if (cachedBitCount < bhi.bitsPerPixel) {
                 if (cachedBitCount != 0) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/dcx/DcxImageParser.java b/src/main/java/org/apache/commons/imaging/formats/dcx/DcxImageParser.java
index 29e43ac4..d60c17a4 100644
--- a/src/main/java/org/apache/commons/imaging/formats/dcx/DcxImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/dcx/DcxImageParser.java
@@ -210,7 +210,7 @@ public class DcxImageParser extends ImageParser {
             final Object value = params.remove(PcxConstants.PARAM_KEY_PCX_COMPRESSION);
             pcxParams.put(PcxConstants.PARAM_KEY_PCX_COMPRESSION, value);
         }
-        
+
         if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) {
             final Object value = params.remove(PARAM_KEY_PIXEL_DENSITY);
             if (value != null) {
@@ -245,7 +245,7 @@ public class DcxImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/gif/GifImageParser.java b/src/main/java/org/apache/commons/imaging/formats/gif/GifImageParser.java
index 843a2caa..2cb4768d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/gif/GifImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/gif/GifImageParser.java
@@ -593,7 +593,7 @@ public class GifImageParser extends ImageParser {
         }
 
         imageData.toString(pw, "");
-        
+
         final GifImageContents blocks = readFile(byteSource, false);
 
         pw.println("gif.blocks: " + blocks.blocks.size());
@@ -992,7 +992,7 @@ public class GifImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/icns/IcnsImageParser.java b/src/main/java/org/apache/commons/imaging/formats/icns/IcnsImageParser.java
index 9db5449a..62153362 100644
--- a/src/main/java/org/apache/commons/imaging/formats/icns/IcnsImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/icns/IcnsImageParser.java
@@ -332,7 +332,7 @@ public class IcnsImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/icns/IcnsType.java b/src/main/java/org/apache/commons/imaging/formats/icns/IcnsType.java
index 7f71b9cc..5721da42 100644
--- a/src/main/java/org/apache/commons/imaging/formats/icns/IcnsType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/icns/IcnsType.java
@@ -170,7 +170,7 @@ enum IcnsType {
         if (bytes.length != 4) {
             throw new IllegalArgumentException("Invalid ICNS type");
         }
-        return ((0xff & bytes[0]) << 24) 
+        return ((0xff & bytes[0]) << 24)
              | ((0xff & bytes[1]) << 16)
              | ((0xff & bytes[2]) << 8)
              | (0xff & bytes[3]);
diff --git a/src/main/java/org/apache/commons/imaging/formats/icns/Rle24Compression.java b/src/main/java/org/apache/commons/imaging/formats/icns/Rle24Compression.java
index a7176eaa..42d0f3a1 100644
--- a/src/main/java/org/apache/commons/imaging/formats/icns/Rle24Compression.java
+++ b/src/main/java/org/apache/commons/imaging/formats/icns/Rle24Compression.java
@@ -19,7 +19,7 @@ package org.apache.commons.imaging.formats.icns;
 final class Rle24Compression {
     private Rle24Compression() {
     }
-    
+
     public static byte[] decompress(final int width, final int height, final byte[] data) {
         final int pixelCount = width * height;
         final byte[] result = new byte[4 * pixelCount];
diff --git a/src/main/java/org/apache/commons/imaging/formats/ico/IcoImageParser.java b/src/main/java/org/apache/commons/imaging/formats/ico/IcoImageParser.java
index 5764de39..43836338 100644
--- a/src/main/java/org/apache/commons/imaging/formats/ico/IcoImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/ico/IcoImageParser.java
@@ -380,7 +380,7 @@ public class IcoImageParser extends ImageParser {
         final int xPelsPerMeter = read4Bytes("xPelsPerMeter", is,
                 "Not a Valid ICO File", getByteOrder()); // XPelsPerMeter (4 bytes), we don?t
                                          // use this (0)
-        final int yPelsPerMeter = read4Bytes("yPelsPerMeter", is, 
+        final int yPelsPerMeter = read4Bytes("yPelsPerMeter", is,
                 "Not a Valid ICO File", getByteOrder()); // YPelsPerMeter (4 bytes), we don?t
                                          // use this (0)
         final int colorsUsed = read4Bytes("colorsUsed", is, "Not a Valid ICO File", getByteOrder()); // ColorsUsed
@@ -437,7 +437,7 @@ public class IcoImageParser extends ImageParser {
             bos.write4Bytes(bitmapSize);
             bos.write4Bytes(0);
             bos.write4Bytes(bitmapPixelsOffset);
-    
+
             bos.write4Bytes(56);
             bos.write4Bytes(width);
             bos.write4Bytes(height / 2);
@@ -636,7 +636,7 @@ public class IcoImageParser extends ImageParser {
         if (params.containsKey(PARAM_KEY_FORMAT)) {
             params.remove(PARAM_KEY_FORMAT);
         }
-        
+
         final PixelDensity pixelDensity = (PixelDensity) params.remove(PARAM_KEY_PIXEL_DENSITY);
 
         if (!params.isEmpty()) {
@@ -798,7 +798,7 @@ public class IcoImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
index eac5b62c..d4caacfc 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
@@ -147,7 +147,7 @@ public final class JpegConstants {
                     0x30, // 0
                     0, });
     public static final int CONST_8BIM = BinaryFunctions.charsToQuad('8', 'B', 'I', 'M');
-    
+
     private JpegConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageMetadata.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageMetadata.java
index d7f5cce1..4e3da6c3 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageMetadata.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageMetadata.java
@@ -73,7 +73,7 @@ public class JpegImageMetadata implements ImageMetadata {
 
     /**
      * Returns the size of the first JPEG thumbnail found in the EXIF metadata.
-     * 
+     *
      * @return Thumbnail width and height or null if no thumbnail.
      * @throws ImageReadException
      * @throws IOException
@@ -90,7 +90,7 @@ public class JpegImageMetadata implements ImageMetadata {
 
     /**
      * Returns the data of the first JPEG thumbnail found in the EXIF metadata.
-     * 
+     *
      * @return JPEG data or null if no thumbnail.
      * @throws ImageReadException
      * @throws IOException
@@ -118,7 +118,7 @@ public class JpegImageMetadata implements ImageMetadata {
 
     /**
      * Get the thumbnail image if available.
-     * 
+     *
      * @return the thumbnail image. May be <code>null</code> if no image could
      *         be found.
      * @throws ImageReadException
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageParser.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageParser.java
index c3b89b4f..fff62714 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegImageParser.java
@@ -68,7 +68,7 @@ public class JpegImageParser extends ImageParser {
 
     private static final String DEFAULT_EXTENSION = ".jpg";
     private static final String[] ACCEPTED_EXTENSIONS = { ".jpg", ".jpeg", };
-    
+
     public JpegImageParser() {
         setByteOrder(ByteOrder.BIG_ENDIAN);
         // setDebug(true);
@@ -525,7 +525,7 @@ public class JpegImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
@@ -702,7 +702,7 @@ public class JpegImageParser extends ImageParser {
         if (app14Segments != null && !app14Segments.isEmpty()) {
             app14Segment = (App14Segment) app14Segments.get(0);
         }
-        
+
         // JfifSegment fTheJFIFSegment = (JfifSegment) findSegment(segments,
         // kJFIFMarker);
 
@@ -814,14 +814,14 @@ public class JpegImageParser extends ImageParser {
 
         boolean transparent = false;
         final boolean usesPalette = false; // TODO: inaccurate.
-        
+
         // See http://docs.oracle.com/javase/6/docs/api/javax/imageio/metadata/doc-files/jpeg_metadata.html#color
         ImageInfo.ColorType colorType = ImageInfo.ColorType.UNKNOWN;
         // Some images have both JFIF/APP0 and APP14.
         // JFIF is meant to win but in them APP14 is clearly right, so make it win.
         if (app14Segment != null && app14Segment.isAdobeJpegSegment()) {
             final int colorTransform = app14Segment.getAdobeColorTransform();
-            if (colorTransform == App14Segment.ADOBE_COLOR_TRANSFORM_UNKNOWN) { 
+            if (colorTransform == App14Segment.ADOBE_COLOR_TRANSFORM_UNKNOWN) {
                 if (numberOfComponents == 3) {
                     colorType = ImageInfo.ColorType.RGB;
                 } else if (numberOfComponents == 4) {
@@ -924,7 +924,7 @@ public class JpegImageParser extends ImageParser {
                                 maxVerticalSamplingFactor = component.verticalSamplingFactor;
                             }
                         }
-                        final boolean isSubsampled = (minHorizontalSamplingFactor != maxHorizontalSmaplingFactor) 
+                        final boolean isSubsampled = (minHorizontalSamplingFactor != maxHorizontalSmaplingFactor)
                                 || (minVerticalSamplingFactor != maxVerticalSamplingFactor);
                         if (numberOfComponents == 3) {
                             if (isSubsampled) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
index d4401389..9368d71b 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
@@ -92,7 +92,7 @@ public class JpegUtils extends BinaryFileParser {
                     return;
                 }
             }
-            
+
             Debug.debug(Integer.toString(markerCount) + " markers");
         }
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Block.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Block.java
index 2ac966df..17162616 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Block.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Block.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
index dd93470f..b4551644 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
@@ -21,7 +21,7 @@ final class Dct {
      * Mitchell, Chapter 4, discusses a number of approaches to the fast DCT.
      * Here's the cost, exluding modified (de)quantization, for transforming an
      * 8x8 block:
-     * 
+     *
      * Algorithm                     Adds Multiplies RightShifts Total
      * Naive                          896       1024           0  1920
      * "Symmetries"                   448        224           0   672
@@ -29,22 +29,22 @@ final class Dct {
      * Arai, Agui and Nakajima (AA&N) 464         80           0   544
      * Feig 8x8                       462         54           6   522
      * Fused mul/add (a pipe dream)                                416
-     * 
+     *
      * IJG's libjpeg, FFmpeg, and a number of others use AA&N.
-     * 
+     *
      * It would appear that Feig does 4-5% less operations, and multiplications
      * are reduced from 80 in AA&N to only 54. But in practice:
-     * 
+     *
      * Benchmarks, Intel Core i3 @ 2.93 GHz in long mode, 4 GB RAM Time taken to
      * do 100 million IDCTs (less is better):
      * Rene' Stöckel's Feig, int: 45.07 seconds
      * My Feig, floating point: 36.252 seconds
      * AA&N, unrolled loops, double[][] -> double[][]: 25.167 seconds
-     * 
+     *
      * Clearly Feig is hopeless. I suspect the performance killer is simply the
      * weight of the algorithm: massive number of local variables, large code
      * size, and lots of random array accesses.
-     * 
+     *
      * Also, AA&N can be optimized a lot:
      * AA&N, rolled loops, double[][] -> double[][]: 21.162 seconds
      * AA&N, rolled loops, float[][] -> float[][]: no improvement,
@@ -56,10 +56,10 @@ final class Dct {
      * AA&N, previous version rewritten in C and compiled with "gcc -O3"
      * takes: 8.5 seconds
      * (probably due to heavy use of SIMD)
-     * 
+     *
      * Other brave attempts: AA&N, best float version converted to 16:16 fixed
      * point: 23.923 seconds
-     * 
+     *
      * Anyway the best float version stays. 18.5 seconds = 5.4 million
      * transforms per second per core :-)
      */
@@ -98,7 +98,7 @@ final class Dct {
 
     private Dct() {
     }
-    
+
     public static void scaleQuantizationVector(final float[] vector) {
         for (int x = 0; x < 8; x++) {
             vector[x] *= DCT_SCALING_FACTORS[x];
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
index 409c7004..0e29971c 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
index d89b67f7..b0691f64 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/YCbCrConverter.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/YCbCrConverter.java
index 0684d250..2ec8230d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/YCbCrConverter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/YCbCrConverter.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -98,7 +98,7 @@ final class YCbCrConverter {
             }
         }
     }
-    
+
     private YCbCrConverter() {
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/ZigZag.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/ZigZag.java
index 49c3173d..d80e33b5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/ZigZag.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/ZigZag.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ final class ZigZag {
 
     private ZigZag() {
     }
-    
+
     public static void zigZagToBlock(final int[] zz, final int[] block) {
         for (int i = 0; i < ZIG_ZAG.length; i++) {
             block[i] = zz[ZIG_ZAG[i]];
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/exif/ExifRewriter.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/exif/ExifRewriter.java
index 8e910e17..6db70a7e 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/exif/ExifRewriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/exif/ExifRewriter.java
@@ -49,7 +49,7 @@ import org.apache.commons.imaging.formats.tiff.write.TiffOutputSet;
  * <p>
  * <p>
  * See the source of the ExifMetadataUpdateExample class for example usage.
- * 
+ *
  * @see <a
  *      href="https://svn.apache.org/repos/asf/commons/proper/imaging/trunk/src/test/java/org/apache/commons/imaging/examples/WriteExifMetadataExample.java">org.apache.commons.imaging.examples.WriteExifMetadataExample</a>
  */
@@ -65,7 +65,7 @@ public class ExifRewriter extends BinaryFileParser {
     /**
      * Constructor.
      * <p>
-     * 
+     *
      * @param byteOrder
      *            byte order of EXIF segment.
      */
@@ -199,12 +199,12 @@ public class ExifRewriter extends BinaryFileParser {
      * Reads a Jpeg image, removes all EXIF metadata (by removing the APP1
      * segment), and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
      *            OutputStream to write the image to.
-     * 
+     *
      * @see java.io.File
      * @see java.io.OutputStream
      * @see java.io.File
@@ -220,7 +220,7 @@ public class ExifRewriter extends BinaryFileParser {
      * Reads a Jpeg image, removes all EXIF metadata (by removing the APP1
      * segment), and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -236,7 +236,7 @@ public class ExifRewriter extends BinaryFileParser {
      * Reads a Jpeg image, removes all EXIF metadata (by removing the APP1
      * segment), and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -252,7 +252,7 @@ public class ExifRewriter extends BinaryFileParser {
      * Reads a Jpeg image, removes all EXIF metadata (by removing the APP1
      * segment), and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
@@ -283,7 +283,7 @@ public class ExifRewriter extends BinaryFileParser {
      * update, which is a serious issue, since all EXIF data must fit in a
      * single APP1 segment of the Jpeg image.
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
@@ -309,7 +309,7 @@ public class ExifRewriter extends BinaryFileParser {
      * update, which is a serious issue, since all EXIF data must fit in a
      * single APP1 segment of the Jpeg image.
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -335,7 +335,7 @@ public class ExifRewriter extends BinaryFileParser {
      * update, which is a serious issue, since all EXIF data must fit in a
      * single APP1 segment of the Jpeg image.
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -361,7 +361,7 @@ public class ExifRewriter extends BinaryFileParser {
      * update, which is a serious issue, since all EXIF data must fit in a
      * single APP1 segment of the Jpeg image.
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
@@ -406,7 +406,7 @@ public class ExifRewriter extends BinaryFileParser {
      * entire EXIF segment, ignoring the possibility that it may be discarding
      * data it couldn't parse (such as Maker Notes).
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -429,7 +429,7 @@ public class ExifRewriter extends BinaryFileParser {
      * entire EXIF segment, ignoring the possibility that it may be discarding
      * data it couldn't parse (such as Maker Notes).
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -452,7 +452,7 @@ public class ExifRewriter extends BinaryFileParser {
      * entire EXIF segment, ignoring the possibility that it may be discarding
      * data it couldn't parse (such as Maker Notes).
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
@@ -475,7 +475,7 @@ public class ExifRewriter extends BinaryFileParser {
      * entire EXIF segment, ignoring the possibility that it may be discarding
      * data it couldn't parse (such as Maker Notes).
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcConstants.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcConstants.java
index 4768efae..ced4033f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcConstants.java
@@ -88,7 +88,7 @@ public final class IptcConstants {
     public static final int IPTC_RECORD_TAG_MARKER = 0x1c;
     public static final int IPTC_ENVELOPE_RECORD_NUMBER = 0x01;
     public static final int IPTC_APPLICATION_2_RECORD_NUMBER = 0x02;
-    
+
     private IptcConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcParser.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcParser.java
index b3308ce9..c5377ce2 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcParser.java
@@ -72,36 +72,36 @@ public class IptcParser extends BinaryFileParser {
      * In practice, App13 segments are only used for Photoshop/IPTC metadata.
      * However, we should not treat App13 signatures without Photoshop's
      * signature as Photoshop/IPTC segments.
-     * 
+     *
      * A Photoshop/IPTC App13 segment begins with the Photoshop Identification
      * string.
-     * 
+     *
      * There follows 0-N blocks (Photoshop calls them "Image Resource Blocks").
-     * 
+     *
      * Each block has the following structure:
-     * 
+     *
      * 1. 4-byte type. This is always "8BIM" for blocks in a Photoshop App13
      * segment. 2. 2-byte id. IPTC data is stored in blocks with id 0x0404, aka.
      * IPTC_NAA_RECORD_IMAGE_RESOURCE_ID 3. Block name as a Pascal String. This
      * is padded to have an even length. 4. 4-byte size (in bytes). 5. Block
      * data. This is also padded to have an even length.
-     * 
+     *
      * The block data consists of a 0-N records. A record has the following
      * structure:
-     * 
+     *
      * 1. 2-byte prefix. The value is always 0x1C02 2. 1-byte record type. The
      * record types are documented by the IPTC. See IptcConstants. 3. 2-byte
      * record size (in bytes). 4. Record data, "record size" bytes long.
-     * 
+     *
      * Record data (unlike block data) is NOT padded to have an even length.
-     * 
+     *
      * Record data, for IPTC record, should always be ISO-8859-1. But according
      * to SANSELAN-33, this isn't always the case.
-     * 
+     *
      * The exception is the first record in the block, which must always be a
      * record version record, whose value is a two-byte number; the value is
      * 0x02.
-     * 
+     *
      * Some IPTC blocks are missing this first "record version" record, so we
      * don't require it.
      */
@@ -256,20 +256,20 @@ public class IptcParser extends BinaryFileParser {
 
             // Note that these are unsigned quantities. Name is always an even
             // number of bytes (including the 1st byte, which is the size.)
-    
-            final byte[] idString = readBytes("", bis, 
+
+            final byte[] idString = readBytes("", bis,
                     JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.size(),
                     "App13 Segment missing identification string");
             if (!JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.equals(idString)) {
                 throw new ImageReadException("Not a Photoshop App13 Segment");
             }
-    
+
             // int index = PHOTOSHOP_IDENTIFICATION_STRING.length;
-    
+
             while (true) {
                 final int imageResourceBlockSignature;
                 try {
-                    imageResourceBlockSignature = read4Bytes("", bis, 
+                    imageResourceBlockSignature = read4Bytes("", bis,
                             "Image Resource Block missing identification string", APP13_BYTE_ORDER);
                 } catch (final IOException ioEx) {
                     break;
@@ -278,13 +278,13 @@ public class IptcParser extends BinaryFileParser {
                     throw new ImageReadException(
                             "Invalid Image Resource Block Signature");
                 }
-    
+
                 final int blockType = read2Bytes("", bis, "Image Resource Block missing type", APP13_BYTE_ORDER);
                 Debug.debug("blockType: " + blockType + " (0x" + Integer.toHexString(blockType) + ")");
-    
+
                 final int blockNameLength = readByte("Name length", bis, "Image Resource Block missing name length");
                 if (blockNameLength > 0) {
-                    Debug.debug("blockNameLength: " + blockNameLength + " (0x" 
+                    Debug.debug("blockNameLength: " + blockNameLength + " (0x"
                             + Integer.toHexString(blockNameLength) + ")");
                 }
                 byte[] blockNameBytes;
@@ -301,15 +301,15 @@ public class IptcParser extends BinaryFileParser {
                         }
                         break;
                     }
-    
+
                     if (blockNameLength % 2 == 0) {
                         readByte("Padding byte", bis, "Image Resource Block missing padding byte");
                     }
                 }
-    
+
                 final int blockSize = read4Bytes("", bis, "Image Resource Block missing size", APP13_BYTE_ORDER);
                 Debug.debug("blockSize: " + blockSize + " (0x" + Integer.toHexString(blockSize) + ")");
-    
+
                 /*
                  * doesn't catch cases where blocksize is invalid but is still less
                  * than bytes.length but will at least prevent OutOfMemory errors
@@ -317,7 +317,7 @@ public class IptcParser extends BinaryFileParser {
                 if (blockSize > bytes.length) {
                     throw new ImageReadException("Invalid Block Size : " + blockSize + " > " + bytes.length);
                 }
-    
+
                 final byte[] blockData;
                 try {
                     blockData = readBytes("", bis, blockSize, "Invalid Image Resource Block data");
@@ -327,14 +327,14 @@ public class IptcParser extends BinaryFileParser {
                     }
                     break;
                 }
-    
+
                 blocks.add(new IptcBlock(blockType, blockNameBytes, blockData));
-    
+
                 if ((blockSize % 2) != 0) {
                     readByte("Padding byte", bis, "Image Resource Block missing padding byte");
                 }
             }
-    
+
             return blocks;
         }
     }
@@ -388,7 +388,7 @@ public class IptcParser extends BinaryFileParser {
         byte[] blockData;
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         try (BinaryOutputStream bos = new BinaryOutputStream(baos, getByteOrder())) {
-    
+
             // first, right record version record
             bos.write(IptcConstants.IPTC_RECORD_TAG_MARKER);
             bos.write(IptcConstants.IPTC_APPLICATION_2_RECORD_NUMBER);
@@ -396,10 +396,10 @@ public class IptcParser extends BinaryFileParser {
                                                       // type.
             bos.write2Bytes(2); // record version record size
             bos.write2Bytes(2); // record version value
-    
+
             // make a copy of the list.
             elements = new ArrayList<>(elements);
-    
+
             // sort the list. Records must be in numerical order.
             final Comparator<IptcRecord> comparator = new Comparator<IptcRecord>() {
                 @Override
@@ -409,7 +409,7 @@ public class IptcParser extends BinaryFileParser {
             };
             Collections.sort(elements, comparator);
             // TODO: make sure order right
-    
+
             // write the list.
             for (final IptcRecord element : elements) {
                 if (element.iptcType == IptcTypes.RECORD_VERSION) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypeLookup.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypeLookup.java
index 12c057d0..8aa73c0a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypeLookup.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypeLookup.java
@@ -30,7 +30,7 @@ public final class IptcTypeLookup {
 
     private IptcTypeLookup() {
     }
-    
+
     public static IptcType getIptcType(final int type) {
         if (!IPTC_TYPE_MAP.containsKey(type)) {
             return IptcTypes.getUnknown(type);
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypes.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypes.java
index dd055eee..324d931e 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypes.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcTypes.java
@@ -134,17 +134,17 @@ public enum IptcTypes implements IptcType {
 
     public final int type;
     public final String name;
-    
+
     IptcTypes(final int type, final String name) {
         this.type = type;
         this.name = name;
     }
-    
+
     @Override
     public String getName() {
         return name;
     }
-    
+
     @Override
     public int getType() {
         return type;
@@ -154,19 +154,19 @@ public enum IptcTypes implements IptcType {
     public String toString() {
         return name + " (" + type + ")";
     }
-    
+
     public static IptcType getUnknown(final int type) {
         return new IptcType() {
             @Override
             public String getName() {
                 return "Unknown";
             }
-            
+
             @Override
             public int getType() {
                 return type;
             }
-            
+
             @Override
             public String toString() {
                 return "Unknown (" + type + ")";
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/JpegIptcRewriter.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/JpegIptcRewriter.java
index bd522152..a064578e 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/JpegIptcRewriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/JpegIptcRewriter.java
@@ -45,12 +45,12 @@ public class JpegIptcRewriter extends JpegRewriter {
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
      *            OutputStream to write the image to.
-     * 
+     *
      * @see java.io.File
      * @see java.io.OutputStream
      */
@@ -58,20 +58,20 @@ public class JpegIptcRewriter extends JpegRewriter {
             throws ImageReadException, IOException, ImageWriteException {
         removeIPTC(src, os, false);
     }
-    
+
     /**
      * Reads a Jpeg image, removes all IPTC data from the App13 segment but
      * leaves the other data in that segment (if present) unchanged (unless
      * removeSegment is true) and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
      *            OutputStream to write the image to.
      * @param removeSegment
      *            Remove the App13 segment.
-     * 
+     *
      * @see java.io.File
      * @see java.io.OutputStream
      */
@@ -86,7 +86,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -96,13 +96,13 @@ public class JpegIptcRewriter extends JpegRewriter {
             throws ImageReadException, IOException, ImageWriteException {
         removeIPTC(src, os, false);
     }
-    
+
     /**
      * Reads a Jpeg image, removes all IPTC data from the App13 segment but
      * leaves the other data in that segment (if present) unchanged (unless
      * removeSegment is true) and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -121,7 +121,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -131,13 +131,13 @@ public class JpegIptcRewriter extends JpegRewriter {
             throws ImageReadException, IOException, ImageWriteException {
         removeIPTC(src, os, false);
     }
-    
+
     /**
      * Reads a Jpeg image, removes all IPTC data from the App13 segment but
      * leaves the other data in that segment (if present) unchanged (unless
      * removeSegment is true) and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -156,7 +156,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
@@ -166,13 +166,13 @@ public class JpegIptcRewriter extends JpegRewriter {
             throws ImageReadException, IOException, ImageWriteException {
         removeIPTC(byteSource, os, false);
     }
-    
+
     /**
      * Reads a Jpeg image, removes all IPTC data from the App13 segment but
      * leaves the other data in that segment (if present) unchanged (unless
      * removeSegment is true) and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
@@ -211,7 +211,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * Reads a Jpeg image, replaces the IPTC data in the App13 segment but
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -230,7 +230,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * Reads a Jpeg image, replaces the IPTC data in the App13 segment but
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -249,7 +249,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * Reads a Jpeg image, replaces the IPTC data in the App13 segment but
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
@@ -267,7 +267,7 @@ public class JpegIptcRewriter extends JpegRewriter {
      * Reads a Jpeg image, replaces the IPTC data in the App13 segment but
      * leaves the other data in that segment (if present) unchanged and writes
      * the result to a stream.
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/App14Segment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/App14Segment.java
index b5c7a317..a859bd11 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/App14Segment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/App14Segment.java
@@ -31,7 +31,7 @@ public class App14Segment extends AppnSegment {
     public static final int ADOBE_COLOR_TRANSFORM_UNKNOWN = 0;
     public static final int ADOBE_COLOR_TRANSFORM_YCbCr = 1;
     public static final int ADOBE_COLOR_TRANSFORM_YCCK = 2;
-    
+
     static {
         ADOBE_PREFIX = "Adobe".getBytes(StandardCharsets.US_ASCII);
     }
@@ -39,7 +39,7 @@ public class App14Segment extends AppnSegment {
     public App14Segment(final int marker, final byte[] segmentData) throws IOException {
         this(marker, segmentData.length, new ByteArrayInputStream(segmentData));
     }
-    
+
     public App14Segment(final int marker, final int markerLength, final InputStream is) throws IOException {
         super(marker, markerLength, is);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/ComSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/ComSegment.java
index 5665f67d..d897eee3 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/ComSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/ComSegment.java
@@ -28,7 +28,7 @@ public class ComSegment extends GenericSegment {
     public ComSegment(final int marker, final int markerLength, final InputStream is) throws IOException {
         super(marker, markerLength, is);
     }
-    
+
     /**
      * Returns a copy of the comment.
      * @return a copy of the comment's bytes
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DhtSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DhtSegment.java
index 8763aa8a..b12c8fc2 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DhtSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DhtSegment.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DqtSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DqtSegment.java
index 3833190e..1aaf270e 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DqtSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/DqtSegment.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/GenericSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/GenericSegment.java
index e557f712..2b64d00f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/GenericSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/GenericSegment.java
@@ -62,7 +62,7 @@ public abstract class GenericSegment extends Segment {
     /**
      * Returns a specific byte of the segment's contents,
      * excluding the marker and length bytes at
-     * the beginning. 
+     * the beginning.
      * @see GenericSegment#getSegmentData()
      * @return the bye in the segment's contents
      */
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/JfifSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/JfifSegment.java
index a8f30043..bd3a4a27 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/JfifSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/JfifSegment.java
@@ -46,7 +46,7 @@ public class JfifSegment extends Segment {
         this(marker, segmentData.length, new ByteArrayInputStream(segmentData));
     }
 
-    public JfifSegment(final int marker, final int markerLength, final InputStream is) 
+    public JfifSegment(final int marker, final int markerLength, final InputStream is)
             throws ImageReadException, IOException {
         super(marker, markerLength);
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SofnSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SofnSegment.java
index 23c6cd13..4b133123 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SofnSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SofnSegment.java
@@ -84,7 +84,7 @@ public class SofnSegment extends Segment {
                     quantTabDestSelector);
         }
     }
-    
+
     /**
      * Returns a copy of all the components.
      * @return the components
@@ -92,7 +92,7 @@ public class SofnSegment extends Segment {
     public Component[] getComponents() {
         return components.clone();
     }
-    
+
     /**
      * Returns the component at the specified index.
      * @param index the array index
@@ -101,7 +101,7 @@ public class SofnSegment extends Segment {
     public Component getComponents(final int index) {
         return components[index];
     }
-    
+
 
     @Override
     public String getDescription() {
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SosSegment.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SosSegment.java
index 31421b80..29f27420 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SosSegment.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/segments/SosSegment.java
@@ -97,7 +97,7 @@ public class SosSegment extends Segment {
         successiveApproximationBitHigh = (successiveApproximationBitPosition >> 4) & 0xf;
         successiveApproximationBitLow = successiveApproximationBitPosition & 0xf;
     }
-    
+
     /**
      * Returns a copy of all the components.
      * @return all the components
@@ -105,7 +105,7 @@ public class SosSegment extends Segment {
     public Component[] getComponents() {
         return components.clone();
     }
-    
+
     /**
      * Return a component at the specified index.
      * @param index the component index
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegXmpRewriter.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegXmpRewriter.java
index d2a67ebe..c22f641f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegXmpRewriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/xmp/JpegXmpRewriter.java
@@ -42,12 +42,12 @@ public class JpegXmpRewriter extends JpegRewriter {
      * Reads a Jpeg image, removes all XMP XML (by removing the APP1 segment),
      * and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
      *            OutputStream to write the image to.
-     * 
+     *
      * @see java.io.File
      * @see java.io.OutputStream
      */
@@ -61,7 +61,7 @@ public class JpegXmpRewriter extends JpegRewriter {
      * Reads a Jpeg image, removes all XMP XML (by removing the APP1 segment),
      * and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -77,7 +77,7 @@ public class JpegXmpRewriter extends JpegRewriter {
      * Reads a Jpeg image, removes all XMP XML (by removing the APP1 segment),
      * and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -93,7 +93,7 @@ public class JpegXmpRewriter extends JpegRewriter {
      * Reads a Jpeg image, removes all XMP XML (by removing the APP1 segment),
      * and writes the result to a stream.
      * <p>
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
@@ -110,7 +110,7 @@ public class JpegXmpRewriter extends JpegRewriter {
     /**
      * Reads a Jpeg image, replaces the XMP XML and writes the result to a
      * stream.
-     * 
+     *
      * @param src
      *            Byte array containing Jpeg image data.
      * @param os
@@ -127,7 +127,7 @@ public class JpegXmpRewriter extends JpegRewriter {
     /**
      * Reads a Jpeg image, replaces the XMP XML and writes the result to a
      * stream.
-     * 
+     *
      * @param src
      *            InputStream containing Jpeg image data.
      * @param os
@@ -144,7 +144,7 @@ public class JpegXmpRewriter extends JpegRewriter {
     /**
      * Reads a Jpeg image, replaces the XMP XML and writes the result to a
      * stream.
-     * 
+     *
      * @param src
      *            Image file.
      * @param os
@@ -161,7 +161,7 @@ public class JpegXmpRewriter extends JpegRewriter {
     /**
      * Reads a Jpeg image, replaces the XMP XML and writes the result to a
      * stream.
-     * 
+     *
      * @param byteSource
      *            ByteSource containing Jpeg image data.
      * @param os
diff --git a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxConstants.java b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxConstants.java
index a491786f..7884153f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxConstants.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,7 +23,7 @@ public final class PcxConstants {
     public static final String PARAM_KEY_PCX_BIT_DEPTH = "PCX_BIT_DEPTH";
 
     public static final String PARAM_KEY_PCX_PLANES = "PCX_PLANES";
-    
+
     private PcxConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxImageParser.java b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxImageParser.java
index 4a26e527..4be8d6c4 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxImageParser.java
@@ -498,7 +498,7 @@ public class PcxImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxWriter.java b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxWriter.java
index f782fe74..fb5a92da 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pcx/PcxWriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pcx/PcxWriter.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -78,7 +78,7 @@ class PcxWriter {
                 bitDepthWanted = ((Number) value).intValue();
             }
         }
-        
+
         if (params.containsKey(PcxConstants.PARAM_KEY_PCX_PLANES)) {
             final Object value = params.remove(PcxConstants.PARAM_KEY_PCX_PLANES);
             if (value != null) {
@@ -110,7 +110,7 @@ class PcxWriter {
             throw new ImageWriteException("Unknown parameter: " + firstKey);
         }
     }
-    
+
     public void writeImage(final BufferedImage src, final OutputStream os)
             throws ImageWriteException, IOException {
         final PaletteFactory paletteFactory = new PaletteFactory();
@@ -171,13 +171,13 @@ class PcxWriter {
                 planes = 2;
             }
         }
-        
+
         int bytesPerLine = (bitDepth * src.getWidth() + 7) / 8;
         if ((bytesPerLine % 2) != 0) {
             // must be even:
             bytesPerLine++;
         }
-        
+
         final byte[] palette16 = new byte[16 * 3];
         for (int i = 0; i < 16; i++) {
             int rgb;
@@ -216,7 +216,7 @@ class PcxWriter {
         } else {
             writePixels(src, bitDepth, planes, bytesPerLine, palette, bos);
         }
-        
+
         if (bitDepth == 8 && planes == 1) {
             // 256 color palette
             bos.write(12);
@@ -233,7 +233,7 @@ class PcxWriter {
             }
         }
     }
-    
+
     private void writePixels(final BufferedImage src, final int bitDepth, final int planes,
             final int bytesPerLine, final SimplePalette palette, final BinaryOutputStream bos) throws IOException, ImageWriteException {
         final byte[] plane0 = new byte[bytesPerLine];
@@ -241,12 +241,12 @@ class PcxWriter {
         final byte[] plane2 = new byte[bytesPerLine];
         final byte[] plane3 = new byte[bytesPerLine];
         final byte[][] allPlanes = { plane0, plane1, plane2, plane3 };
-        
+
         for (int y = 0; y < src.getHeight(); y++) {
             for (int i = 0; i < planes; i++) {
                 Arrays.fill(allPlanes[i], (byte)0);
             }
-            
+
             if (bitDepth == 1 && planes == 1) {
                 for (int x = 0; x < src.getWidth(); x++) {
                     final int rgb = 0xffffff & src.getRGB(x, y);
@@ -308,7 +308,7 @@ class PcxWriter {
                     plane2[x] = (byte) argb;
                 }
             }
-            
+
             for (int i = 0; i < planes; i++) {
                 rleWriter.write(bos, allPlanes[i]);
             }
@@ -318,7 +318,7 @@ class PcxWriter {
 
     private void writePixels32(final BufferedImage src, final int bytesPerLine,
             final BinaryOutputStream bos) throws IOException, ImageWriteException {
-        
+
         final int[] rgbs = new int[src.getWidth()];
         final byte[] plane = new byte[4 * bytesPerLine];
         for (int y = 0; y < src.getHeight(); y++) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/pcx/RleReader.java b/src/main/java/org/apache/commons/imaging/formats/pcx/RleReader.java
index 735a2052..1b8a063d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pcx/RleReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pcx/RleReader.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,17 +26,17 @@ class RleReader {
     private final boolean isCompressed;
     private int count;
     private byte sample;
-    
+
     RleReader(final boolean isCompressed) {
         this.isCompressed = isCompressed;
     }
-    
+
     void read(final InputStream is, final byte[] samples) throws IOException, ImageReadException {
         if (isCompressed) {
             final int prefill = Math.min(count, samples.length);
             Arrays.fill(samples, 0, prefill, sample);
             count -= prefill;
-            
+
             for (int bytesRead = prefill; bytesRead < samples.length;) {
                 final byte b = BinaryFunctions.readByte("RleByte", is, "Error reading image data");
                 if ((b & 0xc0) == 0xc0) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/pcx/RleWriter.java b/src/main/java/org/apache/commons/imaging/formats/pcx/RleWriter.java
index ce4e3eab..afb9b1b5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pcx/RleWriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pcx/RleWriter.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,7 +28,7 @@ class RleWriter {
     RleWriter(final boolean isCompressed) {
         this.isCompressed = isCompressed;
     }
-    
+
     void write(final BinaryOutputStream bos, final byte[] samples)
             throws IOException, ImageWriteException {
         if (isCompressed) {
@@ -54,7 +54,7 @@ class RleWriter {
             bos.write(samples);
         }
     }
-    
+
     void flush(final BinaryOutputStream bos) throws IOException {
         if (repeatCount > 0) {
             if (repeatCount == 1 && (previousByte & 0xc0) != 0xc0) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/ChunkType.java b/src/main/java/org/apache/commons/imaging/formats/png/ChunkType.java
index 1346808c..ef8f8731 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/ChunkType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/ChunkType.java
@@ -22,7 +22,7 @@ import org.apache.commons.imaging.common.BinaryFunctions;
 
 /**
  * Type of a PNG chunk.
- * 
+ *
  * @see <a href="http://www.w3.org/TR/PNG/#11Chunks">Portable Network Graphics Specification - Chunk specifications</a>
  */
 public enum ChunkType {
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/FilterType.java b/src/main/java/org/apache/commons/imaging/formats/png/FilterType.java
index 2dd9f7b2..3132d94d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/FilterType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/FilterType.java
@@ -18,7 +18,7 @@ package org.apache.commons.imaging.formats.png;
 
 /**
  * Filter types for filter method 0.
- * 
+ *
  * @see <a href="http://www.w3.org/TR/PNG/#9Filters">Portable Network Graphics Specification - Filtering</a>
  */
 enum FilterType {
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/InterlaceMethod.java b/src/main/java/org/apache/commons/imaging/formats/png/InterlaceMethod.java
index c25cdd9a..9bc4ec0b 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/InterlaceMethod.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/InterlaceMethod.java
@@ -18,7 +18,7 @@ package org.apache.commons.imaging.formats.png;
 
 /**
  * Interlace methods.
- * 
+ *
  * @see <a href="http://www.w3.org/TR/PNG/#8Interlace">Portable Network Graphics Specification - Interlacing and pass extraction</a>
  */
 public enum InterlaceMethod {
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngColorType.java b/src/main/java/org/apache/commons/imaging/formats/png/PngColorType.java
index a7b7b77d..117fa0b2 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngColorType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngColorType.java
@@ -69,7 +69,7 @@ public enum PngColorType {
                 return type;
             }
         }
-        
+
         return null;
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java b/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
index a17e1b31..e7c68f34 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
@@ -61,7 +61,7 @@ public final class PngConstants {
 
     /**
      * Parameter key.
-     * 
+     *
      * Only used when writing Png images.
      * <p>
      * Valid values: a list of WriteTexts.
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java b/src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java
index 7952437a..07ae14da 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java
@@ -122,7 +122,7 @@ public class PngImageParser extends ImageParser {
         return chunkTypes;
     }
 
-    public boolean hasChunkType(final ByteSource byteSource, final ChunkType chunkType) 
+    public boolean hasChunkType(final ByteSource byteSource, final ChunkType chunkType)
             throws ImageReadException, IOException {
         try (InputStream is = byteSource.getInputStream()) {
             readSignature(is);
@@ -196,7 +196,7 @@ public class PngImageParser extends ImageParser {
                     result.add(new PngChunkGama(length, chunkType, crc, bytes));
                 } else if (chunkType == ChunkType.iTXt.value) {
                     result.add(new PngChunkItxt(length, chunkType, crc, bytes));
-                } else { 
+                } else {
                     result.add(new PngChunk(length, chunkType, crc, bytes));
                 }
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngText.java b/src/main/java/org/apache/commons/imaging/formats/png/PngText.java
index d3fb00c6..45390b38 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngText.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngText.java
@@ -19,7 +19,7 @@ package org.apache.commons.imaging.formats.png;
 public abstract class PngText {
     public final String keyword;
     public final String text;
-    
+
     public PngText(final String keyword, final String text) {
         this.keyword = keyword;
         this.text = text;
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java b/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
index b7d07541..94792b0f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
@@ -50,7 +50,7 @@ class PngWriter {
      4. Miscellaneous information: bKGD, hIST, pHYs, sPLT (see 11.3.5: Miscellaneous information).
      5. Time information: tIME (see 11.3.6: Time stamp information).
     */
-    
+
     private void writeInt(final OutputStream os, final int value) throws IOException {
         os.write(0xff & (value >> 24));
         os.write(0xff & (value >> 16));
@@ -144,7 +144,7 @@ class PngWriter {
         writeChunk(os, ChunkType.iTXt, baos.toByteArray());
     }
 
-    private void writeChunkzTXt(final OutputStream os, final PngText.Ztxt text) 
+    private void writeChunkzTXt(final OutputStream os, final PngText.Ztxt text)
             throws IOException, ImageWriteException {
         if (!isValidISO_8859_1(text.keyword)) {
             throw new ImageWriteException("Png zTXt chunk keyword is not ISO-8859-1: " + text.keyword);
@@ -198,12 +198,12 @@ class PngWriter {
             return baos.toByteArray();
         }
     }
-    
+
     private boolean isValidISO_8859_1(final String s) {
         final String roundtrip = new String(s.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.ISO_8859_1);
         return s.equals(roundtrip);
     }
-    
+
     private void writeChunkXmpiTXt(final OutputStream os, final String xmpXml)
             throws IOException {
 
@@ -247,11 +247,11 @@ class PngWriter {
 
     private void writeChunkTRNS(final OutputStream os, final Palette palette) throws IOException {
         final byte[] bytes = new byte[palette.length()];
-        
+
         for (int i = 0; i < bytes.length; i++) {
             bytes[i] = (byte) (0xff & (palette.getEntry(i) >> 24));
         }
-        
+
         writeChunk(os, ChunkType.tRNS, bytes);
     }
 
@@ -309,11 +309,11 @@ class PngWriter {
     /// Wraps a palette by adding a single transparent entry at index 0.
     private static class TransparentPalette implements Palette {
         private final Palette palette;
-        
+
         TransparentPalette(final Palette palette) {
             this.palette = palette;
         }
-        
+
         @Override
         public int getEntry(final int index) {
             if (index == 0) {
@@ -321,12 +321,12 @@ class PngWriter {
             }
             return palette.getEntry(index - 1);
         }
-        
+
         @Override
         public int length() {
             return 1 + palette.length();
         }
-        
+
         @Override
         public int getPaletteIndex(final int rgb) throws ImageWriteException {
             if (rgb == 0x00000000) {
@@ -480,7 +480,7 @@ class PngWriter {
 
             if (hasAlpha) {
                 palette = new TransparentPalette(palette);
-                writeChunkPLTE(os, palette);                
+                writeChunkPLTE(os, palette);
                 writeChunkTRNS(os, new SimplePalette(new int[] { 0x00000000 }));
             } else {
                 writeChunkPLTE(os, palette);
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/ScanExpediter.java b/src/main/java/org/apache/commons/imaging/formats/png/ScanExpediter.java
index df119d17..97a281ec 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/ScanExpediter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/ScanExpediter.java
@@ -81,7 +81,7 @@ abstract class ScanExpediter {
 
     public abstract void drive() throws ImageReadException, IOException;
 
-    int getRGB(final BitParser bitParser, final int pixelIndexInScanline) 
+    int getRGB(final BitParser bitParser, final int pixelIndexInScanline)
             throws ImageReadException, IOException {
 
         switch (pngColorType) {
@@ -184,7 +184,7 @@ abstract class ScanExpediter {
             case PAETH:
                 return new ScanlineFilterPaeth(bytesPerPixel);
         }
-        
+
         return null;
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/FileInfo.java b/src/main/java/org/apache/commons/imaging/formats/pnm/FileInfo.java
index 8c5099b3..90b6711f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/FileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/FileInfo.java
@@ -35,7 +35,7 @@ abstract class FileInfo {
     }
 
     abstract boolean hasAlpha();
-    
+
     abstract int getNumComponents();
 
     abstract int getBitDepth();
@@ -55,7 +55,7 @@ abstract class FileInfo {
     void newline() {
         // do nothing by default.
     }
-    
+
     static int readSample(final InputStream is, final int bytesPerSample) throws IOException {
         int sample = 0;
         for (int i = 0; i < bytesPerSample; i++) {
@@ -68,7 +68,7 @@ abstract class FileInfo {
         }
         return sample;
     }
-    
+
     static int scaleSample(int sample, final float scale, final int max) throws IOException {
         if (sample < 0) {
             // Even netpbm tools break for files like this
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PamFileInfo.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PamFileInfo.java
index d931a6e5..a8e1dee6 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PamFileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PamFileInfo.java
@@ -29,7 +29,7 @@ class PamFileInfo extends FileInfo {
     private final int depth;
     private final int maxval;
     private final float scale;
-    private final int bytesPerSample; 
+    private final int bytesPerSample;
     private final boolean hasAlpha;
     private final TupleReader tupleReader;
 
@@ -62,12 +62,12 @@ class PamFileInfo extends FileInfo {
             throw new ImageReadException("Unknown PAM tupletype '" + tupleType + "'");
         }
     }
-    
+
     @Override
     public boolean hasAlpha() {
         return hasAlpha;
     }
-    
+
     @Override
     public int getNumComponents() {
         return depth;
@@ -97,7 +97,7 @@ class PamFileInfo extends FileInfo {
     public ImageInfo.ColorType getColorType() {
         return tupleReader.getColorType();
     }
-    
+
     @Override
     public int getRGB(final WhiteSpaceReader wsr) throws IOException {
         throw new UnsupportedOperationException("PAM files are only ever binary");
@@ -112,31 +112,31 @@ class PamFileInfo extends FileInfo {
         public abstract ImageInfo.ColorType getColorType();
         public abstract int getRGB(InputStream is) throws IOException;
     }
-    
+
     private class GrayscaleTupleReader extends TupleReader {
         private final ImageInfo.ColorType colorType;
-        
+
         public GrayscaleTupleReader(final ImageInfo.ColorType colorType) {
             this.colorType = colorType;
         }
-        
+
         @Override
         public ImageInfo.ColorType getColorType() {
             return colorType;
         }
-        
+
         @Override
         public int getRGB(final InputStream is) throws IOException {
             int sample = readSample(is, bytesPerSample);
             sample = scaleSample(sample, scale, maxval);
-            
+
             int alpha = 0xff;
             if (hasAlpha) {
                 alpha = readSample(is, bytesPerSample);
                 alpha = scaleSample(alpha, scale, maxval);
             }
 
-            return ((0xff & alpha)  << 24) 
+            return ((0xff & alpha)  << 24)
                  | ((0xff & sample) << 16)
                  | ((0xff & sample) << 8)
                  | ((0xff & sample) << 0);
@@ -148,7 +148,7 @@ class PamFileInfo extends FileInfo {
         public ImageInfo.ColorType getColorType() {
             return ImageInfo.ColorType.RGB;
         }
-        
+
         @Override
         public int getRGB(final InputStream is) throws IOException {
             int red = readSample(is, bytesPerSample);
@@ -165,7 +165,7 @@ class PamFileInfo extends FileInfo {
                 alpha = scaleSample(alpha, scale, maxval);
             }
 
-            return ((0xff & alpha) << 24) 
+            return ((0xff & alpha) << 24)
                  | ((0xff & red)   << 16)
                  | ((0xff & green) << 8)
                  | ((0xff & blue)  << 0);
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PamWriter.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PamWriter.java
index 31429aa6..7ed25cbd 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PamWriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PamWriter.java
@@ -34,7 +34,7 @@ class PamWriter implements PnmWriter {
         os.write(PnmConstants.PNM_PREFIX_BYTE);
         os.write(PnmConstants.PAM_RAW_CODE);
         os.write(PnmConstants.PNM_NEWLINE);
-        
+
         final int width = src.getWidth();
         final int height = src.getHeight();
 
@@ -43,19 +43,19 @@ class PamWriter implements PnmWriter {
 
         os.write(("HEIGHT " + height).getBytes(StandardCharsets.US_ASCII));
         os.write(PnmConstants.PNM_NEWLINE);
-        
+
         os.write(("DEPTH 4").getBytes(StandardCharsets.US_ASCII));
         os.write(PnmConstants.PNM_NEWLINE);
-        
+
         os.write(("MAXVAL 255").getBytes(StandardCharsets.US_ASCII));
         os.write(PnmConstants.PNM_NEWLINE);
 
         os.write(("TUPLTYPE RGB_ALPHA").getBytes(StandardCharsets.US_ASCII));
         os.write(PnmConstants.PNM_NEWLINE);
-        
+
         os.write(("ENDHDR").getBytes(StandardCharsets.US_ASCII));
         os.write(PnmConstants.PNM_NEWLINE);
-        
+
         for (int y = 0; y < height; y++) {
             for (int x = 0; x < width; x++) {
                 final int argb = src.getRGB(x, y);
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PbmFileInfo.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PbmFileInfo.java
index 8cc29195..36ef6eb6 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PbmFileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PbmFileInfo.java
@@ -30,7 +30,7 @@ class PbmFileInfo extends FileInfo {
     PbmFileInfo(final int width, final int height, final boolean rawbits) {
         super(width, height, rawbits);
     }
-    
+
     @Override
     public boolean hasAlpha() {
         return false;
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PgmFileInfo.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PgmFileInfo.java
index 70cd7a54..b4a7bfe5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PgmFileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PgmFileInfo.java
@@ -27,7 +27,7 @@ import org.apache.commons.imaging.ImageReadException;
 class PgmFileInfo extends FileInfo {
     private final int max;
     private final float scale;
-    private final int bytesPerSample; 
+    private final int bytesPerSample;
 
     public PgmFileInfo(final int width, final int height, final boolean rawbits, final int max) throws ImageReadException {
         super(width, height, rawbits);
@@ -46,7 +46,7 @@ class PgmFileInfo extends FileInfo {
         }
         this.max = max;
     }
-    
+
     @Override
     public boolean hasAlpha() {
         return false;
@@ -85,14 +85,14 @@ class PgmFileInfo extends FileInfo {
     @Override
     public int getRGB(final InputStream is) throws IOException {
         int sample = readSample(is, bytesPerSample);
-        
+
         sample = scaleSample(sample, scale, max);
 
         final int alpha = 0xff;
 
-        return ((0xff & alpha)  << 24) 
-             | ((0xff & sample) << 16) 
-             | ((0xff & sample) << 8) 
+        return ((0xff & alpha)  << 24)
+             | ((0xff & sample) << 16)
+             | ((0xff & sample) << 8)
              | ((0xff & sample) << 0);
     }
 
@@ -101,12 +101,12 @@ class PgmFileInfo extends FileInfo {
         int sample = Integer.parseInt(wsr.readtoWhiteSpace());
 
         sample = scaleSample(sample, scale, max);
-        
+
         final int alpha = 0xff;
 
-        return ((0xff & alpha)  << 24) 
-             | ((0xff & sample) << 16) 
-             | ((0xff & sample) << 8) 
+        return ((0xff & alpha)  << 24)
+             | ((0xff & sample) << 16)
+             | ((0xff & sample) << 8)
              | ((0xff & sample) << 0);
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PnmImageParser.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PnmImageParser.java
index 08893638..ca3d9465 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PnmImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PnmImageParser.java
@@ -90,16 +90,16 @@ public class PnmImageParser extends ImageParser {
         if (identifier1 != PnmConstants.PNM_PREFIX_BYTE) {
             throw new ImageReadException("PNM file has invalid prefix byte 1");
         }
-        
+
         final WhiteSpaceReader wsr = new WhiteSpaceReader(is);
-        
+
         if (identifier2 == PnmConstants.PBM_TEXT_CODE
                 || identifier2 == PnmConstants.PBM_RAW_CODE
                 || identifier2 == PnmConstants.PGM_TEXT_CODE
                 || identifier2 == PnmConstants.PGM_RAW_CODE
                 || identifier2 == PnmConstants.PPM_TEXT_CODE
                 || identifier2 == PnmConstants.PPM_RAW_CODE) {
-            
+
             final int width;
             try {
               width = Integer.parseInt(wsr.readtoWhiteSpace());
@@ -112,7 +112,7 @@ public class PnmImageParser extends ImageParser {
             } catch (final NumberFormatException e) {
               throw new ImageReadException("Invalid height specified." , e);
             }
-    
+
             if (identifier2 == PnmConstants.PBM_TEXT_CODE) {
                 return new PbmFileInfo(width, height, false);
             } else if (identifier2 == PnmConstants.PBM_RAW_CODE) {
@@ -143,7 +143,7 @@ public class PnmImageParser extends ImageParser {
             boolean seenMaxVal = false;
             final StringBuilder tupleType = new StringBuilder();
             boolean seenTupleType = false;
-            
+
             // Advance to next line
             wsr.readLine();
             String line;
@@ -190,7 +190,7 @@ public class PnmImageParser extends ImageParser {
                     throw new ImageReadException("Invalid PAM file header type " + type);
                 }
             }
-            
+
             if (!seenWidth) {
                 throw new ImageReadException("PAM header has no WIDTH");
             } else if (!seenHeight) {
@@ -202,7 +202,7 @@ public class PnmImageParser extends ImageParser {
             } else if (!seenTupleType) {
                 throw new ImageReadException("PAM header has no TUPLTYPE");
             }
-            
+
             return new PamFileInfo(width, height, depth, maxVal, tupleType.toString());
         } else {
             throw new ImageReadException("PNM file has invalid prefix byte 2");
@@ -321,7 +321,7 @@ public class PnmImageParser extends ImageParser {
             throws ImageWriteException, IOException {
         PnmWriter writer = null;
         boolean useRawbits = true;
-        
+
         if (params != null) {
             final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS);
             if (useRawbitsParam != null) {
@@ -338,7 +338,7 @@ public class PnmImageParser extends ImageParser {
                     writer = new PgmWriter(useRawbits);
                 } else if (subtype.equals(ImageFormats.PPM)) {
                     writer = new PpmWriter(useRawbits);
-                } else if (subtype.equals(ImageFormats.PAM)) { 
+                } else if (subtype.equals(ImageFormats.PAM)) {
                     writer = new PamWriter();
                 }
             }
@@ -348,7 +348,7 @@ public class PnmImageParser extends ImageParser {
             final boolean hasAlpha = new PaletteFactory().hasTransparency(src);
             if (hasAlpha) {
                 writer = new PamWriter();
-            } else {   
+            } else {
                 writer = new PpmWriter(useRawbits);
             }
         }
@@ -369,7 +369,7 @@ public class PnmImageParser extends ImageParser {
         if (params.containsKey(PARAM_KEY_PNM_RAWBITS)) {
             params.remove(PARAM_KEY_PNM_RAWBITS);
         }
-        
+
         if (!params.isEmpty()) {
             final Object firstKey = params.keySet().iterator().next();
             throw new ImageWriteException("Unknown parameter: " + firstKey);
@@ -381,7 +381,7 @@ public class PnmImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/PpmFileInfo.java b/src/main/java/org/apache/commons/imaging/formats/pnm/PpmFileInfo.java
index 4b704e59..24ea26e8 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/PpmFileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/PpmFileInfo.java
@@ -27,7 +27,7 @@ import org.apache.commons.imaging.ImageReadException;
 class PpmFileInfo extends FileInfo {
     private final int max;
     private final float scale;
-    private final int bytesPerSample; 
+    private final int bytesPerSample;
 
     public PpmFileInfo(final int width, final int height, final boolean rawbits, final int max) throws ImageReadException {
         super(width, height, rawbits);
@@ -44,7 +44,7 @@ class PpmFileInfo extends FileInfo {
         }
         this.max = max;
     }
-    
+
     @Override
     public boolean hasAlpha() {
         return false;
diff --git a/src/main/java/org/apache/commons/imaging/formats/pnm/WhiteSpaceReader.java b/src/main/java/org/apache/commons/imaging/formats/pnm/WhiteSpaceReader.java
index d6d01ebd..a4df343d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/pnm/WhiteSpaceReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/pnm/WhiteSpaceReader.java
@@ -61,7 +61,7 @@ class WhiteSpaceReader {
 
         return buffer.toString();
     }
-    
+
     public String readLine() throws IOException {
         final StringBuilder buffer = new StringBuilder();
         for (char c = read(); (c != '\n') && (c != '\r'); c = read()) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/psd/PsdImageParser.java b/src/main/java/org/apache/commons/imaging/formats/psd/PsdImageParser.java
index 3ebf877c..9df8b30c 100644
--- a/src/main/java/org/apache/commons/imaging/formats/psd/PsdImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/psd/PsdImageParser.java
@@ -198,7 +198,7 @@ public class PsdImageParser extends ImageParser {
                     "Not a Valid PSD File");
             available -= nameLength;
             if (((nameLength + 1) % 2) != 0) {
-                //final int NameDiscard = 
+                //final int NameDiscard =
                 readByte("NameDiscard", is,
                         "Not a Valid PSD File");
                 available -= 1;
@@ -660,7 +660,7 @@ public class PsdImageParser extends ImageParser {
             throw new ImageReadException("Unknown Compression: "
                     + imageContents.Compression);
         }
-        
+
         try (InputStream is = getInputStream(byteSource, PSD_SECTION_IMAGE_DATA)) {
             fDataReader.readData(is, result, imageContents, this);
 
@@ -676,7 +676,7 @@ public class PsdImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/psd/datareaders/UncompressedDataReader.java b/src/main/java/org/apache/commons/imaging/formats/psd/datareaders/UncompressedDataReader.java
index 4b2d9e3e..28f188cd 100644
--- a/src/main/java/org/apache/commons/imaging/formats/psd/datareaders/UncompressedDataReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/psd/datareaders/UncompressedDataReader.java
@@ -55,12 +55,12 @@ public class UncompressedDataReader implements DataReader {
                 for (int y = 0; y < height; y++) {
                     for (int x = 0; x < width; x++) {
                         final int b = bbis.readBits(depth);
-    
+
                         data[channel][y][x] = (byte) b;
                     }
                 }
             }
-    
+
             dataParser.parseData(data, bi, imageContents);
         }
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeImageParser.java b/src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeImageParser.java
index 93b61d31..3463bb63 100644
--- a/src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeImageParser.java
@@ -41,7 +41,7 @@ import org.apache.commons.imaging.common.bytesource.ByteSource;
 
 /**
  * Parser for Radiance HDR images
- * 
+ *
  * @author <a href="mailto:peter@electrotank.com">peter royal</a>
  */
 public class RgbeImageParser extends ImageParser {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffDirectory.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffDirectory.java
index 691e4308..18ddff73 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffDirectory.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffDirectory.java
@@ -73,7 +73,7 @@ public class TiffDirectory extends TiffElement {
         this.entries = Collections.unmodifiableList(entries);
         this.nextDirectoryOffset = nextDirectoryOffset;
     }
-    
+
     public String description() {
         return TiffDirectory.description(type);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java
index 40d75a6c..43bcc691 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java
@@ -66,23 +66,23 @@ public class TiffField {
 
         tagInfo = TiffTags.getTag(directoryType, tag);
     }
-    
+
     public int getDirectoryType() {
         return directoryType;
     }
-    
+
     public TagInfo getTagInfo() {
         return tagInfo;
     }
 
     /**
      * Returns the field's tag, derived from bytes 0-1.
-     * @return the tag, as an <code>int</code> in which only the lowest 2 bytes are set 
+     * @return the tag, as an <code>int</code> in which only the lowest 2 bytes are set
      */
     public int getTag() {
         return tag;
     }
-    
+
     /**
      * Returns the field's type, derived from bytes 2-3.
      * @return the field's type, as a {@code FieldType} object.
@@ -137,7 +137,7 @@ public class TiffField {
     }
 
     /**
-     * Returns a copy of the raw value of the field. 
+     * Returns a copy of the raw value of the field.
      * @return the value of the field, in the byte order of the field.
      */
     public byte[] getByteArrayValue() {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
index 52d23fb0..71931112 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
@@ -61,8 +61,8 @@ public abstract class TiffImageData {
                     predictor, samplesPerPixel, width, height, compression,
                     byteOrder, this);
         }
-        
-        /** 
+
+        /**
          * Get the width of individual tiles.  Note that if the overall
          * image width is not a multiple of the tile width, then
          * the last column of tiles may extend beyond the image width.
@@ -71,8 +71,8 @@ public abstract class TiffImageData {
         public int getTileWidth() {
             return tileWidth;
         }
-        
-        /** 
+
+        /**
          * Get the height of individual tiles.  Note that if the overall
          * image height is not a multiple of the tile height, then
          * the last row of tiles may extend beyond the image height.
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
index fd482c2f..7235f2e3 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
@@ -420,7 +420,7 @@ public class TiffImageParser extends ImageParser {
      * The TIFF parser includes support for loading partial images without
      * committing significantly more memory resources than are necessary
      * to store the image. This feature is useful for conserving memory
-     * in applications that require a relatively small sub image from a 
+     * in applications that require a relatively small sub image from a
      * very large TIFF file.  The specifications for partial images are
      * as follows:
      * <code><pre>
@@ -431,14 +431,14 @@ public class TiffImageParser extends ImageParser {
      *   params.put(TiffConstants.PARAM_KEY_SUBIMAGE_HEIGHT, new Integer(height));
      * </pre></code>
      * Note that the arguments x, y, width, and height must specify a
-     * valid rectangular region that is fully contained within the 
+     * valid rectangular region that is fully contained within the
      * source TIFF image.
      * @param byteSource A valid instance of ByteSource
-     * @param params Optional instructions for special-handling or 
-     * interpretation of the input data (null objects are permitted and 
+     * @param params Optional instructions for special-handling or
+     * interpretation of the input data (null objects are permitted and
      * must be supported by implementations).
      * @return A valid instance of BufferedImage.
-     * @throws ImageReadException In the event that the specified 
+     * @throws ImageReadException In the event that the specified
      * content does not conform to the format of the specific parser
      * implementation.
      * @throws IOException In the event of unsuccessful read or
@@ -498,7 +498,7 @@ public class TiffImageParser extends ImageParser {
         }
         throw new ImageReadException("Non-Integer parameter " + key);
     }
-    
+
     private Rectangle checkForSubImage(
             final Map<String, Object> params)
             throws ImageReadException
@@ -507,7 +507,7 @@ public class TiffImageParser extends ImageParser {
         final Integer iy0 = getIntegerParameter(TiffConstants.PARAM_KEY_SUBIMAGE_Y, params);
         final Integer iwidth = getIntegerParameter(TiffConstants.PARAM_KEY_SUBIMAGE_WIDTH, params);
         final Integer iheight = getIntegerParameter(TiffConstants.PARAM_KEY_SUBIMAGE_HEIGHT, params);
-        
+
         if (ix0 == null && iy0 == null && iwidth == null && iheight == null) {
             return null;
         }
@@ -529,12 +529,12 @@ public class TiffImageParser extends ImageParser {
             sb.setLength(sb.length() - 1);
             throw new ImageReadException("Incomplete subimage parameters, missing" + sb.toString());
         }
-        
+
         return new Rectangle(ix0, iy0, iwidth, iheight);
     }
-    
+
     protected BufferedImage getBufferedImage(final TiffDirectory directory,
-            final ByteOrder byteOrder, final Map<String, Object> params) 
+            final ByteOrder byteOrder, final Map<String, Object> params)
             throws ImageReadException, IOException
     {
         final List<TiffField> entries = directory.entries;
@@ -553,8 +553,8 @@ public class TiffImageParser extends ImageParser {
         }
         final int compression = 0xffff & compressionFieldValue;
         final int width = directory.getSingleFieldValue(TiffTagConstants.TIFF_TAG_IMAGE_WIDTH);
-        final int height = directory.getSingleFieldValue(TiffTagConstants.TIFF_TAG_IMAGE_LENGTH);      
-        
+        final int height = directory.getSingleFieldValue(TiffTagConstants.TIFF_TAG_IMAGE_LENGTH);
+
         Rectangle subImage = checkForSubImage(params);
         if (subImage != null) {
             // Check for valid subimage specification. The following checks
@@ -588,7 +588,7 @@ public class TiffImageParser extends ImageParser {
             }
         }
 
-        
+
         int samplesPerPixel = 1;
         final TiffField samplesPerPixelField = directory.findField(
                 TiffTagConstants.TIFF_TAG_SAMPLES_PER_PIXEL);
@@ -649,7 +649,7 @@ public class TiffImageParser extends ImageParser {
             dataReader.readImageData(imageBuilder);
             result =  imageBuilder.getBufferedImage();
         }
-        return result;     
+        return result;
     }
 
     private PhotometricInterpreter getPhotometricInterpreter(
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
index 55be2115..61506451 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
@@ -58,7 +58,7 @@ public class TiffReader extends BinaryFileParser {
             return readTiffHeader(is);
         }
     }
-    
+
     private ByteOrder getTiffByteOrder(final int byteOrderByte) throws ImageReadException {
         if (byteOrderByte == 'I') {
             return ByteOrder.LITTLE_ENDIAN; // Intel
@@ -84,7 +84,7 @@ public class TiffReader extends BinaryFileParser {
             throw new ImageReadException("Unknown Tiff Version: " + tiffVersion);
         }
 
-        final long offsetToFirstIFD = 
+        final long offsetToFirstIFD =
                 0xFFFFffffL & read4Bytes("offsetToFirstIFD", is, "Not a Valid TIFF File", getByteOrder());
 
         skipBytes(is, offsetToFirstIFD - 8, "Not a Valid TIFF File: couldn't find IFDs");
@@ -158,7 +158,7 @@ public class TiffReader extends BinaryFileParser {
                     // which can cause OOM problems.
                     continue;
                 }
-                
+
                 final FieldType fieldType;
                 try {
                     fieldType = FieldType.getFieldType(type);
@@ -245,7 +245,7 @@ public class TiffReader extends BinaryFileParser {
                             subDirectoryRead = readDirectory(byteSource,
                                     subDirectoryOffset, subDirectoryType,
                                     formatCompliance, listener, true, visited);
-    
+
                         } catch (final ImageReadException imageReadException) {
                             if (strict) {
                                 throw imageReadException;
@@ -452,7 +452,7 @@ public class TiffReader extends BinaryFileParser {
                 if (imageHeight != null) {
                     rowsPerStrip = imageHeight.getIntValue();
                 }
-                
+
             }
 
             return new TiffImageData.Strips(data, rowsPerStrip);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffTags.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffTags.java
index fbf95b03..076031ad 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffTags.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffTags.java
@@ -77,7 +77,7 @@ final class TiffTags {
 
         return Collections.unmodifiableList(result);
     }
-    
+
     private static Map<Integer, List<TagInfo>> makeTagMap(
             final List<TagInfo> tags) {
         // make sure to use the thread-safe version; this is shared state.
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePageMaker6TagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePageMaker6TagConstants.java
index d905b648..3cef4c96 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePageMaker6TagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePageMaker6TagConstants.java
@@ -35,7 +35,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort;
  * http://partners.adobe.com/public/developer/en/tiff/TIFFPM6.pdf
  */
 public final class AdobePageMaker6TagConstants {
-    
+
     public static final TagInfoLongOrIFD TIFF_TAG_SUB_IFD = new TagInfoLongOrIFD(
             "SubIFDs",  0x014a, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN, true);
@@ -78,7 +78,7 @@ public final class AdobePageMaker6TagConstants {
                     TIFF_TAG_INDEXED,
                     TIFF_TAG_OPIPROXY,
                     TIFF_TAG_IMAGE_ID));
-    
+
     private AdobePageMaker6TagConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePhotoshopTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePhotoshopTagConstants.java
index d5f45a21..a3aab61e 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePhotoshopTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AdobePhotoshopTagConstants.java
@@ -45,7 +45,7 @@ public final class AdobePhotoshopTagConstants {
                     EXIF_TAG_JPEGTABLES,
                     EXIF_TAG_IMAGE_SOURCE_DATA
             ));
-    
+
     private AdobePhotoshopTagConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AliasSketchbookProTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AliasSketchbookProTagConstants.java
index 947c4613..0052cdc9 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AliasSketchbookProTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/AliasSketchbookProTagConstants.java
@@ -29,7 +29,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAscii;
  * http://www.awaresystems.be/imaging/tiff/tifftags/docs/alias.html
  */
 public final class AliasSketchbookProTagConstants {
-    
+
     public static final TagInfoAscii EXIF_TAG_ALIAS_LAYER_METADATA = new TagInfoAscii(
             "Alias Layer Metadata", 0xc660, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -37,7 +37,7 @@ public final class AliasSketchbookProTagConstants {
     public static final List<TagInfo> ALL_ALIAS_SKETCHBOOK_PRO_TAGS =
             Collections.unmodifiableList(Arrays.<TagInfo> asList(
                     EXIF_TAG_ALIAS_LAYER_METADATA));
-    
+
     private AliasSketchbookProTagConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/ExifTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/ExifTagConstants.java
index 3d0fb5d1..16c85e55 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/ExifTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/ExifTagConstants.java
@@ -45,7 +45,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoUnknowns;
  * http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/EXIF.html
  * http://tiki-lounge.com/~raf/tiff/fields.html
  * http://www.awaresystems.be/imaging/tiff/tifftags.html
- * 
+ *
  * "Stonits": http://www.anyhere.com/gward/pixformat/tiffluv.html
  */
 public final class ExifTagConstants {
@@ -644,9 +644,9 @@ public final class ExifTagConstants {
                     EXIF_TAG_SHADOWS, EXIF_TAG_BRIGHTNESS, EXIF_TAG_CONTRAST_2,
                     EXIF_TAG_SATURATION_2, EXIF_TAG_SHARPNESS_2, EXIF_TAG_SMOOTHNESS,
                     EXIF_TAG_MOIRE_FILTER,
-        
+
                     EXIF_TAG_USER_COMMENT, //
-        
+
                     EXIF_TAG_MAKER_NOTE));
 
     private ExifTagConstants() {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GdalLibraryTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GdalLibraryTagConstants.java
index 96a4d0b3..541514cc 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GdalLibraryTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GdalLibraryTagConstants.java
@@ -31,7 +31,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAscii;
  * http://www.awaresystems.be/imaging/tiff/tifftags/gdal_nodata.html
  */
 public final class GdalLibraryTagConstants {
-    
+
     public static final TagInfoAscii EXIF_TAG_GDAL_METADATA = new TagInfoAscii(
             "GDALMetadata", 0xa480, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GpsTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GpsTagConstants.java
index 43a3ffef..598374ed 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GpsTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/GpsTagConstants.java
@@ -36,11 +36,11 @@ public final class GpsTagConstants {
             TiffDirectoryType.EXIF_DIRECTORY_GPS);
 
     private static final byte[] GPS_VERSION = new byte[] { (byte)2, (byte)3, (byte)0, (byte)0 };
-    
+
     public static byte[] gpsVersion() {
         return GPS_VERSION.clone();
     }
-    
+
     // ************************************************************
     public static final TagInfoAscii GPS_TAG_GPS_LATITUDE_REF = new TagInfoAscii(
             "GPSLatitudeRef", 0x0001, 2,
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MicrosoftHdPhotoTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MicrosoftHdPhotoTagConstants.java
index d27d864e..04c3d072 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MicrosoftHdPhotoTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MicrosoftHdPhotoTagConstants.java
@@ -29,7 +29,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong;
 import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoUndefineds;
 
 /**
- * Microsoft's HDP/WDP file format. 
+ * Microsoft's HDP/WDP file format.
  */
 public final class MicrosoftHdPhotoTagConstants {
 
@@ -163,7 +163,7 @@ public final class MicrosoftHdPhotoTagConstants {
     public static final int TRANSFOMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_90_CW = 5;
     public static final int TRANSFOMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_270_CW = 6;
     public static final int TRANSFOMATION_VALUE_ROTATE_270_CW = 7;
-    
+
     public static final TagInfoLong EXIF_TAG_UNCOMPRESSED = new TagInfoLong(
             "Uncompressed", 0xbc03,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -177,33 +177,33 @@ public final class MicrosoftHdPhotoTagConstants {
     public static final TagInfoLong EXIF_TAG_IMAGE_WIDTH = new TagInfoLong(
             "ImageWidth", 0xbc80,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoLong EXIF_TAG_IMAGE_HEIGHT = new TagInfoLong(
             "ImageHeight", 0xbc81,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoFloat EXIF_TAG_WIDTH_RESOLUTION = new TagInfoFloat(
             "WidthResolution", 0xbc82,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoFloat EXIF_TAG_HEIGHT_RESOLUTION = new TagInfoFloat(
             "HeightResolution", 0xbc83,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     // FIXME: might be an offset?
     public static final TagInfoLong EXIF_TAG_IMAGE_OFFSET = new TagInfoLong(
             "ImageOffset", 0xbcc0,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoLong EXIF_TAG_IMAGE_BYTE_COUNT = new TagInfoLong(
             "ImageByteCount", 0xbcc1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     // FIXME: might be an offset?
     public static final TagInfoLong EXIF_TAG_ALPHA_OFFSET = new TagInfoLong(
             "AlphaOffset", 0xbcc2,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoLong EXIF_TAG_ALPHA_BYTE_COUNT = new TagInfoLong(
             "AlphaByteCount", 0xbcc3,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -227,7 +227,7 @@ public final class MicrosoftHdPhotoTagConstants {
     public static final TagInfoUndefineds EXIF_TAG_PADDING = new TagInfoUndefineds(
             "Padding", 0xea1c, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final List<TagInfo> ALL_MICROSOFT_HD_PHOTO_TAGS =
             Collections.unmodifiableList(Arrays.asList(
                     EXIF_TAG_PIXEL_FORMAT,
@@ -253,7 +253,7 @@ public final class MicrosoftHdPhotoTagConstants {
                 (byte) 0x3D, (byte) 0x77, (byte) 0x76, (byte) 0x8D,
                 (byte) 0xC9, end });
     }
-    
+
     private MicrosoftHdPhotoTagConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MolecularDynamicsGelTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MolecularDynamicsGelTagConstants.java
index 6bab50a5..a02094de 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MolecularDynamicsGelTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/MolecularDynamicsGelTagConstants.java
@@ -28,7 +28,7 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShorts;
 
 /**
  * Molecular Dynamics GEL file format
- * <BR>  
+ * <BR>
  * http://www.awaresystems.be/imaging/tiff/tifftags/docs/gel.html
  */
 public final class MolecularDynamicsGelTagConstants {
@@ -75,7 +75,7 @@ public final class MolecularDynamicsGelTagConstants {
                     EXIF_TAG_MD_PREP_DATE,
                     EXIF_TAG_MD_PREP_TIME,
                     EXIF_TAG_MD_FILE_UNITS));
-    
+
     private MolecularDynamicsGelTagConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/Rfc2301TagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/Rfc2301TagConstants.java
index c4f570d7..6e978a8d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/Rfc2301TagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/Rfc2301TagConstants.java
@@ -45,14 +45,14 @@ public final class Rfc2301TagConstants {
     public static final TagInfoShortOrLong TIFF_TAG_BAD_FAX_LINES = new TagInfoShortOrLong(
             "BadFaxLines", 0x0146, 1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoShort TIFF_TAG_CLEAN_FAX_DATA = new TagInfoShort(
             "CleanFaxData", 0x0147,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
     public static final int CLEAN_FAX_DATA_VALUE_CLEAN = 0;
     public static final int CLEAN_FAX_DATA_VALUE_REGENERATED = 1;
     public static final int CLEAN_FAX_DATA_VALUE_UNCLEAN = 2;
-    
+
     public static final TagInfoShortOrLong TIFF_TAG_CONSECUTIVE_BAD_FAX_LINES = new TagInfoShortOrLong(
             "ConsecutiveBadFaxLines", 0x0148, 1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -60,13 +60,13 @@ public final class Rfc2301TagConstants {
     public static final TagInfoDirectory TIFF_TAG_GLOBAL_PARAMETERS_IFD = new TagInfoDirectory(
             "GlobalParametersIFD", 0x0190,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoLong TIFF_TAG_PROFILE_TYPE = new TagInfoLong(
             "ProfileType", 0x0191,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
     public static final int PROFILE_TYPE_VALUE_UNSPECIFIED = 0;
     public static final int PROFILE_TYPE_VALUE_GROUP_3_FAX = 1;
-    
+
     public static final TagInfoByte TIFF_TAG_FAX_PROFILE = new TagInfoByte(
             "FaxProfile", 0x0192,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -77,7 +77,7 @@ public final class Rfc2301TagConstants {
     public static final int FAX_PROFILE_VALUE_LOSSY_COLOR_AND_GRAYSCALE_C = 4;
     public static final int FAX_PROFILE_VALUE_LOSSLESS_COLOR_AND_GRAYSCALE_L = 5;
     public static final int FAX_PROFILE_VALUE_MIXED_RASTER_CONTENT_M = 6;
-    
+
     public static final TagInfoLong TIFF_TAG_CODING_METHODS = new TagInfoLong(
             "CodingMethods", 0x0193,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -87,11 +87,11 @@ public final class Rfc2301TagConstants {
     public static final int CODING_METHODS_VALUE_T82_T85 = 16;
     public static final int CODING_METHODS_VALUE_T81 = 32;
     public static final int CODING_METHODS_VALUE_T82_T43 = 64;
-    
+
     public static final TagInfoBytes TIFF_TAG_VERSION_YEAR = new TagInfoBytes(
             "VersionYear", 0x0194, 4,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoByte TIFF_TAG_MODE_NUMBER = new TagInfoByte(
             "ModeNumber", 0x0195,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -99,7 +99,7 @@ public final class Rfc2301TagConstants {
     public static final TagInfoRationals TIFF_TAG_DECODE = new TagInfoRationals(
             "Decode", 0x01b1, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoShorts TIFF_TAG_DEFAULT_IMAGE_COLOR = new TagInfoShorts(
             "DefaultImageColor", 0x01b2, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffConstants.java
index 76e3b358..737b00ee 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffConstants.java
@@ -61,8 +61,8 @@ public final class TiffConstants {
     public static final int TIFF_FLAG_T4_OPTIONS_UNCOMPRESSED_MODE = 2;
     public static final int TIFF_FLAG_T4_OPTIONS_FILL = 4;
     public static final int TIFF_FLAG_T6_OPTIONS_UNCOMPRESSED_MODE = 2;
-    
-    
+
+
     public static final String PARAM_KEY_SUBIMAGE_X = "SUBIMAGE_X";
     public static final String PARAM_KEY_SUBIMAGE_Y = "SUBIMAGE_Y";
     public static final String PARAM_KEY_SUBIMAGE_WIDTH = "SUBIMAGE_WIDTH";
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffDirectoryType.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffDirectoryType.java
index 619c8de2..70a41042 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffDirectoryType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffDirectoryType.java
@@ -22,7 +22,7 @@ public enum TiffDirectoryType {
 
     TIFF_DIRECTORY_IFD1(
             true, TiffDirectoryConstants.DIRECTORY_TYPE_DIR_1, "IFD1"),
-    
+
     TIFF_DIRECTORY_IFD2(
             true, TiffDirectoryConstants.DIRECTORY_TYPE_DIR_2, "IFD2"),
 
@@ -37,17 +37,17 @@ public enum TiffDirectoryType {
             false, TiffDirectoryConstants.DIRECTORY_TYPE_EXIF, "Exif IFD"),
     EXIF_DIRECTORY_GPS(
             false, TiffDirectoryConstants.DIRECTORY_TYPE_GPS, "GPS IFD");
-    
+
     private final boolean isImageDirectory;
     public final int directoryType;
     public final String name;
-    
+
     TiffDirectoryType(final boolean isImageDirectory, final int directoryType, final String name) {
         this.isImageDirectory = isImageDirectory;
         this.directoryType = directoryType;
         this.name = name;
     }
-    
+
     public boolean isImageDirectory() {
         return isImageDirectory;
     }
@@ -61,7 +61,7 @@ public enum TiffDirectoryType {
         }
         return TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN;
     }
-    
+
     public static final TiffDirectoryType EXIF_DIRECTORY_IFD0 = TIFF_DIRECTORY_IFD0;
     public static final TiffDirectoryType TIFF_DIRECTORY_ROOT = TIFF_DIRECTORY_IFD0;
     public static final TiffDirectoryType EXIF_DIRECTORY_IFD1 = TIFF_DIRECTORY_IFD1;
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffEpTagConstants.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffEpTagConstants.java
index 48ddd26d..755013c5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffEpTagConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffEpTagConstants.java
@@ -33,14 +33,14 @@ import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShorts;
 import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoUndefineds;
 
 /**
- * 
+ *
  */
 public final class TiffEpTagConstants {
 
     public static final TagInfoShorts EXIF_TAG_CFAREPEAT_PATTERN_DIM = new TagInfoShorts(
             "CFARepeatPatternDim", 0x828d, 2,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoBytes EXIF_TAG_CFAPATTERN_2 = new TagInfoBytes(
             "CFAPattern2", 0x828e, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -48,7 +48,7 @@ public final class TiffEpTagConstants {
     public static final TagInfoAsciiOrRational EXIF_TAG_BATTERY_LEVEL = new TagInfoAsciiOrRational(
             "BatteryLevel", 0x828f, -1,
             TiffDirectoryType.TIFF_DIRECTORY_ROOT);
-    
+
     public static final TagInfoUndefineds EXIF_TAG_INTER_COLOR_PROFILE = new TagInfoUndefineds(
             "InterColorProfile", 0x8773, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -72,19 +72,19 @@ public final class TiffEpTagConstants {
     public static final TagInfoUndefineds EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE_1 = new TagInfoUndefineds(
             "SpatialFrequencyResponse", 0x920c, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoUndefineds EXIF_TAG_NOISE_1 = new TagInfoUndefineds(
             "Noise", 0x920d, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoRational EXIF_TAG_FOCAL_PLANE_XRESOLUTION = new TagInfoRational(
             "FocalPlaneXResolution", 0x920e,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoRational EXIF_TAG_FOCAL_PLANE_YRESOLUTION = new TagInfoRational(
             "FocalPlaneYResolution", 0x920f,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoShort EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT = new TagInfoShort(
             "FocalPlaneResolutionUnit", 0x9210,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
@@ -109,7 +109,7 @@ public final class TiffEpTagConstants {
     public static final TagInfoRationals EXIF_TAG_EXPOSURE_INDEX = new TagInfoRationals(
             "ExposureIndex", 0x9215, -1,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    
+
     public static final TagInfoBytes EXIF_TAG_TIFF_EPSTANDARD_ID_1 = new TagInfoBytes(
             "TIFF/EPStandardID", 0x9216, 4,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
index 3878b268..a44bf7dd 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
@@ -55,7 +55,7 @@ public final class DataReaderStrips extends ImageDataReader {
     }
 
     private void interpretStrip(
-            final ImageBuilder imageBuilder, 
+            final ImageBuilder imageBuilder,
             final byte[] bytes,
             final int pixelsPerStrip,
             final int yLimit) throws ImageReadException, IOException {
@@ -217,16 +217,16 @@ public final class DataReaderStrips extends ImageDataReader {
 
         }
     }
-    
-    
+
+
     @Override
     public BufferedImage readImageData(final Rectangle subImage)
             throws ImageReadException, IOException
     {
         // the legacy code is optimized to the reading of whole
         // strips (except for the last strip in the image, which can
-        // be a partial).  So create a working image with compatible 
-        // dimensions and read that.  Later on, the working image 
+        // be a partial).  So create a working image with compatible
+        // dimensions and read that.  Later on, the working image
         // will be sub-imaged to the proper size.
 
         // strip0 and strip1 give the indices of the strips containing
@@ -237,17 +237,17 @@ public final class DataReaderStrips extends ImageDataReader {
 
 
         // the legacy code uses a member element "y" to keep track
-        // of the row index of the output image that is being processed 
-        // by interpretStrip. y is set to zero before the first 
+        // of the row index of the output image that is being processed
+        // by interpretStrip. y is set to zero before the first
         // call to interpretStrip.  y0 will be the index of the first row
         // in the full image (the source image) that will be processed.
- 
+
         final int y0 = strip0 * rowsPerStrip;
         final int yLimit = subImage.y - y0 + subImage.height;
 
 
         // TO DO: we can probably save some processing by using yLimit instead
-        //        or working 
+        //        or working
         final ImageBuilder workingBuilder =
                 new ImageBuilder(width, workingHeight, false);
 
@@ -270,7 +270,7 @@ public final class DataReaderStrips extends ImageDataReader {
                     (int) pixelsPerStrip,
                     yLimit);
         }
- 
+
 
         if (subImage.x == 0
                 && subImage.y == y0
@@ -283,7 +283,7 @@ public final class DataReaderStrips extends ImageDataReader {
                 subImage.x,
                 subImage.y - y0,
                 subImage.width,
-                subImage.height);      
+                subImage.height);
     }
 
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
index 91ca4c55..dae6d1fe 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
@@ -180,7 +180,7 @@ public final class DataReaderTiled extends ImageDataReader {
 
         }
     }
-    
+
     @Override
     public BufferedImage readImageData(final Rectangle subImage)
             throws ImageReadException, IOException
@@ -192,7 +192,7 @@ public final class DataReaderTiled extends ImageDataReader {
         int y = 0;
 
         // tileWidth is the width of the tile
-        // tileLength is the height of the tile 
+        // tileLength is the height of the tile
         final int col0 = subImage.x / tileWidth;
         final int col1 = (subImage.x + subImage.width - 1) / tileWidth;
         final int row0 = subImage.y / tileLength;
@@ -207,10 +207,10 @@ public final class DataReaderTiled extends ImageDataReader {
 
         final int x0 = col0 * tileWidth;
         final int y0 = row0 * tileLength;
-        
+
         final ImageBuilder workingBuilder =
                 new ImageBuilder(workingWidth, workingHeight, false);
-        
+
         for (int iRow = row0; iRow <= row1; iRow++) {
             for (int iCol = col0; iCol <= col1; iCol++) {
                 final int tile = iRow * nColumnsOfTiles + iCol;
@@ -222,12 +222,12 @@ public final class DataReaderTiled extends ImageDataReader {
                 interpretTile(workingBuilder, decompressed, x, y, workingWidth, workingHeight);
             }
         }
-   
+
         if (subImage.x == x0
                 && subImage.y == y0
                 && subImage.width == workingWidth
                 && subImage.height == workingHeight) {
-            return workingBuilder.getBufferedImage(); 
+            return workingBuilder.getBufferedImage();
         }
         return workingBuilder.getSubimage(
             subImage.x - x0,
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java
index ab182e2d..19f25a1d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java
@@ -93,10 +93,10 @@ public abstract class ImageDataReader {
         }
         return true;
     }
- 
+
     /**
      * Reads samples and returns them in an int array.
-     * 
+     *
      * @param bis
      *            the stream to read from
      * @param result
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldType.java b/src/main/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldType.java
index b1708c01..5c259cb7 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldType.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldType.java
@@ -46,7 +46,7 @@ public abstract class FieldType {
     private final int type;
     private final String name;
     private final int elementSize;
-    
+
     public static final List<FieldType> ANY =
             Collections.unmodifiableList(Arrays.asList(
                     BYTE, ASCII, SHORT,
@@ -58,31 +58,31 @@ public abstract class FieldType {
     public static final List<FieldType> SHORT_OR_LONG =
             Collections.unmodifiableList(Arrays.asList(
                     SHORT, LONG));
-    
+
     public static final List<FieldType> SHORT_OR_RATIONAL =
             Collections.unmodifiableList(Arrays.asList(
                     SHORT, RATIONAL));
-    
+
     public static final List<FieldType> SHORT_OR_LONG_OR_RATIONAL =
             Collections.unmodifiableList(Arrays.asList(
                     SHORT, LONG, RATIONAL));
-    
+
     public static final List<FieldType> LONG_OR_SHORT =
             Collections.unmodifiableList(Arrays.asList(
                     SHORT, LONG));
-    
+
     public static final List<FieldType> BYTE_OR_SHORT =
             Collections.unmodifiableList(Arrays.asList(
                     SHORT, BYTE));
-    
+
     public static final List<FieldType> LONG_OR_IFD =
             Collections.unmodifiableList(Arrays.asList(
                     (FieldType) LONG, IFD));
-    
+
     public static final List<FieldType> ASCII_OR_RATIONAL =
             Collections.unmodifiableList(Arrays.asList(
                     ASCII, RATIONAL));
-    
+
     public static final List<FieldType> ASCII_OR_BYTE =
             Collections.unmodifiableList(Arrays.asList(
                     ASCII, BYTE));
@@ -92,20 +92,20 @@ public abstract class FieldType {
         this.name = name;
         this.elementSize = elementSize;
     }
-    
-    
+
+
     public int getType() {
         return type;
     }
-    
+
     public String getName() {
         return name;
     }
-    
+
     public int getSize() {
         return elementSize;
     }
-    
+
     public static FieldType getFieldType(final int type) throws ImageReadException {
         for (final FieldType fieldType : ANY) {
             if (fieldType.getType() == type) {
@@ -114,7 +114,7 @@ public abstract class FieldType {
         }
         throw new ImageReadException("Field type " + type + " is unsupported");
     }
-    
+
     public abstract Object getValue(final TiffField entry);
     public abstract byte[] writeData(final Object o, final ByteOrder byteOrder) throws ImageWriteException;
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreter.java b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreter.java
index c3c707c1..ff3e30ad 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreter.java
@@ -39,7 +39,7 @@ public abstract class PhotometricInterpreter {
 
     public abstract void interpretPixel(ImageBuilder imageBuilder,
             int[] samples, int x, int y) throws ImageReadException, IOException;
-    
+
     protected int getBitsPerSample(final int offset) {
         return bitsPerSample[offset];
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterYCbCr.java b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterYCbCr.java
index c701b864..9b3ec33c 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterYCbCr.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterYCbCr.java
@@ -41,7 +41,7 @@ public class PhotometricInterpreterYCbCr extends PhotometricInterpreter {
      * imageWidth and imageHeight. These variables are either set manually in
      * the case of a null constructor, or they are automatically calculated from
      * the image parameter constructor.
-     * 
+     *
      * @param Y
      *            The Y component set.
      * @param Cb
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfo.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfo.java
index 4ab72810..d7ff6e59 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfo.java
@@ -76,7 +76,7 @@ public class TagInfo {
     }
 
     /**
-     * 
+     *
      * @param entry the TIFF field whose value to return
      * @return the value of the TIFF field
      * @throws ImageReadException thrown by subclasses
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByte.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByte.java
index fc3f7060..6ada6cc5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByte.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByte.java
@@ -26,7 +26,7 @@ public class TagInfoByte extends TagInfo {
     public TagInfoByte(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.BYTE, 1, directoryType);
     }
-    
+
     public TagInfoByte(final String name, final int tag, final List<FieldType> fieldTypes,
             final TiffDirectoryType directoryType) {
         super(name, tag, fieldTypes, 1, directoryType);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByteOrShort.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByteOrShort.java
index 56fce73a..a111aea0 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByteOrShort.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoByteOrShort.java
@@ -26,11 +26,11 @@ public class TagInfoByteOrShort extends TagInfo {
     public TagInfoByteOrShort(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.BYTE_OR_SHORT, length, directoryType);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final byte... values) {
         return values;
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoBytes.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoBytes.java
index a800d140..89076465 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoBytes.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoBytes.java
@@ -26,7 +26,7 @@ public class TagInfoBytes extends TagInfo {
     public TagInfoBytes(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.BYTE, length, directoryType);
     }
-    
+
     public TagInfoBytes(final String name, final int tag, final List<FieldType> fieldTypes,
             final int length, final TiffDirectoryType directoryType) {
         super(name, tag, fieldTypes, length, directoryType);
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDouble.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDouble.java
index b282d4f4..d5a22dc4 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDouble.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDouble.java
@@ -26,11 +26,11 @@ public class TagInfoDouble extends TagInfo {
     public TagInfoDouble(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.DOUBLE, 1, directoryType);
     }
-    
+
     public double getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toDouble(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final double value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDoubles.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDoubles.java
index 9043efce..6d1a512c 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDoubles.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoDoubles.java
@@ -26,11 +26,11 @@ public class TagInfoDoubles extends TagInfo {
     public TagInfoDoubles(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.DOUBLE, length, directoryType);
     }
-    
+
     public double[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toDoubles(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final double... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloat.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloat.java
index d18982e4..c8fad33a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloat.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloat.java
@@ -26,11 +26,11 @@ public class TagInfoFloat extends TagInfo {
     public TagInfoFloat(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.FLOAT, 1, directoryType);
     }
-    
+
     public float getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toFloat(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final float value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloats.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloats.java
index c8f5d9a4..c90ee908 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloats.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoFloats.java
@@ -26,11 +26,11 @@ public class TagInfoFloats extends TagInfo {
     public TagInfoFloats(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.FLOAT, length, directoryType);
     }
-    
+
     public float[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toFloats(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final float... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoGpsText.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoGpsText.java
index 323bc451..90715eac 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoGpsText.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoGpsText.java
@@ -32,7 +32,7 @@ import org.apache.commons.imaging.internal.Debug;
  * Used by some GPS tags and the EXIF user comment tag,
  * this badly documented value is meant to contain
  * the text encoding in the first 8 bytes followed by
- * the non-null-terminated text in an unknown byte order.  
+ * the non-null-terminated text in an unknown byte order.
  */
 public final class TagInfoGpsText extends TagInfo {
     private static final TagInfoGpsText.TextEncoding TEXT_ENCODING_ASCII = new TextEncoding(
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLong.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLong.java
index 78aa7b22..3b72a716 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLong.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLong.java
@@ -27,15 +27,15 @@ public class TagInfoLong extends TagInfo {
     public TagInfoLong(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.LONG, 1, directoryType);
     }
-    
+
     public TagInfoLong(final String name, final int tag, final TiffDirectoryType directoryType, final boolean isOffset) {
         super(name, tag, FieldType.LONG, 1, directoryType, isOffset);
     }
-    
+
     public int getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toInt(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongOrIFD.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongOrIFD.java
index 2814898c..2345d5a4 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongOrIFD.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongOrIFD.java
@@ -27,15 +27,15 @@ public class TagInfoLongOrIFD extends TagInfo {
     public TagInfoLongOrIFD(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.LONG_OR_IFD, length, directoryType);
     }
-    
+
     public TagInfoLongOrIFD(final String name, final int tag, final int length, final TiffDirectoryType directoryType, final boolean isOffset) {
         super(name, tag, FieldType.LONG_OR_IFD, length, directoryType, isOffset);
     }
-    
+
     public int[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toInts(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongs.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongs.java
index 2f95e257..a2aba044 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongs.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoLongs.java
@@ -26,15 +26,15 @@ public class TagInfoLongs extends TagInfo {
     public TagInfoLongs(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.LONG, length, directoryType);
     }
-    
+
     public TagInfoLongs(final String name, final int tag, final int length, final TiffDirectoryType directoryType, final boolean isOffset) {
         super(name, tag, FieldType.LONG, length, directoryType, isOffset);
     }
-    
+
     public int[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toInts(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRational.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRational.java
index 0e5391c3..c113ff66 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRational.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRational.java
@@ -31,7 +31,7 @@ public class TagInfoRational extends TagInfo {
     public RationalNumber getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toRational(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final RationalNumber value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRationals.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRationals.java
index f3ccb7f1..e4fde594 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRationals.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoRationals.java
@@ -31,7 +31,7 @@ public class TagInfoRationals extends TagInfo {
     public RationalNumber[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toRationals(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final RationalNumber... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLong.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLong.java
index 833b46a7..606e4efd 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLong.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLong.java
@@ -26,11 +26,11 @@ public class TagInfoSLong extends TagInfo {
     public TagInfoSLong(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SLONG, 1, directoryType);
     }
-    
+
     public int getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toInt(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLongs.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLongs.java
index 83976be4..6eba86b5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLongs.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSLongs.java
@@ -26,11 +26,11 @@ public class TagInfoSLongs extends TagInfo {
     public TagInfoSLongs(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SLONG, length, directoryType);
     }
-    
+
     public int[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toInts(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRational.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRational.java
index f6242510..8df641f9 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRational.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRational.java
@@ -31,7 +31,7 @@ public class TagInfoSRational extends TagInfo {
     public RationalNumber getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toRational(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final RationalNumber value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRationals.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRationals.java
index 95200a82..350ed13d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRationals.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSRationals.java
@@ -31,7 +31,7 @@ public class TagInfoSRationals extends TagInfo {
     public RationalNumber[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toRationals(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final RationalNumber... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShort.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShort.java
index 9baf5ced..1cb9bb0c 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShort.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShort.java
@@ -26,11 +26,11 @@ public class TagInfoSShort extends TagInfo {
     public TagInfoSShort(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SSHORT, 1, directoryType);
     }
-    
+
     public short getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toShort(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short value) {
         return ByteConversions.toBytes(value, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShorts.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShorts.java
index d32061e8..a4a0aa9f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShorts.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoSShorts.java
@@ -26,11 +26,11 @@ public class TagInfoSShorts extends TagInfo {
     public TagInfoSShorts(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SSHORT, length, directoryType);
     }
-    
+
     public short[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toShorts(bytes, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShort.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShort.java
index 4d926c9b..0b00f073 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShort.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShort.java
@@ -26,7 +26,7 @@ public class TagInfoShort extends TagInfo {
     public TagInfoShort(final String name, final int tag, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SHORT, 1, directoryType);
     }
-    
+
     public short getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toShort(bytes, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLong.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLong.java
index 1b62bc70..266d9cf4 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLong.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLong.java
@@ -26,15 +26,15 @@ public class TagInfoShortOrLong extends TagInfo {
     public TagInfoShortOrLong(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SHORT_OR_LONG, length, directoryType, false);
     }
-    
+
     public TagInfoShortOrLong(final String name, final int tag, final int length, final TiffDirectoryType directoryType, final boolean isOffset) {
         super(name, tag, FieldType.SHORT_OR_LONG, length, directoryType, isOffset);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLongOrRational.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLongOrRational.java
index b99b428d..90f9148f 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLongOrRational.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrLongOrRational.java
@@ -27,15 +27,15 @@ public class TagInfoShortOrLongOrRational extends TagInfo {
     public TagInfoShortOrLongOrRational(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SHORT_OR_LONG_OR_RATIONAL, length, directoryType);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final int... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final RationalNumber... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrRational.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrRational.java
index 167749e9..16913ee2 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrRational.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShortOrRational.java
@@ -27,7 +27,7 @@ public class TagInfoShortOrRational extends TagInfo {
     public TagInfoShortOrRational(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SHORT_OR_RATIONAL, length, directoryType, false);
     }
-    
+
     public byte[] encodeValue(final ByteOrder byteOrder, final short... values) {
         return ByteConversions.toBytes(values, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShorts.java b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShorts.java
index 21adb024..299e45ec 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShorts.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/taginfos/TagInfoShorts.java
@@ -26,7 +26,7 @@ public class TagInfoShorts extends TagInfo {
     public TagInfoShorts(final String name, final int tag, final int length, final TiffDirectoryType directoryType) {
         super(name, tag, FieldType.SHORT, length, directoryType);
     }
-    
+
     public short[] getValue(final ByteOrder byteOrder, final byte[] bytes) {
         return ByteConversions.toShorts(bytes, byteOrder);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/ImageDataOffsets.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/ImageDataOffsets.java
index 220dacfb..db44ff5d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/ImageDataOffsets.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/ImageDataOffsets.java
@@ -22,7 +22,7 @@ class ImageDataOffsets {
     final int[] imageDataOffsets;
     final TiffOutputField imageDataOffsetsField;
     final TiffOutputItem[] outputItems;
-    
+
     ImageDataOffsets(final TiffElement.DataElement[] imageData,
             final int[] imageDataOffsets,
             final TiffOutputField imageDataOffsetsField) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterBase.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterBase.java
index 6c09b49f..8b67f09d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterBase.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterBase.java
@@ -67,7 +67,7 @@ public abstract class TiffImageWriterBase {
             throws ImageWriteException {
         final List<TiffOutputDirectory> directories = outputSet.getDirectories();
 
-        if (directories.isEmpty()) { 
+        if (directories.isEmpty()) {
             throw new ImageWriteException("No directories.");
         }
 
@@ -456,7 +456,7 @@ public abstract class TiffImageWriterBase {
                         (short) 0);
                 directory.add(TiffTagConstants.TIFF_TAG_XRESOLUTION,
                         RationalNumber.valueOf(pixelDensity.getRawHorizontalDensity()));
-                directory.add(TiffTagConstants.TIFF_TAG_YRESOLUTION, 
+                directory.add(TiffTagConstants.TIFF_TAG_YRESOLUTION,
                         RationalNumber.valueOf(pixelDensity.getRawVerticalDensity()));
             } else if (pixelDensity.isInInches()) {
                 directory.add(TiffTagConstants.TIFF_TAG_RESOLUTION_UNIT,
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterLossless.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterLossless.java
index 43c7f17c..729615a5 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterLossless.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterLossless.java
@@ -89,7 +89,7 @@ public class TiffImageWriterLossless extends TiffImageWriterBase {
                     if (oversizeValue != null) {
                         final TiffOutputField frozenField = frozenFields.get(field.getTag());
                         if (frozenField != null
-                                && frozenField.getSeperateValue() != null 
+                                && frozenField.getSeperateValue() != null
                                 && frozenField.bytesEqual(field.getByteArrayValue())) {
                             frozenField.getSeperateValue().setOffset(field.getOffset());
                         } else {
@@ -145,7 +145,7 @@ public class TiffImageWriterLossless extends TiffImageWriterBase {
     public void write(final OutputStream os, final TiffOutputSet outputSet)
             throws IOException, ImageWriteException {
         // There are some fields whose address in the file must not change,
-        // unless of course their value is changed. 
+        // unless of course their value is changed.
         final Map<Integer, TiffOutputField> frozenFields = new HashMap<>();
         final TiffOutputField makerNoteField = outputSet.findField(ExifTagConstants.EXIF_TAG_MAKER_NOTE);
         if (makerNoteField != null && makerNoteField.getSeperateValue() != null) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputDirectory.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputDirectory.java
index 02ceeacf..83f1caa8 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputDirectory.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputDirectory.java
@@ -568,7 +568,7 @@ public final class TiffOutputDirectory extends TiffOutputItem {
      * If there is no field matching the given TagInfo, null will be returned.
      * </p>
      *
-     * @param tagInfo the TagInfo specifying the field 
+     * @param tagInfo the TagInfo specifying the field
      * @return the field matching tagInfo or null, if the field isn't present
      * @see #findField(int)
      */
@@ -583,7 +583,7 @@ public final class TiffOutputDirectory extends TiffOutputItem {
      * If there is no field matching the given tag, null will be returned.
      * </p>
      *
-     * @param tag the tag specifying the field 
+     * @param tag the tag specifying the field
      * @return the field matching tagInfo or null, if the field isn't present
      * @see #findField(TagInfo)
      */
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputField.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputField.java
index d685f80f..c77d1001 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputField.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputField.java
@@ -101,7 +101,7 @@ public class TiffOutputField {
     protected final boolean isLocalValue() {
         return bytes.length <= TIFF_ENTRY_MAX_VALUE_LENGTH;
     }
-    
+
     public boolean bytesEqual(final byte[] data) {
         return Arrays.equals(bytes, data);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSet.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSet.java
index 815cdff1..d9f7075a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSet.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSet.java
@@ -127,7 +127,7 @@ public final class TiffOutputSet {
 
     /**
      * A convenience method to update GPS values in EXIF metadata.
-     * 
+     *
      * @param longitude
      *            Longitude in degrees E, negative values are W.
      * @param latitude
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSummary.java b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSummary.java
index c26045c5..af91d7b3 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSummary.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffOutputSummary.java
@@ -30,7 +30,7 @@ class TiffOutputSummary {
     public final Map<Integer, TiffOutputDirectory> directoryTypeMap;
     private final List<OffsetItem> offsetItems = new ArrayList<>();
     private final List<ImageDataOffsets> imageDataItems = new ArrayList<>();
-    
+
     public TiffOutputSummary(final ByteOrder byteOrder,
             final TiffOutputDirectory rootDirectory,
             final Map<Integer, TiffOutputDirectory> directoryTypeMap) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/wbmp/WbmpImageParser.java b/src/main/java/org/apache/commons/imaging/formats/wbmp/WbmpImageParser.java
index bd1b7873..deea19e9 100644
--- a/src/main/java/org/apache/commons/imaging/formats/wbmp/WbmpImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/wbmp/WbmpImageParser.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -265,7 +265,7 @@ public class WbmpImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/xbm/XbmImageParser.java b/src/main/java/org/apache/commons/imaging/formats/xbm/XbmImageParser.java
index 39700b2b..7ca8a43a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/xbm/XbmImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/xbm/XbmImageParser.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -173,7 +173,7 @@ public class XbmImageParser extends ImageParser {
             return xbmParseResult;
         }
     }
-    
+
     private static int parseCIntegerLiteral(String value) {
         if (value.startsWith("0")) {
             if (value.length() >= 2) {
@@ -300,7 +300,7 @@ public class XbmImageParser extends ImageParser {
         final ColorModel colorModel = new IndexColorModel(1, 2, palette, 0, false, -1, DataBuffer.TYPE_BYTE);
         final DataBufferByte dataBuffer = new DataBufferByte(imageData, imageData.length);
         final WritableRaster raster = Raster.createPackedRaster(dataBuffer, xbmHeader.width, xbmHeader.height, 1, null);
-        
+
         return new BufferedImage(colorModel, raster, colorModel.isAlphaPremultiplied(), new Properties());
     }
 
@@ -414,7 +414,7 @@ public class XbmImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/formats/xpm/XpmImageParser.java b/src/main/java/org/apache/commons/imaging/formats/xpm/XpmImageParser.java
index 7c78b457..8f098de9 100644
--- a/src/main/java/org/apache/commons/imaging/formats/xpm/XpmImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/xpm/XpmImageParser.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -72,7 +72,7 @@ public class XpmImageParser extends ImageParser {
             if (colorNames != null) {
                 return;
             }
-    
+
             try {
                 final InputStream rgbTxtStream =
                         XpmImageParser.class.getResourceAsStream("rgb.txt");
@@ -361,7 +361,7 @@ public class XpmImageParser extends ImageParser {
             return 0x00000000;
         }
     }
-    
+
     private void populatePaletteEntry(final PaletteEntry paletteEntry, final String key, final String color) throws ImageReadException {
         if ("m".equals(key)) {
             paletteEntry.monoArgb = parseColor(color);
@@ -399,11 +399,11 @@ public class XpmImageParser extends ImageParser {
             for (int j = 0; j < tokens.length; j++) {
                 final String token = tokens[j];
                 boolean isKey = false;
-                if (previousKeyIndex < (j - 1) 
+                if (previousKeyIndex < (j - 1)
                         && "m".equals(token)
-                        || "g4".equals(token) 
+                        || "g4".equals(token)
                         || "g".equals(token)
-                        || "c".equals(token) 
+                        || "c".equals(token)
                         || "s".equals(token)) {
                     isKey = true;
                 }
@@ -724,7 +724,7 @@ public class XpmImageParser extends ImageParser {
     /**
      * Extracts embedded XML metadata as XML string.
      * <p>
-     * 
+     *
      * @param byteSource
      *            File containing image data.
      * @param params
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccConstants.java b/src/main/java/org/apache/commons/imaging/icc/IccConstants.java
index 787a1299..e3ab397c 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccConstants.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccConstants.java
@@ -21,7 +21,7 @@ public final class IccConstants {
             | ((0xff & 'C') << 8) | ((0xff & ' ') << 0));
     public static final int sRGB = (((0xff & 's') << 24) | ((0xff & 'R') << 16)
             | ((0xff & 'G') << 8) | ((0xff & 'B') << 0));
-    
+
     private IccConstants() {
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccProfileInfo.java b/src/main/java/org/apache/commons/imaging/icc/IccProfileInfo.java
index 22f3a68e..63631615 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccProfileInfo.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccProfileInfo.java
@@ -84,7 +84,7 @@ public class IccProfileInfo {
     }
 
     public boolean issRGB() {
-        return deviceManufacturer == IccConstants.IEC 
+        return deviceManufacturer == IccConstants.IEC
                 && deviceModel == IccConstants.sRGB;
     }
 
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccProfileParser.java b/src/main/java/org/apache/commons/imaging/icc/IccProfileParser.java
index 3dee15ea..efbafc6c 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccProfileParser.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccProfileParser.java
@@ -137,7 +137,7 @@ public class IccProfileParser extends BinaryFileParser {
 
             final int profileVersion = read4Bytes("ProfileVersion", is, "Not a Valid ICC Profile", getByteOrder());
 
-            final int profileDeviceClassSignature = read4Bytes("ProfileDeviceClassSignature", is, 
+            final int profileDeviceClassSignature = read4Bytes("ProfileDeviceClassSignature", is,
                     "Not a Valid ICC Profile", getByteOrder());
             if (LOGGER.isLoggable(Level.FINEST)) {
                 printCharQuad("ProfileDeviceClassSignature", profileDeviceClassSignature);
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccTag.java b/src/main/java/org/apache/commons/imaging/icc/IccTag.java
index e4570c0d..5c9fcd51 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccTag.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccTag.java
@@ -54,9 +54,9 @@ public class IccTag {
         data = bytes;
 
         try (InputStream bis = new ByteArrayInputStream(bytes)) {
-            dataTypeSignature = BinaryFunctions.read4Bytes("data type signature", bis, 
+            dataTypeSignature = BinaryFunctions.read4Bytes("data type signature", bis,
                     "ICC: corrupt tag data", ByteOrder.BIG_ENDIAN);
-    
+
             itdt = getIccTagDataType(dataTypeSignature);
             // if (itdt != null)
             // {
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccTagDataTypes.java b/src/main/java/org/apache/commons/imaging/icc/IccTagDataTypes.java
index a23c6e1b..7e65a7a4 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccTagDataTypes.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccTagDataTypes.java
@@ -36,11 +36,11 @@ public enum IccTagDataTypes implements IccTagDataType {
         {
             try (InputStream bis = new ByteArrayInputStream(bytes)) {
                 read4Bytes("type_signature", bis, "ICC: corrupt tag data", ByteOrder.BIG_ENDIAN);
-    
+
                 //            bis.setDebug(true);
                 read4Bytes("ignore", bis, "ICC: corrupt tag data", ByteOrder.BIG_ENDIAN);
                 final int stringLength = read4Bytes("stringLength", bis, "ICC: corrupt tag data", ByteOrder.BIG_ENDIAN);
-    
+
                 //            bis.readByteArray("ignore", bytes.length -12, "none");
                 final String s = new String(bytes, 12, stringLength - 1, StandardCharsets.US_ASCII);
                 LOGGER.fine(prefix + "s: '" + s + "'");
@@ -125,12 +125,12 @@ public enum IccTagDataTypes implements IccTagDataType {
         this.name = name;
         this.signature = signature;
     }
-    
+
     @Override
     public String getName() {
         return name;
     }
-    
+
     @Override
     public int getSignature() {
         return signature;
diff --git a/src/main/java/org/apache/commons/imaging/icc/IccTagTypes.java b/src/main/java/org/apache/commons/imaging/icc/IccTagTypes.java
index 36d15a59..61cf96c4 100644
--- a/src/main/java/org/apache/commons/imaging/icc/IccTagTypes.java
+++ b/src/main/java/org/apache/commons/imaging/icc/IccTagTypes.java
@@ -328,12 +328,12 @@ public enum IccTagTypes implements IccTagType {
     public String getName() {
         return name;
     }
-    
+
     @Override
     public String getTypeDescription() {
         return typeDescription;
     }
-    
+
     @Override
     public int getSignature() {
         return signature;
diff --git a/src/main/java/org/apache/commons/imaging/palette/ColorComponent.java b/src/main/java/org/apache/commons/imaging/palette/ColorComponent.java
index 77ac38bc..ba39bd8f 100644
--- a/src/main/java/org/apache/commons/imaging/palette/ColorComponent.java
+++ b/src/main/java/org/apache/commons/imaging/palette/ColorComponent.java
@@ -21,7 +21,7 @@ enum ColorComponent {
     RED(16),
     GREEN(8),
     BLUE(0);
-    
+
     private final int shift;
 
     private ColorComponent(final int shift) {
diff --git a/src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java b/src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java
index 6405aa95..e4e32c13 100644
--- a/src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java
+++ b/src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java
@@ -143,7 +143,7 @@ class ColorSpaceSubset {
             for (int green = mins[1]; green <= maxs[1]; green++) {
                 for (int blue = mins[2]; blue <= maxs[2]; blue++) {
                     // note: order reversed
-                    final int idx = (blue << (2 * precision)) 
+                    final int idx = (blue << (2 * precision))
                             | (green << (1 * precision))
                             | (red << (0 * precision));
                     final int count = table[idx];
diff --git a/src/main/java/org/apache/commons/imaging/palette/Dithering.java b/src/main/java/org/apache/commons/imaging/palette/Dithering.java
index 991c75e4..381c4310 100644
--- a/src/main/java/org/apache/commons/imaging/palette/Dithering.java
+++ b/src/main/java/org/apache/commons/imaging/palette/Dithering.java
@@ -26,7 +26,7 @@ import org.apache.commons.imaging.ImageWriteException;
 public final class Dithering {
     private Dithering() {
     }
-    
+
     /**
      * Changes the given image to only use colors from the given palette,
      * applying Floyd-Steinberg dithering in the process. Ensure that
@@ -43,12 +43,12 @@ public final class Dithering {
                 final int index = palette.getPaletteIndex(argb);
                 final int nextArgb = palette.getEntry(index);
                 image.setRGB(x, y, nextArgb);
-                
+
                 final int a = (argb >> 24) & 0xff;
                 final int r = (argb >> 16) & 0xff;
                 final int g = (argb >> 8) & 0xff;
                 final int b = argb & 0xff;
-                
+
                 final int na = (nextArgb >> 24) & 0xff;
                 final int nr = (nextArgb >> 16) & 0xff;
                 final int ng = (nextArgb >> 8) & 0xff;
@@ -58,7 +58,7 @@ public final class Dithering {
                 final int errR = r - nr;
                 final int errG = g - ng;
                 final int errB = b - nb;
-                
+
                 if (x + 1 < image.getWidth()) {
                     int update = adjustPixel(image.getRGB(x + 1, y), errA, errR, errG, errB, 7);
                     image.setRGB(x + 1, y, update);
@@ -79,7 +79,7 @@ public final class Dithering {
             }
         }
     }
-    
+
     private static int adjustPixel(final int argb, final int errA, final int errR, final int errG, final int errB, final int mul) {
         int a = (argb >> 24) & 0xff;
         int r = (argb >> 16) & 0xff;
diff --git a/src/main/java/org/apache/commons/imaging/palette/LongestAxisMedianCut.java b/src/main/java/org/apache/commons/imaging/palette/LongestAxisMedianCut.java
index 8b3b4c6b..d1751d8f 100644
--- a/src/main/java/org/apache/commons/imaging/palette/LongestAxisMedianCut.java
+++ b/src/main/java/org/apache/commons/imaging/palette/LongestAxisMedianCut.java
@@ -58,7 +58,7 @@ public class LongestAxisMedianCut implements MedianCut {
         }
         return true;
     }
-    
+
     private void doCut(final ColorGroup colorGroup, final ColorComponent mode,
             final List<ColorGroup> colorGroups, final boolean ignoreAlpha) throws ImageWriteException {
 
diff --git a/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java b/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
index aee4d724..cb8e1bab 100644
--- a/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
+++ b/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
@@ -81,7 +81,7 @@ public class MedianCutQuantizer {
         }
         throw new Error("");
     }
-    
+
     public Palette process(final BufferedImage image, final int maxColors,
             final MedianCut medianCut)
             throws ImageWriteException {
diff --git a/src/main/java/org/apache/commons/imaging/palette/MostPopulatedBoxesMedianCut.java b/src/main/java/org/apache/commons/imaging/palette/MostPopulatedBoxesMedianCut.java
index aa9eab02..f8defe95 100644
--- a/src/main/java/org/apache/commons/imaging/palette/MostPopulatedBoxesMedianCut.java
+++ b/src/main/java/org/apache/commons/imaging/palette/MostPopulatedBoxesMedianCut.java
@@ -42,9 +42,9 @@ public class MostPopulatedBoxesMedianCut implements MedianCut {
         if (colorGroup == null) {
             return false;
         }
-        
-        
-        
+
+
+
         double bestScore = Double.MAX_VALUE;
         ColorComponent bestColorComponent = null;
         int bestMedianIndex = -1;
@@ -59,9 +59,9 @@ public class MostPopulatedBoxesMedianCut implements MedianCut {
             int medianIndex;
             for (medianIndex = 0; medianIndex < colorGroup.colorCounts.size(); medianIndex++) {
                 final ColorCount colorCount = colorGroup.colorCounts.get(medianIndex);
-    
+
                 newCount += colorCount.count;
-    
+
                 if (newCount < countHalf) {
                     oldCount = newCount;
                 } else {
@@ -100,7 +100,7 @@ public class MostPopulatedBoxesMedianCut implements MedianCut {
         if (bestColorComponent == null) {
             return false;
         }
-        
+
         Collections.sort(colorGroup.colorCounts, new ColorComparer(bestColorComponent));
         final List<ColorCount> lowerColors = new ArrayList<>(
                 colorGroup.colorCounts.subList(0, bestMedianIndex + 1));
@@ -112,7 +112,7 @@ public class MostPopulatedBoxesMedianCut implements MedianCut {
         colorGroups.remove(colorGroup);
         colorGroups.add(lowerGroup);
         colorGroups.add(upperGroup);
-        
+
         final ColorCount medianValue = colorGroup.colorCounts.get(bestMedianIndex);
         int limit;
         switch (bestColorComponent) {
@@ -134,16 +134,16 @@ public class MostPopulatedBoxesMedianCut implements MedianCut {
         colorGroup.cut = new ColorGroupCut(lowerGroup, upperGroup, bestColorComponent, limit);
         return true;
     }
-    
+
     private static class ColorComparer implements Comparator<ColorCount>, Serializable {
         private static final long serialVersionUID = 1L;
-        
+
         private final ColorComponent colorComponent;
-        
+
         public ColorComparer(final ColorComponent colorComponent) {
             this.colorComponent = colorComponent;
         }
-        
+
         @Override
         public int compare(final ColorCount c1, final ColorCount c2) {
             switch (colorComponent) {
diff --git a/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java b/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
index 2bb9f2d3..d00c62a0 100644
--- a/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
+++ b/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
@@ -38,7 +38,7 @@ public class PaletteFactory {
     private static final Logger LOGGER = Logger.getLogger(PaletteFactory.class.getName());
 
     public static final int COMPONENTS = 3; // in bits
-    
+
     /**
      * Builds an exact complete opaque palette containing all the colors in {@code src},
      * using an algorithm that is faster than {@linkplain #makeExactRgbPaletteSimple} for large images
@@ -381,7 +381,7 @@ public class PaletteFactory {
 
         return new QuantizedPalette(subsets, precision);
     }
-    
+
     /**
      * Builds an inexact possibly translucent palette of at most {@code max} colors in {@code src}
      * using the traditional Median Cut algorithm. Color bounding boxes are split along the
@@ -421,7 +421,7 @@ public class PaletteFactory {
                 }
             }
         }
-        
+
         final int[] result = new int[rgbs.size()];
         int next = 0;
         for (final int rgb : rgbs) {
diff --git a/src/test/java/org/apache/commons/imaging/common/BinaryFileFunctionsTest.java b/src/test/java/org/apache/commons/imaging/common/BinaryFileFunctionsTest.java
index f5c2ab68..7f35af29 100644
--- a/src/test/java/org/apache/commons/imaging/common/BinaryFileFunctionsTest.java
+++ b/src/test/java/org/apache/commons/imaging/common/BinaryFileFunctionsTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/examples/ApacheImagingSpeedAndMemoryTest.java b/src/test/java/org/apache/commons/imaging/examples/ApacheImagingSpeedAndMemoryTest.java
index bc36953c..e6528c73 100644
--- a/src/test/java/org/apache/commons/imaging/examples/ApacheImagingSpeedAndMemoryTest.java
+++ b/src/test/java/org/apache/commons/imaging/examples/ApacheImagingSpeedAndMemoryTest.java
@@ -17,12 +17,12 @@
 
 /****************************************************************
  * Explanation of Use and Rationale For Procedures
- * 
+ *
  * This class is intended to serve as a "test stand" for loading
  * images using the Apache Imaging (nee "Sanselan") package.
  * It performs a loop that loads a specified image multiple times
  * recording both memory and time required for the loading process.
- * 
+ *
  * The notes given below explain some of the operations of this
  * test class and the reasons they were designed as they are.
  * This test is by no means to be considered the "last word" in how
@@ -31,61 +31,61 @@
  * enhancements for some of the Apache Imaging operations. But I know
  * I haven't thought of everything and am actually hoping that
  * someone will have suggestions for improvements.
- * 
- * 
+ *
+ *
  * Prerequisites to Testing  --------------------------------
- * 
- * Whenever testing software performance, particularly timing, 
+ *
+ * Whenever testing software performance, particularly timing,
  * there are a few important considerations that should be observed:
- * 
- *   a) Get a clean testing environment. In a modern computer 
+ *
+ *   a) Get a clean testing environment. In a modern computer
  *      system, there are dozens of processes running.  To whatever
  *      degree possible, make sure you are not running competing
  *      processes that will consume computer resources and contaminate
  *      your timing results.
- * 
+ *
  *   b) Make sure you are testing what you think you are testing.
  *      This guideline is especially true when comparing two different
  *      approaches.  Eliminate as many variables from the analysis
  *      as you possible can.
- * 
+ *
  *   c) When writing or modifying code, remember that no matter how
  *      obvious and self-evidentially superior a particular approach
  *      may seem, you don't really know if it's an improvement until you
  *      test it. If nothing else, the experience of computer programming
  *      teaches us to not to take anything for granted.
- * 
+ *
  *   d) Make sure the JVM is allowed a sufficiently large maximum
  *      memory size.   Putting aside the fact that the default size
  *      for the maximum memory use of the JVM could be too small for
  *      handling test images, we also want to allocate a sufficiently
  *      large memory size to ensure that it doesn't get too close to
  *      the maximum size when performing timing tests.   When the JVM
- *      detects that it is running up against the limits of its 
+ *      detects that it is running up against the limits of its
  *      maximum memory size setting, it triggers garbage collection
  *      operations that can contaminate timing values.
  *        I usually try to set the maximum memory size to be at least
- *      twice what I think I will need.  Traditionally, the memory 
+ *      twice what I think I will need.  Traditionally, the memory
  *      size for the JVM is quite modest, perhaps 256 megabytes.  You
  *      can alter that value by using something like the following
  *      specification (check your own JVM version for alternate values):
  *            -Xmx768M   (maximum of 768 megabytes)
- *      
- *  
- * 
- *  
+ *
+ *
+ *
+ *
  * What the Test Application Does and Why ----------------------
- * 
+ *
  * 0.  Functions  ------------------
  * This class reads the path to a graphics file from the command
  * line and attempts to read it several times, measuring the time
  * required to read it.   If you prefer, you may hardwire the code
  * to use a specific file.  Take whatever approach is easiest... it
  * shouldn't affect the accuracy of the results.
- * 
+ *
  * 1)  Specific Instances of Classes to Be Tested  -----------------
  * The Apache Imagine package includes a set of "parsers" for
- * reading different graphics file formats.  The package also includes 
+ * reading different graphics file formats.  The package also includes
  * a general-purpose class called "Imaging" that determines
  * the format an arbitrarily specified input
  * file and internally processes it using the appropriate parser.
@@ -93,32 +93,32 @@
  * class itself, it is better to instantiate the proper subject-matter
  * parser explicitly in your code.  In ordinary applications, it is often
  * more convenient to use the Imaging class and let it take care
- * of the details for you.  But in that "taking care of details" 
+ * of the details for you.  But in that "taking care of details"
  * operation, the Imaging class loads and instantiates a large
  * number of different subject-matter parsers.  These operations take
  * time, consume memory, and will color the results of any timing
  * and memory-use measurements you perform.
- * 
+ *
  * 2) Repetition -----------------------------------------
  * The example output from this program included below, shows that
  * it performs multiple image-loading operations, recording both
  * the time required for each individual load time and the overall
  * average time required for most of the load operations (times are
- * in milliseconds).  
- * 
+ * in milliseconds).
+ *
  *  image size: 10000 by 10000
  *  time to load image               memory
  *  time ms      avg ms         used mb   total mb
- * 15559.150     0.000    --    384.845   397.035 
- *  8544.926     0.000    --    410.981   568.723 
- *  8471.012  8471.012    --    411.563   695.723 
- *  8626.015  8548.513    --    384.791   397.039 
- * 
- * Note that in the example output, the times for the first two load 
+ * 15559.150     0.000    --    384.845   397.035
+ *  8544.926     0.000    --    410.981   568.723
+ *  8471.012  8471.012    --    411.563   695.723
+ *  8626.015  8548.513    --    384.791   397.039
+ *
+ * Note that in the example output, the times for the first two load
  * operations are not included in the average.  The reason for this is
  * that the first time a Java application performs some operation,
  * it is likely to take a little longer than for subsequent
- * operations due to the overhead for class loading and the 
+ * operations due to the overhead for class loading and the
  * just-in-time (JIT) compiler.  Unless you're specifically interested
  * in measuring the cost of start-up operations, the time they take
  * will contaminate any timing values for the functions of interest.
@@ -127,23 +127,23 @@
  * carry over into the second.  In either case, two loop iterations
  * has proven to be enough to isolate the start costs... but keep an eye
  * on the individual times to make sure nothing unwanted is happening.
- * 
+ *
  * 3) Clean Up Memory Between Load Operations --------------------
  * This test application specifically invokes the garbage collection
  * method provided by the Java Runtime class.  It then executes a one-second
  * sleep operation.
- *    Recall that in Java, the JVM performs garbage collection in a 
+ *    Recall that in Java, the JVM performs garbage collection in a
  * separate thread that runs whenever Java thinks it important to do so.
  * We want to do what we can to ensure that the garbage collection operation,
  * which consumes processor resources, doesn't do so while the application
- * is loading an image.  To that end, the application invokes 
- * Runtime.gc() and then allows the JVM one second to initiate and 
+ * is loading an image.  To that end, the application invokes
+ * Runtime.gc() and then allows the JVM one second to initiate and
  * complete the garbage collection.  However, the .gc() method is, at best,
  * a "suggestion" that the JVM should run garbage collection.
  * It does not guarantee that the garbage collection will be executed and
  * completed immediately.  Thus the relatively long one-second delay
  * between loop iterations.
- * 
+ *
  * ---------------------------------------------------------------------
  * Good luck in using the class for testing.
  * Feel free to modify it to suit your own requirements... Nothing
@@ -151,7 +151,7 @@
  * well for you.
  *                Gary Lucas --  May 2012.
  * ---------------------------------------------------------------
- * 
+ *
  */
 package org.apache.commons.imaging.examples;
 
@@ -174,7 +174,7 @@ public class ApacheImagingSpeedAndMemoryTest {
     /**
      * Create an instance of the speed and memory test class and execute a test
      * loop for the specified file.
-     * 
+     *
      * @param args
      *            the path to the file to be processed
      */
@@ -189,7 +189,7 @@ public class ApacheImagingSpeedAndMemoryTest {
     /**
      * Loads the input file multiple times, measuring the time and memory use
      * for each iteration.
-     * 
+     *
      * @param name
      *            the path for the input image file to be tested
      */
diff --git a/src/test/java/org/apache/commons/imaging/examples/WriteExifMetadataExample.java b/src/test/java/org/apache/commons/imaging/examples/WriteExifMetadataExample.java
index 34725474..f0dd4f51 100644
--- a/src/test/java/org/apache/commons/imaging/examples/WriteExifMetadataExample.java
+++ b/src/test/java/org/apache/commons/imaging/examples/WriteExifMetadataExample.java
@@ -46,7 +46,7 @@ public class WriteExifMetadataExample {
 
     /**
      * This example illustrates how to add/update EXIF metadata in a JPEG file.
-     * 
+     *
      * @param jpegImageFile
      *            A source image file.
      * @param dst
@@ -57,10 +57,10 @@ public class WriteExifMetadataExample {
      */
     public void changeExifMetadata(final File jpegImageFile, final File dst)
             throws IOException, ImageReadException, ImageWriteException {
-        
+
         try (FileOutputStream fos = new FileOutputStream(dst);
                 OutputStream os = new BufferedOutputStream(fos);) {
-            
+
             TiffOutputSet outputSet = null;
 
             // note that metadata might be null if no metadata is found.
@@ -133,10 +133,10 @@ public class WriteExifMetadataExample {
     /**
      * This example illustrates how to remove a tag (if present) from EXIF
      * metadata in a JPEG file.
-     * 
+     *
      * In this case, we remove the "aperture" tag from the EXIF metadata if
      * present.
-     * 
+     *
      * @param jpegImageFile
      *            A source image file.
      * @param dst
@@ -209,7 +209,7 @@ public class WriteExifMetadataExample {
 
     /**
      * This example illustrates how to set the GPS values in JPEG EXIF metadata.
-     * 
+     *
      * @param jpegImageFile
      *            A source image file.
      * @param dst
diff --git a/src/test/java/org/apache/commons/imaging/formats/jpeg/JpegReadTest.java b/src/test/java/org/apache/commons/imaging/formats/jpeg/JpegReadTest.java
index a37dff53..039ae4d6 100644
--- a/src/test/java/org/apache/commons/imaging/formats/jpeg/JpegReadTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/jpeg/JpegReadTest.java
@@ -60,12 +60,12 @@ public class JpegReadTest extends JpegBaseTest {
         // TODO only run this tests with images that have metadata...
         //assertNotNull(metadata);
         Debug.debug("metadata", metadata);
-        
+
         Debug.debug("ICC profile", Imaging.getICCProfile(imageFile, params));
 
         final ImageInfo imageInfo = Imaging.getImageInfo(imageFile, params);
         assertNotNull(imageInfo);
-        
+
         try {
             final BufferedImage image = Imaging.getBufferedImage(imageFile, params);
             assertNotNull(image);
diff --git a/src/test/java/org/apache/commons/imaging/formats/jpeg/exif/MicrosoftTagTest.java b/src/test/java/org/apache/commons/imaging/formats/jpeg/exif/MicrosoftTagTest.java
index ea6b7dc0..2814983c 100644
--- a/src/test/java/org/apache/commons/imaging/formats/jpeg/exif/MicrosoftTagTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/jpeg/exif/MicrosoftTagTest.java
@@ -64,7 +64,7 @@ public class MicrosoftTagTest extends ExifBaseTest {
         final byte[] bytes = Imaging.writeImageToBytes(image, ImageFormats.TIFF, params);
         checkFields(bytes);
     }
-    
+
     private TiffImageMetadata toTiffMetadata(final ImageMetadata metadata) throws Exception {
         if (metadata instanceof JpegImageMetadata) {
             return ((JpegImageMetadata)metadata).getExif();
@@ -76,7 +76,7 @@ public class MicrosoftTagTest extends ExifBaseTest {
     }
 
     private byte[] cleanImage(final File imageWithExif) throws ImageReadException, ImageWriteException, IOException {
-        // Windows doesn't show XP tags if same-meaning tags exist in IPTC or XMP. Remove them: 
+        // Windows doesn't show XP tags if same-meaning tags exist in IPTC or XMP. Remove them:
         final ByteArrayOutputStream noXmp = new ByteArrayOutputStream();
         new JpegXmpRewriter().removeXmpXml(imageWithExif, noXmp);
         final ByteArrayOutputStream noXmpNoIptc = new ByteArrayOutputStream();
@@ -92,32 +92,32 @@ public class MicrosoftTagTest extends ExifBaseTest {
         final ExifRewriter rewriter = new ExifRewriter();
         final TiffOutputSet outputSet = metadata.getOutputSet();
         final TiffOutputDirectory root = outputSet.getOrCreateRootDirectory();
-        
+
         // In Windows these will also hide XP fields:
         root.removeField(TiffTagConstants.TIFF_TAG_IMAGE_DESCRIPTION);
         root.removeField(TiffTagConstants.TIFF_TAG_ARTIST);
-        
+
         // Duplicates can be a problem:
         root.removeField(MicrosoftTagConstants.EXIF_TAG_XPAUTHOR);
         root.add(MicrosoftTagConstants.EXIF_TAG_XPAUTHOR, AUTHOR);
-        
+
         root.removeField(MicrosoftTagConstants.EXIF_TAG_XPCOMMENT);
         root.add(MicrosoftTagConstants.EXIF_TAG_XPCOMMENT, COMMENT);
-        
+
         root.removeField(MicrosoftTagConstants.EXIF_TAG_XPSUBJECT);
         root.add(MicrosoftTagConstants.EXIF_TAG_XPSUBJECT, SUBJECT);
-        
+
         root.removeField(MicrosoftTagConstants.EXIF_TAG_XPTITLE);
         root.add(MicrosoftTagConstants.EXIF_TAG_XPTITLE, TITLE);
-        
+
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         rewriter.updateExifMetadataLossy(imageWithExif, baos, outputSet);
         checkFields(baos.toByteArray());
     }
-    
+
     private void checkFields(final byte[] file) throws Exception {
         final TiffImageMetadata metadata = toTiffMetadata(Imaging.getMetadata(file));
-        
+
         // field values may be duplicated between directories, we have to check all
         final List<Object> authorValues = new ArrayList<>();
         final List<Object> commentValues = new ArrayList<>();
@@ -129,7 +129,7 @@ public class MicrosoftTagTest extends ExifBaseTest {
             commentValues.add(d.getFieldValue(MicrosoftTagConstants.EXIF_TAG_XPCOMMENT, false));
             subjectValues.add(d.getFieldValue(MicrosoftTagConstants.EXIF_TAG_XPSUBJECT, false));
         }
-        
+
         assertTrue(authorValues.contains(AUTHOR));
         assertTrue(commentValues.contains(COMMENT));
         assertTrue(subjectValues.contains(SUBJECT));
diff --git a/src/test/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcUpdateTest.java b/src/test/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcUpdateTest.java
index 863435aa..adb40b42 100644
--- a/src/test/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcUpdateTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcUpdateTest.java
@@ -71,10 +71,10 @@ public class IptcUpdateTest extends IptcBaseTest {
         assertNotNull(metadata);
 
         final File noIptcFile = removeIptc(byteSource);
-        
+
         final JpegPhotoshopMetadata outMetadata = new JpegImageParser().getPhotoshopMetadata(
                 new ByteSourceFile(noIptcFile), params);
-        
+
         // FIXME should either be null or empty
         assertTrue(outMetadata == null
                 || outMetadata.getItems().size() == 0);
diff --git a/src/test/java/org/apache/commons/imaging/formats/png/PngReadTest.java b/src/test/java/org/apache/commons/imaging/formats/png/PngReadTest.java
index 4e9d4993..88c6a4da 100644
--- a/src/test/java/org/apache/commons/imaging/formats/png/PngReadTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/png/PngReadTest.java
@@ -68,7 +68,7 @@ public class PngReadTest extends PngBaseTest {
                 assertNotNull(imageInfo);
 
                 Debug.debug("ICC profile", Imaging.getICCProfile(imageFile));
-                
+
                 final BufferedImage image = Imaging.getBufferedImage(imageFile);
                 assertNotNull(image);
             }
diff --git a/src/test/java/org/apache/commons/imaging/formats/pnm/PbmFileInfoTest.java b/src/test/java/org/apache/commons/imaging/formats/pnm/PbmFileInfoTest.java
index f69dea34..8963eaf6 100644
--- a/src/test/java/org/apache/commons/imaging/formats/pnm/PbmFileInfoTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/pnm/PbmFileInfoTest.java
@@ -34,7 +34,7 @@ public class PbmFileInfoTest{
       InputStream inputStream = new ByteArrayInputStream(byteArray);
       inputStream.read(byteArray);
 
-      try { 
+      try {
         pbmFileInfo.getRGB(inputStream);
         fail("Expecting exception: IOException");
       } catch(IOException e) {
diff --git a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffCcittTest.java b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffCcittTest.java
index 10dc5993..a8e70889 100644
--- a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffCcittTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffCcittTest.java
@@ -301,7 +301,7 @@ public class TiffCcittTest extends TiffBaseTest {
      * Generates the next combination of elements in the sequence array, with
      * each element having a maximum value of max. Initially, the sequence
      * should be set to minimum values of each element.
-     * 
+     *
      * @param sequence
      *            the array of elements to update
      * @param max
diff --git a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadWriteTagsTest.java b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadWriteTagsTest.java
index 8f69a5f4..f395a2b3 100644
--- a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadWriteTagsTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadWriteTagsTest.java
@@ -50,7 +50,7 @@ public class TiffReadWriteTagsTest extends TiffBaseTest {
         final String area = "A good area";
         final float widthRes = 2.2f;
         final double geoDoubleParams = -8.4;
-        
+
         final TiffOutputSet set = new TiffOutputSet();
         final TiffOutputDirectory dir = set.getOrCreateRootDirectory();
         dir.add(TiffTagConstants.TIFF_TAG_IMAGE_DESCRIPTION, description);
@@ -62,11 +62,11 @@ public class TiffReadWriteTagsTest extends TiffBaseTest {
         dir.add(GpsTagConstants.GPS_TAG_GPS_AREA_INFORMATION, area);
         dir.add(MicrosoftHdPhotoTagConstants.EXIF_TAG_WIDTH_RESOLUTION, widthRes);
         dir.add(GeoTiffTagConstants.EXIF_TAG_GEO_DOUBLE_PARAMS_TAG, geoDoubleParams);
-        
+
         final TiffImageWriterLossy writer = new TiffImageWriterLossy();
         final ByteArrayOutputStream tiff = new ByteArrayOutputStream();
         writer.write(tiff, set);
-        
+
         final TiffReader reader = new TiffReader(true);
         final Map<String, Object> params = new TreeMap<>();
         final FormatCompliance formatCompliance = new FormatCompliance("");
diff --git a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffSubImageTest.java b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffSubImageTest.java
index 6aad65d1..ec6537ec 100644
--- a/src/test/java/org/apache/commons/imaging/formats/tiff/TiffSubImageTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/tiff/TiffSubImageTest.java
@@ -36,7 +36,7 @@ public class TiffSubImageTest extends TiffBaseTest {
     public void testSubImage() throws ImageReadException, ImageWriteException, IOException {
         final BufferedImage src = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
         final byte[] imageBytes = Imaging.writeImageToBytes(src, ImageFormats.TIFF, null);
-        
+
         final Map<String, Object> params = new TreeMap<>();
         params.put(TiffConstants.PARAM_KEY_SUBIMAGE_X, 0);
         params.put(TiffConstants.PARAM_KEY_SUBIMAGE_Y, 0);
diff --git a/src/test/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldTypeTest.java b/src/test/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldTypeTest.java
index bfe732b6..762a185b 100644
--- a/src/test/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldTypeTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/tiff/fieldtypes/FieldTypeTest.java
@@ -25,7 +25,7 @@ public class FieldTypeTest{
 
   @Test
   public void testGetFieldTypeWithNegative() {
-      try { 
+      try {
         FieldType.getFieldType((-748));
         fail("Expecting exception: Exception");
       } catch(Exception e) {
diff --git a/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpBaseTest.java b/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpBaseTest.java
index 32ff33c5..15450bdc 100644
--- a/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpBaseTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpBaseTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpReadTest.java b/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpReadTest.java
index 564a3773..6b956ab1 100644
--- a/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpReadTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/wbmp/WbmpReadTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/formats/xbm/XbmBaseTest.java b/src/test/java/org/apache/commons/imaging/formats/xbm/XbmBaseTest.java
index 9dde918d..d42b67c2 100644
--- a/src/test/java/org/apache/commons/imaging/formats/xbm/XbmBaseTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/xbm/XbmBaseTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/formats/xbm/XbmReadTest.java b/src/test/java/org/apache/commons/imaging/formats/xbm/XbmReadTest.java
index dcdd4a58..0365c4b5 100644
--- a/src/test/java/org/apache/commons/imaging/formats/xbm/XbmReadTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/xbm/XbmReadTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/formats/xpm/XpmBaseTest.java b/src/test/java/org/apache/commons/imaging/formats/xpm/XpmBaseTest.java
index 7fae8f21..d6946ac9 100644
--- a/src/test/java/org/apache/commons/imaging/formats/xpm/XpmBaseTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/xpm/XpmBaseTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/formats/xpm/XpmReadTest.java b/src/test/java/org/apache/commons/imaging/formats/xpm/XpmReadTest.java
index 2f113fa0..d6248c26 100644
--- a/src/test/java/org/apache/commons/imaging/formats/xpm/XpmReadTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/xpm/XpmReadTest.java
@@ -2,9 +2,9 @@
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
  *  You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/imaging/palette/PaletteQuantizationTest.java b/src/test/java/org/apache/commons/imaging/palette/PaletteQuantizationTest.java
index 994c1085..dbf8c276 100644
--- a/src/test/java/org/apache/commons/imaging/palette/PaletteQuantizationTest.java
+++ b/src/test/java/org/apache/commons/imaging/palette/PaletteQuantizationTest.java
@@ -35,7 +35,7 @@ public class PaletteQuantizationTest extends ImagingTest {
             }
         }
         checkPaletteDetails(whiteImage, 10, 1);
-        
+
         final BufferedImage whiteAndBlackImage = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
         for (int y = 0; y < whiteImage.getHeight(); y++) {
             for (int x = 0; x < 5; x++) {
@@ -46,7 +46,7 @@ public class PaletteQuantizationTest extends ImagingTest {
             }
         }
         checkPaletteDetails(whiteAndBlackImage, 10, 2);
-        
+
         final BufferedImage rainbowImage = new BufferedImage(9, 10, BufferedImage.TYPE_INT_RGB);
         for (int y = 0; y < whiteImage.getHeight(); y++) {
             for (int x = 0; x < 3; x++) {
@@ -62,7 +62,7 @@ public class PaletteQuantizationTest extends ImagingTest {
         checkPaletteDetails(rainbowImage, 10, 3);
         checkPaletteDetails(rainbowImage, 2, 2);
     }
-    
+
     private void checkPaletteDetails(final BufferedImage image, final int limit, final int expectedSize) throws ImageWriteException {
         final PaletteFactory paletteFactory = new PaletteFactory();
         Palette palette;
@@ -85,14 +85,14 @@ public class PaletteQuantizationTest extends ImagingTest {
         if (exact) {
             checkPixelsAreIdentical(image, palette);
         }
-        
+
         palette = paletteFactory.makeQuantizedRgbPalette(image, limit);
         assertEquals(expectedSize, palette.length());
         //checkUniqueColors(image, palette);
         if (exact) {
             //checkDithering(image, palette);
         }
-        
+
         final MedianCutQuantizer medianCutQuantizer = new MedianCutQuantizer(true);
         palette = medianCutQuantizer.process(
                 image, limit, new MostPopulatedBoxesMedianCut());
@@ -102,7 +102,7 @@ public class PaletteQuantizationTest extends ImagingTest {
             checkPixelsAreIdentical(image, palette);
         }
     }
-    
+
     private void checkUniqueColors(final BufferedImage src, final Palette palette) throws ImageWriteException {
         final BufferedImage dst = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_RGB);
         dst.getGraphics().drawImage(src, 0, 0, src.getWidth(), src.getHeight(), null);
@@ -110,7 +110,7 @@ public class PaletteQuantizationTest extends ImagingTest {
         final Palette ditheredPalette = new PaletteFactory().makeExactRgbPaletteSimple(dst, palette.length() * 2);
         assertEquals(palette.length(), ditheredPalette.length());
     }
-    
+
     private void checkPixelsAreIdentical(final BufferedImage src, final Palette palette) throws ImageWriteException {
         final BufferedImage dst = new BufferedImage(src.getWidth(), src.getHeight(), BufferedImage.TYPE_INT_RGB);
         dst.getGraphics().drawImage(src, 0, 0, src.getWidth(), src.getHeight(), null);
diff --git a/src/test/java/org/apache/commons/imaging/roundtrip/ImageAsserts.java b/src/test/java/org/apache/commons/imaging/roundtrip/ImageAsserts.java
index 6ea7829f..f6f9c309 100644
--- a/src/test/java/org/apache/commons/imaging/roundtrip/ImageAsserts.java
+++ b/src/test/java/org/apache/commons/imaging/roundtrip/ImageAsserts.java
@@ -31,7 +31,7 @@ final class ImageAsserts {
 
     private ImageAsserts() {
     }
-    
+
     static void assertEquals(final BufferedImage a, final BufferedImage b) {
         assertEquals(a, b, 0);
     }
