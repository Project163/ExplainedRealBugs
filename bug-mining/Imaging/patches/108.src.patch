diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c4b71fff..58e627cf 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -45,6 +45,9 @@ The <action> type attribute can be add,update,fix,remove.
   </properties>
   <body>
     <release version="1.0-alpha3" date="2020-??-??" description="Third 1.0 alpha release">
+      <action issue="IMAGING-265" dev="kinow" type="fix" due-to="Gary Lucas">
+        ArrayIndexOutOfBoundsException on reading simple GeoTIFF.
+      </action>
       <action dev="kinow" type="update" due-to="Dependabot">
         Bump actions/setup-java from v1.4.0 to v1.4.3 #92 #95 #101.
       </action>
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
index 8fae0502..325b5336 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageData.java
@@ -21,6 +21,7 @@ import java.nio.ByteOrder;
 
 import org.apache.commons.imaging.ImageReadException;
 import org.apache.commons.imaging.common.bytesource.ByteSourceFile;
+import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;
 import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;
 import org.apache.commons.imaging.formats.tiff.datareaders.ImageDataReader;
 import org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips;
@@ -53,14 +54,17 @@ public abstract class TiffImageData {
 
         @Override
         public ImageDataReader getDataReader(final TiffDirectory directory,
-                final PhotometricInterpreter photometricInterpreter,
-                final int bitsPerPixel, final int[] bitsPerSample, final int predictor,
-                final int samplesPerPixel, final int width, final int height, final int compression,
-            final ByteOrder byteOrder) throws IOException, ImageReadException {
+          final PhotometricInterpreter photometricInterpreter,
+          final int bitsPerPixel, final int[] bitsPerSample, final int predictor,
+          final int samplesPerPixel, final int width, final int height,
+          final int compression,
+          final TiffPlanarConfiguration planarConfiguration,
+          final ByteOrder byteOrder) throws IOException, ImageReadException {
             int sampleFormat = extractSampleFormat(directory);
             return new DataReaderTiled(directory, photometricInterpreter,
-                    tileWidth, tileLength, bitsPerPixel, bitsPerSample,
-                predictor, samplesPerPixel, sampleFormat, width, height, compression,                    byteOrder, this);
+              tileWidth, tileLength, bitsPerPixel, bitsPerSample,
+              predictor, samplesPerPixel, sampleFormat, width, height, compression,
+              planarConfiguration, byteOrder, this);
         }
 
         /**
@@ -119,29 +123,31 @@ public abstract class TiffImageData {
 
         @Override
         public ImageDataReader getDataReader(final TiffDirectory directory,
-                final PhotometricInterpreter photometricInterpreter,
-                final int bitsPerPixel, final int[] bitsPerSample, final int predictor,
-                final int samplesPerPixel, final int width, final int height, final int compression,
-            final ByteOrder byteorder) throws IOException, ImageReadException {
+          final PhotometricInterpreter photometricInterpreter,
+          final int bitsPerPixel, final int[] bitsPerSample, final int predictor,
+          final int samplesPerPixel, final int width, final int height,
+          final int compression,
+          final TiffPlanarConfiguration planarConfiguration,
+          final ByteOrder byteorder) throws IOException, ImageReadException {
             int sampleFormat = extractSampleFormat(directory);
             return new DataReaderStrips(directory, photometricInterpreter,
-                bitsPerPixel, bitsPerSample, predictor, samplesPerPixel, sampleFormat,
-                width, height, compression, byteorder, rowsPerStrip, this);
+              bitsPerPixel, bitsPerSample, predictor,
+              samplesPerPixel, sampleFormat, width, height,
+              compression, planarConfiguration, byteorder, rowsPerStrip, this);
         }
 
     }
 
-    // public abstract TiffElement[] getElements();
-
     public abstract TiffElement.DataElement[] getImageData();
 
     public abstract boolean stripsNotTiles();
 
     public abstract ImageDataReader getDataReader(TiffDirectory directory,
-            PhotometricInterpreter photometricInterpreter, int bitsPerPixel,
-            int[] bitsPerSample, int predictor, int samplesPerPixel, int width,
-            int height, int compression, ByteOrder byteOrder) throws IOException,
-            ImageReadException;
+      PhotometricInterpreter photometricInterpreter, int bitsPerPixel,
+      int[] bitsPerSample, int predictor, int samplesPerPixel, int width,
+      int height, int compression,
+      TiffPlanarConfiguration planarConfiguration,
+      ByteOrder byteOrder) throws IOException, ImageReadException;
 
     public static class Data extends TiffElement.DataElement {
         public Data(final long offset, final int length, final byte[] data) {
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
index dfe7e4e1..4e65550b 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java
@@ -51,6 +51,7 @@ import org.apache.commons.imaging.common.bytesource.ByteSource;
 import org.apache.commons.imaging.formats.tiff.TiffDirectory.ImageDataElement;
 import org.apache.commons.imaging.formats.tiff.constants.TiffConstants;
 import org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants;
+import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;
 import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;
 import org.apache.commons.imaging.formats.tiff.datareaders.ImageDataReader;
 import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter;
@@ -649,11 +650,34 @@ public class TiffImageParser extends ImageParser implements XmpEmbeddable {
                 bitsPerSample, predictor, samplesPerPixel, width, height);
         }
 
+        // Obtain the planar configuration
+        final TiffField pcField = directory.findField(
+          TiffTagConstants.TIFF_TAG_PLANAR_CONFIGURATION);
+        final TiffPlanarConfiguration planarConfiguration
+          = pcField == null
+            ? TiffPlanarConfiguration.CHUNKY
+            : TiffPlanarConfiguration.lenientValueOf(pcField.getIntValue());
+
+        if (planarConfiguration == TiffPlanarConfiguration.PLANAR) {
+            // currently, we support the non-interleaved (non-chunky)
+            // option only in the case of a 24-bit RBG photometric interpreter
+            // and for strips (not for tiles).
+            if (photometricInterpretation
+              != TiffTagConstants.PHOTOMETRIC_INTERPRETATION_VALUE_RGB
+              || bitsPerPixel != 24) {
+                throw new ImageReadException("For planar configuration 2, only 24 bit RGB is currently supported");
+            }
+            if (null == directory.findField(TiffTagConstants.TIFF_TAG_STRIP_OFFSETS)) {
+                throw new ImageReadException("For planar configuration 2, only strips-organization is supported");
+            }
+        }
+
         final TiffImageData imageData = directory.getTiffImageData();
 
         final ImageDataReader dataReader = imageData.getDataReader(directory,
                 photometricInterpreter, bitsPerPixel, bitsPerSample, predictor,
-                samplesPerPixel, width, height, compression, byteOrder);
+          samplesPerPixel, width, height, compression,
+          planarConfiguration, byteOrder);
 
         BufferedImage result = null;
         if (subImage != null) {
@@ -897,8 +921,9 @@ public class TiffImageParser extends ImageParser implements XmpEmbeddable {
         final TiffImageData imageData = directory.getTiffImageData();
 
         final ImageDataReader dataReader = imageData.getDataReader(directory,
-            photometricInterpreter, bitsPerPixel, bitsPerSample, predictor,
-            samplesPerPixel, width, height, compression, byteOrder);
+          photometricInterpreter, bitsPerPixel, bitsPerSample, predictor,
+          samplesPerPixel, width, height, compression,
+          TiffPlanarConfiguration.CHUNKY, byteOrder);
 
         return dataReader.readRasterData(subImage);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffPlanarConfiguration.java b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffPlanarConfiguration.java
new file mode 100644
index 00000000..ac74f8b3
--- /dev/null
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/constants/TiffPlanarConfiguration.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff.constants;
+
+/**
+ * Defines options for the organization of data in a TIFF file.
+ */
+public enum TiffPlanarConfiguration {
+
+    /**
+     * Indicates that data is stored in an interleaved format,
+     * so that component values for each pixel are contiguous in the file.
+     */
+    CHUNKY(TiffTagConstants.PLANAR_CONFIGURATION_VALUE_CHUNKY),
+    /**
+     * Indicates that data is stored in a non-interleaved format,
+     * component values for each pixel are separated into distinct
+     * planes.
+     */
+    PLANAR(TiffTagConstants.PLANAR_CONFIGURATION_VALUE_PLANAR);
+
+    /**
+     * The integer code values used for indicating the planar configuration
+     * in a TIFF file.
+     */
+    public final int codeValue;
+
+    /**
+     *
+     * @param codeValue format-indicator value for use in file.
+     */
+    TiffPlanarConfiguration(final int codeValue) {
+        this.codeValue = codeValue;
+    }
+
+    /**
+     * Interprets an integer code value to determine the enumerated value.
+     * Implements lenient rules for handling non-compliant values.
+     *
+     * @param codeValue an integer code corresponding to the TIFF specification.
+     * @return a valid enumeration.
+     */
+    public static TiffPlanarConfiguration lenientValueOf(int codeValue) {
+        switch (codeValue) {
+            case TiffTagConstants.PLANAR_CONFIGURATION_VALUE_CHUNKY:
+                return CHUNKY;
+            case TiffTagConstants.PLANAR_CONFIGURATION_VALUE_PLANAR:
+                return PLANAR;
+            default:
+                return CHUNKY;
+        }
+    }
+}
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
index 652d8a35..9967c6e9 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java
@@ -28,6 +28,7 @@ import org.apache.commons.imaging.common.ImageBuilder;
 import org.apache.commons.imaging.formats.tiff.TiffRasterData;
 import org.apache.commons.imaging.formats.tiff.TiffDirectory;
 import org.apache.commons.imaging.formats.tiff.TiffImageData;
+import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;
 import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;
 import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter;
 import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterRgb;
@@ -43,23 +44,27 @@ public final class DataReaderStrips extends ImageDataReader {
     private final int bitsPerPixel;
     private final int compression;
     private final int rowsPerStrip;
+    private final TiffPlanarConfiguration planarConfiguration;
     private final ByteOrder byteOrder;
     private int x;
     private int y;
     private final TiffImageData.Strips imageData;
 
     public DataReaderStrips(final TiffDirectory directory,
-            final PhotometricInterpreter photometricInterpreter, final int bitsPerPixel,
-        final int[] bitsPerSample, final int predictor,
-        final int samplesPerPixel, final int sampleFormat, final int width,
-        final int height, final int compression, final ByteOrder byteOrder, final int rowsPerStrip,
-        final TiffImageData.Strips imageData) {
+      final PhotometricInterpreter photometricInterpreter, final int bitsPerPixel,
+      final int[] bitsPerSample, final int predictor,
+      final int samplesPerPixel, final int sampleFormat, final int width,
+      final int height, final int compression,
+      final TiffPlanarConfiguration planarConfiguration,
+      final ByteOrder byteOrder,
+      final int rowsPerStrip, final TiffImageData.Strips imageData) {
         super(directory, photometricInterpreter, bitsPerSample, predictor,
             samplesPerPixel, sampleFormat, width, height);
 
         this.bitsPerPixel = bitsPerPixel;
         this.compression = compression;
         this.rowsPerStrip = rowsPerStrip;
+        this.planarConfiguration = planarConfiguration;
         this.imageData = imageData;
         this.byteOrder = byteOrder;
     }
@@ -237,27 +242,51 @@ public final class DataReaderStrips extends ImageDataReader {
 
     @Override
     public void readImageData(final ImageBuilder imageBuilder)
-            throws ImageReadException, IOException {
-        for (int strip = 0; strip < imageData.getImageDataLength(); strip++) {
-            final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
-            final long rowsRemaining = height - (strip * rowsPerStripLong);
-            final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
-            final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
-            final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
-            final long pixelsPerStrip = rowsInThisStrip * width;
-
-            final byte[] compressed = imageData.getImageData(strip).getData();
-
-            final byte[] decompressed = decompress(compressed, compression,
-                    (int) bytesPerStrip, width, (int) rowsInThisStrip);
-
-            interpretStrip(
-                    imageBuilder,
-                    decompressed,
-                    (int) pixelsPerStrip,
-                    height);
-
+      throws ImageReadException, IOException {
+        if (planarConfiguration != TiffPlanarConfiguration.PLANAR) {
+            for (int strip = 0; strip < imageData.getImageDataLength(); strip++) {
+                final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
+                final long rowsRemaining = height - (strip * rowsPerStripLong);
+                final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
+                final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
+                final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
+                final long pixelsPerStrip = rowsInThisStrip * width;
+
+                final byte[] compressed = imageData.getImageData(strip).getData();
+                final byte[] decompressed = decompress(compressed, compression,
+                  (int) bytesPerStrip, width, (int) rowsInThisStrip);
+                interpretStrip(
+                  imageBuilder,
+                  decompressed,
+                  (int) pixelsPerStrip,
+                  height);
+            }
+        } else {
+            int nStripsInPlane = imageData.getImageDataLength() / 3;
+            for (int strip = 0; strip < nStripsInPlane; strip++) {
+                final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
+                final long rowsRemaining = height - (strip * rowsPerStripLong);
+                final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
+                final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
+                final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
+                final long pixelsPerStrip = rowsInThisStrip * width;
+
+                byte[] b = new byte[(int) bytesPerStrip];
+                for (int iPlane = 0; iPlane < 3; iPlane++) {
+                    int planeStrip = iPlane * nStripsInPlane + strip;
+                    final byte[] compressed = imageData.getImageData(planeStrip).getData();
+                    final byte[] decompressed = decompress(compressed, compression,
+                      (int) bytesPerStrip, width, (int) rowsInThisStrip);
+                    int index = iPlane;
+                    for (int i = 0; i < decompressed.length; i++) {
+                        b[index] = decompressed[i];
+                        index += 3;
+                    }
+                }
+                interpretStrip(imageBuilder, b, (int) pixelsPerStrip, height);
+            }
         }
+
     }
 
 
@@ -291,25 +320,50 @@ public final class DataReaderStrips extends ImageDataReader {
         //        or working
         final ImageBuilder workingBuilder =
                 new ImageBuilder(width, workingHeight, false);
-
-        for (int strip = strip0; strip <= strip1; strip++) {
-            final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
-            final long rowsRemaining = height - (strip * rowsPerStripLong);
-            final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
-            final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
-            final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
-            final long pixelsPerStrip = rowsInThisStrip * width;
-
-            final byte[] compressed = imageData.getImageData(strip).getData();
-
-            final byte[] decompressed = decompress(compressed, compression,
-                    (int) bytesPerStrip, width, (int) rowsInThisStrip);
-
-            interpretStrip(
-                    workingBuilder,
-                    decompressed,
-                    (int) pixelsPerStrip,
-                    yLimit);
+        if (planarConfiguration != TiffPlanarConfiguration.PLANAR) {
+            for (int strip = strip0; strip <= strip1; strip++) {
+                final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
+                final long rowsRemaining = height - (strip * rowsPerStripLong);
+                final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
+                final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
+                final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
+                final long pixelsPerStrip = rowsInThisStrip * width;
+
+                final byte[] compressed = imageData.getImageData(strip).getData();
+
+                final byte[] decompressed = decompress(compressed, compression,
+                  (int) bytesPerStrip, width, (int) rowsInThisStrip);
+
+                interpretStrip(
+                  workingBuilder,
+                  decompressed,
+                  (int) pixelsPerStrip,
+                  yLimit);
+            }
+        } else {
+            int nStripsInPlane = imageData.getImageDataLength() / 3;
+            for (int strip = strip0; strip <= strip1; strip++) {
+                final long rowsPerStripLong = 0xFFFFffffL & rowsPerStrip;
+                final long rowsRemaining = height - (strip * rowsPerStripLong);
+                final long rowsInThisStrip = Math.min(rowsRemaining, rowsPerStripLong);
+                final long bytesPerRow = (bitsPerPixel * width + 7) / 8;
+                final long bytesPerStrip = rowsInThisStrip * bytesPerRow;
+                final long pixelsPerStrip = rowsInThisStrip * width;
+
+                byte[] b = new byte[(int) bytesPerStrip];
+                for (int iPlane = 0; iPlane < 3; iPlane++) {
+                    int planeStrip = iPlane * nStripsInPlane + strip;
+                    final byte[] compressed = imageData.getImageData(planeStrip).getData();
+                    final byte[] decompressed = decompress(compressed, compression,
+                      (int) bytesPerStrip, width, (int) rowsInThisStrip);
+                    int index = iPlane;
+                    for (int i = 0; i < decompressed.length; i++) {
+                        b[index] = decompressed[i];
+                        index += 3;
+                    }
+                }
+                interpretStrip(workingBuilder, b, (int) pixelsPerStrip, height);
+            }
         }
 
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
index 9b8903bf..35e514c7 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java
@@ -35,6 +35,7 @@ import org.apache.commons.imaging.formats.tiff.TiffRasterData;
 import org.apache.commons.imaging.formats.tiff.TiffDirectory;
 import org.apache.commons.imaging.formats.tiff.TiffElement.DataElement;
 import org.apache.commons.imaging.formats.tiff.TiffImageData;
+import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;
 import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;
 import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter;
 import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterRgb;
@@ -55,10 +56,13 @@ public final class DataReaderTiled extends ImageDataReader {
     private final TiffImageData.Tiles imageData;
 
     public DataReaderTiled(final TiffDirectory directory,
-            final PhotometricInterpreter photometricInterpreter, final int tileWidth,
-            final int tileLength, final int bitsPerPixel, final int[] bitsPerSample,
-        final int predictor, final int samplesPerPixel, final int sampleFormat,
-        final int width, final int height,            final int compression, final ByteOrder byteOrder, final TiffImageData.Tiles imageData) {
+      final PhotometricInterpreter photometricInterpreter, final int tileWidth,
+      final int tileLength, final int bitsPerPixel, final int[] bitsPerSample,
+      final int predictor, final int samplesPerPixel, final int sampleFormat,
+      final int width, final int height,
+      final int compression,
+      final TiffPlanarConfiguration planarConfiguration,
+      final ByteOrder byteOrder, final TiffImageData.Tiles imageData) {
         super(directory, photometricInterpreter, bitsPerSample, predictor,
             samplesPerPixel, sampleFormat, width, height);
 
diff --git a/src/test/data/images/tiff/10/Imaging265.tiff b/src/test/data/images/tiff/10/Imaging265.tiff
new file mode 100644
index 00000000..5c4b7c09
Binary files /dev/null and b/src/test/data/images/tiff/10/Imaging265.tiff differ
diff --git a/src/test/data/images/tiff/10/README.txt b/src/test/data/images/tiff/10/README.txt
index bee22799..d43ab04b 100644
--- a/src/test/data/images/tiff/10/README.txt
+++ b/src/test/data/images/tiff/10/README.txt
@@ -1,5 +1,10 @@
-Imaging247 is a copy of the file neutre.TIFF that was supplied by the user for JIRA 247. 
+Imaging247.tiff is a copy of the file neutre.TIFF that was supplied by the user for 
+JIRA issue IMAGING-247. 
 
-Imaging258 is a test file in which an offset field is given as type IFD rather
-than type Long.
- 
\ No newline at end of file
+Imaging258.tiff is a test file in which an offset field is given as type IFD rather
+than type Long.  It was produced specifically for JIRA issue IMAGING-258.
+
+Imaging265.tiff is a test file with a planar configuration of 2 (red, green, and blue bytes
+split into different "planes" within the file).  It is organized in strips.
+This file is taken from the file small_world.tif that was posted with the
+original JIRA issue for IMAGING-265
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStripsTest.java b/src/test/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStripsTest.java
index c060ded2..1ff8440a 100644
--- a/src/test/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStripsTest.java
+++ b/src/test/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStripsTest.java
@@ -16,6 +16,8 @@
  */
 package org.apache.commons.imaging.formats.tiff.datareaders;
 
+import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;
+
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
@@ -24,7 +26,9 @@ public class DataReaderStripsTest {
     @Test
     public void testApplyPredictor() throws Exception {
         final int[] bitsPerPixel = {1,2,3};
-        final DataReaderStrips strips = new DataReaderStrips(null, null, 3, bitsPerPixel, 2, 4, 0, 3, 1, 1, null, 2, null);
+        final DataReaderStrips strips = new DataReaderStrips(
+            null, null, 3, bitsPerPixel, 2, 4, 0, 3, 1, 1, 
+            TiffPlanarConfiguration.CHUNKY, null, 2, null);
         strips.resetPredictor();
         final int[] samples = {10, 355, 355, 255};
         int[] expected = {10, 99, 99, 255};
