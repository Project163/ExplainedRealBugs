diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index f3d31f5b..4a4b6d74 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -46,6 +46,9 @@ The <action> type attribute can be add,update,fix,remove.
   <body>
 
     <release version="1.0" date="TBA" description="TBA">
+      <action issue="IMAGING-109" dev="damjan" type="fix">
+        Several files contain non-UTF8 characters
+      </action>
       <action issue="IMAGING-113" dev="damjan" type="fix">
         Cannot read multipage tiff.
       </action>
diff --git a/src/main/java/org/apache/commons/imaging/color/ColorConversions.java b/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
index 47bf4a08..3d0ca293 100644
--- a/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
+++ b/src/main/java/org/apache/commons/imaging/color/ColorConversions.java
@@ -29,7 +29,7 @@ public abstract class ColorConversions {
     public static final ColorCieLab convertXYZtoCIELab(final double X, final double Y,
             final double Z) {
 
-        double var_X = X / ref_X; // ref_X = 95.047 Observer= 2, Illuminant=
+        double var_X = X / ref_X; // ref_X = 95.047 Observer= 2°, Illuminant=
                                   // D65
         double var_Y = Y / ref_Y; // ref_Y = 100.000
         double var_Z = Z / ref_Z; // ref_Z = 108.883
@@ -81,7 +81,7 @@ public abstract class ColorConversions {
             var_Z = (var_Z - 16 / 116.0) / 7.787;
         }
 
-        final double X = ref_X * var_X; // ref_X = 95.047 Observer= 2, Illuminant=
+        final double X = ref_X * var_X; // ref_X = 95.047 Observer= 2°, Illuminant=
                                   // D65
         final double Y = ref_Y * var_Y; // ref_Y = 100.000
         final double Z = ref_Z * var_Z; // ref_Z = 108.883
@@ -124,10 +124,10 @@ public abstract class ColorConversions {
     }
 
     public static final int convertXYZtoRGB(final double X, final double Y, final double Z) {
-        // Observer = 2, Illuminant = D65
-        final double var_X = X / 100.0; // Where X = 0  95.047
-        final double var_Y = Y / 100.0; // Where Y = 0  100.000
-        final double var_Z = Z / 100.0; // Where Z = 0  108.883
+        // Observer = 2°, Illuminant = D65
+        final double var_X = X / 100.0; // Where X = 0 ÷ 95.047
+        final double var_Y = Y / 100.0; // Where Y = 0 ÷ 100.000
+        final double var_Z = Z / 100.0; // Where Z = 0 ÷ 108.883
 
         double var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;
         double var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;
@@ -161,9 +161,9 @@ public abstract class ColorConversions {
         final int g = 0xff & (rgb >> 8);
         final int b = 0xff & (rgb >> 0);
 
-        double var_R = r / 255.0; // Where R = 0  255
-        double var_G = g / 255.0; // Where G = 0  255
-        double var_B = b / 255.0; // Where B = 0  255
+        double var_R = r / 255.0; // Where R = 0 ÷ 255
+        double var_G = g / 255.0; // Where G = 0 ÷ 255
+        double var_B = b / 255.0; // Where B = 0 ÷ 255
 
         if (var_R > 0.04045) {
             var_R = Math.pow((var_R + 0.055) / 1.055, 2.4);
@@ -185,7 +185,7 @@ public abstract class ColorConversions {
         var_G = var_G * 100;
         var_B = var_B * 100;
 
-        // Observer. = 2, Illuminant = D65
+        // Observer. = 2°, Illuminant = D65
         final double X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
         final double Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
         final double Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;
@@ -198,8 +198,8 @@ public abstract class ColorConversions {
         final int G = 0xff & (rgb >> 8);
         final int B = 0xff & (rgb >> 0);
 
-        // RGB values = 0  255
-        // CMY values = 0  1
+        // RGB values = 0 ÷ 255
+        // CMY values = 0 ÷ 1
 
         final double C = 1 - (R / 255.0);
         final double M = 1 - (G / 255.0);
@@ -215,8 +215,8 @@ public abstract class ColorConversions {
         // and similarly for G and B.
         // This is Ghostscript's formula with K = 0.
 
-        // CMY values = 0  1
-        // RGB values = 0  255
+        // CMY values = 0 ÷ 1
+        // RGB values = 0 ÷ 255
 
         final double R = (1 - cmy.C) * 255.0;
         final double G = (1 - cmy.M) * 255.0;
@@ -226,7 +226,7 @@ public abstract class ColorConversions {
     }
 
     public static final ColorCmyk convertCMYtoCMYK(final ColorCmy cmy) {
-        // Where CMYK and CMY values = 0  1
+        // Where CMYK and CMY values = 0 ÷ 1
 
         double C = cmy.C;
         double M = cmy.M;
@@ -261,7 +261,7 @@ public abstract class ColorConversions {
 
     public static final ColorCmy convertCMYKtoCMY(double C, double M, double Y,
             final double K) {
-        // Where CMYK and CMY values = 0  1
+        // Where CMYK and CMY values = 0 ÷ 1
 
         C = (C * (1 - K) + K);
         M = (M * (1 - K) + K);
@@ -287,7 +287,7 @@ public abstract class ColorConversions {
         final int G = 0xff & (rgb >> 8);
         final int B = 0xff & (rgb >> 0);
 
-        final double var_R = (R / 255.0); // Where RGB values = 0  255
+        final double var_R = (R / 255.0); // Where RGB values = 0 ÷ 255
         final double var_G = (G / 255.0);
         final double var_B = (B / 255.0);
 
@@ -314,7 +314,7 @@ public abstract class ColorConversions {
         if (del_Max == 0) {
             // This is a gray, no chroma...
         
-            H = 0; // HSL results = 0  1
+            H = 0; // HSL results = 0 ÷ 1
             S = 0;
         } else {
         // Chromatic data...
@@ -364,8 +364,8 @@ public abstract class ColorConversions {
         double R, G, B;
 
         if (S == 0) {
-            // HSL values = 0  1
-            R = L * 255; // RGB results = 0  255
+            // HSL values = 0 ÷ 1
+            R = L * 255; // RGB results = 0 ÷ 255
             G = L * 255;
             B = L * 255;
         } else {
@@ -411,7 +411,7 @@ public abstract class ColorConversions {
         final int G = 0xff & (rgb >> 8);
         final int B = 0xff & (rgb >> 0);
 
-        final double var_R = (R / 255.0); // RGB values = 0  255
+        final double var_R = (R / 255.0); // RGB values = 0 ÷ 255
         final double var_G = (G / 255.0);
         final double var_B = (B / 255.0);
 
@@ -436,7 +436,7 @@ public abstract class ColorConversions {
         double H, S;
         if (del_Max == 0) {
             // This is a gray, no chroma...
-            H = 0; // HSV results = 0  1
+            H = 0; // HSV results = 0 ÷ 1
             S = 0;
         } else {
         // Chromatic data...
@@ -473,7 +473,7 @@ public abstract class ColorConversions {
         double R, G, B;
 
         if (S == 0) {
-            // HSV values = 0  1
+            // HSV values = 0 ÷ 1
             R = V * 255;
             G = V * 255;
             B = V * 255;
@@ -515,7 +515,7 @@ public abstract class ColorConversions {
                 var_b = var_2;
             }
 
-            R = var_r * 255; // RGB results = 0  255
+            R = var_r * 255; // RGB results = 0 ÷ 255
             G = var_g * 255;
             B = var_b * 255;
         }
@@ -575,7 +575,7 @@ public abstract class ColorConversions {
             // double ref_Y = 100.000;
             // double ref_Z = 108.883;
 
-            X = ref_X * var_X; // ref_X = 95.047 Observer= 2, Illuminant= D65
+            X = ref_X * var_X; // ref_X = 95.047 Observer= 2°, Illuminant= D65
             Y = ref_Y * var_Y; // ref_Y = 100.000
             Z = ref_Z * var_Z; // ref_Z = 108.883
 
@@ -667,7 +667,7 @@ public abstract class ColorConversions {
     }
 
     public static ColorCieLab convertCIELCHtoCIELab(final double L, final double C, final double H) {
-        // Where CIE-H = 0  360
+        // Where CIE-H° = 0 ÷ 360°
 
         // CIE-L* = CIE-L;
         final double a = Math.cos(degree_2_radian(H)) * C;
@@ -706,7 +706,7 @@ public abstract class ColorConversions {
             var_Y = (7.787 * var_Y) + (16 / 116.0);
         }
 
-        final double ref_X = 95.047; // Observer= 2, Illuminant= D65
+        final double ref_X = 95.047; // Observer= 2°, Illuminant= D65
         final double ref_Y = 100.000;
         final double ref_Z = 108.883;
 
@@ -739,7 +739,7 @@ public abstract class ColorConversions {
             var_Y = (var_Y - 16 / 116) / 7.787;
         }
 
-        final double ref_X = 95.047; // Observer= 2, Illuminant= D65
+        final double ref_X = 95.047; // Observer= 2°, Illuminant= D65
         final double ref_Y = 100.000;
         final double ref_Z = 108.883;
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/bmp/BmpHeaderInfo.java b/src/main/java/org/apache/commons/imaging/formats/bmp/BmpHeaderInfo.java
index 8c135e20..71e4492d 100644
--- a/src/main/java/org/apache/commons/imaging/formats/bmp/BmpHeaderInfo.java
+++ b/src/main/java/org/apache/commons/imaging/formats/bmp/BmpHeaderInfo.java
@@ -17,12 +17,12 @@
 package org.apache.commons.imaging.formats.bmp;
 
 public class BmpHeaderInfo {
-    // BM - Windows 3.1x, 95, NT, 
-    // BA - OS/2 Bitmap Array
-    // CI - OS/2 Color Icon
-    // CP - OS/2 Color Pointer
-    // IC - OS/2 Icon
-    // PT - OS/2 Pointer
+    // BM - Windows 3.1x, 95, NT
+    // BA - OS/2 Bitmap Array
+    // CI - OS/2 Color Icon
+    // CP - OS/2 Color Pointer
+    // IC - OS/2 Icon
+    // PT - OS/2 Pointer
     public final byte identifier1;
     public final byte identifier2;
 
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
index c406d805..79009723 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/Dct.java
@@ -33,7 +33,7 @@ public class Dct {
      * are reduced from 80 in AA&N to only 54. But in practice:
      * 
      * Benchmarks, Intel Core i3 @ 2.93 GHz in long mode, 4 GB RAM Time taken to
-     * do 100 million IDCTs (less is better): Rene' Stckel's Feig, int: 45.07
+     * do 100 million IDCTs (less is better): Rene' Stöckel's Feig, int: 45.07
      * seconds My Feig, floating point: 36.252 seconds AA&N, unrolled loops,
      * double[][] -> double[][]: 25.167 seconds
      * 
diff --git a/src/main/java/org/apache/commons/imaging/formats/psd/PsdConstants.java b/src/main/java/org/apache/commons/imaging/formats/psd/PsdConstants.java
index 48c1623b..6d358ecf 100644
--- a/src/main/java/org/apache/commons/imaging/formats/psd/PsdConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/psd/PsdConstants.java
@@ -148,7 +148,7 @@ public class PsdConstants {
                     new ImageResourceType(
                             0x0414,
                             1044,
-                            "Document specific IDs, layer IDs will be generated starting at this base value or a greater value if we find existing IDs to already exceed it. Its purpose is to avoid the case where we add layers, flatten, save, open, and then add more layers that end up with the same IDs as the first set. 4 bytes."),
+                            "Document specific IDs, layer IDs will be generated starting at this base value or a greater value if we find existing IDs to already exceed it. It's purpose is to avoid the case where we add layers, flatten, save, open, and then add more layers that end up with the same IDs as the first set. 4 bytes."),
                     new ImageResourceType(0x0415, 1045,
                             "Unicode Alpha Names. 4 bytes for length and the string as a unicode string."),
                     new ImageResourceType(
@@ -166,7 +166,7 @@ public class PsdConstants {
                     new ImageResourceType(
                             0x041C,
                             1052,
-                            "Jump To XPEP. 2 bytes major version, 2 bytes minor version, 4 bytes count. Following is repeated for count: 4 bytes block size, 4 bytes key, if key = 'jtDd' then next is a Boolean for the dirty flag otherwise its a 4 byte entry for the mod date."),
+                            "Jump To XPEP. 2 bytes major version, 2 bytes minor version, 4 bytes count. Following is repeated for count: 4 bytes block size, 4 bytes key, if key = 'jtDd' then next is a Boolean for the dirty flag otherwise it's a 4 byte entry for the mod date."),
                     new ImageResourceType(
                             0x041D,
                             1053,
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterLogLuv.java b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterLogLuv.java
index 529ca0c0..b0316e06 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterLogLuv.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/photometricinterpreters/PhotometricInterpreterLogLuv.java
@@ -83,13 +83,13 @@ public class PhotometricInterpreterLogLuv extends PhotometricInterpreter {
             final float ref_Y = 100.000f;
             final float ref_Z = 108.883f;
 
-            X = ref_X * var_X; // ref_X = 95.047 Observer= 2, Illuminant= D65
+            X = ref_X * var_X; // ref_X = 95.047 Observer= 2°, Illuminant= D65
             Y = ref_Y * var_Y; // ref_Y = 100.000
             Z = ref_Z * var_Z; // ref_Z = 108.883
 
         }
 
-        // ref_X = 95.047 //Observer = 2, Illuminant = D65
+        // ref_X = 95.047 //Observer = 2°, Illuminant = D65
         // ref_Y = 100.000
         // ref_Z = 108.883
 
