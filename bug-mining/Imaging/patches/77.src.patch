diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
index d4caacfc..e071ac15 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegConstants.java
@@ -111,6 +111,17 @@ public final class JpegConstants {
     public static final int SOF14_MARKER = 0xFFc0 + 0xe;
     public static final int SOF15_MARKER = 0xFFc0 + 0xf;
 
+    // marker for restart intervals
+    public static final int DRI_MARKER = 0xFFdd;
+    public static final int RST0_MARKER = 0xFFd0;
+    public static final int RST1_MARKER = 0xFFd0 + 0x1;
+    public static final int RST2_MARKER = 0xFFd0 + 0x2;
+    public static final int RST3_MARKER = 0xFFd0 + 0x3;
+    public static final int RST4_MARKER = 0xFFd0 + 0x4;
+    public static final int RST5_MARKER = 0xFFd0 + 0x5;
+    public static final int RST6_MARKER = 0xFFd0 + 0x6;
+    public static final int RST7_MARKER = 0xFFd0 + 0x7;
+
     public static final int EOI_MARKER = 0xFFd9;
     public static final int SOS_MARKER = 0xFFda;
     public static final int DQT_MARKER = 0xFFdb;
@@ -125,7 +136,8 @@ public final class JpegConstants {
             SOF5_MARKER, SOF6_MARKER, SOF7_MARKER, SOF8_MARKER, SOF9_MARKER,
             SOF10_MARKER, SOF11_MARKER, DAC_MARKER, SOF13_MARKER,
             SOF14_MARKER, SOF15_MARKER, EOI_MARKER, SOS_MARKER, DQT_MARKER,
-            DNL_MARKER, COM_MARKER));
+            DNL_MARKER, COM_MARKER, DRI_MARKER, RST0_MARKER, RST1_MARKER, RST2_MARKER,
+            RST3_MARKER, RST4_MARKER, RST5_MARKER, RST6_MARKER, RST7_MARKER ));
 
     public static final BinaryConstant ICC_PROFILE_LABEL = new BinaryConstant(
             new byte[] { 0x49, 0x43, 0x43, 0x5F, 0x50, 0x52, 0x4F, 0x46, 0x49,
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
index 9368d71b..0621a1ca 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/JpegUtils.java
@@ -151,6 +151,24 @@ public class JpegUtils extends BinaryFileParser {
             return "SOF15_MARKER";
         case JpegConstants.DQT_MARKER:
             return "DQT_MARKER";
+        case JpegConstants.DRI_MARKER:
+            return "DRI_MARKER";
+        case JpegConstants.RST0_MARKER:
+            return "RST0_MARKER";
+        case JpegConstants.RST1_MARKER:
+            return "RST1_MARKER";
+        case JpegConstants.RST2_MARKER:
+            return "RST2_MARKER";
+        case JpegConstants.RST3_MARKER:
+            return "RST3_MARKER";
+        case JpegConstants.RST4_MARKER:
+            return "RST4_MARKER";
+        case JpegConstants.RST5_MARKER:
+            return "RST5_MARKER";
+        case JpegConstants.RST6_MARKER:
+            return "RST6_MARKER";
+        case JpegConstants.RST7_MARKER:
+            return "RST7_MARKER";
         default:
             return "Unknown";
         }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
index 2b21da2c..1691e856 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java
@@ -15,9 +15,6 @@
 
 package org.apache.commons.imaging.formats.jpeg.decoder;
 
-import static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.readBytes;
-
 import java.awt.image.BufferedImage;
 import java.awt.image.ColorModel;
 import java.awt.image.DataBuffer;
@@ -26,7 +23,9 @@ import java.awt.image.Raster;
 import java.awt.image.WritableRaster;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Properties;
 
 import org.apache.commons.imaging.ImageReadException;
@@ -39,6 +38,9 @@ import org.apache.commons.imaging.formats.jpeg.segments.DqtSegment;
 import org.apache.commons.imaging.formats.jpeg.segments.SofnSegment;
 import org.apache.commons.imaging.formats.jpeg.segments.SosSegment;
 
+import static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;
+import static org.apache.commons.imaging.common.BinaryFunctions.readBytes;
+
 public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
     /*
      * JPEG is an advanced image format that takes significant computation to
@@ -71,11 +73,23 @@ public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
     public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {
         final ByteArrayInputStream is = new ByteArrayInputStream(imageData);
         try {
+            // read the scan header
             final int segmentLength = read2Bytes("segmentLength", is, "Not a Valid JPEG File", getByteOrder());
             final byte[] sosSegmentBytes = readBytes("SosSegment",
                     is, segmentLength - 2, "Not a Valid JPEG File");
             sosSegment = new SosSegment(marker, sosSegmentBytes);
 
+            // read the payload of the scan, this is the remainder of image data after the header
+            // the payload contains the entropy-encoded segments (or ECS) divded by RST markers
+            // or only one ECS if the entropy-encoded data is not divided by RST markers
+            // length of payload = length of imaga data - length of data already read
+            final int[] scanPayload = new int[imageData.length - segmentLength];
+            int payloadReadCount = 0;
+            while (payloadReadCount < scanPayload.length) {
+                scanPayload[payloadReadCount] = is.read();
+                payloadReadCount++;
+            }
+
             int hMax = 0;
             int vMax = 0;
             for (int i = 0; i < sofnSegment.numberOfComponents; i++) {
@@ -86,8 +100,6 @@ public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
             }
             final int hSize = 8 * hMax;
             final int vSize = 8 * vMax;
-
-            final JpegInputStream bitInputStream = new JpegInputStream(is);
             final int xMCUs = (sofnSegment.width + hSize - 1) / hSize;
             final int yMCUs = (sofnSegment.height + vSize - 1) / vSize;
             final Block[] mcu = allocateMCUMemory();
@@ -122,8 +134,21 @@ public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
             }
             final DataBuffer dataBuffer = raster.getDataBuffer();
 
+            final JpegInputStream[] bitInputStreams = splitByRstMarkers(scanPayload);
+            int bitInputStreamCount = 0;
+            JpegInputStream bitInputStream = bitInputStreams[0];
+
             for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {
                 for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {
+                    // provide a the next interval if an interval is read until it's end
+                    // as long there are unread intervals available
+                    if (bitInputStream.hasNext() == false) {
+                        bitInputStreamCount++;
+                        if (bitInputStreamCount < bitInputStreams.length) {
+                            bitInputStream = bitInputStreams[bitInputStreamCount];
+                        }
+                    }
+
                     readMCU(bitInputStream, preds, mcu);
                     rescaleMCU(mcu, hSize, vSize, scaledMCU);
                     int srcRowOffset = 0;
@@ -393,6 +418,74 @@ public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {
+            if ( foundFF == true ) {
+                // found 0xFF D0 .. 0xFF D7 => RST marker
+                if ( scanPayload[ pos ] >= ( 0xff & JpegConstants.RST0_MARKER ) &&
+                    scanPayload[ pos ] <= ( 0xff & JpegConstants.RST7_MARKER ) ) {
+                    foundD0toD7 = true;
+                } else { // found 0xFF followed by something else => no RST marker
+                    foundFF = false;
+                }
+            }
+
+            if ( scanPayload[ pos ] == 0xFF ) {
+                foundFF = true;
+            }
+
+            // true if one of the RST markers was found
+            if ( foundFF == true && foundD0toD7 == true ) {
+                // we need to add the position after the current position because
+                // we had already read 0xFF and are now at 0xDn
+                intervalStarts.add( pos + 1 );
+                foundFF = foundD0toD7 = false;
+            }
+
+            pos++;
+        }
+        return intervalStarts;
+    }
+
     private static int fastRound(final float x) {
         return (int) (x + 0.5f);
     }
diff --git a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
index 375bed53..c2cff7bb 100644
--- a/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
+++ b/src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java
@@ -15,31 +15,39 @@
 
 package org.apache.commons.imaging.formats.jpeg.decoder;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 import org.apache.commons.imaging.ImageReadException;
 import org.apache.commons.imaging.formats.jpeg.JpegConstants;
 
 class JpegInputStream {
     // Figure F.18, F.2.2.5, page 111 of ITU-T T.81
-    private final InputStream is;
+    private final int[] interval;
+    // next position in the array to read
+    private int nextPos;
     private int cnt;
     private int b;
 
-    JpegInputStream(final InputStream is) {
-        this.is = is;
+    JpegInputStream(final int[] interval) {
+        this.interval = interval;
+        this.nextPos = 0;
+    }
+
+    /**
+     * Returns {@code true} as long there are unread fields available, else {@code false}
+     * @return
+     */
+    public boolean hasNext() {
+        return nextPos < this.interval.length;
     }
 
-    public int nextBit() throws IOException, ImageReadException {
+    public int nextBit() throws ImageReadException {
         if (cnt == 0) {
-            b = is.read();
+            b = this.read();
             if (b < 0) {
                 throw new ImageReadException("Premature End of File");
             }
             cnt = 8;
             if (b == 0xff) {
-                final int b2 = is.read();
+                final int b2 = this.read();
                 if (b2 < 0) {
                     throw new ImageReadException("Premature End of File");
                 }
@@ -48,7 +56,7 @@ class JpegInputStream {
                         throw new ImageReadException("DNL not yet supported");
                     }
                     throw new ImageReadException("Invalid marker found "
-                            + "in entropy data");
+                        + "in entropy data: 0xFF " + Integer.toHexString(b2));
                 }
             }
         }
@@ -57,4 +65,19 @@ class JpegInputStream {
         b <<= 1;
         return bit;
     }
+
+    /**
+     * Returns the value from current field (as {@code InputStream.read()} would do)
+     * and set the position of the pointer to the next field to read.
+     * @return
+     * @throws IllegalStateException if the stream hasn't any other value.
+     */
+    int read() {
+        if (this.hasNext() == false) {
+            throw new IllegalStateException("This stream hasn't any other value, all values were already read.");
+        }
+        int value = this.interval[nextPos];
+        this.nextPos++;
+        return value;
+    }
 }
diff --git a/src/test/data/images/jpg/6/image.jpeg b/src/test/data/images/jpg/6/image.jpeg
new file mode 100644
index 00000000..ffa54484
Binary files /dev/null and b/src/test/data/images/jpg/6/image.jpeg differ
diff --git a/src/test/data/images/jpg/7/_DSC6099.jpg b/src/test/data/images/jpg/7/_DSC6099.jpg
new file mode 100644
index 00000000..c810c6d7
Binary files /dev/null and b/src/test/data/images/jpg/7/_DSC6099.jpg differ
