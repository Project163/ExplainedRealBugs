diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 76060558..ee0d8dfb 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -45,6 +45,9 @@ The <action> type attribute can be add,update,fix,remove.
   </properties>
   <body>
     <release version="1.0-alpha2" date="2019-??-??" description="Second 1.0 alpha release">
+      <action issue="IMAGING-230" dev="kinow" type="fix">
+        Properly close resources with try-with-resources in T4AndT6Compression
+      </action>
       <action issue="IMAGING-134" dev="kinow" type="fix" due-to="Michael Sommerville">
         Invalid (RST) marker found in entropy data
       </action>
diff --git a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
index 59492095..c1e0f2fd 100644
--- a/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
+++ b/src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java
@@ -370,103 +370,105 @@ public final class T4AndT6Compression {
     public static byte[] decompressT4_2D(final byte[] compressed, final int width,
             final int height, final boolean hasFill) throws ImageReadException {
         final BitInputStreamFlexible inputStream = new BitInputStreamFlexible(new ByteArrayInputStream(compressed));
-        final BitArrayOutputStream outputStream = new BitArrayOutputStream();
-        final int[] referenceLine = new int[width];
-        for (int y = 0; y < height; y++) {
-            int rowLength = 0;
-            try {
-                T4_T6_Tables.Entry entry = CONTROL_CODES.decode(inputStream);
-                if (!isEOL(entry, hasFill)) {
-                    throw new ImageReadException("Expected EOL not found");
-                }
-                final int tagBit = inputStream.readBits(1);
-                if (tagBit == 0) {
-                    // 2D
-                    int codingA0Color = WHITE;
-                    int referenceA0Color = WHITE;
-                    int b1 = nextChangingElement(referenceLine, referenceA0Color, 0);
-                    int b2 = nextChangingElement(referenceLine, 1 - referenceA0Color, b1 + 1);
-                    for (int a0 = 0; a0 < width;) {
-                        int a1;
-                        int a2;
-                        entry = CONTROL_CODES.decode(inputStream);
-                        if (entry == T4_T6_Tables.P) {
-                            fillRange(outputStream, referenceLine, a0, b2, codingA0Color);
-                            a0 = b2;
-                        } else if (entry == T4_T6_Tables.H) {
-                            final int a0a1 = readTotalRunLength(inputStream, codingA0Color);
-                            a1 = a0 + a0a1;
-                            fillRange(outputStream, referenceLine, a0, a1, codingA0Color);
-                            final int a1a2 = readTotalRunLength(inputStream, 1 - codingA0Color);
-                            a2 = a1 + a1a2;
-                            fillRange(outputStream, referenceLine, a1, a2, 1 - codingA0Color);
-                            a0 = a2;
-                        } else {
-                            int a1b1;
-                            if (entry == T4_T6_Tables.V0) {
-                                a1b1 = 0;
-                            } else if (entry == T4_T6_Tables.VL1) {
-                                a1b1 = -1;
-                            } else if (entry == T4_T6_Tables.VL2) {
-                                a1b1 = -2;
-                            } else if (entry == T4_T6_Tables.VL3) {
-                                a1b1 = -3;
-                            } else if (entry == T4_T6_Tables.VR1) {
-                                a1b1 = 1;
-                            } else if (entry == T4_T6_Tables.VR2) {
-                                a1b1 = 2;
-                            } else if (entry == T4_T6_Tables.VR3) {
-                                a1b1 = 3;
+        try (final BitArrayOutputStream outputStream = new BitArrayOutputStream()) {
+            final int[] referenceLine = new int[width];
+            for (int y = 0; y < height; y++) {
+                int rowLength = 0;
+                try {
+                    T4_T6_Tables.Entry entry = CONTROL_CODES.decode(inputStream);
+                    if (!isEOL(entry, hasFill)) {
+                        throw new ImageReadException("Expected EOL not found");
+                    }
+                    final int tagBit = inputStream.readBits(1);
+                    if (tagBit == 0) {
+                        // 2D
+                        int codingA0Color = WHITE;
+                        int referenceA0Color = WHITE;
+                        int b1 = nextChangingElement(referenceLine, referenceA0Color, 0);
+                        int b2 = nextChangingElement(referenceLine, 1 - referenceA0Color, b1 + 1);
+                        for (int a0 = 0; a0 < width;) {
+                            int a1;
+                            int a2;
+                            entry = CONTROL_CODES.decode(inputStream);
+                            if (entry == T4_T6_Tables.P) {
+                                fillRange(outputStream, referenceLine, a0, b2, codingA0Color);
+                                a0 = b2;
+                            } else if (entry == T4_T6_Tables.H) {
+                                final int a0a1 = readTotalRunLength(inputStream, codingA0Color);
+                                a1 = a0 + a0a1;
+                                fillRange(outputStream, referenceLine, a0, a1, codingA0Color);
+                                final int a1a2 = readTotalRunLength(inputStream, 1 - codingA0Color);
+                                a2 = a1 + a1a2;
+                                fillRange(outputStream, referenceLine, a1, a2, 1 - codingA0Color);
+                                a0 = a2;
                             } else {
-                                throw new ImageReadException("Invalid/unknown T.4 control code " + entry.bitString);
+                                int a1b1;
+                                if (entry == T4_T6_Tables.V0) {
+                                    a1b1 = 0;
+                                } else if (entry == T4_T6_Tables.VL1) {
+                                    a1b1 = -1;
+                                } else if (entry == T4_T6_Tables.VL2) {
+                                    a1b1 = -2;
+                                } else if (entry == T4_T6_Tables.VL3) {
+                                    a1b1 = -3;
+                                } else if (entry == T4_T6_Tables.VR1) {
+                                    a1b1 = 1;
+                                } else if (entry == T4_T6_Tables.VR2) {
+                                    a1b1 = 2;
+                                } else if (entry == T4_T6_Tables.VR3) {
+                                    a1b1 = 3;
+                                } else {
+                                    throw new ImageReadException("Invalid/unknown T.4 control code " + entry.bitString);
+                                }
+                                a1 = b1 + a1b1;
+                                fillRange(outputStream, referenceLine, a0, a1, codingA0Color);
+                                a0 = a1;
+                                codingA0Color = 1 - codingA0Color;
                             }
-                            a1 = b1 + a1b1;
-                            fillRange(outputStream, referenceLine, a0, a1, codingA0Color);
-                            a0 = a1;
-                            codingA0Color = 1 - codingA0Color;
-                        }
-                        referenceA0Color = changingElementAt(referenceLine, a0);
-                        if (codingA0Color == referenceA0Color) {
-                            b1 = nextChangingElement(referenceLine, referenceA0Color, a0 + 1);
-                        } else {
-                            b1 = nextChangingElement(referenceLine, referenceA0Color, a0 + 1);
-                            b1 = nextChangingElement(referenceLine, 1 - referenceA0Color, b1 + 1);
+                            referenceA0Color = changingElementAt(referenceLine, a0);
+                            if (codingA0Color == referenceA0Color) {
+                                b1 = nextChangingElement(referenceLine, referenceA0Color, a0 + 1);
+                            } else {
+                                b1 = nextChangingElement(referenceLine, referenceA0Color, a0 + 1);
+                                b1 = nextChangingElement(referenceLine, 1 - referenceA0Color, b1 + 1);
+                            }
+                            b2 = nextChangingElement(referenceLine, 1 - codingA0Color, b1 + 1);
+                            rowLength = a0;
                         }
-                        b2 = nextChangingElement(referenceLine, 1 - codingA0Color, b1 + 1);
-                        rowLength = a0;
-                    }
-                } else {
-                    // 1D
-                    int color = WHITE;
-                    for (rowLength = 0; rowLength < width;) {
-                        final int runLength = readTotalRunLength(inputStream, color);
-                        for (int i = 0; i < runLength; i++) {
-                            outputStream.writeBit(color);
-                            referenceLine[rowLength + i] = color;
+                    } else {
+                        // 1D
+                        int color = WHITE;
+                        for (rowLength = 0; rowLength < width;) {
+                            final int runLength = readTotalRunLength(inputStream, color);
+                            for (int i = 0; i < runLength; i++) {
+                                outputStream.writeBit(color);
+                                referenceLine[rowLength + i] = color;
+                            }
+                            color = 1 - color;
+                            rowLength += runLength;
                         }
-                        color = 1 - color;
-                        rowLength += runLength;
                     }
+                } catch (final IOException ioException) {
+                    throw new ImageReadException("Decompression error", ioException);
+                } catch (final HuffmanTreeException huffmanException) {
+                    throw new ImageReadException("Decompression error", huffmanException);
                 }
-            } catch (final IOException ioException) {
-                throw new ImageReadException("Decompression error", ioException);
-            } catch (final HuffmanTreeException huffmanException) {
-                throw new ImageReadException("Decompression error", huffmanException);
-            }
 
-            if (rowLength == width) {
-                outputStream.flush();
-            } else if (rowLength > width) {
-                throw new ImageReadException("Unrecoverable row length error in image row " + y);
+                if (rowLength == width) {
+                    outputStream.flush();
+                } else if (rowLength > width) {
+                    throw new ImageReadException("Unrecoverable row length error in image row " + y);
+                }
             }
-        }
 
-        return outputStream.toByteArray();
+            return outputStream.toByteArray();
+        }
     }
 
     public static byte[] compressT6(final byte[] uncompressed, final int width, final int height)
             throws ImageWriteException {
-        try (BitInputStreamFlexible inputStream = new BitInputStreamFlexible(new ByteArrayInputStream(uncompressed))) {
+        try (final ByteArrayInputStream bais = new ByteArrayInputStream(uncompressed);
+                BitInputStreamFlexible inputStream = new BitInputStreamFlexible(bais)) {
             final BitArrayOutputStream outputStream = new BitArrayOutputStream();
             int[] referenceLine = new int[width];
             int[] codingLine = new int[width];
