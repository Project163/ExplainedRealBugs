diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/IPojoFactory.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/IPojoFactory.java
index 89b4abde28..db0d71f328 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/IPojoFactory.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/IPojoFactory.java
@@ -752,9 +752,9 @@ public abstract class IPojoFactory implements Factory, ManagedServiceFactory {
         String name = (String) ref.getProperty(Handler.HANDLER_NAME_PROPERTY);
         String namespace = (String) ref.getProperty(Handler.HANDLER_NAMESPACE_PROPERTY);
         if (HandlerFactory.IPOJO_NAMESPACE.equals(namespace)) {
-            return name.equals(req.getName()) && req.getNamespace() == null;
+            return name.equalsIgnoreCase(req.getName()) && req.getNamespace() == null; 
         }
-        return name.equals(req.getName()) && namespace.equals(req.getNamespace());
+        return name.equalsIgnoreCase(req.getName()) && namespace.equalsIgnoreCase(req.getNamespace());
     }
 
     /**
diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/architecture/InstanceDescription.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/architecture/InstanceDescription.java
index 347d4c7b23..632722cbd9 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/architecture/InstanceDescription.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/architecture/InstanceDescription.java
@@ -102,12 +102,13 @@ public class InstanceDescription implements InstanceStateListener {
     
     /**
      * Gets a handler description by specifying the handler qualified name.
+     * This method ignores case of the given handler name.
      * @param handler the handler name
      * @return the handler description or <code>null</code> if not found
      */
     public HandlerDescription getHandlerDescription(String handler) {
         for (int i = 0; i < m_handlers.length; i++) {
-            if (m_handlers[i].getHandlerName().equals(handler)) {
+            if (m_handlers[i].getHandlerName().equalsIgnoreCase(handler)) {
                 return m_handlers[i];
             }
         }
diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
index 917a5ee675..9cfddf524a 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
@@ -1,4 +1,4 @@
-/*
+/* 
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/DependencyHandlerDescription.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/DependencyHandlerDescription.java
index 786ec33937..7794f2e17c 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/DependencyHandlerDescription.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/DependencyHandlerDescription.java
@@ -39,6 +39,26 @@ public class DependencyHandlerDescription extends HandlerDescription {
      * Dependencies managed by the dependency handler.
      */
     private DependencyDescription[] m_dependencies = new DependencyDescription[0];
+    
+    // TODO Definie the DependencyStateListener Interface (in ipojo utils)
+    
+    // TODO Add the list of listener.
+    
+    // TODO Add register listener method.
+    
+    // TODO Add unregister listener method.
+    
+    // TODO Implement the validate method.
+    
+    // TODO Implement the invalidate method.
+    
+    // TODO Implement the onServiceArrival method.
+    
+    // TODO Implement the onServiceDeparture method.
+    
+    // TODO Implement the onServiceBound method.
+    
+    // TODO Implement the onServiceUnbound method.
 
     /**
      * Creates the Dependency Handler description.
@@ -50,6 +70,7 @@ public class DependencyHandlerDescription extends HandlerDescription {
         m_dependencies = new DependencyDescription[deps.length];
         for (int i = 0; i < m_dependencies.length; i++) {
             m_dependencies[i] = new DependencyDescription(deps[i]);
+            //TODO Register callback there on the dependency model.
         }
     }
 
diff --git a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
index 0228542067..155aec1202 100644
--- a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
+++ b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
@@ -23,7 +23,7 @@ public class BundleAsiPOJO implements BundleAs<URL> {
     public BundleAsiPOJO (File file, File metadata) {
         m_metadata = metadata;
         m_file = file;
-        if (! metadata.exists()) {
+        if (metadata != null && !metadata.exists()) {
             throw new RuntimeException("METADATA NOT FOUND");
         }
     }
diff --git a/ipojo/tests/core/handler/ignorecase.xml b/ipojo/tests/core/handler/ignorecase.xml
new file mode 100644
index 0000000000..11730317d3
--- /dev/null
+++ b/ipojo/tests/core/handler/ignorecase.xml
@@ -0,0 +1,20 @@
+<ipojo xmlns:ex="org.apache.felix.ipojo.tests.core.handler">
+
+<!--  Empty handler, name and namespace written strangely -->
+<handler
+  name="EmPtY"
+  namespace="orG.apAche.feliX.iPOJO.tests.CORE.hAnDlEr"
+  classname="org.apache.felix.ipojo.tests.core.handler.EmptyHandler">
+</handler>
+
+<component classname="org.apache.felix.ipojo.tests.core.component.MyComponent" name="IgnoreCase-1">
+  <ex:empty/>
+</component>
+<instance component="IgnoreCase-1" name="IgnoreCase-1"/>
+
+<component classname="org.apache.felix.ipojo.tests.core.component.MyComponent" name="IgnoreCase-2">
+  <ex:eMptY/>
+</component>
+<instance component="IgnoreCase-2" name="IgnoreCase-2"/>
+
+</ipojo>
diff --git a/ipojo/tests/core/handler/pom.xml b/ipojo/tests/core/handler/pom.xml
new file mode 100644
index 0000000000..b73f0247d9
--- /dev/null
+++ b/ipojo/tests/core/handler/pom.xml
@@ -0,0 +1,122 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>ipojo.tests</groupId>
+  <artifactId>tests.core.handler</artifactId>
+  <name>iPOJO Handler Mechanism Test Suite</name>
+  <version>1.3.0-SNAPSHOT</version>
+  <description>Test the handler mechanism</description>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.servicemix.tooling</groupId>
+        <artifactId>depends-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>generate-depends-file</id>
+            <goals>
+              <goal>generate-depends-file</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+
+      <!--  <plugin>
+        <groupId>org.ops4j.pax.exam</groupId>
+        <artifactId>maven-paxexam-plugin</artifactId>
+        <executions>
+          <execution>
+          <id>generate-paxexam-config</id>
+          <goals>
+            <goal>generate-paxexam-config</goal>
+          </goals>
+          </execution>
+        </executions>
+        <configuration>
+        <settings>
+          <platform>felix</platform>
+        </settings>
+        </configuration>
+      </plugin> -->
+    </plugins>
+  </build>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo</artifactId>
+      <version>${pom.version}</version>
+    </dependency>
+
+  <!--
+    Pax Exam API:
+  -->
+  <dependency>
+    <groupId>org.ops4j.pax.exam</groupId>
+    <artifactId>pax-exam</artifactId>
+    <version>0.6.0</version>
+  </dependency>
+  <!--
+    During runtime Pax Exam will discover the OSGi container to use by
+    searching metadata available into classpath. Pax Exam comes with a
+    default container that uses [Pax Runner] for implementing the
+    container requirements:
+  -->
+  <dependency>
+    <groupId>org.ops4j.pax.exam</groupId>
+    <artifactId>pax-exam-container-default
+    </artifactId>
+    <version>0.6.0</version>
+  </dependency>
+  <!--
+    If your test code is based on JUnit you will have to have the Junit
+    support artifact:
+  -->
+  <dependency>
+    <groupId>org.ops4j.pax.exam</groupId>
+    <artifactId>pax-exam-junit</artifactId>
+    <version>0.6.0</version>
+  </dependency>
+  <dependency>
+    <groupId>junit</groupId>
+    <artifactId>junit</artifactId>
+    <version>4.5</version>
+    <type>jar</type>
+    <scope>test</scope>
+  </dependency>
+  <!--  Tinybundles -->
+  <dependency>
+    <groupId>org.ops4j.pax.swissbox</groupId>
+    <artifactId>pax-swissbox-tinybundles</artifactId>
+    <version>1.0.0</version>
+  </dependency>
+  <dependency>
+    <groupId>org.apache.felix</groupId>
+    <artifactId>org.apache.felix.ipojo.tinybundles.bundleAsiPOJO</artifactId>
+    <version>${pom.version}</version>
+  </dependency>
+  </dependencies>
+
+  <repositories>
+    <repository>
+      <id>ops4j.releases</id>
+      <name>OPS4J Release</name>
+      <url> http://repository.ops4j.org/maven2/</url>
+      <releases>
+        <enabled>true</enabled>
+      </releases>
+      <snapshots>
+        <enabled>false</enabled>
+      </snapshots>
+    </repository>
+  </repositories>
+
+</project>
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java
new file mode 100644
index 0000000000..7755c085c9
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java
@@ -0,0 +1,730 @@
+/* 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.ipojo.tests.core;
+
+import java.util.ArrayList;
+import java.util.Dictionary;
+import java.util.List;
+import java.util.Properties;
+
+import org.apache.felix.ipojo.ComponentInstance;
+import org.apache.felix.ipojo.Factory;
+import org.apache.felix.ipojo.Handler;
+import org.apache.felix.ipojo.HandlerFactory;
+import org.apache.felix.ipojo.ServiceContext;
+import org.apache.felix.ipojo.architecture.Architecture;
+import org.apache.felix.ipojo.metadata.Element;
+import org.apache.felix.ipojo.parser.ManifestMetadataParser;
+import org.apache.felix.ipojo.parser.ParseException;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.cm.ManagedServiceFactory;
+
+/**
+ * iPOJO Helper.
+ * This helper helps getting {@link Factory}, and managing
+ * {@link ComponentInstance}.
+ * @author <a href="mailto:dev@felix.apache.org">Felix Project Team</a>
+ */
+public class IPOJOHelper {
+
+    /**
+     * The bundle context.
+     */
+    private BundleContext m_context;
+
+
+    /**
+     * List of instances.
+     */
+    private List<ComponentInstance> m_instances;
+
+    /**
+     * Creates a IPOJOHelper.
+     * @param tc the OSGi Test Case
+     */
+    public IPOJOHelper(BundleContext context) {
+        m_context = context;
+        m_instances = new ArrayList<ComponentInstance>();
+    }
+
+    /**
+     * Disposes created instances.
+     * @see org.apache.felix.ipojo.junit4osgi.Helper#dispose()
+     */
+    public void dispose() {
+        for (int i = 0; i < m_instances.size(); i++) {
+            ((ComponentInstance) m_instances.get(i)).dispose();
+        }
+        m_instances.clear();
+    }
+
+    /**
+     * Gets a created instance from the instance name.
+     * @param name the instance name.
+     * @return the created {@link ComponentInstance} or <code>null</code>
+     * if the instance was not created during the session.
+     */
+    public ComponentInstance getInstanceByName(String name) {
+        for (int i = 0; i < m_instances.size(); i++) {
+            if (((ComponentInstance) m_instances.get(i)).getInstanceName()
+                    .equals(name)) {
+                return (ComponentInstance) m_instances.get(i);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Creates a new component instance with the given name (and empty
+     * configuration), from the factory specified in the given bundle.
+     * 
+     * @param bundle the bundle from which the component factory is defined.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified bundle.
+     * @param instanceName the name of the component instance to create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(Bundle bundle,
+            String factoryName, String instanceName) {
+
+        // Create the instance configuration
+        Properties configuration = new Properties();
+        configuration.put("instance.name", instanceName);
+
+        return createComponentInstance(bundle, factoryName, configuration);
+    }
+
+    /**
+     * Creates a new component instance with the given configuration, from the
+     * factory specified in the given bundle.
+     * 
+     * @param bundle the bundle from which the component factory is defined.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified bundle.
+     * @param configuration the configuration of the component instance to
+     *            create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(Bundle bundle,
+            String factoryName, Dictionary configuration) {
+
+        // Retrieve the component factory.
+        Factory fact = getFactory(bundle, factoryName);
+
+        if (fact == null) {
+            // Factory not found...
+            throw new IllegalArgumentException(
+                    "Cannot find the component factory (" + factoryName
+                            + ") in the specified bundle ("
+                            + bundle.getSymbolicName() + ").");
+        }
+
+        try {
+            return fact.createComponentInstance(configuration);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(
+                    "Cannot create the component instance with the given configuration:"
+                            + e.getMessage());
+        }
+    }
+
+    /**
+     * Creates a new component instance with the given name and configuration,
+     * from the factory specified in the given bundle.
+     * 
+     * @param bundle the bundle from which the component factory is defined.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified bundle.
+     * @param instanceName the name of the component instance to create.
+     * @param configuration the configuration of the instance to create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(Bundle bundle,
+            String factoryName, String instanceName, Dictionary configuration) {
+
+        // Add the instance name to the configuration
+        configuration.put("instance.name", instanceName);
+
+        return createComponentInstance(bundle, factoryName, configuration);
+    }
+
+    /**
+     * Creates a new component instance with the given name (and an empty
+     * configuration), from the factory specified in the given service context.
+     * 
+     * @param serviceContext the service context in which the component factory
+     *            service is registered.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified service context.
+     * @param instanceName the name of the component instance to create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(
+            ServiceContext serviceContext, String factoryName,
+            String instanceName) {
+
+        // Create the instance configuration
+        Properties configuration = new Properties();
+        configuration.put("instance.name", instanceName);
+
+        return createComponentInstance(serviceContext, factoryName,
+                configuration);
+    }
+
+    /**
+     * Creates a new component instance with the given name and configuration,
+     * from the factory specified in the given service context.
+     * 
+     * @param serviceContext the service context in which the component factory
+     *            service is registered.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified service context.
+     * @param configuration the configuration of the instance to create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(
+            ServiceContext serviceContext, String factoryName,
+            Dictionary configuration) {
+
+        // Retrieve the component factory.
+        Factory fact = getFactory(serviceContext, factoryName);
+
+        if (fact == null) {
+            // Factory not found...
+            throw new IllegalArgumentException(
+                    "Cannot find the component factory (" + factoryName
+                            + ") in the specified service context.");
+        }
+
+        try {
+            return fact.createComponentInstance(configuration);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(
+                    "Cannot create the component instance with the given configuration: "
+                            + e.getMessage());
+        }
+    }
+
+    /**
+     * Creates a new component instance with the given name and configuration,
+     * from the factory specified in the given service context.
+     * 
+     * @param serviceContext the service context in which the component factory
+     *            service is registered.
+     * @param factoryName the name of the component factory, defined in the
+     *            specified service context.
+     * @param instanceName the name of the component instance to create.
+     * @param configuration the configuration of the instance to create.
+     * @return the newly created component instance.
+     */
+    public static ComponentInstance createComponentInstance(
+            ServiceContext serviceContext, String factoryName,
+            String instanceName, Dictionary configuration) {
+
+        // Add the instance name to the configuration
+        configuration.put("instance.name", instanceName);
+
+        return createComponentInstance(serviceContext, factoryName,
+                configuration);
+    }
+
+    /**
+     * Creates a new component instance with the given name (and empty
+     * configuration), from the factory specified in the local bundle.
+     * 
+     * @param factoryName the name of the component factory, defined in the
+     *            local bundle.
+     * @param instanceName the name of the component instance to create.
+     * @return the newly created component instance.
+     */
+    public ComponentInstance createComponentInstance(String factoryName,
+            String instanceName) {
+        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
+                factoryName, instanceName);
+        m_instances.add(ci);
+        return ci;
+    }
+
+    /**
+     * Creates a new component instance with the given configuration, from the
+     * factory specified in the local bundle.
+     * 
+     * @param factoryName the name of the component factory, in the local
+     *            bundle.
+     * @param configuration the configuration of the component instance to
+     *            create.
+     * @return the newly created component instance.
+     */
+    public ComponentInstance createComponentInstance(String factoryName,
+            Dictionary configuration) {
+        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
+                factoryName, configuration);
+        m_instances.add(ci);
+        return ci;
+    }
+
+    /**
+     * Creates a new component instance with no configuration, from the factory
+     * specified in the local bundle.
+     * 
+     * @param factoryName the name of the component factory, in the local
+     *            bundle.
+     * @return the newly created component instance.
+     */
+    public ComponentInstance createComponentInstance(String factoryName) {
+        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
+                factoryName, (Dictionary) null);
+        m_instances.add(ci);
+        return ci;
+    }
+
+    /**
+     * Creates a new component instance with the given name and configuration,
+     * from the factory specified in the given bundle.
+     * 
+     * @param factoryName the name of the component factory, defined in the
+     *            specified bundle.
+     * @param instanceName the name of the component instance to create.
+     * @param configuration the configuration of the instance to create.
+     * @return the newly created component instance.
+     */
+    public ComponentInstance createComponentInstance(String factoryName,
+            String instanceName, Dictionary configuration) {
+        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
+                factoryName, instanceName, configuration);
+        m_instances.add(ci);
+        return ci;
+    }
+
+    /**
+     * Returns the component factory with the given name in the local bundle.
+     * 
+     * @param factoryName the name of the factory to retrieve.
+     * @return the component factory with the given name in the local bundle, or
+     *         {@code null} if not found.
+     */
+    public Factory getFactory(String factoryName) {
+        return getFactory(m_context.getBundle(), factoryName);
+    }
+
+    /**
+     * Returns the handler factory with the given name in the local bundle.
+     * 
+     * @param factoryName the name of the handler factory to retrieve.
+     * @return the handler factory with the given name in the local bundle, or
+     *         {@code null} if not found.
+     */
+    public HandlerFactory getHandlerFactory(String factoryName) {
+        return getHandlerFactory(m_context.getBundle(), factoryName);
+    }
+
+    /**
+     * Returns the metadata description of the component defined in this bundle.
+     * 
+     * @param component the name of the locally defined component.
+     * @return the metadata description of the component with the given name,
+     *         defined in this given bundle, or {@code null} if not found.
+     */
+    public Element getMetadata(String component) {
+        return getMetadata(m_context.getBundle(), component);
+    }
+
+    /**
+     * Returns the component factory with the given name in the given bundle.
+     * 
+     * @param bundle the bundle from which the component factory is defined.
+     * @param factoryName the name of the defined factory.
+     * @return the component factory with the given name in the given bundle, or
+     *         {@code null} if not found.
+     */
+    public static Factory getFactory(Bundle bundle, String factoryName) {
+        ServiceReference[] refs;
+        try {
+            // Retrieves the component factories services in the bundle.
+            refs = bundle.getBundleContext().getServiceReferences(
+                    Factory.class.getName(),
+                    "(factory.name=" + factoryName + ")");
+            if (refs != null) {
+                return (Factory) bundle.getBundleContext().getService(refs[0]);
+            }
+
+            // Factory not found...
+            return null;
+
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalArgumentException(
+                    "Cannot get the component factory services: "
+                            + e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the component factory with the given name, registered in the
+     * given service context.
+     * 
+     * @param serviceContext the service context in which the factory service is
+     *            defined.
+     * @param factoryName the name of the factory.
+     * @return the component factory with the given name, registered in the
+     *         given service context.
+     */
+    public static Factory getFactory(ServiceContext serviceContext,
+            String factoryName) {
+        ServiceReference[] refs;
+        try {
+            // Retrieves the component factories services in the service
+            // context.
+            refs = serviceContext.getServiceReferences(Factory.class.getName(),
+                    "(factory.name=" + factoryName + ")");
+            if (refs != null) {
+                return (Factory) serviceContext.getService(refs[0]);
+            }
+            return null;
+
+        } catch (InvalidSyntaxException e) {
+            System.err.println("Cannot get the factory " + factoryName + " : "
+                    + e.getMessage());
+            return null;
+        }
+    }
+
+    /**
+     * Returns the handler factory with the given name in the given bundle.
+     * 
+     * @param bundle the bundle from which the handler factory is defined.
+     * @param factoryName the name of the handler factory to retrieve.
+     * @return the handler factory with the given name in the given bundle, or
+     *         {@code null} if not found.
+     */
+    public static HandlerFactory getHandlerFactory(Bundle bundle,
+            String factoryName) {
+        ServiceReference[] refs;
+        try {
+            // Retrieves the handler factories services in the bundle.
+            refs = bundle.getBundleContext().getServiceReferences(
+                    HandlerFactory.class.getName(),
+                    "(" + Handler.HANDLER_NAME_PROPERTY + "=" + factoryName
+                            + ")");
+            if (refs != null) {
+                return (HandlerFactory) bundle.getBundleContext().getService(
+                        refs[0]);
+            }
+
+            // Factory not found...
+            return null;
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalArgumentException(
+                    "Cannot get the handler factory services: "
+                            + e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the metadata description of the component with the given name,
+     * defined in the given bundle.
+     * 
+     * @param bundle the bundle from which the component is defined.
+     * @param component the name of the defined component.
+     * @return the metadata description of the component with the given name,
+     *         defined in the given bundle, or {@code null} if not found.
+     */
+    public static Element getMetadata(Bundle bundle, String component) {
+
+        // Retrieves the component description from the bundle's manifest.
+        String elem = (String) bundle.getHeaders().get("iPOJO-Components");
+        if (elem == null) {
+            throw new IllegalArgumentException(
+                    "Cannot find iPOJO-Components descriptor in the specified bundle ("
+                            + bundle.getSymbolicName()
+                            + "). Not an iPOJO bundle.");
+        }
+
+        // Parses the retrieved description and find the component with the
+        // given name.
+        try {
+            Element element = ManifestMetadataParser.parseHeaderMetadata(elem);
+            Element[] childs = element.getElements("component");
+            for (int i = 0; i < childs.length; i++) {
+                String name = childs[i].getAttribute("name");
+                String clazz = childs[i].getAttribute("classname");
+                if (name != null && name.equalsIgnoreCase(component)) {
+                    return childs[i];
+                }
+                if (clazz.equalsIgnoreCase(component)) {
+                    return childs[i];
+                }
+            }
+
+            // Component not found...
+            return null;
+
+        } catch (ParseException e) {
+            throw new IllegalStateException(
+                    "Cannot parse the components from specified bundle ("
+                            + bundle.getSymbolicName() + "): " + e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the service object of a service registered in the specified
+     * service context, offering the specified interface and matching the given
+     * filter.
+     * 
+     * @param serviceContext the service context in which the service is
+     *            searched.
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service object provided by the specified bundle, offering the
+     *         specified interface and matching the given filter.
+     */
+    public static Object getServiceObject(ServiceContext serviceContext,
+            String itf, String filter) {
+        ServiceReference ref = getServiceReference(serviceContext, itf, filter);
+        if (ref != null) {
+            return serviceContext.getService(ref);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the service objects of the services registered in the specified
+     * service context, offering the specified interface and matching the given
+     * filter.
+     * 
+     * @param serviceContext the service context in which services are searched.
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service objects provided by the specified bundle, offering
+     *         the specified interface and matching the given filter.
+     */
+    public static Object[] getServiceObjects(ServiceContext serviceContext,
+            String itf, String filter) {
+        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
+                filter);
+        if (refs != null) {
+            Object[] list = new Object[refs.length];
+            for (int i = 0; i < refs.length; i++) {
+                list[i] = serviceContext.getService(refs[i]);
+            }
+            return list;
+        } else {
+            return new Object[0];
+        }
+    }
+
+    /**
+     * Returns the service reference of a service registered in the specified
+     * service context, offering the specified interface and matching the given
+     * filter.
+     * 
+     * @param serviceContext the service context in which services are searched.
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return a service reference registered in the specified service context,
+     *         offering the specified interface and matching the given filter.
+     *         If no service is found, {@code null} is returned.
+     */
+    public static ServiceReference getServiceReference(
+            ServiceContext serviceContext, String itf, String filter) {
+        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
+                filter);
+        if (refs.length != 0) {
+            return refs[0];
+        } else {
+            // No service found
+            return null;
+        }
+    }
+
+    /**
+     * Returns the service reference of the service registered in the specified
+     * service context, offering the specified interface and having the given
+     * persistent ID.
+     * 
+     * @param serviceContext the service context in which services are searched.
+     * @param itf the interface provided by the searched service.
+     * @param pid the persistent ID of the searched service.
+     * @return a service registered in the specified service context, offering
+     *         the specified interface and having the given persistent ID.
+     */
+    public static ServiceReference getServiceReferenceByPID(
+            ServiceContext serviceContext, String itf, String pid) {
+        String filter = "(" + "service.pid" + "=" + pid + ")";
+        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
+                filter);
+        if (refs == null) {
+            return null;
+        } else if (refs.length == 1) {
+            return refs[0];
+        } else {
+            throw new IllegalStateException(
+                    "A service lookup by PID returned several providers ("
+                            + refs.length + ")" + " for " + itf + " with pid="
+                            + pid);
+        }
+    }
+
+    /**
+     * Returns the service reference of all the services registered in the
+     * specified service context, offering the specified interface and matching
+     * the given filter.
+     * 
+     * @param serviceContext the service context in which services are searched.
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return all the service references registered in the specified service
+     *         context, offering the specified interface and matching the given
+     *         filter. If no service matches, an empty array is returned.
+     */
+    public static ServiceReference[] getServiceReferences(
+            ServiceContext serviceContext, String itf, String filter) {
+        ServiceReference[] refs = null;
+        try {
+            // Get all the service references
+            refs = serviceContext.getServiceReferences(itf, filter);
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalArgumentException(
+                    "Cannot get service references: " + e.getMessage());
+        }
+        if (refs == null) {
+            return new ServiceReference[0];
+        } else {
+            return refs;
+        }
+    }
+
+    /**
+     * Returns the service reference of a service registered in the specified
+     * service context, offering the specified interface and having the given
+     * name.
+     * 
+     * @param serviceContext the service context in which services are searched.
+     * @param itf the interface provided by the searched service.
+     * @param name the name of the searched service.
+     * @return a service registered in the specified service context, offering
+     *         the specified interface and having the given name.
+     */
+    public static ServiceReference getServiceReferenceByName(
+            ServiceContext serviceContext, String itf, String name) {
+        String filter = null;
+        if (itf.equals(Factory.class.getName())
+                || itf.equals(ManagedServiceFactory.class.getName())) {
+            filter = "(" + "factory.name" + "=" + name + ")";
+        } else if (itf.equals(Architecture.class.getName())) {
+            filter = "(" + "architecture.instance" + "=" + name + ")";
+        } else {
+            filter = "(" + "instance.name" + "=" + name + ")";
+        }
+        return getServiceReference(serviceContext, itf, filter);
+    }
+
+    /**
+     * Checks the availability of a service inside the given service context.
+     * @param sc the service context
+     * @param itf the service interface to found
+     * @return <code>true</code> if the service is available in the service
+     *         context, <code>false</code> otherwise.
+     */
+    public static boolean isServiceAvailable(ServiceContext sc, String itf) {
+        ServiceReference ref = getServiceReference(sc, itf, null);
+        return ref != null;
+    }
+
+    /**
+     * Checks the availability of a service inside the given service context.
+     * @param sc the service context
+     * @param itf the service interface to found
+     * @param name the service provider name
+     * @return <code>true</code> if the service is available in the service
+     *         context, <code>false</code> otherwise.
+     */
+    public static boolean isServiceAvailableByName(ServiceContext sc,
+            String itf, String name) {
+        ServiceReference ref = getServiceReferenceByName(sc, itf, name);
+        return ref != null;
+    }
+
+    /**
+     * Checks the availability of a service inside the given service context.
+     * @param sc the service context
+     * @param itf the service interface to found
+     * @param pid the pid of the service
+     * @return <code>true</code> if the service is available in the service
+     *         context, <code>false</code> otherwise.
+     */
+    public static boolean isServiceAvailableByPID(ServiceContext sc,
+            String itf, String pid) {
+        ServiceReference ref = getServiceReferenceByPID(sc, itf, pid);
+        return ref != null;
+    }
+
+    /**
+     * Returns the service reference of a service provided by the specified
+     * bundle, offering the specified interface and having the given name.
+     * 
+     * @param bundle the bundle from which the service is searched.
+     * @param itf the interface provided by the searched service.
+     * @param name the name of the searched service.
+     * @return a service provided by the specified bundle, offering the
+     *         specified interface and having the given name.
+     */
+    public static ServiceReference getServiceReferenceByName(Bundle bundle,
+            String itf, String name) {
+        String filter = null;
+        if (itf.equals(Factory.class.getName())
+                || itf.equals(ManagedServiceFactory.class.getName())) {
+            filter = "(" + "factory.name" + "=" + name + ")";
+        } else if (itf.equals(Architecture.class.getName())) {
+            filter = "(" + "architecture.instance" + "=" + name + ")";
+        } else {
+            filter = "(" + "instance.name" + "=" + name + ")";
+        }
+        return OSGiHelper.getServiceReference(bundle, itf, filter);
+    }
+
+    /**
+     * Returns the service reference of a service provided by the local bundle,
+     * offering the specified interface and having the given name.
+     * 
+     * @param itf the interface provided by the searched service.
+     * @param name the name of the searched service.
+     * @return a service provided by the specified bundle, offering the
+     *         specified interface and having the given name.
+     */
+    public ServiceReference getServiceReferenceByName(String itf, String name) {
+        return getServiceReferenceByName(m_context.getBundle(), itf, name);
+    }
+
+    /**
+     * Checks if the service is available.
+     * @param itf the service interface
+     * @param name the service provider name
+     * @return <code>true</code> if the service is available, <code>false</code>
+     *         otherwise.
+     */
+    public boolean isServiceAvailableByName(String itf, String name) {
+        ServiceReference ref = getServiceReferenceByName(itf, name);
+        return ref != null;
+    }
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java
new file mode 100644
index 0000000000..6899ab3d21
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java
@@ -0,0 +1,173 @@
+package org.apache.felix.ipojo.tests.core;
+
+import static org.apache.felix.ipojo.tinybundles.BundleAsiPOJO.asiPOJOBundle;
+import static org.ops4j.pax.exam.CoreOptions.equinox;
+import static org.ops4j.pax.exam.CoreOptions.felix;
+import static org.ops4j.pax.exam.CoreOptions.knopflerfish;
+import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.exam.MavenUtils.asInProject;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.asURL;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.with;
+
+import java.io.File;
+
+import org.apache.felix.ipojo.ComponentInstance;
+import org.apache.felix.ipojo.Factory;
+import org.apache.felix.ipojo.HandlerFactory;
+import org.apache.felix.ipojo.architecture.Architecture;
+import org.apache.felix.ipojo.architecture.HandlerDescription;
+import org.apache.felix.ipojo.tests.core.component.MyComponent;
+import org.apache.felix.ipojo.tests.core.handler.EmptyHandler;
+import org.apache.felix.ipojo.tests.core.service.MyService;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.Inject;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * Check that the handler selection ignore case.
+ * An empty handler declared with
+ * name="EmPtY" and namespace="orG.apAche.feliX.iPOJO.tests.CORE.hAnDlEr"
+ * is declared, and two instances using this handler are created. The test is
+ * successful is the two instances are created correctly.
+ * Test about Felix-1318 : Case mismatch problem of iPOJO custom handler name
+ */
+@RunWith( JUnit4TestRunner.class )
+public class IgnoreCaseHandlerSelectionTest {
+
+    @Inject
+    private BundleContext context;
+
+    private OSGiHelper osgi;
+
+    private IPOJOHelper ipojo;
+
+    @Before
+    public void init() {
+        osgi = new OSGiHelper(context);
+        ipojo = new IPOJOHelper(context);
+    }
+
+    @After
+    public void stop() {
+        ipojo.dispose();
+        osgi.dispose();
+    }
+
+    @Configuration
+    public static Option[] configure() {
+
+        File tmp = new File("target/tmp");
+        tmp.mkdirs();
+
+        Option[] opt =  options(
+                felix(),
+                equinox(),
+                knopflerfish(),
+                provision(
+                        // Runtime.
+                        mavenBundle().groupId("org.apache.felix").artifactId("org.apache.felix.ipojo").version(asInProject()),
+                        mavenBundle().groupId( "org.ops4j.pax.swissbox" ).artifactId( "pax-swissbox-tinybundles" ).version(asInProject())
+                        ),
+                provision(
+                        newBundle()
+                            .addClass( MyService.class )
+                            .prepare()
+                           .set(Constants.BUNDLE_SYMBOLICNAME,"ServiceInterface")
+                           .set(Constants.EXPORT_PACKAGE, "org.apache.felix.ipojo.tests.core.service")
+                            .build( asURL() ).toExternalForm()
+                    ),
+               provision(
+                       // Components and the handler
+                        newBundle()
+                            .addClass(MyComponent.class) // Component Implementation
+                            .addClass(EmptyHandler.class) // Handler.
+                            .prepare(
+                                    with()
+                                        .set(Constants.BUNDLE_SYMBOLICNAME,"IgnoreCase")
+                                        .set(Constants.IMPORT_PACKAGE, "org.apache.felix.ipojo.tests.core.service, org.apache.felix.ipojo, org.apache.felix.ipojo.metadata")
+                                    )
+                            .build( asiPOJOBundle(new File(tmp, "ignorecase.jar"), new File("ignorecase.xml"))).toExternalForm()));
+        return opt;
+    }
+
+    @Test
+    public void testDeploy() {
+        Bundle[] bundles = context.getBundles();
+        for (int i = 0; i < bundles.length; i++) {
+            Assert.assertEquals(bundles[i].getSymbolicName() + " is not active", Bundle.ACTIVE, bundles[i].getState());
+        }
+    }
+
+    /**
+     * Checks that the handler is declared and accessible.
+     */
+    @Test
+    public void testHandlerAvailability() {
+        ServiceReference[] refs = osgi.getServiceReferences(HandlerFactory.class.getName(), null);
+        for (ServiceReference ref : refs) {
+            String name = (String) ref.getProperty("handler.name");
+            String ns = (String) ref.getProperty("handler.namespace");
+            if (name != null
+                    && name.equalsIgnoreCase("EmPtY") // Check with ignore case.
+                    && ns != null
+                    && ns.equalsIgnoreCase("orG.apAche.feliX.iPOJO.tests.CORE.hAnDlEr")) { // Check with ignore case.
+                Integer state = (Integer) ref.getProperty("factory.state");
+                if (state != null) {
+                    Assert.assertEquals(Factory.VALID, state.intValue());
+                    return; // Handler found and valid.
+                } else {
+                    Assert.fail("Handler found but no state exposed");
+                }
+            }
+        }
+        Assert.fail("Handler not found");
+    }
+
+    /**
+     * Check that the instance is correctly created with "empty".
+     */
+    @Test
+    public void testCreationOfIgnoreCase1() {
+          ServiceReference refv1 = ipojo.getServiceReferenceByName(Architecture.class.getName(), "IgnoreCase-1");
+          Assert.assertNotNull(refv1);
+          Architecture arch = (Architecture) osgi.getServiceObject(refv1);
+          Assert.assertEquals(ComponentInstance.VALID, arch.getInstanceDescription().getState());
+
+          HandlerDescription desc = arch.getInstanceDescription()
+              .getHandlerDescription("orG.apAche.feliX.iPOJO.tests.CORE.hAnDlEr:EmPtY");  // Check with the declared name.
+                
+          Assert.assertNotNull(desc);
+          Assert.assertTrue(desc.isValid());
+    }
+
+    /**
+     * Check that the instance is correctly created with "eMptY".
+     */
+    @Test
+    public void testCreationOfIgnoreCase2() {
+          ServiceReference refv1 = ipojo.getServiceReferenceByName(Architecture.class.getName(), "IgnoreCase-2");
+          Assert.assertNotNull(refv1);
+          Architecture arch = (Architecture) osgi.getServiceObject(refv1);
+          Assert.assertEquals(ComponentInstance.VALID, arch.getInstanceDescription().getState());
+
+          HandlerDescription desc = arch.getInstanceDescription()
+              .getHandlerDescription("org.apache.felix.ipojo.tests.core.handler:empty"); // Check with different case.
+          Assert.assertNotNull(desc);
+          Assert.assertTrue(desc.isValid());
+    }
+
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java
new file mode 100644
index 0000000000..bf880f1e15
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java
@@ -0,0 +1,456 @@
+package org.apache.felix.ipojo.tests.core;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+import static org.junit.Assert.fail;
+
+
+public class OSGiHelper {
+    
+    /**
+     * The bundle context.
+     */
+    private BundleContext context;
+    
+    /**
+     * List of get references.
+     */
+    private List<ServiceReference> m_references = new ArrayList<ServiceReference>();
+    
+    public OSGiHelper(BundleContext context) {
+        this.context = context;
+    }
+    
+    public void dispose() {
+        // Unget services
+        for (int i = 0; i < m_references.size(); i++) {
+            context.ungetService((ServiceReference) m_references.get(i));
+        }
+        m_references.clear();
+    }
+    
+    /**
+     * Gets the Bundle Context.
+     * @return the bundle context.
+     */
+    public BundleContext getContext() {
+        return context;
+    }
+    
+    /**
+     * Returns the service object of a service provided by the specified bundle,
+     * offering the specified interface and matching the given filter.
+     * 
+     * @param bundle the bundle from which the service is searched.
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service object provided by the specified bundle, offering the
+     *         specified interface and matching the given filter.
+     */
+    public static Object getServiceObject(Bundle bundle, String itf,
+            String filter) {
+        ServiceReference ref = getServiceReference(bundle, itf, filter);
+        if (ref != null) {
+            return bundle.getBundleContext().getService(ref);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the service objects of the services provided by the specified
+     * bundle, offering the specified interface and matching the given filter.
+     * 
+     * @param bundle the bundle from which services are searched.
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service objects provided by the specified bundle, offering
+     *         the specified interface and matching the given filter.
+     */
+    public static Object[] getServiceObjects(Bundle bundle, String itf,
+            String filter) {
+        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
+        if (refs != null) {
+            Object[] list = new Object[refs.length];
+            for (int i = 0; i < refs.length; i++) {
+                list[i] = bundle.getBundleContext().getService(refs[i]);
+            }
+            return list;
+        } else {
+            return new Object[0];
+        }
+    }
+
+    /**
+     * Returns the service reference of a service provided by the specified
+     * bundle, offering the specified interface and matching the given filter.
+     * 
+     * @param bundle the bundle from which the service is searched.
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return a service reference provided by the specified bundle, offering
+     *         the specified interface and matching the given filter. If no
+     *         service is found, {@code null} is returned.
+     */
+    public static ServiceReference getServiceReference(Bundle bundle,
+            String itf, String filter) {
+        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
+        if (refs.length != 0) {
+            return refs[0];
+        } else {
+            // No service found
+            return null;
+        }
+    }
+
+    /**
+     * Checks if the service is available.
+     * @param itf the service interface
+     * @return <code>true</code> if the service is available, <code>false</code>
+     *         otherwise.
+     */
+    public boolean isServiceAvailable(String itf) {
+        ServiceReference ref = getServiceReference(itf, null);
+        return ref != null;
+    }
+
+    /**
+     * Checks if the service is available.
+     * @param itf the service interface
+     * @param pid the service pid
+     * @return <code>true</code> if the service is available, <code>false</code>
+     *         otherwise.
+     */
+    public boolean isServiceAvailableByPID(String itf, String pid) {
+        ServiceReference ref = getServiceReferenceByPID(itf, pid);
+        return ref != null;
+    }
+
+    /**
+     * Returns the service reference of the service provided by the specified
+     * bundle, offering the specified interface and having the given persistent
+     * ID.
+     * 
+     * @param bundle the bundle from which the service is searched.
+     * @param itf the interface provided by the searched service.
+     * @param pid the persistent ID of the searched service.
+     * @return a service provided by the specified bundle, offering the
+     *         specified interface and having the given persistent ID.
+     */
+    public static ServiceReference getServiceReferenceByPID(Bundle bundle,
+            String itf, String pid) {
+        String filter = "(" + "service.pid" + "=" + pid + ")";
+        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
+        if (refs == null) {
+            return null;
+        } else if (refs.length == 1) {
+            return refs[0];
+        } else {
+            throw new IllegalStateException(
+                    "A service lookup by PID returned several providers ("
+                            + refs.length + ")" + " for " + itf + " with pid="
+                            + pid);
+        }
+    }
+
+    /**
+     * Returns the service reference of all the services provided in the
+     * specified bundle, offering the specified interface and matching the given
+     * filter.
+     * 
+     * @param bundle the bundle from which services are searched.
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return all the service references provided in the specified bundle,
+     *         offering the specified interface and matching the given filter.
+     *         If no service matches, an empty array is returned.
+     */
+    public static ServiceReference[] getServiceReferences(Bundle bundle,
+            String itf, String filter) {
+        ServiceReference[] refs = null;
+        try {
+            // Get all the service references
+            refs = bundle.getBundleContext().getServiceReferences(itf, filter);
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalArgumentException(
+                    "Cannot get service references: " + e.getMessage());
+        }
+        if (refs == null) {
+            return new ServiceReference[0];
+        } else {
+            return refs;
+        }
+    }
+
+    /**
+     * Returns the service object of a service provided by the local bundle,
+     * offering the specified interface and matching the given filter.
+     * 
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service object provided by the local bundle, offering the
+     *         specified interface and matching the given filter.
+     */
+    public Object getServiceObject(String itf, String filter) {
+        ServiceReference ref = getServiceReference(itf, filter);
+        if (ref != null) {
+            m_references.add(ref);
+            return context.getService(ref);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the service object associated with this service reference.
+     * 
+     * @param ref service reference
+     * @return the service object.
+     */
+    public Object getServiceObject(ServiceReference ref) {
+        if (ref != null) {
+            m_references.add(ref);
+            return context.getService(ref);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the service objects of the services provided by the local bundle,
+     * offering the specified interface and matching the given filter.
+     * 
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return the service objects provided by the local bundle, offering the
+     *         specified interface and matching the given filter.
+     */
+    public Object[] getServiceObjects(String itf, String filter) {
+        ServiceReference[] refs = getServiceReferences(itf, filter);
+        if (refs != null) {
+            Object[] list = new Object[refs.length];
+            for (int i = 0; i < refs.length; i++) {
+                m_references.add(refs[i]);
+                list[i] = context.getService(refs[i]);
+            }
+            return list;
+        } else {
+            return new Object[0];
+        }
+    }
+
+    /**
+     * Returns the service reference of a service provided by the local bundle,
+     * offering the specified interface and matching the given filter.
+     * 
+     * @param itf the interface provided by the searched service.
+     * @param filter an additional filter (can be {@code null}).
+     * @return a service reference provided by the local bundle, offering the
+     *         specified interface and matching the given filter. If no service
+     *         is found, {@code null} is returned.
+     */
+    public ServiceReference getServiceReference(String itf, String filter) {
+        return getServiceReference(context.getBundle(), itf, filter);
+    }
+
+    /**
+     * Returns the service reference of a service provided offering the
+     * specified interface.
+     * 
+     * @param itf the interface provided by the searched service.
+     * @return a service reference provided by the local bundle, offering the
+     *         specified interface and matching the given filter. If no service
+     *         is found, {@code null} is returned.
+     */
+    public ServiceReference getServiceReference(String itf) {
+        return getServiceReference(context.getBundle(), itf, null);
+    }
+
+    /**
+     * Returns the service reference of the service provided by the local
+     * bundle, offering the specified interface and having the given persistent
+     * ID.
+     * 
+     * @param itf the interface provided by the searched service.
+     * @param pid the persistent ID of the searched service.
+     * @return a service provided by the local bundle, offering the specified
+     *         interface and having the given persistent ID.
+     */
+    public ServiceReference getServiceReferenceByPID(String itf, String pid) {
+        return getServiceReferenceByPID(context.getBundle(), itf, pid);
+    }
+
+    /**
+     * Returns the service reference of all the services provided in the local
+     * bundle, offering the specified interface and matching the given filter.
+     * 
+     * @param itf the interface provided by the searched services.
+     * @param filter an additional filter (can be {@code null}).
+     * @return all the service references provided in the local bundle, offering
+     *         the specified interface and matching the given filter. If no
+     *         service matches, an empty array is returned.
+     */
+    public ServiceReference[] getServiceReferences(String itf, String filter) {
+        return getServiceReferences(context.getBundle(), itf, filter);
+    }
+    
+    /**
+     * Gets the package admin exposed by the framework.
+     * Fails if the package admin is not available. 
+     * @return the package admin service.
+     */
+    public PackageAdmin getPackageAdmin() {
+        PackageAdmin pa = (PackageAdmin) getServiceObject(PackageAdmin.class.getName(), null);
+        if (pa == null) {
+            fail("No package admin available");
+        }
+        return pa;
+    }
+    
+    /**
+     * Refresh the packages.
+     * Fails if the package admin service is not available.
+     */
+    public void refresh() {
+        getPackageAdmin().refreshPackages(null);
+    }
+    
+    /**
+     * Waits for a service. Fails on timeout.
+     * If timeout is set to 0, it sets the timeout to 10s.
+     * @param itf the service interface
+     * @param filter  the filter
+     * @param timeout the timeout
+     */
+    public void waitForService(String itf, String filter, long timeout) {
+        if (timeout == 0) {
+            timeout = 10000; // Default 10 secondes.
+        }
+        ServiceReference[] refs = getServiceReferences(itf, filter);
+        long begin = System.currentTimeMillis();
+        if (refs.length != 0) {
+            return;
+        } else {
+            while(refs.length == 0) {
+                try {
+                    Thread.sleep(5);
+                } catch (InterruptedException e) {
+                    // Interrupted
+                }
+                long now = System.currentTimeMillis();
+                
+                if ((now - begin) > timeout) {
+                    fail("Timeout ... no services matching with the request after " + timeout + "ms");
+                }
+                refs = getServiceReferences(itf, filter);
+            }
+        }
+    }
+    
+    
+    /**
+     * Installs a bundle.
+     * Fails if the bundle cannot be installed.
+     * Be aware that you have to uninstall the bundle yourself.
+     * @param url bundle url
+     * @return the installed bundle
+     */
+    public Bundle installBundle(String url) {
+        try {
+            return context.installBundle(url);
+        } catch (BundleException e) {
+            fail("Cannot install the bundle " + url + " : " + e.getMessage());
+        }
+        return null; // Can not happen
+    }
+    
+    /**
+     * Installs a bundle.
+     * Fails if the bundle cannot be installed.
+     * Be aware that you have to uninstall the bundle yourself.
+     * @param url bundle url
+     * @param stream input stream containing the bundle
+     * @return the installed bundle
+     */
+    public Bundle installBundle(String url, InputStream stream) {
+        try {
+            return context.installBundle(url, stream);
+        } catch (BundleException e) {
+            fail("Cannot install the bundle " + url + " : " + e.getMessage());
+        }
+        return null; // Can not happen
+    }
+    
+    /**
+     * Installs and starts a bundle.
+     * Fails if the bundle cannot be installed or an error occurs
+     * during startup. Be aware that you have to uninstall the bundle
+     * yourself.
+     * @param url the bundle url
+     * @return the Bundle object.
+     */
+    public Bundle installAndStart(String url) {
+        Bundle bundle = installBundle(url);
+        try {
+            bundle.start();
+        } catch (BundleException e) {
+           fail("Cannot start the bundle " + url + " : " + e.getMessage());
+        }
+        return bundle;
+    }
+    
+    /**
+     * Installs and starts a bundle.
+     * Fails if the bundle cannot be installed or an error occurs
+     * during startup. Be aware that you have to uninstall the bundle
+     * yourself.
+     * @param url the bundle url
+     * @param stream input stream containing the bundle
+     * @return the Bundle object.
+     */
+    public Bundle installAndStart(String url, InputStream stream) {
+        Bundle bundle = installBundle(url, stream);
+        try {
+            bundle.start();
+        } catch (BundleException e) {
+           fail("Cannot start the bundle " + url + " : " + e.getMessage());
+        }
+        return bundle;
+    }
+    
+    /**
+     * Get the bundle by its id.
+     * @param bundleId the bundle id.
+     * @return the bundle with the given id.
+     */
+    public Bundle getBundle(long bundleId) {
+        return context.getBundle(bundleId);
+    }
+    
+    /**
+     * Gets a bundle by its symbolic name.
+     * Fails if no bundle matches.
+     * @param name the symbolic name of the bundle
+     * @return the bundle object.
+     */
+    public Bundle getBundle(String name) {
+        Bundle[] bundles = context.getBundles();
+        for (int i = 0; i < bundles.length; i++) {
+            if (name.equals(bundles[i].getSymbolicName())) {
+                return bundles[i];
+            }
+        }
+        fail("No bundles with the given symbolic name " + name);
+        return null; // should not happen
+    }
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/MyComponent.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/MyComponent.java
new file mode 100644
index 0000000000..71fcc94eb9
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/MyComponent.java
@@ -0,0 +1,11 @@
+package org.apache.felix.ipojo.tests.core.component;
+
+import org.apache.felix.ipojo.tests.core.service.MyService;
+
+public class MyComponent implements MyService {
+
+    public void foo() {
+        // Nothing to do.
+    }
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/EmptyHandler.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/EmptyHandler.java
new file mode 100644
index 0000000000..2a1db72a64
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/EmptyHandler.java
@@ -0,0 +1,27 @@
+package org.apache.felix.ipojo.tests.core.handler;
+
+import java.util.Dictionary;
+
+import org.apache.felix.ipojo.ConfigurationException;
+import org.apache.felix.ipojo.PrimitiveHandler;
+import org.apache.felix.ipojo.metadata.Element;
+
+public class EmptyHandler extends PrimitiveHandler {
+
+    @Override
+    public void configure(Element arg0, Dictionary arg1)
+            throws ConfigurationException {
+        info("Configured");
+    }
+
+    @Override
+    public void start() {
+        info("Started");
+    }
+
+    @Override
+    public void stop() {
+        info("Stopped");
+    }
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/MyService.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/MyService.java
new file mode 100644
index 0000000000..9ffaa52411
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/MyService.java
@@ -0,0 +1,7 @@
+package org.apache.felix.ipojo.tests.core.service;
+
+public interface MyService {
+
+    public void foo();
+
+}
diff --git a/ipojo/tests/pom.xml b/ipojo/tests/pom.xml
index 5cc2c9a68c..80ff621572 100644
--- a/ipojo/tests/pom.xml
+++ b/ipojo/tests/pom.xml
@@ -39,6 +39,7 @@
 	<module>core/service-dependency-comparator</module>
 	<module>core/service-providing-strategies</module>
 	<module>core/configuration</module>
+	<module>core/handler</module>
 	<module>core/external-handlers</module>
 	<module>core/bad-configurations</module>
 	<module>composite/composite-runtime</module>
