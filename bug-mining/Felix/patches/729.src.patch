diff --git a/framework/src/main/java/org/apache/felix/framework/ExtensionManager.java b/framework/src/main/java/org/apache/felix/framework/ExtensionManager.java
index 644e01cd42..4f9a565664 100644
--- a/framework/src/main/java/org/apache/felix/framework/ExtensionManager.java
+++ b/framework/src/main/java/org/apache/felix/framework/ExtensionManager.java
@@ -88,9 +88,19 @@ class ExtensionManager extends URLStreamHandler implements IContent
 
     static
     {
+        // pre-init the url sub-system as otherwise we don't work on gnu/classpath
+        ExtensionManager extensionManager = new ExtensionManager();
+        try 
+        {
+            (new URL("http://felix.extensions:9/")).openConnection();
+        }
+        catch (Throwable t)
+        {
+            // This doesn't matter much - we only need the above to init the url subsystem
+        }
+        
         // We use the secure action of Felix to add a new instance to the parent
         // classloader.
-        ExtensionManager extensionManager = new ExtensionManager();
         try
         {
             Felix.m_secureAction.addURLToURLClassLoader(Felix.m_secureAction.createURL(
@@ -98,7 +108,7 @@ class ExtensionManager extends URLStreamHandler implements IContent
                 "http://felix.extensions:9/", extensionManager),
                 Felix.class.getClassLoader());
         }
-        catch (Exception ex)
+        catch (Throwable ex)
         {
             // extension bundles will not be supported.
             extensionManager = null;
@@ -375,7 +385,6 @@ class ExtensionManager extends URLStreamHandler implements IContent
             }
             catch (Throwable ex)
             {
-                ex.printStackTrace();
                 m_logger.log(Logger.LOG_WARNING,
                     "Unable to start Felix Extension Activator", ex);
             }
diff --git a/framework/src/main/java/org/apache/felix/framework/ModuleImpl.java b/framework/src/main/java/org/apache/felix/framework/ModuleImpl.java
index 6c912bd61c..a294357fb0 100644
--- a/framework/src/main/java/org/apache/felix/framework/ModuleImpl.java
+++ b/framework/src/main/java/org/apache/felix/framework/ModuleImpl.java
@@ -112,7 +112,7 @@ public class ModuleImpl implements IModule
             m_secureAction.setAccesssible(ctor);
             cl = (ClassLoader) m_secureAction.invoke(ctor, new Object[] { null });
         }
-        catch (Exception ex)
+        catch (Throwable ex)
         {
             // On Android we get an exception if we set the parent class loader
             // to null, so we will work around that case by setting the parent
@@ -1602,7 +1602,7 @@ public class ModuleImpl implements IModule
             dexFileClassLoadClass = dexFileClass.getMethod("loadClass",
                 new Class[] { String.class, ClassLoader.class });
         }
-        catch (Exception ex)
+        catch (Throwable ex)
         {
            dexFileClassConstructor = null;
            dexFileClassLoadDex = null;
diff --git a/framework/src/main/java/org/apache/felix/framework/URLHandlers.java b/framework/src/main/java/org/apache/felix/framework/URLHandlers.java
index 5f368421a6..f67b0481fb 100644
--- a/framework/src/main/java/org/apache/felix/framework/URLHandlers.java
+++ b/framework/src/main/java/org/apache/felix/framework/URLHandlers.java
@@ -125,7 +125,6 @@ class URLHandlers implements URLStreamHandlerFactory, ContentHandlerFactory
         }
         catch (Throwable ex)
         {
-            ex.printStackTrace();
             // Ignore, this is a best effort (maybe log it or something).
         }
     }
@@ -150,7 +149,6 @@ class URLHandlers implements URLStreamHandlerFactory, ContentHandlerFactory
         }
         catch (Throwable ex)
         {
-            ex.printStackTrace();
             // Ignore, this is a best effort (maybe log it or something)
         }
         m_sm = new SecurityManagerEx();
@@ -161,6 +159,15 @@ class URLHandlers implements URLStreamHandlerFactory, ContentHandlerFactory
                 URL.setURLStreamHandlerFactory(this);
                 m_streamHandlerFactory = this;
                 m_rootURLHandlers = this;
+                // try to flush the cache (gnu/classpath doesn't do it itself)
+                try
+                {
+                    m_secureAction.flush(URL.class, URL.class);
+                }
+                catch (Throwable t)
+                {
+                    // Not much we can do
+                }
             }
             catch (Error err)
             {
@@ -208,6 +215,15 @@ class URLHandlers implements URLStreamHandlerFactory, ContentHandlerFactory
             {
                 URLConnection.setContentHandlerFactory(this);
                 m_contentHandlerFactory = this;
+                // try to flush the cache (gnu/classpath doesn't do it itself)
+                try
+                {
+                    m_secureAction.flush(URLConnection.class, URLConnection.class);
+                }
+                catch (Throwable t)
+                {
+                    // Not much we can do
+                }
             }
             catch (Error err)
             {
@@ -341,7 +357,7 @@ class URLHandlers implements URLStreamHandlerFactory, ContentHandlerFactory
                         (URLStreamHandler) handler.newInstance());
                 }
             }
-            catch (Exception ex)
+            catch (Throwable ex)
             {
                 // This could be a class not found exception or an
                 // instantiation exception, not much we can do in either
diff --git a/framework/src/main/java/org/apache/felix/framework/URLHandlersStreamHandlerProxy.java b/framework/src/main/java/org/apache/felix/framework/URLHandlersStreamHandlerProxy.java
index 36708c93d7..09d0337a95 100644
--- a/framework/src/main/java/org/apache/felix/framework/URLHandlersStreamHandlerProxy.java
+++ b/framework/src/main/java/org/apache/felix/framework/URLHandlersStreamHandlerProxy.java
@@ -28,8 +28,6 @@ import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
-import java.util.Collections;
-import java.util.Arrays;
 
 import org.apache.felix.framework.util.SecureAction;
 import org.osgi.service.url.URLStreamHandlerService;
@@ -360,6 +358,10 @@ public class URLHandlersStreamHandlerProxy extends URLStreamHandler
         }
     }
 
+    // We use this thread local to detect whether we have a reentrant entry to the parseURL 
+    // method. This can happen do to some difference between gnu/classpath and sun jvms
+    // For more see inside the method.
+    private static final ThreadLocal m_loopCheck = new ThreadLocal();
     protected void parseURL(URL url, String spec, int start, int limit)
     {
         Object svc = getStreamHandlerService();
@@ -377,17 +379,50 @@ public class URLHandlersStreamHandlerProxy extends URLStreamHandler
             try 
             {
                 URL test = null;
+                // In order to cater for built-in urls being over-writable we need to use a 
+                // somewhat strange hack. We use a hidden feature inside the jdk which passes
+                // the handler of the url given as a context to a new URL to that URL as its
+                // handler. This way, we can create a new URL which will use the given built-in
+                // handler to parse the url. Subsequently, we can use the information from that
+                // URL to call set with the correct values. 
                 if (m_builtInURL != null)
                 {
-                    test = new URL(new URL(m_builtInURL, url.toExternalForm()), spec);
+                    // However, if we are on gnu/classpath we have to pass the handler directly
+                    // because the hidden feature is not there. Funnily, the workaround to pass
+                    // pass the handler directly doesn't work on sun as their handler detects
+                    // that it is not the same as the one inside the url and throws an exception
+                    // Luckily it doesn't do that on gnu/classpath. We detect that we need to 
+                    // pass the handler directly by using the m_loopCheck thread local to detect
+                    // that we parseURL has been called inside a call to parseURL.
+                    if (m_loopCheck.get() != null)
+                    {
+                        test = new URL(new URL(m_builtInURL, url.toExternalForm()), spec, (URLStreamHandler) svc);
+                    }
+                    else
+                    {
+                        // Set-up the thread local as we don't expect to be called again until we are
+                        // done. Otherwise, we are on gnu/classpath
+                        m_loopCheck.set(Thread.currentThread());
+                        try
+                        {
+                            test = new URL(new URL(m_builtInURL, url.toExternalForm()), spec);
+                        }
+                        finally
+                        {
+                            m_loopCheck.set(null);
+                        }
+                    }
                 }
                 else
                 {
+                    // We don't have a url with a built-in handler for this but still want to create
+                    // the url with the buil-in handler as we could find one now. This might not 
+                    // work for all handlers on sun but it is better then doing nothing. 
                     test = m_action.createURL(url, spec, (URLStreamHandler) svc);
                 }
-                    
+
                 super.setURL(url, test.getProtocol(), test.getHost(), test.getPort(),test.getAuthority(), 
-                   test.getUserInfo(), test.getPath(), test.getQuery(), test.getRef());
+                    test.getUserInfo(), test.getPath(), test.getQuery(), test.getRef());
             } 
             catch (Exception ex)  
             {
@@ -452,8 +487,17 @@ public class URLHandlersStreamHandlerProxy extends URLStreamHandler
         {
             try 
             {
-                return (String) TO_EXTERNAL_FORM.invoke( 
+                String result = (String) TO_EXTERNAL_FORM.invoke( 
                     svc, new Object[]{url});
+                
+                // mika does return an invalid format if we have a url with the 
+                // protocol only (<proto>://null) - we catch this case now
+                if ((result != null) && (result.equals(url.getProtocol() + "://null")))
+                {
+                    result = url.getProtocol() + ":";
+                }
+                
+                return result;
             }
             catch (InvocationTargetException ex)
             {
@@ -484,7 +528,7 @@ public class URLHandlersStreamHandlerProxy extends URLStreamHandler
             answer.append(url.getProtocol());
             answer.append(':');
             String authority = url.getAuthority();
-            if (authority != null && authority.length() > 0) 
+            if ((authority != null) && (authority.length() > 0)) 
             {
                 answer.append("//"); //$NON-NLS-1$
                 answer.append(url.getAuthority());
@@ -563,6 +607,13 @@ public class URLHandlersStreamHandlerProxy extends URLStreamHandler
         }
         catch (Throwable t)
         {
+            // In case that we are inside tomcat - the problem is that the webapp classloader
+            // creates a new url to load a class. This gets us to this method. Now, if we 
+            // trigger a classload while executing tomcat is creating a new url and we end-up with
+            // a loop which is cut short after two iterations (because of a circularclassload). 
+            // We catch this exception (and all others) and just return the built-in handler
+            // (if we have any) as this way we at least eventually get started (this just means 
+            // that we don't use the potentially provided built-in handler overwrite). 
             return m_builtIn;
         }
     }
diff --git a/framework/src/main/java/org/apache/felix/framework/util/SecureAction.java b/framework/src/main/java/org/apache/felix/framework/util/SecureAction.java
index 22fda7735f..ef9b979330 100644
--- a/framework/src/main/java/org/apache/felix/framework/util/SecureAction.java
+++ b/framework/src/main/java/org/apache/felix/framework/util/SecureAction.java
@@ -22,6 +22,7 @@ import java.io.*;
 import java.lang.reflect.*;
 import java.net.*;
 import java.security.*;
+import java.util.HashMap;
 import java.util.Hashtable;
 
 import org.osgi.framework.BundleActivator;
@@ -996,6 +997,60 @@ public class SecureAction
         return null;
     }
 
+    public void flush(Class targetClazz, Object lock) throws Exception
+    {
+        if (System.getSecurityManager() != null)
+        {
+            Actions actions = (Actions) m_actions.get();
+            actions.set(Actions.FLUSH_FIELD_ACTION, targetClazz, lock);
+            try
+            {
+                AccessController.doPrivileged(actions, m_acc);
+            }
+            catch (PrivilegedActionException e)
+            {
+                throw e.getException();
+            }
+        }
+        else
+        {
+            _flush(targetClazz, lock);
+        }
+    }
+
+    private static void _flush(Class targetClazz, Object lock) throws Exception
+    {
+        synchronized (lock) 
+        {
+            Field[] fields = targetClazz.getDeclaredFields();
+            // reset cache
+            for (int i = 0; i < fields.length; i++)
+            {
+                if (Modifier.isStatic(fields[i].getModifiers()) &&
+                    ((fields[i].getType() == Hashtable.class) || (fields[i].getType() == HashMap.class)))
+                {
+                    fields[i].setAccessible(true);
+                    if (fields[i].getType() == Hashtable.class)
+                    {
+                        Hashtable cache = (Hashtable) fields[i].get(null);
+                        if (cache != null)
+                        {
+                            cache.clear();
+                        }
+                    }
+                    else
+                    {
+                        HashMap cache = (HashMap) fields[i].get(null);
+                        if (cache != null)
+                        {
+                            cache.clear();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
     private static class Actions implements PrivilegedExceptionAction
     {
         public static final int INITIALIZE_CONTEXT = 0;
@@ -1038,6 +1093,7 @@ public class SecureAction
         public static final int STOP_ACTIVATOR_ACTION = 37;
         public static final int SWAP_FIELD_ACTION = 38;
         public static final int SYSTEM_EXIT_ACTION = 39;
+        public static final int FLUSH_FIELD_ACTION = 40;
 
         private int m_action = -1;
         private Object m_arg1 = null;
@@ -1280,6 +1336,10 @@ public class SecureAction
             {
                 ((AccessibleObject) arg1).setAccessible(true);
             }
+            else if (action == FLUSH_FIELD_ACTION)
+            {
+                _flush(((Class) arg1), arg2);
+            }
 
             return null;
         }
