diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/ActivateMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/ActivateMethod.java
index 981d25825b..3ee8ff6a29 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/ActivateMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/ActivateMethod.java
@@ -35,14 +35,14 @@ public class ActivateMethod extends BaseMethod
         { COMPONENT_CONTEXT_CLASS };
 
 
-    public ActivateMethod( final SimpleLogger logger, final String methodName,
-        final boolean methodRequired, final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
+    public ActivateMethod( final String methodName,
+            final boolean methodRequired, final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, methodRequired, componentClass, isDS11, isDS12Felix );
+        super( methodName, methodRequired, componentClass, isDS11, isDS12Felix );
     }
 
 
-    protected Method doFindMethod( Class targetClass, boolean acceptPrivate, boolean acceptPackage )
+    protected Method doFindMethod( Class targetClass, boolean acceptPrivate, boolean acceptPackage, SimpleLogger logger )
         throws SuitableMethodNotAccessibleException, InvocationTargetException
     {
 
@@ -50,7 +50,7 @@ public class ActivateMethod extends BaseMethod
 
         try
         {
-            final Method method = getSingleParameterMethod( targetClass, acceptPrivate, acceptPackage );
+            final Method method = getSingleParameterMethod( targetClass, acceptPrivate, acceptPackage, logger );
             if ( method != null )
             {
                 return method;
@@ -86,7 +86,7 @@ public class ActivateMethod extends BaseMethod
                 try
                 {
                     // find the declared method in this class
-                    Method m = getMethod( targetClass, getMethodName(), null, acceptPrivate, acceptPackage );
+                    Method m = getMethod( targetClass, getMethodName(), null, acceptPrivate, acceptPackage, logger );
                     if ( m != null ) {
                         return m;
                     }
@@ -142,11 +142,11 @@ public class ActivateMethod extends BaseMethod
         return "activate";
     }
 
-    public MethodResult invoke(Object componentInstance, Object rawParameter, final MethodResult methodCallFailureResult)
+    public MethodResult invoke( Object componentInstance, Object rawParameter, final MethodResult methodCallFailureResult, SimpleLogger logger )
     {
-        if (methodExists())
+        if (methodExists( logger ))
         {
-            return super.invoke(componentInstance, rawParameter, methodCallFailureResult);
+            return super.invoke(componentInstance, rawParameter, methodCallFailureResult, logger );
         }
         return null;
     }
@@ -156,12 +156,14 @@ public class ActivateMethod extends BaseMethod
      * {@link #getAcceptedParameterTypes()} or <code>null</code> if no such
      * method exists.
      *
+     *
      * @param targetClass The class in which to look for the method. Only this
      *      class is searched for the method.
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class.
      * @throws SuitableMethodNotAccessibleException If a suitable method was
@@ -170,7 +172,7 @@ public class ActivateMethod extends BaseMethod
      *      trying to find the requested method.
      */
     private Method getSingleParameterMethod( final Class targetClass, final boolean acceptPrivate,
-        final boolean acceptPackage ) throws SuitableMethodNotAccessibleException, InvocationTargetException
+            final boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException, InvocationTargetException
     {
         SuitableMethodNotAccessibleException ex = null;
         Method singleParameterMethod = null;
@@ -181,11 +183,11 @@ public class ActivateMethod extends BaseMethod
             {
                 // find the declared method in this class
                 singleParameterMethod = getMethod( targetClass, getMethodName(), new Class[]
-                    { acceptedTypes[i] }, acceptPrivate, acceptPackage );
+                    { acceptedTypes[i] }, acceptPrivate, acceptPackage, logger );
             }
             catch ( SuitableMethodNotAccessibleException thrown )
             {
-                getLogger().log( LogService.LOG_DEBUG, "SuitableMethodNotAccessible", thrown );
+                logger.log( LogService.LOG_DEBUG, "SuitableMethodNotAccessible", thrown );
                 ex = thrown;
             }
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/BaseMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/BaseMethod.java
index eae9d206ad..747d50e939 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/BaseMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/BaseMethod.java
@@ -44,7 +44,6 @@ abstract class BaseMethod
     protected static final Class MAP_CLASS = Map.class;
     protected static final Class INTEGER_CLASS = Integer.class;
 
-    private final SimpleLogger m_logger;
     private final boolean isDS11;
     private final boolean isDS12Felix;
 
@@ -57,17 +56,16 @@ abstract class BaseMethod
 
     private volatile State m_state;
 
-    protected BaseMethod( final SimpleLogger logger, final String methodName,
+    protected BaseMethod( final String methodName,
             final Class componentClass, final boolean ds11, final boolean ds12Felix )
     {
-        this( logger, methodName, methodName != null, componentClass, ds11, ds12Felix );
+        this( methodName, methodName != null, componentClass, ds11, ds12Felix );
     }
 
 
-    protected BaseMethod( final SimpleLogger logger, final String methodName,
+    protected BaseMethod( final String methodName,
             final boolean methodRequired, final Class componentClass, final boolean ds11, final boolean ds12Felix )
     {
-        m_logger = logger;
         m_methodName = methodName;
         m_methodRequired = methodRequired;
         m_componentClass = componentClass;
@@ -83,13 +81,6 @@ abstract class BaseMethod
         }
     }
 
-
-    protected final SimpleLogger getLogger()
-    {
-        return m_logger;
-    }
-
-
     protected final boolean isDS11()
     {
         return isDS11;
@@ -118,27 +109,27 @@ abstract class BaseMethod
     }
 
 
-    synchronized void setMethod( Method method )
+    synchronized void setMethod( Method method, SimpleLogger logger )
     {
         this.m_method = method;
 
         if ( method != null )
         {
             m_state = Resolved.INSTANCE;
-            getLogger().log( LogService.LOG_DEBUG, "Found {0} method: {1}", new Object[]
+            logger.log( LogService.LOG_DEBUG, "Found {0} method: {1}", new Object[]
                 { getMethodNamePrefix(), method }, null );
         }
         else if ( m_methodRequired )
         {
             m_state = NotFound.INSTANCE;
-            getLogger().log(LogService.LOG_ERROR, "{0} method [{1}] not found; Component will fail",
+            logger.log(LogService.LOG_ERROR, "{0} method [{1}] not found; Component will fail",
                 new Object[]
                     { getMethodNamePrefix(), getMethodName() }, null);
         }
         else
         {
             // optional method not found, log as DEBUG and ignore
-            getLogger().log( LogService.LOG_DEBUG, "{0} method [{1}] not found, ignoring", new Object[]
+            logger.log( LogService.LOG_DEBUG, "{0} method [{1}] not found, ignoring", new Object[]
                 { getMethodNamePrefix(), getMethodName() }, null );
             m_state = NotApplicable.INSTANCE;
         }
@@ -161,8 +152,9 @@ abstract class BaseMethod
      *      can be found in the target class or any super class.
      * @throws InvocationTargetException If an unexpected Throwable is caught
      *      trying to find the requested method.
+     * @param logger
      */
-    private Method findMethod() throws InvocationTargetException
+    private Method findMethod( SimpleLogger logger ) throws InvocationTargetException
     {
         boolean acceptPrivate = isDS11();
         boolean acceptPackage = isDS11();
@@ -174,15 +166,15 @@ abstract class BaseMethod
         for ( Class theClass = targetClass; theClass != null; )
         {
 
-            if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
-                getLogger().log( LogService.LOG_DEBUG,
+                logger.log( LogService.LOG_DEBUG,
                     "Locating method " + getMethodName() + " in class " + theClass.getName(), null );
             }
 
             try
             {
-                Method method = doFindMethod( theClass, acceptPrivate, acceptPackage );
+                Method method = doFindMethod( theClass, acceptPrivate, acceptPackage, logger );
                 if ( method != null )
                 {
                     return method;
@@ -191,7 +183,7 @@ abstract class BaseMethod
             catch ( SuitableMethodNotAccessibleException ex )
             {
                 // log and return null
-                getLogger().log( LogService.LOG_ERROR,
+                logger.log( LogService.LOG_ERROR,
                     "findMethod: Suitable but non-accessible method {0} found in class {1}, subclass of {2}", new Object[]
                         { getMethodName(), theClass.getName(), targetClass.getName() }, null );
                 break;
@@ -220,13 +212,13 @@ abstract class BaseMethod
 
 
     protected abstract Method doFindMethod( final Class targetClass, final boolean acceptPrivate,
-        final boolean acceptPackage ) throws SuitableMethodNotAccessibleException, InvocationTargetException;
+            final boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException, InvocationTargetException;
 
 
-    private MethodResult invokeMethod( final Object componentInstance, final Object rawParameter )
+    private MethodResult invokeMethod( final Object componentInstance, final Object rawParameter, SimpleLogger logger )
         throws InvocationTargetException
     {
-        getLogger().log( LogService.LOG_DEBUG, "invoking {0}: {1}", new Object[]
+        logger.log( LogService.LOG_DEBUG, "invoking {0}: {1}", new Object[]
             { getMethodNamePrefix(), getMethodName() }, null );
         try
         {
@@ -234,20 +226,20 @@ abstract class BaseMethod
             {
                 final Object[] params = getParameters(m_method, rawParameter);
                 Object result = m_method.invoke(componentInstance, params);
-                getLogger().log( LogService.LOG_DEBUG, "invoked {0}: {1}: parameters {2}", new Object[]
+                logger.log( LogService.LOG_DEBUG, "invoked {0}: {1}: parameters {2}", new Object[]
                     { getMethodNamePrefix(), getMethodName(), Arrays.asList( params ) }, null );
                 return new MethodResult((m_method.getReturnType() != Void.TYPE), (Map) result);
             }
             else
             {
-                getLogger().log( LogService.LOG_WARNING, "Method {0} cannot be called on null object",
+                logger.log( LogService.LOG_WARNING, "Method {0} cannot be called on null object",
                     new Object[]
                         { getMethodName() }, null );
             }
         }
         catch ( IllegalStateException ise )
         {
-            getLogger().log( LogService.LOG_DEBUG, ise.getMessage(), null );
+            logger.log( LogService.LOG_DEBUG, ise.getMessage(), null );
             return null;
         }
         catch ( IllegalAccessException ex )
@@ -255,7 +247,7 @@ abstract class BaseMethod
             // 112.3.1 If the method is not is not declared protected or
             // public, SCR must log an error message with the log service,
             // if present, and ignore the method
-            getLogger().log( LogService.LOG_DEBUG, "Method {0} cannot be called", new Object[]
+            logger.log( LogService.LOG_DEBUG, "Method {0} cannot be called", new Object[]
                 { getMethodName() }, ex );
         }
         catch ( InvocationTargetException ex )
@@ -267,7 +259,7 @@ abstract class BaseMethod
             throw new InvocationTargetException( t );
         }
 
-        // assume success (also if the mehotd is not available or accessible)
+        // assume success (also if the method is not available or accessible)
         return MethodResult.VOID; // TODO: or null ??
     }
 
@@ -304,11 +296,13 @@ abstract class BaseMethod
      * the method is returned. Enforcing accessibility is required to support
      * invocation of protected methods.
      *
+     *
      * @param clazz The <code>Class</code> which provides the method.
      * @param name The name of the method.
      * @param parameterTypes The parameters to the method. Passing
      *      <code>null</code> is equivalent to using an empty array.
      *
+     * @param logger
      * @return The named method with enforced accessibility or <code>null</code>
      *      if no such method exists in the class.
      *
@@ -319,7 +313,7 @@ abstract class BaseMethod
      *      trying to access the desired method.
      */
     public /* static */ Method getMethod( Class clazz, String name, Class[] parameterTypes, boolean acceptPrivate,
-        boolean acceptPackage ) throws SuitableMethodNotAccessibleException,
+            boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException,
         InvocationTargetException
     {
         try
@@ -340,10 +334,10 @@ abstract class BaseMethod
         {
             // thrown if no method is declared with the given name and
             // parameters
-            if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
                 String argList = ( parameterTypes != null ) ? Arrays.asList( parameterTypes ).toString() : "";
-                getLogger().log( LogService.LOG_DEBUG, "Declared Method {0}.{1}({2}) not found", new Object[]
+                logger.log( LogService.LOG_DEBUG, "Declared Method {0}.{1}({2}) not found", new Object[]
                     { clazz.getName(), name, argList }, null );
             }
         }
@@ -352,7 +346,7 @@ abstract class BaseMethod
             // may be thrown if a method would be found but the signature
             // contains throws declaration for an exception which cannot
             // be loaded
-            if ( getLogger().isLogEnabled( LogService.LOG_WARNING ) )
+            if ( logger.isLogEnabled( LogService.LOG_WARNING ) )
             {
                 StringBuffer buf = new StringBuffer();
                 buf.append( "Failure loooking up method " ).append( name ).append( '(' );
@@ -365,7 +359,7 @@ abstract class BaseMethod
                     }
                 }
                 buf.append( ") in class class " ).append( clazz.getName() ).append( ". Assuming no such method." );
-                getLogger().log( LogService.LOG_WARNING, buf.toString(), cdfe );
+                logger.log( LogService.LOG_WARNING, buf.toString(), cdfe );
             }
         }
         catch ( SuitableMethodNotAccessibleException e)
@@ -386,7 +380,7 @@ abstract class BaseMethod
 
     /**
      * Returns <code>true</code> if the method is acceptable to be returned from the
-     * {@link #getMethod(Class, String, Class[], boolean, boolean)} and also
+     * {@link #getMethod(Class, String, Class[], boolean, boolean, SimpleLogger)} and also
      * makes the method accessible.
      * <p>
      * This method returns <code>true</code> iff:
@@ -475,6 +469,7 @@ abstract class BaseMethod
      *
      *
      *
+     *
      * @param componentInstance The component instance on which to call the
      *      method
      * @param rawParameter The parameter container providing the actual
@@ -482,6 +477,7 @@ abstract class BaseMethod
      * @param methodCallFailureResult The result to return from this method if
      *      calling the method resulted in an exception.
      *
+     * @param logger
      * @return <code>true</code> if the method was called successfully or the
      *      method was not found and was not required. <code>false</code> if
      *      the method was not found but required.
@@ -489,15 +485,15 @@ abstract class BaseMethod
      *      found and called, but the method threw an exception.
      */
     public MethodResult invoke( final Object componentInstance, final Object rawParameter,
-            final MethodResult methodCallFailureResult )
+            final MethodResult methodCallFailureResult, SimpleLogger logger )
     {
         try
         {
-            return m_state.invoke( this, componentInstance, rawParameter );
+            return m_state.invoke( this, componentInstance, rawParameter, logger );
         }
         catch ( InvocationTargetException ite )
         {
-            getLogger().log( LogService.LOG_ERROR, "The {0} method has thrown an exception", new Object[]
+            logger.log( LogService.LOG_ERROR, "The {0} method has thrown an exception", new Object[]
                 { getMethodName() }, ite.getCause() );
         }
 
@@ -505,19 +501,19 @@ abstract class BaseMethod
     }
 
 
-    public boolean methodExists()
+    public boolean methodExists( SimpleLogger logger )
     {
-        return m_state.methodExists( this );
+        return m_state.methodExists( this, logger );
     }
 
     private static interface State
     {
 
-        MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter )
+        MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter, SimpleLogger logger )
             throws InvocationTargetException;
 
 
-        boolean methodExists( final BaseMethod baseMethod );
+        boolean methodExists( final BaseMethod baseMethod, SimpleLogger logger );
     }
 
     private static class NotApplicable implements State
@@ -526,13 +522,13 @@ abstract class BaseMethod
         private static final State INSTANCE = new NotApplicable();
 
 
-        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter )
+        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter, SimpleLogger logger )
         {
             return MethodResult.VOID;
         }
 
 
-        public boolean methodExists( final BaseMethod baseMethod )
+        public boolean methodExists( final BaseMethod baseMethod, SimpleLogger logger )
         {
             return true;
         }
@@ -543,40 +539,40 @@ abstract class BaseMethod
         private static final State INSTANCE = new NotResolved();
 
 
-        private void resolve( final BaseMethod baseMethod )
+        private void resolve( final BaseMethod baseMethod, SimpleLogger logger )
         {
-            baseMethod.getLogger().log( LogService.LOG_DEBUG, "getting {0}: {1}", new Object[]
+            logger.log( LogService.LOG_DEBUG, "getting {0}: {1}", new Object[]
                     {baseMethod.getMethodNamePrefix(), baseMethod.getMethodName()}, null );
 
             // resolve the method
             Method method;
             try
             {
-                method = baseMethod.findMethod();
+                method = baseMethod.findMethod( logger );
             }
             catch ( InvocationTargetException ex )
             {
                 method = null;
-                baseMethod.getLogger().log( LogService.LOG_WARNING, "{0} cannot be found", new Object[]
+                logger.log( LogService.LOG_WARNING, "{0} cannot be found", new Object[]
                         {baseMethod.getMethodName()}, ex.getTargetException() );
             }
 
-            baseMethod.setMethod( method );
+            baseMethod.setMethod( method, logger );
         }
 
 
-        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter )
+        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter, SimpleLogger logger )
             throws InvocationTargetException
         {
-            resolve( baseMethod );
-            return baseMethod.getState().invoke( baseMethod, componentInstance, rawParameter );
+            resolve( baseMethod, logger );
+            return baseMethod.getState().invoke( baseMethod, componentInstance, rawParameter, logger );
         }
 
 
-        public boolean methodExists( final BaseMethod baseMethod )
+        public boolean methodExists( final BaseMethod baseMethod, SimpleLogger logger )
         {
-            resolve( baseMethod );
-            return baseMethod.getState().methodExists( baseMethod );
+            resolve( baseMethod, logger );
+            return baseMethod.getState().methodExists( baseMethod, logger );
         }
     }
 
@@ -585,18 +581,18 @@ abstract class BaseMethod
         private static final State INSTANCE = new NotFound();
 
 
-        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter )
+        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter, SimpleLogger logger )
         {
             // 112.3.1 If the method is not found , SCR must log an error
             // message with the log service, if present, and ignore the
             // method
-            baseMethod.getLogger().log( LogService.LOG_ERROR, "{0} method [{1}] not found", new Object[]
+            logger.log( LogService.LOG_ERROR, "{0} method [{1}] not found", new Object[]
                 { baseMethod.getMethodNamePrefix(), baseMethod.getMethodName() }, null );
             return null;
         }
 
 
-        public boolean methodExists( final BaseMethod baseMethod )
+        public boolean methodExists( final BaseMethod baseMethod, SimpleLogger logger )
         {
             return false;
         }
@@ -607,14 +603,14 @@ abstract class BaseMethod
         private static final State INSTANCE = new Resolved();
 
 
-        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter )
+        public MethodResult invoke( final BaseMethod baseMethod, final Object componentInstance, final Object rawParameter, SimpleLogger logger )
             throws InvocationTargetException
         {
-            return baseMethod.invokeMethod( componentInstance, rawParameter );
+            return baseMethod.invokeMethod( componentInstance, rawParameter, logger );
         }
 
 
-        public boolean methodExists( final BaseMethod baseMethod )
+        public boolean methodExists( final BaseMethod baseMethod, SimpleLogger logger )
         {
             return true;
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethod.java
index 2c0f91b61d..b1f843852a 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethod.java
@@ -23,7 +23,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
 import org.apache.felix.scr.impl.Activator;
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
 import org.apache.felix.scr.impl.manager.RefPair;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
@@ -49,10 +48,10 @@ public class BindMethod extends BaseMethod
     private int m_paramStyle;
 
 
-    public BindMethod( final SimpleLogger logger, final String methodName,
+    public BindMethod( final String methodName,
             final Class componentClass, final String referenceClassName, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, componentClass, isDS11, isDS12Felix );
+        super( methodName, componentClass, isDS11, isDS12Felix );
         m_referenceClassName = referenceClassName;
     }
 
@@ -63,17 +62,19 @@ public class BindMethod extends BaseMethod
      * the class hierarchy is traversed until a method is found or the root
      * of the class hierarchy is reached without finding a method.
      *
+     *
      * @param targetClass The class in which to look for the method
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class or any super class.
      * @throws InvocationTargetException If an unexpected Throwable is caught
      *      trying to find the requested method.
      */
-    protected Method doFindMethod( Class targetClass, boolean acceptPrivate, boolean acceptPackage )
+    protected Method doFindMethod( Class targetClass, boolean acceptPrivate, boolean acceptPackage, SimpleLogger logger )
         throws SuitableMethodNotAccessibleException, InvocationTargetException
     {
         // 112.3.1 The method is searched for using the following priority
@@ -86,9 +87,9 @@ public class BindMethod extends BaseMethod
         // flag indicating a suitable but inaccessible method has been found
         boolean suitableMethodNotAccessible = false;
 
-        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log( LogService.LOG_DEBUG,
+            logger.log( LogService.LOG_DEBUG,
                 "doFindMethod: Looking for method " + targetClass.getName() + "." + getMethodName(), null );
         }
 
@@ -96,12 +97,12 @@ public class BindMethod extends BaseMethod
         Method method;
         try
         {
-            method = getServiceReferenceMethod( targetClass, acceptPrivate, acceptPackage );
+            method = getServiceReferenceMethod( targetClass, acceptPrivate, acceptPackage, logger );
             if ( method != null )
             {
-                if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+                if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
                 {
-                    getLogger().log( LogService.LOG_DEBUG, "doFindMethod: Found Method " + method, null );
+                    logger.log( LogService.LOG_DEBUG, "doFindMethod: Found Method " + method, null );
                 }
                 m_paramStyle = SERVICE_REFERENCE;
                 return method;
@@ -113,13 +114,13 @@ public class BindMethod extends BaseMethod
         }
 
         // for further methods we need the class of the service object
-        final Class parameterClass = getParameterClass( targetClass );
+        final Class parameterClass = getParameterClass( targetClass, logger );
         if ( parameterClass != null )
         {
 
-            if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
-                getLogger().log(
+                logger.log(
                     LogService.LOG_DEBUG,
                     "doFindMethod: No method taking ServiceReference found, checking method taking "
                         + parameterClass.getName(), null );
@@ -128,7 +129,7 @@ public class BindMethod extends BaseMethod
             // Case 2 - Service object parameter
             try
             {
-                method = getServiceObjectMethod( targetClass, parameterClass, acceptPrivate, acceptPackage );
+                method = getServiceObjectMethod( targetClass, parameterClass, acceptPrivate, acceptPackage, logger );
                 if ( method != null )
                 {
                     m_paramStyle = SERVICE_OBJECT;
@@ -143,7 +144,7 @@ public class BindMethod extends BaseMethod
             // Case 3 - Service interface assignement compatible methods
             try
             {
-                method = getServiceObjectAssignableMethod( targetClass, parameterClass, acceptPrivate, acceptPackage );
+                method = getServiceObjectAssignableMethod( targetClass, parameterClass, acceptPrivate, acceptPackage, logger );
                 if ( method != null )
                 {
                     m_paramStyle = SERVICE_OBJECT;
@@ -162,7 +163,7 @@ public class BindMethod extends BaseMethod
                 // Case 4 - same as case 2, but + Map param (DS 1.1 only)
                 try
                 {
-                    method = getServiceObjectWithMapMethod( targetClass, parameterClass, acceptPrivate, acceptPackage );
+                    method = getServiceObjectWithMapMethod( targetClass, parameterClass, acceptPrivate, acceptPackage, logger );
                     if ( method != null )
                     {
                         m_paramStyle = SERVICE_OBJECT_AND_MAP;
@@ -193,9 +194,9 @@ public class BindMethod extends BaseMethod
             }
 
         }
-        else if ( getLogger().isLogEnabled( LogService.LOG_WARNING ) )
+        else if ( logger.isLogEnabled( LogService.LOG_WARNING ) )
         {
-            getLogger().log(
+            logger.log(
                 LogService.LOG_WARNING,
                 "doFindMethod: Cannot check for methods taking parameter class " + m_referenceClassName + ": "
                     + targetClass.getName() + " does not see it", null );
@@ -205,7 +206,7 @@ public class BindMethod extends BaseMethod
         // the suitable methods are accessible, we have to terminate
         if ( suitableMethodNotAccessible )
         {
-            getLogger().log( LogService.LOG_ERROR,
+            logger.log( LogService.LOG_ERROR,
                 "doFindMethod: Suitable but non-accessible method found in class {0}", new Object[]
                     { targetClass.getName() }, null );
             throw new SuitableMethodNotAccessibleException();
@@ -229,14 +230,14 @@ public class BindMethod extends BaseMethod
      *      if the class loader of the <code>targetClass</code> cannot see that
      *      class.
      */
-    private Class getParameterClass( final Class targetClass )
+    private Class getParameterClass( final Class targetClass, SimpleLogger logger )
     {
-        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log(
+            logger.log(
                 LogService.LOG_DEBUG,
-                "getParameterClass: Looking for interface class " + m_referenceClassName + "through loader of "
-                    + targetClass.getName(), null );
+                "getParameterClass: Looking for interface class {0} through loader of {1}",
+                    new Object[] {m_referenceClassName, targetClass.getName()}, null );
         }
 
         try
@@ -250,10 +251,10 @@ public class BindMethod extends BaseMethod
             }
 
             final Class referenceClass = loader.loadClass( m_referenceClassName );
-            if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
-                getLogger().log( LogService.LOG_DEBUG,
-                    "getParameterClass: Found class " + referenceClass.getName(), null );
+                logger.log( LogService.LOG_DEBUG,
+                    "getParameterClass: Found class {0}", new Object[] {referenceClass.getName()}, null );
             }
             return referenceClass;
         }
@@ -263,9 +264,9 @@ public class BindMethod extends BaseMethod
             // super class so we try this class next
         }
 
-        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log( LogService.LOG_DEBUG,
+            logger.log( LogService.LOG_DEBUG,
                 "getParameterClass: Not found through component class, using PackageAdmin service", null );
         }
 
@@ -282,19 +283,19 @@ public class BindMethod extends BaseMethod
                 {
                     try
                     {
-                        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+                        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
                         {
-                            getLogger().log(
+                            logger.log(
                                 LogService.LOG_DEBUG,
-                                "getParameterClass: Checking Bundle " + pkg[i].getExportingBundle().getSymbolicName()
-                                    + "/" + pkg[i].getExportingBundle().getBundleId(), null );
+                                "getParameterClass: Checking Bundle {0}/{1}",
+                                    new Object[] {pkg[i].getExportingBundle().getSymbolicName(), pkg[i].getExportingBundle().getBundleId()}, null );
                         }
 
                         Class referenceClass = pkg[i].getExportingBundle().loadClass( m_referenceClassName );
-                        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+                        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
                         {
-                            getLogger().log( LogService.LOG_DEBUG,
-                                "getParameterClass: Found class " + referenceClass.getName(), null );
+                            logger.log( LogService.LOG_DEBUG,
+                                    "getParameterClass: Found class {0}", new Object[] {referenceClass.getName()}, null );
                         }
                         return referenceClass;
                     }
@@ -304,23 +305,23 @@ public class BindMethod extends BaseMethod
                     }
                 }
             }
-            else if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            else if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
-                getLogger().log( LogService.LOG_DEBUG,
-                    "getParameterClass: No bundles exporting package " + referenceClassPackage + " found ", null );
+                logger.log( LogService.LOG_DEBUG,
+                    "getParameterClass: No bundles exporting package {0} found", new Object[] {referenceClassPackage}, null );
             }
         }
-        else if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        else if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log( LogService.LOG_DEBUG,
+            logger.log( LogService.LOG_DEBUG,
                 "getParameterClass: PackageAdmin service not available, cannot find class", null );
         }
 
         // class cannot be found, neither through the component nor from an
         // export, so we fall back to assuming Object
-        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log( LogService.LOG_DEBUG,
+            logger.log( LogService.LOG_DEBUG,
                 "getParameterClass: No class found, falling back to class Object", null );
         }
         return OBJECT_CLASS;
@@ -331,12 +332,14 @@ public class BindMethod extends BaseMethod
      * Returns a method taking a single <code>ServiceReference</code> object
      * as a parameter or <code>null</code> if no such method exists.
      *
+     *
      * @param targetClass The class in which to look for the method. Only this
      *      class is searched for the method.
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class.
      * @throws SuitableMethodNotAccessibleException If a suitable method was
@@ -344,11 +347,11 @@ public class BindMethod extends BaseMethod
      * @throws InvocationTargetException If an unexpected Throwable is caught
      *      trying to find the requested method.
      */
-    private Method getServiceReferenceMethod( final Class targetClass, boolean acceptPrivate, boolean acceptPackage )
+    private Method getServiceReferenceMethod( final Class targetClass, boolean acceptPrivate, boolean acceptPackage, SimpleLogger logger )
         throws SuitableMethodNotAccessibleException, InvocationTargetException
     {
         return getMethod( targetClass, getMethodName(), new Class[]
-            { SERVICE_REFERENCE_CLASS }, acceptPrivate, acceptPackage );
+            { SERVICE_REFERENCE_CLASS }, acceptPrivate, acceptPackage, logger );
     }
 
 
@@ -356,12 +359,14 @@ public class BindMethod extends BaseMethod
      * Returns a method taking a single parameter of the exact type declared
      * for the service reference or <code>null</code> if no such method exists.
      *
+     *
      * @param targetClass The class in which to look for the method. Only this
      *      class is searched for the method.
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class.
      * @throws SuitableMethodNotAccessibleException If a suitable method was
@@ -370,10 +375,10 @@ public class BindMethod extends BaseMethod
      *      trying to find the requested method.
      */
     private Method getServiceObjectMethod( final Class targetClass, final Class parameterClass, boolean acceptPrivate,
-        boolean acceptPackage ) throws SuitableMethodNotAccessibleException, InvocationTargetException
+            boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException, InvocationTargetException
     {
         return getMethod( targetClass, getMethodName(), new Class[]
-            { parameterClass }, acceptPrivate, acceptPackage );
+            { parameterClass }, acceptPrivate, acceptPackage, logger );
     }
 
 
@@ -382,27 +387,29 @@ public class BindMethod extends BaseMethod
      * compatible with the declared service type or <code>null</code> if no
      * such method exists.
      *
+     *
      * @param targetClass The class in which to look for the method. Only this
      *      class is searched for the method.
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class.
      * @throws SuitableMethodNotAccessibleException If a suitable method was
      *      found which is not accessible
      */
     private Method getServiceObjectAssignableMethod( final Class targetClass, final Class parameterClass,
-        boolean acceptPrivate, boolean acceptPackage ) throws SuitableMethodNotAccessibleException
+            boolean acceptPrivate, boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException
     {
         // Get all potential bind methods
         Method candidateBindMethods[] = targetClass.getDeclaredMethods();
         boolean suitableNotAccessible = false;
 
-        if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+        if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
         {
-            getLogger().log(
+            logger.log(
                 LogService.LOG_DEBUG,
                 "getServiceObjectAssignableMethod: Checking " + candidateBindMethods.length
                     + " declared method in class " + targetClass.getName(), null );
@@ -412,9 +419,9 @@ public class BindMethod extends BaseMethod
         for ( int i = 0; i < candidateBindMethods.length; i++ )
         {
             Method method = candidateBindMethods[i];
-            if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+            if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
             {
-                getLogger().log( LogService.LOG_DEBUG, "getServiceObjectAssignableMethod: Checking " + method, null );
+                logger.log( LogService.LOG_DEBUG, "getServiceObjectAssignableMethod: Checking " + method, null );
             }
 
             // Get the parameters for the current method
@@ -426,9 +433,9 @@ public class BindMethod extends BaseMethod
             if ( parameters.length == 1 && method.getName().equals( getMethodName() ) )
             {
 
-                if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+                if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
                 {
-                    getLogger().log( LogService.LOG_DEBUG, "getServiceObjectAssignableMethod: Considering " + method, null );
+                    logger.log( LogService.LOG_DEBUG, "getServiceObjectAssignableMethod: Considering " + method, null );
                 }
 
                 // Get the parameter type
@@ -447,9 +454,9 @@ public class BindMethod extends BaseMethod
                     // suitable method is not accessible, flag for exception
                     suitableNotAccessible = true;
                 }
-                else if ( getLogger().isLogEnabled( LogService.LOG_DEBUG ) )
+                else if ( logger.isLogEnabled( LogService.LOG_DEBUG ) )
                 {
-                    getLogger().log(
+                    logger.log(
                         LogService.LOG_DEBUG,
                         "getServiceObjectAssignableMethod: Parameter failure: Required " + theParameter + "; actual "
                             + parameterClass.getName(), null );
@@ -475,12 +482,14 @@ public class BindMethod extends BaseMethod
      * type declared for the service reference and the second being a
      * <code>Map</code> or <code>null</code> if no such method exists.
      *
+     *
      * @param targetClass The class in which to look for the method. Only this
      *      class is searched for the method.
      * @param acceptPrivate <code>true</code> if private methods should be
      *      considered.
      * @param acceptPackage <code>true</code> if package private methods should
      *      be considered.
+     * @param logger
      * @return The requested method or <code>null</code> if no acceptable method
      *      can be found in the target class.
      * @throws SuitableMethodNotAccessibleException If a suitable method was
@@ -489,11 +498,11 @@ public class BindMethod extends BaseMethod
      *      trying to find the requested method.
      */
     private Method getServiceObjectWithMapMethod( final Class targetClass, final Class parameterClass,
-        boolean acceptPrivate, boolean acceptPackage ) throws SuitableMethodNotAccessibleException,
+            boolean acceptPrivate, boolean acceptPackage, SimpleLogger logger ) throws SuitableMethodNotAccessibleException,
         InvocationTargetException
     {
         return getMethod( targetClass, getMethodName(), new Class[]
-            { parameterClass, MAP_CLASS }, acceptPrivate, acceptPackage );
+            { parameterClass, MAP_CLASS }, acceptPrivate, acceptPackage, logger );
     }
 
 
@@ -554,19 +563,19 @@ public class BindMethod extends BaseMethod
         return null;
     }
 
-    public boolean getServiceObject( RefPair refPair, BundleContext context )
+    public boolean getServiceObject( RefPair refPair, BundleContext context, SimpleLogger logger )
     {
         //??? this resolves which we need.... better way?
-        if ( refPair.getServiceObject() == null && methodExists() )
+        if ( refPair.getServiceObject() == null && methodExists( logger ) )
         {
             if (m_paramStyle == SERVICE_OBJECT || m_paramStyle == SERVICE_OBJECT_AND_MAP) {
                 Object service = context.getService( refPair.getRef() );
                 if ( service == null )
                 {
                     refPair.setFailed();
-                    getLogger().log(
+                    logger.log(
                          LogService.LOG_WARNING,
-                         "Could not get service from ref " + refPair.getRef(), null );
+                         "Could not get service from ref {0}", new Object[] {refPair.getRef()}, null );
                     return false;
                 }
                 refPair.setServiceObject( service );
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethods.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethods.java
index 8f547c0d19..30531de53e 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethods.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/BindMethods.java
@@ -32,26 +32,24 @@ public class BindMethods
     private final UpdatedMethod m_updated;
     private final UnbindMethod m_unbind;
 
-    BindMethods( SimpleLogger logger, ReferenceMetadata m_dependencyMetadata, Class instanceClass,
+    BindMethods( ReferenceMetadata m_dependencyMetadata, Class instanceClass,
             final boolean isDS11, final boolean isDS12Felix )
     {
-        m_bind = new BindMethod( logger,
+        m_bind = new BindMethod(
                 m_dependencyMetadata.getBind(),
                 instanceClass,
                 m_dependencyMetadata.getInterface(),
                 isDS11, isDS12Felix
         );
-        m_updated = new UpdatedMethod( logger,
+        m_updated = new UpdatedMethod(
                 m_dependencyMetadata.getUpdated(),
                 instanceClass,
-                m_dependencyMetadata.getName(),
                 m_dependencyMetadata.getInterface(),
                 isDS11, isDS12Felix
         );
-        m_unbind = new UnbindMethod( logger,
+        m_unbind = new UnbindMethod(
                 m_dependencyMetadata.getUnbind(),
                 instanceClass,
-                m_dependencyMetadata.getName(),
                 m_dependencyMetadata.getInterface(),
                 isDS11, isDS12Felix
         );
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/ComponentMethods.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/ComponentMethods.java
index 3759b7f5bb..8d94814f59 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/ComponentMethods.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/ComponentMethods.java
@@ -39,7 +39,7 @@ public class ComponentMethods
 
     private final Map bindMethodMap = new HashMap();//<String, BindMethods>
 
-    public synchronized void initComponentMethods(SimpleLogger logger, ComponentMetadata componentMetadata, Class implementationObjectClass)
+    public synchronized void initComponentMethods( ComponentMetadata componentMetadata, Class implementationObjectClass )
     {
         if (m_activateMethod != null)
         {
@@ -47,18 +47,18 @@ public class ComponentMethods
         }
         boolean isDS11 = componentMetadata.isDS11();
         boolean isDS12Felix = componentMetadata.isDS12Felix();
-        m_activateMethod = new ActivateMethod( logger, componentMetadata.getActivate(), componentMetadata
+        m_activateMethod = new ActivateMethod( componentMetadata.getActivate(), componentMetadata
                 .isActivateDeclared(), implementationObjectClass, isDS11, isDS12Felix );
-        m_deactivateMethod = new DeactivateMethod( logger, componentMetadata.getDeactivate(),
+        m_deactivateMethod = new DeactivateMethod( componentMetadata.getDeactivate(),
                 componentMetadata.isDeactivateDeclared(), implementationObjectClass, isDS11, isDS12Felix );
 
-        m_modifiedMethod = new ModifiedMethod( logger, componentMetadata.getModified(), implementationObjectClass, isDS11, isDS12Felix );
+        m_modifiedMethod = new ModifiedMethod( componentMetadata.getModified(), implementationObjectClass, isDS11, isDS12Felix );
 
         for ( Iterator it = componentMetadata.getDependencies().iterator(); it.hasNext(); )
         {
             ReferenceMetadata referenceMetadata = ( ReferenceMetadata ) it.next();
             String refName = referenceMetadata.getName();
-            BindMethods bindMethods = new BindMethods(logger, referenceMetadata, implementationObjectClass, isDS11, isDS12Felix);
+            BindMethods bindMethods = new BindMethods( referenceMetadata, implementationObjectClass, isDS11, isDS12Felix);
             bindMethodMap.put( refName, bindMethods );
         }
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/DeactivateMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/DeactivateMethod.java
index 152aa2feea..a74c4df948 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/DeactivateMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/DeactivateMethod.java
@@ -19,9 +19,6 @@
 package org.apache.felix.scr.impl.helper;
 
 
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
-
-
 public class DeactivateMethod extends ActivateMethod
 {
 
@@ -29,10 +26,10 @@ public class DeactivateMethod extends ActivateMethod
         { COMPONENT_CONTEXT_CLASS, BUNDLE_CONTEXT_CLASS, MAP_CLASS, Integer.TYPE, INTEGER_CLASS };
 
 
-    public DeactivateMethod( final SimpleLogger logger, final String methodName,
-        final boolean methodRequired, final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
+    public DeactivateMethod( final String methodName,
+            final boolean methodRequired, final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, methodRequired, componentClass, isDS11, isDS12Felix );
+        super( methodName, methodRequired, componentClass, isDS11, isDS12Felix );
     }
 
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/ModifiedMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/ModifiedMethod.java
index c660e56c49..68966c40ac 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/ModifiedMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/ModifiedMethod.java
@@ -19,16 +19,13 @@
 package org.apache.felix.scr.impl.helper;
 
 
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
-
-
 public class ModifiedMethod extends ActivateMethod
 {
 
-    public ModifiedMethod( final SimpleLogger logger, final String methodName,
-        final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
+    public ModifiedMethod( final String methodName,
+            final Class componentClass, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, methodName != null, componentClass, isDS11, isDS12Felix );
+        super( methodName, methodName != null, componentClass, isDS11, isDS12Felix );
     }
 
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/UnbindMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/UnbindMethod.java
index 3b9d677112..c5d4cffa76 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/UnbindMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/UnbindMethod.java
@@ -19,19 +19,16 @@
 package org.apache.felix.scr.impl.helper;
 
 
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
-
-
 /**
  * Component method to be invoked on service unbinding.
  */
 public class UnbindMethod extends BindMethod
 {
 
-    public UnbindMethod( final SimpleLogger logger, final String methodName,
-        final Class componentClass, final String referenceName, final String referenceClassName, final boolean isDS11, final boolean isDS12Felix )
+    public UnbindMethod( final String methodName,
+            final Class componentClass, final String referenceClassName, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, componentClass, referenceClassName, isDS11, isDS12Felix );
+        super( methodName, componentClass, referenceClassName, isDS11, isDS12Felix );
     }
 
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/UpdatedMethod.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/UpdatedMethod.java
index 8d3fe91e36..80f24b686f 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/UpdatedMethod.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/UpdatedMethod.java
@@ -19,19 +19,16 @@
 package org.apache.felix.scr.impl.helper;
 
 
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
-
-
 /**
  * Component method to be invoked on service property update of a bound service.
  */
 public class UpdatedMethod extends BindMethod
 {
 
-    public UpdatedMethod( final SimpleLogger logger, final String methodName,
-        final Class componentClass, final String referenceName, final String referenceClassName, final boolean isDS11, final boolean isDS12Felix )
+    public UpdatedMethod( final String methodName,
+            final Class componentClass, final String referenceClassName, final boolean isDS11, final boolean isDS12Felix )
     {
-        super( logger, methodName, componentClass, referenceClassName, isDS11, isDS12Felix );
+        super( methodName, componentClass, referenceClassName, isDS11, isDS12Felix );
     }
 
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 07ad20f6e5..fd4836463b 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -784,7 +784,7 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
             log( LogService.LOG_ERROR, "Could not load implementation object class", e );
             return false;
         }
-        m_componentMethods.initComponentMethods( this, m_componentMetadata, implementationObjectClass );
+        m_componentMethods.initComponentMethods( m_componentMetadata, implementationObjectClass );
 
         for ( DependencyManager dependencyManager : m_dependencyManagers )
         {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 3613d8a816..6bf977c68b 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -309,7 +309,7 @@ public class DependencyManager<S, T> implements Reference
             }
             if (isActive())
             {
-                 m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext());
+                 m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
             }
             return refPair;
         }
@@ -387,7 +387,7 @@ public class DependencyManager<S, T> implements Reference
             {
                 synchronized (refPair)
                 {
-                    if (m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext()))
+                    if (m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager ))
                     {
                          success = true;
                     }
@@ -433,7 +433,7 @@ public class DependencyManager<S, T> implements Reference
             RefPair<T> refPair = new RefPair<T>( serviceReference  );
             if (isActive())
             {
-                 m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext());
+                 m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
             }
             return refPair;
         }
@@ -497,7 +497,7 @@ public class DependencyManager<S, T> implements Reference
             {
                 synchronized (refPair)
                 {
-                    success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext());
+                    success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
                 }
             }
             return success;
@@ -584,7 +584,7 @@ public class DependencyManager<S, T> implements Reference
             {
                 synchronized (refPair)
                 {
-                    success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext());
+                    success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
                 }
                 refs.add(refPair) ;
             }
@@ -636,7 +636,7 @@ public class DependencyManager<S, T> implements Reference
                     {
                         synchronized ( refPair )
                         {
-                            m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() );
+                            m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
                         }
                         if ( !refPair.isFailed() )
                         {
@@ -691,7 +691,7 @@ public class DependencyManager<S, T> implements Reference
                         nextRefPair = tracked.values().iterator().next();
                         synchronized ( nextRefPair )
                         {
-                            if (!m_bindMethods.getBind().getServiceObject( nextRefPair, m_componentManager.getActivator().getBundleContext() ))
+                            if (!m_bindMethods.getBind().getServiceObject( nextRefPair, m_componentManager.getActivator().getBundleContext(), m_componentManager ))
                             {
                                 //TODO error???
                             }
@@ -745,7 +745,7 @@ public class DependencyManager<S, T> implements Reference
                     RefPair<T> refPair = tracked.values().iterator().next();
                     synchronized ( refPair )
                     {
-                        success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() );
+                        success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
                     }
                     if (refPair.isFailed())
                     {
@@ -861,7 +861,7 @@ public class DependencyManager<S, T> implements Reference
                     RefPair<T> refPair = tracked.values().iterator().next();
                     synchronized ( refPair )
                     {
-                        success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() );
+                        success |= m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
                     }
                     this.refPair = refPair;
                 }
@@ -1416,7 +1416,7 @@ public class DependencyManager<S, T> implements Reference
                 //something else got the reference and may be binding it.
                 return;
             }
-            m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() );
+            m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager );
         }
         m_componentManager.invokeBindMethod( this, refPair, trackingCount );
     }
@@ -1456,7 +1456,7 @@ public class DependencyManager<S, T> implements Reference
                     return true;
                 }
             }
-            MethodResult result = m_bindMethods.getBind().invoke( componentInstance, refPair, MethodResult.VOID );
+            MethodResult result = m_bindMethods.getBind().invoke( componentInstance, refPair, MethodResult.VOID, m_componentManager );
             if ( result == null )
             {
                 return false;
@@ -1515,7 +1515,7 @@ public class DependencyManager<S, T> implements Reference
                     return;
                 }
             }
-            if ( !m_bindMethods.getUpdated().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() ))
+            if ( !m_bindMethods.getUpdated().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager ))
             {
                 m_componentManager.log( LogService.LOG_WARNING,
                         "DependencyManager : invokeUpdatedMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
@@ -1523,7 +1523,7 @@ public class DependencyManager<S, T> implements Reference
                 return;
 
             }
-            MethodResult methodResult = m_bindMethods.getUpdated().invoke( componentInstance, refPair, MethodResult.VOID );
+            MethodResult methodResult = m_bindMethods.getUpdated().invoke( componentInstance, refPair, MethodResult.VOID, m_componentManager );
             if ( methodResult != null)
             {
                 m_componentManager.setServiceProperties( methodResult );
@@ -1587,7 +1587,7 @@ public class DependencyManager<S, T> implements Reference
                         "DependencyManager : invokeUnbindMethod : Component set, but reference not present", null );
                 return;
             }
-            if ( !m_bindMethods.getUnbind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() ))
+            if ( !m_bindMethods.getUnbind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext(), m_componentManager ))
             {
                 m_componentManager.log( LogService.LOG_WARNING,
                         "DependencyManager : invokeUnbindMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
@@ -1595,7 +1595,7 @@ public class DependencyManager<S, T> implements Reference
                 return;
 
             }
-            MethodResult methodResult = m_bindMethods.getUnbind().invoke( componentInstance, refPair, MethodResult.VOID );
+            MethodResult methodResult = m_bindMethods.getUnbind().invoke( componentInstance, refPair, MethodResult.VOID, m_componentManager );
             if ( methodResult != null )
             {
                 m_componentManager.setServiceProperties( methodResult );
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
index cbb67e3e81..f29fb00462 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
@@ -287,7 +287,7 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
 
         // 5. Call the activate method, if present
         final MethodResult result = getComponentMethods().getActivateMethod().invoke( implementationObject, new ActivatorParameter(
-                componentContext, 1 ), null );
+                componentContext, 1 ), null, this );
         if ( result == null )
         {
             // make sure the implementation object is not available
@@ -321,7 +321,7 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
         // method throws an exception, SCR must log an error message containing the
         // exception with the Log Service and continue) has already been logged
         final MethodResult result = getComponentMethods().getDeactivateMethod().invoke( implementationObject, new ActivatorParameter( componentContext,
-                reason ), null );
+                reason ), null, this );
         if ( result != null )
         {
             setServiceProperties( result );
@@ -649,7 +649,7 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
     protected MethodResult invokeModifiedMethod()
     {
         return getComponentMethods().getModifiedMethod().invoke( getInstance(),
-                    new ActivatorParameter( m_componentContext, -1 ), MethodResult.VOID );
+                    new ActivatorParameter( m_componentContext, -1 ), MethodResult.VOID, this );
     }
 
     protected boolean hasInstance()
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
index e4e609cf52..e97e010666 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
@@ -249,14 +249,14 @@ public class ServiceFactoryComponentManager<S> extends ImmediateComponentManager
         {
             Object instance = componentContext.getInstance();
             result = modifiedMethod.invoke( instance,
-                    new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID );
+                    new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID, this );
 
         }
         for ( BundleComponentContext componentContext : tmpImplementationObjects.values() )
         {
             Object instance = componentContext.getInstance();
             result = modifiedMethod.invoke( instance,
-                    new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID );
+                    new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID, this );
 
         }
         return result;
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/helper/ActivateMethodTest.java b/scr/src/test/java/org/apache/felix/scr/impl/helper/ActivateMethodTest.java
index 973e5c775f..2833eafbc0 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/helper/ActivateMethodTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/helper/ActivateMethodTest.java
@@ -271,8 +271,8 @@ public class ActivateMethodTest extends TestCase
             }
         };
         ImmediateComponentManager icm = new ImmediateComponentManager( null, null, metadata, new ComponentMethods() );
-        ActivateMethod am = new ActivateMethod( icm, methodName, methodName != null, obj.getClass(), true, false );
-        am.invoke( obj, new ActivateMethod.ActivatorParameter( m_ctx, -1 ), null );
+        ActivateMethod am = new ActivateMethod( methodName, methodName != null, obj.getClass(), true, false );
+        am.invoke( obj, new ActivateMethod.ActivatorParameter( m_ctx, -1 ), null, icm );
         Method m = get(am, "m_method");
         assertNotNull( m );
         assertEquals( methodName, m.getName() );
@@ -299,8 +299,8 @@ public class ActivateMethodTest extends TestCase
             }
         };
         ImmediateComponentManager icm = new ImmediateComponentManager( null, null, metadata, new ComponentMethods() );
-        ActivateMethod am = new ActivateMethod( icm, methodName, methodName != null, obj.getClass(), true, false );
-        am.invoke( obj, new ActivateMethod.ActivatorParameter( m_ctx, -1 ), null );
+        ActivateMethod am = new ActivateMethod( methodName, methodName != null, obj.getClass(), true, false );
+        am.invoke( obj, new ActivateMethod.ActivatorParameter( m_ctx, -1 ), null, icm );
         assertNull( get( am, "m_method" ) );
         assertNull( obj.getCalledMethod() );
     }
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/helper/BindMethodTest.java b/scr/src/test/java/org/apache/felix/scr/impl/helper/BindMethodTest.java
index e18479085f..f3989bb2ed 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/helper/BindMethodTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/helper/BindMethodTest.java
@@ -21,7 +21,6 @@ package org.apache.felix.scr.impl.helper;
 
 import junit.framework.TestCase;
 
-import org.apache.felix.scr.impl.manager.AbstractComponentManager;
 import org.apache.felix.scr.impl.manager.ImmediateComponentManager;
 import org.apache.felix.scr.impl.manager.RefPair;
 import org.apache.felix.scr.impl.manager.components.FakeService;
@@ -434,11 +433,11 @@ public class BindMethodTest extends TestCase
             }
         };
         ImmediateComponentManager icm = new ImmediateComponentManager( null, null, metadata, new ComponentMethods() );
-        BindMethod bm = new BindMethod( icm, methodName, component.getClass(),
+        BindMethod bm = new BindMethod( methodName, component.getClass(),
                 FakeService.class.getName(), isDS11, false );
         RefPair refPair = new RefPair( m_serviceReference );
-        assertTrue( bm.getServiceObject( refPair, m_context ) );
-        bm.invoke( component, refPair, null );
+        assertTrue( bm.getServiceObject( refPair, m_context, icm ) );
+        bm.invoke( component, refPair, null, icm );
         assertEquals( expectCallPerformed, component.callPerformed );
     }
 }
