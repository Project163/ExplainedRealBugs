diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java
index 74801ed5ec..0983443b94 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java
@@ -19,6 +19,8 @@ package org.apache.felix.serializer.impl.json;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -31,21 +33,23 @@ import org.osgi.util.converter.Converter;
 
 public class DebugJsonWriter implements Writer {
 
-    private final Converter converter;
+    private Converter converter;
+    private final Map<String, List<String>> orderingRules;
     private final boolean ignoreNull = false;
     private final int indentation = 2;
 
-    public DebugJsonWriter(Converter c) {
+    public DebugJsonWriter(Converter c, Map<String,List<String>> rules) {
         converter = c;
+        orderingRules = rules;
     }
 
     @Override
     public String write(Object obj) {
-        return encode(obj, 0).trim();
+        return encode(obj, "/", 0).trim();
     }
 
     @SuppressWarnings("rawtypes")
-    private String encode(Object obj, int level) {
+    private String encode(Object obj, String path, int level) {
         if (obj == null) {
             return ignoreNull ? "" : "null";
         }
@@ -53,13 +57,14 @@ public class DebugJsonWriter implements Writer {
         if (obj instanceof String) {
             return "\"" + (String)obj + "\"";
         } else if (obj instanceof Map) {
-            return encodeMap((Map) obj, level);
+            return encodeMap(orderMap((Map)obj, path), path, level);
         } else if (obj instanceof Collection) {
-            return encodeCollection((Collection) obj, level);
+            return encodeCollection((Collection) obj, path, level);
         } else if (obj instanceof DTO) {
-            return encodeMap(converter.convert(obj).sourceAsDTO().to(Map.class), level);
+            Map converted = converter.convert(obj).sourceAsDTO().to(Map.class);
+            return encodeMap(orderMap(converted, path), path, level);
         } else if (obj.getClass().isArray()) {
-            return encodeCollection(asCollection(obj), level);
+            return encodeCollection(asCollection(obj), path, level);
         } else if (obj instanceof Number) {
             return obj.toString();
         } else if (obj instanceof Boolean) {
@@ -69,6 +74,40 @@ public class DebugJsonWriter implements Writer {
         return "\"" + converter.convert(obj).to(String.class) + "\"";
     }
 
+    @SuppressWarnings( { "unchecked", "rawtypes" } )
+    private Map orderMap(Map unordered, String path) {
+        Map ordered = (orderingRules.containsKey(path)) ? new LinkedHashMap<>() : new TreeMap<>();
+        List<String> keys = (orderingRules.containsKey(path)) ? orderingRules.get(path) : new ArrayList<>(unordered.keySet());
+        for (String key : keys) {
+            String itemPath = (path.endsWith("/")) ? path + key : path + "/" + key;
+            Object value = unordered.get(key);
+            if (value instanceof Map)
+                ordered.put(key, orderMap((Map)value, itemPath));
+            else if(value instanceof Collection)
+                ordered.put(key, orderCollectionItems((Collection)value, itemPath));
+            else
+                ordered.put(key, value);
+        }
+
+        return ordered;
+    }
+
+    @SuppressWarnings( { "unchecked", "rawtypes" } )
+    private List orderCollectionItems(Collection unordered, String path) {
+        List ordered = new ArrayList<>();
+        for (Object obj: unordered) {
+            if (obj instanceof Map)
+                ordered.add(orderMap((Map)obj, path));
+            else if(obj instanceof Collection)
+                ordered.add(orderCollectionItems((Collection)obj, path));
+            else
+                ordered.add(obj);
+        }
+
+        try{Collections.sort(ordered);}catch (Exception e){}
+        return ordered;
+    }
+
     private Collection<?> asCollection(Object arr) {
         // Arrays.asList() doesn't work for primitive arrays
         int len = Array.getLength(arr);
@@ -79,7 +118,7 @@ public class DebugJsonWriter implements Writer {
         return l;
     }
 
-    private String encodeCollection(Collection<?> collection, int level) {
+    private String encodeCollection(Collection<?> collection, String path, int level) {
         level++;
         StringBuilder sb = new StringBuilder("[\n");
 
@@ -90,8 +129,8 @@ public class DebugJsonWriter implements Writer {
             else
                 sb.append(",\n");
 
-            sb.append( getIdentPrefix(level));
-            sb.append(encode(o, level));
+            sb.append(getIdentPrefix(level));
+            sb.append(encode(o, path, level));
         }
 
         sb.append("\n");
@@ -101,22 +140,23 @@ public class DebugJsonWriter implements Writer {
     }
 
     @SuppressWarnings({ "rawtypes", "unchecked" })
-    private String encodeMap(Map m, int level) {
+    private String encodeMap(Map m, String path, int level) {
         level++;
-        Map orderedMap = new TreeMap<>(m);
+//        Map orderedMap = (orderingRules.isEmpty()) ? new TreeMap<>(m) : m;
         StringBuilder sb = new StringBuilder("{\n");
-        for (Entry entry : (Set<Entry>) orderedMap.entrySet()) {
+        for (Entry entry : (Set<Entry>) m.entrySet()) {
             if (entry.getKey() == null || entry.getValue() == null)
                 if (ignoreNull)
                     continue;
 
+            String itemPath = (path.endsWith("/")) ? path + entry.getKey() : path + "/" + entry.getKey();
             if (sb.length() > 2)
                 sb.append(",\n");
             sb.append(getIdentPrefix(level));
             sb.append('"');
             sb.append(entry.getKey().toString());
             sb.append("\":");
-            sb.append(encode(entry.getValue(), level));
+            sb.append(encode(entry.getValue(), itemPath, level));
         }
         sb.append("\n");
         sb.append(getIdentPrefix(--level));
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java
index 3b9e9f8366..f5d9854f24 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java
@@ -49,11 +49,6 @@ public class DefaultJsonWriter implements Writer {
         }
 
         if (obj instanceof String) {
-            // Optimization for when the value is already a String
-            // David B.: is this ok? Or does the Converter do something else
-            //           other than just returning a String??
-            //           I noticed that a lot of calculations were going on, just
-            //           to return a String anyway.
             return "\"" + (String)obj + "\"";
         } else if (obj instanceof Map) {
             return encodeMap((Map) obj);
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java
index 7e9ecb72a0..4f875c893f 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java
@@ -16,11 +16,22 @@
  */
 package org.apache.felix.serializer.impl.json;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 import org.osgi.service.serializer.Writer;
 import org.osgi.service.serializer.WriterFactory;
 import org.osgi.util.converter.Converter;
 
-public class JsonWriterFactory implements WriterFactory {
+public class JsonWriterFactory implements WriterFactory, WriterFactory.JsonWriterFactory {
+    private final Map<String, List<String>> orderingRules = new HashMap<>();
+
+    @Override
+    public JsonWriterFactory orderBy(String path, List<String> keyOrder) {
+        orderingRules.put(path, keyOrder);
+        return this;
+    }
 
     @Override
     public Writer newDefaultWriter(Converter c) {
@@ -29,6 +40,6 @@ public class JsonWriterFactory implements WriterFactory {
 
     @Override
     public Writer newDebugWriter(Converter c) {
-        return new DebugJsonWriter(c);
+        return new DebugJsonWriter(c, orderingRules);
     }
 }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java
index 7531e9b26b..7b404da916 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java
@@ -16,11 +16,22 @@
  */
 package org.apache.felix.serializer.impl.yaml;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 import org.osgi.service.serializer.Writer;
 import org.osgi.service.serializer.WriterFactory;
 import org.osgi.util.converter.Converter;
 
-public class YamlWriterFactory implements WriterFactory {
+public class YamlWriterFactory implements WriterFactory, WriterFactory.YamlWriterFactory {
+    private final Map<String, List<String>> orderingRules = new HashMap<>();
+
+    @Override
+    public YamlWriterFactory orderBy(String path, List<String> keyOrder) {
+        orderingRules.put(path,keyOrder);
+        return this;
+    }
 
     @Override
     public Writer newDefaultWriter(Converter c) {
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java b/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java
index d46b50aefd..b7bd224c87 100644
--- a/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java
@@ -15,6 +15,8 @@
  */
 package org.osgi.service.serializer;
 
+import java.util.List;
+
 import org.osgi.annotation.versioning.ProviderType;
 import org.osgi.util.converter.Converter;
 
@@ -43,6 +45,22 @@ public interface WriterFactory {
      */
     Writer newDebugWriter(Converter c);
 
+    /**
+     * Register an ordering rule for this writer.
+     * 
+     * An ordering rule causes the written json to be output in the order
+     * specified. This can be useful, for example, for debugging or when
+     * the data otherwise needs to be human consumable.
+     * 
+     * Note that only the target type is specified, so the rule will be visited 
+     * for every conversion to the target type.
+     *
+     * @param path the path where the key is located in the object graph.
+     * @param func The desired key order.
+     * @return This factory object to allow further invocations on it.
+     */
+    WriterFactory orderBy(String path, List<String> keyOrder);
+
     /**
      * A convenience means of obtaining a JsonWriterFactory without having to
      * configure service settings.
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
index a215fd00fd..f78670ae14 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
@@ -17,6 +17,7 @@
 package org.apache.felix.serializer.impl.json;
 
 import java.lang.reflect.Type;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
@@ -74,6 +75,19 @@ public class JsonBackingObjectSerializationTest {
         assertEquals(EXPECTED, actual);
     }
 
+    @Test
+    public void testOrderedSerialization() {
+        final JsonWriterFactory factory = new JsonWriterFactory();
+        factory.orderBy("/", Arrays.asList("b", "a", "o", "l2", "l1"));
+        factory.orderBy("/l2", Arrays.asList("b", "a"));
+        final String actual = new JsonSerializerImpl()
+                .serialize(MyDTOishObject.factory("A", "B"))
+                .writeWith(factory.newDebugWriter(Converters.standardConverter()))
+                .toString();
+
+        assertEquals(ORDERED, actual);
+    }
+
     public static class MyDTOishObject extends DTO {
         public String a;
         public String b;
@@ -138,10 +152,10 @@ public class JsonBackingObjectSerializationTest {
             "  \"a\":\"A\",\n" +
             "  \"b\":\"B\",\n" +
             "  \"l1\":[\n" +
+            "    \"four\",\n" +
             "    \"one\",\n" +
-            "    \"two\",\n" +
             "    \"three\",\n" +
-            "    \"four\"\n" +
+            "    \"two\"\n" +
             "  ],\n" +
             "  \"l2\":[\n" +
             "    {\n" +
@@ -158,4 +172,30 @@ public class JsonBackingObjectSerializationTest {
             "    \"b\":\"BB\"\n" +
             "  }\n" +
             "}";
+
+    private static final String ORDERED =
+            "{\n" +
+            "  \"b\":\"B\",\n" +
+            "  \"a\":\"A\",\n" +
+            "  \"o\":{\n" +
+            "    \"a\":\"AA\",\n" +
+            "    \"b\":\"BB\"\n" +
+            "  },\n" +
+            "  \"l2\":[\n" +
+            "    {\n" +
+            "      \"b\":\"B\",\n" +
+            "      \"a\":\"A\"\n" +
+            "    },\n" +
+            "    {\n" +
+            "      \"b\":\"BB\",\n" +
+            "      \"a\":\"AA\"\n" +
+            "    }\n" +
+            "  ],\n" +
+            "  \"l1\":[\n" +
+            "    \"four\",\n" +
+            "    \"one\",\n" +
+            "    \"three\",\n" +
+            "    \"two\"\n" +
+            "  ]\n" +
+            "}";
 }
