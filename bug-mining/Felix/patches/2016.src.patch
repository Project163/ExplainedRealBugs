diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index d95b7214df..5140c030f6 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -823,34 +823,32 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
     final void disposeInternal( int reason )
     {
         log( LogService.LOG_DEBUG, "Disposing component (reason: " + reason + ")", null );
-        if ( m_activated )
-        {
-            doDeactivate( reason, true );
-        }
+        doDeactivate( reason, true );
         clear();
     }
          
-    void doDeactivate( int reason, boolean disable )
+    final void doDeactivate( int reason, boolean disable )
     {
         try
         {
             if ( !unregisterService() )
             {
                 log( LogService.LOG_DEBUG, "Component deactivation occuring on another thread", null );
-                //another thread is deactivating.
-                return;
             }
             obtainWriteLock( "AbstractComponentManager.State.doDeactivate.1" );
             try
             {
-                m_activated = false;
-                deleteComponent( reason );
-                deactivateDependencyManagers();
-                if ( disable )
+                if ( m_activated )
                 {
-                    disableDependencyManagers();
+                    m_activated = false;
+                    deleteComponent( reason );
+                    deactivateDependencyManagers();
+                    if ( disable )
+                    {
+                        disableDependencyManagers();
+                    }
+                    unsetDependenciesCollected();
                 }
-                unsetDependenciesCollected();
             }
             finally
             {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
index 54f05b2fe1..3f31f3b5e3 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
@@ -81,6 +81,7 @@ public class ConfigurationComponentFactoryImpl<S> extends ComponentFactoryImpl<S
             ((AbstractComponentManager)i.next()).enable( false );
         }
 
+        m_activated = true;
         return true;
     }
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
index fc872dd435..4f09836e34 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
@@ -572,6 +572,17 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
             m_properties = null;
 
             
+            // reactivate the component to ensure it is provided with the
+            // configuration data
+            if ( ( getState() & ( STATE_DISPOSED | STATE_DISABLED ) ) != 0 )
+            {
+                // nothing to do for inactive components, leave this method
+                log( LogService.LOG_DEBUG, "Component can not be configured in state {0}", new Object[] { getState() }, null );
+                //m_internalEnabled is false, we don't need to worry about activation
+                updateTargets( getProperties() );
+                return;
+            }
+
             //TODO wait for activation/deactivation to complete, then lock(?) or internal disable...
             
             // unsatisfied component and non-ignored configuration may change targets
@@ -594,17 +605,6 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
                 return;
             }
 
-            // reactivate the component to ensure it is provided with the
-            // configuration data
-            if ( ( getState() & ( STATE_DISPOSED | STATE_DISABLED ) ) != 0 )
-            {
-                // nothing to do for inactive components, leave this method
-                log( LogService.LOG_DEBUG, "Component can not be configured in state {0}", new Object[] { getState() }, null );
-                //m_internalEnabled is false, we don't need to worry about activation
-                updateTargets( getProperties() );
-                return;
-            }
-
             // if the configuration has been deleted but configuration is required
             // this component must be deactivated
             if ( configuration == null && getComponentMetadata().isConfigurationRequired() )
