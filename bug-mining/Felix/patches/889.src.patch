diff --git a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
index eeac47880b..5b4f3c1a71 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
@@ -367,23 +367,30 @@ public class ComponentRegistry implements ScrService
      * been sent.  Hence DS must consider a bundle active when it is really
      * active and when it is a lazily activated bundle in the STARTING state.
      *
-     * @throws NullPointerException if bundle is <code>null</code>.
+     * @param bundle The bundle check
+     * @return <code>true</code> if <code>bundle</code> is not <code>null</code>
+     *          and the bundle is either active or has lazy activation policy
+     *          and is in the starting state.
+     *
      * @see <a href="https://issues.apache.org/jira/browse/FELIX-1666">FELIX-1666</a>
      */
     static boolean isBundleActive( final Bundle bundle )
     {
-        if ( bundle.getState() == Bundle.ACTIVE )
+        if ( bundle != null )
         {
-            return true;
-        }
+            if ( bundle.getState() == Bundle.ACTIVE )
+            {
+                return true;
+            }
 
-        if ( bundle.getState() == Bundle.STARTING )
-        {
-            // according to the spec the activationPolicy header is only
-            // set to request a bundle to be lazily activated. So in this
-            // simple check we just verify the header is set to assume
-            // the bundle is considered a lazily activated bundle
-            return bundle.getHeaders().get( Constants.BUNDLE_ACTIVATIONPOLICY ) != null;
+            if ( bundle.getState() == Bundle.STARTING )
+            {
+                // according to the spec the activationPolicy header is only
+                // set to request a bundle to be lazily activated. So in this
+                // simple check we just verify the header is set to assume
+                // the bundle is considered a lazily activated bundle
+                return bundle.getHeaders().get( Constants.BUNDLE_ACTIVATIONPOLICY ) != null;
+            }
         }
 
         // fall back: bundle is not considered active
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 60bffec0ef..bab62cf017 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -35,6 +35,7 @@ import org.apache.felix.scr.impl.metadata.ComponentMetadata;
 import org.apache.felix.scr.impl.metadata.ReferenceMetadata;
 import org.apache.felix.scr.impl.metadata.ServiceMetadata;
 import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
 import org.osgi.framework.InvalidSyntaxException;
 import org.osgi.framework.ServicePermission;
 import org.osgi.framework.ServiceReference;
@@ -196,11 +197,35 @@ public abstract class AbstractComponentManager implements Component
         return m_componentMetadata.getName();
     }
 
+    /**
+     * Returns the <code>Bundle</code> providing this component. If the
+     * component as already been disposed off, this method returns
+     * <code>null</code>.
+     */
     public Bundle getBundle()
     {
-        return getActivator().getBundleContext().getBundle();
+        final BundleComponentActivator activator = getActivator();
+        if ( activator != null )
+        {
+            final BundleContext context = activator.getBundleContext();
+            if ( context != null )
+            {
+                try
+                {
+                    return context.getBundle();
+                }
+                catch ( IllegalStateException ise )
+                {
+                    // if the bundle context is not valid any more
+                }
+            }
+        }
+
+        // already disposed off component or bundle context is invalid
+        return null;
     }
 
+
     public String getClassName()
     {
         return m_componentMetadata.getImplementationClassName();
