diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 56562a5d8f..6e5a4ac013 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -53,6 +53,7 @@ import org.osgi.framework.ServicePermission;
 import org.osgi.framework.ServiceReference;
 import org.osgi.framework.ServiceRegistration;
 import org.osgi.service.component.ComponentConstants;
+import org.osgi.service.component.runtime.dto.ComponentConfigurationDTO;
 import org.osgi.service.log.LogService;
 import org.osgi.util.promise.Deferred;
 import org.osgi.util.promise.Promise;
@@ -73,6 +74,56 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         "Configuration deleted",
         "Component disabled",
         "Bundle stopped"};
+    
+    protected enum State {
+        //disposed is a final state, normally only for factory components
+        disposed(-1, false, false, false), 
+        //Since enable/disable on the component description are asynchronous, this tracks the component configuration state
+        //which may differ while the enable/disable is occurring.
+        disabled(-1, false, false, false), 
+        unsatisfiedReference(ComponentConfigurationDTO.UNSATISFIED_REFERENCE, true, false, false), 
+        satisfied(ComponentConfigurationDTO.SATISFIED, true, true, false), 
+        active(ComponentConfigurationDTO.ACTIVE, true, true, true);
+    
+        private final int specState;
+        
+        private final boolean enabled;
+
+        private final boolean satisfed;
+        
+        private final boolean actve;
+
+        private State(int specState, boolean enabled, boolean satisfied, boolean active)
+        {
+            this.specState = specState;
+            this.enabled = enabled;
+            this.satisfed = satisfied;
+            this.actve = active;
+        }
+
+        public int getSpecState()
+        {
+            return specState;
+        }
+
+        public boolean isEnabled()
+        {
+            return enabled;
+        }
+
+        public boolean isSatisfied()
+        {
+            return satisfed;
+        }
+
+        public boolean isActive()
+        {
+            return actve;
+        }
+        
+        
+                
+    }
 
     protected final ComponentContainer<S> m_container;
 
@@ -100,11 +151,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      */
     private final AtomicReference< Deferred<Void>> m_enabledLatchRef = new AtomicReference<Deferred<Void>>( new Deferred<Void>() );
 
-    protected volatile boolean m_internalEnabled;
-
-	private volatile boolean m_satisfied;
-
-    protected volatile boolean m_disposed;
+    private final AtomicReference<State> state = new AtomicReference<State>(State.disabled);
 
     //service event tracking
     private int m_floor;
@@ -115,7 +162,6 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     private final Condition m_missingCondition = m_missingLock.newCondition();
     private final Set<Integer> m_missing = new TreeSet<Integer>( );
 
-    volatile boolean m_activated;
 
     protected final ReentrantReadWriteLock m_activationLock = new ReentrantReadWriteLock();
 
@@ -387,10 +433,9 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         try
         {
             enableLatch = enableLatchWait();
-            enableInternal();
             if ( !async )
             {
-                activateInternal( );
+                enableInternal();
             }
         }
         finally
@@ -413,7 +458,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                 {
                     try
                     {
-                        activateInternal( );
+                        enableInternal();
                     }
                     finally
                     {
@@ -481,9 +526,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             enableLatch = enableLatchWait();
             if ( !async )
             {
-                deactivateInternal( ComponentConstants.DEACTIVATION_REASON_DISABLED, true, false );
+                disableInternal();
             }
-            disableInternal();
         }
         finally
         {
@@ -505,7 +549,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                 {
                     try
                     {
-                        deactivateInternal( ComponentConstants.DEACTIVATION_REASON_DISABLED, true, false );
+                        disableInternal();
                     }
                     finally
                     {
@@ -609,17 +653,13 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return false;
     }
 
-    protected boolean isSatisfied()
-    {
-        return m_satisfied;
-    }
-
 
     //-------------- atomic transition methods -------------------------------
 
     final void enableInternal()
     {
-        if ( m_disposed )
+        State previousState;
+        if ( (previousState = getState()) == State.disposed )
         {
             throw new IllegalStateException( "enable: " + this );
         }
@@ -629,31 +669,39 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                     null );
             return;
         }
+        if (previousState.isEnabled())
+        {
+            log( LogService.LOG_WARNING, "enable  called but component is already in state {0}", new Object[] {previousState},
+                    null );
+            return;
+        }
 
         registerComponentId();
         log( LogService.LOG_DEBUG, "Updating target filters", null );
         updateTargets( getProperties() );
 
-        m_internalEnabled = true;
+        setState(previousState, State.unsatisfiedReference);
         log( LogService.LOG_DEBUG, "Component enabled", null );
+        activateInternal( );
     }
 
     final void activateInternal( )
     {
         log( LogService.LOG_DEBUG, "ActivateInternal",
                 null );
-        if ( m_disposed )
+        State s = getState();
+        if ( s == State.disposed )
         {
             log( LogService.LOG_DEBUG, "ActivateInternal: disposed",
                     null );
             return;
         }
-        if ( m_activated ) {
+        if ( s == State.active ) {
             log( LogService.LOG_DEBUG, "ActivateInternal: already activated",
                     null );
             return;
         }
-        if ( !isInternalEnabled())
+        if ( !s.isEnabled())
         {
             log( LogService.LOG_DEBUG, "Component is not enabled; not activating component",
                     null );
@@ -681,18 +729,19 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         try
         {
             // Double check conditions now that we have obtained the lock
-            if ( m_disposed )
+            s = getState();
+            if ( s == State.disposed )
             {
                 log( LogService.LOG_DEBUG, "ActivateInternal: disposed",
                         null );
                 return;
             }
-            if ( m_activated ) {
+            if ( s == State.active ) {
                 log( LogService.LOG_DEBUG, "ActivateInternal: already activated",
                         null );
                 return;
             }
-            if ( !isInternalEnabled() )
+            if ( !s.isEnabled() )
             {
                 log( LogService.LOG_DEBUG, "Component is not enabled; not activating component",
                         null );
@@ -733,13 +782,18 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      */
     final void deactivateInternal( int reason, boolean disable, boolean dispose )
     {
-        synchronized ( this )
+        if ( !getState().isEnabled() )
         {
-            if ( m_disposed )
-            {
-                return;
-            }
-            m_disposed = dispose;
+            return;
+        }
+        State nextState = State.unsatisfiedReference;
+        if (disable) 
+        {
+            nextState = State.disabled;
+        }
+        if (dispose)
+        {
+            nextState = State.disposed;
         }
         log( LogService.LOG_DEBUG, "Deactivating component", null );
 
@@ -748,7 +802,9 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         obtainActivationReadLock(  );
         try
         {
+            //doDeactivate may trigger a state change from active to satisfied as the registration is removed.
             doDeactivate( reason, disable || m_factoryInstance );
+            setState(getState(), nextState);
         }
         finally
         {
@@ -769,11 +825,10 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             {
                 log( LogService.LOG_DEBUG, "Component deactivation occuring on another thread", null );
             }
-            obtainStateLock(  );
+            obtainStateLock( );
             try
             {
-            	m_satisfied = false;
-                m_activated = false;
+//              setState(previousState, State.unsatisfiedReference);
                 deleteComponent( reason );
                 deactivateDependencyManagers();
                 if ( disable )
@@ -794,11 +849,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     final void disableInternal()
     {
-        m_internalEnabled = false;
-        if ( m_disposed )
-        {
-            throw new IllegalStateException( "Cannot disable a disposed component " + getName() );
-        }
+        deactivateInternal( ComponentConstants.DEACTIVATION_REASON_DISABLED, true, false );
         unregisterComponentId();
     }
 
@@ -850,15 +901,15 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             }
             final Dictionary<String, Object> serviceProperties = getServiceProperties();
             try {
-				ServiceRegistration<S> serviceRegistration = (ServiceRegistration<S>) bundleContext
-						.registerService(services, getService(),
-								serviceProperties);
-				return serviceRegistration;
-			} catch (ServiceException e) {
-				log(LogService.LOG_ERROR, "Unexpected error registering component service with properties {0}",
-						new Object[] {serviceProperties}, e);
-				return null;
-			}
+                ServiceRegistration<S> serviceRegistration = (ServiceRegistration<S>) bundleContext
+                        .registerService(services, getService(),
+                                serviceProperties);
+                return serviceRegistration;
+            } catch (ServiceException e) {
+                log(LogService.LOG_ERROR, "Unexpected error registering component service with properties {0}",
+                        new Object[] {serviceProperties}, e);
+                return null;
+            }
         }
 
         @Override
@@ -1117,6 +1168,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     protected boolean verifyDependencyManagers()
     {
+        State previousState = getState();
         // indicates whether all dependencies are satisfied
         boolean satisfied = true;
 
@@ -1149,7 +1201,12 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             }
         }
 
-        m_satisfied = satisfied;
+        //Only try to change the state if the satisfied attribute is different.
+        //We only succeed if no one else has changed the state meanwhile.
+        if (satisfied != previousState.isSatisfied())
+        {
+            setState(previousState, satisfied ? State.satisfied : State.unsatisfiedReference);
+        }
         return satisfied;
     }
 
@@ -1164,7 +1221,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     public List<? extends ReferenceManager<S, ?>> getReferenceManagers()
     {
-    	return m_dependencyManagers;
+        return m_dependencyManagers;
     }
 
     /**
@@ -1213,8 +1270,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     }
 
     /* (non-Javadoc)
-	 * @see org.apache.felix.scr.impl.manager.ComponentManager#getProperties()
-	 */
+     * @see org.apache.felix.scr.impl.manager.ComponentManager#getProperties()
+     */
     public abstract Map<String, Object> getProperties();
 
     public abstract void setServiceProperties( Dictionary<String, ?> serviceProperties );
@@ -1336,30 +1393,31 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return m_container.getComponentMetadata();
     }
 
-    /**
-     * TODO now returning bizarre mix of values!!
-     */
-    public int getState()
+    public int getSpecState()
     {
-        if (m_disposed)
-        {
-            return STATE_DISPOSED;
-        }
-        if ( !m_internalEnabled)
-        {
-            return STATE_DISABLED;
-        }
-        if ( !m_satisfied )
+        return getState().getSpecState();
+    }
+    
+    State getState()
+    {
+        State s = state.get();
+        log( LogService.LOG_DEBUG, "Querying state {0}", new Object[] {s}, null);
+        return s;
+    }
+    
+    void setState(State previousState, State newState)
+    {
+        if (state.compareAndSet(previousState, newState))
         {
-            return STATE_UNSATISFIED_REFERENCE;
+            log( LogService.LOG_DEBUG, "Changed state from {0} to {1}", new Object[] {previousState, newState}, null);
         }
-        if ( hasInstance() )
+        else
         {
-            return STATE_ACTIVE;
+            log( LogService.LOG_DEBUG, "Did not change state from {0} to {1}: current state {2}", new Object[] {previousState, newState, state.get()}, null);
         }
-        return STATE_SATISFIED;
-    }
 
+    }
+    
     abstract boolean hasInstance();
 
     public void setServiceProperties( MethodResult methodResult )
@@ -1375,13 +1433,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     abstract void preDeregister();
 
-    boolean isInternalEnabled()
-    {
-        return m_internalEnabled;
-    }
-
-	public abstract void reconfigure(Map<String, Object> configuration, boolean configurationDeleted);
+    public abstract void reconfigure(Map<String, Object> configuration, boolean configurationDeleted);
 
-	public abstract void getComponentManagers(List<AbstractComponentManager<S>> cms);
+    public abstract void getComponentManagers(List<AbstractComponentManager<S>> cms);
 
 }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
index 29ca62bdad..155e77424b 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
@@ -126,8 +126,6 @@ public class ComponentFactoryImpl<S> extends AbstractComponentManager<S> impleme
         cm.reconfigure( m_configuration, false );
         // enable
         cm.enableInternal();
-        //activate immediately
-        cm.activateInternal( );
 
         ComponentInstance instance;
         if ( getComponentMetadata().isPersistentFactoryComponent() ) 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentManager.java
index 7c0d3b8d1c..f60901306e 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentManager.java
@@ -37,7 +37,7 @@ public interface ComponentManager<S> {
 
 	long getId();
 
-	int getState();
+	int getSpecState();
 	
 	List<? extends ReferenceManager<S, ?>> getReferenceManagers();
 	
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurableComponentHolder.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurableComponentHolder.java
index c7b982a465..f42e043ad9 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurableComponentHolder.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurableComponentHolder.java
@@ -28,6 +28,7 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.felix.scr.impl.helper.ComponentMethods;
 import org.apache.felix.scr.impl.helper.SimpleLogger;
@@ -70,7 +71,7 @@ public abstract class ConfigurableComponentHolder<S> implements ComponentHolder<
      * The {@link ComponentMetadata} describing the held component(s)
      */
     private final ComponentMetadata m_componentMetadata;
-
+    
     /** the targeted pids corresponding to the pids specified in the config metadata, except possibly for the single
      * factory pid
      */
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 8ff0896857..9e133a16b0 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -267,7 +267,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             refPair.markDeleted();
             if ( !cardinalitySatisfied( getTracker().getServiceCount() ) )
             {
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
             }
         }
 
@@ -368,7 +368,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 lastRefPair = refPair;
                 lastRefPairTrackingCount = trackingCount;
                 tracked( trackingCount );
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 lastRefPair = null;
                 m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed (deactivate) {2}", new Object[] {getName(), trackingCount, serviceReference}, null );
             }
@@ -451,7 +451,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 m_componentManager.log( LogService.LOG_DEBUG,
                         "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
                         {getName(), m_dependencyMetadata.getInterface()}, null );
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 //event may be null during initial operations.
                 if (event != null)
                 {
@@ -477,7 +477,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             tracked( trackingCount );
             if ( reactivate )
             {
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 if (event != null)
                 {
                     event.addComponentManager(m_componentManager);
@@ -497,7 +497,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 m_componentManager.log( LogService.LOG_DEBUG,
                         "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
                         {getName(), m_dependencyMetadata.getInterface()}, null );
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 //try to reactivate after ref is no longer tracked.
                 if (event != null)
                 {
@@ -509,7 +509,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 m_componentManager.log( LogService.LOG_DEBUG,
                         "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
                         {getName(), m_dependencyMetadata.getInterface()}, null );
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
             }
             //This is unlikely
             ungetService( refPair );
@@ -586,7 +586,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             tracked( trackingCount );
             if ( reactivate )
             {
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 if (event != null)
                 {
                     event.addComponentManager(m_componentManager);
@@ -609,7 +609,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     m_componentManager.log( LogService.LOG_DEBUG,
                         "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
                             { getName(), m_dependencyMetadata.getInterface() }, null );
-                    m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                    deactivateComponentManager();
 
                     // FELIX-2368: immediately try to reactivate
                     if (event != null)
@@ -624,7 +624,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 m_componentManager.log( LogService.LOG_DEBUG,
                         "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
                         {getName(), m_dependencyMetadata.getInterface()}, null );
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
             }
             ungetService( refPair );
             m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant removed {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
@@ -833,7 +833,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 this.trackingCount = trackingCount;
                 tracked( trackingCount );
                 untracked = false;
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
             }
             if ( oldRefPair != null )
             {
@@ -935,7 +935,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 }
                 if ( reactivate )
                 {
-                    m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                    deactivateComponentManager();
                     if (event != null)
                     {
                         event.addComponentManager(m_componentManager);
@@ -975,7 +975,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             tracked( trackingCount );
             if ( reactivate )
             {
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 synchronized ( sync )
                 {
                     if (refPair == this.refPair)
@@ -1008,7 +1008,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             }
             if ( reactivate )
             {
-                m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+                deactivateComponentManager();
                 synchronized ( sync )
                 {
                     if (refPair == this.refPair)
@@ -2150,4 +2150,9 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return new MultiplePrototypeRefPair<S, T>(m_componentManager.getBundleContext(), serviceReference);
     }
 
+    private void deactivateComponentManager()
+    {
+        m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+    }
+
 }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
index 8cbc47afdc..5abfa0239f 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
@@ -109,6 +109,7 @@ public class ServiceFactoryComponentManager<S> extends SingleComponentManager<S>
             //cannot obtain service from a required reference
             return null;
         }
+        State previousState = getState();
         // private ComponentContext and implementation instances
         S service = createImplementationObject( bundle, new SetImplementationObject<S>()
         {
@@ -139,7 +140,7 @@ public class ServiceFactoryComponentManager<S> extends SingleComponentManager<S>
         } 
         else 
         {
-            m_activated = true;
+             setState(previousState, State.active);
         }
 
         return service;
@@ -165,9 +166,10 @@ public class ServiceFactoryComponentManager<S> extends SingleComponentManager<S>
         {
             serviceContexts.remove( service );
             // if this was the last use of the component, go back to REGISTERED state
-            if ( serviceContexts.isEmpty() && getState() == STATE_ACTIVE )
+            State previousState;
+            if ( serviceContexts.isEmpty() && (previousState = getState()) == State.active )
             {
-                m_activated = false;
+                setState(previousState, State.satisfied);
             }
         }
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
index 93f202fe24..7f94981b74 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
@@ -438,29 +438,29 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                 props.putAll(m_factoryProperties);
                 if (getComponentMetadata().getDSVersion().isDS13() && m_factoryProperties.containsKey(Constants.SERVICE_PID))
                 {
-                	final List<String> servicePids = new ArrayList<String>();
-                	final Object configPropServicePids = m_configurationProperties.get(Constants.SERVICE_PID);
-                	if ( configPropServicePids instanceof List )
-                	{
-                		servicePids.addAll((List)configPropServicePids);
-                	}
-                	else
-                	{
-                		servicePids.add(configPropServicePids.toString());
-                	}
+                    final List<String> servicePids = new ArrayList<String>();
+                    final Object configPropServicePids = m_configurationProperties.get(Constants.SERVICE_PID);
+                    if ( configPropServicePids instanceof List )
+                    {
+                        servicePids.addAll((List)configPropServicePids);
+                    }
+                    else
+                    {
+                        servicePids.add(configPropServicePids.toString());
+                    }
                     if (m_factoryProperties.get(Constants.SERVICE_PID) instanceof String)
                     {
                         servicePids.add((String)m_factoryProperties.get(Constants.SERVICE_PID));
                     }
 
-                	if ( servicePids.size() == 1 )
-                	{
-                		props.put(Constants.SERVICE_PID, servicePids.get(0));
-                	}
-                	else
-                	{
-                		props.put(Constants.SERVICE_PID, servicePids);
-                	}
+                    if ( servicePids.size() == 1 )
+                    {
+                        props.put(Constants.SERVICE_PID, servicePids.get(0));
+                    }
+                    else
+                    {
+                        props.put(Constants.SERVICE_PID, servicePids);
+                    }
                 }
             }
 
@@ -613,7 +613,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
 
             // reactivate the component to ensure it is provided with the
             // configuration data
-            if ( m_disposed || !m_internalEnabled )
+            if ( !getState().isEnabled() )
             {
                 // nothing to do for inactive components, leave this method
                 log( LogService.LOG_DEBUG, "Component can not be activated since it is in state {0}", new Object[] { getState() }, null );
@@ -626,7 +626,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
             obtainActivationWriteLock( );
             try
             {
-                if ( !isSatisfied() && !getComponentMetadata().isConfigurationIgnored() )
+                if ( !getState().isSatisfied() && !getComponentMetadata().isConfigurationIgnored() )
                 {
                     log( LogService.LOG_DEBUG, "Attempting to activate unsatisfied component", null );
                     updateTargets( getProperties() );
@@ -678,11 +678,11 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
 
     private boolean modify(boolean configurationDeleted)
     {
-    	//0 SCR 112.7.1 If configuration is deleted, and version is < 1.3 and no flag set, then deactivate unconditionally.
-    	// For version 1.3 and later, or with a flag, more sensible behavior is allowed.
-    	if ( configurationDeleted && !getComponentMetadata().isDeleteCallsModify()){
-    		return false;
-    	}
+        //0 SCR 112.7.1 If configuration is deleted, and version is < 1.3 and no flag set, then deactivate unconditionally.
+        // For version 1.3 and later, or with a flag, more sensible behavior is allowed.
+        if ( configurationDeleted && !getComponentMetadata().isDeleteCallsModify()){
+            return false;
+        }
 
         // 1. no live update if there is no declared method
         if ( getComponentMetadata().getModified() == null )
@@ -860,6 +860,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                 {
                     if ( m_componentContext == null )
                     {
+                        State previousState = getState();
                         //state should be "Registered"
                         S result = getService(componentContext );
                         if ( result == null )
@@ -868,7 +869,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                         }
                         else
                         {
-                            m_activated = true;
+                            setState(previousState, State.active);
                         }
                     }
                 }
@@ -891,7 +892,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
     private S getService(ComponentContextImpl<S> componentContext)
     {
         //should be write locked
-        if (!isInternalEnabled())
+        if (!getState().isEnabled())
         {
             return null;
         }
@@ -932,7 +933,9 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
             // be kept (FELIX-3039)
             if (  m_useCount.decrementAndGet() == 0 && !isImmediate() && !keepInstances() )
             {
-                ungetService( );
+                State previousState = getState();
+                deleteComponent( ComponentConstants.DEACTIVATION_REASON_UNSPECIFIED );
+                setState(previousState, State.satisfied);
             }
         }
         finally
@@ -941,11 +944,6 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
         }
     }
 
-    private void ungetService( )
-    {
-        deleteComponent( ComponentConstants.DEACTIVATION_REASON_UNSPECIFIED );
-    }
-
     private boolean keepInstances()
     {
         return getComponentMetadata().isDelayedKeepInstances();
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/runtime/ServiceComponentRuntimeImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/runtime/ServiceComponentRuntimeImpl.java
index 1e392fe8fa..7e8a15c189 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/runtime/ServiceComponentRuntimeImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/runtime/ServiceComponentRuntimeImpl.java
@@ -138,7 +138,7 @@ public class ServiceComponentRuntimeImpl implements ServiceComponentRuntime
 		dto.description = description;
 		dto.id = manager.getId();
 		dto.properties = new HashMap<String, Object>(manager.getProperties());//TODO deep copy?
-		dto.state = manager.getState();
+		dto.state = manager.getSpecState();
 		return dto;
 	}
 
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/inject/ActivateMethodTest.java b/scr/src/test/java/org/apache/felix/scr/impl/inject/ActivateMethodTest.java
index 0812799235..30dfc01e6c 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/inject/ActivateMethodTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/inject/ActivateMethodTest.java
@@ -319,6 +319,11 @@ public class ActivateMethodTest extends TestCase
             public void disposed(SingleComponentManager component)
             {
             }
+
+            public boolean isEnabled()
+            {
+                return false;
+            }
             
         };
         return container;
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/inject/BindMethodTest.java b/scr/src/test/java/org/apache/felix/scr/impl/inject/BindMethodTest.java
index c10a0e1b83..580919134a 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/inject/BindMethodTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/inject/BindMethodTest.java
@@ -480,6 +480,11 @@ public class BindMethodTest extends TestCase
             {
             }
 
+            public boolean isEnabled()
+            {
+                return false;
+            }
+
         };
         return container;
     }
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/manager/SingleComponentManagerTest.java b/scr/src/test/java/org/apache/felix/scr/impl/manager/SingleComponentManagerTest.java
index 83fd24446e..78f9a5cb7d 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/manager/SingleComponentManagerTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/manager/SingleComponentManagerTest.java
@@ -27,6 +27,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.felix.scr.impl.helper.ComponentMethods;
 import org.apache.felix.scr.impl.inject.ComponentMethodsImpl;
+import org.apache.felix.scr.impl.manager.AbstractComponentManager.State;
 import org.apache.felix.scr.impl.metadata.ComponentMetadata;
 import org.apache.felix.scr.impl.metadata.DSVersion;
 import org.junit.Test;
@@ -68,7 +69,7 @@ public class SingleComponentManagerTest
         f.setAccessible(true);
         f.set(scm, cci);
 
-        scm.m_internalEnabled = true;
+        scm.setState(scm.getState(), State.unsatisfiedReference);
         assertSame(implObj, scm.getService(null, null));
 
         Field u = SingleComponentManager.class.getDeclaredField("m_useCount");
@@ -95,7 +96,7 @@ public class SingleComponentManagerTest
                 return true;
             }
         };
-        scm.m_internalEnabled = true;
+        scm.setState(scm.getState(), State.unsatisfiedReference);
         assertNull("m_componentContext is null, this should not cause an NPE",
                 scm.getService(null, null));
 
