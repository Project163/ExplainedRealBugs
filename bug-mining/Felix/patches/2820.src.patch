diff --git a/converter/schematizer/pom.xml b/converter/schematizer/pom.xml
index 53e5cbc9fd..4d7cb6bffa 100644
--- a/converter/schematizer/pom.xml
+++ b/converter/schematizer/pom.xml
@@ -122,7 +122,14 @@
             <version>6.0.0</version>
             <scope>provided</scope>
         </dependency>
-        
+
+        <dependency>
+            <groupId>org.apache.felix</groupId>
+            <artifactId>org.apache.felix.utils</artifactId>
+            <version>1.9.1-SNAPSHOT</version>
+            <scope>provided</scope>
+        </dependency>
+
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
diff --git a/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java b/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
index 6424b6e586..42e95808bb 100644
--- a/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
+++ b/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
@@ -33,6 +33,7 @@ import org.apache.felix.schematizer.Node;
 import org.apache.felix.schematizer.Schema;
 import org.apache.felix.schematizer.Schematizing;
 import org.apache.felix.schematizer.impl.Util;
+import org.apache.felix.utils.json.JSONParser;
 import org.osgi.dto.DTO;
 import org.osgi.service.serializer.Deserializing;
 import org.osgi.util.converter.ConversionException;
@@ -65,7 +66,7 @@ public class JsonDeserializingImpl<T> implements Deserializing<T> {
     @Override
     @SuppressWarnings("unchecked")
     public T from(CharSequence in) {
-        JsonParser jp = new JsonParser(in);
+        JSONParser jp = new JSONParser(in);
         Map<?,?> m = jp.getParsed();
         Class<T> clazz = (Class<T>)Util.rawClassOf(target);
         if (m.getClass().isAssignableFrom(clazz))
diff --git a/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java b/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java
deleted file mode 100644
index 8f15a4f6db..0000000000
--- a/converter/schematizer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.felix.serializer.impl.json;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Stack;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.felix.serializer.impl.Util;
-
-/**
- * A very small JSON parser.
- *
- * The JSON input is parsed into an object structure in the following way:
- * <ul>
- * <li>Object names are represented as a {@link String}.
- * <li>String values are represented as a {@link String}.
- * <li>Numeric values are represented as a {@link Long} (TODO support floats).
- * <li>Boolean values are represented as a {@link Boolean}.
- * <li>Nested JSON objects are parsed into a {@link java.util.Map Map&lt;String, Object&gt;}.
- * <li>JSON lists are parsed into a {@link java.util.List} which may contain any of the above values.
- * </ul>
- */
-public class JsonParser {
-    private static final Pattern KEY_VALUE_PATTERN = Pattern.compile("^\\s*[\"](.+?)[\"]\\s*[:]\\s*(.+)$");
-
-    private enum Scope { QUOTE, CURLY, BRACKET;
-        static Scope getScope(char c) {
-            switch (c) {
-            case '"':
-                return QUOTE;
-            case '[':
-            case ']':
-                return BRACKET;
-            case '{':
-            case '}':
-                return CURLY;
-            default:
-                return null;
-            }
-        }
-    }
-
-    static class Pair<K, V> {
-        final K key;
-        final V value;
-
-        Pair(K k, V v) {
-            key = k;
-            value = v;
-        }
-    }
-
-    private final Map<String, Object> parsed;
-
-    public JsonParser(CharSequence json) {
-        String str = json.toString();
-        str = str.trim().replace('\n', ' ').replace('\r', ' ');
-        parsed = parseObject(str);
-    }
-
-    public JsonParser(InputStream is) throws IOException {
-        this(readStreamAsString(is));
-    }
-
-    public Map<String, Object> getParsed() {
-        return parsed;
-    }
-
-    private static Pair<String, Object> parseKeyValue(String jsonKeyValue) {
-        Matcher matcher = KEY_VALUE_PATTERN.matcher(jsonKeyValue);
-        if (!matcher.matches() || matcher.groupCount() < 2) {
-            throw new IllegalArgumentException("Malformatted JSON key-value pair: " + jsonKeyValue);
-        }
-
-        return new Pair<>(matcher.group(1), parseValue(matcher.group(2)));
-    }
-
-    private static Object parseValue(String jsonValue) {
-        jsonValue = jsonValue.trim();
-
-        switch (jsonValue.charAt(0)) {
-        case '\"':
-            if (!jsonValue.endsWith("\""))
-                throw new IllegalArgumentException("Malformatted JSON string: " + jsonValue);
-
-            return jsonValue.substring(1, jsonValue.length() - 1);
-        case '[':
-            List<Object> entries = new ArrayList<>();
-            for (String v : parseListValuesRaw(jsonValue)) {
-                entries.add(parseValue(v));
-            }
-            return entries;
-        case '{':
-            return parseObject(jsonValue);
-        case 't':
-        case 'T':
-        case 'f':
-        case 'F':
-            return Boolean.parseBoolean(jsonValue);
-        case 'n':
-        case 'N':
-            return null;
-        default:
-            if (jsonValue.contains("."))
-                return Double.parseDouble(jsonValue);
-            else
-                return Long.parseLong(jsonValue);
-        }
-    }
-
-    private static Map<String, Object> parseObject(String jsonObject) {
-        if (!(jsonObject.startsWith("{") && jsonObject.endsWith("}")))
-            throw new IllegalArgumentException("Malformatted JSON object: " + jsonObject);
-
-        jsonObject = jsonObject.substring(1, jsonObject.length() - 1);
-
-        if (jsonObject.isEmpty())
-            return null;
-
-        Map<String, Object> values = new HashMap<>();
-        for (String element : parseKeyValueListRaw(jsonObject)) {
-            Pair<String, Object> pair = parseKeyValue(element);
-            values.put(pair.key, pair.value);
-        }
-
-        return values;
-    }
-
-    private static List<String> parseKeyValueListRaw(String jsonKeyValueList) {
-        if (jsonKeyValueList.trim().isEmpty())
-            return Collections.emptyList();
-        // Append comma to simplify parsing, if there is not already a trailing comma
-        if (!jsonKeyValueList.endsWith(","))
-                jsonKeyValueList = jsonKeyValueList + ",";
-        List<String> elements = new ArrayList<>();
-
-        int i=0;
-        int start=0;
-        Stack<Scope> scopeStack = new Stack<>();
-        while (i < jsonKeyValueList.length()) {
-            char curChar = jsonKeyValueList.charAt(i);
-            switch (curChar) {
-            case '"':
-                if (i > 0 && jsonKeyValueList.charAt(i-1) == '\\') {
-                    // it's escaped, ignore for now
-                } else {
-                    if (!scopeStack.empty() && scopeStack.peek() == Scope.QUOTE) {
-                        scopeStack.pop();
-                    } else {
-                        scopeStack.push(Scope.QUOTE);
-                    }
-                }
-                break;
-            case '[':
-            case '{':
-                if ((scopeStack.empty() ? null : scopeStack.peek()) == Scope.QUOTE) {
-                    // inside quotes, ignore
-                } else {
-                    scopeStack.push(Scope.getScope(curChar));
-                }
-                break;
-            case ']':
-            case '}':
-                Scope curScope = scopeStack.empty() ? null : scopeStack.peek();
-                if (curScope == Scope.QUOTE) {
-                    // inside quotes, ignore
-                } else {
-                    Scope newScope = Scope.getScope(curChar);
-                    if (curScope == newScope) {
-                        scopeStack.pop();
-                    } else {
-                        throw new IllegalArgumentException("Unbalanced closing " +
-                            curChar + " in: " + jsonKeyValueList);
-                    }
-                }
-                break;
-            case ',':
-                if (scopeStack.empty()) {
-                    elements.add(jsonKeyValueList.substring(start, i));
-                    start = i+1;
-                }
-                break;
-            }
-
-            i++;
-        }
-        return elements;
-    }
-
-    private static List<String> parseListValuesRaw(String jsonList) {
-        if (!(jsonList.startsWith("[") && jsonList.endsWith("]")))
-            throw new IllegalArgumentException("Malformatted JSON list: " + jsonList);
-
-        jsonList = jsonList.substring(1, jsonList.length() - 1);
-        return parseKeyValueListRaw(jsonList);
-    }
-
-    private static String readStreamAsString(InputStream is) throws IOException {
-        byte [] bytes = Util.readStream(is);
-        if (bytes.length < 5)
-            // need at least 5 bytes to establish the encoding
-            throw new IllegalArgumentException("Malformatted JSON");
-
-        int offset = 0;
-        if ((bytes[0] == -1 && bytes[1] == -2)
-            || (bytes[0] == -2 && bytes[1] == -1)) {
-            // Skip UTF16/UTF32 Byte Order Mark (BOM)
-            offset = 2;
-        }
-
-        /* Infer the encoding as described in section 3 of http://www.ietf.org/rfc/rfc4627.txt
-         * which reads:
-         *   Encoding
-         *
-         *   JSON text SHALL be encoded in Unicode.  The default encoding is
-         *   UTF-8.
-         *
-         *   Since the first two characters of a JSON text will always be ASCII
-         *   characters [RFC0020], it is possible to determine whether an octet
-         *   stream is UTF-8, UTF-16 (BE or LE), or UTF-32 (BE or LE) by looking
-         *   at the pattern of nulls in the first four octets.
-         *
-         *         00 00 00 xx  UTF-32BE
-         *         00 xx 00 xx  UTF-16BE
-         *         xx 00 00 00  UTF-32LE
-         *         xx 00 xx 00  UTF-16LE
-         *         xx xx xx xx  UTF-8
-         */
-        String encoding;
-        if (bytes[offset + 2] == 0) {
-            if (bytes[offset + 1] != 0) {
-                encoding = "UTF-16";
-            } else {
-                encoding = "UTF-32";
-            }
-        } else if (bytes[offset + 1] == 0) {
-            encoding = "UTF-16";
-        } else {
-            encoding = "UTF-8";
-        }
-        return new String(bytes, encoding);
-    }
-}
\ No newline at end of file
diff --git a/converter/serializer/pom.xml b/converter/serializer/pom.xml
index fdfabc0508..d4253134c2 100644
--- a/converter/serializer/pom.xml
+++ b/converter/serializer/pom.xml
@@ -101,7 +101,14 @@
             <artifactId>snakeyaml</artifactId>
             <version>1.17</version>
         </dependency>
-        
+
+        <dependency>
+            <groupId>org.apache.felix</groupId>
+            <artifactId>org.apache.felix.utils</artifactId>
+            <version>1.9.1-SNAPSHOT</version>
+            <scope>provided</scope>
+        </dependency>
+
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
index 2bbaf23b4e..9b022e4b93 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
@@ -25,6 +25,7 @@ import java.util.Map;
 import java.util.Scanner;
 
 import org.apache.felix.serializer.impl.Util;
+import org.apache.felix.utils.json.JSONParser;
 import org.osgi.service.serializer.Deserializing;
 import org.osgi.util.converter.ConversionException;
 import org.osgi.util.converter.Converter;
@@ -41,7 +42,7 @@ public class JsonDeserializingImpl<T> implements Deserializing<T> {
     @Override
     @SuppressWarnings("unchecked")
     public T from(CharSequence in) {
-        JsonParser jp = new JsonParser(in);
+        JSONParser jp = new JSONParser(in);
         Map<?,?> m = jp.getParsed();
         if (type instanceof Class)
             if (m.getClass().isAssignableFrom((Class<?>) type))
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java
deleted file mode 100644
index ba078c2fb4..0000000000
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonParser.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.felix.serializer.impl.json;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Stack;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.felix.serializer.impl.Util;
-
-/**
- * A very small JSON parser.
- *
- * The JSON input is parsed into an object structure in the following way:
- * <ul>
- * <li>Object names are represented as a {@link String}.
- * <li>String values are represented as a {@link String}.
- * <li>Numeric values without a decimal separator are represented as a {@link Long}.
- * <li>Numeric values with a decimal separator are represented as a {@link Double}.
- * <li>Boolean values are represented as a {@link Boolean}.
- * <li>Nested JSON objects are parsed into a {@link java.util.Map Map&lt;String, Object&gt;}.
- * <li>JSON lists are parsed into a {@link java.util.List} which may contain any of the above values.
- * </ul>
- */
-public class JsonParser {
-    private static final Pattern KEY_VALUE_PATTERN = Pattern.compile("^\\s*[\"](.+?)[\"]\\s*[:]\\s*(.+)$");
-
-    private enum Scope { QUOTE, CURLY, BRACKET;
-        static Scope getScope(char c) {
-            switch (c) {
-            case '"':
-                return QUOTE;
-            case '[':
-            case ']':
-                return BRACKET;
-            case '{':
-            case '}':
-                return CURLY;
-            default:
-                return null;
-            }
-        }
-    }
-
-    static class Pair<K, V> {
-        final K key;
-        final V value;
-
-        Pair(K k, V v) {
-            key = k;
-            value = v;
-        }
-    }
-
-    private final Map<String, Object> parsed;
-
-    public JsonParser(CharSequence json) {
-        String str = json.toString();
-        str = str.trim().replace('\n', ' ').replace('\r', ' ');
-        parsed = parseObject(str);
-    }
-
-    public JsonParser(InputStream is) throws IOException {
-        this(readStreamAsString(is));
-    }
-
-    public Map<String, Object> getParsed() {
-        return parsed;
-    }
-
-    private static Pair<String, Object> parseKeyValue(String jsonKeyValue) {
-        Matcher matcher = KEY_VALUE_PATTERN.matcher(jsonKeyValue);
-        if (!matcher.matches() || matcher.groupCount() < 2) {
-            throw new IllegalArgumentException("Malformatted JSON key-value pair: " + jsonKeyValue);
-        }
-
-        return new Pair<>(matcher.group(1), parseValue(matcher.group(2)));
-    }
-
-    private static Object parseValue(String jsonValue) {
-        jsonValue = jsonValue.trim();
-
-        switch (jsonValue.charAt(0)) {
-        case '\"':
-            if (!jsonValue.endsWith("\""))
-                throw new IllegalArgumentException("Malformatted JSON string: " + jsonValue);
-
-            return jsonValue.substring(1, jsonValue.length() - 1);
-        case '[':
-            List<Object> entries = new ArrayList<>();
-            for (String v : parseListValuesRaw(jsonValue)) {
-                entries.add(parseValue(v));
-            }
-            return entries;
-        case '{':
-            return parseObject(jsonValue);
-        case 't':
-        case 'T':
-        case 'f':
-        case 'F':
-            return Boolean.parseBoolean(jsonValue);
-        case 'n':
-        case 'N':
-            return null;
-        default:
-            if (jsonValue.contains(".")) {
-                return Double.parseDouble(jsonValue);
-            }
-            return Long.parseLong(jsonValue);
-        }
-    }
-
-    private static Map<String, Object> parseObject(String jsonObject) {
-        if (!(jsonObject.startsWith("{") && jsonObject.endsWith("}")))
-            throw new IllegalArgumentException("Malformatted JSON object: " + jsonObject);
-
-        Map<String, Object> values = new HashMap<>();
-
-        jsonObject = jsonObject.substring(1, jsonObject.length() - 1).trim();
-        if (jsonObject.length() == 0)
-            return values;
-
-        for (String element : parseKeyValueListRaw(jsonObject)) {
-            Pair<String, Object> pair = parseKeyValue(element);
-            values.put(pair.key, pair.value);
-        }
-
-        return values;
-    }
-
-    private static List<String> parseKeyValueListRaw(String jsonKeyValueList) {
-        if (jsonKeyValueList.trim().isEmpty())
-            return Collections.emptyList();
-        jsonKeyValueList = jsonKeyValueList + ","; // append comma to simplify parsing
-        List<String> elements = new ArrayList<>();
-
-        int i=0;
-        int start=0;
-        Stack<Scope> scopeStack = new Stack<>();
-        while (i < jsonKeyValueList.length()) {
-            char curChar = jsonKeyValueList.charAt(i);
-            switch (curChar) {
-            case '"':
-                if (i > 0 && jsonKeyValueList.charAt(i-1) == '\\') {
-                    // it's escaped, ignore for now
-                } else {
-                    if (!scopeStack.empty() && scopeStack.peek() == Scope.QUOTE) {
-                        scopeStack.pop();
-                    } else {
-                        scopeStack.push(Scope.QUOTE);
-                    }
-                }
-                break;
-            case '[':
-            case '{':
-                if ((scopeStack.empty() ? null : scopeStack.peek()) == Scope.QUOTE) {
-                    // inside quotes, ignore
-                } else {
-                    scopeStack.push(Scope.getScope(curChar));
-                }
-                break;
-            case ']':
-            case '}':
-                Scope curScope = scopeStack.empty() ? null : scopeStack.peek();
-                if (curScope == Scope.QUOTE) {
-                    // inside quotes, ignore
-                } else {
-                    Scope newScope = Scope.getScope(curChar);
-                    if (curScope == newScope) {
-                        scopeStack.pop();
-                    } else {
-                        throw new IllegalArgumentException("Unbalanced closing " +
-                            curChar + " in: " + jsonKeyValueList);
-                    }
-                }
-                break;
-            case ',':
-                if (scopeStack.empty()) {
-                    elements.add(jsonKeyValueList.substring(start, i));
-                    start = i+1;
-                }
-                break;
-            }
-
-            i++;
-        }
-        return elements;
-    }
-
-    private static List<String> parseListValuesRaw(String jsonList) {
-        if (!(jsonList.startsWith("[") && jsonList.endsWith("]")))
-            throw new IllegalArgumentException("Malformatted JSON list: " + jsonList);
-
-        jsonList = jsonList.substring(1, jsonList.length() - 1);
-        return parseKeyValueListRaw(jsonList);
-    }
-
-    private static String readStreamAsString(InputStream is) throws IOException {
-        byte [] bytes = Util.readStream(is);
-        if (bytes.length < 5)
-            // need at least 5 bytes to establish the encoding
-            throw new IllegalArgumentException("Malformatted JSON");
-
-        int offset = 0;
-        if ((bytes[0] == -1 && bytes[1] == -2)
-            || (bytes[0] == -2 && bytes[1] == -1)) {
-            // Skip UTF16/UTF32 Byte Order Mark (BOM)
-            offset = 2;
-        }
-
-        /* Infer the encoding as described in section 3 of http://www.ietf.org/rfc/rfc4627.txt
-         * which reads:
-         *   Encoding
-         *
-         *   JSON text SHALL be encoded in Unicode.  The default encoding is
-         *   UTF-8.
-         *
-         *   Since the first two characters of a JSON text will always be ASCII
-         *   characters [RFC0020], it is possible to determine whether an octet
-         *   stream is UTF-8, UTF-16 (BE or LE), or UTF-32 (BE or LE) by looking
-         *   at the pattern of nulls in the first four octets.
-         *
-         *         00 00 00 xx  UTF-32BE
-         *         00 xx 00 xx  UTF-16BE
-         *         xx 00 00 00  UTF-32LE
-         *         xx 00 xx 00  UTF-16LE
-         *         xx xx xx xx  UTF-8
-         */
-        String encoding;
-        if (bytes[offset + 2] == 0) {
-            if (bytes[offset + 1] != 0) {
-                encoding = "UTF-16";
-            } else {
-                encoding = "UTF-32";
-            }
-        } else if (bytes[offset + 1] == 0) {
-            encoding = "UTF-16";
-        } else {
-            encoding = "UTF-8";
-        }
-        return new String(bytes, encoding);
-    }
-}
\ No newline at end of file
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
index 9842b2678a..0fb8f7e268 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
@@ -22,6 +22,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.felix.utils.json.JSONParser;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -31,7 +32,7 @@ public class JsonParserTest {
     @Test
     public void testJsonSimple() {
         String json = "{\"hi\": \"ho\", \"ha\": true}";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(2, m.size());
         assertEquals("ho", m.get("hi"));
@@ -50,7 +51,7 @@ public class JsonParserTest {
                 + "  ]\n"
                 + "}\n"
                 + "\n";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(2, m.size());
         assertEquals("ho", m.get("hi"));
@@ -69,7 +70,7 @@ public class JsonParserTest {
                 + "  ]\r\n"
                 + "}\r\n"
                 + "\r\n";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(2, m.size());
         assertEquals("ho", m.get("hi"));
@@ -80,7 +81,7 @@ public class JsonParserTest {
     @SuppressWarnings("unchecked")
     public void testJsonComplex() {
         String json = "{\"a\": [1,2,3,4,5], \"b\": {\"x\": 12, \"y\": 42, \"z\": {\"test test\": \"hello hello\"}}, \"ddd\": 12.34}";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(3, m.size());
         assertEquals(Arrays.asList(1L, 2L, 3L, 4L, 5L), m.get("a"));
@@ -97,7 +98,7 @@ public class JsonParserTest {
     @Test
     public void testJsonArray() {
         String json = "{\"abc\": [\"x\", \"y\", \"z\"]}";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(1, m.size());
         assertEquals(Arrays.asList("x", "y", "z"), m.get("abc"));
@@ -106,7 +107,7 @@ public class JsonParserTest {
     @Test
     public void testEmptyJsonArray() {
         String json = "{\"abc\": {\"def\": []}}";
-        JsonParser jp = new JsonParser(json);
+        JSONParser jp = new JSONParser(json);
         Map<String, Object> m = jp.getParsed();
         assertEquals(1, m.size());
         Map<String, Object> result = new HashMap<>();
diff --git a/utils/src/main/java/org/apache/felix/utils/json/JSONParser.java b/utils/src/main/java/org/apache/felix/utils/json/JSONParser.java
index 24f5d775f6..20f70ac133 100644
--- a/utils/src/main/java/org/apache/felix/utils/json/JSONParser.java
+++ b/utils/src/main/java/org/apache/felix/utils/json/JSONParser.java
@@ -76,7 +76,7 @@ public class JSONParser {
 
     public JSONParser(CharSequence json) {
         String str = json.toString();
-        str = str.trim().replace('\n', ' ');
+        str = str.trim().replace('\n', ' ').replace('\r', ' ');
         parsed = parseObject(str);
     }
 
@@ -329,4 +329,4 @@ public class JSONParser {
         }
         return new String(bytes, encoding);
     }
-}
\ No newline at end of file
+}
