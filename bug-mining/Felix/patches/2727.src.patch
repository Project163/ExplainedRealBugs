diff --git a/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ComponentImpl.java b/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ComponentImpl.java
index 1ac0837993..eba044d1cd 100644
--- a/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ComponentImpl.java
+++ b/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ComponentImpl.java
@@ -1161,44 +1161,48 @@ public class ComponentImpl implements Component, ComponentContext, ComponentDecl
      * Then handleEvent calls this method when a dependency service is being removed.
      */
     private void handleRemoved(DependencyContext dc, Event e) {
-        if (! m_isStarted) {
-            return;
-        }
-        // Check if the dependency is still available.
-        Set<Event> dependencyEvents = m_dependencyEvents.get(dc);
-        int size = dependencyEvents.size();
-        if (dependencyEvents.contains(e)) {
-            size--; // the dependency is currently registered and is about to be removed.
-        }
-        dc.setAvailable(size > 0);
-        
-        // If the dependency is now unavailable, we have to recalculate state change. This will result in invoking the
-        // "removed" callback with the removed dependency (which we have not yet removed from our dependency events list.).
-        // But we don't recalculate the state if the dependency is not started (if not started, it means that it is currently starting,
-        // and the tracker is detecting a removed service).
-        if (size == 0 && dc.isStarted()) {
-            handleChange();
-        }
+    	try {
+    		if (! m_isStarted) {
+    			return;
+    		}
+    		// Check if the dependency is still available.
+    		Set<Event> dependencyEvents = m_dependencyEvents.get(dc);
+    		int size = dependencyEvents.size();
+    		if (dependencyEvents.contains(e)) {
+    			size--; // the dependency is currently registered and is about to be removed.
+    		}
+    		dc.setAvailable(size > 0);
         
-        // Now, really remove the dependency event.
-        dependencyEvents.remove(e);    
+    		// If the dependency is now unavailable, we have to recalculate state change. This will result in invoking the
+    		// "removed" callback with the removed dependency (which we have not yet removed from our dependency events list.).
+    		// But we don't recalculate the state if the dependency is not started (if not started, it means that it is currently starting,
+    		// and the tracker is detecting a removed service).
+    		if (size == 0 && dc.isStarted()) {
+    			handleChange();
+    		}
+    		
+    		// Now, really remove the dependency event.
+    		dependencyEvents.remove(e);    
         
-        // Depending on the state, we possible have to invoke the callbacks and update the component instance.        
-        switch (m_state) {
-        case INSTANTIATED_AND_WAITING_FOR_REQUIRED:
-            if (!dc.isInstanceBound()) {
-                if (dc.isRequired()) {
-                    invokeCallbackSafe(dc, EventType.REMOVED, e);
-                }
-                updateInstance(dc, e, false, false);
-            }
-            break;
-        case TRACKING_OPTIONAL:
-            invokeCallbackSafe(dc, EventType.REMOVED, e);
-            updateInstance(dc, e, false, false);
-            break;
-        default:
-        }
+    		// Depending on the state, we possible have to invoke the callbacks and update the component instance.        
+			switch (m_state) {
+			case INSTANTIATED_AND_WAITING_FOR_REQUIRED:
+				if (!dc.isInstanceBound()) {
+					if (dc.isRequired()) {
+						invokeCallbackSafe(dc, EventType.REMOVED, e);
+					}
+					updateInstance(dc, e, false, false);
+				}
+				break;
+			case TRACKING_OPTIONAL:
+				invokeCallbackSafe(dc, EventType.REMOVED, e);
+				updateInstance(dc, e, false, false);
+				break;
+			default:
+			}
+    	} finally {
+    		e.close();
+    	}
     }
     
     private void handleSwapped(DependencyContext dc, Event oldEvent, Event newEvent) {
diff --git a/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ServiceEventImpl.java b/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ServiceEventImpl.java
index a27147da5b..ebc26eb142 100644
--- a/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ServiceEventImpl.java
+++ b/dependencymanager/org.apache.felix.dependencymanager/src/org/apache/felix/dm/impl/ServiceEventImpl.java
@@ -41,9 +41,7 @@ public class ServiceEventImpl extends Event {
 	private final BundleContext m_bundleContext;
 	
     /**
-     * The bundle which has created the service dependency. If not null, will be used to ensure that the bundle is still active before
-     * ungetting the service reference of the dependency. (ungetting a service reference on a bundle which is not
-     * active triggers an exception, and this may degrade performance, especially when doing some benchmarks).
+     * The bundle which has created the service dependency.
      */
 	private final Bundle m_bundle;
 	
@@ -112,12 +110,7 @@ public class ServiceEventImpl extends Event {
     public void close() {
         if (m_bundleContext != null) {
             try {
-                // Optimization: don't call ungetService if the bundle referring to the service is not active. 
-                // This optim is important when doing benchmarks where the referring bundle is being stopped 
-                // while some dependencies are lost concurrently (here we want to avoid having many exception thrown).
-                if (m_bundle == null || m_bundle.getState() == Bundle.ACTIVE) {
-                    m_bundleContext.ungetService(m_reference);
-                }
+            	m_bundleContext.ungetService(m_reference);
             } catch (IllegalStateException e) {}
         }
     }
