diff --git a/scr/src/main/java/org/apache/felix/scr/impl/Activator.java b/scr/src/main/java/org/apache/felix/scr/impl/Activator.java
index 87b08e7e97..fa8c87e4b5 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/Activator.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/Activator.java
@@ -61,7 +61,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
     private static ServiceTracker m_packageAdmin;
 
     // map of BundleComponentActivator instances per Bundle indexed by Bundle id
-    private Map m_componentBundles;
+    private Map<Long, BundleComponentActivator> m_componentBundles;
 
     // registry of managed component
     private ComponentRegistry m_componentRegistry;
@@ -85,7 +85,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
         m_logService.open();
 
         // prepare component registry
-        m_componentBundles = new HashMap();
+        m_componentBundles = new HashMap<Long, BundleComponentActivator>();
         m_componentRegistry = new ComponentRegistry( context );
 
         // get the configuration
@@ -191,9 +191,8 @@ public class Activator implements BundleActivator, SynchronousBundleListener
     private void loadAllComponents( BundleContext context )
     {
         Bundle[] bundles = context.getBundles();
-        for ( int i = 0; i < bundles.length; i++ )
+        for ( Bundle bundle : bundles )
         {
-            Bundle bundle = bundles[i];
             if ( ComponentRegistry.isBundleActive( bundle ) )
             {
                 loadComponents( bundle );
@@ -234,7 +233,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
         // FELIX-2231 Mark bundle loaded early to prevent concurrent loading
         // if LAZY_ACTIVATION and STARTED event are fired at the same time
         final boolean loaded;
-        final Long bundleId = new Long( bundle.getBundleId() );
+        final Long bundleId = bundle.getBundleId();
         synchronized ( m_componentBundles )
         {
             if ( m_componentBundles.containsKey( bundleId ) )
@@ -243,7 +242,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
             }
             else
             {
-                m_componentBundles.put( bundleId, bundleId );
+                m_componentBundles.put( bundleId, null );
                 loaded = false;
             }
         }
@@ -306,7 +305,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
         final Object ga;
         synchronized ( m_componentBundles )
         {
-            ga = m_componentBundles.remove( new Long( bundle.getBundleId() ) );
+            ga = m_componentBundles.remove( bundle.getBundleId() );
         }
 
         if ( ga instanceof BundleComponentActivator )
@@ -334,11 +333,11 @@ public class Activator implements BundleActivator, SynchronousBundleListener
             m_componentBundles.clear();
         }
 
-        for ( int i = 0; i < activators.length; i++ )
+        for ( Object activator : activators )
         {
-            if ( activators[i] instanceof BundleComponentActivator )
+            if ( activator instanceof BundleComponentActivator )
             {
-                final BundleComponentActivator ga = ( BundleComponentActivator ) activators[i];
+                final BundleComponentActivator ga = ( BundleComponentActivator ) activator;
                 try
                 {
                     final Bundle bundle = ga.getBundleContext().getBundle();
@@ -349,7 +348,7 @@ public class Activator implements BundleActivator, SynchronousBundleListener
                     catch ( Exception e )
                     {
                         log( LogService.LOG_ERROR, m_context.getBundle(), "Error while disposing components of bundle "
-                            + bundle.getSymbolicName() + "/" + bundle.getBundleId(), e );
+                                + bundle.getSymbolicName() + "/" + bundle.getBundleId(), e );
                     }
                 }
                 catch ( IllegalStateException e )
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java b/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
index 1be5427920..4d040ee9b6 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
@@ -61,7 +61,7 @@ public class BundleComponentActivator implements Logger
     private BundleContext m_context = null;
 
     // This is a list of component instance managers that belong to a particular bundle
-    private List m_managers = new ArrayList();
+    private List<ComponentHolder> m_managers = new ArrayList<ComponentHolder>();
 
     // The Configuration Admin tracker providing configuration for components
     private ServiceTracker m_logService;
@@ -144,16 +144,15 @@ public class BundleComponentActivator implements Logger
             }
 
             // load from the descriptors
-            for ( int i = 0; i < descriptorURLs.length; i++ )
+            for ( URL descriptorURL : descriptorURLs )
             {
-                loadDescriptor( descriptorURLs[i] );
+                loadDescriptor( descriptorURL );
             }
         }
         //enable all the enabled components
-        for (Iterator it = m_managers.iterator(); it.hasNext();)
+        for ( ComponentHolder componentHolder : m_managers )
         {
-            ComponentHolder componentHolder = ( ComponentHolder ) it.next();
-            if (componentHolder.getComponentMetadata().isEnabled())
+            if ( componentHolder.getComponentMetadata().isEnabled() )
             {
                 componentHolder.enableComponents( false );
             }
@@ -191,19 +190,19 @@ public class BundleComponentActivator implements Logger
         }
 
         // find the entries
-        final Enumeration entries = bundle.findEntries( path, filePattern, false );
+        final Enumeration<URL> entries = bundle.findEntries( path, filePattern, false );
         if ( entries == null || !entries.hasMoreElements() )
         {
             return new URL[0];
         }
 
         // create the result list
-        List urls = new ArrayList();
+        List<URL> urls = new ArrayList<URL>();
         while ( entries.hasMoreElements() )
         {
             urls.add( entries.nextElement() );
         }
-        return ( URL[] ) urls.toArray( new URL[urls.size()] );
+        return urls.toArray( new URL[urls.size()] );
     }
 
 
@@ -227,10 +226,9 @@ public class BundleComponentActivator implements Logger
 
             // 112.4.2 Component descriptors may contain a single, root component element
             // or one or more component elements embedded in a larger document
-            Iterator i = handler.getComponentMetadataList().iterator();
-            while ( i.hasNext() )
+            for ( Object o : handler.getComponentMetadataList() )
             {
-                ComponentMetadata metadata = ( ComponentMetadata ) i.next();
+                ComponentMetadata metadata = ( ComponentMetadata ) o;
                 ComponentRegistryKey key = null;
                 try
                 {
@@ -313,7 +311,7 @@ public class BundleComponentActivator implements Logger
 
         while ( m_managers.size() != 0 )
         {
-            ComponentHolder holder = ( ComponentHolder ) m_managers.get( 0 );
+            ComponentHolder holder = m_managers.get( 0 );
             try
             {
                 m_managers.remove( holder );
@@ -333,7 +331,7 @@ public class BundleComponentActivator implements Logger
         }
 
         log( LogService.LOG_DEBUG, "BundleComponentActivator : Bundle [{0}] STOPPED", new Object[]
-            { new Long( m_context.getBundle().getBundleId() ) }, null, null );
+            {m_context.getBundle().getBundleId()}, null, null );
 
         if (m_logService != null) {
             m_logService.close();
@@ -393,16 +391,16 @@ public class BundleComponentActivator implements Logger
             return;
         }
 
-        for ( int i = 0; i < holder.length; i++ )
+        for ( ComponentHolder aHolder : holder )
         {
             try
             {
-                log( LogService.LOG_DEBUG, "Enabling Component", holder[i].getComponentMetadata(), null );
-                holder[i].enableComponents( true );
+                log( LogService.LOG_DEBUG, "Enabling Component", aHolder.getComponentMetadata(), null );
+                aHolder.enableComponents( true );
             }
             catch ( Throwable t )
             {
-                log( LogService.LOG_ERROR, "Cannot enable component", holder[i].getComponentMetadata(), t );
+                log( LogService.LOG_ERROR, "Cannot enable component", aHolder.getComponentMetadata(), t );
             }
         }
     }
@@ -425,16 +423,16 @@ public class BundleComponentActivator implements Logger
             return;
         }
 
-        for ( int i = 0; i < holder.length; i++ )
+        for ( ComponentHolder aHolder : holder )
         {
             try
             {
-                log( LogService.LOG_DEBUG, "Disabling Component", holder[i].getComponentMetadata(), null );
-                holder[i].disableComponents( true );
+                log( LogService.LOG_DEBUG, "Disabling Component", aHolder.getComponentMetadata(), null );
+                aHolder.disableComponents( true );
             }
             catch ( Throwable t )
             {
-                log( LogService.LOG_ERROR, "Cannot disable component", holder[i].getComponentMetadata(), t );
+                log( LogService.LOG_ERROR, "Cannot disable component", aHolder.getComponentMetadata(), t );
             }
         }
     }
@@ -460,7 +458,7 @@ public class BundleComponentActivator implements Logger
         // if all components are selected
         if ( name == null )
         {
-            return ( ComponentHolder[] ) m_managers.toArray( new ComponentHolder[m_managers.size()] );
+            return m_managers.toArray( new ComponentHolder[m_managers.size()] );
         }
 
         ComponentHolder componentHolder = m_componentRegistry.getComponentHolder( m_context.getBundle(), name );
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
index 0e2ab5cb96..4672d87adf 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
@@ -19,6 +19,7 @@
 package org.apache.felix.scr.impl;
 
 
+import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Dictionary;
@@ -82,7 +83,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
      * @see #registerComponentHolder(String, ComponentHolder)
      * @see #unregisterComponentHolder(String)
      */
-    private final Map /* <ComponentRegistryKey, Object> */ m_componentHoldersByName;
+    private final Map<ComponentRegistryKey, ComponentHolder> m_componentHoldersByName;
 
     /**
      * The map of known components indexed by component configuration pid. The values are
@@ -101,7 +102,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
      * @see #unregisterComponentHolder(String)
      * @see ConfigurationSupport#configurationEvent(org.osgi.service.cm.ConfigurationEvent)
      */
-    private final Map m_componentHoldersByPid;
+    private final Map<String, Set<ComponentHolder>> m_componentHoldersByPid;
 
     /**
      * Map of components by component ID. This map indexed by the component
@@ -111,7 +112,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
      * @see #registerComponentId(AbstractComponentManager)
      * @see #unregisterComponentId(long)
      */
-    private final Map m_componentsById;
+    private final Map<Long, AbstractComponentManager> m_componentsById;
 
     /**
      * Counter to setup the component IDs as issued by the
@@ -130,7 +131,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
     // the ConfigurationAdmin service
     private ConfigurationSupport configurationSupport;
 
-    private final Map m_missingDependencies = new HashMap( );
+    private final Map<ServiceReference<?>, List<DependencyManager>> m_missingDependencies = new HashMap<ServiceReference<?>, List<DependencyManager>>( );
 
     protected ComponentRegistry( BundleContext context )
     {
@@ -333,27 +334,31 @@ public class ComponentRegistry implements ScrService, ServiceListener
     {
         // register the name if no registration for that name exists already
         final ComponentRegistryKey key = new ComponentRegistryKey( bundle, name );
-        final Object existingRegistration;
+        ComponentHolder existingRegistration = null;
+        boolean present;
         synchronized ( m_componentHoldersByName )
         {
-            existingRegistration = m_componentHoldersByName.get( key );
-            if ( existingRegistration == null )
+            present = m_componentHoldersByName.containsKey( key );
+            if ( !present )
             {
-                m_componentHoldersByName.put( key, key );
+                m_componentHoldersByName.put( key, null );
+            }
+            else
+            {
+                existingRegistration = m_componentHoldersByName.get( key );
             }
         }
 
         // there was a registration already, throw an exception and use the
         // existing registration to provide more information if possible
-        if ( existingRegistration != null )
+        if ( present )
         {
             String message = "The component name '" + name + "' has already been registered";
 
-            if ( existingRegistration instanceof ComponentHolder )
+            if ( existingRegistration != null )
             {
-                ComponentHolder c = ( ComponentHolder ) existingRegistration;
-                Bundle cBundle = c.getActivator().getBundleContext().getBundle();
-                ComponentMetadata cMeta = c.getComponentMetadata();
+                Bundle cBundle = existingRegistration.getActivator().getBundleContext().getBundle();
+                ComponentMetadata cMeta = existingRegistration.getComponentMetadata();
 
                 StringBuffer buf = new StringBuffer( message );
                 buf.append( " by Bundle " ).append( cBundle.getBundleId() );
@@ -388,7 +393,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
         synchronized ( m_componentHoldersByName )
         {
             // only register the component if there is a m_registration for it !
-            if ( !key.equals( m_componentHoldersByName.get( key ) ) )
+            if ( m_componentHoldersByName.get( key ) != null )
             {
                 // this is not expected if all works ok
                 throw new ComponentException( "The component name '" + component.getComponentMetadata().getName()
@@ -406,10 +411,10 @@ public class ComponentRegistry implements ScrService, ServiceListener
             // Since several components may refer to the same configuration pid, we have to
             // store the component holder in a Set, in order to be able to lookup every
             // components from a given pid.
-            Set set = (Set) m_componentHoldersByPid.get(configurationPid);
+            Set<ComponentHolder> set = m_componentHoldersByPid.get(configurationPid);
             if (set == null)
             {
-                set = new HashSet();
+                set = new HashSet<ComponentHolder>();
                 m_componentHoldersByPid.put(configurationPid, set);
             }
             set.add(component);
@@ -422,7 +427,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
      */
     public final ComponentHolder getComponentHolder( final Bundle bundle, final String name )
     {
-        Object entry;
+        ComponentHolder entry;
         synchronized ( m_componentHoldersByName )
         {
             entry = m_componentHoldersByName.get( new ComponentRegistryKey( bundle, name ) );
@@ -444,12 +449,12 @@ public class ComponentRegistry implements ScrService, ServiceListener
      * @return a iterator of ComponentHolder, or an empty iterator if no ComponentHolders
      * are found
      */
-    public final Iterator getComponentHoldersByPid(String pid)
+    public final Iterator<ComponentHolder> getComponentHoldersByPid(String pid)
     {
-        Set componentHoldersUsingPid = new HashSet();
+        Set<ComponentHolder> componentHoldersUsingPid = new HashSet<ComponentHolder>();
         synchronized (m_componentHoldersByPid)
         {
-            Set set = (Set) m_componentHoldersByPid.get(pid);
+            Set<ComponentHolder> set = m_componentHoldersByPid.get(pid);
             // only return the entry if non-null and not a reservation
             if (set != null)
             {
@@ -465,11 +470,11 @@ public class ComponentRegistry implements ScrService, ServiceListener
      * name reservations or {@link ComponentHolder} instances for actual
      * holders of components.
      */
-    private Object[] getComponentHolders()
+    private ComponentHolder[] getComponentHolders()
     {
         synchronized ( m_componentHoldersByName )
         {
-            return m_componentHoldersByName.values().toArray();
+            return m_componentHoldersByName.values().toArray( new ComponentHolder[ m_componentHoldersByName.size() ]);
         }
     }
 
@@ -494,17 +499,17 @@ public class ComponentRegistry implements ScrService, ServiceListener
      */
     final void unregisterComponentHolder( final ComponentRegistryKey key )
     {
-        Object component;
+        ComponentHolder component;
         synchronized ( m_componentHoldersByName )
         {
             component = m_componentHoldersByName.remove( key );
         }
 
-        if (component instanceof ComponentHolder) {
+        if (component != null) {
             synchronized (m_componentHoldersByPid)
             {
-                String configurationPid = ((ComponentHolder) component).getComponentMetadata().getConfigurationPid();
-                Set componentsForPid = (Set) m_componentHoldersByPid.get(configurationPid);
+                String configurationPid = component.getComponentMetadata().getConfigurationPid();
+                Set<ComponentHolder> componentsForPid = m_componentHoldersByPid.get(configurationPid);
                 if (componentsForPid != null)
                 {
                     componentsForPid.remove(component);
@@ -655,7 +660,7 @@ public class ComponentRegistry implements ScrService, ServiceListener
 
     public void missingServicePresent( final ServiceReference serviceReference, ComponentActorThread actor )
     {
-        final List dependencyManagers = ( List ) m_missingDependencies.remove( serviceReference );
+        final List<DependencyManager> dependencyManagers = m_missingDependencies.remove( serviceReference );
         if ( dependencyManagers != null )
         {
             actor.schedule( new Runnable()
@@ -663,9 +668,8 @@ public class ComponentRegistry implements ScrService, ServiceListener
 
                 public void run()
                 {
-                    for ( Iterator i = dependencyManagers.iterator(); i.hasNext(); )
+                    for ( DependencyManager dm : dependencyManagers )
                     {
-                        DependencyManager dm = ( DependencyManager ) i.next();
                         dm.invokeBindMethodLate( serviceReference );
                     }
                 }
@@ -680,10 +684,10 @@ public class ComponentRegistry implements ScrService, ServiceListener
         {
             return;
         }
-        List dependencyManagers = ( List ) m_missingDependencies.get( serviceReference );
+        List<DependencyManager> dependencyManagers = m_missingDependencies.get( serviceReference );
         if ( dependencyManagers == null )
         {
-            dependencyManagers = new ArrayList();
+            dependencyManagers = new ArrayList<DependencyManager>();
             m_missingDependencies.put( serviceReference, dependencyManagers );
         }
         dependencyManagers.add( dependencyManager );
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/ScrCommand.java b/scr/src/main/java/org/apache/felix/scr/impl/ScrCommand.java
index b81c537bc2..4cdf823a53 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/ScrCommand.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/ScrCommand.java
@@ -167,14 +167,14 @@ class ScrCommand
         }
 
         out.println("   Id   State          Name");
-        for (int i = 0; i < components.length; i++)
+        for ( Component component : components )
         {
-            out.print('[');
-            out.print(pad(String.valueOf(components[i].getId()), -4));
-            out.print("] [");
-            out.print(pad(toStateString(components[i].getState()), 13));
-            out.print("] ");
-            out.print(components[i].getName());
+            out.print( '[' );
+            out.print( pad( String.valueOf( component.getId() ), -4 ) );
+            out.print( "] [" );
+            out.print( pad( toStateString( component.getState() ), 13 ) );
+            out.print( "] " );
+            out.print( component.getName() );
             out.println();
         }
     }
@@ -187,131 +187,131 @@ class ScrCommand
             return;
         }
 
-        for (int j = 0; j < components.length; j++)
+        for ( Component component : components )
         {
-            Component component = components[j];
-            out.print("ID: ");
-            out.println(component.getId());
-            out.print("Name: ");
-            out.println(component.getName());
-            out.print("Bundle: ");
-            out.println(component.getBundle().getSymbolicName() + " (" + component.getBundle().getBundleId() + ")");
-            out.print("State: ");
-            out.println(toStateString(component.getState()));
-            out.print("Default State: ");
-            out.println(component.isDefaultEnabled() ? "enabled" : "disabled");
-            out.print("Activation: ");
-            out.println(component.isImmediate() ? "immediate" : "delayed");
+            out.print( "ID: " );
+            out.println( component.getId() );
+            out.print( "Name: " );
+            out.println( component.getName() );
+            out.print( "Bundle: " );
+            out.println( component.getBundle().getSymbolicName() + " (" + component.getBundle().getBundleId() + ")" );
+            out.print( "State: " );
+            out.println( toStateString( component.getState() ) );
+            out.print( "Default State: " );
+            out.println( component.isDefaultEnabled() ? "enabled" : "disabled" );
+            out.print( "Activation: " );
+            out.println( component.isImmediate() ? "immediate" : "delayed" );
 
             // DS 1.1 new features
-            out.print("Configuration Policy: ");
-            out.println(component.getConfigurationPolicy());
-            out.print("Activate Method: ");
-            out.print(component.getActivate());
-            if (component.isActivateDeclared())
+            out.print( "Configuration Policy: " );
+            out.println( component.getConfigurationPolicy() );
+            out.print( "Activate Method: " );
+            out.print( component.getActivate() );
+            if ( component.isActivateDeclared() )
             {
-                out.print(" (declared in the descriptor)");
+                out.print( " (declared in the descriptor)" );
             }
             out.println();
-            out.print("Deactivate Method: ");
-            out.print(component.getDeactivate());
-            if (component.isDeactivateDeclared())
+            out.print( "Deactivate Method: " );
+            out.print( component.getDeactivate() );
+            if ( component.isDeactivateDeclared() )
             {
-                out.print(" (declared in the descriptor)");
+                out.print( " (declared in the descriptor)" );
             }
             out.println();
-            out.print("Modified Method: ");
-            if (component.getModified() != null)
+            out.print( "Modified Method: " );
+            if ( component.getModified() != null )
             {
-                out.print(component.getModified());
+                out.print( component.getModified() );
             }
             else
             {
-                out.print("-");
+                out.print( "-" );
             }
             out.println();
 
-            out.print("Configuration Pid: ");
-            out.print(component.getConfigurationPid());
-            if (component.isConfigurationPidDeclared())
+            out.print( "Configuration Pid: " );
+            out.print( component.getConfigurationPid() );
+            if ( component.isConfigurationPidDeclared() )
             {
-                out.print(" (declared in the descriptor)");
+                out.print( " (declared in the descriptor)" );
             }
             out.println();
 
-            if (component.getFactory() != null)
+            if ( component.getFactory() != null )
             {
-                out.print("Factory: ");
-                out.println(component.getFactory());
+                out.print( "Factory: " );
+                out.println( component.getFactory() );
             }
 
             String[] services = component.getServices();
-            if (services != null)
+            if ( services != null )
             {
-                out.print("Services: ");
-                out.println(services[0]);
-                for (int i = 1; i < services.length; i++)
+                out.print( "Services: " );
+                out.println( services[0] );
+                for ( int i = 1; i < services.length; i++ )
                 {
-                    out.print("          ");
-                    out.println(services[i]);
+                    out.print( "          " );
+                    out.println( services[i] );
                 }
-                out.print("Service Type: ");
-                out.println(component.isServiceFactory() ? "service factory" : "service");
+                out.print( "Service Type: " );
+                out.println( component.isServiceFactory() ? "service factory" : "service" );
             }
 
             Reference[] refs = component.getReferences();
-            if (refs != null)
+            if ( refs != null )
             {
-                for (int i = 0; i < refs.length; i++)
+                for ( Reference ref : refs )
                 {
-                    out.print("Reference: ");
-                    out.println(refs[i].getName());
-                    out.print("    Satisfied: ");
-                    out.println(refs[i].isSatisfied() ? "satisfied" : "unsatisfied");
-                    out.print("    Service Name: ");
-                    out.println(refs[i].getServiceName());
-                    if (refs[i].getTarget() != null)
+                    out.print( "Reference: " );
+                    out.println( ref.getName() );
+                    out.print( "    Satisfied: " );
+                    out.println( ref.isSatisfied() ? "satisfied" : "unsatisfied" );
+                    out.print( "    Service Name: " );
+                    out.println( ref.getServiceName() );
+                    if ( ref.getTarget() != null )
                     {
-                        out.print("    Target Filter: ");
-                        out.println(refs[i].getTarget());
+                        out.print( "    Target Filter: " );
+                        out.println( ref.getTarget() );
                     }
-                    out.print("    Multiple: ");
-                    out.println(refs[i].isMultiple() ? "multiple" : "single");
-                    out.print("    Optional: ");
-                    out.println(refs[i].isOptional() ? "optional" : "mandatory");
-                    out.print("    Policy: ");
-                    out.println(refs[i].isStatic() ? "static" : "dynamic");
-                    out.print("    Policy option: ");
-                    out.println(refs[i].isReluctant() ? "reluctant" : "greedy");
-                    ServiceReference[] serviceRefs = refs[i].getBoundServiceReferences();
-                    if (serviceRefs != null) {
-                        out.print("    Bound to:");
-                        for (int k = 0; k< serviceRefs.length; k++) {
-                            out.print("        " );
-                            out.println(serviceRefs[k]);
+                    out.print( "    Multiple: " );
+                    out.println( ref.isMultiple() ? "multiple" : "single" );
+                    out.print( "    Optional: " );
+                    out.println( ref.isOptional() ? "optional" : "mandatory" );
+                    out.print( "    Policy: " );
+                    out.println( ref.isStatic() ? "static" : "dynamic" );
+                    out.print( "    Policy option: " );
+                    out.println( ref.isReluctant() ? "reluctant" : "greedy" );
+                    ServiceReference[] serviceRefs = ref.getBoundServiceReferences();
+                    if ( serviceRefs != null )
+                    {
+                        out.print( "    Bound to:" );
+                        for ( int k = 0; k < serviceRefs.length; k++ )
+                        {
+                            out.print( "        " );
+                            out.println( serviceRefs[k] );
                         }
                     }
                 }
             }
 
             Dictionary props = component.getProperties();
-            if (props != null)
+            if ( props != null )
             {
-                out.println("Properties:");
-                TreeSet keys = new TreeSet(Collections.list(props.keys()));
-                for (Iterator ki = keys.iterator(); ki.hasNext();)
+                out.println( "Properties:" );
+                TreeSet keys = new TreeSet( Collections.list( props.keys() ) );
+                for ( Object key : keys )
                 {
-                    Object key = ki.next();
-                    out.print("    ");
-                    out.print(key);
-                    out.print(" = ");
+                    out.print( "    " );
+                    out.print( key );
+                    out.print( " = " );
 
-                    Object prop = props.get(key);
-                    if (prop.getClass().isArray())
+                    Object prop = props.get( key );
+                    if ( prop.getClass().isArray() )
                     {
-                        prop = Arrays.asList((Object[]) prop);
+                        prop = Arrays.asList( ( Object[] ) prop );
                     }
-                    out.print(prop);
+                    out.print( prop );
 
                     out.println();
                 }
@@ -327,35 +327,34 @@ class ScrCommand
             return;
         }
 
-        for (int i = 0; i < components.length; i++)
+        for ( Component component : components )
         {
-            Component component = components[i];
-            if (component.getState() == Component.STATE_DISPOSED)
+            if ( component.getState() == Component.STATE_DISPOSED )
             {
-                err.println("Component " + component.getName() + " already disposed, cannot change state");
+                err.println( "Component " + component.getName() + " already disposed, cannot change state" );
             }
-            else if (enable)
+            else if ( enable )
             {
-                if (component.getState() == Component.STATE_DISABLED)
+                if ( component.getState() == Component.STATE_DISABLED )
                 {
                     component.enable();
-                    out.println("Component " + component.getName() + " enabled");
+                    out.println( "Component " + component.getName() + " enabled" );
                 }
                 else
                 {
-                    out.println("Component " + component.getName() + " already enabled");
+                    out.println( "Component " + component.getName() + " already enabled" );
                 }
             }
             else
             {
-                if (component.getState() != Component.STATE_DISABLED)
+                if ( component.getState() != Component.STATE_DISABLED )
                 {
                     component.disable();
-                    out.println("Component " + component.getName() + " disabled");
+                    out.println( "Component " + component.getName() + " disabled" );
                 }
                 else
                 {
-                    out.println("Component " + component.getName() + " already disabled");
+                    out.println( "Component " + component.getName() + " already disabled" );
                 }
             }
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/config/ComponentHolder.java b/scr/src/main/java/org/apache/felix/scr/impl/config/ComponentHolder.java
index 530606f25d..21cbf0a877 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/config/ComponentHolder.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/config/ComponentHolder.java
@@ -68,7 +68,7 @@ public interface ComponentHolder
      *
      * @param pid The PID of the configuration used to configure the component
      */
-    void configurationUpdated( String pid, Dictionary props );
+    void configurationUpdated( String pid, Dictionary<String, Object> props );
 
     /**
      * Returns all <code>Component</code> instances held by this holder.
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/helper/MethodResult.java b/scr/src/main/java/org/apache/felix/scr/impl/helper/MethodResult.java
index 4262c4c14e..87d1c72b2f 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/helper/MethodResult.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/helper/MethodResult.java
@@ -41,11 +41,11 @@ public class MethodResult
     /**
      * The actual result from the method, which may be <code>null</code>.
      */
-    private final Map result;
+    private final Map<String, Object> result;
 
     private final boolean hasResult;
 
-    MethodResult(final boolean hasResult, final Map result)
+    MethodResult(final boolean hasResult, final Map<String, Object> result)
     {
         this.hasResult = hasResult;
         this.result = result;
@@ -56,7 +56,7 @@ public class MethodResult
         return hasResult;
     }
 
-    public Map getResult()
+    public Map<String, Object> getResult()
     {
         return result;
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index dac31af2d3..2c44b5cbd3 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -35,6 +35,7 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReentrantLock;
 
+import com.sun.xml.internal.rngom.binary.DataExceptPattern;
 import org.apache.felix.scr.Component;
 import org.apache.felix.scr.Reference;
 import org.apache.felix.scr.impl.BundleComponentActivator;
@@ -59,7 +60,7 @@ import org.osgi.service.log.LogService;
  * implementation object's lifecycle.
  *
  */
-public abstract class AbstractComponentManager implements Component, SimpleLogger
+public abstract class AbstractComponentManager<S> implements Component, SimpleLogger
 {
 
     // the ID of this component
@@ -76,27 +77,22 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     private final ComponentMethods m_componentMethods;
 
     // The dependency managers that manage every dependency
-    private final List m_dependencyManagers;
+    private final List<DependencyManager> m_dependencyManagers;
 
     private boolean m_dependencyManagersInitialized;
 
-    //<Map<DependencyManager, Map<ServiceReference, RefPair>>>
-    private final AtomicReference m_dependencies_map;
+    private final AtomicReference<Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>>> m_dependencies_map;
 
     // A reference to the BundleComponentActivator
     private BundleComponentActivator m_activator;
 
     // The ServiceRegistration
-    private final AtomicReference m_serviceRegistration;
+    private final AtomicReference<ServiceRegistration<S>> m_serviceRegistration;
 
     private final ReentrantLock m_stateLock;
 
     private long m_timeout = 5000;
 
-//    private Thread lockingThread;
-//    private Throwable lockingStackTrace;
-//    private ArrayList lockingActivity = new ArrayList( );
-
     protected volatile boolean enabled;
     protected volatile CountDownLatch enabledLatch;
     private final Object enabledLatchLock = new Object();
@@ -125,8 +121,8 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         m_dependencyManagers = loadDependencyManagers( metadata );
 
         m_stateLock = new ReentrantLock( true );
-        m_dependencies_map = new AtomicReference();
-        m_serviceRegistration = new AtomicReference();
+        m_dependencies_map = new AtomicReference<Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>>>();
+        m_serviceRegistration = new AtomicReference<ServiceRegistration<S>>();
 
         // dump component details
         if ( isLogEnabled( LogService.LOG_DEBUG ) )
@@ -158,19 +154,12 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
 
     final void obtainWriteLock( String source )
     {
-//        if ( isLogEnabled( LogService.LOG_DEBUG ) )
-//        {
-//            lockingActivity.add( "obtainWriteLock from: " +  source + " readLocks: " + m_stateLock.getReadHoldCount() + " writeLocks: " + m_stateLock.getWriteHoldCount() + " thread: " + Thread.currentThread() + " time: " + System.currentTimeMillis());
-//        }
         try
         {
             if (!m_stateLock.tryLock( m_timeout, TimeUnit.MILLISECONDS ) )
             {
-//                lockingActivity.add( "obtainWriteLock failure from: " +  source + " readLocks: " + m_stateLock.getReadHoldCount() + " writeLocks: " + m_stateLock.getWriteHoldCount() + " thread: " + Thread.currentThread() + " time: " + System.currentTimeMillis() + " Could not obtain write lock.");
                 throw new IllegalStateException( "Could not obtain lock" );
             }
-//            lockingThread = Thread.currentThread();
-//            lockingStackTrace = new Exception("Write lock stack trace for thread: " + lockingThread);
         }
         catch ( InterruptedException e )
         {
@@ -181,13 +170,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
 
     final void releaseWriteLock( String source )
     {
-//        if ( isLogEnabled( LogService.LOG_DEBUG ) )
-//        {
-//            lockingActivity.add( "deescalateLock from: " +  source + " readLocks: " + m_stateLock.getReadHoldCount() + " writeLocks: " + m_stateLock.getWriteHoldCount() + " thread: " + Thread.currentThread() + " time: " + System.currentTimeMillis());
-//        }
         m_stateLock.unlock();
-//        lockingThread = null;
-//        lockingStackTrace = null;
     }
 
     final boolean isWriteLocked()
@@ -649,13 +632,13 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     {
         synchronized ( m_serviceRegistration )
         {
-            ServiceRegistration existing = ( ServiceRegistration ) m_serviceRegistration.get();
+            ServiceRegistration existing = m_serviceRegistration.get();
             if ( existing == null )
             {
                 log( LogService.LOG_DEBUG, "registering services", null );
 
                 // get a copy of the component properties as service properties
-                final Dictionary serviceProperties = getServiceProperties();
+                final Dictionary<String, Object> serviceProperties = getServiceProperties();
 
                 ServiceRegistration newRegistration = getActivator().getBundleContext().registerService(
                         provides,
@@ -694,7 +677,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         {
             synchronized ( m_serviceRegistration )
             {
-                ServiceRegistration sr = ( ServiceRegistration ) m_serviceRegistration.get();
+                ServiceRegistration sr = m_serviceRegistration.get();
 
                 if ( sr != null && m_serviceRegistration.compareAndSet( sr, null ) )
                 {
@@ -719,7 +702,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         {
             return true;
         }
-        Class implementationObjectClass;
+        Class<?> implementationObjectClass;
         try
         {
             implementationObjectClass = getActivator().getBundleContext().getBundle().loadClass(
@@ -732,10 +715,8 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         }
         m_componentMethods.initComponentMethods( this, m_componentMetadata, implementationObjectClass );
 
-        for (Iterator it = m_dependencyManagers.iterator(); it.hasNext(); )
+        for ( DependencyManager dependencyManager : m_dependencyManagers )
         {
-            DependencyManager dependencyManager = ( DependencyManager ) it.next();
-
             dependencyManager.initBindingMethods( m_componentMethods.getBindMethods( dependencyManager.getName() ) );
         }
         m_dependencyManagersInitialized = true;
@@ -753,19 +734,17 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
      */
     protected boolean collectDependencies() throws IllegalStateException
     {
-        Map old = ( Map ) m_dependencies_map.get();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> old = m_dependencies_map.get();
         if ( old != null)
         {
             log( LogService.LOG_DEBUG, "dependency map already present, do not collect dependencies", null );
             return false;
         }
         initDependencyManagers();
-        Map newDeps = new HashMap( );//<DependencyManager, Map<ServiceReference, RefPair>
-        for (Iterator it = m_dependencyManagers.iterator(); it.hasNext(); )
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> newDeps = new HashMap<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>>( );
+        for ( DependencyManager dependencyManager : m_dependencyManagers )
         {
-            DependencyManager dependencyManager = ( DependencyManager ) it.next();
-
-            if (!dependencyManager.prebind( newDeps) )
+            if ( !dependencyManager.prebind( newDeps ) )
             {
                 //not actually satisfied any longer
                 returnServices( newDeps );
@@ -784,7 +763,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         return true;
     }
 
-    protected boolean setDependencyMap( Map old, Map newDeps )
+    protected boolean setDependencyMap( Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> old, Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> newDeps )
     {
         return m_dependencies_map.compareAndSet( old, newDeps );
     }
@@ -794,35 +773,33 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         m_dependencies_map.set( null );
     }
 
-    private void returnServices( Map deps )
+    private void returnServices( Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> deps )
     {
-         for (Iterator it = deps.values().iterator(); it.hasNext(); )
-         {
-             Map refs = ( Map ) it.next();
-             if ( refs != null )
-             {
-                 for (Iterator ri = refs.entrySet().iterator(); ri.hasNext(); )
-                 {
-                     Map.Entry entry = ( Map.Entry ) ri.next();
-                     RefPair args = ( RefPair ) entry.getValue();
-                     if ( args.getServiceObject() != null )
-                     {
-                         getActivator().getBundleContext().ungetService( (ServiceReference) entry.getKey() );
-                     }
-                 }
-             }
-         }
+        for ( Map<ServiceReference<?>, RefPair<?>> refs : deps.values() )
+        {
+            if ( refs != null )
+            {
+                for ( Map.Entry<ServiceReference<?>, RefPair<?>> serviceReferenceRefPairEntry : refs.entrySet() )
+                {
+                    RefPair<?> args = serviceReferenceRefPairEntry.getValue();
+                    if ( args.getServiceObject() != null )
+                    {
+                        getActivator().getBundleContext().ungetService( serviceReferenceRefPairEntry.getKey() );
+                    }
+                }
+            }
+        }
     }
 
-    abstract void update( DependencyManager dependencyManager, ServiceReference ref );
+    abstract <T> void update( DependencyManager<S, T> dependencyManager, ServiceReference<T> ref );
 
-    abstract void invokeBindMethod( DependencyManager dependencyManager, ServiceReference reference );
+    abstract <T> void invokeBindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> reference );
 
-    abstract void invokeUnbindMethod( DependencyManager dependencyManager, ServiceReference oldRef );
+    abstract <T> void invokeUnbindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> oldRef );
 
-    Map getDependencyMap()
+    Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> getDependencyMap()
     {
-        return ( Map ) m_dependencies_map.get();
+        return m_dependencies_map.get();
     }
 
     //**********************************************************************************************************
@@ -839,9 +816,9 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     }
 
 
-    final ServiceRegistration getServiceRegistration()
+    final ServiceRegistration<?> getServiceRegistration()
     {
-        return ( ServiceRegistration ) m_serviceRegistration.get();
+        return m_serviceRegistration.get();
     }
 
 
@@ -857,13 +834,6 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         m_dependencyManagers.clear();
     }
 
-    //<DependencyManager, Map<ServiceReference, RefPair>>
-    protected Map getParameterMap()
-    {
-        return ( Map ) m_dependencies_map.get();
-    }
-
-
     /**
      * Returns <code>true</code> if logging for the given level is enabled.
      */
@@ -917,13 +887,13 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
                 if ( services != null && services.length > 0 )
                 {
                     final Bundle bundle = getBundle();
-                    for ( int i = 0; i < services.length; i++ )
+                    for ( String service : services )
                     {
-                        final Permission perm = new ServicePermission( services[i], ServicePermission.REGISTER );
+                        final Permission perm = new ServicePermission( service, ServicePermission.REGISTER );
                         if ( !bundle.hasPermission( perm ) )
                         {
                             log( LogService.LOG_DEBUG, "Permission to register service {0} is denied", new Object[]
-                                { services[i] }, null );
+                                    {service}, null );
                             allowed = false;
                         }
                     }
@@ -936,19 +906,15 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     }
 
 
-    private List loadDependencyManagers( ComponentMetadata metadata )
+    private List<DependencyManager> loadDependencyManagers( ComponentMetadata metadata )
     {
-        List depMgrList = new ArrayList(metadata.getDependencies().size());
+        List<DependencyManager> depMgrList = new ArrayList<DependencyManager>(metadata.getDependencies().size());
 
         // If this component has got dependencies, create dependency managers for each one of them.
         if ( metadata.getDependencies().size() != 0 )
         {
-            Iterator dependencyit = metadata.getDependencies().iterator();
-
-            while ( dependencyit.hasNext() )
+            for ( ReferenceMetadata currentdependency: metadata.getDependencies() )
             {
-                ReferenceMetadata currentdependency = (ReferenceMetadata) dependencyit.next();
-
                 DependencyManager depmanager = new DependencyManager( this, currentdependency );
 
                 depMgrList.add( depmanager );
@@ -962,10 +928,8 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     {
         if ( !m_componentMetadata.isConfigurationRequired() )
         {
-            Iterator it = getDependencyManagers();
-            while ( it.hasNext() )
+            for ( DependencyManager dm: getDependencyManagers() )
             {
-                DependencyManager dm = (DependencyManager) it.next();
                 dm.enable();
             }
         }
@@ -973,10 +937,9 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
 
     protected void updateTargets(Dictionary properties)
     {
-        for (Object o: m_dependencyManagers)
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dependencyManager = ( DependencyManager ) o;
-            dependencyManager.setTargetFilter( properties );
+            dm.setTargetFilter( properties );
         }
     }
 
@@ -985,10 +948,8 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         // indicates whether all dependencies are satisfied
         boolean satisfied = true;
 
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dm = ( DependencyManager ) it.next();
 
             if ( !dm.hasGetPermission() )
             {
@@ -1023,29 +984,27 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
      * Returns an iterator over the {@link DependencyManager} objects
      * representing the declared references in declaration order
      */
-    Iterator getDependencyManagers()
+    List<DependencyManager> getDependencyManagers()
     {
-        return m_dependencyManagers.iterator();
+        return m_dependencyManagers;
     }
 
     /**
      * Returns an iterator over the {@link DependencyManager} objects
      * representing the declared references in reversed declaration order
      */
-    Iterator getReversedDependencyManagers()
+    List<DependencyManager> getReversedDependencyManagers()
     {
         List list = new ArrayList( m_dependencyManagers );
         Collections.reverse( list );
-        return list.iterator();
+        return list;
     }
 
 
     DependencyManager getDependencyManager(String name)
     {
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dm = (DependencyManager) it.next();
             if ( name.equals(dm.getName()) )
             {
                 return dm;
@@ -1058,29 +1017,25 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
 
     private void deactivateDependencyManagers()
     {
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dm = (DependencyManager) it.next();
             dm.deactivate();
         }
     }
 
     private void disableDependencyManagers()
     {
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dm = (DependencyManager) it.next();
             dm.unregisterServiceListener();
         }
     }
 
     public abstract boolean hasConfiguration();
 
-    public abstract Dictionary getProperties();
+    public abstract Dictionary<String, Object> getProperties();
 
-    public abstract void setServiceProperties( Dictionary serviceProperties );
+    public abstract void setServiceProperties( Dictionary<String, Object> serviceProperties );
 
     /**
      * Returns the subset of component properties to be used as service
@@ -1088,7 +1043,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
      * name does not start with dot (.), properties which are considered
      * private.
      */
-    public Dictionary getServiceProperties()
+    public Dictionary<String, Object> getServiceProperties()
     {
         return copyTo( null, getProperties(), false );
     }
@@ -1107,7 +1062,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
      *      <code>source</code> is <code>null</code> or empty and
      *      <code>target</code> was <code>null</code>.
      */
-    protected static Dictionary copyTo( Dictionary target, Dictionary source )
+    protected static Dictionary<String, Object> copyTo( Dictionary<String, Object> target, Dictionary<String, Object> source )
     {
         return copyTo( target, source, true );
     }
@@ -1131,11 +1086,11 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
      *         <code>target</code> was <code>null</code> or all properties are
      *         private and had not to be copied
      */
-    protected static Dictionary copyTo( Dictionary target, final Dictionary source, final boolean allProps )
+    protected static Dictionary<String, Object> copyTo( Dictionary<String, Object> target, final Dictionary<String, Object> source, final boolean allProps )
     {
         if ( target == null )
         {
-            target = new Hashtable();
+            target = new Hashtable<String, Object>();
         }
 
         if ( source != null && !source.isEmpty() )
@@ -1187,7 +1142,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
     {
         if ( methodResult.hasResult() )
         {
-            Dictionary serviceProps = ( methodResult.getResult() == null) ? null : new Hashtable( methodResult.getResult() );
+            Dictionary<String, Object> serviceProps = ( methodResult.getResult() == null) ? null : new Hashtable<String, Object>( methodResult.getResult() );
             setServiceProperties(serviceProps );
         }
     }
@@ -1239,7 +1194,7 @@ public abstract class AbstractComponentManager implements Component, SimpleLogge
         }
 
 
-        ServiceReference getServiceReference( AbstractComponentManager acm )
+        ServiceReference<?> getServiceReference( AbstractComponentManager acm )
         {
             throw new IllegalStateException("getServiceReference" + this);
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
index 5532fb5ff3..27c3bb4cdc 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
@@ -58,7 +58,7 @@ import org.osgi.service.log.LogService;
  * with earlier releases of the Apache Felix Declarative Services implementation.
  * But keep in mind, that this is non-standard behaviour.
  */
-public class ComponentFactoryImpl extends AbstractComponentManager implements ComponentFactory, ComponentHolder
+public class ComponentFactoryImpl<S> extends AbstractComponentManager<S> implements ComponentFactory, ComponentHolder
 {
 
     /**
@@ -71,14 +71,14 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
      * entry is the same as the entry's key.
      * This is an IdentityHashMap for speed, thus not a Set.
      */
-    private final Map m_componentInstances;
+    private final Map<ImmediateComponentManager, ImmediateComponentManager> m_componentInstances;
 
     /**
      * The configuration for the component factory. This configuration is
      * supplied as the base configuration for each component instance created
      * by the {@link #newInstance(Dictionary)} method.
      */
-    private volatile Dictionary m_configuration;
+    private volatile Dictionary<String, Object> m_configuration;
     
     /**
      * Flag telling if our component factory is configured from config admin.
@@ -90,8 +90,8 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
     public ComponentFactoryImpl( BundleComponentActivator activator, ComponentMetadata metadata )
     {
         super( activator, metadata, new ComponentMethods() );
-        m_componentInstances = new IdentityHashMap();
-        m_configuration = new Hashtable();
+        m_componentInstances = new IdentityHashMap<ImmediateComponentManager, ImmediateComponentManager>();
+        m_configuration = new Hashtable<String, Object>();
     }
 
 
@@ -204,15 +204,14 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
     }
 
 
-    public Dictionary getProperties()
+    public Dictionary<String, Object> getProperties()
     {
-        Dictionary props = getServiceProperties();
+        Dictionary<String, Object> props = getServiceProperties();
 
         // add target properties of references
-        List depMetaData = getComponentMetadata().getDependencies();
-        for ( Iterator di = depMetaData.iterator(); di.hasNext(); )
+        List<ReferenceMetadata> depMetaData = getComponentMetadata().getDependencies();
+        for ( ReferenceMetadata rm : depMetaData )
         {
-            ReferenceMetadata rm = ( ReferenceMetadata ) di.next();
             if ( rm.getTarget() != null )
             {
                 props.put( rm.getTargetPropertyName(), rm.getTarget() );
@@ -220,9 +219,9 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
         }
 
         // add target properties from configuration (if we have one)        
-        for ( Object key : Collections.list( m_configuration.keys() ) )
+        for ( String key : Collections.list( m_configuration.keys() ) )
         {
-            if ( key.toString().endsWith( ".target" ) )
+            if ( key.endsWith( ".target" ) )
             {
                 props.put( key, m_configuration.get( key ) );
             }
@@ -237,9 +236,9 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
     }
 
 
-    public Dictionary getServiceProperties()
+    public Dictionary<String, Object> getServiceProperties()
     {
-        Dictionary props = new Hashtable();
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
 
         // 112.5.5 The Component Factory service must register with the following properties
         props.put( ComponentConstants.COMPONENT_NAME, getComponentMetadata().getName() );
@@ -268,28 +267,28 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
 
     protected boolean collectDependencies()
     {
-        Map old = getDependencyMap();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> old = getDependencyMap();
         if ( old == null )
         {
-            Map dependenciesMap = new HashMap();
-            for (Iterator i = getDependencyManagers(); i.hasNext(); )
+            Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependenciesMap = new HashMap<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>>();
+            for (DependencyManager dm: getDependencyManagers() )
             {
-                dependenciesMap.put( i.next(), Collections.EMPTY_MAP );
+                dependenciesMap.put( dm, Collections.EMPTY_MAP );
             }
             setDependencyMap( old, dependenciesMap );
         }
         return true;
     }
 
-    void update( DependencyManager dependencyManager, ServiceReference ref )
+    <T> void update( DependencyManager<S, T> dependencyManager, ServiceReference<T> ref )
     {
     }
 
-    void invokeBindMethod( DependencyManager dependencyManager, ServiceReference reference )
+    <T> void invokeBindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> reference )
     {
     }
 
-    void invokeUnbindMethod( DependencyManager dependencyManager, ServiceReference oldRef )
+    <T> void invokeUnbindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> oldRef )
     {
     }
 
@@ -340,7 +339,7 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
     }
 
 
-    public void configurationUpdated( String pid, Dictionary configuration )
+    public void configurationUpdated( String pid, Dictionary<String, Object> configuration )
     {
         if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )
         {
@@ -399,13 +398,13 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
 
     public Component[] getComponents()
     {
-        List cms = getComponentList();
-        return (Component[]) cms.toArray( new Component[ cms.size() ] );
+        List<AbstractComponentManager> cms = getComponentList();
+        return cms.toArray( new Component[ cms.size() ] );
     }
 
-    protected List getComponentList()
+    protected List<AbstractComponentManager> getComponentList()
     {
-        List cms = new ArrayList( );
+        List<AbstractComponentManager> cms = new ArrayList<AbstractComponentManager>( );
         cms.add( this );
         getComponentManagers( m_componentInstances, cms );
         return cms;
@@ -440,11 +439,11 @@ public class ComponentFactoryImpl extends AbstractComponentManager implements Co
      */
     public void disposeComponents( int reason )
     {
-        List cms = new ArrayList( );
+        List<AbstractComponentManager> cms = new ArrayList<AbstractComponentManager>( );
         getComponentManagers( m_componentInstances, cms );
-        for ( Iterator i = cms.iterator(); i.hasNext(); )
+        for ( AbstractComponentManager acm: cms )
         {
-            ((AbstractComponentManager)i.next()).dispose( reason );
+            acm.dispose( reason );
         }
 
         synchronized ( m_componentInstances )
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
index ba7c25f7d8..02008c99a8 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ConfigurationComponentFactoryImpl.java
@@ -48,7 +48,7 @@ import org.osgi.service.log.LogService;
  * with earlier releases of the Apache Felix Declarative Services implementation.
  * But keep in mind, that this is non-standard behaviour.
  */
-public class ConfigurationComponentFactoryImpl extends ComponentFactoryImpl implements ComponentHolder
+public class ConfigurationComponentFactoryImpl<S> extends ComponentFactoryImpl<S> implements ComponentHolder
 {
 
     /**
@@ -132,7 +132,7 @@ public class ConfigurationComponentFactoryImpl extends ComponentFactoryImpl impl
     }
 
 
-    public void configurationUpdated( String pid, Dictionary configuration )
+    public void configurationUpdated( String pid, Dictionary<String, Object> configuration )
     {
         if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )
         {
@@ -199,11 +199,11 @@ public class ConfigurationComponentFactoryImpl extends ComponentFactoryImpl impl
     {
         super.disposeComponents( reason );
 
-        List cms = new ArrayList( );
+        List<AbstractComponentManager> cms = new ArrayList<AbstractComponentManager>( );
         getComponentManagers( m_configuredServices, cms );
-        for ( Iterator i = cms.iterator(); i.hasNext(); )
+        for ( AbstractComponentManager acm: cms )
         {
-            ((AbstractComponentManager)i.next()).dispose( reason );
+            acm.dispose( reason );
         }
 
         m_configuredServices = null;
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DelayedComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DelayedComponentManager.java
index 46aa4486ec..d87bae0150 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DelayedComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DelayedComponentManager.java
@@ -26,7 +26,7 @@ import org.apache.felix.scr.impl.metadata.ComponentMetadata;
 
 
 /**
- * The <code>DelayedComponentManager</code> TODO
+ * The <code>DelayedComponentManager</code> marker class.  Needed?
  */
 public class DelayedComponentManager extends ImmediateComponentManager
 {
@@ -42,10 +42,4 @@ public class DelayedComponentManager extends ImmediateComponentManager
         super( activator, componentHolder, metadata, componentMethods );
     }
 
-
-//    State getSatisfiedState()
-//    {
-//        return Registered.getInstance();
-//    }
-
 }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 2de96c88c5..ed5c445bca 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -53,14 +53,14 @@ import org.osgi.service.log.LogService;
  * declared by a single <code>&lt;reference&gt;</code element in component
  * descriptor.
  */
-public class DependencyManager implements ServiceListener, Reference
+public class DependencyManager<S, T> implements ServiceListener, Reference
 {
     // mask of states ok to send events
     private static final int STATE_MASK = //Component.STATE_UNSATISFIED |
          Component.STATE_ACTIVE | Component.STATE_REGISTERED | Component.STATE_FACTORY;
 
     // the component to which this dependency belongs
-    private final AbstractComponentManager m_componentManager;
+    private final AbstractComponentManager<S> m_componentManager;
 
     // Reference to the metadata
     private final ReferenceMetadata m_dependencyMetadata;
@@ -77,8 +77,8 @@ public class DependencyManager implements ServiceListener, Reference
     private volatile Filter m_targetFilter;
 
     private final Object enableLock = new Object();
-    private final Collection<ServiceReference> added = new ArrayList<ServiceReference>();
-    private final Collection<ServiceReference> removed = new ArrayList<ServiceReference>();
+    private final Collection<ServiceReference<T>> added = new ArrayList<ServiceReference<T>>();
+    private final Collection<ServiceReference<T>> removed = new ArrayList<ServiceReference<T>>();
 
     private boolean registered;
 
@@ -88,7 +88,7 @@ public class DependencyManager implements ServiceListener, Reference
      *
      * @param dependency An object that contains data about the dependency
      */
-    DependencyManager( AbstractComponentManager componentManager, ReferenceMetadata dependency )
+    DependencyManager( AbstractComponentManager<S> componentManager, ReferenceMetadata dependency )
     {
         m_componentManager = componentManager;
         m_dependencyMetadata = dependency;
@@ -124,10 +124,10 @@ public class DependencyManager implements ServiceListener, Reference
      */
     public void serviceChanged( ServiceEvent event )
     {
-        final ServiceReference ref = event.getServiceReference();
+        final ServiceReference<T> ref = ( ServiceReference<T> ) event.getServiceReference();
         final String serviceString = "Service " + m_dependencyMetadata.getInterface() + "/"
             + ref.getProperty( Constants.SERVICE_ID );
-        Collection<ServiceReference> changes = null;
+        Collection<ServiceReference<T>> changes = null;
         try
         {
             switch ( event.getType() )
@@ -318,7 +318,7 @@ public class DependencyManager implements ServiceListener, Reference
      * @param reference The reference to the service newly registered or
      *      modified.
      */
-    private void serviceAdded( ServiceReference reference )
+    private void serviceAdded( ServiceReference<T> reference )
     {
         // if the component is currently unsatisfied, it may become satisfied
         // by adding this service, try to activate (also schedule activation
@@ -337,10 +337,10 @@ public class DependencyManager implements ServiceListener, Reference
                     "Dependency Manager: Service {0} activation did not occur on this thread", new Object[]
                         { m_dependencyMetadata.getName() }, null );
 
-                Map dependenciesMap = m_componentManager.getDependencyMap();
+                Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependenciesMap = m_componentManager.getDependencyMap();
                 if (dependenciesMap  != null) {
                     //someone else has managed to activate
-                    Map references = ( Map ) dependenciesMap.get( this );
+                    Map<ServiceReference<T>, RefPair<T>> references = (Map)dependenciesMap.get( this );
                     if (references == null )
                     {
                         throw new IllegalStateException( "Allegedly active but dependency manager not represented: " + this );
@@ -380,10 +380,10 @@ public class DependencyManager implements ServiceListener, Reference
                 }
                 else
                 {
-                    Map dependenciesMap = m_componentManager.getDependencyMap();
+                    Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependenciesMap = m_componentManager.getDependencyMap();
                     if ( dependenciesMap != null )
                     {
-                        Map bound = ( Map ) dependenciesMap.get( this );
+                        Map<ServiceReference<T>, RefPair<T>> bound = (Map)dependenciesMap.get( this );
                         if ( m_dependencyMetadata.isMultiple() ||
                                                 bound.isEmpty() ||
                                                 reference.compareTo( bound.keySet().iterator().next() ) > 0 )
@@ -408,11 +408,11 @@ public class DependencyManager implements ServiceListener, Reference
                 else if ( !isReluctant() )
                 {
                     //dynamic greedy single: bind then unbind
-                    Map dependenciesMap = m_componentManager.getDependencyMap();
+                    Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependenciesMap = m_componentManager.getDependencyMap();
                     if ( dependenciesMap != null )
                     {
-                        Map bound = ( Map ) dependenciesMap.get( this );
-                        ServiceReference oldRef = ( ServiceReference ) bound.keySet().iterator().next();
+                        Map<ServiceReference<T>, RefPair<T>> bound = (Map)dependenciesMap.get( this );
+                        ServiceReference oldRef = bound.keySet().iterator().next();
                         if ( reference.compareTo( oldRef ) > 0 )
                         {
                             m_componentManager.invokeBindMethod( this, reference );
@@ -444,7 +444,7 @@ public class DependencyManager implements ServiceListener, Reference
      * @param reference The reference to the service unregistering or being
      *      modified.
      */
-    private void serviceRemoved( ServiceReference reference )
+    private void serviceRemoved( ServiceReference<T> reference )
     {
         // if the dependency is not satisfied anymore, we have to
         // deactivate the component
@@ -470,11 +470,11 @@ public class DependencyManager implements ServiceListener, Reference
         // otherwise check whether the component is in a state to handle the event
         else if ( handleServiceEvent() || (m_componentManager.getState() & (Component.STATE_DISABLED | Component.STATE_DISPOSED)) != 0 )
         {
-            Map dependencyMap = m_componentManager.getDependencyMap();
-            Map referenceMap = null;
+            Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
+            Map<ServiceReference<T>, RefPair<T>> referenceMap = null;
             if (dependencyMap != null)
             {
-                referenceMap = ( Map ) dependencyMap.get( this );
+                referenceMap = (Map)dependencyMap.get( this );
             }
             // if the dependency is static, we have to deactivate the component
             // to "remove" the dependency
@@ -511,7 +511,7 @@ public class DependencyManager implements ServiceListener, Reference
                     // if the dependency is mandatory and no replacement is
                     // available, bind returns false and we deactivate
                     // bind best matching service
-                    ServiceReference ref = getFrameworkServiceReference();
+                    ServiceReference<T> ref = getFrameworkServiceReference();
 
                     if ( ref == null )
                     {
@@ -652,12 +652,12 @@ public class DependencyManager implements ServiceListener, Reference
         // unget all services we once got
         if ( m_componentManager.getDependencyMap() != null )
         {
-            ServiceReference[] boundRefs = getBoundServiceReferences();
+            ServiceReference<T>[] boundRefs = getBoundServiceReferences();
             if ( boundRefs != null )
             {
-                for ( int i = 0; i < boundRefs.length; i++ )
+                for ( ServiceReference<T> ref: boundRefs )
                 {
-                    ungetService( boundRefs[i] );
+                    ungetService( ref );
                 }
             }
         }
@@ -691,13 +691,13 @@ public class DependencyManager implements ServiceListener, Reference
      * This method always directly accesses the framework's service registry
      * and ignores the services bound by this dependency manager.
      */
-    ServiceReference[] getFrameworkServiceReferences()
+    ServiceReference<T>[] getFrameworkServiceReferences()
     {
         return getFrameworkServiceReferences( getTarget() );
     }
 
 
-    private ServiceReference[] getFrameworkServiceReferences( String targetFilter )
+    private ServiceReference<T>[] getFrameworkServiceReferences( String targetFilter )
     {
         if ( hasGetPermission() )
         {
@@ -717,7 +717,7 @@ public class DependencyManager implements ServiceListener, Reference
 
             try
             {
-                return bc.getServiceReferences(
+                return ( ServiceReference<T>[] ) bc.getServiceReferences(
                     m_dependencyMetadata.getInterface(), targetFilter );
             }
             catch ( IllegalStateException ise )
@@ -738,7 +738,7 @@ public class DependencyManager implements ServiceListener, Reference
 
     private int getServiceReferenceCount()
     {
-        ServiceReference[] refs = getFrameworkServiceReferences();
+        ServiceReference<T>[] refs = getFrameworkServiceReferences();
         return refs == null? 0: refs.length;
     }
 
@@ -757,10 +757,10 @@ public class DependencyManager implements ServiceListener, Reference
      * This method always directly accesses the framework's service registry
      * and ignores the services bound by this dependency manager.
      */
-    ServiceReference getFrameworkServiceReference()
+    ServiceReference<T> getFrameworkServiceReference()
     {
         // get the framework registered services and short cut
-        ServiceReference[] refs = getFrameworkServiceReferences();
+        ServiceReference<T>[] refs = getFrameworkServiceReferences();
         if ( refs == null )
         {
             return null;
@@ -772,10 +772,10 @@ public class DependencyManager implements ServiceListener, Reference
 
 
         // find the service with the highest ranking
-        ServiceReference selectedRef = refs[0];
+        ServiceReference<T> selectedRef = refs[0];
         for ( int i = 1; i < refs.length; i++ )
         {
-            ServiceReference ref = refs[i];
+            ServiceReference<T> ref = refs[i];
             if ( ref.compareTo( selectedRef ) > 0 )
             {
                 selectedRef = ref;
@@ -792,9 +792,9 @@ public class DependencyManager implements ServiceListener, Reference
      * non-<code>null</code> service instance the service is then considered
      * bound to this instance.
      */
-    Object getService()
+    T getService()
     {
-        ServiceReference sr = getFrameworkServiceReference();
+        ServiceReference<T> sr = getFrameworkServiceReference();
         return ( sr != null ) ? getService( sr ) : null;
     }
 
@@ -806,25 +806,25 @@ public class DependencyManager implements ServiceListener, Reference
      * returned. All services returned by this method will be considered bound
      * after this method returns.
      */
-    Object[] getServices()
+    T[] getServices()
     {
-        ServiceReference[] sr = getFrameworkServiceReferences();
+        ServiceReference<T>[] sr = getFrameworkServiceReferences();
         if ( sr == null || sr.length == 0 )
         {
             return null;
         }
 
-        List services = new ArrayList();
-        for ( int i = 0; i < sr.length; i++ )
+        List<Object> services = new ArrayList<Object>();
+        for ( ServiceReference<T> ref: sr )
         {
-            Object service = getService( sr[i] );
+            Object service = getService( ref );
             if ( service != null )
             {
                 services.add( service );
             }
         }
 
-        return ( services.size() > 0 ) ? services.toArray() : null;
+        return ( services.size() > 0 ) ? services.toArray((T[])new Object[services.size()]) : null;
     }
 
 
@@ -835,20 +835,20 @@ public class DependencyManager implements ServiceListener, Reference
      * services this instance is bound to or <code>null</code> if no services
      * are actually bound.
      */
-    public ServiceReference[] getBoundServiceReferences()
+    public ServiceReference<T>[] getBoundServiceReferences()
     {
-        Map dependencyMap = m_componentManager.getDependencyMap();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
         if ( dependencyMap == null )
         {
             return null;
         }
-        Map bound = ( Map ) dependencyMap.get( this );
+        Map<ServiceReference<T>, RefPair<T>> bound = (Map)dependencyMap.get( this );
         if ( bound.isEmpty() )
         {
             return null;
         }
 
-        return ( ServiceReference[] ) bound.keySet().toArray( new ServiceReference[bound.size()] );
+        return bound.keySet().toArray( new ServiceReference[bound.size()] );
     }
 
 
@@ -857,12 +857,12 @@ public class DependencyManager implements ServiceListener, Reference
      */
     private boolean isBound()
     {
-        Map dependencyMap = m_componentManager.getDependencyMap();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
         if (dependencyMap  == null )
         {
             return false;
         }
-        Map bound = ( Map ) dependencyMap.get( this );
+        Map<ServiceReference<T>, RefPair<T>> bound = (Map)dependencyMap.get( this );
         return !bound.isEmpty();
     }
 
@@ -878,14 +878,14 @@ public class DependencyManager implements ServiceListener, Reference
      *      if the service is bound or <code>null</code> if the service is not
      *      bound.
      */
-    private RefPair getBoundService( ServiceReference serviceReference )
+    private RefPair getBoundService( ServiceReference<T> serviceReference )
     {
-        Map dependencyMap = m_componentManager.getDependencyMap();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
         if (dependencyMap == null)
         {
             return null;
         }
-        return ( RefPair ) (( Map ) dependencyMap.get( this )).get(serviceReference);
+        return dependencyMap.get( this ).get( serviceReference );
     }
 
 
@@ -900,15 +900,15 @@ public class DependencyManager implements ServiceListener, Reference
      * @return The requested service or <code>null</code> if no service is
      *      registered for the service reference (any more).
      */
-    Object getService( ServiceReference serviceReference )
+    T getService( ServiceReference<T> serviceReference )
     {
         // check whether we already have the service and return that one
         RefPair refPair = getBoundService( serviceReference );
         if ( refPair != null && refPair.getServiceObject() != null )
         {
-            return refPair.getServiceObject();
+            return (T)refPair.getServiceObject();
         }
-        Object serviceObject = null;
+        T serviceObject = null;
         // otherwise acquire the service
         try
         {
@@ -936,7 +936,7 @@ public class DependencyManager implements ServiceListener, Reference
             {
                 refPair = new RefPair( serviceReference );
                 refPair.setServiceObject( serviceObject );
-                ((Map)m_componentManager.getDependencyMap().get( this )).put( serviceReference, refPair );
+                m_componentManager.getDependencyMap().get( this ).put( serviceReference, refPair );
             }
         }
 
@@ -949,13 +949,13 @@ public class DependencyManager implements ServiceListener, Reference
      * Ungets the service described by the ServiceReference and removes it from
      * the list of bound services.
      */
-    void ungetService( ServiceReference serviceReference )
+    void ungetService( ServiceReference<T> serviceReference )
     {
         // check we really have this service, do nothing if not
-        Map dependencyMap = m_componentManager.getDependencyMap();
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
         if ( dependencyMap != null )
         {
-            RefPair refPair  = ( RefPair ) ((Map ) dependencyMap.get( this )).get( serviceReference );
+            RefPair refPair  = dependencyMap.get( this ).get( serviceReference );
             if ( refPair != null && refPair.getServiceObject() != null )
             {
                 BundleComponentActivator activator = m_componentManager.getActivator();
@@ -1023,9 +1023,9 @@ public class DependencyManager implements ServiceListener, Reference
     }
 
 
-    boolean open( Object componentInstance, Map parameters )
+    boolean open( S componentInstance, Map<ServiceReference<?>, RefPair<?>> parameters )
     {
-        return bind( componentInstance, parameters);
+        return bind( componentInstance, (Map)parameters);
     }
 
 
@@ -1034,13 +1034,12 @@ public class DependencyManager implements ServiceListener, Reference
      * try to complete all that it can
      * @param componentInstance
      */
-    void close( Object componentInstance )
+    void close( S componentInstance )
     {
         unbind( componentInstance, getBoundServiceReferences() );
     }
 
-    //returns Map<ServiceReference, RefPair>
-    boolean prebind( Map dependencyMap)
+    boolean prebind( Map<DependencyManager<S, T>, Map<ServiceReference<T>, RefPair<T>>> dependencyMap)
     {
         // If no references were received, we have to check if the dependency
         // is optional, if it is not then the dependency is invalid
@@ -1053,11 +1052,11 @@ public class DependencyManager implements ServiceListener, Reference
         // we have nothing to do and just signal success
         if ( m_dependencyMetadata.getBind() == null )
         {
-            dependencyMap.put( this, new HashMap( ) );
+            dependencyMap.put( this, new HashMap<ServiceReference<T>, RefPair<T>>( ) );
             return true;
         }
 
-        Map result = new HashMap(); //<ServiceReference, RefPair>
+        Map<ServiceReference<T>, RefPair<T>> result = new HashMap<ServiceReference<T>, RefPair<T>>();
         // assume success to begin with: if the dependency is optional,
         // we don't care, whether we can bind a service. Otherwise, we
         // require at least one service to be bound, thus we require
@@ -1068,22 +1067,22 @@ public class DependencyManager implements ServiceListener, Reference
         if ( m_dependencyMetadata.isMultiple() )
         {
             // bind all registered services
-            ServiceReference[] refs = getFrameworkServiceReferences();
+            ServiceReference<T>[] refs = getFrameworkServiceReferences();
             if ( refs != null )
             {
-                for ( int index = 0; index < refs.length; index++ )
+                for ( ServiceReference<T> ref : refs )
                 {
-                    RefPair refPair = new RefPair( refs[index] );
+                    RefPair refPair = new RefPair( ref );
                     // success is if we have the minimal required number of services bound
                     if ( m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() ) )
                     {
-                        result.put( refs[index], refPair );
+                        result.put( ref, refPair );
                         // of course, we have success if the service is bound
                         success = true;
                     }
                     else
                     {
-                        m_componentManager.getActivator().registerMissingDependency(this, refs[index]);
+                        m_componentManager.getActivator().registerMissingDependency( this, ref );
                     }
                 }
             }
@@ -1123,7 +1122,7 @@ public class DependencyManager implements ServiceListener, Reference
      * @return true if the dependency is satisfied and at least the minimum
      *      number of services could be bound. Otherwise false is returned.
      */
-    private boolean bind( Object componentInstance, Map parameters )
+    private boolean bind( S componentInstance, Map<ServiceReference<T>, RefPair<T>> parameters )
     {
         // If no references were received, we have to check if the dependency
         // is optional, if it is not then the dependency is invalid
@@ -1150,11 +1149,10 @@ public class DependencyManager implements ServiceListener, Reference
 
         m_componentManager.log( LogService.LOG_DEBUG,
             "For dependency {0}, optional: {1}; to bind: {2}",
-            new Object[]{ m_dependencyMetadata.getName(), new Boolean( success ), parameters }, null );
-        for ( Iterator i = parameters.entrySet().iterator(); i.hasNext(); )
+            new Object[]{ m_dependencyMetadata.getName(), success, parameters }, null );
+        for ( Map.Entry<ServiceReference<T>, RefPair<T>> entry : parameters.entrySet() )
         {
-            Map.Entry entry = ( Map.Entry ) i.next();
-            if ( !invokeBindMethod( componentInstance, ( RefPair ) entry.getValue() ) )
+            if ( !invokeBindMethod( componentInstance, entry.getValue() ) )
             {
                 m_componentManager.log( LogService.LOG_DEBUG,
                         "For dependency {0}, failed to invoke bind method on object {1}",
@@ -1177,7 +1175,7 @@ public class DependencyManager implements ServiceListener, Reference
      * @param componentInstance
      * @param ref The <code>ServiceReference</code> representing the updated
      */
-    void update( Object componentInstance, final ServiceReference ref )
+    void update( S componentInstance, final ServiceReference<T> ref )
     {
         if ( m_dependencyMetadata.getUpdated() != null )
         {
@@ -1190,7 +1188,7 @@ public class DependencyManager implements ServiceListener, Reference
      * Revoke the given bindings. This method cannot throw an exception since
      * it must try to complete all that it can
      */
-    private void unbind( Object componentInstance, ServiceReference[] boundRefs )
+    private void unbind( S componentInstance, ServiceReference<T>[] boundRefs )
     {
         if ( boundRefs != null )
         {
@@ -1198,28 +1196,28 @@ public class DependencyManager implements ServiceListener, Reference
             // in the delayed component situation) and the unbind method is declared.
             boolean doUnbind = componentInstance != null && m_dependencyMetadata.getUnbind() != null;
 
-            for ( int i = 0; i < boundRefs.length; i++ )
+            for ( ServiceReference<T> boundRef : boundRefs )
             {
                 if ( doUnbind )
                 {
-                    invokeUnbindMethod( componentInstance, boundRefs[i] );
+                    invokeUnbindMethod( componentInstance, boundRef );
                 }
 
                 // unget the service, we call it here since there might be a
                 // bind method (or the locateService method might have been
                 // called) but there is no unbind method to actually unbind
                 // the service (see FELIX-832)
-                ungetService( boundRefs[i] );
+                ungetService( boundRef );
             }
         }
     }
 
-    boolean invokeBindMethod( Object componentInstance, ServiceReference ref )
+    boolean invokeBindMethod( S componentInstance, ServiceReference<T> ref )
     {
         //event driven, and we already checked this ref is not yet handled.
         if ( componentInstance != null )
         {
-            Map dependencyMap = m_componentManager.getDependencyMap();
+            Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> dependencyMap = m_componentManager.getDependencyMap();
             if ( dependencyMap != null )
             {
                 if (m_bindMethods == null)
@@ -1230,8 +1228,8 @@ public class DependencyManager implements ServiceListener, Reference
                             { m_dependencyMetadata.getName(), new Integer(m_componentManager.getState())  }, null );
 
                 }
-                Map deps = ( Map ) dependencyMap.get( this );
-                RefPair refPair = new RefPair( ref );
+                Map<ServiceReference<T>, RefPair<T>> deps = (Map)dependencyMap.get( this );
+                RefPair<T> refPair = new RefPair<T>( ref );
                 if ( !m_bindMethods.getBind().getServiceObject( refPair, m_componentManager.getActivator().getBundleContext() ) )
                 {
                     //reference deactivated while we are processing.
@@ -1251,7 +1249,7 @@ public class DependencyManager implements ServiceListener, Reference
         }
     }
 
-    public void invokeBindMethodLate( final ServiceReference ref )
+    public void invokeBindMethodLate( final ServiceReference<T> ref )
     {
         if ( !isSatisfied() )
         {
@@ -1259,7 +1257,7 @@ public class DependencyManager implements ServiceListener, Reference
         }
         if ( !isMultiple() )
         {
-            ServiceReference[] refs = getFrameworkServiceReferences();
+            ServiceReference<T>[] refs = getFrameworkServiceReferences();
             if ( refs == null )
             {
                 return; // should not happen, we have one!
@@ -1267,7 +1265,7 @@ public class DependencyManager implements ServiceListener, Reference
             // find the service with the highest ranking
             for ( int i = 1; i < refs.length; i++ )
             {
-                ServiceReference test = refs[i];
+                ServiceReference<T> test = refs[i];
                 if ( test.compareTo( ref ) > 0 )
                 {
                     return; //another ref is better
@@ -1296,7 +1294,7 @@ public class DependencyManager implements ServiceListener, Reference
      *      be handed over to the bind method but the service cannot be
      *      retrieved using the service reference.
      */
-    private boolean invokeBindMethod( Object componentInstance, RefPair refPair )
+    private boolean invokeBindMethod( S componentInstance, RefPair refPair )
     {
         // The bind method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
@@ -1337,13 +1335,13 @@ public class DependencyManager implements ServiceListener, Reference
      * @param componentInstance
      * @param ref A service reference corresponding to the service whose service
      */
-    private void invokeUpdatedMethod( Object componentInstance, final ServiceReference ref )
+    private void invokeUpdatedMethod( S componentInstance, final ServiceReference<T> ref )
     {
         // The updated method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
         if ( componentInstance != null )
         {
-            RefPair refPair = ( RefPair ) ((Map )m_componentManager.getDependencyMap().get( this )).get( ref );
+            RefPair refPair = m_componentManager.getDependencyMap().get( this ).get( ref );
             if (refPair == null)
             {
 
@@ -1387,13 +1385,13 @@ public class DependencyManager implements ServiceListener, Reference
      * @param componentInstance
      * @param ref A service reference corresponding to the service that will be
      */
-    void invokeUnbindMethod( Object componentInstance, final ServiceReference ref )
+    void invokeUnbindMethod( S componentInstance, final ServiceReference<T> ref )
     {
         // The unbind method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
         if ( componentInstance != null )
         {
-            RefPair refPair = ( RefPair ) ((Map )m_componentManager.getDependencyMap().get( this )).get( ref );
+            RefPair refPair = m_componentManager.getDependencyMap().get( this ).get( ref );
             if (refPair == null)
             {
                 //TODO should this be possible? If so, reduce or eliminate logging
@@ -1448,7 +1446,7 @@ public class DependencyManager implements ServiceListener, Reference
      * apply.</li>
      * </ol>
      */
-    boolean canUpdateDynamically( Dictionary properties )
+    boolean canUpdateDynamically( Dictionary<String, Object> properties )
     {
         // 1. no target filter change
         final String newTarget = ( String ) properties.get( m_dependencyMetadata.getTargetPropertyName() );
@@ -1474,7 +1472,7 @@ public class DependencyManager implements ServiceListener, Reference
         // invariant: target filter change + dynamic policy
 
         // 3. check target services matching the new filter
-        ServiceReference[] refs = getFrameworkServiceReferences( newTarget );
+        ServiceReference<T>[] refs = getFrameworkServiceReferences( newTarget );
         if ( refs != null && refs.length > 0 )
         {
             // can update since there is at least on service matching the
@@ -1508,7 +1506,7 @@ public class DependencyManager implements ServiceListener, Reference
      * @param properties The properties containing the optional target service
      *      filter property
      */
-    void setTargetFilter( Dictionary properties )
+    void setTargetFilter( Dictionary<String, Object> properties )
     {
         try
         {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
index efce051262..222762e1d4 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
@@ -46,16 +46,16 @@ import org.osgi.service.log.LogService;
  * The default ComponentManager. Objects of this class are responsible for managing
  * implementation object's lifecycle.
  */
-public class ImmediateComponentManager extends AbstractComponentManager implements ServiceFactory
+public class ImmediateComponentManager<S> extends AbstractComponentManager<S> implements ServiceFactory<S>
 {
 
     // The object that implements the service and that is bound to other services
-    private volatile Object m_implementationObject;
+    private volatile S m_implementationObject;
 
     // The component implementation object temporarily set to allow
     // for service updates during activation. This field is only set
     // to a non-null value while calling the activate method
-    private volatile Object m_tmpImplementationObject;
+    private volatile S m_tmpImplementationObject;
 
     // keep the using bundles as reference "counters" for instance deactivation
     private volatile int m_useCount;
@@ -67,18 +67,18 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
     private ComponentHolder m_componentHolder;
 
     // optional properties provided in the ComponentFactory.newInstance method
-    private Dictionary m_factoryProperties;
+    private Dictionary<String, Object> m_factoryProperties;
 
     // the component properties, also used as service properties
-    private Dictionary m_properties;
+    private Dictionary<String, Object> m_properties;
 
     // properties supplied ot ExtComponentContext.updateProperties
     // null if properties are not to be overwritten
-    private Dictionary m_serviceProperties;
+    private Dictionary<String, Object> m_serviceProperties;
 
     // the component properties from the Configuration Admin Service
     // this is null, if none exist or none are provided
-    private Dictionary m_configurationProperties;
+    private Dictionary<String, Object> m_configurationProperties;
 
     /**
      * The constructor receives both the activator and the metadata
@@ -121,9 +121,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         if ( m_implementationObject == null )
         {
             final ComponentContextImpl tmpContext = new ComponentContextImpl( this );
-            Object tmpComponent = createImplementationObject( tmpContext, new SetImplementationObject()
+            S tmpComponent = createImplementationObject( tmpContext, new SetImplementationObject<S>()
             {
-                public void setImplementationObject( Object implementationObject )
+                public void setImplementationObject( S implementationObject )
                 {
                     m_componentContext = tmpContext;
                     m_implementationObject = implementationObject;
@@ -131,13 +131,13 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
                 }
 
 
-                public void presetImplementationObject( Object implementationObject )
+                public void presetImplementationObject( S implementationObject )
                 {
                     m_tmpImplementationObject = implementationObject;
                 }
 
 
-                public void resetImplementationObject( Object implementationObject )
+                public void resetImplementationObject( S implementationObject )
                 {
                     m_tmpImplementationObject = null;
                 }
@@ -202,7 +202,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
      * potentially other parts as part of the {@link #createImplementationObject} method
      * processing.
      */
-    protected interface SetImplementationObject
+    protected interface SetImplementationObject<S>
     {
 
         /**
@@ -211,7 +211,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
          * temporarily set the implementation object during the activator
          * call.
          */
-        void presetImplementationObject( Object implementationObject );
+        void presetImplementationObject( S implementationObject );
 
 
         /**
@@ -220,7 +220,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
          * revert any temporary settings done in the {@link #presetImplementationObject(Object)}
          * method.
          */
-        void resetImplementationObject( Object implementationObject );
+        void resetImplementationObject( S implementationObject );
 
 
         /**
@@ -230,14 +230,14 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
          * by the {@link #presetImplementationObject(Object)} should be
          * removed and the implementation object is now accessible.
          */
-        void setImplementationObject( Object implementationObject );
+        void setImplementationObject( S implementationObject );
     }
 
 
-    protected Object createImplementationObject( ComponentContext componentContext, SetImplementationObject setter )
+    protected S createImplementationObject( ComponentContext componentContext, SetImplementationObject setter )
     {
-        final Class implementationObjectClass;
-        final Object implementationObject;
+        final Class<S> implementationObjectClass;
+        final S implementationObject;
 
         // 1. Load the component implementation class
         // 2. Create the component instance and component context
@@ -245,8 +245,8 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         try
         {
             // 112.4.4 The class is retrieved with the loadClass method of the component's bundle
-            implementationObjectClass = getActivator().getBundleContext().getBundle().loadClass(
-                    getComponentMetadata().getImplementationClassName() );
+            implementationObjectClass = (Class<S>) getActivator().getBundleContext().getBundle().loadClass(
+                    getComponentMetadata().getImplementationClassName() )  ;
 
             // 112.4.4 The class must be public and have a public constructor without arguments so component instances
             // may be created by the SCR with the newInstance method on Class
@@ -260,15 +260,14 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         }
 
         // 3. Bind the target services
-        Map parameters = getParameterMap();
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        Map<DependencyManager<S, ?>, Map<ServiceReference<?>, RefPair<?>>> parameters = getDependencyMap();
+
+        for ( DependencyManager<S, ?> dm: getDependencyManagers())
         {
             // if a dependency turned unresolved since the validation check,
             // creating the instance fails here, so we deactivate and return
             // null.
-            DependencyManager dm = ( DependencyManager ) it.next();
-            Map params = ( Map ) parameters.get( dm );  //<ServiceReference, RefPair>
+            Map<ServiceReference<?>, RefPair<?>> params = parameters.get( dm );
             if ( !dm.open( implementationObject, params ) )
             {
                 log( LogService.LOG_ERROR, "Cannot create component instance due to failure to bind reference {0}",
@@ -276,11 +275,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
                                 {dm.getName()}, null );
 
                 // make sure, we keep no bindings
-                it = getReversedDependencyManagers();
-                while ( it.hasNext() )
+                for ( DependencyManager md: getReversedDependencyManagers() )
                 {
-                    dm = ( DependencyManager ) it.next();
-                    dm.close( implementationObject );
+                    md.close( implementationObject );
                 }
 
                 return null;
@@ -300,11 +297,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
 
             // 112.5.8 If the activate method throws an exception, SCR must log an error message
             // containing the exception with the Log Service and activation fails
-            it = getDependencyManagers();
-            while ( it.hasNext() )
+            for ( DependencyManager md: getReversedDependencyManagers() )
             {
-                DependencyManager dm = ( DependencyManager ) it.next();
-                dm.close( implementationObject );
+                md.close( implementationObject );
             }
 
             return null;
@@ -335,11 +330,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         }
 
         // 2. Unbind any bound services
-        Iterator it = getReversedDependencyManagers();
-        while ( it.hasNext() )
+        for ( DependencyManager md: getReversedDependencyManagers() )
         {
-            DependencyManager dm = ( DependencyManager ) it.next();
-            dm.close( implementationObject );
+            md.close( implementationObject );
         }
 
         // 3. Release all references
@@ -356,25 +349,25 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         return Active.getInstance();
     }
 
-    void update( DependencyManager dependencyManager, ServiceReference ref )
+    <T> void update( DependencyManager<S, T> dependencyManager, ServiceReference<T> ref )
     {
-        final Object impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
+        final S impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
         dependencyManager.update( impl, ref );
     }
 
-    void invokeBindMethod( DependencyManager dependencyManager, ServiceReference reference )
+    <T> void invokeBindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> reference )
     {
-        final Object impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
+        final S impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
         dependencyManager.invokeBindMethod( impl, reference);
     }
 
-    void invokeUnbindMethod( DependencyManager dependencyManager, ServiceReference oldRef )
+    <T> void invokeUnbindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> oldRef )
     {
-        final Object impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
+        final S impl = ( m_tmpImplementationObject != null ) ? m_tmpImplementationObject : m_implementationObject;
         dependencyManager.invokeUnbindMethod( impl, oldRef);
     }
 
-    protected void setFactoryProperties( Dictionary dictionary )
+    protected void setFactoryProperties( Dictionary<String, Object> dictionary )
     {
         m_factoryProperties = copyTo( null, dictionary );
     }
@@ -409,21 +402,19 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
      *
      * @return a private Hashtable of component properties
      */
-    public Dictionary getProperties()
+    public Dictionary<String, Object> getProperties()
     {
 
         if ( m_properties == null )
         {
 
             // 1. the properties from the component descriptor
-            Dictionary props = copyTo( null, getComponentMetadata().getProperties() );
+            Dictionary<String, Object> props = copyTo( null, getComponentMetadata().getProperties() );
 
             // 2. add target properties of references
             // 112.6 Component Properties, target properties (p. 302)
-            List depMetaData = getComponentMetadata().getDependencies();
-            for ( Iterator di = depMetaData.iterator(); di.hasNext(); )
+            for ( ReferenceMetadata rm : getComponentMetadata().getDependencies() )
             {
-                ReferenceMetadata rm = ( ReferenceMetadata ) di.next();
                 if ( rm.getTarget() != null )
                 {
                     props.put( rm.getTargetPropertyName(), rm.getTarget() );
@@ -438,7 +429,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
 
             // 5. set component.name and component.id
             props.put( ComponentConstants.COMPONENT_NAME, getComponentMetadata().getName() );
-            props.put( ComponentConstants.COMPONENT_ID, new Long( getId() ) );
+            props.put( ComponentConstants.COMPONENT_ID, getId() );
 
             m_properties = props;
         }
@@ -446,7 +437,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         return m_properties;
     }
 
-    public void setServiceProperties( Dictionary serviceProperties )
+    public void setServiceProperties( Dictionary<String, Object> serviceProperties )
     {
         if ( serviceProperties == null || serviceProperties.isEmpty() )
         {
@@ -457,13 +448,13 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
             m_serviceProperties = copyTo( null, serviceProperties, false );
             // set component.name and component.id
             m_serviceProperties.put( ComponentConstants.COMPONENT_NAME, getComponentMetadata().getName() );
-            m_serviceProperties.put( ComponentConstants.COMPONENT_ID, new Long( getId() ) );
+            m_serviceProperties.put( ComponentConstants.COMPONENT_ID, getId() );
         }
 
         updateServiceRegistration();
     }
 
-    public Dictionary getServiceProperties()
+    public Dictionary<String, Object> getServiceProperties()
     {
         if ( m_serviceProperties != null )
         {
@@ -474,13 +465,13 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
 
     private void updateServiceRegistration()
     {
-        ServiceRegistration sr = getServiceRegistration();
+        ServiceRegistration<?> sr = getServiceRegistration();
         if ( sr != null )
         {
             try
             {
                 // Don't propagate if service properties did not change.
-                final Dictionary regProps = getServiceProperties();
+                final Dictionary<String, Object> regProps = getServiceProperties();
                 if ( !servicePropertiesMatches( sr, regProps ) )
                 {
                     sr.setProperties( regProps );
@@ -518,7 +509,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
      *                      the Configuration Admin Service or <code>null</code> if there is
      *                      no configuration or if the configuration has just been deleted.
      */
-    public void reconfigure( Dictionary configuration )
+    public void reconfigure( Dictionary<String, Object> configuration )
     {
         // nothing to do if there is no configuration (see FELIX-714)
         if ( configuration == null && m_configurationProperties == null )
@@ -594,11 +585,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
 
         // 3. check whether we can dynamically apply the configuration if
         // any target filters influence the bound services
-        final Dictionary props = getProperties();
-        Iterator it = getDependencyManagers();
-        while ( it.hasNext() )
+        final Dictionary<String, Object> props = getProperties();
+        for ( DependencyManager dm: getDependencyManagers() )
         {
-            DependencyManager dm = ( DependencyManager ) it.next();
             if ( !dm.canUpdateDynamically( props ) )
             {
                 log( LogService.LOG_DEBUG,
@@ -672,9 +661,9 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
      * @return <code>true</code> if the registration service properties equals
      *         the prop properties, false if not.
      */
-    private boolean servicePropertiesMatches( ServiceRegistration reg, Dictionary props )
+    private boolean servicePropertiesMatches( ServiceRegistration reg, Dictionary<String, Object> props )
     {
-        Dictionary regProps = new Hashtable();
+        Dictionary<String, Object> regProps = new Hashtable<String, Object>();
         String[] keys = reg.getReference().getPropertyKeys();
         for ( int i = 0; keys != null && i < keys.length; i++ )
         {
@@ -687,7 +676,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
         return regProps.equals( props );
     }
 
-    public Object getService( Bundle bundle, ServiceRegistration serviceRegistration )
+    public S getService( Bundle bundle, ServiceRegistration<S> serviceRegistration )
     {
             Object implementationObject = m_implementationObject;
             if ( implementationObject == null )
@@ -725,7 +714,7 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
                     if ( m_implementationObject == null )
                     {
                         //state should be "Registered"
-                        Object result = state().getService( this );
+                        S result = (S) state().getService( this );
                         if ( result != null )
                         {
                             m_useCount++;
@@ -740,10 +729,10 @@ public class ImmediateComponentManager extends AbstractComponentManager implemen
                 }
             }
             m_useCount++;
-            return implementationObject;
+            return (S) implementationObject;
     }
 
-    public void ungetService( Bundle bundle, ServiceRegistration serviceRegistration, Object o )
+    public void ungetService( Bundle bundle, ServiceRegistration<S> serviceRegistration, S o )
     {
         // the framework should not call ungetService more than it calls
         // calls getService. Still, we want to be sure to not go below zero
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/RefPair.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/RefPair.java
index 34cf14e306..1b2e1e39ef 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/RefPair.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/RefPair.java
@@ -25,27 +25,27 @@ import org.osgi.framework.ServiceReference;
 /**
  * @version $Rev:$ $Date:$
  */
-public class RefPair
+public class RefPair<T>
 {
-    private final ServiceReference ref;
-    private Object serviceObject;
+    private final ServiceReference<T> ref;
+    private T serviceObject;
 
-    public RefPair( ServiceReference ref )
+    public RefPair( ServiceReference<T> ref )
     {
         this.ref = ref;
     }
 
-    public ServiceReference getRef()
+    public ServiceReference<T> getRef()
     {
         return ref;
     }
 
-    public Object getServiceObject()
+    public T getServiceObject()
     {
         return serviceObject;
     }
 
-    public void setServiceObject( Object serviceObject )
+    public void setServiceObject( T serviceObject )
     {
         this.serviceObject = serviceObject;
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
index 9e9f49456a..06a60fdec6 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
@@ -42,18 +42,18 @@ import org.osgi.service.log.LogService;
  * The <code>ServiceFactoryComponentManager</code> for components specified with &lt;service serviceFactory='true'/&gt;
  * in the xml metadata. The component must be delayed, not immediate or factory.
  */
-public class ServiceFactoryComponentManager extends ImmediateComponentManager
+public class ServiceFactoryComponentManager<S> extends ImmediateComponentManager<S>
 {
 
     // maintain the map of ComponentContext objects created for the
     // service instances
-    private IdentityHashMap serviceContexts = new IdentityHashMap();
+    private IdentityHashMap<S, BundleComponentContext> serviceContexts = new IdentityHashMap<S, BundleComponentContext>();
 
     // pseudo map of implementation objects to be used for service
     // binding while calling the activate method. The map's keys and values
     // are just the implementation objects. The objects will only be
     // contained while the activate method is being called.
-    private IdentityHashMap tmpImplementationObjects = new IdentityHashMap();
+    private IdentityHashMap<S, BundleComponentContext> tmpImplementationObjects = new IdentityHashMap<S, BundleComponentContext>();
 
     /**
      * @param activator BundleComponentActivator for this DS implementation
@@ -111,7 +111,7 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
     /* (non-Javadoc)
      * @see org.osgi.framework.ServiceFactory#getService(org.osgi.framework.Bundle, org.osgi.framework.ServiceRegistration)
      */
-    public Object getService( Bundle bundle, ServiceRegistration registration )
+    public S getService( Bundle bundle, ServiceRegistration<S> registration )
     {
         log( LogService.LOG_DEBUG, "ServiceFactory.getService()", null );
 
@@ -143,9 +143,9 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
         }
         // private ComponentContext and implementation instances
         final BundleComponentContext serviceContext = new BundleComponentContext( this, bundle );
-        Object service = createImplementationObject( serviceContext, new SetImplementationObject()
+        S service = createImplementationObject( serviceContext, new SetImplementationObject<S>()
         {
-            public void presetImplementationObject( Object implementationObject )
+            public void presetImplementationObject( S implementationObject )
             {
                 serviceContext.setImplementationObject( implementationObject );
                 tmpImplementationObjects.put( implementationObject, serviceContext );
@@ -153,7 +153,7 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
             }
 
 
-            public void setImplementationObject( Object implementationObject )
+            public void setImplementationObject( S implementationObject )
             {
                 serviceContexts.put( implementationObject, serviceContext );
                 tmpImplementationObjects.remove( implementationObject );
@@ -166,7 +166,7 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
             }
 
 
-            public void resetImplementationObject( Object implementationObject )
+            public void resetImplementationObject( S implementationObject )
             {
                 tmpImplementationObjects.remove( implementationObject );
                 serviceContext.setImplementationObject( null );
@@ -189,7 +189,7 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
     /* (non-Javadoc)
      * @see org.osgi.framework.ServiceFactory#ungetService(org.osgi.framework.Bundle, org.osgi.framework.ServiceRegistration, java.lang.Object)
      */
-    public void ungetService( Bundle bundle, ServiceRegistration registration, Object service )
+    public void ungetService( Bundle bundle, ServiceRegistration<S> registration, S service )
     {
         log( LogService.LOG_DEBUG, "ServiceFactory.ungetService()", null );
 
@@ -208,40 +208,35 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
         }
     }
 
-    void update( DependencyManager dependencyManager, ServiceReference ref )
+    <T> void update( DependencyManager<S, T> dependencyManager, ServiceReference<T> ref )
     {
-        for ( Iterator it = serviceContexts.keySet().iterator(); it.hasNext(); )
+        for ( S implementationObject : serviceContexts.keySet() )
         {
-            Object implementationObject = it.next();
             dependencyManager.update( implementationObject, ref );
         }
     }
 
-    void invokeBindMethod( DependencyManager dependencyManager, ServiceReference reference )
+    <T> void invokeBindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> reference )
     {
-        for ( Iterator it = serviceContexts.keySet().iterator(); it.hasNext(); )
+        for ( S implementationObject : serviceContexts.keySet() )
         {
-            Object implementationObject = it.next();
-            dependencyManager.invokeBindMethod( implementationObject, reference);
+            dependencyManager.invokeBindMethod( implementationObject, reference );
         }
-        for ( Iterator it = tmpImplementationObjects.keySet().iterator(); it.hasNext(); )
+        for ( S implementationObject : tmpImplementationObjects.keySet() )
         {
-            Object implementationObject = it.next();
-            dependencyManager.invokeBindMethod( implementationObject, reference);
+            dependencyManager.invokeBindMethod( implementationObject, reference );
         }
     }
 
-    void invokeUnbindMethod( DependencyManager dependencyManager, ServiceReference oldRef )
+    <T> void invokeUnbindMethod( DependencyManager<S, T> dependencyManager, ServiceReference<T> oldRef )
     {
-        for ( Iterator it = serviceContexts.keySet().iterator(); it.hasNext(); )
+        for ( S implementationObject : serviceContexts.keySet() )
         {
-            Object implementationObject = it.next();
-            dependencyManager.invokeUnbindMethod( implementationObject, oldRef);
+            dependencyManager.invokeUnbindMethod( implementationObject, oldRef );
         }
-        for ( Iterator it = tmpImplementationObjects.keySet().iterator(); it.hasNext(); )
+        for ( S implementationObject : tmpImplementationObjects.keySet() )
         {
-            Object implementationObject = it.next();
-            dependencyManager.invokeUnbindMethod( implementationObject, oldRef);
+            dependencyManager.invokeUnbindMethod( implementationObject, oldRef );
         }
     }
 
@@ -249,20 +244,18 @@ public class ServiceFactoryComponentManager extends ImmediateComponentManager
     {
         ModifiedMethod modifiedMethod = getComponentMethods().getModifiedMethod();
         MethodResult result = null;
-        for (Iterator i = serviceContexts.values().iterator(); i.hasNext(); )
+        for ( BundleComponentContext componentContext : serviceContexts.values() )
         {
-            BundleComponentContext componentContext = ( BundleComponentContext ) i.next();
             Object instance = componentContext.getInstance();
             result = modifiedMethod.invoke( instance,
                     new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID );
 
         }
-        for (Iterator i = tmpImplementationObjects.values().iterator(); i.hasNext(); )
+        for ( BundleComponentContext componentContext : tmpImplementationObjects.values() )
         {
-            BundleComponentContext componentContext = ( BundleComponentContext ) i.next();
             Object instance = componentContext.getInstance();
             result = modifiedMethod.invoke( instance,
-                new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID );
+                    new ActivateMethod.ActivatorParameter( componentContext, -1 ), MethodResult.VOID );
 
         }
         return result;
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/metadata/ComponentMetadata.java b/scr/src/main/java/org/apache/felix/scr/impl/metadata/ComponentMetadata.java
index 3cea976748..7c1ec7ea2a 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/metadata/ComponentMetadata.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/metadata/ComponentMetadata.java
@@ -47,7 +47,7 @@ public class ComponentMetadata
     public static final String CONFIGURATION_POLICY_OPTIONAL = "optional";
 
     // set of valid configuration policy settings
-    private static final Set CONFIGURATION_POLICY_VALID;
+    private static final Set<String> CONFIGURATION_POLICY_VALID;
 
     // marker value indicating duplicate implementation class setting
     private static final String IMPLEMENTATION_CLASS_DUPLICATE = "icd";
@@ -98,26 +98,26 @@ public class ComponentMetadata
     private String m_configurationPid;
 
     // Associated properties (0..*)
-    private Dictionary m_properties = new Hashtable();
+    private Dictionary<String, Object> m_properties = new Hashtable<String, Object>();
 
     // List of Property metadata - used while building the meta data
     // while validating the properties contained in the PropertyMetadata
     // instances are copied to the m_properties Dictionary while this
     // list will be cleared
-    private List m_propertyMetaData = new ArrayList();
+    private List<PropertyMetadata> m_propertyMetaData = new ArrayList<PropertyMetadata>();
 
     // Provided services (0..1)
     private ServiceMetadata m_service = null;
 
     // List of service references, (required services 0..*)
-    private List m_references = new ArrayList();
+    private List<ReferenceMetadata> m_references = new ArrayList<ReferenceMetadata>();
 
     // Flag that is set once the component is verified (its properties cannot be changed)
     private boolean m_validated = false;
 
     static
     {
-        CONFIGURATION_POLICY_VALID = new TreeSet();
+        CONFIGURATION_POLICY_VALID = new TreeSet<String>();
         CONFIGURATION_POLICY_VALID.add( CONFIGURATION_POLICY_IGNORE );
         CONFIGURATION_POLICY_VALID.add( CONFIGURATION_POLICY_OPTIONAL );
         CONFIGURATION_POLICY_VALID.add( CONFIGURATION_POLICY_REQUIRE );
@@ -135,7 +135,7 @@ public class ComponentMetadata
      * Setter for the configuration-pid component (since DS 1.2)
      * @param configurationPid
      */
-    public void setConfigirationPid(String configurationPid)
+    public void setConfigurationPid( String configurationPid )
     {
         if ( m_validated )
         {
@@ -487,7 +487,7 @@ public class ComponentMetadata
      * Returns the flag that defines the activation policy for the component.
      * <p>
      * This method may only be trusted after this instance has been validated
-     * by the {@link #validate()} call. Else it will either return the value
+     * by the {@link #validate( Logger logger )} call. Else it will either return the value
      * of an explicitly set "immediate" attribute or return false if a service
      * element or the factory attribute is set or true otherwise. This latter
      * default value deduction may be unsafe while the descriptor has not been
@@ -611,7 +611,7 @@ public class ComponentMetadata
      *
      * @return the properties as a Dictionary
      */
-    public Dictionary getProperties()
+    public Dictionary<String, Object> getProperties()
     {
         return m_properties;
     }
@@ -623,7 +623,7 @@ public class ComponentMetadata
      *
      * @return the list of property meta data.
      */
-    List getPropertyMetaData()
+    List<PropertyMetadata> getPropertyMetaData()
     {
         return m_propertyMetaData;
     }
@@ -634,7 +634,7 @@ public class ComponentMetadata
      *
      * @return a Collection of dependency descriptors
      */
-    public List getDependencies()
+    public List<ReferenceMetadata> getDependencies()
     {
         return m_references;
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/metadata/PropertyMetadata.java b/scr/src/main/java/org/apache/felix/scr/impl/metadata/PropertyMetadata.java
index 69a95b951c..6d954ab230 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/metadata/PropertyMetadata.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/metadata/PropertyMetadata.java
@@ -92,7 +92,7 @@ public class PropertyMetadata {
             return;
         }
         // splite th values
-        List valueList = new ArrayList();
+        List<String> valueList = new ArrayList<String>();
         StringTokenizer tokener = new StringTokenizer(values, "\r\n");
         while (tokener.hasMoreTokens()) {
             String value = tokener.nextToken().trim();
@@ -324,7 +324,7 @@ public class PropertyMetadata {
             boolean[] array = new boolean[valueList.length];
             for ( int i = 0; i < array.length; i++ )
             {
-                array[i] = Boolean.valueOf( valueList[i] ).booleanValue();
+                array[i] = Boolean.valueOf( valueList[i] );
             }
             return array;
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/metadata/ServiceMetadata.java b/scr/src/main/java/org/apache/felix/scr/impl/metadata/ServiceMetadata.java
index 92b107ec57..0c7ebe4b7e 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/metadata/ServiceMetadata.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/metadata/ServiceMetadata.java
@@ -33,7 +33,7 @@ public class ServiceMetadata {
 	private boolean m_serviceFactory = false;
 
 	// List of provided interfaces
-	private List m_provides = new ArrayList();
+	private List<String> m_provides = new ArrayList<String>();
 
 	// Flag that indicates if this metadata has been validated and has become immutable
 	private boolean m_validated = false;
@@ -79,7 +79,7 @@ public class ServiceMetadata {
      * @return the implemented interfaces as a string array
      */
     public String [] getProvides() {
-        return (String[]) m_provides.toArray( new String[m_provides.size()] );
+        return m_provides.toArray( new String[m_provides.size()] );
     }
 
     /**
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/metadata/XmlHandler.java b/scr/src/main/java/org/apache/felix/scr/impl/metadata/XmlHandler.java
index de86e25d99..49304d9be8 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/metadata/XmlHandler.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/metadata/XmlHandler.java
@@ -242,7 +242,7 @@ public class XmlHandler implements KXml2SAXHandler
                     // configuration-pid attribute is optional (since DS 1.2)
                     if (attrib.getProperty("configuration-pid") != null)
                     {
-                        m_currentComponent.setConfigirationPid( attrib.getProperty( "configuration-pid" ) );
+                        m_currentComponent.setConfigurationPid( attrib.getProperty( "configuration-pid" ) );
                     }
 
                     // Add this component to the list
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/metadata/ComponentMetadataTest.java b/scr/src/test/java/org/apache/felix/scr/impl/metadata/ComponentMetadataTest.java
index f07d2a926a..293c134d3d 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/metadata/ComponentMetadataTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/metadata/ComponentMetadataTest.java
@@ -715,7 +715,7 @@ public class ComponentMetadataTest extends TestCase
       ComponentMetadata cm = createComponentMetadata11( null, null );
         try
         {
-          cm.setConfigirationPid( "configurationPid" );
+          cm.setConfigurationPid( "configurationPid" );
           cm.validate( logger );
           fail( "Expect validation failure for illegal configuration-pid usage in ds 1.1 namespace" );
         }
@@ -727,7 +727,7 @@ public class ComponentMetadataTest extends TestCase
         cm = createComponentMetadata12( null, null );
         try
         {
-          cm.setConfigirationPid( "configurationPid" );
+          cm.setConfigurationPid( "configurationPid" );
           cm.validate( logger );
         }
         catch ( ComponentException ce )
