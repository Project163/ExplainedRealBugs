diff --git a/scr/src/main/java/org/apache/felix/scr/impl/config/ConfigurableComponentHolder.java b/scr/src/main/java/org/apache/felix/scr/impl/config/ConfigurableComponentHolder.java
index 5aa27eda58..bf39d2ae8b 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/config/ConfigurableComponentHolder.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/config/ConfigurableComponentHolder.java
@@ -25,6 +25,7 @@ import java.util.Dictionary;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -222,8 +223,8 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
                 new Object[] {pid}, null);
 
         // component to deconfigure or dispose of
-        final SingleComponentManager<S> icm;
-        boolean deconfigure = false;
+        final Map<SingleComponentManager<S>, Map<String, Object>> scms = new HashMap<SingleComponentManager<S>, Map<String, Object>>();
+        boolean reconfigure = false;
 
         synchronized ( m_components )
         {
@@ -235,22 +236,27 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
 			if (factoryPid != null) {
 				checkFactoryPidIndex(factoryPid);
 				String servicePid = pid.getServicePid();
-				icm = m_components.remove(servicePid);
-				if (icm == null)
-				{
-					return;
-				}
 				m_factoryTargetedPids.remove(servicePid);
 				m_factoryChangeCount.remove(servicePid);
 				m_factoryConfigurations.remove(servicePid);
-				deconfigure = m_componentMetadata.isConfigurationOptional() && m_components.isEmpty();
-				if ( deconfigure )
+				SingleComponentManager<S> scm = m_components.remove(servicePid);
+				if ( m_factoryConfigurations.isEmpty() )
 				{
-					m_singleComponent = icm;
+					m_factoryPidIndex = null;
 				}
-				if ( m_components.isEmpty() )
+				if ( !m_enabled )
 				{
-					m_factoryPidIndex = null;
+					return;
+				}
+				reconfigure = m_componentMetadata.isConfigurationOptional() && m_components.isEmpty();
+				if ( reconfigure )
+				{
+					m_singleComponent = scm;
+					scms.put( scm, mergeProperties(null) );
+				}
+				else
+				{
+					scms.put( scm,  null );
 				}
 			}
 			else
@@ -260,21 +266,49 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
 				m_targetedPids[index] = null;
 				m_changeCount[index] = null;
 				m_configurations[index] = null;
-				icm = m_singleComponent;
-				deconfigure = m_componentMetadata.isConfigurationOptional();
-				if ( !deconfigure )
+				if ( !m_enabled )
+				{
+					return;
+				}
+				reconfigure = m_componentMetadata.isConfigurationOptional();
+
+				if ( m_factoryPidIndex == null)
 				{
-					m_singleComponent = null;
+					if ( reconfigure)
+					{
+						scms.put(m_singleComponent, mergeProperties( null ));
+					}
+					else
+					{
+						scms.put( m_singleComponent, null);
+						m_singleComponent = null;
+					}
+				}
+				else
+				{
+					if (reconfigure) {
+						for (Map.Entry<String, SingleComponentManager<S>> entry : m_components.entrySet()) {
+							scms.put(entry.getValue(), mergeProperties(entry.getKey()));
+						}
+					}
+					else
+					{
+						for (Map.Entry<String, SingleComponentManager<S>> entry : m_components.entrySet()) {
+							scms.put(entry.getValue(), null );
+						}	
+						m_components.clear();
+					}
 				}
+
 			}
         }
 
-        if ( icm != null ) 
+        for ( Map.Entry<SingleComponentManager<S>,Map<String, Object>> entry: scms.entrySet())
         {
-			if ( deconfigure ) {
-				icm.reconfigure(null);
+			if ( reconfigure ) {
+				entry.getKey().reconfigure( entry.getValue(), true);
 			} else {
-				icm.dispose(ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED);
+				entry.getKey().dispose(ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED);
 			}
 		}
     }
@@ -300,12 +334,11 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
                 new Object[] {pid, props}, null);
 
         // component to update or create
-        final SingleComponentManager<S> scm;
+        final Map<SingleComponentManager<S>, Map<String, Object>> scms = new HashMap< SingleComponentManager<S>, Map<String, Object>>();
         final String message;
         Object[] notEnabledArguments = null;
         boolean created = false;
         
-        Map<String, Object> properties;
         //TODO better change count tracking
         synchronized (m_components) {
 			//Find or create the component manager, or return if not satisfied.
@@ -314,20 +347,22 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
 				m_factoryConfigurations.put(pid.getServicePid(), props);
 				m_factoryTargetedPids.put(pid.getServicePid(), factoryPid);
 				m_factoryChangeCount.put(pid.getServicePid(), changeCount);
-				if (isSatisfied()) {
+				if (m_enabled && isSatisfied()) {
 					if (m_singleComponent != null) {
-						scm = m_singleComponent;
+						SingleComponentManager<S> scm = m_singleComponent;
+						scms.put( scm, mergeProperties( pid.getServicePid() ) );
 						m_singleComponent = null;
 						m_components.put(pid.getServicePid(), scm);
 					} else if (m_components.containsKey(pid.getServicePid())) {
-						scm = m_components.get(pid.getServicePid());
+						scms.put( m_components.get(pid.getServicePid()), mergeProperties( pid.getServicePid())  );
 					} else {
-						scm = createComponentManager();
+						SingleComponentManager<S> scm = createComponentManager();
 						m_components.put(pid.getServicePid(), scm);
+						scms.put( scm, mergeProperties( pid.getServicePid())  );
 						created = true;
 					}
 				} else {
-					return created; //still false
+					return false;
 				}
 
 			} else {
@@ -336,117 +371,75 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
 				m_targetedPids[index] = pid;
 				m_changeCount[index] = changeCount;
 				m_configurations[index] = props;
-				if (isSatisfied()) {
+				if (m_enabled && isSatisfied()) {
 					if (m_singleComponent != null) {
-						scm = m_singleComponent;
-					} else {
+						scms.put( m_singleComponent, mergeProperties( pid.getServicePid() ) );
+					} 
+					else if ( m_factoryPidIndex != null) 
+					{
+						for (Map.Entry<String, SingleComponentManager<S>> entry: m_components.entrySet()) 
+						{
+							scms.put(entry.getValue(), mergeProperties( entry.getKey()));
+						}
+					}
+					else
+					{
 						m_singleComponent = createComponentManager();
-						scm = m_singleComponent;
+						scms.put( m_singleComponent, mergeProperties( pid.getServicePid() ) );
 						created = true;
 					}
 				} else {
-					return created; //false
+					return false;
 				}
 
 			}
-			properties = new HashMap<String, Object>(m_componentMetadata.getProperties());
-			for (int i = 0; i < m_configurations.length; i++)
-			{
-				if ( m_factoryPidIndex != null && i == m_factoryPidIndex)
-				{
-					copyTo(properties, props);
-				}
-				else if ( m_configurations[i] != null )
-				{
-					copyTo(properties, m_configurations[i]);
-				}
-			}
 			
 		}
 		
 
         // we have the icm.
         //properties is all the configs merged together (without any possible component factory info.
-//        synchronized ( m_components )
-//        {
-//            // FELIX-2231: nothing to do any more, all components have been disposed off
-//            if (m_singleComponent == null) 
-//            {
-//                return false;
-//            }
-//
-//            if ( pid.equals( getComponentMetadata().getConfigurationPid() ) )
-//            {
-//                // singleton configuration has pid equal to component name
-//                scm = m_singleComponent;
-//                message = "ImmediateComponentHolder reconfiguring single component for pid {0} ";
-//                enable = false;
-//            }
-//            else
-//            {
-//                final SingleComponentManager existingIcm = m_components.get( pid );
-//                if ( existingIcm != null )
-//                {
-//                    // factory configuration updated for existing component instance
-//                    scm = existingIcm;
-//                    message = "ImmediateComponentHolder reconfiguring existing component for pid {0} ";
-//                    enable = false;
-//                }
-//                else
-//                {
-//                    // factory configuration created
-//                    created = true;
-//                    if ( !m_singleComponent.hasConfiguration() )
-//                    {
-//                        // configure the single instance if this is not configured
-//                        scm = m_singleComponent;
-//                        message = "ImmediateComponentHolder configuring the unconfigured single component for pid {0} ";
-//                    }
-//                    else
-//                    {
-//                        // otherwise create a new instance to provide the config to
-//                        scm = createComponentManager();
-//                        message = "ImmediateComponentHolder configuring a new component for pid {0} ";
-//                    }
-//
-//                    // enable the component if it is initially enabled
-//                    if ( m_enabled && getComponentMetadata().isEnabled() ) 
-//                    {
-//                        enable = true;
-//                    }
-//                    else 
-//                    {
-//                        enable = false;
-//                        notEnabledArguments = new Object[] {pid, m_enabled, getComponentMetadata().isEnabled()};
-//                    }
-//
-//	                // store the component in the map
-//                    m_components.put( pid, scm );
-//                }
-//            }
-//        }
-//        log( LogService.LOG_DEBUG, message, new Object[] {pid}, null);
-
-        final boolean enable = created && m_enabled && getComponentMetadata().isEnabled();
-        // configure the component
-        scm.reconfigure( properties );
-        log( LogService.LOG_DEBUG, "ImmediateComponentHolder Finished configuring the dependency managers for component for pid {0} ",
-                new Object[] {pid}, null );
 
-        if (enable) 
+        final boolean enable = created && m_enabled;// TODO WTF?? && getComponentMetadata().isEnabled();
+        for ( Map.Entry<SingleComponentManager<S>,Map<String, Object>> entry: scms.entrySet())
         {
-            scm.enable( false );
-            log( LogService.LOG_DEBUG, "ImmediateComponentHolder Finished enabling component for pid {0} ",
-                    new Object[] {pid}, null );
-        }
-        else  
-        {
-            log( LogService.LOG_DEBUG, "ImmediateComponentHolder Will not enable component for pid {0}: holder enabled state: {1}, metadata enabled: {2} ",
-                    new Object[] { pid, m_enabled, m_componentMetadata.isEnabled()}, null );
-        }
-        return created;
+			// configure the component
+			entry.getKey().reconfigure(entry.getValue(), false);
+			log(LogService.LOG_DEBUG,
+					"ImmediateComponentHolder Finished configuring the dependency managers for component for pid {0} ",
+					new Object[] { pid }, null);
+			if (enable) {
+				entry.getKey().enable(false);
+				log(LogService.LOG_DEBUG,
+						"ImmediateComponentHolder Finished enabling component for pid {0} ",
+						new Object[] { pid }, null);
+			} else {
+				log(LogService.LOG_DEBUG,
+						"ImmediateComponentHolder Will not enable component for pid {0}: holder enabled state: {1}, metadata enabled: {2} ",
+						new Object[] { pid, m_enabled,
+								m_componentMetadata.isEnabled() }, null);
+			}
+		}
+		return created;
     }
 
+	private Map<String, Object> mergeProperties(String servicePid) {
+		Map<String, Object> properties;
+		properties = new HashMap<String, Object>(m_componentMetadata.getProperties());
+		for (int i = 0; i < m_configurations.length; i++)
+		{
+			if ( m_factoryPidIndex != null && i == m_factoryPidIndex)
+			{
+				copyTo(properties, m_factoryConfigurations.get(servicePid));
+			}
+			else if ( m_configurations[i] != null )
+			{
+				copyTo(properties, m_configurations[i]);
+			}
+		}
+		return properties;
+	}
+
 	private int getSingletonPidIndex(TargetedPID pid) {
 		int index = m_componentMetadata.getPidIndex(pid);
 		if (index == -1) {
@@ -517,7 +510,7 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
      * @return true if configuration optional or all pids supplied with configurations
      */
     private boolean isSatisfied() {
-    	if ( m_componentMetadata.isConfigurationOptional()) 
+    	if ( m_componentMetadata.isConfigurationOptional() || m_componentMetadata.isConfigurationIgnored() ) 
     	{
     		return true;
     	}
@@ -576,16 +569,27 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
 
     public void enableComponents( final boolean async )
     {
-    	List<SingleComponentManager<S>> cms;
+    	List<SingleComponentManager<S>> cms = new ArrayList<SingleComponentManager<S>>();
     	synchronized ( m_components )
     	{
-    		if (m_singleComponent == null && m_factoryPidIndex == null && 
-    				(m_componentMetadata.isConfigurationIgnored() || m_componentMetadata.isConfigurationOptional()))
+    		if ( isSatisfied() )
     		{
-    			m_singleComponent = createComponentManager();
+    			if ( m_factoryPidIndex == null)
+    			{
+        			m_singleComponent = createComponentManager();
+        			cms.add( m_singleComponent );
+        			m_singleComponent.reconfigure(mergeProperties( null ), false);
+    			}
+    			else
+    			{
+    				for (String pid: m_factoryConfigurations.keySet()) {
+    					SingleComponentManager<S> scm = createComponentManager();
+    					scm.reconfigure( mergeProperties( pid ), false);
+    					cms.add( scm );
+    				}
+    			}
     		}
     		m_enabled = true;
-    		cms = getComponentManagers( false );
     	}
     	for ( SingleComponentManager<S> cm : cms )
     	{
@@ -601,12 +605,12 @@ public class ConfigurableComponentHolder<S> implements ComponentHolder<S>, Simpl
         {
             m_enabled = false;
 
-            cms = getComponentManagers( false );
-       		if (m_singleComponent != null && m_factoryPidIndex == null && 
-    				(m_componentMetadata.isConfigurationIgnored() || m_componentMetadata.isConfigurationOptional()))
-    		{
-    			m_singleComponent = null;
-    		}
+            cms = getComponentManagers( true );
+//       		if (m_singleComponent != null && m_factoryPidIndex == null && 
+//    				(m_componentMetadata.isConfigurationIgnored() || m_componentMetadata.isConfigurationOptional()))
+//    		{
+//    			m_singleComponent = null;
+//    		}
         }
         for ( SingleComponentManager<S> cm : cms )
         {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 0c551e2496..d602bc6cd2 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -111,6 +111,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     protected volatile boolean m_enabled;
     protected volatile boolean m_internalEnabled;
     
+	private volatile boolean m_satisfied;
+    
     protected volatile boolean m_disposed;
     
     //service event tracking
@@ -744,12 +746,12 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         registerComponentId();
         // Before creating the implementation object, we are going to
         // test if we have configuration if such is required
-        if ( hasConfiguration() || !getComponentMetadata().isConfigurationRequired() )
-        {
+//        if ( hasConfiguration() || !getComponentMetadata().isConfigurationRequired() )
+//        {
             // Update our target filters.
             log( LogService.LOG_DEBUG, "Updating target filters", null );
             updateTargets( getProperties() );
-        }
+//        }
 
         m_internalEnabled = true;
         log( LogService.LOG_DEBUG, "Component enabled", null );
@@ -787,11 +789,12 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
         // Before creating the implementation object, we are going to
         // test if we have configuration if such is required
-        if ( !hasConfiguration() && getComponentMetadata().isConfigurationRequired() )
-        {
-            log( LogService.LOG_DEBUG, "Missing required configuration, cannot activate", null );
-            return;
-        }
+        //TODO this should not be needed, no configuration >>> no manager
+//        if ( !hasConfiguration() && getComponentMetadata().isConfigurationRequired() )
+//        {
+//            log( LogService.LOG_DEBUG, "Missing required configuration, cannot activate", null );
+//            return;
+//        }
 
         // Before creating the implementation object, we are going to
         // test that the bundle has enough permissions to register services
@@ -897,6 +900,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             obtainStateLock( "AbstractComponentManager.State.doDeactivate.1" );
             try
             {
+            	m_satisfied = false;
                 m_activated = false;
                 deleteComponent( reason );
                 deactivateDependencyManagers();
@@ -1023,7 +1027,6 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         }
         
     };
-    
 
     /**
      * Registers the service on behalf of the component.
@@ -1289,6 +1292,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             }
         }
 
+        m_satisfied = satisfied;
         return satisfied;
     }
 
@@ -1351,8 +1355,6 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         }
     }
 
-    public abstract boolean hasConfiguration();
-
     /* (non-Javadoc)
 	 * @see org.apache.felix.scr.impl.manager.ComponentManager#getProperties()
 	 */
@@ -1490,7 +1492,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         {
             return STATE_DISABLED;
         }
-        if ( getServiceRegistration() == null && (getProvidedServices() != null || !hasInstance()))
+        if ( !m_satisfied )
         {
             return STATE_UNSATISFIED;
         }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
index 0372077aee..583f069207 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentFactoryImpl.java
@@ -128,7 +128,7 @@ public class ComponentFactoryImpl<S> extends AbstractComponentManager<S> impleme
 
         cm.setFactoryProperties( dictionary );
         //configure the properties
-        cm.reconfigure( m_configuration );
+        cm.reconfigure( m_configuration, false );
         // enable
         cm.enableInternal();
         //activate immediately
@@ -181,7 +181,7 @@ public class ComponentFactoryImpl<S> extends AbstractComponentManager<S> impleme
         public void modify(Dictionary<String, ?> properties)
         {
             cm.setFactoryProperties( properties );
-            cm.reconfigure();            
+            cm.reconfigure(false);            
         }
         
     }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
index fadc1e5582..4295a00df3 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
@@ -413,12 +413,6 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
     }
 
 
-    public boolean hasConfiguration()
-    {
-        return m_configurationProperties != null;
-    }
-
-
     void registerComponentId()
     {
         super.registerComponentId();
@@ -541,10 +535,11 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
      * @param configuration The configuration properties for the component from
      *                      the Configuration Admin Service or <code>null</code> if there is
      *                      no configuration or if the configuration has just been deleted.
+     * @param configurationDeleted TODO
      * @param changeCount Change count for the configuration
      * @param targetedPID TargetedPID for the configuration
      */
-    public void reconfigure( Map<String, Object> configuration )
+    public void reconfigure( Map<String, Object> configuration, boolean configurationDeleted )
     {
 //        if ( targetedPID == null || !targetedPID.equals( m_targetedPID ) )
 //        {
@@ -576,10 +571,10 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
         // store the properties
         m_configurationProperties = configuration;
 
-        reconfigure();
+        reconfigure(configurationDeleted);
     }
 
-    void reconfigure()
+    void reconfigure(boolean configurationDeleted)
     {
         CountDownLatch enableLatch = enableLatchWait();
         try
@@ -598,17 +593,17 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                 return;
             }
 
-            //TODO should be handled in Holder, not here
-            // if the configuration has been deleted but configuration is required
-            // this component must be deactivated
-            if ( m_configurationProperties == null && getComponentMetadata().isConfigurationRequired() )
-            {
-                //deactivate and remove service listeners
-                deactivateInternal( ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED, true, false );
-                //do not reset targets as that will reinstall the service listeners which may activate the component.
-                //when a configuration arrives the properties will get set based on the new configuration.
-                return;
-            }
+//            //TODO should be handled in Holder, not here
+//            // if the configuration has been deleted but configuration is required
+//            // this component must be deactivated
+//            if ( m_configurationProperties == null && getComponentMetadata().isConfigurationRequired() )
+//            {
+//                //deactivate and remove service listeners
+//                deactivateInternal( ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED, true, false );
+//                //do not reset targets as that will reinstall the service listeners which may activate the component.
+//                //when a configuration arrives the properties will get set based on the new configuration.
+//                return;
+//            }
 
             // unsatisfied component and non-ignored configuration may change targets
             // to satisfy references
@@ -625,7 +620,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                     return;
                 }
 
-                if ( !modify() )
+                if ( !modify(configurationDeleted) )
                 {
                     // SCR 112.7.1 - deactivate if configuration is deleted or no modified method declared
                     log( LogService.LOG_DEBUG, "Deactivating and Activating to reconfigure from configuration", null );
@@ -661,11 +656,11 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
         }
     }
 
-    private boolean modify()
+    private boolean modify(boolean configurationDeleted)
     {
     	//0 SCR 112.7.1 If configuration is deleted, and version is < 1.3 and no flag set, then deactivate unconditionally.
     	// For version 1.3 and later, or with a flag, more sensible behavior is allowed.
-    	if ( m_configurationProperties == null && !getComponentMetadata().isDeleteCallsModify()){
+    	if ( configurationDeleted && !getComponentMetadata().isDeleteCallsModify()){
     		return false;
     	}
     	
diff --git a/scr/src/test/java/org/apache/felix/scr/impl/config/ConfiguredComponentHolderTest.java b/scr/src/test/java/org/apache/felix/scr/impl/config/ConfiguredComponentHolderTest.java
index 552b997839..421c27c1e4 100644
--- a/scr/src/test/java/org/apache/felix/scr/impl/config/ConfiguredComponentHolderTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/impl/config/ConfiguredComponentHolderTest.java
@@ -52,8 +52,8 @@ public class ConfiguredComponentHolderTest extends TestCase
         assertNotNull( "Expect single component manager", cmgr );
         assertEquals( "Expect no other component manager list", 1, getComponentManagers( holder ).size());
 
-        // assert no configuration of single component
-        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
+//        // assert no configuration of single component
+//        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
     }
 
 
@@ -70,26 +70,27 @@ public class ConfiguredComponentHolderTest extends TestCase
         assertNotNull( "Expect single component manager", cmgr );
         assertEquals( "Expect no other component manager list", 1, getComponentManagers( holder ).size());
 
-        // assert no configuration of single component
-        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
+//        // assert no configuration of single component
+//        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
 
         // configure with the singleton configuration
         final Dictionary config = new Hashtable();
         config.put( "value", name );
-        holder.configurationUpdated( new TargetedPID(name), null, config, 0 );
+        TargetedPID targetedPid = new TargetedPID(name);
+		holder.configurationUpdated( targetedPid, null, config, 0 );
 
         // assert single component and no map
         final SingleComponentManager cmgrAfterConfig = getSingleManager( holder );
         assertNotNull( "Expect single component manager", cmgrAfterConfig );
         assertEquals( "Expect no other component manager list", 1, getComponentManagers( holder ).size());
 
-        // assert configuration of single component
-        assertTrue( "Expect configuration after updating it", cmgrAfterConfig.hasConfiguration() );
+//        // assert configuration of single component
+//        assertTrue( "Expect configuration after updating it", cmgrAfterConfig.hasConfiguration() );
         final Map componentConfig = ( ( MockImmediateComponentManager ) cmgrAfterConfig ).getConfiguration();
         assertEquals( "Expect exact configuration set", config, componentConfig );
 
         // unconfigure singleton
-        holder.configurationDeleted( name );
+        holder.configurationDeleted( targetedPid, null );
 
         // assert single component and no map
         final SingleComponentManager cmgrAfterUnconfig = getSingleManager( holder );
@@ -115,14 +116,16 @@ public class ConfiguredComponentHolderTest extends TestCase
         assertNotNull( "Expect single component manager", cmgr );
         assertEquals( "Expect no other component manager list", 1, getComponentManagers( holder ).size());
 
-        // assert no configuration of single component
-        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
+//        // assert no configuration of single component
+//        assertFalse( "Expect no configuration", cmgr.hasConfiguration() );
 
         // configure with configuration
         final String pid1 = "test.factory.0001";
         final Dictionary config1 = new Hashtable();
         config1.put( "value", pid1 );
-        holder.configurationUpdated( new TargetedPID(pid1), new TargetedPID(name), config1, 0 );
+        TargetedPID targetedFactoryPid = new TargetedPID(name);
+		TargetedPID targetedPid1 = new TargetedPID(pid1);
+		holder.configurationUpdated( targetedPid1, targetedFactoryPid, config1, 0 );
 
         // assert single component and single-entry map
         final SingleComponentManager cmgrAfterConfig = getSingleManager( holder );
@@ -135,7 +138,8 @@ public class ConfiguredComponentHolderTest extends TestCase
         final String pid2 = "test.factory.0002";
         final Dictionary config2 = new Hashtable();
         config1.put( "value", pid2 );
-        holder.configurationUpdated( new TargetedPID(pid2), new TargetedPID(name), config2, 1 );
+        TargetedPID targetedPid2 = new TargetedPID(pid2);
+		holder.configurationUpdated( targetedPid2, targetedFactoryPid, config2, 1 );
 
         // assert single component and single-entry map
 //        final SingleComponentManager cmgrAfterConfig2 = getSingleManager( holder );
@@ -145,7 +149,7 @@ public class ConfiguredComponentHolderTest extends TestCase
         assertEquals( "Expect two component manager in list", 2, cmgrsAfterConfig2.size() );
 
         // remove second configuration
-        holder.configurationDeleted( pid2 );
+        holder.configurationDeleted( targetedPid2, targetedFactoryPid );
 
         // assert single component and single-entry map
 //        final SingleComponentManager cmgrAfterUnConfig2 = getSingleManager( holder );
@@ -155,8 +159,8 @@ public class ConfiguredComponentHolderTest extends TestCase
 //TODO Multipids fix correct assertion        assertEquals( "Expect one component manager in list", 1, cmgrsAfterUnConfig2.size() );
 
         // add second config again and remove first config -> replace singleton component
-        holder.configurationUpdated( new TargetedPID(pid2), new TargetedPID(name), config2, 2 );
-        holder.configurationDeleted( pid1 );
+        holder.configurationUpdated( targetedPid2, targetedFactoryPid, config2, 2 );
+        holder.configurationDeleted( targetedPid1, targetedFactoryPid );
 
         // assert single component and single-entry map
 //        final SingleComponentManager cmgrAfterConfigUnconfig = getSingleManager( holder );
@@ -166,7 +170,7 @@ public class ConfiguredComponentHolderTest extends TestCase
 //TODO Multipids fix correct assertion        assertEquals( "Expect one component manager in list", 1, cmgrsAfterConfigUnconfig.size() );
 
         // remove second configuration (leaving no configurations)
-        holder.configurationDeleted( pid2 );
+        holder.configurationDeleted( targetedPid2, targetedFactoryPid );
 
         // assert single component and single-entry map
 //        final SingleComponentManager cmgrAfterAllUnconfig = getSingleManager( holder );
@@ -263,7 +267,7 @@ public class ConfiguredComponentHolderTest extends TestCase
         }
 
 
-        public void reconfigure( Map<String, Object> configuration )
+        public void reconfigure( Map<String, Object> configuration, boolean configurationDeleted )
         {
             this.m_configuration = configuration;
         }
