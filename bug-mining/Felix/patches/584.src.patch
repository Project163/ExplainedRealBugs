diff --git a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationBindingTest.java b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationBindingTest.java
index e269eff59a..2998375037 100644
--- a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationBindingTest.java
+++ b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationBindingTest.java
@@ -574,13 +574,33 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         // ==> configuration is bound to locationB
         TestCase.assertEquals( locationB, config.getBundleLocation() );
 
-        // ==> configuration removed from service ms1
-        TestCase.assertNull( testerA1.props );
-        TestCase.assertEquals( 2, testerA1.numManagedServiceUpdatedCalls );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.props );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration removed from service ms1
+            TestCase.assertNull( testerA1.props );
+            TestCase.assertEquals( 2, testerA1.numManagedServiceUpdatedCalls );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.props );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration remains for service ms1
+            TestCase.assertNotNull( testerA1.props );
+            TestCase.assertEquals( 1, testerA1.numManagedServiceUpdatedCalls );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.props );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceUpdatedCalls );
+        }
     }
 
 
@@ -625,13 +645,33 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         // ==> configuration is bound to locationB
         TestCase.assertEquals( locationB, config.getBundleLocation() );
 
-        // ==> configuration removed from service ms1
-        TestCase.assertNull( testerA1.props );
-        TestCase.assertEquals( 2, testerA1.numManagedServiceUpdatedCalls );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.props );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration removed from service ms1
+            TestCase.assertNull( testerA1.props );
+            TestCase.assertEquals( 2, testerA1.numManagedServiceUpdatedCalls );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.props );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration remains for service ms1
+            TestCase.assertNotNull( testerA1.props );
+            TestCase.assertEquals( 1, testerA1.numManagedServiceUpdatedCalls );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.props );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceUpdatedCalls );
+        }
     }
 
 
@@ -674,14 +714,35 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         // ==> configuration is bound to locationB
         TestCase.assertEquals( locationB, config.getBundleLocation() );
 
-        // ==> configuration removed from service ms1
-        TestCase.assertNull( testerA1.configs.get( pid ));
-        TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
-        TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryDeleteCalls );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.configs.get( pid ) );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration removed from service ms1
+            TestCase.assertNull( testerA1.configs.get( pid ));
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryDeleteCalls );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration not removed from service ms1
+            TestCase.assertNotNull( testerA1.configs.get( pid ));
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
+            TestCase.assertEquals( 0, testerA1.numManagedServiceFactoryDeleteCalls );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
     }
 
 
@@ -728,14 +789,35 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         // ==> configuration is bound to locationB
         TestCase.assertEquals( locationB, config.getBundleLocation() );
 
-        // ==> configuration removed from service ms1
-        TestCase.assertNull( testerA1.configs.get( pid ));
-        TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
-        TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryDeleteCalls );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.configs.get( pid ) );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration removed from service ms1
+            TestCase.assertNull( testerA1.configs.get( pid ));
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryDeleteCalls );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration not removed from service ms1
+            TestCase.assertNotNull( testerA1.configs.get( pid ));
+            TestCase.assertEquals( 1, testerA1.numManagedServiceFactoryUpdatedCalls );
+            TestCase.assertEquals( 0, testerA1.numManagedServiceFactoryDeleteCalls );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
     }
 
 
@@ -779,12 +861,31 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         delay();
         delay();
 
-        // ==> configuration is bound to locationB
-        TestCase.assertEquals( locationB, config.getBundleLocation() );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.props );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration is bound to locationB
+            TestCase.assertEquals( locationB, config.getBundleLocation() );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.props );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration is unbound
+            TestCase.assertNull( config.getBundleLocation() );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.props );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceUpdatedCalls );
+        }
     }
 
 
@@ -828,11 +929,30 @@ public class ConfigurationBindingTest extends ConfigurationTestBase
         delay();
         delay();
 
-        // ==> configuration is bound to locationB
-        TestCase.assertEquals( locationB, config.getBundleLocation() );
-
-        // ==> configuration supplied to the service ms2
-        TestCase.assertNotNull( testerB1.configs.get( pid ) );
-        TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        /*
+         * According to BJ Hargrave configuration is not re-dispatched
+         * due to setting the bundle location.
+         * <p>
+         * Therefore, we have two sets one with re-dispatch expectation and
+         * one without re-dispatch expectation.
+         */
+        if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+        {
+            // ==> configuration is bound to locationB
+            TestCase.assertEquals( locationB, config.getBundleLocation() );
+
+            // ==> configuration supplied to the service ms2
+            TestCase.assertNotNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 1, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
+        else
+        {
+            // ==> configuration is unbound
+            TestCase.assertNull( config.getBundleLocation() );
+
+            // ==> configuration not supplied to the service ms2
+            TestCase.assertNull( testerB1.configs.get( pid ) );
+            TestCase.assertEquals( 0, testerB1.numManagedServiceFactoryUpdatedCalls );
+        }
     }
 }
diff --git a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTestBase.java b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTestBase.java
index 28e173863e..e46bd90cac 100644
--- a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTestBase.java
+++ b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTestBase.java
@@ -53,6 +53,24 @@ import org.osgi.util.tracker.ServiceTracker;
 public abstract class ConfigurationTestBase
 {
 
+    /**
+     * There is currently an open issue in the specification in whether a
+     * call to Configuration.setBundleLocation() might trigger a configuration
+     * update or not.
+     * We have test cases in our integration test suite for both cases. To
+     * enable the respective tests set this field accordingly:
+     * <dl>
+     * <dt>false</dt>
+     * <dd>Expect configuration to <b>NOT</b> be redispatched. That is existing
+     * configurations are kept and other services are not updated</dd>
+     * <dt>true</dt>
+     * <dd>Expect configuration to be redispatched. That is existing configuration
+     * is revoked (update(null) or delete calls) and new matching services are
+     * updated.</dd>
+     * </dl>
+     */
+    public static final boolean REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION = false;
+
     @Inject
     protected BundleContext bundleContext;
 
diff --git a/configadmin/src/test/java/org/apache/felix/cm/integration/MultiServiceFactoryPIDTest.java b/configadmin/src/test/java/org/apache/felix/cm/integration/MultiServiceFactoryPIDTest.java
index 11dfc93c1d..1ce490eec3 100644
--- a/configadmin/src/test/java/org/apache/felix/cm/integration/MultiServiceFactoryPIDTest.java
+++ b/configadmin/src/test/java/org/apache/felix/cm/integration/MultiServiceFactoryPIDTest.java
@@ -165,8 +165,23 @@ public class MultiServiceFactoryPIDTest extends ConfigurationTestBase
 
             delay();
 
-            // expect configuration reassigned
-            TestCase.assertEquals( bundle2.getLocation(), config.getBundleLocation() );
+            /*
+             * According to BJ Hargrave configuration is not re-dispatched
+             * due to setting the bundle location.
+             * <p>
+             * Therefore, we have two sets one with re-dispatch expectation and
+             * one without re-dispatch expectation.
+             */
+            if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+            {
+                // expect configuration reassigned
+                TestCase.assertEquals( bundle2.getLocation(), config.getBundleLocation() );
+            }
+            else
+            {
+                // expected configuration unbound
+                TestCase.assertNull( config.getBundleLocation() );
+            }
 
             // remove the configuration for good
             deleteConfig( pid );
@@ -231,8 +246,23 @@ public class MultiServiceFactoryPIDTest extends ConfigurationTestBase
 
                 delay();
 
-                // expect configuration reassigned
-                TestCase.assertEquals( bundle2.getLocation(), config.getBundleLocation() );
+                /*
+                 * According to BJ Hargrave configuration is not re-dispatched
+                 * due to setting the bundle location.
+                 * <p>
+                 * Therefore, we have two sets one with re-dispatch expectation and
+                 * one without re-dispatch expectation.
+                 */
+                if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+                {
+                    // expect configuration reassigned
+                    TestCase.assertEquals( bundle2.getLocation(), config.getBundleLocation() );
+                }
+                else
+                {
+                    // expected configuration unbound
+                    TestCase.assertNull( config.getBundleLocation() );
+                }
             }
             else if ( bundle2.getLocation().equals( config.getBundleLocation() ) )
             {
@@ -249,8 +279,23 @@ public class MultiServiceFactoryPIDTest extends ConfigurationTestBase
 
                 delay();
 
-                // expect configuration reassigned
-                TestCase.assertEquals( bundle.getLocation(), config.getBundleLocation() );
+                /*
+                 * According to BJ Hargrave configuration is not re-dispatched
+                 * due to setting the bundle location.
+                 * <p>
+                 * Therefore, we have two sets one with re-dispatch expectation and
+                 * one without re-dispatch expectation.
+                 */
+                if ( REDISPATCH_CONFIGURATION_ON_SET_BUNDLE_LOCATION )
+                {
+                    // expect configuration reassigned
+                    TestCase.assertEquals( bundle.getLocation(), config.getBundleLocation() );
+                }
+                else
+                {
+                    // expected configuration unbound
+                    TestCase.assertNull( config.getBundleLocation() );
+                }
             }
             else
             {
