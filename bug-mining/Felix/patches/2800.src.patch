diff --git a/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/FelixResolveContext.java b/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/FelixResolveContext.java
new file mode 100644
index 0000000000..ddfb49bcf7
--- /dev/null
+++ b/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/FelixResolveContext.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */package org.apache.felix.resolver;
+
+import java.util.Collection;
+import org.osgi.framework.namespace.PackageNamespace;
+import org.osgi.resource.*;
+
+public interface FelixResolveContext {
+	/**
+	 * Returns the subset of {@link Wiring#getRequiredResourceWires(String) require wires}
+	 * that provide wires to {@link Capability capabilities} which substitute capabilities
+	 * of the given wiring. For example, when a {@link PackageNamespace package} name is both
+	 * provided and required by the same resource. If the package requirement is resolved
+	 * to a capability hosted by a different wiring then the package capability is
+	 * considered to be substituted.
+	 *
+	 * @param wiring the wiring to get the substitution wires from
+	 * @return A collection containing a snapshot of the substitution {@link Wire}s
+	 * for the {@link Requirement requirements} of this wiring, or an empty list
+	 * if this wiring has no substitution wires.
+	 */
+	public Collection<Wire> getSubstitutionWires(Wiring wiring);
+}
diff --git a/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/ResolverImpl.java b/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/ResolverImpl.java
index b7e027223e..8e8ae20183 100644
--- a/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/ResolverImpl.java
+++ b/osgi-r7/resolver/src/main/java/org/apache/felix/resolver/ResolverImpl.java
@@ -919,7 +919,6 @@ public class ResolverImpl implements Resolver
         }
         else if (candCap.getNamespace().equals(BundleNamespace.BUNDLE_NAMESPACE))
         {
-
             // Get the candidate's package space to determine which packages
             // will be visible to the current resource.
             if (visitedRequiredBundles.add(candCap.getResource()))
@@ -933,6 +932,13 @@ public class ResolverImpl implements Resolver
                         currentReq,
                         blame.m_cap);
                 }
+                // now merge in substitutes
+                for (Blame blame : resourcePkgMap.get(
+                    candCap.getResource()).m_substitePkgs.values())
+                {
+                    mergeCandidatePackage(packages.m_requiredPkgs, currentReq,
+                        blame.m_cap);
+                }
             }
 
             // If the candidate requires any other bundles with reexport visibility,
@@ -1163,7 +1169,8 @@ public class ResolverImpl implements Resolver
             {
                 public void run()
                 {
-                    calculateExportedPackages(session, allCandidates, resource, packages.m_exportedPkgs);
+                    calculateExportedPackages(session, allCandidates, resource,
+                        packages.m_exportedPkgs, packages.m_substitePkgs);
                 }
             });
         }
@@ -1596,7 +1603,7 @@ public class ResolverImpl implements Resolver
             ResolveSession session,
             Candidates allCandidates,
             Resource resource,
-            OpenHashMap<String, Blame> exports)
+        OpenHashMap<String, Blame> exports, OpenHashMap<String, Blame> substitutes)
     {
         // Get all exported packages.
         Wiring wiring = session.getContext().getWirings().get(resource);
@@ -1621,9 +1628,35 @@ public class ResolverImpl implements Resolver
         // already excludes imported substitutable exports, but
         // for resolving resources we must look in the candidate
         // map to determine which exports are substitutable.
-        if (!exports.isEmpty())
+        if (wiring != null)
         {
-            if (wiring == null)
+            Collection<Wire> substitutionWires;
+            if (session.getContext() instanceof FelixResolveContext)
+            {
+                substitutionWires = ((FelixResolveContext) session.getContext()).getSubstitutionWires(
+                    wiring);
+            }
+            else
+            {
+                substitutionWires = getSubstitutionWires(wiring);
+            }
+            for (Wire wire : substitutionWires)
+            {
+                Capability cap = wire.getCapability();
+                if (!cap.getResource().equals(wire.getProvider()))
+                {
+                    cap = new WrappedCapability(wire.getProvider(), cap);
+                }
+                substitutes.put(
+                    // Using a null on requirement instead of the wire requirement here.
+                    // It is unclear if we want to treat the substitution requirement as a permutation req here.
+                    (String) cap.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE),
+                    new Blame(cap, null));
+            }
+        }
+        else
+        {
+            if (!exports.isEmpty())
             {
                 for (Requirement req : resource.getRequirements(null))
                 {
@@ -1633,7 +1666,13 @@ public class ResolverImpl implements Resolver
                         if (cand != null)
                         {
                             String pkgName = (String) cand.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE);
-                            exports.remove(pkgName);
+                            Blame blame = exports.remove(pkgName);
+                            if (blame != null)
+                            {
+                                // Using a null on requirement instead of the wire requirement here.
+                                // It is unclear if we want to treat the substitution requirement as a permutation req here.
+                                substitutes.put(pkgName, new Blame(cand, null));
+                            }
                         }
                     }
                 }
@@ -1642,6 +1681,49 @@ public class ResolverImpl implements Resolver
         return exports;
     }
 
+    private static Collection<Wire> getSubstitutionWires(Wiring wiring)
+    {
+        Set<String> exportNames = new HashSet<String>();
+        for (Capability cap : wiring.getResource().getCapabilities(null))
+        {
+            if (PackageNamespace.PACKAGE_NAMESPACE.equals(cap.getNamespace()))
+            {
+                exportNames.add(
+                    (String) cap.getAttributes().get(PackageNamespace.PACKAGE_NAMESPACE));
+            }
+        }
+        // Add fragment exports
+        for (Wire wire : wiring.getProvidedResourceWires(null))
+        {
+            if (HostNamespace.HOST_NAMESPACE.equals(wire.getCapability().getNamespace()))
+            {
+                for (Capability cap : wire.getRequirement().getResource().getCapabilities(
+                    null))
+                {
+                    if (PackageNamespace.PACKAGE_NAMESPACE.equals(cap.getNamespace()))
+                    {
+                        exportNames.add((String) cap.getAttributes().get(
+                            PackageNamespace.PACKAGE_NAMESPACE));
+                    }
+                }
+            }
+        }
+        Collection<Wire> substitutionWires = new ArrayList<Wire>();
+        for (Wire wire : wiring.getRequiredResourceWires(null))
+        {
+            if (PackageNamespace.PACKAGE_NAMESPACE.equals(
+                wire.getCapability().getNamespace()))
+            {
+                if (exportNames.contains(wire.getCapability().getAttributes().get(
+                    PackageNamespace.PACKAGE_NAMESPACE)))
+                {
+                    substitutionWires.add(wire);
+                }
+            }
+        }
+        return substitutionWires;
+    }
+
     private static boolean isCompatible(
         Blame currentBlame, Capability candCap,
         Map<Resource, Packages> resourcePkgMap)
@@ -2051,6 +2133,7 @@ public class ResolverImpl implements Resolver
     public static class Packages
     {
         public final OpenHashMap<String, Blame> m_exportedPkgs;
+        public final OpenHashMap<String, Blame> m_substitePkgs;
         public final OpenHashMap<String, List<Blame>> m_importedPkgs;
         public final OpenHashMap<String, List<Blame>> m_requiredPkgs;
         public final OpenHashMap<String, ArrayMap<Capability, UsedBlames>> m_usedPkgs;
@@ -2063,6 +2146,7 @@ public class ResolverImpl implements Resolver
             int nbReqs = resource.getRequirements(null).size();
 
             m_exportedPkgs = new OpenHashMap<String, Blame>(nbCaps);
+            m_substitePkgs = new OpenHashMap<String, Blame>(nbCaps);
             m_importedPkgs = new OpenHashMap<String, List<Blame>>(nbReqs) {
                 public List<Blame> compute(String s) {
                     return new ArrayList<Blame>();
diff --git a/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/ResolverTest.java b/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/ResolverTest.java
index 25379aa5bf..fc67f3f75c 100644
--- a/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/ResolverTest.java
+++ b/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/ResolverTest.java
@@ -58,6 +58,7 @@ import org.osgi.resource.Resource;
 import org.osgi.resource.Wire;
 import org.osgi.resource.Wiring;
 import org.osgi.service.resolver.ResolutionException;
+import org.osgi.service.resolver.ResolveContext;
 import org.osgi.service.resolver.Resolver;
 
 public class ResolverTest
@@ -856,6 +857,148 @@ public class ResolverTest
 
     }
 
+    @Test
+    public void testScenario17_1() throws Exception
+    {
+        ResolveContext rci = populateScenario17(false, false, false);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    @Test
+    public void testScenario17_2() throws Exception
+    {
+        ResolveContext rci = populateScenario17(false, false, true);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    @Test
+    public void testScenario17_3() throws Exception
+    {
+        ResolveContext rci = populateScenario17(true, false, false);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    @Test
+    public void testScenario17_4() throws Exception
+    {
+        ResolveContext rci = populateScenario17(true, false, true);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    @Test
+    public void testScenario17_5() throws Exception
+    {
+        ResolveContext rci = populateScenario17(false, true, true);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    @Test
+    public void testScenario17_6() throws Exception
+    {
+        ResolveContext rci = populateScenario17(true, true, true);
+        ResolverImpl resolver = new ResolverImpl(new Logger(Logger.LOG_DEBUG), 1);
+        resolver.resolve(rci);
+    }
+
+    private ResolveContext populateScenario17(boolean realSubstitute,
+        boolean felixResolveContext, boolean existingWirings)
+    {
+        Map<Requirement, List<Capability>> candMap = new HashMap<Requirement, List<Capability>>();
+        ResourceImpl core = new ResourceImpl("core");
+        Capability core_pkgCap = addCap(core, PackageNamespace.PACKAGE_NAMESPACE, "pkg1");
+        Capability core_bundleCap = addCap(core, BundleNamespace.BUNDLE_NAMESPACE,
+            "core");
+        Requirement core_pkgReq = addReq(core, PackageNamespace.PACKAGE_NAMESPACE,
+            "pkg1");
+
+        ResourceImpl misc = new ResourceImpl("misc");
+        Capability misc_pkgCap = addCap(misc, PackageNamespace.PACKAGE_NAMESPACE, "pkg1");
+        Capability misc_bundleCap = addCap(misc, BundleNamespace.BUNDLE_NAMESPACE,
+            "misc");
+        Requirement misc_bundleReq = addReq(misc, BundleNamespace.BUNDLE_NAMESPACE,
+            "core");
+
+        ResourceImpl importsCore = new ResourceImpl("importsCore");
+        Capability importsCore_pkgCap = addCap(importsCore,
+            PackageNamespace.PACKAGE_NAMESPACE, "pkg2", "pkg1");
+        Requirement importsCore_pkgReq = addReq(importsCore,
+            PackageNamespace.PACKAGE_NAMESPACE, "pkg1");
+
+        ResourceImpl requiresMisc = new ResourceImpl("requiresMisc");
+        Requirement requiresMisc_pkgReq = addReq(requiresMisc,
+            PackageNamespace.PACKAGE_NAMESPACE, "pkg2");
+        Requirement requiresMisc_bundleReq = addReq(requiresMisc,
+            BundleNamespace.BUNDLE_NAMESPACE, "misc");
+
+        ResourceImpl substitutesCore = new ResourceImpl("substitutesCore");
+        Capability substitutesCore_pkgCap = addCap(substitutesCore,
+            PackageNamespace.PACKAGE_NAMESPACE, "pkg1");
+
+        candMap.put(core_pkgReq, Collections.singletonList(
+            realSubstitute ? substitutesCore_pkgCap : core_pkgCap));
+        candMap.put(misc_bundleReq, Collections.singletonList(core_bundleCap));
+        candMap.put(importsCore_pkgReq, Collections.singletonList(
+            realSubstitute ? substitutesCore_pkgCap : core_pkgCap));
+        candMap.put(requiresMisc_pkgReq, Collections.singletonList(importsCore_pkgCap));
+        candMap.put(requiresMisc_bundleReq, Collections.singletonList(misc_bundleCap));
+
+        Map<Resource, List<Wire>> wires = new HashMap<Resource, List<Wire>>();
+        wires.put(substitutesCore, new ArrayList<Wire>());
+        wires.put(core, new ArrayList<Wire>());
+        if (realSubstitute)
+        {
+            wires.get(core).add(new SimpleWire(core_pkgReq, substitutesCore_pkgCap));
+        }
+        wires.put(misc, new ArrayList<Wire>());
+        wires.get(misc).add(new SimpleWire(misc_bundleReq, core_bundleCap));
+
+        Wiring coreWiring = null;
+        Map<Resource, Wiring> wirings = new HashMap<Resource, Wiring>();
+        if (existingWirings)
+        {
+            Map<Resource, List<Wire>> invertedWires = new HashMap<Resource, List<Wire>>();
+            invertedWires.put(substitutesCore, new ArrayList<Wire>());
+            if (realSubstitute)
+            {
+                invertedWires.get(substitutesCore).add(
+                    new SimpleWire(core_pkgReq, substitutesCore_pkgCap));
+            }
+            invertedWires.put(core, new ArrayList<Wire>());
+            invertedWires.get(core).add(new SimpleWire(misc_bundleReq, core_bundleCap));
+            invertedWires.put(misc, new ArrayList<Wire>());
+
+            wirings.put(substitutesCore, new SimpleWiring(substitutesCore,
+                Arrays.asList(substitutesCore_pkgCap), wires, invertedWires));
+
+            coreWiring = new SimpleWiring(core,
+                Arrays.asList(core_bundleCap, core_pkgCap), wires, invertedWires);
+            wirings.put(core, coreWiring);
+            wirings.put(misc, new SimpleWiring(misc,
+                Arrays.asList(misc_bundleCap, misc_pkgCap), wires, invertedWires));
+        }
+        Collection<Resource> mandatory = Collections.<Resource> singletonList(requiresMisc);
+        if (felixResolveContext) {
+            Map<Wiring, Collection<Wire>> substitutions = new HashMap<Wiring, Collection<Wire>>();
+            if (realSubstitute && coreWiring != null)
+            {
+                substitutions.put(coreWiring, Arrays.<Wire> asList(
+                    new SimpleWire(core_pkgReq, substitutesCore_pkgCap)));
+            }
+            return new ResolveContextImpl.FelixResolveContextImpl(wirings, candMap,
+                mandatory, Collections.<Resource> emptyList(), substitutions);
+        }
+        else
+        {
+            return new ResolveContextImpl(wirings, candMap, mandatory,
+                Collections.<Resource> emptyList());
+        }
+    }
+
     private static String getResourceName(Resource r)
     {
         return r.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0).getAttributes()
@@ -1379,3 +1522,4 @@ public class ResolverTest
         }
     }
 }
+
diff --git a/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/util/ResolveContextImpl.java b/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/util/ResolveContextImpl.java
index eb34911748..52e96f379c 100644
--- a/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/util/ResolveContextImpl.java
+++ b/osgi-r7/resolver/src/test/java/org/apache/felix/resolver/test/util/ResolveContextImpl.java
@@ -20,11 +20,15 @@ package org.apache.felix.resolver.test.util;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+
+import org.apache.felix.resolver.FelixResolveContext;
 import org.osgi.resource.Capability;
 import org.osgi.resource.Requirement;
 import org.osgi.resource.Resource;
+import org.osgi.resource.Wire;
 import org.osgi.resource.Wiring;
 import org.osgi.service.resolver.HostedCapability;
 import org.osgi.service.resolver.ResolveContext;
@@ -88,4 +92,27 @@ public class ResolveContextImpl extends ResolveContext
     {
         return m_wirings;
     }
+
+    public static class FelixResolveContextImpl extends ResolveContextImpl implements FelixResolveContext
+    {
+        private final Map<Wiring, Collection<Wire>> m_substitutions;
+
+        public FelixResolveContextImpl(Map<Resource, Wiring> wirings, Map<Requirement, List<Capability>> candMap, Collection<Resource> mandatory, Collection<Resource> optional, Map<Wiring, Collection<Wire>> substitutions)
+        {
+            super(wirings, candMap, mandatory, optional);
+            this.m_substitutions = substitutions;
+        }
+
+        public Collection<Resource> getOndemandResources(Resource host)
+        {
+            return Collections.emptyList();
+        }
+
+        public Collection<Wire> getSubstitutionWires(Wiring wiring)
+        {
+            Collection<Wire> result = m_substitutions.get(wiring);
+            return result == null ? Collections.<Wire> emptyList() : result;
+        }
+
+    }
 }
\ No newline at end of file
