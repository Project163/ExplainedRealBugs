diff --git a/http.jetty/pom.xml b/http.jetty/pom.xml
index b118dd2fdd..583fa77cba 100644
--- a/http.jetty/pom.xml
+++ b/http.jetty/pom.xml
@@ -21,7 +21,6 @@
       <groupId>${pom.groupId}</groupId>
       <artifactId>org.osgi.compendium</artifactId>
       <version>0.9.0-SNAPSHOT</version>
-      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>${pom.groupId}</groupId>
@@ -54,7 +53,7 @@
             <DynamicImport-Package>javax.net.ssl</DynamicImport-Package>
             <Export-Package>org.osgi.service.http; version=1.1</Export-Package>
             <Import-Package>!com.sun.net.ssl.internal.ssl,!com.sun.net.ssl,!org.xml.sax,!org.xml.sax.helpers,!javax.xml.parsers,!javax.security.cert,javax.servlet;version=1.1, javax.servlet.http;version=1.1,*</Import-Package>
-	    <Private-Package>org.apache.felix.http.jetty, org.mortbay.*</Private-Package>
+	        <Private-Package>org.apache.felix.http.jetty, org.mortbay.*;-split-package:=merge-first</Private-Package>
             <Export-Service>org.osgi.service.http.HttpService</Export-Service>
           </instructions>
         </configuration>
diff --git a/http.jetty/src/main/java/org/apache/felix/http/jetty/Activator.java b/http.jetty/src/main/java/org/apache/felix/http/jetty/Activator.java
index d0583c6b82..20bd058543 100644
--- a/http.jetty/src/main/java/org/apache/felix/http/jetty/Activator.java
+++ b/http.jetty/src/main/java/org/apache/felix/http/jetty/Activator.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,17 +18,25 @@
  */
 package org.apache.felix.http.jetty;
 
+
 import java.lang.reflect.Constructor;
 
 import org.mortbay.http.HashUserRealm;
 import org.mortbay.http.HttpServer;
+import org.mortbay.http.JsseListener;
 import org.mortbay.http.SocketListener;
+import org.mortbay.jetty.servlet.OsgiServletHandler;
+import org.mortbay.jetty.servlet.ServletHttpContext;
 import org.mortbay.util.Code;
 import org.mortbay.util.InetAddrPort;
-import org.osgi.framework.*;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.ServiceFactory;
+import org.osgi.framework.ServiceRegistration;
 import org.osgi.service.http.HttpService;
-import org.mortbay.http.SunJsseListener;
-import org.mortbay.http.JsseListener;
+
 
 /**
  *  Basic implementation of OSGi HTTP service 1.1.
@@ -58,37 +66,34 @@ public class Activator implements BundleActivator
 
     private BundleContext m_bundleContext = null;
     private ServiceRegistration m_svcReg = null;
-    private HttpServiceFactory  m_httpServ = null;
+    private HttpServiceFactory m_httpServ = null;
     private HttpServer m_server = null;
+    private OsgiServletHandler m_hdlr = null;
 
     private int m_httpPort;
     private int m_httpsPort;
 
 
-    public void start(BundleContext bundleContext)
-        throws BundleException
+    public void start( BundleContext bundleContext ) throws BundleException
     {
         m_bundleContext = bundleContext;
 
         // org.mortbay.util.Loader needs this (used for JDK 1.4 log classes)
-        Thread.currentThread().setContextClassLoader(
-                this.getClass().getClassLoader());
-        
-        String optDebug =
-            m_bundleContext.getProperty("org.apache.felix.http.jetty.debug");
-        if (optDebug != null && optDebug.toLowerCase().equals("true"))
-        {
-            Code.setDebug(true);
+        Thread.currentThread().setContextClassLoader( this.getClass().getClassLoader() );
+
+        String optDebug = m_bundleContext.getProperty( "org.apache.felix.http.jetty.debug" );
+        if ( optDebug != null && optDebug.toLowerCase().equals( "true" ) )
+        {
+            Code.setDebug( true );
             debug = true;
         }
 
         // get default HTTP and HTTPS ports as per the OSGi spec
         try
         {
-            m_httpPort = Integer.parseInt(m_bundleContext.getProperty(
-                    "org.osgi.service.http.port"));
+            m_httpPort = Integer.parseInt( m_bundleContext.getProperty( "org.osgi.service.http.port" ) );
         }
-        catch (Exception e)
+        catch ( Exception e )
         {
             // maybe log a message saying using default?
             m_httpPort = 80;
@@ -97,10 +102,9 @@ public class Activator implements BundleActivator
         try
         {
             // TODO: work out how/when we should use the HTTPS port
-            m_httpsPort = Integer.parseInt(m_bundleContext.getProperty(
-                    "org.osgi.service.http.port.secure"));
+            m_httpsPort = Integer.parseInt( m_bundleContext.getProperty( "org.osgi.service.http.port.secure" ) );
         }
-        catch (Exception e)
+        catch ( Exception e )
         {
             // maybe log a message saying using default?
             m_httpsPort = 443;
@@ -110,24 +114,24 @@ public class Activator implements BundleActivator
         {
             initializeJetty();
 
-        } catch (Exception ex) {
+        }
+        catch ( Exception ex )
+        {
             //TODO: maybe throw a bundle exception in here?
-            System.out.println("Http2: " + ex);
+            System.out.println( "Http2: " + ex );
             return;
         }
 
         m_httpServ = new HttpServiceFactory();
-        m_svcReg = m_bundleContext.registerService(
-            HttpService.class.getName(), m_httpServ, null);
+        m_svcReg = m_bundleContext.registerService( HttpService.class.getName(), m_httpServ, null );
     }
 
-    
-    public void stop(BundleContext bundleContext)
-        throws BundleException
+
+    public void stop( BundleContext bundleContext ) throws BundleException
     {
         //TODO: wonder if we need to closedown service factory ???
 
-        if (m_svcReg != null)
+        if ( m_svcReg != null )
         {
             m_svcReg.unregister();
         }
@@ -136,89 +140,113 @@ public class Activator implements BundleActivator
         {
             m_server.stop();
         }
-        catch (Exception e)
+        catch ( Exception e )
         {
             //TODO: log some form of error
         }
     }
 
-    protected void initializeJetty()
-        throws Exception
+
+    protected void initializeJetty() throws Exception
     {
         //TODO: Maybe create a separate "JettyServer" object here?
         // Realm
-        HashUserRealm realm =
-            new HashUserRealm("OSGi HTTP Service Realm");
+        HashUserRealm realm = new HashUserRealm( "OSGi HTTP Service Realm" );
 
         // Create server
         m_server = new HttpServer();
-        m_server.addRealm(realm);
+        m_server.addRealm( realm );
 
         // Add a regular HTTP listener
         SocketListener listener = null;
-        listener = (SocketListener)
-            m_server.addListener(new InetAddrPort(m_httpPort));        
-        listener.setMaxIdleTimeMs(60000);
-        
+        listener = ( SocketListener ) m_server.addListener( new InetAddrPort( m_httpPort ) );
+        listener.setMaxIdleTimeMs( 60000 );
+
         // See if we need to add an HTTPS listener
-        String enableHTTPS = m_bundleContext.getProperty("org.ungoverned.osgi.bundle.https.enable");
-        if (enableHTTPS != null && enableHTTPS.toLowerCase().equals("true"))
+        String enableHTTPS = m_bundleContext.getProperty( "org.ungoverned.osgi.bundle.https.enable" );
+        if ( enableHTTPS != null && enableHTTPS.toLowerCase().equals( "true" ) )
         {
             initializeHTTPS();
         }
-        
+
         m_server.start();
+
+        // setup the Jetty web application context shared by all Http services
+        ServletHttpContext hdlrContext = new ServletHttpContext();
+        hdlrContext.setContextPath( "/" );
+        //TODO: was in original code, but seems we shouldn't serve
+        //      resources in servlet context
+        //hdlrContext.setServingResources(true);
+        hdlrContext.setClassLoader( getClass().getClassLoader() );
+        debug( " adding handler context : " + hdlrContext );
+        m_server.addContext( hdlrContext );
+
+        m_hdlr = new OsgiServletHandler();
+        hdlrContext.addHandler( m_hdlr );
+
+        try
+        {
+            hdlrContext.start();
+        }
+        catch ( Exception e )
+        {
+            // make sure we unwind the adding process
+            System.err.println( "Exception Starting Jetty Handler Context: " + e );
+            e.printStackTrace( System.err );
+        }
     }
 
+
     //TODO: Just a basic implementation to give us a working HTTPS port. A better
-    //      long-term solution may be to separate out the SSL provider handling, 
+    //      long-term solution may be to separate out the SSL provider handling,
     //      keystore, passwords etc. into it's own pluggable service
-    protected void initializeHTTPS()
-        throws Exception
+    protected void initializeHTTPS() throws Exception
     {
-        String sslProvider = m_bundleContext.getProperty("org.ungoverned.osgi.bundle.https.provider");
-        if (sslProvider == null)
+        String sslProvider = m_bundleContext.getProperty( "org.ungoverned.osgi.bundle.https.provider" );
+        if ( sslProvider == null )
         {
             sslProvider = "org.mortbay.http.SunJsseListener";
         }
 
-        // Set default jetty properties for supplied values. For any not set, 
+        // Set default jetty properties for supplied values. For any not set,
         // Jetty will fallback to checking system properties.
-        String keystore = m_bundleContext.getProperty("org.ungoverned.osgi.bundle.https.keystore");
-        if (keystore != null)
+        String keystore = m_bundleContext.getProperty( "org.ungoverned.osgi.bundle.https.keystore" );
+        if ( keystore != null )
         {
-            System.setProperty(JsseListener.KEYSTORE_PROPERTY, keystore);
+            System.setProperty( JsseListener.KEYSTORE_PROPERTY, keystore );
         }
 
-        String passwd = m_bundleContext.getProperty("org.ungoverned.osgi.bundle.https.password");
-        if (passwd != null)
+        String passwd = m_bundleContext.getProperty( "org.ungoverned.osgi.bundle.https.password" );
+        if ( passwd != null )
         {
-            System.setProperty(JsseListener.PASSWORD_PROPERTY, passwd);
+            System.setProperty( JsseListener.PASSWORD_PROPERTY, passwd );
         }
-        
-        String keyPasswd = m_bundleContext.getProperty("org.ungoverned.osgi.bundle.https.key.password");
-        if (keyPasswd != null)
+
+        String keyPasswd = m_bundleContext.getProperty( "org.ungoverned.osgi.bundle.https.key.password" );
+        if ( keyPasswd != null )
         {
-            System.setProperty(JsseListener.KEYPASSWORD_PROPERTY, keyPasswd);
+            System.setProperty( JsseListener.KEYPASSWORD_PROPERTY, keyPasswd );
         }
 
         //SunJsseListener s_listener = new SunJsseListener(new InetAddrPort(m_httpsPort));
-        Object args[] = { new InetAddrPort(m_httpsPort) };
-        Class argTypes[] = { args[0].getClass() };
-        Class clazz = Class.forName(sslProvider);
-        Constructor cstruct = clazz.getDeclaredConstructor(argTypes);
-        JsseListener s_listener = (JsseListener) cstruct.newInstance(args);
-
-        m_server.addListener(s_listener);        
-        s_listener.setMaxIdleTimeMs(60000);
+        Object args[] =
+            { new InetAddrPort( m_httpsPort ) };
+        Class argTypes[] =
+            { args[0].getClass() };
+        Class clazz = Class.forName( sslProvider );
+        Constructor cstruct = clazz.getDeclaredConstructor( argTypes );
+        JsseListener s_listener = ( JsseListener ) cstruct.newInstance( args );
+
+        m_server.addListener( s_listener );
+        s_listener.setMaxIdleTimeMs( 60000 );
     }
 
-    
-    protected static void debug(String txt)
+
+    protected static void debug( String txt )
     {
-        if (debug)
+        if ( debug )
         {
-            System.err.println(">>Oscar HTTP: " + txt);
+            System.err.println( ">>Oscar HTTP: " + txt );
         }
     }
 
@@ -232,21 +260,20 @@ public class Activator implements BundleActivator
             HttpServiceImpl.initializeStatics();
         }
 
-        public Object getService(Bundle bundle,
-                ServiceRegistration registration)
+
+        public Object getService( Bundle bundle, ServiceRegistration registration )
         {
-            Object srv = new HttpServiceImpl(bundle, m_server); 
-            debug("** http service get:" + bundle + ", service: " + srv);
+            Object srv = new HttpServiceImpl( bundle, m_server, m_hdlr );
+            debug( "** http service get:" + bundle + ", service: " + srv );
             return srv;
         }
 
-        public void ungetService(Bundle bundle,
-                ServiceRegistration registration, Object service)
+
+        public void ungetService( Bundle bundle, ServiceRegistration registration, Object service )
         {
-            debug("** http service unget:" + bundle + ", service: " 
-            + service);
-            ((HttpServiceImpl) service).unregisterAll();
+            debug( "** http service unget:" + bundle + ", service: " + service );
+            ( ( HttpServiceImpl ) service ).unregisterAll();
         }
     }
-    
+
 }
\ No newline at end of file
diff --git a/http.jetty/src/main/java/org/apache/felix/http/jetty/DefaultContextImpl.java b/http.jetty/src/main/java/org/apache/felix/http/jetty/DefaultContextImpl.java
index 14f0a96f0b..ab832c4a93 100644
--- a/http.jetty/src/main/java/org/apache/felix/http/jetty/DefaultContextImpl.java
+++ b/http.jetty/src/main/java/org/apache/felix/http/jetty/DefaultContextImpl.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,6 +18,7 @@
  */
 package org.apache.felix.http.jetty;
 
+
 import java.net.URL;
 
 import javax.servlet.http.HttpServletRequest;
@@ -26,6 +27,7 @@ import javax.servlet.http.HttpServletResponse;
 import org.osgi.framework.Bundle;
 import org.osgi.service.http.HttpContext;
 
+
 /**
  * Implementation of default HttpContext as per OSGi specification.
  *
@@ -40,35 +42,38 @@ public class DefaultContextImpl implements HttpContext
 {
     private Bundle m_bundle;
 
-    public DefaultContextImpl(Bundle bundle)
+
+    public DefaultContextImpl( Bundle bundle )
     {
         m_bundle = bundle;
     }
 
-    public String getMimeType(String name)
+
+    public String getMimeType( String name )
     {
         return null;
     }
 
-    public URL getResource(String name)
+
+    public URL getResource( String name )
     {
         //TODO: need to grant "org.osgi.framework.AdminPermission" when
         //      permissions are included.
-        Activator.debug("getResource for:" + name);
+        Activator.debug( "getResource for:" + name );
 
         //TODO: temp measure for name. Bundle classloading doesn't seem to find
         // resources which have a leading "/". This code should be removed
         // if the bundle classloader is changed to allow a leading "/"
-        if (name.startsWith("/"))
+        if ( name.startsWith( "/" ) )
         {
-            name = name.substring(1);
+            name = name.substring( 1 );
         }
 
-        return m_bundle.getResource(name);
+        return m_bundle.getResource( name );
     }
 
-    public boolean handleSecurity(HttpServletRequest request,
-        HttpServletResponse response)
+
+    public boolean handleSecurity( HttpServletRequest request, HttpServletResponse response )
     {
         //TODO: need to look into what's appropriate for default security
         //      handling. Default to all requests to be serviced for now.
diff --git a/http.jetty/src/main/java/org/apache/felix/http/jetty/HttpServiceImpl.java b/http.jetty/src/main/java/org/apache/felix/http/jetty/HttpServiceImpl.java
index c49d1a6e2e..29dfa6f9e0 100644
--- a/http.jetty/src/main/java/org/apache/felix/http/jetty/HttpServiceImpl.java
+++ b/http.jetty/src/main/java/org/apache/felix/http/jetty/HttpServiceImpl.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,222 +18,208 @@
  */
 package org.apache.felix.http.jetty;
 
+
 import java.security.AccessControlContext;
 import java.security.AccessController;
-import java.util.*;
+import java.util.Dictionary;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 
 import javax.servlet.Servlet;
 import javax.servlet.ServletException;
 
 import org.mortbay.http.HttpServer;
-import org.mortbay.jetty.servlet.*;
+import org.mortbay.jetty.servlet.OsgiServletHandler;
 import org.osgi.framework.Bundle;
+import org.osgi.service.http.HttpContext;
 import org.osgi.service.http.HttpService;
 import org.osgi.service.http.NamespaceException;
 
+
 public class HttpServiceImpl implements HttpService
 {
     /** global namesspace of all aliases that have been registered */
-    private static Map      m_aliasNamespace = null;
-    /** global pool of all OSGi HttpContext that have been created */
-    private static Map      m_contextMap = null;
-    /** global set of all servlet instances that have been registered */
-    private static Set      m_servletSet = null;
+    private static Map m_aliasNamespace = null;
 
     /** local list of aliases registered by the bundle holding this service */
     private Set m_localAliasSet = null;
 
     /** Bundle which "got" this service instance from the service factory */
     private Bundle m_bundle = null;
-    /** Instance of Jetty server which provides underlying http server */
     private HttpServer m_server = null;
+    private OsgiServletHandler m_serverServletHandler = null;
 
-    public HttpServiceImpl(Bundle bundle, HttpServer server)
+
+    public HttpServiceImpl( Bundle bundle, HttpServer server, OsgiServletHandler serverServletHandler )
     {
         m_bundle = bundle;
         m_server = server;
+        m_serverServletHandler = serverServletHandler;
         m_localAliasSet = new HashSet();
 
-        if (m_aliasNamespace == null)
+        if ( m_aliasNamespace == null )
         {
             m_aliasNamespace = new HashMap();
         }
-
-        if (m_contextMap == null)
-        {
-            m_contextMap = new HashMap();
-        }
-
-        if (m_servletSet == null)
-        {
-            m_servletSet = new HashSet();
-        }
     }
 
+
     /**
      * Initializes static variables.
     **/
     public static void initializeStatics()
     {
-        if (m_aliasNamespace != null)
+        if ( m_aliasNamespace != null )
         {
             m_aliasNamespace.clear();
         }
-        if (m_contextMap != null)
-        {
-            m_contextMap.clear();
-        }
-        if (m_servletSet != null)
-        {
-            m_servletSet.clear();
-        }
+        ServletContextGroup.initializeStatics();
     }
 
-    public org.osgi.service.http.HttpContext createDefaultHttpContext()
+
+    public HttpContext createDefaultHttpContext()
     {
-        return new DefaultContextImpl(m_bundle);
+        return new DefaultContextImpl( m_bundle );
     }
 
-    public void registerServlet(String alias, Servlet servlet,
-        Dictionary params, org.osgi.service.http.HttpContext osgiHttpContext)
+
+    public void registerServlet( String alias, Servlet servlet, Dictionary params, HttpContext osgiHttpContext )
         throws ServletException, NamespaceException
     {
-        Activator.debug("http register servlet :" + m_bundle + ", alias: " + alias);
+        Activator.debug( "http register servlet :" + m_bundle + ", alias: " + alias );
 
-        if (!aliasValid(alias))
+        if ( !aliasValid( alias ) )
         {
-            throw new IllegalArgumentException("malformed alias");
+            throw new IllegalArgumentException( "malformed alias" );
         }
 
-        if (m_servletSet.contains(servlet))
+        if ( ServletContextGroup.isServletRegistered( servlet ) )
         {
-            throw new ServletException("servlet already registered");
+            throw new ServletException( "servlet already registered" );
         }
 
         // add alias with null details, and record servlet instance details
-        addAlias(alias, null);
+        addAlias( alias, null );
 
         //make sure alias is unique, and create
         ServletContextGroup grp = null;
 
-        if (osgiHttpContext == null)
+        if ( osgiHttpContext == null )
         {
             osgiHttpContext = createDefaultHttpContext();
         }
 
         // servlets using same context must get same handler to ensure
         // they share a common ServletContext
-        Activator.debug("looking for context: " + osgiHttpContext);
-        grp = (ServletContextGroup) m_contextMap.get(osgiHttpContext);
-        if (grp == null)
-        {
-            grp = new ServletContextGroup(
-                    servlet.getClass().getClassLoader(), osgiHttpContext);
-        }
+        Activator.debug( "looking for context: " + osgiHttpContext );
+        grp = ServletContextGroup.getServletContextGroup( m_serverServletHandler, osgiHttpContext );
 
-        grp.addServlet(servlet, alias, params);
+        grp.addServlet( servlet, alias, params );
 
         // update alias namespace with reference to group object for later
         // unregistering
-        updateAlias(alias, grp);
+        updateAlias( alias, grp );
 
         // maybe should remove alias/servlet entries if exceptions?
     }
 
-    public void registerResources(String alias, String name,
-        org.osgi.service.http.HttpContext osgiHttpContext)
-        throws NamespaceException
+
+    public void registerResources( String alias, String name, HttpContext osgiHttpContext ) throws NamespaceException
     {
-        Activator.debug("** http register resource :" + m_bundle + ", alias: " + alias);
+        Activator.debug( "** http register resource :" + m_bundle + ", alias: " + alias );
 
-        if (!aliasValid(alias))
+        if ( !aliasValid( alias ) )
         {
-            throw new IllegalArgumentException("malformed alias");
+            throw new IllegalArgumentException( "malformed alias" );
         }
 
         // add alias with null details
-        addAlias(alias, null);
+        addAlias( alias, null );
 
         //make sure alias is unique, and create
         org.mortbay.http.HttpContext hdlrContext = null;
 
-        if (osgiHttpContext == null)
+        if ( osgiHttpContext == null )
         {
             osgiHttpContext = createDefaultHttpContext();
         }
 
-        hdlrContext = m_server.addContext(alias);
+        hdlrContext = m_server.addContext( alias );
 
         // update alias namespace with reference to context object for later
         // unregistering
-        updateAlias(alias, hdlrContext);
+        updateAlias( alias, hdlrContext );
 
         // create resource handler, observing any access controls
         AccessControlContext acc = null;
-        if (System.getSecurityManager() != null)
+        if ( System.getSecurityManager() != null )
         {
             acc = AccessController.getContext();
         }
-        OsgiResourceHandler hdlr = new OsgiResourceHandler(osgiHttpContext,
-                name, acc);
+        OsgiResourceHandler hdlr = new OsgiResourceHandler( osgiHttpContext, name, acc );
 
-        hdlrContext.addHandler(hdlr);
+        hdlrContext.addHandler( hdlr );
         try
         {
             hdlrContext.start();
         }
-        catch (Exception e)
+        catch ( Exception e )
         {
-            System.err.println("Oscar exception adding resource: " + e);
-            e.printStackTrace(System.err);
+            System.err.println( "Oscar exception adding resource: " + e );
+            e.printStackTrace( System.err );
             // maybe we should remove alias here?
         }
     }
 
-    public void unregister(String alias)
+
+    public void unregister( String alias )
     {
-        doUnregister(alias, true);
+        doUnregister( alias, true );
     }
 
+
     protected void unregisterAll()
     {
         // note that this is a forced unregister, so we shouldn't call destroy
         // on any servlets
         // unregister each alias for the bundle - copy list since it will
         // change
-        String[] all = (String[]) m_localAliasSet.toArray(new String[0]);
-        for (int ix = 0; ix < all.length; ix++)
+        String[] all = ( String[] ) m_localAliasSet.toArray( new String[0] );
+        for ( int ix = 0; ix < all.length; ix++ )
         {
-            doUnregister(all[ix], false);
+            doUnregister( all[ix], false );
         }
     }
 
-    protected void doUnregister(String alias, boolean forced)
+
+    protected void doUnregister( String alias, boolean forced )
     {
-        Object obj = removeAlias(alias);
+        Object obj = removeAlias( alias );
 
-        if (obj instanceof org.mortbay.http.HttpContext)
+        if ( obj instanceof org.mortbay.http.HttpContext )
         {
-            Activator.debug("** http unregister resource :" + m_bundle + ", alias: " + alias);
+            Activator.debug( "** http unregister resource :" + m_bundle + ", alias: " + alias );
 
-            org.mortbay.http.HttpContext ctxt = (org.mortbay.http.HttpContext) obj;
+            org.mortbay.http.HttpContext ctxt = ( org.mortbay.http.HttpContext ) obj;
             try
             {
                 ctxt.stop();
-                m_server.removeContext(ctxt);
+                m_server.removeContext( ctxt );
             }
-            catch(Exception e)
+            catch ( Exception e )
             {
-                System.err.println("Oscar exception removing resource: " + e);
+                System.err.println( "Oscar exception removing resource: " + e );
                 e.printStackTrace();
             }
         }
-        else if (obj instanceof ServletContextGroup)
+        else if ( obj instanceof ServletContextGroup )
         {
-            Activator.debug("** http unregister servlet :" + m_bundle + ", alias: " + alias + ",forced:" + forced);
+            Activator.debug( "** http unregister servlet :" + m_bundle + ", alias: " + alias + ",forced:" + forced );
 
-            ServletContextGroup grp = (ServletContextGroup) obj;
-            grp.removeServlet(alias, forced);
+            ServletContextGroup grp = ( ServletContextGroup ) obj;
+            grp.removeServlet( alias, forced );
         }
         else
         {
@@ -241,140 +227,54 @@ public class HttpServiceImpl implements HttpService
         }
     }
 
-    protected void addAlias(String alias, Object obj)
-            throws NamespaceException
+
+    protected void addAlias( String alias, Object obj ) throws NamespaceException
     {
-        synchronized (m_aliasNamespace)
+        synchronized ( m_aliasNamespace )
         {
-            if (m_aliasNamespace.containsKey(alias))
+            if ( m_aliasNamespace.containsKey( alias ) )
             {
-                throw new NamespaceException("alias already registered");
+                throw new NamespaceException( "alias already registered" );
             }
 
-            m_aliasNamespace.put(alias, obj);
-            m_localAliasSet.add(alias);
+            m_aliasNamespace.put( alias, obj );
+            m_localAliasSet.add( alias );
         }
     }
 
-    protected Object removeAlias(String alias)
+
+    protected Object removeAlias( String alias )
     {
-        synchronized (m_aliasNamespace)
+        synchronized ( m_aliasNamespace )
         {
             // remove alias, don't worry if doesn't exist
-            Object obj = m_aliasNamespace.remove(alias);
-            m_localAliasSet.remove(alias);
+            Object obj = m_aliasNamespace.remove( alias );
+            m_localAliasSet.remove( alias );
             return obj;
         }
     }
 
-    protected void updateAlias(String alias, Object obj)
+
+    protected void updateAlias( String alias, Object obj )
     {
-        synchronized (m_aliasNamespace)
+        synchronized ( m_aliasNamespace )
         {
             // only update if already present
-            if (m_aliasNamespace.containsKey(alias))
+            if ( m_aliasNamespace.containsKey( alias ) )
             {
-                m_aliasNamespace.put(alias, obj);
+                m_aliasNamespace.put( alias, obj );
             }
         }
     }
 
-    protected boolean aliasValid(String alias)
+
+    protected boolean aliasValid( String alias )
     {
-       if (!alias.equals("/") &&
-            (!alias.startsWith("/") || alias.endsWith("/")))
+        if ( !alias.equals( "/" ) && ( !alias.startsWith( "/" ) || alias.endsWith( "/" ) ) )
         {
             return false;
         }
 
         return true;
     }
-
-    private class ServletContextGroup
-    {
-        private OsgiServletHttpContext m_hdlrContext = null;
-        private OsgiServletHandler m_hdlr = null;
-        private org.osgi.service.http.HttpContext m_osgiHttpContext = null;
-        private int m_servletCount = 0;
-
-        private ServletContextGroup(ClassLoader loader,
-                org.osgi.service.http.HttpContext osgiHttpContext)
-        {
-            init(loader, osgiHttpContext);
-        }
-
-        private void init(ClassLoader loader,
-                org.osgi.service.http.HttpContext osgiHttpContext)
-        {
-            m_osgiHttpContext = osgiHttpContext;
-            m_hdlrContext = new OsgiServletHttpContext(m_osgiHttpContext);
-            m_hdlrContext.setContextPath("/");
-            //TODO: was in original code, but seems we shouldn't serve
-            //      resources in servlet context
-            //m_hdlrContext.setServingResources(true);
-            m_hdlrContext.setClassLoader(loader);
-            Activator.debug(" adding handler context : " + m_hdlrContext);
-            m_server.addContext(m_hdlrContext);
-
-            m_hdlr = new OsgiServletHandler(m_osgiHttpContext);
-            m_hdlrContext.addHandler(m_hdlr);
-
-            try
-            {
-                m_hdlrContext.start();
-            }
-            catch (Exception e)
-            {
-                // make sure we unwind the adding process
-                System.err.println("Oscar exception adding servlet: " + e);
-                e.printStackTrace(System.err);
-            }
-
-            m_contextMap.put(m_osgiHttpContext, this);
-        }
-
-        private void destroy()
-        {
-            Activator.debug(" removing handler context : " + m_hdlrContext);
-            m_server.removeContext(m_hdlrContext);
-            m_contextMap.remove(m_osgiHttpContext);
-        }
-
-        private void addServlet(Servlet servlet, String alias,
-                Dictionary params)
-        {
-            String wAlias = aliasWildcard(alias);
-            ServletHolder holder = new OsgiServletHolder(m_hdlr, servlet, wAlias, params);
-            m_hdlr.addOsgiServletHolder(wAlias, holder);
-            Activator.debug(" adding servlet instance: " + servlet);
-            m_servletSet.add(servlet);
-            m_servletCount++;
-        }
-
-        private void removeServlet(String alias, boolean destroy)
-        {
-            String wAlias = aliasWildcard(alias);
-            OsgiServletHolder holder = m_hdlr.removeOsgiServletHolder(wAlias);
-            Servlet servlet = holder.getOsgiServlet();
-            Activator.debug(" removing servlet instance: " + servlet);
-            m_servletSet.remove(servlet);
-
-            if (destroy)
-            {
-                servlet.destroy();
-            }
-
-            if (--m_servletCount == 0)
-            {
-                destroy();
-            }
-        }
-        
-        private String aliasWildcard(String alias)
-        {
-            // add wilcard filter at the end of the alias to allow servlet to
-            // get requests which include sub-paths
-            return "/".equals(alias) ? "/*" : alias + "/*";
-        } 
-    }
 }
\ No newline at end of file
diff --git a/http.jetty/src/main/java/org/apache/felix/http/jetty/OsgiResourceHandler.java b/http.jetty/src/main/java/org/apache/felix/http/jetty/OsgiResourceHandler.java
index 0e942a91ad..f6c81b30fe 100644
--- a/http.jetty/src/main/java/org/apache/felix/http/jetty/OsgiResourceHandler.java
+++ b/http.jetty/src/main/java/org/apache/felix/http/jetty/OsgiResourceHandler.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,194 +18,196 @@
  */
 package org.apache.felix.http.jetty;
 
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.URL;
-import java.security.*;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 import org.mortbay.http.HttpException;
 import org.mortbay.http.HttpRequest;
 import org.mortbay.http.HttpResponse;
 import org.mortbay.http.handler.AbstractHttpHandler;
-import org.mortbay.jetty.servlet.*;
+import org.mortbay.jetty.servlet.DummyServletHttpRequest;
+import org.mortbay.jetty.servlet.DummyServletHttpResponse;
+import org.mortbay.jetty.servlet.OsgiServletHandler;
+import org.mortbay.jetty.servlet.ServletHttpRequest;
+import org.mortbay.jetty.servlet.ServletHttpResponse;
+import org.osgi.service.http.HttpContext;
+
 
-/**
- *
- */
 public class OsgiResourceHandler extends AbstractHttpHandler
 {
-    protected org.osgi.service.http.HttpContext     m_osgiHttpContext;
-    protected String                                m_name;
-    protected OsgiServletHandler                    m_dummyHandler;
-    protected AccessControlContext                  m_acc;
-
-    
-    public OsgiResourceHandler(
-            org.osgi.service.http.HttpContext osgiHttpContext, String name,
-            AccessControlContext acc)
+    protected HttpContext m_osgiHttpContext;
+    protected String m_name;
+    protected OsgiServletHandler m_dummyHandler;
+    protected AccessControlContext m_acc;
+
+
+    public OsgiResourceHandler( HttpContext osgiHttpContext, String name, AccessControlContext acc )
     {
         m_osgiHttpContext = osgiHttpContext;
         m_name = name;
         // needed for OSGi security handling
-        m_dummyHandler = new OsgiServletHandler(osgiHttpContext);
+        m_dummyHandler = new OsgiServletHandler();
         m_acc = acc;
     }
 
-    
-    public void initialize(org.mortbay.http.HttpContext context)
+
+    public void initialize( org.mortbay.http.HttpContext context )
     {
-        super.initialize(context);
-        m_dummyHandler.initialize(context);
+        super.initialize( context );
+        m_dummyHandler.initialize( context );
     }
 
-    
-    public void handle(String pathInContext,
-                       String pathParams,
-                       HttpRequest request,
-                       HttpResponse response)
+
+    public void handle( String pathInContext, String pathParams, HttpRequest request, HttpResponse response )
         throws HttpException, IOException
     {
-        Activator.debug("handle for name:" + m_name
-                + "(path=" + pathInContext + ")");
+        Activator.debug( "handle for name:" + m_name + "(path=" + pathInContext + ")" );
 
-        ServletHttpRequest servletRequest = new DummyServletHttpRequest(
-                m_dummyHandler, pathInContext, request);
-        ServletHttpResponse servletResponse = new DummyServletHttpResponse(
-                servletRequest, response);
+        ServletHttpRequest servletRequest = new DummyServletHttpRequest( m_dummyHandler, pathInContext, request );
+        ServletHttpResponse servletResponse = new DummyServletHttpResponse( servletRequest, response );
 
-        if (!m_osgiHttpContext.handleSecurity(servletRequest, servletResponse))
+        if ( !m_osgiHttpContext.handleSecurity( servletRequest, servletResponse ) )
         {
-            // spec doesn't state specific processing here apart from 
+            // spec doesn't state specific processing here apart from
             // "send the response back to the client". We take this to mean
             // any response generated in the context, and so all we do here
             // is set handled to "true" to ensure any output is sent back
-            request.setHandled(true);
+            request.setHandled( true );
             return;
         }
 
         // Create resource based name and see if we can resolve it
         String resName = m_name + pathInContext;
-        Activator.debug("** looking for: " + resName); 
-        URL url = m_osgiHttpContext.getResource(resName);
+        Activator.debug( "** looking for: " + resName );
+        URL url = m_osgiHttpContext.getResource( resName );
 
-        if (url == null)
+        if ( url == null )
         {
             return;
         }
-        
-        Activator.debug("serving up:" + resName);
+
+        Activator.debug( "serving up:" + resName );
 
         // It doesn't state so in the OSGi spec, but can't see how anything
         // other than GET and variants would be supported
-        String method=request.getMethod();
-        if (method.equals(HttpRequest.__GET) ||
-            method.equals(HttpRequest.__POST) ||
-            method.equals(HttpRequest.__HEAD))
+        String method = request.getMethod();
+        if ( method.equals( HttpRequest.__GET ) || method.equals( HttpRequest.__POST )
+            || method.equals( HttpRequest.__HEAD ) )
         {
-            handleGet(request, response, url, resName);
+            handleGet( request, response, url, resName );
         }
         else
         {
             try
             {
-                response.sendError(HttpResponse.__501_Not_Implemented);
+                response.sendError( HttpResponse.__501_Not_Implemented );
+            }
+            catch ( Exception e )
+            {/*TODO: include error logging*/
             }
-            catch(Exception e) {/*TODO: include error logging*/}
         }
     }
 
-    
-    public void handleGet(HttpRequest request, final HttpResponse response, 
-            final URL url, String resName)
+
+    public void handleGet( HttpRequest request, final HttpResponse response, final URL url, String resName )
         throws IOException
     {
-        String encoding = m_osgiHttpContext.getMimeType(resName);
+        String encoding = m_osgiHttpContext.getMimeType( resName );
 
-        if (encoding == null)
+        if ( encoding == null )
         {
-            encoding = getHttpContext().getMimeByExtension(resName);
+            encoding = getHttpContext().getMimeByExtension( resName );
         }
 
-        if (encoding == null)
+        if ( encoding == null )
         {
-            encoding = getHttpContext().getMimeByExtension(".default");
+            encoding = getHttpContext().getMimeByExtension( ".default" );
         }
 
         //TODO: not sure why this is needed, but sometimes get "IllegalState"
         // errors if not included
-        response.setAcceptTrailer(true);
-        response.setContentType(encoding);
+        response.setAcceptTrailer( true );
+        response.setContentType( encoding );
 
         //TODO: check other http fields e.g. ranges, timestamps etc.
 
         // make sure we access the resource inside the bundle's access control
         // context if supplied
-        if (System.getSecurityManager() != null)
+        if ( System.getSecurityManager() != null )
         {
             try
             {
-                AccessController.doPrivileged(new PrivilegedExceptionAction()
+                AccessController.doPrivileged( new PrivilegedExceptionAction()
                 {
-                    public Object run()
-                            throws Exception
+                    public Object run() throws Exception
                     {
-                        copyResourceBytes(url, response);
+                        copyResourceBytes( url, response );
                         return null;
                     }
-                }, m_acc);
-            } 
-            catch (PrivilegedActionException ex) 
+                }, m_acc );
+            }
+            catch ( PrivilegedActionException ex )
             {
-                IOException ioe = (IOException) ex.getException();
+                IOException ioe = ( IOException ) ex.getException();
                 throw ioe;
             }
         }
         else
         {
-            copyResourceBytes(url, response);
+            copyResourceBytes( url, response );
         }
 
-        request.setHandled(true);
+        request.setHandled( true );
         //TODO: set other http fields e.g. __LastModified, __ContentLength
     }
-    
-    
-    private void copyResourceBytes(URL url, HttpResponse response)
-            throws
-                    IOException
+
+
+    private void copyResourceBytes( URL url, HttpResponse response ) throws IOException
     {
         OutputStream os = null;
         InputStream is = null;
-        
+
         try
         {
             os = response.getOutputStream();
             is = url.openStream();
-        
+
             int len = 0;
             byte[] buf = new byte[1024];
             int n = 0;
-    
-            while ((n = is.read(buf, 0, buf.length)) >= 0)
+
+            while ( ( n = is.read( buf, 0, buf.length ) ) >= 0 )
             {
-                os.write(buf, 0, n);
+                os.write( buf, 0, n );
                 len += n;
             }
-            
-            try 
+
+            try
             {
-                response.setContentLength(len);
-            } 
-            catch (IllegalStateException ex) 
+                response.setContentLength( len );
+            }
+            catch ( IllegalStateException ex )
             {
-                System.err.println("OsgiResourceHandler: " + ex);
+                System.err.println( "OsgiResourceHandler: " + ex );
             }
         }
         finally
         {
-            if (is != null) is.close();
-            if (os != null) os.close();
-        }        
+            if ( is != null )
+            {
+                is.close();
+            }
+            if ( os != null )
+            {
+                os.close();
+            }
+        }
     }
 }
diff --git a/http.jetty/src/main/java/org/apache/felix/http/jetty/ServletContextGroup.java b/http.jetty/src/main/java/org/apache/felix/http/jetty/ServletContextGroup.java
new file mode 100644
index 0000000000..260ec6aef9
--- /dev/null
+++ b/http.jetty/src/main/java/org/apache/felix/http/jetty/ServletContextGroup.java
@@ -0,0 +1,270 @@
+/*
+ * $Url: $
+ * $Id: $
+ *
+ * Copyright 1997-2005 Day Management AG
+ * Barfuesserplatz 6, 4001 Basel, Switzerland
+ * All Rights Reserved.
+ *
+ * This software is the confidential and proprietary information of
+ * Day Management AG, ("Confidential Information"). You shall not
+ * disclose such Confidential Information and shall use it only in
+ * accordance with the terms of the license agreement you entered into
+ * with Day.
+ */
+package org.apache.felix.http.jetty;
+
+
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Set;
+
+import javax.servlet.RequestDispatcher;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
+import org.mortbay.jetty.servlet.OsgiServletHandler;
+import org.mortbay.jetty.servlet.OsgiServletHolder;
+import org.mortbay.jetty.servlet.ServletHolder;
+import org.osgi.service.http.HttpContext;
+
+
+public class ServletContextGroup implements ServletContext
+{
+    /** global pool of all OSGi HttpContext that have been created */
+    private static Map m_contextMap = new HashMap();
+
+    /** global set of all servlet instances that have been registered */
+    private static Set m_servletSet = new HashSet();
+
+    private OsgiServletHandler m_hdlr = null;
+    private HttpContext m_osgiHttpContext = null;
+    private Hashtable m_attributes = null;
+
+
+    static void initializeStatics()
+    {
+        m_contextMap.clear();
+        m_servletSet.clear();
+    }
+
+
+    static ServletContextGroup getServletContextGroup( OsgiServletHandler hdlr, HttpContext osgiHttpContext )
+    {
+
+        ServletContextGroup grp = ( ServletContextGroup ) m_contextMap.get( osgiHttpContext );
+        if ( grp == null )
+        {
+            grp = new ServletContextGroup( hdlr, osgiHttpContext );
+            m_contextMap.put( osgiHttpContext, grp );
+        }
+
+        return grp;
+    }
+
+
+    static boolean isServletRegistered( Servlet servlet )
+    {
+        return m_servletSet.contains( servlet );
+    }
+
+
+    private ServletContextGroup( OsgiServletHandler hdlr, HttpContext osgiHttpContext )
+    {
+        init( hdlr, osgiHttpContext );
+    }
+
+
+    private void init( OsgiServletHandler hdlr, HttpContext osgiHttpContext )
+    {
+        m_hdlr = hdlr;
+        m_osgiHttpContext = osgiHttpContext;
+
+        m_attributes = new Hashtable();
+
+        m_contextMap.put( m_osgiHttpContext, this );
+    }
+
+
+    private void destroy()
+    {
+        m_contextMap.remove( m_osgiHttpContext );
+    }
+
+
+    public HttpContext getOsgiHttpContext()
+    {
+        return m_osgiHttpContext;
+    }
+
+
+    void addServlet( Servlet servlet, String alias, Dictionary params )
+    {
+        String wAlias = aliasWildcard( alias );
+        ServletHolder holder = new OsgiServletHolder( m_hdlr, servlet, wAlias, this, params );
+        m_hdlr.addOsgiServletHolder( wAlias, holder );
+        Activator.debug( " adding servlet instance: " + servlet );
+        m_servletSet.add( servlet );
+    }
+
+
+    void removeServlet( String alias, boolean destroy )
+    {
+        String wAlias = aliasWildcard( alias );
+        OsgiServletHolder holder = m_hdlr.removeOsgiServletHolder( wAlias );
+        Servlet servlet = holder.getOsgiServlet();
+        Activator.debug( " removing servlet instance: " + servlet );
+        m_servletSet.remove( servlet );
+
+        if ( destroy )
+        {
+            servlet.destroy();
+        }
+
+        if ( m_servletSet.isEmpty() )
+        {
+            destroy();
+        }
+    }
+
+
+    private String aliasWildcard( String alias )
+    {
+        // add wilcard filter at the end of the alias to allow servlet to
+        // get requests which include sub-paths
+        return "/".equals( alias ) ? "/*" : alias + "/*";
+    }
+
+
+    // ServletContext interface for OSGi servlets
+
+    public ServletContext getContext( String contextName )
+    {
+        return m_hdlr.getServletContext().getContext( contextName );
+    }
+
+
+    public int getMajorVersion()
+    {
+        return m_hdlr.getServletContext().getMajorVersion();
+    }
+
+
+    public int getMinorVersion()
+    {
+        return m_hdlr.getServletContext().getMinorVersion();
+    }
+
+
+    public String getMimeType( String file )
+    {
+        String type = m_osgiHttpContext.getMimeType( file );
+        if ( type != null )
+        {
+            return type;
+        }
+
+        return m_hdlr.getServletContext().getMimeType( file );
+    }
+
+
+    public String getRealPath( String path )
+    {
+        return m_hdlr.getServletContext().getRealPath( path );
+    }
+
+
+    public RequestDispatcher getRequestDispatcher( String uri )
+    {
+        return m_hdlr.getServletContext().getRequestDispatcher( uri );
+    }
+
+
+    public URL getResource( String path ) throws MalformedURLException
+    {
+        return m_hdlr.getServletContext().getResource( path );
+    }
+
+
+    public InputStream getResourceAsStream( String path )
+    {
+        return m_hdlr.getServletContext().getResourceAsStream( path );
+    }
+
+
+    public String getServerInfo()
+    {
+        return m_hdlr.getServletContext().getServerInfo();
+    }
+
+
+    public Servlet getServlet( String servletName ) throws ServletException
+    {
+        return m_hdlr.getServletContext().getServlet( servletName );
+    }
+
+
+    public Enumeration getServletNames()
+    {
+        return m_hdlr.getServletContext().getServletNames();
+    }
+
+
+    /* (non-Javadoc)
+     * @see javax.servlet.ServletContext#getServlets()
+     */
+    public Enumeration getServlets()
+    {
+        return m_hdlr.getServletContext().getServlets();
+    }
+
+
+    public void log( Exception exception, String message )
+    {
+        m_hdlr.getServletContext().log( exception, message );
+    }
+
+
+    public void log( String message, Throwable throwable )
+    {
+        m_hdlr.getServletContext().log( message, throwable );
+    }
+
+
+    public void log( String message )
+    {
+        m_hdlr.getServletContext().log( message );
+    }
+
+
+    public void setAttribute( String name, Object value )
+    {
+        m_attributes.put( name, value );
+    }
+
+
+    public Object getAttribute( String name )
+    {
+        return m_attributes.get( name );
+    }
+
+
+    public Enumeration getAttributeNames()
+    {
+        return m_attributes.keys();
+    }
+
+
+    public void removeAttribute( String name )
+    {
+        m_attributes.remove( name );
+    }
+}
\ No newline at end of file
diff --git a/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpRequest.java b/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpRequest.java
index 72f43906f1..b01c415985 100644
--- a/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpRequest.java
+++ b/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpRequest.java
@@ -18,17 +18,15 @@
  */
 package org.mortbay.jetty.servlet;
 
+
 import org.mortbay.http.HttpRequest;
 
-public class DummyServletHttpRequest
-        extends
-                ServletHttpRequest
+
+public class DummyServletHttpRequest extends ServletHttpRequest
 {
-    public DummyServletHttpRequest(ServletHandler servletHandler,
-                       String pathInContext,
-                       HttpRequest request)
+    public DummyServletHttpRequest( ServletHandler servletHandler, String pathInContext, HttpRequest request )
     {
-        super(servletHandler, pathInContext, request);
+        super( servletHandler, pathInContext, request );
     }
 
 }
\ No newline at end of file
diff --git a/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpResponse.java b/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpResponse.java
index 7b018b71ad..7f0d368c70 100644
--- a/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpResponse.java
+++ b/http.jetty/src/main/java/org/mortbay/jetty/servlet/DummyServletHttpResponse.java
@@ -18,17 +18,15 @@
  */
 package org.mortbay.jetty.servlet;
 
+
 import org.mortbay.http.HttpResponse;
 
-public class DummyServletHttpResponse
-        extends
-                ServletHttpResponse
+
+public class DummyServletHttpResponse extends ServletHttpResponse
 {
-    public DummyServletHttpResponse(ServletHttpRequest request,
-            HttpResponse response)
+    public DummyServletHttpResponse( ServletHttpRequest request, HttpResponse response )
     {
-        super(request, response);
+        super( request, response );
     }
 
 }
-
diff --git a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHandler.java b/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHandler.java
index 3e806ee37b..49da73df6a 100644
--- a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHandler.java
+++ b/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHandler.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,10 +18,9 @@
  */
 package org.mortbay.jetty.servlet;
 
+
 import java.io.IOException;
-import java.net.MalformedURLException;
 import java.net.URL;
-
 import javax.servlet.ServletException;
 import javax.servlet.UnavailableException;
 import javax.servlet.http.HttpServletRequest;
@@ -31,35 +30,23 @@ import org.mortbay.http.PathMap;
 import org.mortbay.util.Code;
 
 
-public class OsgiServletHandler
-        extends ServletHandler
+public class OsgiServletHandler extends ServletHandler
 {
-    protected org.osgi.service.http.HttpContext     m_osgiHttpContext;
-
-
-    public OsgiServletHandler(
-            org.osgi.service.http.HttpContext osgiHttpContext)
-    {
-        m_osgiHttpContext = osgiHttpContext;
-    }
-
-
     // allow external adding of osgi servlet holder
-    public void addOsgiServletHolder(String pathSpec, ServletHolder holder)
+    public void addOsgiServletHolder( String pathSpec, ServletHolder holder )
     {
-        super.addServletHolder(pathSpec, holder);
+        super.addServletHolder( pathSpec, holder );
     }
 
 
-    public OsgiServletHolder removeOsgiServletHolder(String pathSpec)
+    public OsgiServletHolder removeOsgiServletHolder( String pathSpec )
     {
-        OsgiServletHolder holder = (OsgiServletHolder)
-                super.getServletHolder(pathSpec);
+        OsgiServletHolder holder = ( OsgiServletHolder ) super.getServletHolder( pathSpec );
         PathMap map = super.getServletMap();
-        map.remove(pathSpec);
+        map.remove( pathSpec );
 
         // Remove holder from handler name map to allow re-registration.
-        super._nameMap.remove(holder.getName());
+        super._nameMap.remove( holder.getName() );
 
         return holder;
     }
@@ -67,44 +54,18 @@ public class OsgiServletHandler
 
     // override standard handler behaviour to return resource from OSGi
     // HttpContext
-    public URL getResource(String uriInContext)
-                         throws MalformedURLException
+    public URL getResource( String uriInContext )
     {
-        Code.debug("OSGI ServletHandler getResource:" + uriInContext);
-        return m_osgiHttpContext.getResource(uriInContext);
+        Code.debug( "OSGI ServletHandler getResource:" + uriInContext );
+        return null;
     }
 
+
     // override standard behaviour to check context first
-    protected void dispatch(String pathInContext,
-                  HttpServletRequest request,
-                  HttpServletResponse response,
-                  ServletHolder servletHolder)
-        throws ServletException,
-               UnavailableException,
-               IOException
+    protected void dispatch( String pathInContext, HttpServletRequest request, HttpServletResponse response,
+        ServletHolder servletHolder ) throws ServletException, UnavailableException, IOException
     {
-        Code.debug("dispatch path = " + pathInContext);
-        if (m_osgiHttpContext.handleSecurity(request, response))
-        {
-            // service request
-            servletHolder.handle(request,response);
-        }
-        else
-        {
-            //TODO: any other error/auth handling we should do in here?
-            
-            // response.flushBuffer() if available
-            try
-            {
-                response.getClass().getDeclaredMethod("flushBuffer", null).invoke(response, null);
-            } 
-            catch (Exception ex)
-            {
-                // else ignore
-                ex.printStackTrace();
-            }
-        }
+        Code.debug( "dispatch path = " + pathInContext );
+        super.dispatch( pathInContext, request, response, servletHolder );
     }
 }
-
-
diff --git a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHolder.java b/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHolder.java
index 20fc2a5920..8b384e56fe 100644
--- a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHolder.java
+++ b/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHolder.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -19,46 +19,57 @@
 package org.mortbay.jetty.servlet;
 
 
+import java.io.IOException;
 import java.util.Dictionary;
 import java.util.Enumeration;
 
 import javax.servlet.Servlet;
 import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-public class OsgiServletHolder
-        extends
-                ServletHolder
+import org.apache.felix.http.jetty.ServletContextGroup;
+
+
+public class OsgiServletHolder extends ServletHolder
 {
     private Servlet m_servlet;
+    private ServletContextGroup m_servletContextGroup;
     private ServletConfig m_config;
 
 
-    public OsgiServletHolder(ServletHandler handler, Servlet servlet,
-            String name, Dictionary params)
+    public OsgiServletHolder( ServletHandler handler, Servlet servlet, String name,
+        ServletContextGroup servletContextGroup, Dictionary params )
     {
-        super(handler,name,servlet.getClass().getName());
+        super( handler, name, servlet.getClass().getName() );
         m_servlet = servlet;
+        m_servletContextGroup = servletContextGroup;
 
         // Seemed safer to copy params into parent holder, rather than override
         // the getInitxxx methods.
-        if (params != null)
+        if ( params != null )
         {
             Enumeration e = params.keys();
-            while (e.hasMoreElements())
+            while ( e.hasMoreElements() )
             {
                 Object key = e.nextElement();
-                super.put(key, params.get(key));
+                super.put( key, params.get( key ) );
             }
         }
     }
 
+
     public synchronized Servlet getServlet()
-        throws UnavailableException
     {
-        return m_servlet;        
+        return m_servlet;
     }
 
+
     public Servlet getOsgiServlet()
     {
         return m_servlet;
@@ -67,27 +78,59 @@ public class OsgiServletHolder
 
     // override "Holder" method to prevent instantiation
     public synchronized Object newInstance()
-        throws InstantiationException,
-               IllegalAccessException
     {
         return getOsgiServlet();
     }
 
+
+    public void handle( ServletRequest request, ServletResponse response ) throws ServletException,
+        UnavailableException, IOException
+    {
+        if ( m_servletContextGroup.getOsgiHttpContext().handleSecurity( ( HttpServletRequest ) request,
+            ( HttpServletResponse ) response ) )
+        {
+            // service request
+            super.handle( request, response );
+        }
+        else
+        {
+            //TODO: any other error/auth handling we should do in here?
+
+            // response.flushBuffer() if available
+            try
+            {
+                response.getClass().getDeclaredMethod( "flushBuffer", null ).invoke( response, null );
+            }
+            catch ( Exception ex )
+            {
+                // else ignore
+                ex.printStackTrace();
+            }
+        }
+    }
+
+
     // override "Holder" method to prevent attempt to load
     // the servlet class.
-    public void start()
-        throws Exception
+    public void start() throws Exception
     {
-        _class=m_servlet.getClass();
-        
-        m_config=new Config();
-        m_servlet.init(m_config);        
+        _class = m_servlet.getClass();
+
+        m_config = new Config()
+        {
+            public ServletContext getServletContext()
+            {
+                return m_servletContextGroup;
+            }
+        };
+
+        m_servlet.init( m_config );
     }
 
+
     // override "Holder" method to prevent destroy, which is only called
     // when a bundle manually unregisters
     public void stop()
     {
     }
 }
-
diff --git a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHttpContext.java b/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHttpContext.java
deleted file mode 100644
index 0dbb733ef2..0000000000
--- a/http.jetty/src/main/java/org/mortbay/jetty/servlet/OsgiServletHttpContext.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/* 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.mortbay.jetty.servlet;
-
-
-import org.mortbay.util.Code;
-
-public class OsgiServletHttpContext
-        extends
-                ServletHttpContext
-{
-    protected org.osgi.service.http.HttpContext     m_osgiHttpContext;
-    
-    public OsgiServletHttpContext(
-            org.osgi.service.http.HttpContext osgiHttpContext)
-    {
-        m_osgiHttpContext = osgiHttpContext;
-    }
-    
-    // intercept to ensure OSGi context is used first for servlet calls to 
-    // getMimeType()
-    public String getMimeByExtension(String filename)
-    { 
-        Code.debug("OSGi servlet context: get mime type");
-        String encoding = m_osgiHttpContext.getMimeType(filename);
-
-        if (encoding == null)
-        {
-            encoding = super.getMimeByExtension(filename);
-        }
-        
-        return encoding;
-    }
-    
-}
