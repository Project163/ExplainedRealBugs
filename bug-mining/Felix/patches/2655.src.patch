diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index c6e93e8bc5..9be5d8afd0 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -58,7 +58,6 @@ import org.osgi.service.log.LogService;
 import org.osgi.util.promise.Deferred;
 import org.osgi.util.promise.Promise;
 
-
 /**
  * The default ComponentManager. Objects of this class are responsible for managing
  * implementation object's lifecycle.
@@ -67,30 +66,25 @@ import org.osgi.util.promise.Promise;
 public abstract class AbstractComponentManager<S> implements SimpleLogger, ComponentManager<S>
 {
     //useful text for deactivation reason numbers
-    static final String[] REASONS = {"Unspecified",
-        "Component disabled",
-        "Reference became unsatisfied",
-        "Configuration modified",
-        "Configuration deleted",
-        "Component disabled",
-        "Bundle stopped"};
-    
-    protected enum State {
+    static final String[] REASONS = { "Unspecified", "Component disabled", "Reference became unsatisfied",
+            "Configuration modified", "Configuration deleted", "Component disabled", "Bundle stopped" };
+
+    protected enum State
+    {
         //disposed is a final state, normally only for factory components
-        disposed(-1, false, false, false), 
+        disposed(-1, false, false, false),
         //Since enable/disable on the component description are asynchronous, this tracks the component configuration state
         //which may differ while the enable/disable is occurring.
-        disabled(-1, false, false, false), 
-        unsatisfiedReference(ComponentConfigurationDTO.UNSATISFIED_REFERENCE, true, false, false), 
-        satisfied(ComponentConfigurationDTO.SATISFIED, true, true, false), 
-        active(ComponentConfigurationDTO.ACTIVE, true, true, true);
-    
+        disabled(-1, false, false, false), unsatisfiedReference(ComponentConfigurationDTO.UNSATISFIED_REFERENCE, true,
+            false, false), satisfied(ComponentConfigurationDTO.SATISFIED, true, true,
+                false), active(ComponentConfigurationDTO.ACTIVE, true, true, true);
+
         private final int specState;
-        
+
         private final boolean enabled;
 
         private final boolean satisfed;
-        
+
         private final boolean actve;
 
         private State(int specState, boolean enabled, boolean satisfied, boolean active)
@@ -120,9 +114,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         {
             return actve;
         }
-        
-        
-                
+
     }
 
     protected final ComponentContainer<S> m_container;
@@ -139,7 +131,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     private volatile boolean m_dependencyManagersInitialized;
 
-    private final AtomicInteger m_trackingCount = new AtomicInteger( );
+    private final AtomicInteger m_trackingCount = new AtomicInteger();
 
     // The ServiceRegistration is now tracked in the RegistrationManager
 
@@ -149,7 +141,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * This latch prevents concurrent enable, disable, and reconfigure.  Since the enable and disable operations may use
      * two threads and the initiating thread does not wait for the operation to complete, we can't use a regular lock.
      */
-    private final AtomicReference< Deferred<Void>> m_enabledLatchRef = new AtomicReference<Deferred<Void>>( new Deferred<Void>() );
+    private final AtomicReference<Deferred<Void>> m_enabledLatchRef = new AtomicReference<Deferred<Void>>(
+        new Deferred<Void>());
 
     private final AtomicReference<State> state = new AtomicReference<State>(State.disabled);
 
@@ -160,8 +153,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     private final Lock m_missingLock = new ReentrantLock();
     private final Condition m_missingCondition = m_missingLock.newCondition();
-    private final Set<Integer> m_missing = new TreeSet<Integer>( );
-
+    private final Set<Integer> m_missing = new TreeSet<Integer>();
 
     protected final ReentrantReadWriteLock m_activationLock = new ReentrantReadWriteLock();
 
@@ -171,12 +163,12 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * @param container
      * @param componentMethods
      */
-    protected AbstractComponentManager( ComponentContainer<S> container, ComponentMethods componentMethods )
+    protected AbstractComponentManager(ComponentContainer<S> container, ComponentMethods componentMethods)
     {
-        this( container, componentMethods, false );
+        this(container, componentMethods, false);
     }
 
-    protected AbstractComponentManager( ComponentContainer<S> container, ComponentMethods componentMethods, boolean factoryInstance )
+    protected AbstractComponentManager(ComponentContainer<S> container, ComponentMethods componentMethods, boolean factoryInstance)
     {
         m_enabledLatchRef.get().resolve(null);
         m_factoryInstance = factoryInstance;
@@ -186,34 +178,33 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
         ComponentMetadata metadata = container.getComponentMetadata();
 
-        m_dependencyManagers = loadDependencyManagers( metadata );
+        m_dependencyManagers = loadDependencyManagers(metadata);
 
-        m_stateLock = new ReentrantLock( true );
+        m_stateLock = new ReentrantLock(true);
 
         // dump component details
-        if ( isLogEnabled( LogService.LOG_DEBUG ) )
+        if (isLogEnabled(LogService.LOG_DEBUG))
         {
-            log(
-                LogService.LOG_DEBUG,
+            log(LogService.LOG_DEBUG,
                 "Component {0} created: DS={1}, implementation={2}, immediate={3}, default-enabled={4}, factory={5}, configuration-policy={6}, activate={7}, deactivate={8}, modified={9} configuration-pid={10}",
-                new Object[]
-                    { metadata.getName(), metadata.getDSVersion(),
-                        metadata.getImplementationClassName(), metadata.isImmediate(),
-                        metadata.isEnabled(), metadata.getFactoryIdentifier(),
+                new Object[] { metadata.getName(), metadata.getDSVersion(), metadata.getImplementationClassName(),
+                        metadata.isImmediate(), metadata.isEnabled(), metadata.getFactoryIdentifier(),
                         metadata.getConfigurationPolicy(), metadata.getActivate(), metadata.getDeactivate(),
-                        metadata.getModified(), metadata.getConfigurationPid() }, null );
+                        metadata.getModified(), metadata.getConfigurationPid() },
+                null);
 
-            if ( metadata.getServiceMetadata() != null )
+            if (metadata.getServiceMetadata() != null)
             {
-                log( LogService.LOG_DEBUG, "Component {0} Services: scope={1}, services={2}", new Object[]
-                    { metadata.getName(), metadata.getServiceScope(),
-                        Arrays.asList( metadata.getServiceMetadata().getProvides() ) }, null );
+                log(LogService.LOG_DEBUG,
+                    "Component {0} Services: scope={1}, services={2}", new Object[] { metadata.getName(),
+                            metadata.getServiceScope(), Arrays.asList(metadata.getServiceMetadata().getProvides()) },
+                    null);
             }
 
-            if ( metadata.getProperties() != null )
+            if (metadata.getProperties() != null)
             {
-                log( LogService.LOG_DEBUG, "Component {0} Properties: {1}", new Object[]
-                    { metadata.getName(), metadata.getProperties() }, null );
+                log(LogService.LOG_DEBUG, "Component {0} Properties: {1}",
+                    new Object[] { metadata.getName(), metadata.getProperties() }, null);
             }
         }
     }
@@ -222,61 +213,61 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     {
         ComponentActivator activator = getActivator();
         //for tests....
-        if ( activator != null && activator.getConfiguration() != null )
+        if (activator != null && activator.getConfiguration() != null)
         {
             return activator.getConfiguration().lockTimeout();
         }
         return ScrConfiguration.DEFAULT_LOCK_TIMEOUT_MILLISECONDS;
     }
 
-    private void obtainLock( Lock lock )
+    private void obtainLock(Lock lock)
     {
         try
         {
-            if (!lock.tryLock( getLockTimeout(), TimeUnit.MILLISECONDS ) )
+            if (!lock.tryLock(getLockTimeout(), TimeUnit.MILLISECONDS))
             {
                 dumpThreads();
-                throw new IllegalStateException( "Could not obtain lock" );
+                throw new IllegalStateException("Could not obtain lock");
             }
         }
-        catch ( InterruptedException e )
+        catch (InterruptedException e)
         {
             try
             {
-                if (!lock.tryLock( getLockTimeout(), TimeUnit.MILLISECONDS ) )
+                if (!lock.tryLock(getLockTimeout(), TimeUnit.MILLISECONDS))
                 {
                     dumpThreads();
-                    throw new IllegalStateException( "Could not obtain lock" );
+                    throw new IllegalStateException("Could not obtain lock");
                 }
             }
-            catch ( InterruptedException e1 )
+            catch (InterruptedException e1)
             {
                 Thread.currentThread().interrupt();
                 //TODO is there a better exception to throw?
-                throw new IllegalStateException( "Interrupted twice: Could not obtain lock" );
+                throw new IllegalStateException("Interrupted twice: Could not obtain lock");
             }
             Thread.currentThread().interrupt();
         }
     }
 
-    final void obtainActivationReadLock(  )
+    final void obtainActivationReadLock()
     {
-        obtainLock( m_activationLock.readLock());
+        obtainLock(m_activationLock.readLock());
     }
 
-    final void releaseActivationReadLock( )
+    final void releaseActivationReadLock()
     {
         m_activationLock.readLock().unlock();
     }
 
-    final void obtainActivationWriteLock( )
+    final void obtainActivationWriteLock()
     {
-        obtainLock( m_activationLock.writeLock());
+        obtainLock(m_activationLock.writeLock());
     }
 
-    final void releaseActivationWriteeLock( )
+    final void releaseActivationWriteeLock()
     {
-        if ( m_activationLock.getWriteHoldCount() > 0 )
+        if (m_activationLock.getWriteHoldCount() > 0)
         {
             m_activationLock.writeLock().unlock();
         }
@@ -284,7 +275,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     final void obtainStateLock()
     {
-        obtainLock( m_stateLock );
+        obtainLock(m_stateLock);
     }
 
     final void releaseStateLock()
@@ -302,34 +293,34 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         try
         {
             String dump = new ThreadDump().call();
-            log( LogService.LOG_DEBUG, dump, null );
+            log(LogService.LOG_DEBUG, dump, null);
         }
-        catch ( Throwable t )
+        catch (Throwable t)
         {
-            log( LogService.LOG_DEBUG, "Could not dump threads", t );
+            log(LogService.LOG_DEBUG, "Could not dump threads", t);
         }
     }
 
     //service event tracking
-    void tracked( int trackingCount )
+    void tracked(int trackingCount)
     {
         m_missingLock.lock();
         try
         {
-            if (trackingCount == m_floor + 1 )
+            if (trackingCount == m_floor + 1)
             {
                 m_floor++;
-                m_missing.remove( trackingCount );
+                m_missing.remove(trackingCount);
             }
-            else if ( trackingCount < m_ceiling )
+            else if (trackingCount < m_ceiling)
             {
-                m_missing.remove( trackingCount );
+                m_missing.remove(trackingCount);
             }
-            if ( trackingCount > m_ceiling )
+            if (trackingCount > m_ceiling)
             {
-                for (int i = m_ceiling + 1; i < trackingCount; i++ )
+                for (int i = m_ceiling + 1; i < trackingCount; i++)
                 {
-                    m_missing.add( i );
+                    m_missing.add(i);
                 }
                 m_ceiling = trackingCount;
             }
@@ -346,35 +337,36 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * to the parameter tracking count to complete, then returns.  See further documentation in EdgeInfo.
      * @param trackingCount
      */
-    void waitForTracked( int trackingCount )
+    void waitForTracked(int trackingCount)
     {
         m_missingLock.lock();
         try
         {
-            while ( m_ceiling  < trackingCount || ( !m_missing.isEmpty() && m_missing.iterator().next() < trackingCount))
+            while (m_ceiling < trackingCount || (!m_missing.isEmpty() && m_missing.iterator().next() < trackingCount))
             {
-                log( LogService.LOG_DEBUG, "waitForTracked trackingCount: {0} ceiling: {1} missing: {2}",
-                        new Object[] {trackingCount, m_ceiling, m_missing}, null );
+                log(LogService.LOG_DEBUG, "waitForTracked trackingCount: {0} ceiling: {1} missing: {2}",
+                    new Object[] { trackingCount, m_ceiling, m_missing }, null);
                 try
                 {
-                    if ( !doMissingWait())
+                    if (!doMissingWait())
                     {
                         return;
                     }
                 }
-                catch ( InterruptedException e )
+                catch (InterruptedException e)
                 {
                     try
                     {
-                        if ( !doMissingWait())
+                        if (!doMissingWait())
                         {
                             return;
                         }
                     }
-                    catch ( InterruptedException e1 )
+                    catch (InterruptedException e1)
                     {
-                        log( LogService.LOG_ERROR, "waitForTracked interrupted twice: {0} ceiling: {1} missing: {2},  Expect further errors",
-                                new Object[] {trackingCount, m_ceiling, m_missing}, e1 );
+                        log(LogService.LOG_ERROR,
+                            "waitForTracked interrupted twice: {0} ceiling: {1} missing: {2},  Expect further errors",
+                            new Object[] { trackingCount, m_ceiling, m_missing }, e1);
                     }
                     Thread.currentThread().interrupt();
                 }
@@ -388,10 +380,10 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     private boolean doMissingWait() throws InterruptedException
     {
-        if ( !m_missingCondition.await( getLockTimeout(), TimeUnit.MILLISECONDS ))
+        if (!m_missingCondition.await(getLockTimeout(), TimeUnit.MILLISECONDS))
         {
-            log( LogService.LOG_ERROR, "waitForTracked timed out: {0} ceiling: {1} missing: {2},  Expect further errors",
-                    new Object[] {m_trackingCount, m_ceiling, m_missing}, null );
+            log(LogService.LOG_ERROR, "waitForTracked timed out: {0} ceiling: {1} missing: {2},  Expect further errors",
+                new Object[] { m_trackingCount, m_ceiling, m_missing }, null);
             dumpThreads();
             m_missing.clear();
             return false;
@@ -399,58 +391,56 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return true;
     }
 
-//---------- Component ID management
+    //---------- Component ID management
 
     void registerComponentId()
     {
         final ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
-            this.m_componentId = activator.registerComponentId( this );
+            this.m_componentId = activator.registerComponentId(this);
         }
     }
 
-
     void unregisterComponentId()
     {
-        if ( this.m_componentId >= 0 )
+        if (this.m_componentId >= 0)
         {
             final ComponentActivator activator = getActivator();
-            if ( activator != null )
+            if (activator != null)
             {
-                activator.unregisterComponentId( this );
+                activator.unregisterComponentId(this);
             }
             this.m_componentId = -1;
         }
     }
 
-
     //---------- Asynchronous frontend to state change methods ----------------
-    private static final AtomicLong taskCounter = new AtomicLong( );
+    private static final AtomicLong taskCounter = new AtomicLong();
 
-    public final Promise<Void> enable( final boolean async )
+    public final Promise<Void> enable(final boolean async)
     {
         Deferred<Void> enableLatch = null;
         try
         {
             enableLatch = enableLatchWait();
-            if ( !async )
+            if (!async)
             {
                 enableInternal();
             }
         }
         finally
         {
-            if ( !async )
+            if (!async)
             {
                 enableLatch.resolve(null);
             }
         }
 
-        if ( async )
+        if (async)
         {
             final Deferred<Void> latch = enableLatch;
-            getActivator().schedule( new Runnable()
+            getActivator().schedule(new Runnable()
             {
 
                 long count = taskCounter.incrementAndGet();
@@ -472,7 +462,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                 {
                     return "Async Activate: " + getComponentMetadata().getName() + " id: " + count;
                 }
-            } );
+            });
         }
         return enableLatch.getPromise();
     }
@@ -493,14 +483,14 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             enabledLatch = m_enabledLatchRef.get();
             boolean waited = false;
             boolean interrupted = false;
-            while ( !waited )
+            while (!waited)
             {
                 try
                 {
                     enabledLatch.getPromise().getValue();
                     waited = true;
                 }
-                catch ( InterruptedException e )
+                catch (InterruptedException e)
                 {
                     interrupted = true;
                 }
@@ -509,23 +499,23 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                     //this is not going to happen
                 }
             }
-            if ( interrupted )
+            if (interrupted)
             {
                 Thread.currentThread().interrupt();
             }
             newEnabledLatch = new Deferred<Void>();
         }
-        while ( !m_enabledLatchRef.compareAndSet( enabledLatch, newEnabledLatch) );
+        while (!m_enabledLatchRef.compareAndSet(enabledLatch, newEnabledLatch));
         return newEnabledLatch;
     }
 
-    public final Promise<Void> disable( final boolean async )
+    public final Promise<Void> disable(final boolean async)
     {
         Deferred<Void> enableLatch = null;
         try
         {
             enableLatch = enableLatchWait();
-            if ( !async )
+            if (!async)
             {
                 disableInternal();
             }
@@ -538,10 +528,10 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
             }
         }
 
-        if ( async )
+        if (async)
         {
             final Deferred<Void> latch = enableLatch;
-            getActivator().schedule( new Runnable()
+            getActivator().schedule(new Runnable()
             {
 
                 long count = taskCounter.incrementAndGet();
@@ -564,7 +554,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                     return "Async Deactivate: " + getComponentMetadata().getName() + " id: " + count;
                 }
 
-            } );
+            });
         }
         return enableLatch.getPromise();
     }
@@ -572,7 +562,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     // supports the ComponentInstance.dispose() method
     void dispose()
     {
-        dispose( ComponentConstants.DEACTIVATION_REASON_DISPOSED );
+        dispose(ComponentConstants.DEACTIVATION_REASON_DISPOSED);
     }
 
     /**
@@ -584,17 +574,17 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * method has to actually complete before other actions like bundle stopping
      * may continue.
      */
-    public void dispose( int reason )
+    public void dispose(int reason)
     {
-        deactivateInternal( reason, true, true );
+        deactivateInternal(reason, true, true);
     }
 
-    <T> void registerMissingDependency( DependencyManager<S, T> dm, ServiceReference<T> ref, int trackingCount)
+    <T> void registerMissingDependency(DependencyManager<S, T> dm, ServiceReference<T> ref, int trackingCount)
     {
         ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
-            activator.registerMissingDependency( dm, ref, trackingCount );
+            activator.registerMissingDependency(dm, ref, trackingCount);
         }
     }
 
@@ -605,7 +595,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return m_componentId;
     }
 
-    protected String getName() {
+    protected String getName()
+    {
         return getComponentMetadata().getName();
     }
 
@@ -617,13 +608,13 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     public Bundle getBundle()
     {
         final BundleContext context = getBundleContext();
-        if ( context != null )
+        if (context != null)
         {
             try
             {
                 return context.getBundle();
             }
-            catch ( IllegalStateException ise )
+            catch (IllegalStateException ise)
             {
                 // if the bundle context is not valid any more
             }
@@ -635,14 +626,13 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     BundleContext getBundleContext()
     {
         final ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
             return activator.getBundleContext();
         }
         return null;
     }
 
-
     protected boolean isImmediate()
     {
         return getComponentMetadata().isImmediate();
@@ -654,123 +644,113 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return false;
     }
 
-
     //-------------- atomic transition methods -------------------------------
 
     final void enableInternal()
     {
         State previousState;
-        if ( (previousState = getState()) == State.disposed )
+        if ((previousState = getState()) == State.disposed)
         {
-            throw new IllegalStateException( "enable: " + this );
+            throw new IllegalStateException("enable: " + this);
         }
-        if ( !isActivatorActive() )
+        if (!isActivatorActive())
         {
-            log( LogService.LOG_DEBUG, "Bundle's component activator is not active; not enabling component",
-                    null );
+            log(LogService.LOG_DEBUG, "Bundle's component activator is not active; not enabling component", null);
             return;
         }
         if (previousState.isEnabled())
         {
-            log( LogService.LOG_WARNING, "enable  called but component is already in state {0}", new Object[] {previousState},
-                    null );
+            log(LogService.LOG_WARNING, "enable  called but component is already in state {0}",
+                new Object[] { previousState }, null);
             return;
         }
 
         registerComponentId();
-        log( LogService.LOG_DEBUG, "Updating target filters", null );
-        updateTargets( getProperties() );
+        log(LogService.LOG_DEBUG, "Updating target filters", null);
+        updateTargets(getProperties());
 
         setState(previousState, State.unsatisfiedReference);
-        log( LogService.LOG_DEBUG, "Component enabled", null );
-        activateInternal( );
+        log(LogService.LOG_DEBUG, "Component enabled", null);
+        activateInternal();
     }
 
-    final void activateInternal( )
+    final void activateInternal()
     {
-        log( LogService.LOG_DEBUG, "ActivateInternal",
-                null );
+        log(LogService.LOG_DEBUG, "ActivateInternal", null);
         State s = getState();
-        if ( s == State.disposed )
+        if (s == State.disposed)
         {
-            log( LogService.LOG_DEBUG, "ActivateInternal: disposed",
-                    null );
+            log(LogService.LOG_DEBUG, "ActivateInternal: disposed", null);
             return;
         }
-        if ( s == State.active ) {
-            log( LogService.LOG_DEBUG, "ActivateInternal: already activated",
-                    null );
+        if (s == State.active)
+        {
+            log(LogService.LOG_DEBUG, "ActivateInternal: already activated", null);
             return;
         }
-        if ( !s.isEnabled())
+        if (!s.isEnabled())
         {
-            log( LogService.LOG_DEBUG, "Component is not enabled; not activating component",
-                    null );
+            log(LogService.LOG_DEBUG, "Component is not enabled; not activating component", null);
             return;
         }
-        if ( !isActivatorActive() )
+        if (!isActivatorActive())
         {
-            log( LogService.LOG_DEBUG, "Bundle's component activator is not active; not activating component",
-                    null );
+            log(LogService.LOG_DEBUG, "Bundle's component activator is not active; not activating component", null);
             return;
         }
 
-        log( LogService.LOG_DEBUG, "Activating component from state {0}", new Object[] {getState()},  null );
+        log(LogService.LOG_DEBUG, "Activating component from state {0}", new Object[] { getState() }, null);
 
         // Before creating the implementation object, we are going to
         // test that the bundle has enough permissions to register services
-        if ( !hasServiceRegistrationPermissions() )
+        if (!hasServiceRegistrationPermissions())
         {
-            log( LogService.LOG_DEBUG, "Component is not permitted to register all services, cannot activate",
-                    null );
+            log(LogService.LOG_DEBUG, "Component is not permitted to register all services, cannot activate", null);
             return;
         }
 
-        obtainActivationReadLock(  );
+        obtainActivationReadLock();
         try
         {
             // Double check conditions now that we have obtained the lock
             s = getState();
-            if ( s == State.disposed )
+            if (s == State.disposed)
             {
-                log( LogService.LOG_DEBUG, "ActivateInternal: disposed",
-                        null );
+                log(LogService.LOG_DEBUG, "ActivateInternal: disposed", null);
                 return;
             }
-            if ( s == State.active ) {
-                log( LogService.LOG_DEBUG, "ActivateInternal: already activated",
-                        null );
+            if (s == State.active)
+            {
+                log(LogService.LOG_DEBUG, "ActivateInternal: already activated", null);
                 return;
             }
-            if ( !s.isEnabled() )
+            if (!s.isEnabled())
             {
-                log( LogService.LOG_DEBUG, "Component is not enabled; not activating component",
-                        null );
+                log(LogService.LOG_DEBUG, "Component is not enabled; not activating component", null);
                 return;
             }
             // Before creating the implementation object, we are going to
             // test if all the mandatory dependencies are satisfied
-            if ( !verifyDependencyManagers() )
+            if (!verifyDependencyManagers())
             {
-                log( LogService.LOG_DEBUG, "Not all dependencies satisfied, cannot activate", null );
+                log(LogService.LOG_DEBUG, "Not all dependencies satisfied, cannot activate", null);
                 return;
             }
 
-            if ( !registerService() )
+            if (!registerService())
             {
                 //some other thread is activating us, or we got concurrently deactivated.
                 return;
             }
 
-
-            if ( ( isImmediate() || getComponentMetadata().isFactory() ) )
+            if ((isImmediate() || getComponentMetadata().isFactory()))
             {
                 getServiceInternal(registrationManager.getServiceRegistration());
             }
         }
         finally
         {
-            releaseActivationReadLock(  );
+            releaseActivationReadLock();
         }
     }
 
@@ -781,14 +761,14 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * @param disable whether to also disable the manager
      * @param dispose whether to also dispose of the manager
      */
-    final void deactivateInternal( int reason, boolean disable, boolean dispose )
+    final void deactivateInternal(int reason, boolean disable, boolean dispose)
     {
-        if ( !getState().isEnabled() )
+        if (!getState().isEnabled())
         {
             return;
         }
         State nextState = State.unsatisfiedReference;
-        if (disable) 
+        if (disable)
         {
             nextState = State.disabled;
         }
@@ -796,67 +776,67 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         {
             nextState = State.disposed;
         }
-        log( LogService.LOG_DEBUG, "Deactivating component", null );
+        log(LogService.LOG_DEBUG, "Deactivating component", null);
 
         // catch any problems from deleting the component to prevent the
         // component to remain in the deactivating state !
-        obtainActivationReadLock(  );
+        obtainActivationReadLock();
         try
         {
             //doDeactivate may trigger a state change from active to satisfied as the registration is removed.
-            doDeactivate( reason, disable || m_factoryInstance );
+            doDeactivate(reason, disable || m_factoryInstance);
             setState(getState(), nextState);
         }
         finally
         {
-            releaseActivationReadLock(  );
+            releaseActivationReadLock();
         }
-        if ( isFactory() || m_factoryInstance || dispose )
+        if (isFactory() || m_factoryInstance || dispose)
         {
-            log( LogService.LOG_DEBUG, "Disposing component (reason: " + reason + ")", null );
+            log(LogService.LOG_DEBUG, "Disposing component (reason: " + reason + ")", null);
             clear();
         }
     }
 
-    private void doDeactivate( int reason, boolean disable )
+    private void doDeactivate(int reason, boolean disable)
     {
         try
         {
-            if ( !unregisterService() )
+            if (!unregisterService())
             {
-                log( LogService.LOG_DEBUG, "Component deactivation occuring on another thread", null );
+                log(LogService.LOG_DEBUG, "Component deactivation occuring on another thread", null);
             }
-            obtainStateLock( );
+            obtainStateLock();
             try
             {
-//              setState(previousState, State.unsatisfiedReference);
-                deleteComponent( reason );
+                //              setState(previousState, State.unsatisfiedReference);
+                deleteComponent(reason);
                 deactivateDependencyManagers();
-                if ( disable )
+                if (disable)
                 {
                     disableDependencyManagers();
                 }
             }
             finally
             {
-                releaseStateLock( );
+                releaseStateLock();
             }
         }
-        catch ( Throwable t )
+        catch (Throwable t)
         {
-            log( LogService.LOG_WARNING, "Component deactivation threw an exception", t );
+            log(LogService.LOG_WARNING, "Component deactivation threw an exception", t);
         }
     }
 
     final void disableInternal()
     {
-        deactivateInternal( ComponentConstants.DEACTIVATION_REASON_DISABLED, true, false );
+        deactivateInternal(ComponentConstants.DEACTIVATION_REASON_DISABLED, true, false);
         unregisterComponentId();
     }
 
     //---------- Component handling methods ----------------------------------
 
-    protected abstract void deleteComponent( int reason );
+    protected abstract void deleteComponent(int reason);
 
     boolean getServiceInternal(ServiceRegistration<S> serviceRegistration)
     {
@@ -880,7 +860,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     protected String[] getProvidedServices()
     {
-        if ( getComponentMetadata().getServiceMetadata() != null )
+        if (getComponentMetadata().getServiceMetadata() != null)
         {
             String[] provides = getComponentMetadata().getServiceMetadata().getProvides();
             return provides;
@@ -901,14 +881,16 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
                 return null;
             }
             final Dictionary<String, Object> serviceProperties = getServiceProperties();
-            try {
-                ServiceRegistration<S> serviceRegistration = (ServiceRegistration<S>) bundleContext
-                        .registerService(services, getService(),
-                                serviceProperties);
+            try
+            {
+                ServiceRegistration<S> serviceRegistration = (ServiceRegistration<S>) bundleContext.registerService(
+                    services, getService(), serviceProperties);
                 return serviceRegistration;
-            } catch (ServiceException e) {
+            }
+            catch (ServiceException e)
+            {
                 log(LogService.LOG_ERROR, "Unexpected error registering component service with properties {0}",
-                        new Object[] {serviceProperties}, e);
+                    new Object[] { serviceProperties }, e);
                 return null;
             }
         }
@@ -953,9 +935,9 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     protected boolean registerService()
     {
         String[] services = getProvidedServices();
-        if ( services != null )
+        if (services != null)
         {
-            return registrationManager.changeRegistration( RegistrationManager.RegState.registered, services);
+            return registrationManager.changeRegistration(RegistrationManager.RegState.registered, services);
         }
         return true;
     }
@@ -963,50 +945,47 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     protected boolean unregisterService()
     {
         String[] services = getProvidedServices();
-        if ( services != null )
+        if (services != null)
         {
-            return registrationManager.changeRegistration( RegistrationManager.RegState.unregistered, services );
+            return registrationManager.changeRegistration(RegistrationManager.RegState.unregistered, services);
         }
         return true;
     }
 
-
     AtomicInteger getTrackingCount()
     {
         return m_trackingCount;
     }
 
-
     private void initDependencyManagers()
     {
-        if ( m_dependencyManagersInitialized )
+        if (m_dependencyManagersInitialized)
         {
             return;
         }
         final Bundle bundle = getBundle();
         if (bundle == null)
         {
-            log( LogService.LOG_ERROR, "bundle shut down while trying to load implementation object class", null );
+            log(LogService.LOG_ERROR, "bundle shut down while trying to load implementation object class", null);
             throw new IllegalStateException("bundle shut down while trying to load implementation object class");
         }
         Class<?> implementationObjectClass;
         try
         {
-            implementationObjectClass = bundle.loadClass(
-                    getComponentMetadata().getImplementationClassName() );
+            implementationObjectClass = bundle.loadClass(getComponentMetadata().getImplementationClassName());
         }
-        catch ( ClassNotFoundException e )
+        catch (ClassNotFoundException e)
         {
-            log( LogService.LOG_ERROR, "Could not load implementation object class {0}",
-                    new Object[] {getComponentMetadata().getImplementationClassName()}, e );
-            throw new IllegalStateException("Could not load implementation object class "
-                    + getComponentMetadata().getImplementationClassName());
+            log(LogService.LOG_ERROR, "Could not load implementation object class {0}",
+                new Object[] { getComponentMetadata().getImplementationClassName() }, e);
+            throw new IllegalStateException(
+                "Could not load implementation object class " + getComponentMetadata().getImplementationClassName());
         }
-        m_componentMethods.initComponentMethods( getComponentMetadata(), implementationObjectClass );
+        m_componentMethods.initComponentMethods(getComponentMetadata(), implementationObjectClass);
 
-        for ( DependencyManager dependencyManager : m_dependencyManagers )
+        for (DependencyManager dependencyManager : m_dependencyManagers)
         {
-            dependencyManager.initBindingMethods( m_componentMethods.getBindMethods( dependencyManager.getName() ) );
+            dependencyManager.initBindingMethods(m_componentMethods.getBindMethods(dependencyManager.getName()));
         }
         m_dependencyManagersInitialized = true;
     }
@@ -1021,18 +1000,18 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     protected boolean collectDependencies(ComponentContextImpl<S> componentContext)
     {
         initDependencyManagers();
-        for ( DependencyManager<S, ?> dependencyManager : m_dependencyManagers )
+        for (DependencyManager<S, ?> dependencyManager : m_dependencyManagers)
         {
-            if ( !dependencyManager.prebind(componentContext) )
+            if (!dependencyManager.prebind(componentContext))
             {
                 //not actually satisfied any longer
                 deactivateDependencyManagers();
-                log( LogService.LOG_DEBUG, "Could not get required dependency for dependency manager: {0}",
-                        new Object[] {dependencyManager.getName()}, null );
+                log(LogService.LOG_DEBUG, "Could not get required dependency for dependency manager: {0}",
+                    new Object[] { dependencyManager.getName() }, null);
                 return false;
             }
         }
-        log( LogService.LOG_DEBUG, "This thread collected dependencies", null );
+        log(LogService.LOG_DEBUG, "This thread collected dependencies", null);
         return true;
     }
 
@@ -1040,11 +1019,14 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      * Invoke updated method
      * @return {@code true} if the component needs reactivation, {@code false} otherwise.
      */
-    abstract <T> boolean invokeUpdatedMethod( DependencyManager<S, T> dependencyManager, RefPair<S, T> refPair, int trackingCount );
+    abstract <T> boolean invokeUpdatedMethod(DependencyManager<S, T> dependencyManager, RefPair<S, T> refPair,
+        int trackingCount);
 
-    abstract <T> void invokeBindMethod( DependencyManager<S, T> dependencyManager, RefPair<S, T> refPair, int trackingCount );
+    abstract <T> void invokeBindMethod(DependencyManager<S, T> dependencyManager, RefPair<S, T> refPair,
+        int trackingCount);
 
-    abstract <T> void invokeUnbindMethod( DependencyManager<S, T> dependencyManager, RefPair<S, T> oldRefPair, int trackingCount );
+    abstract <T> void invokeUnbindMethod(DependencyManager<S, T> dependencyManager, RefPair<S, T> oldRefPair,
+        int trackingCount);
 
     //**********************************************************************************************************
     public ComponentActivator getActivator()
@@ -1052,82 +1034,77 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return m_container.getActivator();
     }
 
-
     boolean isActivatorActive()
     {
         ComponentActivator activator = getActivator();
         return activator != null && activator.isActive();
     }
 
-
     synchronized void clear()
     {
         // for some testing, the activator may be null
-        if ( m_container.getActivator() != null )
+        if (m_container.getActivator() != null)
         {
-            m_container.getActivator().unregisterComponentId( this );
+            m_container.getActivator().unregisterComponentId(this);
         }
     }
 
     /**
      * Returns <code>true</code> if logging for the given level is enabled.
      */
-    public boolean isLogEnabled( int level )
+    public boolean isLogEnabled(int level)
     {
         ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
-            return activator.isLogEnabled( level );
+            return activator.isLogEnabled(level);
         }
         return false;
     }
 
-
-    public void log( int level, String message, Throwable ex )
+    public void log(int level, String message, Throwable ex)
     {
         ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
-            activator.log( level, message, getComponentMetadata(), m_componentId, ex );
+            activator.log(level, message, getComponentMetadata(), m_componentId, ex);
         }
     }
 
-    public void log( int level, String message, Object[] arguments, Throwable ex )
+    public void log(int level, String message, Object[] arguments, Throwable ex)
     {
         ComponentActivator activator = getActivator();
-        if ( activator != null )
+        if (activator != null)
         {
-            activator.log( level, message, arguments, getComponentMetadata(), m_componentId, ex );
+            activator.log(level, message, arguments, getComponentMetadata(), m_componentId, ex);
         }
     }
 
-
     @Override
     public String toString()
     {
         return "Component: " + getName() + " (" + getId() + ")";
     }
 
-
     private boolean hasServiceRegistrationPermissions()
     {
         boolean allowed = true;
-        if ( System.getSecurityManager() != null )
+        if (System.getSecurityManager() != null)
         {
             final ServiceMetadata serviceMetadata = getComponentMetadata().getServiceMetadata();
-            if ( serviceMetadata != null )
+            if (serviceMetadata != null)
             {
                 final String[] services = serviceMetadata.getProvides();
-                if ( services != null && services.length > 0 )
+                if (services != null && services.length > 0)
                 {
                     final Bundle bundle = getBundle();
-                    for ( String service : services )
+                    for (String service : services)
                     {
-                        final Permission perm = new ServicePermission( service, ServicePermission.REGISTER );
-                        if ( !bundle.hasPermission( perm ) )
+                        final Permission perm = new ServicePermission(service, ServicePermission.REGISTER);
+                        if (!bundle.hasPermission(perm))
                         {
-                            log( LogService.LOG_DEBUG, "Permission to register service {0} is denied", new Object[]
-                                    {service}, null );
+                            log(LogService.LOG_DEBUG, "Permission to register service {0} is denied",
+                                new Object[] { service }, null);
                             allowed = false;
                         }
                     }
@@ -1139,20 +1116,20 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return allowed;
     }
 
-
-    private List<DependencyManager<S, ?>> loadDependencyManagers( ComponentMetadata metadata )
+    private List<DependencyManager<S, ?>> loadDependencyManagers(ComponentMetadata metadata)
     {
-        List<DependencyManager<S, ?>> depMgrList = new ArrayList<DependencyManager<S, ?>>(metadata.getDependencies().size());
+        List<DependencyManager<S, ?>> depMgrList = new ArrayList<DependencyManager<S, ?>>(
+            metadata.getDependencies().size());
 
         // If this component has got dependencies, create dependency managers for each one of them.
-        if ( metadata.getDependencies().size() != 0 )
+        if (metadata.getDependencies().size() != 0)
         {
             int index = 0;
-            for ( ReferenceMetadata currentdependency: metadata.getDependencies() )
+            for (ReferenceMetadata currentdependency : metadata.getDependencies())
             {
-                DependencyManager<S, ?> depmanager = new DependencyManager( this, currentdependency, index++ );
+                DependencyManager<S, ?> depmanager = new DependencyManager(this, currentdependency, index++);
 
-                depMgrList.add( depmanager );
+                depMgrList.add(depmanager);
             }
         }
 
@@ -1161,9 +1138,9 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     final void updateTargets(Map<String, Object> properties)
     {
-        for ( DependencyManager<S, ?> dm: getDependencyManagers() )
+        for (DependencyManager<S, ?> dm : getDependencyManagers())
         {
-            dm.setTargetFilter( properties );
+            dm.setTargetFilter(properties);
         }
     }
 
@@ -1173,31 +1150,28 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         // indicates whether all dependencies are satisfied
         boolean satisfied = true;
 
-        for ( DependencyManager<S, ?> dm: getDependencyManagers() )
+        for (DependencyManager<S, ?> dm : getDependencyManagers())
         {
 
-            if ( !dm.hasGetPermission() )
+            if (!dm.hasGetPermission())
             {
                 // bundle has no service get permission
-                if ( dm.isOptional() )
+                if (dm.isOptional())
                 {
-                    log( LogService.LOG_DEBUG, "No permission to get optional dependency: {0}; assuming satisfied",
-                        new Object[]
-                            { dm.getName() }, null );
+                    log(LogService.LOG_DEBUG, "No permission to get optional dependency: {0}; assuming satisfied",
+                        new Object[] { dm.getName() }, null);
                 }
                 else
                 {
-                    log( LogService.LOG_DEBUG, "No permission to get mandatory dependency: {0}; assuming unsatisfied",
-                        new Object[]
-                            { dm.getName() }, null );
+                    log(LogService.LOG_DEBUG, "No permission to get mandatory dependency: {0}; assuming unsatisfied",
+                        new Object[] { dm.getName() }, null);
                     satisfied = false;
                 }
             }
-            else if ( !dm.isSatisfied() )
+            else if (!dm.isSatisfied())
             {
                 // bundle would have permission but there are not enough services
-                log( LogService.LOG_DEBUG, "Dependency not satisfied: {0}", new Object[]
-                    { dm.getName() }, null );
+                log(LogService.LOG_DEBUG, "Dependency not satisfied: {0}", new Object[] { dm.getName() }, null);
                 satisfied = false;
             }
         }
@@ -1231,17 +1205,16 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      */
     List<DependencyManager<S, ?>> getReversedDependencyManagers()
     {
-        List<DependencyManager<S, ?>> list = new ArrayList<DependencyManager<S, ?>>( m_dependencyManagers );
-        Collections.reverse( list );
+        List<DependencyManager<S, ?>> list = new ArrayList<DependencyManager<S, ?>>(m_dependencyManagers);
+        Collections.reverse(list);
         return list;
     }
 
-
     DependencyManager<S, ?> getDependencyManager(String name)
     {
-        for ( ReferenceManager<S, ?> dm: getDependencyManagers() )
+        for (ReferenceManager<S, ?> dm : getDependencyManagers())
         {
-            if ( name.equals(dm.getName()) )
+            if (name.equals(dm.getName()))
             {
                 return (DependencyManager<S, ?>) dm;
             }
@@ -1253,8 +1226,8 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     private void deactivateDependencyManagers()
     {
-        log( LogService.LOG_DEBUG, "Deactivating dependency managers", null);
-        for ( DependencyManager<S, ?> dm: getDependencyManagers() )
+        log(LogService.LOG_DEBUG, "Deactivating dependency managers", null);
+        for (DependencyManager<S, ?> dm : getDependencyManagers())
         {
             dm.deactivate();
         }
@@ -1262,11 +1235,11 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
 
     private void disableDependencyManagers()
     {
-        log( LogService.LOG_DEBUG, "Disabling dependency managers", null);
+        log(LogService.LOG_DEBUG, "Disabling dependency managers", null);
         AtomicInteger trackingCount = new AtomicInteger();
-        for ( DependencyManager<S, ?> dm: getDependencyManagers() )
+        for (DependencyManager<S, ?> dm : getDependencyManagers())
         {
-            dm.unregisterServiceListener( trackingCount );
+            dm.unregisterServiceListener(trackingCount);
         }
     }
 
@@ -1275,7 +1248,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      */
     public abstract Map<String, Object> getProperties();
 
-    public abstract void setServiceProperties( Dictionary<String, ?> serviceProperties );
+    public abstract void setServiceProperties(Dictionary<String, ?> serviceProperties);
 
     /**
      * Returns the subset of component properties to be used as service
@@ -1285,7 +1258,7 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      */
     public Dictionary<String, Object> getServiceProperties()
     {
-        return copyTo( null, getProperties(), false );
+        return copyTo(null, getProperties(), false);
     }
 
     /**
@@ -1307,22 +1280,23 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      *         <code>target</code> was <code>null</code> or all properties are
      *         private and had not to be copied
      */
-    protected static Dictionary<String, Object> copyTo( Dictionary<String, Object> target, final Map<String, ?> source, final boolean allProps )
+    protected static Dictionary<String, Object> copyTo(Dictionary<String, Object> target, final Map<String, ?> source,
+        final boolean allProps)
     {
-        if ( target == null )
+        if (target == null)
         {
             target = new Hashtable<String, Object>();
         }
 
-        if ( source != null && !source.isEmpty() )
+        if (source != null && !source.isEmpty())
         {
-            for ( Map.Entry<String, ?> entry: source.entrySet() )
+            for (Map.Entry<String, ?> entry : source.entrySet())
             {
                 // cast is save, because key must be a string as per the spec
                 String key = entry.getKey();
-                if ( allProps || key.charAt( 0 ) != '.' )
+                if (allProps || key.charAt(0) != '.')
                 {
-                    target.put( key, entry.getValue() );
+                    target.put(key, entry.getValue());
                 }
             }
         }
@@ -1345,19 +1319,19 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
      *         <code>target</code> was <code>null</code> or all properties are
      *         private and had not to be copied
      */
-    protected static Map<String, Object> copyToMap( final Dictionary<String, ?> source, final boolean allProps )
+    protected static Map<String, Object> copyToMap(final Dictionary<String, ?> source, final boolean allProps)
     {
         Map<String, Object> target = new HashMap<String, Object>();
 
-        if ( source != null && !source.isEmpty() )
+        if (source != null && !source.isEmpty())
         {
-            for ( Enumeration<String> ce = source.keys(); ce.hasMoreElements(); )
+            for (Enumeration<String> ce = source.keys(); ce.hasMoreElements();)
             {
                 // cast is save, because key must be a string as per the spec
                 String key = ce.nextElement();
-                if ( allProps || key.charAt( 0 ) != '.' )
+                if (allProps || key.charAt(0) != '.')
                 {
-                    target.put( key, source.get( key ) );
+                    target.put(key, source.get(key));
                 }
             }
         }
@@ -1365,19 +1339,20 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return target;
     }
 
-    protected static Dictionary<String, Object> copyToDictionary( final Dictionary<String, ?> source, final boolean allProps )
+    protected static Dictionary<String, Object> copyToDictionary(final Dictionary<String, ?> source,
+        final boolean allProps)
     {
         Hashtable<String, Object> target = new Hashtable<String, Object>();
 
-        if ( source != null && !source.isEmpty() )
+        if (source != null && !source.isEmpty())
         {
-            for ( Enumeration<String> ce = source.keys(); ce.hasMoreElements(); )
+            for (Enumeration<String> ce = source.keys(); ce.hasMoreElements();)
             {
                 // cast is save, because key must be a string as per the spec
                 String key = ce.nextElement();
-                if ( allProps || key.charAt( 0 ) != '.' )
+                if (allProps || key.charAt(0) != '.')
                 {
-                    target.put( key, source.get( key ) );
+                    target.put(key, source.get(key));
                 }
             }
         }
@@ -1385,7 +1360,6 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
         return target;
     }
 
-
     /**
      *
      */
@@ -1398,35 +1372,41 @@ public abstract class AbstractComponentManager<S> implements SimpleLogger, Compo
     {
         return getState().getSpecState();
     }
-    
+
     State getState()
     {
         State s = state.get();
-        log( LogService.LOG_DEBUG, "Querying state {0}", new Object[] {s}, null);
+        log(LogService.LOG_DEBUG, "Querying state {0}", new Object[] { s }, null);
         return s;
     }
-    
+
     void setState(State previousState, State newState)
     {
         if (state.compareAndSet(previousState, newState))
         {
-            log( LogService.LOG_DEBUG, "Changed state from {0} to {1}", new Object[] {previousState, newState}, null);
+            log(LogService.LOG_DEBUG, "Changed state from {0} to {1}", new Object[] { previousState, newState }, null);
         }
         else
         {
-            log( LogService.LOG_DEBUG, "Did not change state from {0} to {1}: current state {2}", new Object[] {previousState, newState, state.get()}, null);
+            log(LogService.LOG_DEBUG, "Did not change state from {0} to {1}: current state {2}",
+                new Object[] { previousState, newState, state.get() }, null);
         }
 
     }
-    
+
     abstract boolean hasInstance();
 
-    public void setServiceProperties( MethodResult methodResult )
+    public void setServiceProperties(MethodResult methodResult, Integer trackingCount)
     {
-        if ( methodResult.hasResult() )
+        if (methodResult.hasResult())
         {
-            Dictionary<String, Object> serviceProps = ( methodResult.getResult() == null) ? null : new Hashtable<String, Object>( methodResult.getResult() );
-            setServiceProperties(serviceProps );
+            if (trackingCount != null)
+            {
+                tracked(trackingCount);
+            }
+            Dictionary<String, Object> serviceProps = (methodResult.getResult() == null) ? null
+                : new Hashtable<String, Object>(methodResult.getResult());
+            setServiceProperties(serviceProps);
         }
     }
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 9e133a16b0..7076601099 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -18,7 +18,6 @@
  */
 package org.apache.felix.scr.impl.manager;
 
-
 import java.security.Permission;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -48,7 +47,6 @@ import org.osgi.service.component.ComponentConstants;
 import org.osgi.service.component.ComponentException;
 import org.osgi.service.log.LogService;
 
-
 /**
  * The <code>DependencyManager</code> manages the references to services
  * declared by a single <code>&lt;reference&gt;</code element in component
@@ -83,29 +81,26 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param dependency An object that contains data about the dependency
      * @param index index of the dependency manager in the metadata
      */
-    DependencyManager( AbstractComponentManager<S> componentManager, ReferenceMetadata dependency, int index )
+    DependencyManager(AbstractComponentManager<S> componentManager, ReferenceMetadata dependency, int index)
     {
         m_componentManager = componentManager;
         m_dependencyMetadata = dependency;
         m_index = index;
         m_customizer = newCustomizer();
 
-        m_minCardinality = defaultMinimumCardinality( dependency );
+        m_minCardinality = defaultMinimumCardinality(dependency);
 
         // dump the reference information if DEBUG is enabled
-        if ( m_componentManager.isLogEnabled( LogService.LOG_DEBUG ) )
+        if (m_componentManager.isLogEnabled(LogService.LOG_DEBUG))
         {
-            m_componentManager
-                .log(
-                    LogService.LOG_DEBUG,
-                    "Dependency Manager created " + dependency.getDebugInfo(),
-                    null );
+            m_componentManager.log(LogService.LOG_DEBUG, "Dependency Manager created " + dependency.getDebugInfo(),
+                null);
         }
     }
 
     private static int defaultMinimumCardinality(ReferenceMetadata dependency)
     {
-        return dependency.isOptional()? 0: 1;
+        return dependency.isOptional() ? 0 : 1;
     }
 
     int getIndex()
@@ -118,7 +113,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      */
     void initBindingMethods(ReferenceMethods bindMethods)
     {
-       m_bindMethods = bindMethods;
+        m_bindMethods = bindMethods;
     }
 
     private interface Customizer<S, T> extends ServiceTrackerCustomizer<T, RefPair<S, T>, ExtendedServiceEvent>
@@ -133,15 +128,15 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         void close();
 
-        Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount );
+        Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount);
 
         boolean isSatisfied();
 
-        void setTracker( ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker );
+        void setTracker(ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker);
 
         void setTrackerOpened();
 
-        void setPreviousRefMap( Map<ServiceReference<T>, RefPair<S, T>> previousRefMap );
+        void setPreviousRefMap(Map<ServiceReference<T>, RefPair<S, T>> previousRefMap);
     }
 
     private abstract class AbstractCustomizer implements Customizer<S, T>
@@ -152,21 +147,22 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         private volatile Map<ServiceReference<T>, RefPair<S, T>> previousRefMap = EMPTY_REF_MAP;
 
-        public void setTracker( ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker )
+        public void setTracker(ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker)
         {
             m_tracker = tracker;
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracker reset (closed)", new Object[] {getName()}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracker reset (closed)", new Object[] { getName() },
+                null);
             trackerOpened = false;
         }
 
         public boolean isSatisfied()
         {
             ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-            if ( tracker == null)
+            if (tracker == null)
             {
                 return false;
             }
-            return cardinalitySatisfied( tracker.getServiceCount() );
+            return cardinalitySatisfied(tracker.getServiceCount());
         }
 
         protected ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> getTracker()
@@ -191,13 +187,13 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         public void setTrackerOpened()
         {
             trackerOpened = true;
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracker opened", new Object[] {getName()}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracker opened", new Object[] { getName() }, null);
         }
 
         protected void deactivateTracker()
         {
             ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-            if ( tracker != null )
+            if (tracker != null)
             {
                 tracker.deactivate();
             }
@@ -208,9 +204,9 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             return previousRefMap;
         }
 
-        public void setPreviousRefMap( Map<ServiceReference<T>, RefPair<S, T>> previousRefMap )
+        public void setPreviousRefMap(Map<ServiceReference<T>, RefPair<S, T>> previousRefMap)
         {
-            if ( previousRefMap != null )
+            if (previousRefMap != null)
             {
                 this.previousRefMap = previousRefMap;
             }
@@ -221,51 +217,54 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         }
 
-        protected void ungetService( RefPair<S, T> ref )
+        protected void ungetService(RefPair<S, T> ref)
         {
             Object service = ref.unsetServiceObject(null);
-            if ( service != null )
+            if (service != null)
             {
                 BundleContext bundleContext = m_componentManager.getBundleContext();
-                if ( bundleContext != null )
+                if (bundleContext != null)
                 {
-                    bundleContext.ungetService( ref.getRef() );
+                    bundleContext.ungetService(ref.getRef());
                 }
             }
         }
 
-        protected void tracked( int trackingCount )
+        protected void tracked(int trackingCount)
         {
-            m_componentManager.tracked( trackingCount );
+            m_componentManager.tracked(trackingCount);
         }
 
     }
 
+    private class FactoryCustomizer extends AbstractCustomizer
+    {
 
-    private class FactoryCustomizer extends AbstractCustomizer {
-
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
             RefPair<S, T> refPair = newRefPair(serviceReference);
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            if ( cardinalityJustSatisfied( serviceCount ) )
+            if (cardinalityJustSatisfied(serviceCount))
             {
-                m_componentManager.activateInternal( );
+                m_componentManager.activateInternal();
             }
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
             refPair.markDeleted();
-            if ( !cardinalitySatisfied( getTracker().getServiceCount() ) )
+            if (!cardinalitySatisfied(getTracker().getServiceCount()))
             {
                 deactivateComponentManager();
             }
@@ -273,9 +272,9 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
-            AtomicInteger trackingCount = new AtomicInteger( );
-            int serviceCount = getTracker().getTracked( true, trackingCount ).size();
-            return cardinalitySatisfied( serviceCount );
+            AtomicInteger trackingCount = new AtomicInteger();
+            int serviceCount = getTracker().getTracked(true, trackingCount).size();
+            return cardinalitySatisfied(serviceCount);
         }
 
         public void close()
@@ -283,120 +282,139 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             deactivateTracker();
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
             return Collections.emptyList();
         }
     }
 
-    private class MultipleDynamicCustomizer extends AbstractCustomizer {
+    private class MultipleDynamicCustomizer extends AbstractCustomizer
+    {
 
         private RefPair<S, T> lastRefPair;
         private int lastRefPairTrackingCount;
 
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
-            RefPair<S, T> refPair = getPreviousRefMap().get( serviceReference );
-            if ( refPair == null )
+            RefPair<S, T> refPair = getPreviousRefMap().get(serviceReference);
+            if (refPair == null)
             {
                 refPair = newRefPair(serviceReference);
             }
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic added {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
-        	boolean tracked = false;
-            if ( getPreviousRefMap().remove( serviceReference ) == null )
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic added {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            boolean tracked = false;
+            if (getPreviousRefMap().remove(serviceReference) == null)
             {
                 if (isActive())
                 {
-                    m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic already active, binding {2}", new Object[] {getName(), trackingCount, serviceReference}, null );
-                    m_componentManager.invokeBindMethod( DependencyManager.this, refPair, trackingCount );
-                    if ( refPair.isFailed() )
+                    m_componentManager.log(LogService.LOG_DEBUG,
+                        "dm {0} tracking {1} MultipleDynamic already active, binding {2}",
+                        new Object[] { getName(), trackingCount, serviceReference }, null);
+                    m_componentManager.invokeBindMethod(DependencyManager.this, refPair, trackingCount);
+                    if (refPair.isFailed())
                     {
-                        m_componentManager.registerMissingDependency( DependencyManager.this, serviceReference, trackingCount );
+                        m_componentManager.registerMissingDependency(DependencyManager.this, serviceReference,
+                            trackingCount);
                     }
                 }
-                else if ( isTrackerOpened() && cardinalityJustSatisfied( serviceCount ) )
+                else if (isTrackerOpened() && cardinalityJustSatisfied(serviceCount))
                 {
-                    m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic, activating", new Object[] {getName(), trackingCount}, null );
-                    tracked( trackingCount );
+                    m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic, activating",
+                        new Object[] { getName(), trackingCount }, null);
+                    tracked(trackingCount);
                     tracked = true;
-                    m_componentManager.activateInternal( );
+                    m_componentManager.activateInternal();
                 }
                 else
                 {
-                    m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic, inactive, doing nothing: tracker opened: {2}, optional: {3}", new Object[] {getName(), trackingCount, isTrackerOpened(), isOptional()}, null );
+                    m_componentManager.log(LogService.LOG_DEBUG,
+                        "dm {0} tracking {1} MultipleDynamic, inactive, doing nothing: tracker opened: {2}, optional: {3}",
+                        new Object[] { getName(), trackingCount, isTrackerOpened(), isOptional() }, null);
                 }
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic added {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            if ( !tracked )
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic added {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            if (!tracked)
             {
-				tracked(trackingCount);
-			}
+                tracked(trackingCount);
+            }
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic modified {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic modified {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             if (isActive())
             {
-                m_componentManager.invokeUpdatedMethod( DependencyManager.this, refPair, trackingCount );
+                m_componentManager.invokeUpdatedMethod(DependencyManager.this, refPair, trackingCount);
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic modified {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            tracked( trackingCount );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic modified {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            tracked(trackingCount);
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             refPair.markDeleted();
-            boolean unbind = cardinalitySatisfied( getTracker().getServiceCount() );
-            if ( unbind )
+            boolean unbind = cardinalitySatisfied(getTracker().getServiceCount());
+            if (unbind)
             {
-                if ( isActive() )
+                if (isActive())
                 {
-                    m_componentManager.invokeUnbindMethod( DependencyManager.this, refPair, trackingCount );
+                    m_componentManager.invokeUnbindMethod(DependencyManager.this, refPair, trackingCount);
                 }
-                m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed (unbind) {2}", new Object[] {getName(), trackingCount, serviceReference}, null );
-                tracked( trackingCount );
+                m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed (unbind) {2}",
+                    new Object[] { getName(), trackingCount, serviceReference }, null);
+                tracked(trackingCount);
             }
             else
             {
                 lastRefPair = refPair;
                 lastRefPairTrackingCount = trackingCount;
-                tracked( trackingCount );
+                tracked(trackingCount);
                 deactivateComponentManager();
                 lastRefPair = null;
-                m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleDynamic removed (deactivate) {2}", new Object[] {getName(), trackingCount, serviceReference}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "dm {0} tracking {1} MultipleDynamic removed (deactivate) {2}",
+                    new Object[] { getName(), trackingCount, serviceReference }, null);
             }
-            ungetService( refPair );
+            ungetService(refPair);
         }
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
             int serviceCount = 0;
-            AtomicInteger trackingCount = new AtomicInteger( );
-            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked( true, trackingCount );
-            List<RefPair<S,T>> failed = new ArrayList<RefPair<S, T>>();
-            for (RefPair<S, T> refPair: tracked.values())
+            AtomicInteger trackingCount = new AtomicInteger();
+            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked(true, trackingCount);
+            List<RefPair<S, T>> failed = new ArrayList<RefPair<S, T>>();
+            for (RefPair<S, T> refPair : tracked.values())
             {
-                if (getServiceObject( key, m_bindMethods.getBind(), refPair ))
+                if (getServiceObject(key, m_bindMethods.getBind(), refPair))
                 {
-                     serviceCount++;
+                    serviceCount++;
                 }
                 else
                 {
                     failed.add(refPair);
                 }
             }
-            if ( cardinalitySatisfied( serviceCount ) ) 
+            if (cardinalitySatisfied(serviceCount))
             {
-                for ( RefPair<S, T> refPair: failed) 
+                for (RefPair<S, T> refPair : failed)
                 {
-                    m_componentManager.registerMissingDependency( DependencyManager.this, refPair.getRef(), trackingCount.get() );                    
+                    m_componentManager.registerMissingDependency(DependencyManager.this, refPair.getRef(),
+                        trackingCount.get());
                 }
                 return true;
             }
@@ -405,52 +423,54 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         public void close()
         {
-            AtomicInteger trackingCount = new AtomicInteger( );
-            for ( RefPair<S, T> ref : getRefs( trackingCount ) )
+            AtomicInteger trackingCount = new AtomicInteger();
+            for (RefPair<S, T> ref : getRefs(trackingCount))
             {
-                ungetService( ref );
+                ungetService(ref);
             }
             deactivateTracker();
         }
 
-
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
-            if ( lastRefPair == null )
+            if (lastRefPair == null)
             {
                 ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-                if (tracker == null) {
-                    trackingCount.set( lastRefPairTrackingCount );
+                if (tracker == null)
+                {
+                    trackingCount.set(lastRefPairTrackingCount);
                     return Collections.emptyList();
                 }
-                return getTracker().getTracked( null, trackingCount ).values();
+                return getTracker().getTracked(null, trackingCount).values();
             }
             else
             {
-                trackingCount.set( lastRefPairTrackingCount );
-                return Collections.singletonList( lastRefPair );
+                trackingCount.set(lastRefPairTrackingCount);
+                return Collections.singletonList(lastRefPair);
             }
         }
     }
 
-    private class MultipleStaticGreedyCustomizer extends AbstractCustomizer {
-
+    private class MultipleStaticGreedyCustomizer extends AbstractCustomizer
+    {
 
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
             RefPair<S, T> refPair = newRefPair(serviceReference);
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy added {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            tracked( trackingCount );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy added {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            tracked(trackingCount);
             if (isActive())
             {
-                m_componentManager.log( LogService.LOG_DEBUG,
-                        "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
-                        {getName(), m_dependencyMetadata.getInterface()}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "Dependency Manager: Static dependency on {0}/{1} is broken",
+                    new Object[] { getName(), m_dependencyMetadata.getInterface() }, null);
                 deactivateComponentManager();
                 //event may be null during initial operations.
                 if (event != null)
@@ -459,23 +479,27 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 }
 
             }
-            else if ( isTrackerOpened() && cardinalityJustSatisfied( serviceCount ) )
+            else if (isTrackerOpened() && cardinalityJustSatisfied(serviceCount))
             {
-                m_componentManager.activateInternal( );
+                m_componentManager.activateInternal();
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy added {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy added {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy modified {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticGreedy modified {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             boolean reactivate = false;
             if (isActive())
             {
-            	reactivate = m_componentManager.invokeUpdatedMethod( DependencyManager.this, refPair, trackingCount );
+                reactivate = m_componentManager.invokeUpdatedMethod(DependencyManager.this, refPair, trackingCount);
             }
-            tracked( trackingCount );
-            if ( reactivate )
+            tracked(trackingCount);
+            if (reactivate)
             {
                 deactivateComponentManager();
                 if (event != null)
@@ -483,20 +507,23 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     event.addComponentManager(m_componentManager);
                 }
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy modified {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy modified {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy removed {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy removed {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             refPair.markDeleted();
-            tracked( trackingCount );
-            if ( isActive() )
+            tracked(trackingCount);
+            if (isActive())
             {
                 //deactivate while ref is still tracked
-                m_componentManager.log( LogService.LOG_DEBUG,
-                        "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
-                        {getName(), m_dependencyMetadata.getInterface()}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "Dependency Manager: Static dependency on {0}/{1} is broken",
+                    new Object[] { getName(), m_dependencyMetadata.getInterface() }, null);
                 deactivateComponentManager();
                 //try to reactivate after ref is no longer tracked.
                 if (event != null)
@@ -504,87 +531,98 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     event.addComponentManager(m_componentManager);
                 }
             }
-            else if ( !cardinalitySatisfied( getTracker().getServiceCount() ) ) //may be called from an old tracker, so getTracker() may give a different answer
+            else if (!cardinalitySatisfied(getTracker().getServiceCount())) //may be called from an old tracker, so getTracker() may give a different answer
             {
-                m_componentManager.log( LogService.LOG_DEBUG,
-                        "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
-                        {getName(), m_dependencyMetadata.getInterface()}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "Dependency Manager: Static dependency on {0}/{1} is broken",
+                    new Object[] { getName(), m_dependencyMetadata.getInterface() }, null);
                 deactivateComponentManager();
             }
             //This is unlikely
-            ungetService( refPair );
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy removed {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            ungetService(refPair);
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticGreedy removed {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
             int serviceCount = 0;
-            AtomicInteger trackingCount = new AtomicInteger( );
+            AtomicInteger trackingCount = new AtomicInteger();
             final ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = tracker.getTracked( cardinalitySatisfied( tracker.getServiceCount() ), trackingCount );
-            for (RefPair<S, T> refPair: tracked.values())
+            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = tracker.getTracked(
+                cardinalitySatisfied(tracker.getServiceCount()), trackingCount);
+            for (RefPair<S, T> refPair : tracked.values())
             {
-                if ( getServiceObject( key, m_bindMethods.getBind(), refPair ) )
+                if (getServiceObject(key, m_bindMethods.getBind(), refPair))
                 {
                     serviceCount++;
                 }
             }
-            return cardinalitySatisfied( serviceCount );
+            return cardinalitySatisfied(serviceCount);
         }
 
         public void close()
         {
-            AtomicInteger trackingCount = new AtomicInteger( );
-            for ( RefPair<S, T> ref: getRefs( trackingCount ))
+            AtomicInteger trackingCount = new AtomicInteger();
+            for (RefPair<S, T> ref : getRefs(trackingCount))
             {
-                ungetService( ref );
+                ungetService(ref);
             }
             deactivateTracker();
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
             ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-            if (tracker == null) {
+            if (tracker == null)
+            {
                 return Collections.emptyList();
             }
-            return tracker.getTracked( null, trackingCount ).values();
+            return tracker.getTracked(null, trackingCount).values();
         }
     }
 
-    private class MultipleStaticReluctantCustomizer extends AbstractCustomizer {
+    private class MultipleStaticReluctantCustomizer extends AbstractCustomizer
+    {
 
         private final AtomicReference<Collection<RefPair<S, T>>> refs = new AtomicReference<Collection<RefPair<S, T>>>();
         private int trackingCount;
 
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
             RefPair<S, T> refPair = newRefPair(serviceReference);
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant added {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            tracked( trackingCount );
-            if ( isTrackerOpened() && cardinalityJustSatisfied( serviceCount ) && !isActive())
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticReluctant added {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            tracked(trackingCount);
+            if (isTrackerOpened() && cardinalityJustSatisfied(serviceCount) && !isActive())
             {
-                m_componentManager.activateInternal( );
+                m_componentManager.activateInternal();
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant added {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant added {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant modified {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticReluctant modified {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             boolean reactivate = false;
             Collection<RefPair<S, T>> refs = this.refs.get();
-            if (isActive() && refs.contains( refPair ))
+            if (isActive() && refs.contains(refPair))
             {
-                reactivate = m_componentManager.invokeUpdatedMethod( DependencyManager.this, refPair, trackingCount );
+                reactivate = m_componentManager.invokeUpdatedMethod(DependencyManager.this, refPair, trackingCount);
             }
-            tracked( trackingCount );
-            if ( reactivate )
+            tracked(trackingCount);
+            if (reactivate)
             {
                 deactivateComponentManager();
                 if (event != null)
@@ -592,23 +630,28 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     event.addComponentManager(m_componentManager);
                 }
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant modified {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticReluctant modified {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant removed {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticReluctant removed {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             refPair.markDeleted();
-            tracked( trackingCount );
+            tracked(trackingCount);
             Collection<RefPair<S, T>> refs = this.refs.get();
-            if ( isActive() && refs != null )
+            if (isActive() && refs != null)
             {
-                if (refs.contains( refPair ))
+                if (refs.contains(refPair))
                 {
                     //we are tracking the used refs, so we can deactivate here.
-                    m_componentManager.log( LogService.LOG_DEBUG,
-                        "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
-                            { getName(), m_dependencyMetadata.getInterface() }, null );
+                    m_componentManager.log(LogService.LOG_DEBUG,
+                        "Dependency Manager: Static dependency on {0}/{1} is broken",
+                        new Object[] { getName(), m_dependencyMetadata.getInterface() }, null);
                     deactivateComponentManager();
 
                     // FELIX-2368: immediately try to reactivate
@@ -619,44 +662,47 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
                 }
             }
-            else if ( !cardinalitySatisfied( getTracker().getServiceCount() ) )
+            else if (!cardinalitySatisfied(getTracker().getServiceCount()))
             {
-                m_componentManager.log( LogService.LOG_DEBUG,
-                        "Dependency Manager: Static dependency on {0}/{1} is broken", new Object[]
-                        {getName(), m_dependencyMetadata.getInterface()}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "Dependency Manager: Static dependency on {0}/{1} is broken",
+                    new Object[] { getName(), m_dependencyMetadata.getInterface() }, null);
                 deactivateComponentManager();
             }
-            ungetService( refPair );
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} MultipleStaticReluctant removed {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            ungetService(refPair);
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "dm {0} tracking {1} MultipleStaticReluctant removed {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
             int serviceCount = 0;
             Collection<RefPair<S, T>> refs = this.refs.get();
-            if (refs != null) {
+            if (refs != null)
+            {
                 //another thread is concurrently opening, and it got done already
-                for (RefPair<S, T> refPair: refs)
+                for (RefPair<S, T> refPair : refs)
                 {
-                    if (getServiceObject( key, m_bindMethods.getBind(), refPair ))
+                    if (getServiceObject(key, m_bindMethods.getBind(), refPair))
                     {
                         serviceCount++;
                     }
                 }
-                return cardinalitySatisfied( serviceCount );
+                return cardinalitySatisfied(serviceCount);
             }
             refs = new ArrayList<RefPair<S, T>>();
-            AtomicInteger trackingCount = new AtomicInteger( );
-            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked( true, trackingCount );
-            for (RefPair<S, T> refPair: tracked.values())
+            AtomicInteger trackingCount = new AtomicInteger();
+            SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked(true, trackingCount);
+            for (RefPair<S, T> refPair : tracked.values())
             {
-                if (getServiceObject( key, m_bindMethods.getBind(), refPair ))
+                if (getServiceObject(key, m_bindMethods.getBind(), refPair))
                 {
                     serviceCount++;
                 }
-                refs.add(refPair) ;
+                refs.add(refPair);
             }
-            if ( this.refs.compareAndSet( null, refs ) )
+            if (this.refs.compareAndSet(null, refs))
             {
                 this.trackingCount = trackingCount.get();
             }
@@ -664,200 +710,210 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             {
                 //some other thread got done first.  If we have more refPairs, we might need to unget some services.
                 Collection<RefPair<S, T>> actualRefs = this.refs.get();
-                refs.removeAll( actualRefs );
-                for (RefPair<S, T> ref: refs)
+                refs.removeAll(actualRefs);
+                for (RefPair<S, T> ref : refs)
                 {
-                    ungetService( ref );
+                    ungetService(ref);
                 }
             }
-            return cardinalitySatisfied( serviceCount );
+            return cardinalitySatisfied(serviceCount);
         }
 
         public void close()
         {
-            Collection<RefPair<S, T>> refs = this.refs.getAndSet( null );
-            if ( refs != null )
+            Collection<RefPair<S, T>> refs = this.refs.getAndSet(null);
+            if (refs != null)
             {
-                for ( RefPair<S, T> ref: refs )
+                for (RefPair<S, T> ref : refs)
                 {
-                    ungetService( ref );
+                    ungetService(ref);
                 }
             }
             deactivateTracker();
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
-            trackingCount.set( this.trackingCount );
+            trackingCount.set(this.trackingCount);
             Collection<RefPair<S, T>> refs = this.refs.get();
-            return refs == null? Collections.<RefPair<S, T>>emptyList(): refs;
+            return refs == null ? Collections.<RefPair<S, T>> emptyList() : refs;
         }
     }
 
-    private class SingleDynamicCustomizer extends AbstractCustomizer {
+    private class SingleDynamicCustomizer extends AbstractCustomizer
+    {
 
         private RefPair<S, T> refPair;
         private int trackingCount;
 
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
-            RefPair<S, T> refPair = getPreviousRefMap().get( serviceReference );
-            if ( refPair == null )
+            RefPair<S, T> refPair = getPreviousRefMap().get(serviceReference);
+            if (refPair == null)
             {
                 refPair = newRefPair(serviceReference);
             }
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic added {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic added {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             boolean tracked = false;
-            if ( getPreviousRefMap().remove( serviceReference ) == null )
+            if (getPreviousRefMap().remove(serviceReference) == null)
             {
-                if (isActive() )
+                if (isActive())
                 {
                     boolean invokeBind;
-                    synchronized ( getTracker().tracked() )
+                    synchronized (getTracker().tracked())
                     {
                         invokeBind = this.refPair == null
-                                || ( !isReluctant() && refPair.getRef().compareTo( this.refPair.getRef() ) > 0 );
+                            || (!isReluctant() && refPair.getRef().compareTo(this.refPair.getRef()) > 0);
                     }
-                    if ( invokeBind )
+                    if (invokeBind)
                     {
-                        m_componentManager.invokeBindMethod( DependencyManager.this, refPair, trackingCount );
-                        if ( !refPair.isFailed() )
+                        m_componentManager.invokeBindMethod(DependencyManager.this, refPair, trackingCount);
+                        if (!refPair.isFailed())
                         {
-                            if ( this.refPair != null )
+                            if (this.refPair != null)
                             {
-                                m_componentManager.invokeUnbindMethod( DependencyManager.this, this.refPair,
-                                        trackingCount );
+                                m_componentManager.invokeUnbindMethod(DependencyManager.this, this.refPair,
+                                    trackingCount);
                                 closeRefPair();
                             }
                         }
-                        else if ( cardinalitySatisfied( 0 ) )
+                        else if (cardinalitySatisfied(0))
                         {
-                            m_componentManager.registerMissingDependency( DependencyManager.this, serviceReference,
-                                    trackingCount );
+                            m_componentManager.registerMissingDependency(DependencyManager.this, serviceReference,
+                                trackingCount);
                         }
                         this.refPair = refPair;
                     }
                 }
-                else if ( isTrackerOpened() && cardinalityJustSatisfied( serviceCount ) )
+                else if (isTrackerOpened() && cardinalityJustSatisfied(serviceCount))
                 {
-                    tracked( trackingCount );
+                    tracked(trackingCount);
                     tracked = true;
-                    m_componentManager.activateInternal( );
+                    m_componentManager.activateInternal();
                 }
             }
             this.trackingCount = trackingCount;
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic added {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            if ( !tracked )
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic added {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            if (!tracked)
             {
                 tracked(trackingCount);
             }
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic modified {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic modified {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             boolean invokeUpdated;
             synchronized (getTracker().tracked())
             {
                 invokeUpdated = isActive() && refPair == this.refPair;
             }
-            if ( invokeUpdated )
+            if (invokeUpdated)
             {
-                m_componentManager.invokeUpdatedMethod( DependencyManager.this, refPair, trackingCount );
+                m_componentManager.invokeUpdatedMethod(DependencyManager.this, refPair, trackingCount);
             }
             this.trackingCount = trackingCount;
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic modified {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
-            tracked( trackingCount );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic modified {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
+            tracked(trackingCount);
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic removed {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic removed {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             refPair.markDeleted();
             boolean deactivate = false;
             boolean untracked = true;
             RefPair<S, T> oldRefPair = null;
             RefPair<S, T> nextRefPair = null;
-            synchronized ( getTracker().tracked() )
+            synchronized (getTracker().tracked())
             {
-                if ( refPair == this.refPair && isActive() )
+                if (refPair == this.refPair && isActive())
                 {
-                    if ( !getTracker().isEmpty() )
+                    if (!getTracker().isEmpty())
                     {
                         AtomicInteger trackingCount2 = new AtomicInteger();
-                        SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked( true, //TODO true here looks odd.
-                                trackingCount2 );
+                        SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked(true, //TODO true here looks odd.
+                            trackingCount2);
                         nextRefPair = tracked.values().iterator().next();
                     }
 
                     //n.b. we cannot use cardinalitySatisfied( serviceCount ) here as the call may come from an old tracker during target change.
-                    if ( isEffectivelyOptional() || nextRefPair != null )
+                    if (isEffectivelyOptional() || nextRefPair != null)
                     {
                         oldRefPair = this.refPair;
                         this.refPair = null;
                     }
                     else
                     {
-                        deactivate = true;            //required and no replacement service, deactivate
+                        deactivate = true; //required and no replacement service, deactivate
                     }
                 }
-                else if ( !cardinalitySatisfied( getTracker().getServiceCount() ) && this.refPair == null)
+                else if (!cardinalitySatisfied(getTracker().getServiceCount()) && this.refPair == null)
                 {
                     deactivate = true;
                 }
             }
-            if ( nextRefPair != null )
+            if (nextRefPair != null)
             {
-                m_componentManager.invokeBindMethod( DependencyManager.this, nextRefPair,
-                            trackingCount );
+                m_componentManager.invokeBindMethod(DependencyManager.this, nextRefPair, trackingCount);
             }
 
-            if ( oldRefPair != null )
+            if (oldRefPair != null)
             {
                 this.trackingCount = trackingCount;
-                m_componentManager.invokeUnbindMethod( DependencyManager.this, oldRefPair, trackingCount );
-                synchronized ( getTracker().tracked() )
+                m_componentManager.invokeUnbindMethod(DependencyManager.this, oldRefPair, trackingCount);
+                synchronized (getTracker().tracked())
                 {
                     this.refPair = nextRefPair;
                 }
-                tracked( trackingCount );
+                tracked(trackingCount);
                 untracked = false;
             }
-            else if ( deactivate )
+            else if (deactivate)
             {
                 this.trackingCount = trackingCount;
-                tracked( trackingCount );
+                tracked(trackingCount);
                 untracked = false;
                 deactivateComponentManager();
             }
-            if ( oldRefPair != null )
+            if (oldRefPair != null)
             {
-                ungetService( oldRefPair );
+                ungetService(oldRefPair);
             }
             if (untracked) // not ours
             {
                 this.trackingCount = trackingCount;
-                tracked( trackingCount );
+                tracked(trackingCount);
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic removed {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleDynamic removed {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
             RefPair<S, T> refPair = null;
-            boolean success = cardinalitySatisfied( 0 );
+            boolean success = cardinalitySatisfied(0);
             AtomicInteger trackingCount = new AtomicInteger();
-            synchronized ( getTracker().tracked() )
+            synchronized (getTracker().tracked())
             {
-                if ( success || !getTracker().isEmpty() )
+                if (success || !getTracker().isEmpty())
                 {
-                    SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked( true, trackingCount );
-                    if ( !tracked.isEmpty() )
+                    SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked(true,
+                        trackingCount);
+                    if (!tracked.isEmpty())
                     {
                         refPair = tracked.values().iterator().next();
                         this.refPair = refPair;
@@ -866,11 +922,11 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             }
             if (refPair != null)
             {
-                success |= getServiceObject( key, m_bindMethods.getBind(), refPair );
-                if ( refPair.isFailed() &&  cardinalitySatisfied( 0 ))
+                success |= getServiceObject(key, m_bindMethods.getBind(), refPair);
+                if (refPair.isFailed() && cardinalitySatisfied(0))
                 {
-                    m_componentManager.registerMissingDependency( DependencyManager.this, refPair.getRef(),
-                            trackingCount.get() );
+                    m_componentManager.registerMissingDependency(DependencyManager.this, refPair.getRef(),
+                        trackingCount.get());
                 }
             }
             return success;
@@ -884,22 +940,22 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         private void closeRefPair()
         {
-            if ( refPair != null )
+            if (refPair != null)
             {
-                ungetService( refPair );
+                ungetService(refPair);
             }
             refPair = null;
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
-            Object monitor = getTracker() == null? null: getTracker().tracked();
-            if ( monitor != null )
+            Object monitor = getTracker() == null ? null : getTracker().tracked();
+            if (monitor != null)
             {
-                synchronized ( monitor )
+                synchronized (monitor)
                 {
-                    trackingCount.set( this.trackingCount );
-                    return refPair == null? Collections.<RefPair<S, T>> emptyList(): Collections.singleton( refPair );
+                    trackingCount.set(this.trackingCount);
+                    return refPair == null ? Collections.<RefPair<S, T>> emptyList() : Collections.singleton(refPair);
                 }
             }
             else
@@ -915,25 +971,28 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         private RefPair<S, T> refPair;
         private int trackingCount;
 
-        public RefPair<S, T> addingService( ServiceReference<T> serviceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> serviceReference)
         {
             RefPair<S, T> refPair = newRefPair(serviceReference);
             return refPair;
         }
 
-        public void addedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic added {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic added {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             this.trackingCount = trackingCount;
-            tracked( trackingCount );
-            if ( isActive() )
+            tracked(trackingCount);
+            if (isActive())
             {
                 boolean reactivate;
                 synchronized (getTracker().tracked())
                 {
-                    reactivate = !isReluctant() && ( this.refPair == null || refPair.getRef().compareTo( this.refPair.getRef() ) > 0 );
+                    reactivate = !isReluctant()
+                        && (this.refPair == null || refPair.getRef().compareTo(this.refPair.getRef()) > 0);
                 }
-                if ( reactivate )
+                if (reactivate)
                 {
                     deactivateComponentManager();
                     if (event != null)
@@ -943,23 +1002,30 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 }
                 else
                 {
-                    m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic active but new {2} is worse match than old {3}", new Object[] {getName(), trackingCount, refPair, this.refPair, }, null );
+                    m_componentManager.log(LogService.LOG_DEBUG,
+                        "dm {0} tracking {1} SingleStatic active but new {2} is worse match than old {3}",
+                        new Object[] { getName(), trackingCount, refPair, this.refPair, }, null);
                 }
             }
-            else if (isTrackerOpened() && cardinalityJustSatisfied( serviceCount ) )
+            else if (isTrackerOpened() && cardinalityJustSatisfied(serviceCount))
             {
-                m_componentManager.activateInternal( );
+                m_componentManager.activateInternal();
             }
             else
             {
-                m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic active: {2} trackerOpened: {3} optional: {4}", new Object[] {getName(), trackingCount, isActive(), isTrackerOpened(), isOptional()}, null );
+                m_componentManager.log(LogService.LOG_DEBUG,
+                    "dm {0} tracking {1} SingleStatic active: {2} trackerOpened: {3} optional: {4}",
+                    new Object[] { getName(), trackingCount, isActive(), isTrackerOpened(), isOptional() }, null);
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic added {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic added {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void modifiedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic modified {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic modified {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             boolean invokeUpdated;
             final Object sync = getTracker().tracked();
             synchronized (sync)
@@ -967,16 +1033,16 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                 invokeUpdated = isActive() && refPair == this.refPair;
             }
             boolean reactivate = false;
-            if ( invokeUpdated )
+            if (invokeUpdated)
             {
-                reactivate = m_componentManager.invokeUpdatedMethod( DependencyManager.this, refPair, trackingCount );
+                reactivate = m_componentManager.invokeUpdatedMethod(DependencyManager.this, refPair, trackingCount);
             }
             this.trackingCount = trackingCount;
-            tracked( trackingCount );
-            if ( reactivate )
+            tracked(trackingCount);
+            if (reactivate)
             {
                 deactivateComponentManager();
-                synchronized ( sync )
+                synchronized (sync)
                 {
                     if (refPair == this.refPair)
                     {
@@ -988,28 +1054,33 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     event.addComponentManager(m_componentManager);
                 }
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic modified {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic modified {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
-        public void removedService( ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> serviceReference, RefPair<S, T> refPair, int trackingCount,
+            ExtendedServiceEvent event)
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic removed {2} (enter)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic removed {2} (enter)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
             refPair.markDeleted();
             this.trackingCount = trackingCount;
-            tracked( trackingCount );
+            tracked(trackingCount);
             boolean reactivate;
             final Object sync = getTracker().tracked();
             synchronized (sync)
             {
-                reactivate = ( isActive() && refPair == this.refPair) || ( !cardinalitySatisfied( getTracker().getServiceCount() ));
-                if (!reactivate && refPair == this.refPair) {
+                reactivate = (isActive() && refPair == this.refPair)
+                    || (!cardinalitySatisfied(getTracker().getServiceCount()));
+                if (!reactivate && refPair == this.refPair)
+                {
                     this.refPair = null;
                 }
             }
-            if ( reactivate )
+            if (reactivate)
             {
                 deactivateComponentManager();
-                synchronized ( sync )
+                synchronized (sync)
                 {
                     if (refPair == this.refPair)
                     {
@@ -1021,32 +1092,34 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
                     event.addComponentManager(m_componentManager);
                 }
             }
-            m_componentManager.log( LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic removed {2} (exit)", new Object[] {getName(), trackingCount, serviceReference}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "dm {0} tracking {1} SingleStatic removed {2} (exit)",
+                new Object[] { getName(), trackingCount, serviceReference }, null);
         }
 
         public boolean prebind(ComponentContextImpl<S> key)
         {
-            boolean success = cardinalitySatisfied( 0 );
-            if ( success || !getTracker().isEmpty() )
+            boolean success = cardinalitySatisfied(0);
+            if (success || !getTracker().isEmpty())
             {
                 RefPair<S, T> refPair = null;
                 AtomicInteger trackingCount = new AtomicInteger();
-                synchronized ( getTracker().tracked() )
+                synchronized (getTracker().tracked())
                 {
-                    SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked( true, trackingCount );
-                    if ( !tracked.isEmpty() )
+                    SortedMap<ServiceReference<T>, RefPair<S, T>> tracked = getTracker().getTracked(true,
+                        trackingCount);
+                    if (!tracked.isEmpty())
                     {
                         refPair = tracked.values().iterator().next();
                         this.refPair = refPair;
                     }
                 }
-                if ( refPair != null )
+                if (refPair != null)
                 {
-                    success |= getServiceObject( key, m_bindMethods.getBind(), refPair );
-                    if ( refPair.isFailed() )
+                    success |= getServiceObject(key, m_bindMethods.getBind(), refPair);
+                    if (refPair.isFailed())
                     {
-                        m_componentManager.registerMissingDependency( DependencyManager.this, refPair.getRef(),
-                                trackingCount.get() );
+                        m_componentManager.registerMissingDependency(DependencyManager.this, refPair.getRef(),
+                            trackingCount.get());
                     }
                 }
             }
@@ -1056,31 +1129,31 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         public void close()
         {
             ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = getTracker();
-            if ( tracker != null )
+            if (tracker != null)
             {
                 RefPair<S, T> ref;
-                synchronized ( tracker.tracked() )
+                synchronized (tracker.tracked())
                 {
                     ref = refPair;
                     refPair = null;
                 }
-                if ( ref != null )
+                if (ref != null)
                 {
-                    ungetService( ref );
+                    ungetService(ref);
                 }
                 tracker.deactivate();
             }
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
-            Object monitor = getTracker() == null? null: getTracker().tracked();
-            if ( monitor != null )
+            Object monitor = getTracker() == null ? null : getTracker().tracked();
+            if (monitor != null)
             {
-                synchronized ( monitor )
+                synchronized (monitor)
                 {
-                    trackingCount.set( this.trackingCount );
-                    return refPair == null? Collections.<RefPair<S, T>> emptyList(): Collections.singleton( refPair );
+                    trackingCount.set(this.trackingCount);
+                    return refPair == null ? Collections.<RefPair<S, T>> emptyList() : Collections.singleton(refPair);
                 }
             }
             else
@@ -1102,7 +1175,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         {
         }
 
-        public Collection<RefPair<S, T>> getRefs( AtomicInteger trackingCount )
+        public Collection<RefPair<S, T>> getRefs(AtomicInteger trackingCount)
         {
             return Collections.emptyList();
         }
@@ -1112,7 +1185,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             return isOptional();
         }
 
-        public void setTracker( ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tRefPairServiceTracker )
+        public void setTracker(ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tRefPairServiceTracker)
         {
         }
 
@@ -1120,24 +1193,27 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         {
         }
 
-        public void setPreviousRefMap( Map<ServiceReference<T>, RefPair<S, T>> previousRefMap )
+        public void setPreviousRefMap(Map<ServiceReference<T>, RefPair<S, T>> previousRefMap)
         {
         }
 
-        public RefPair<S, T> addingService( ServiceReference<T> tServiceReference )
+        public RefPair<S, T> addingService(ServiceReference<T> tServiceReference)
         {
             return null;
         }
 
-        public void addedService( ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount, int serviceCount, ExtendedServiceEvent event )
+        public void addedService(ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount,
+            int serviceCount, ExtendedServiceEvent event)
         {
         }
 
-        public void modifiedService( ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount, ExtendedServiceEvent event )
+        public void modifiedService(ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount,
+            ExtendedServiceEvent event)
         {
         }
 
-        public void removedService( ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount, ExtendedServiceEvent event )
+        public void removedService(ServiceReference<T> tServiceReference, RefPair<S, T> service, int trackingCount,
+            ExtendedServiceEvent event)
         {
         }
     }
@@ -1172,7 +1248,6 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return m_dependencyMetadata.isMultiple();
     }
 
-
     private boolean isStatic()
     {
         return m_dependencyMetadata.isStatic();
@@ -1185,13 +1260,11 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
     //---------- Service tracking support -------------------------------------
 
-
     void deactivate()
     {
         m_customizer.close();
     }
 
-
     /**
      * Returns the number of services currently registered in the system,
      * which match the service criteria (interface and optional target filter)
@@ -1204,51 +1277,49 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      */
     int size()
     {
-        AtomicInteger trackingCount = new AtomicInteger( );
-        return m_tracker.getTracked( null, trackingCount ).size();
+        AtomicInteger trackingCount = new AtomicInteger();
+        return m_tracker.getTracked(null, trackingCount).size();
     }
 
-
-    private ServiceReference<T>[] getFrameworkServiceReferences( String targetFilter )
+    private ServiceReference<T>[] getFrameworkServiceReferences(String targetFilter)
     {
-        if ( hasGetPermission() )
+        if (hasGetPermission())
         {
             // component activator may be null if disposed concurrently
             ComponentActivator bca = m_componentManager.getActivator();
-            if ( bca == null )
+            if (bca == null)
             {
                 return null;
             }
 
             // get bundle context, may be null if component deactivated since getting bca
             BundleContext bc = bca.getBundleContext();
-            if ( bc == null )
+            if (bc == null)
             {
                 return null;
             }
 
             try
             {
-                return ( ServiceReference<T>[] ) bc.getServiceReferences(
-                    m_dependencyMetadata.getInterface(), targetFilter );
+                return (ServiceReference<T>[]) bc.getServiceReferences(m_dependencyMetadata.getInterface(),
+                    targetFilter);
             }
-            catch ( IllegalStateException ise )
+            catch (IllegalStateException ise)
             {
                 // bundle context is not valid any longer, cannot log
             }
-            catch ( InvalidSyntaxException ise )
+            catch (InvalidSyntaxException ise)
             {
-                m_componentManager.log( LogService.LOG_ERROR, "Unexpected problem with filter ''{0}''", new Object[]
-                    { targetFilter }, ise );
+                m_componentManager.log(LogService.LOG_ERROR, "Unexpected problem with filter ''{0}''",
+                    new Object[] { targetFilter }, ise);
                 return null;
             }
         }
 
-        m_componentManager.log( LogService.LOG_DEBUG, "No permission to access the services", null );
+        m_componentManager.log(LogService.LOG_DEBUG, "No permission to access the services", null);
         return null;
     }
 
-
     /**
      * Returns a <code>ServiceReference</code> instances for a service
      * implementing the interface and complying to the (optional) target filter
@@ -1263,7 +1334,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      */
     private RefPair<S, T> getBestRefPair()
     {
-        Collection<RefPair<S, T>> refs = m_customizer.getRefs( new AtomicInteger( ) );
+        Collection<RefPair<S, T>> refs = m_customizer.getRefs(new AtomicInteger());
         if (refs.isEmpty())
         {
             return null;
@@ -1271,7 +1342,6 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return refs.iterator().next();
     }
 
-
     /**
      * Returns the service instance for the service reference returned by the
      * {@link #getBestRefPair()} method. If this returns a
@@ -1282,10 +1352,9 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
     T getService(ComponentContextImpl<S> key)
     {
         RefPair<S, T> sr = getBestRefPair();
-        return getService( key, sr );
+        return getService(key, sr);
     }
 
-
     /**
      * Returns an array of service instances for the service references returned
      * by the customizer. If no services
@@ -1296,30 +1365,29 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      */
     T[] getServices(ComponentContextImpl<S> key)
     {
-        Collection<RefPair<S, T>> refs = m_customizer.getRefs(  new AtomicInteger( ) );
-        List<T> services = new ArrayList<T>( refs.size() );
-        for ( RefPair<S, T> ref: refs)
+        Collection<RefPair<S, T>> refs = m_customizer.getRefs(new AtomicInteger());
+        List<T> services = new ArrayList<T>(refs.size());
+        for (RefPair<S, T> ref : refs)
         {
             T service = getService(key, ref);
             if (service != null)
             {
-                services.add( service );
+                services.add(service);
             }
         }
-        return services.isEmpty()? null: (T[])services.toArray( new Object[ services.size()] );
+        return services.isEmpty() ? null : (T[]) services.toArray(new Object[services.size()]);
     }
 
-
     //---------- bound services maintenance -----------------------------------
 
     /* (non-Javadoc)
-	 * @see org.apache.felix.scr.impl.manager.ReferenceManager#getServiceReferences()
-	 */
+     * @see org.apache.felix.scr.impl.manager.ReferenceManager#getServiceReferences()
+     */
     public List<ServiceReference<?>> getServiceReferences()
     {
-        Collection<RefPair<S, T>> bound = m_customizer.getRefs(  new AtomicInteger( ) );
+        Collection<RefPair<S, T>> bound = m_customizer.getRefs(new AtomicInteger());
         List<ServiceReference<?>> result = new ArrayList<ServiceReference<?>>(bound.size());
-        for (RefPair<S, T> ref: bound)
+        for (RefPair<S, T> ref : bound)
         {
             result.add(ref.getRef());
         }
@@ -1337,18 +1405,17 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      *      if the service is bound or <code>null</code> if the service is not
      *      bound.
      */
-    private RefPair<S, T> getRefPair( ServiceReference<T> serviceReference )
+    private RefPair<S, T> getRefPair(ServiceReference<T> serviceReference)
     {
         final ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = m_tracker;
-        if ( tracker != null )
+        if (tracker != null)
         {
-            AtomicInteger trackingCount = new AtomicInteger( );
-            return tracker.getTracked( null, trackingCount ).get( serviceReference );
+            AtomicInteger trackingCount = new AtomicInteger();
+            return tracker.getTracked(null, trackingCount).get(serviceReference);
         }
         return null;
     }
 
-
     /**
      * Returns the service described by the ServiceReference. If this instance
      * is already bound the given service, that bound service instance is
@@ -1360,14 +1427,14 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @return The requested service or <code>null</code> if no service is
      *      registered for the service reference (any more).
      */
-    T getService( ComponentContextImpl<S> key, ServiceReference<T> serviceReference )
+    T getService(ComponentContextImpl<S> key, ServiceReference<T> serviceReference)
     {
         // check whether we already have the service and return that one
-        RefPair<S, T> refPair = getRefPair( serviceReference );
-        return getService( key, refPair );
+        RefPair<S, T> refPair = getRefPair(serviceReference);
+        return getService(key, refPair);
     }
 
-    private T getService( ComponentContextImpl<S> key, RefPair<S, T> refPair )
+    private T getService(ComponentContextImpl<S> key, RefPair<S, T> refPair)
     {
         if (refPair == null)
         {
@@ -1375,7 +1442,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             return null;
         }
         T serviceObject;
-        if ( (serviceObject = refPair.getServiceObject(key)) != null )
+        if ((serviceObject = refPair.getServiceObject(key)) != null)
         {
             return serviceObject;
         }
@@ -1383,28 +1450,29 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         final BundleContext bundleContext = m_componentManager.getBundleContext();
         if (bundleContext == null)
         {
-            m_componentManager.log( LogService.LOG_ERROR, "Bundle shut down while getting service {0} ({1}/{2,number,#})", new Object[]
-                    { getName(), m_dependencyMetadata.getInterface(),
-                        refPair.getRef().getProperty( Constants.SERVICE_ID ) }, null );
-                return null;
+            m_componentManager.log(LogService.LOG_ERROR,
+                "Bundle shut down while getting service {0} ({1}/{2,number,#})", new Object[] { getName(),
+                        m_dependencyMetadata.getInterface(), refPair.getRef().getProperty(Constants.SERVICE_ID) },
+                null);
+            return null;
         }
         try
         {
             refPair.getServiceObject(key, bundleContext, m_componentManager);
-            serviceObject = refPair.getServiceObject( key );
+            serviceObject = refPair.getServiceObject(key);
         }
-        catch ( Exception e )
+        catch (Exception e)
         {
             // caused by getService() called on invalid bundle context
             // or if there is a service reference cycle involving service
             // factories !
-            m_componentManager.log( LogService.LOG_ERROR, "Failed getting service {0} ({1}/{2,number,#})", new Object[]
-                { getName(), m_dependencyMetadata.getInterface(),
-                    refPair.getRef().getProperty( Constants.SERVICE_ID ) }, e );
+            m_componentManager.log(LogService.LOG_ERROR, "Failed getting service {0} ({1}/{2,number,#})",
+                new Object[] { getName(), m_dependencyMetadata.getInterface(),
+                        refPair.getRef().getProperty(Constants.SERVICE_ID) },
+                e);
             return null;
         }
 
-
         // return the acquired service (may be null of course)
         //even if we did not set the service object, all the getService are for the same bundle so will have the same object.
         return serviceObject;
@@ -1413,14 +1481,13 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
     //---------- DependencyManager core ---------------------------------------
 
     /* (non-Javadoc)
-	 * @see org.apache.felix.scr.impl.manager.ReferenceManager#getName()
-	 */
+     * @see org.apache.felix.scr.impl.manager.ReferenceManager#getName()
+     */
     public String getName()
     {
         return m_dependencyMetadata.getName();
     }
 
-
     /**
      * Returns <code>true</code> if this dependency manager is satisfied, that
      * is if either the dependency is optional or the number of services
@@ -1432,17 +1499,16 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return m_customizer.isSatisfied();
     }
 
-
     /**
      * Returns <code>true</code> if the component providing bundle has permission
      * to get the service described by this reference.
      */
     public boolean hasGetPermission()
     {
-        if ( System.getSecurityManager() != null )
+        if (System.getSecurityManager() != null)
         {
-            Permission perm = new ServicePermission( getServiceName(), ServicePermission.GET );
-            return m_componentManager.getBundle().hasPermission( perm );
+            Permission perm = new ServicePermission(getServiceName(), ServicePermission.GET);
+            return m_componentManager.getBundle().hasPermission(perm);
         }
 
         // no security manager, hence permission given
@@ -1462,38 +1528,36 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @return true if the dependency is satisfied and at least the minimum
      *      number of services could be bound. Otherwise false is returned.
      */
-    boolean open( ComponentContextImpl<S> componentContext, EdgeInfo edgeInfo )
+    boolean open(ComponentContextImpl<S> componentContext, EdgeInfo edgeInfo)
     {
-        if ( !invokeInitMethod(componentContext) )
+        if (!invokeInitMethod(componentContext))
         {
-            m_componentManager.log( LogService.LOG_DEBUG,
-                    "For dependency {0}, failed to initialize object",
-                    new Object[] {getName()}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "For dependency {0}, failed to initialize object",
+                new Object[] { getName() }, null);
             return false;
         }
 
         int serviceCount = 0;
-        AtomicInteger trackingCount =  new AtomicInteger( );
+        AtomicInteger trackingCount = new AtomicInteger();
         Collection<RefPair<S, T>> refs;
         CountDownLatch openLatch;
-        synchronized ( m_tracker.tracked() )
+        synchronized (m_tracker.tracked())
         {
-            refs = m_customizer.getRefs( trackingCount );
-            edgeInfo.setOpen( trackingCount.get() );
-            openLatch = edgeInfo.getOpenLatch( );
+            refs = m_customizer.getRefs(trackingCount);
+            edgeInfo.setOpen(trackingCount.get());
+            openLatch = edgeInfo.getOpenLatch();
         }
-        m_componentManager.log( LogService.LOG_DEBUG,
-            "For dependency {0}, optional: {1}; to bind: {2}",
-            new Object[]{ getName(), isOptional(), refs }, null );
-        for ( RefPair<S, T> refPair : refs )
+        m_componentManager.log(LogService.LOG_DEBUG, "For dependency {0}, optional: {1}; to bind: {2}",
+            new Object[] { getName(), isOptional(), refs }, null);
+        for (RefPair<S, T> refPair : refs)
         {
-            if ( !refPair.isDeleted() && !refPair.isFailed() )
+            if (!refPair.isDeleted() && !refPair.isFailed())
             {
-                if ( !doInvokeBindMethod( componentContext, refPair ) )
+                if (!doInvokeBindMethod(componentContext, refPair, trackingCount.get()))
                 {
-                    m_componentManager.log( LogService.LOG_DEBUG,
-                            "For dependency {0}, failed to invoke bind method on object {1}",
-                            new Object[] {getName(), refPair}, null );
+                    m_componentManager.log(LogService.LOG_DEBUG,
+                        "For dependency {0}, failed to invoke bind method on object {1}",
+                        new Object[] { getName(), refPair }, null);
 
                 }
                 serviceCount++;
@@ -1509,7 +1573,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param componentContext instance we are unbinding from.
      * @param edgeInfo EdgeInfo for the combination of this component instance and this dependency manager.
      */
-    void close( ComponentContextImpl<S> componentContext, EdgeInfo edgeInfo )
+    void close(ComponentContextImpl<S> componentContext, EdgeInfo edgeInfo)
     {
         // only invoke the unbind method if there is an instance (might be null
         // in the delayed component situation) and the unbind method is declared.
@@ -1518,76 +1582,77 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         AtomicInteger trackingCount = new AtomicInteger();
         Collection<RefPair<S, T>> refPairs;
         CountDownLatch latch;
-        synchronized ( m_tracker.tracked() )
+        synchronized (m_tracker.tracked())
         {
-            refPairs = m_customizer.getRefs( trackingCount );
-            edgeInfo.setClose( trackingCount.get() );
-            latch = edgeInfo.getCloseLatch( );
+            refPairs = m_customizer.getRefs(trackingCount);
+            edgeInfo.setClose(trackingCount.get());
+            latch = edgeInfo.getCloseLatch();
         }
 
-        m_componentManager.log( LogService.LOG_DEBUG,
-                "DependencyManager: {0} close component unbinding from {1} at tracking count {2} refpairs: {3}",
-                new Object[] {getName(), componentContext, trackingCount.get(), refPairs}, null );
-        m_componentManager.waitForTracked( trackingCount.get() );
-        for ( RefPair<S, T> boundRef : refPairs )
+        m_componentManager.log(LogService.LOG_DEBUG,
+            "DependencyManager: {0} close component unbinding from {1} at tracking count {2} refpairs: {3}",
+            new Object[] { getName(), componentContext, trackingCount.get(), refPairs }, null);
+        m_componentManager.waitForTracked(trackingCount.get());
+        for (RefPair<S, T> boundRef : refPairs)
         {
-            if ( doUnbind && !boundRef.isFailed() )
+            if (doUnbind && !boundRef.isFailed())
             {
-                invokeUnbindMethod( componentContext, boundRef, trackingCount.get(), edgeInfo );
+                invokeUnbindMethod(componentContext, boundRef, trackingCount.get(), edgeInfo);
             }
 
         }
         latch.countDown();
     }
 
-    public void invokeBindMethodLate( final ServiceReference<T> ref, int trackingCount )
+    public void invokeBindMethodLate(final ServiceReference<T> ref, int trackingCount)
     {
-        if ( !isSatisfied() )
+        if (!isSatisfied())
         {
             return;
         }
-        if ( !isMultiple() )
+        if (!isMultiple())
         {
-            Collection<RefPair<S, T>> refs = m_customizer.getRefs( new AtomicInteger( ) );
+            Collection<RefPair<S, T>> refs = m_customizer.getRefs(new AtomicInteger());
             if (refs.isEmpty())
             {
                 return;
             }
             RefPair<S, T> test = refs.iterator().next();
-            if ( ref != test.getRef())
+            if (ref != test.getRef())
             {
                 //another ref is now better
                 return;
             }
         }
         //TODO dynamic reluctant
-        RefPair<S, T> refPair = m_tracker.getService( ref );
-        if (refPair == null) {
+        RefPair<S, T> refPair = m_tracker.getService(ref);
+        if (refPair == null)
+        {
             return; // The service is no longer available, probably because the tracker has been closed
         }
         //TODO this check is no longer correct, fix it!
-//        if (refPair.getServiceObject(key) != null)
-//        {
-//            m_componentManager.log( LogService.LOG_DEBUG,
-//                    "DependencyManager : late binding of service reference {1} skipped as service has already been located",
-//                    new Object[] {ref}, null );
-//            //something else got the reference and may be binding it.
-//            return;
-//        }
-        m_componentManager.invokeBindMethod( this, refPair, trackingCount );
+        //        if (refPair.getServiceObject(key) != null)
+        //        {
+        //            m_componentManager.log( LogService.LOG_DEBUG,
+        //                    "DependencyManager : late binding of service reference {1} skipped as service has already been located",
+        //                    new Object[] {ref}, null );
+        //            //something else got the reference and may be binding it.
+        //            return;
+        //        }
+        m_componentManager.invokeBindMethod(this, refPair, trackingCount);
     }
 
     /**
      * Calls the optional init reference method.
      */
-    boolean invokeInitMethod( final ComponentContextImpl<S> componentContext )
+    boolean invokeInitMethod(final ComponentContextImpl<S> componentContext)
     {
         // The bind method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
-        if ( m_bindMethods.getInit() != null )
+        if (m_bindMethods.getInit() != null)
         {
-            final Object componentInstance = componentContext.getImplementationObject( false );
-            if ( componentInstance != null )
+            final Object componentInstance = componentContext.getImplementationObject(false);
+            if (componentInstance != null)
             {
                 return m_bindMethods.getInit().init(componentInstance, m_componentManager);
             }
@@ -1615,54 +1680,55 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      *      be handed over to the bind method but the service cannot be
      *      retrieved using the service reference.
      */
-    boolean invokeBindMethod( ComponentContextImpl<S> componentContext, RefPair<S, T> refPair, int trackingCount, EdgeInfo info )
+    boolean invokeBindMethod(ComponentContextImpl<S> componentContext, RefPair<S, T> refPair, int trackingCount,
+        EdgeInfo info)
     {
         // The bind method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
-        if ( componentContext.getImplementationObject( false ) != null )
+        if (componentContext.getImplementationObject(false) != null)
         {
-            synchronized ( m_tracker.tracked() )
+            synchronized (m_tracker.tracked())
             {
-                if (info.outOfRange( trackingCount ) )
+                if (info.outOfRange(trackingCount))
                 {
                     //ignore events before open started or we will have duplicate binds.
                     return true;
                 }
             }
             //edgeInfo open has been set, so binding has started.
-            return doInvokeBindMethod( componentContext, refPair );
+            return doInvokeBindMethod(componentContext, refPair, trackingCount);
 
         }
         else
         {
-            m_componentManager.log( LogService.LOG_DEBUG,
-                    "DependencyManager : component not yet created, assuming bind method call succeeded",
-                    null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "DependencyManager : component not yet created, assuming bind method call succeeded", null);
 
             return true;
         }
     }
 
-    private boolean doInvokeBindMethod(ComponentContextImpl<S> componentContext, RefPair<S, T> refPair)
+    private boolean doInvokeBindMethod(ComponentContextImpl<S> componentContext, RefPair<S, T> refPair,
+        int trackingCount)
     {
-        if ( !getServiceObject( componentContext, m_bindMethods.getBind(), refPair ))
+        if (!getServiceObject(componentContext, m_bindMethods.getBind(), refPair))
         {
-            m_componentManager.log( LogService.LOG_WARNING,
-                    "DependencyManager : invokeBindMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
-                    new Object[] {refPair.getRef(), getName()}, null );
+            m_componentManager.log(LogService.LOG_WARNING,
+                "DependencyManager : invokeBindMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
+                new Object[] { refPair.getRef(), getName() }, null);
             return false;
 
         }
-        MethodResult result = m_bindMethods.getBind().invoke( componentContext.getImplementationObject( false ), componentContext, refPair, MethodResult.VOID, m_componentManager );
-        if ( result == null )
+        MethodResult result = m_bindMethods.getBind().invoke(componentContext.getImplementationObject(false),
+            componentContext, refPair, MethodResult.VOID, m_componentManager);
+        if (result == null)
         {
             return false;
         }
-        m_componentManager.setServiceProperties( result );
+        m_componentManager.setServiceProperties(result, trackingCount);
         return true;
     }
 
-
     /**
      * Calls the updated method.
      *
@@ -1671,37 +1737,40 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param edgeInfo EdgeInfo for the combination of this instance and this dependency manager.
      * @return {@code true} if reactivation is required.
      */
-    boolean invokeUpdatedMethod( ComponentContextImpl<S> componentContext, final RefPair<S, T> refPair, int trackingCount, EdgeInfo info )
+    boolean invokeUpdatedMethod(ComponentContextImpl<S> componentContext, final RefPair<S, T> refPair,
+        int trackingCount, EdgeInfo info)
     {
-        if ( m_dependencyMetadata.getUpdated() == null && m_dependencyMetadata.getField() == null )
+        if (m_dependencyMetadata.getUpdated() == null && m_dependencyMetadata.getField() == null)
         {
             return false;
         }
         // The updated method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
-        if ( componentContext != null )
+        if (componentContext != null)
         {
-            synchronized ( m_tracker.tracked() )
+            synchronized (m_tracker.tracked())
             {
-                if (info.outOfRange( trackingCount ) )
+                if (info.outOfRange(trackingCount))
                 {
                     //ignore events after close started or we will have duplicate unbinds.
                     return false;
                 }
             }
-            info.waitForOpen( m_componentManager, getName(), "invokeUpdatedMethod" );
-            if ( !getServiceObject( componentContext, m_bindMethods.getUpdated(), refPair ))
+            info.waitForOpen(m_componentManager, getName(), "invokeUpdatedMethod");
+            if (!getServiceObject(componentContext, m_bindMethods.getUpdated(), refPair))
             {
-                m_componentManager.log( LogService.LOG_WARNING,
-                        "DependencyManager : invokeUpdatedMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
-                        new Object[] {refPair.getRef(), getName()}, null );
+                m_componentManager.log(LogService.LOG_WARNING,
+                    "DependencyManager : invokeUpdatedMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
+                    new Object[] { refPair.getRef(), getName() }, null);
                 return false;
 
             }
-            final MethodResult methodResult = m_bindMethods.getUpdated().invoke( componentContext.getImplementationObject( false ), componentContext, refPair, MethodResult.VOID, m_componentManager );
-            if ( methodResult != null)
+            final MethodResult methodResult = m_bindMethods.getUpdated().invoke(
+                componentContext.getImplementationObject(false), componentContext, refPair, MethodResult.VOID,
+                m_componentManager);
+            if (methodResult != null)
             {
-                m_componentManager.setServiceProperties( methodResult );
+                m_componentManager.setServiceProperties(methodResult, trackingCount);
             }
             return methodResult == MethodResult.REACTIVATE;
         }
@@ -1710,13 +1779,12 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             // don't care whether we can or cannot call the updated method
             // if the component instance has already been cleared by the
             // close() method
-            m_componentManager.log( LogService.LOG_DEBUG,
-                    "DependencyManager : Component not set, no need to call updated method", null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "DependencyManager : Component not set, no need to call updated method", null);
         }
         return false;
     }
 
-
     /**
      * Calls the unbind method.
      * <p>
@@ -1729,46 +1797,49 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param trackingCount service event count for this reference
      * @param info EdgeInfo for the combination of this instance and this dependency manager
      */
-    void invokeUnbindMethod( ComponentContextImpl<S> componentContext, final RefPair<S, T> refPair, int trackingCount, EdgeInfo info )
+    void invokeUnbindMethod(ComponentContextImpl<S> componentContext, final RefPair<S, T> refPair, int trackingCount,
+        EdgeInfo info)
     {
         // The unbind method is only invoked if the implementation object is not
         // null. This is valid for both immediate and delayed components
-        if ( componentContext != null )
+        if (componentContext != null)
         {
-            synchronized ( m_tracker.tracked() )
+            synchronized (m_tracker.tracked())
             {
-                if (info.beforeRange( trackingCount ))
+                if (info.beforeRange(trackingCount))
                 {
                     //never bound
                     return;
                 }
             }
-            info.waitForOpen( m_componentManager, getName(), "invokeUnbindMethod" );
+            info.waitForOpen(m_componentManager, getName(), "invokeUnbindMethod");
             boolean outOfRange;
-            synchronized ( m_tracker.tracked() )
+            synchronized (m_tracker.tracked())
             {
-                outOfRange = info.afterRange( trackingCount );
+                outOfRange = info.afterRange(trackingCount);
             }
-            if ( outOfRange )
+            if (outOfRange)
             {
                 //wait for unbinds to complete
-                info.waitForClose( m_componentManager, getName(), "invokeUnbindMethod" );
+                info.waitForClose(m_componentManager, getName(), "invokeUnbindMethod");
                 //ignore events after close started or we will have duplicate unbinds.
                 return;
             }
 
-            if ( !getServiceObject( componentContext, m_bindMethods.getUnbind(), refPair ))
+            if (!getServiceObject(componentContext, m_bindMethods.getUnbind(), refPair))
             {
-                m_componentManager.log( LogService.LOG_WARNING,
-                        "DependencyManager : invokeUnbindMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
-                        new Object[] {refPair.getRef(), getName()}, null );
+                m_componentManager.log(LogService.LOG_WARNING,
+                    "DependencyManager : invokeUnbindMethod : Service not available from service registry for ServiceReference {0} for reference {1}",
+                    new Object[] { refPair.getRef(), getName() }, null);
                 return;
 
             }
-            MethodResult methodResult = m_bindMethods.getUnbind().invoke( componentContext.getImplementationObject( false ), componentContext, refPair, MethodResult.VOID, m_componentManager );
-            if ( methodResult != null )
+            MethodResult methodResult = m_bindMethods.getUnbind().invoke(
+                componentContext.getImplementationObject(false), componentContext, refPair, MethodResult.VOID,
+                m_componentManager);
+            if (methodResult != null)
             {
-                m_componentManager.setServiceProperties( methodResult );
+                m_componentManager.setServiceProperties(methodResult, trackingCount);
             }
             componentContext.getComponentServiceObjectsHelper().closeServiceObjects(refPair.getRef());
         }
@@ -1777,8 +1848,8 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             // don't care whether we can or cannot call the unbind method
             // if the component instance has already been cleared by the
             // close() method
-            m_componentManager.log( LogService.LOG_DEBUG,
-                "DependencyManager : Component not set, no need to call unbind method", null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "DependencyManager : Component not set, no need to call unbind method", null);
         }
     }
 
@@ -1804,15 +1875,14 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * apply.</li>
      * </ol>
      */
-    boolean canUpdateDynamically( Map<String, Object> properties )
+    boolean canUpdateDynamically(Map<String, Object> properties)
     {
         // 1. no target filter change
-        final String newTarget = ( String ) properties.get( m_dependencyMetadata.getTargetPropertyName() );
+        final String newTarget = (String) properties.get(m_dependencyMetadata.getTargetPropertyName());
         final String currentTarget = getTarget();
-        int newMinimumCardinality = getMinimumCardinality( properties );
-        if ( m_minCardinality == newMinimumCardinality &&
-                ( ( currentTarget == null && newTarget == null )
-            || ( currentTarget != null && currentTarget.equals( newTarget ) ) ) )
+        int newMinimumCardinality = getMinimumCardinality(properties);
+        if (m_minCardinality == newMinimumCardinality && ((currentTarget == null && newTarget == null)
+            || (currentTarget != null && currentTarget.equals(newTarget))))
         {
             // can update if target filter is not changed, since there is
             // no change is service binding
@@ -1822,7 +1892,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         // 2. if static policy, cannot update dynamically
         // (for simplicity assuming change in target service binding)
-        if ( m_dependencyMetadata.isStatic() )
+        if (m_dependencyMetadata.isStatic())
         {
             // cannot update if services are statically bound and the target
             // filter is modified, since there is (potentially at least)
@@ -1832,7 +1902,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         // invariant: target filter change + dynamic policy
 
         // 3. check optionality
-        if ( newMinimumCardinality == 0 )
+        if (newMinimumCardinality == 0)
         {
             // can update since even if no service matches the new filter, this
             // makes no difference because the dependency is optional
@@ -1841,8 +1911,8 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         // invariant: target filter change + mandatory + dynamic policy
 
         // 4. check target services matching the new filter
-        ServiceReference<T>[] refs = getFrameworkServiceReferences( newTarget );
-        if ( refs != null )
+        ServiceReference<T>[] refs = getFrameworkServiceReferences(newTarget);
+        if (refs != null)
         {
             // Return whether there are enough target services
             return newMinimumCardinality <= refs.length;
@@ -1853,7 +1923,6 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return false;
     }
 
-
     /**
      * Sets the target filter from target filter property contained in the
      * properties. The filter is taken from a property whose name is derived
@@ -1864,11 +1933,10 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param properties The properties containing the optional target service
      *      filter property
      */
-    void setTargetFilter( Map<String, Object> properties )
+    void setTargetFilter(Map<String, Object> properties)
     {
-        Integer minimumCardinality = getMinimumCardinality( properties );
-        setTargetFilter( ( String ) properties.get( m_dependencyMetadata.getTargetPropertyName() ),
-                minimumCardinality);
+        Integer minimumCardinality = getMinimumCardinality(properties);
+        setTargetFilter((String) properties.get(m_dependencyMetadata.getTargetPropertyName()), minimumCardinality);
     }
 
     private int getMinimumCardinality(Map<String, Object> properties)
@@ -1876,28 +1944,30 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         Integer minimumCardinality = null;
         try
         {
-            minimumCardinality = Coercions.coerceToInteger( properties.get( m_dependencyMetadata.getMinCardinalityName()));
+            minimumCardinality = Coercions.coerceToInteger(
+                properties.get(m_dependencyMetadata.getMinCardinalityName()));
         }
         catch (ComponentException e)
         {
-            m_componentManager.log( LogService.LOG_WARNING, "Invalid minimum cardinality property for dependency {0}: {1}", new Object[]
-                    {getName(), e.getMessage()}, null );
+            m_componentManager.log(LogService.LOG_WARNING,
+                "Invalid minimum cardinality property for dependency {0}: {1}",
+                new Object[] { getName(), e.getMessage() }, null);
         }
-        if (minimumCardinality != null &&
-                (minimumCardinality < defaultMinimumCardinality( m_dependencyMetadata ) ||
-                        (!m_dependencyMetadata.isMultiple() && minimumCardinality > 1 )))
+        if (minimumCardinality != null && (minimumCardinality < defaultMinimumCardinality(m_dependencyMetadata)
+            || (!m_dependencyMetadata.isMultiple() && minimumCardinality > 1)))
         {
             minimumCardinality = null;
         }
-        if ( minimumCardinality == null)
+        if (minimumCardinality == null)
         {
-            minimumCardinality = defaultMinimumCardinality( m_dependencyMetadata );
+            minimumCardinality = defaultMinimumCardinality(m_dependencyMetadata);
         }
         return minimumCardinality;
     }
 
     private static final String OBJECTCLASS_CLAUSE = "(" + Constants.OBJECTCLASS + "=";
-    private static final String PROTOTYPE_SCOPE_CLAUSE = "(" + Constants.SERVICE_SCOPE + "=" + Constants.SCOPE_PROTOTYPE + ")";
+    private static final String PROTOTYPE_SCOPE_CLAUSE = "(" + Constants.SERVICE_SCOPE + "=" + Constants.SCOPE_PROTOTYPE
+        + ")";
 
     /**
      * Sets the target filter of this dependency to the new filter value. If the
@@ -1909,7 +1979,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
      * @param target The new target filter to be set. This may be
      *      <code>null</code> if no target filtering is to be used.
      */
-    private void setTargetFilter( String target, int minimumCardinality )
+    private void setTargetFilter(String target, int minimumCardinality)
     {
         // if configuration does not set filter, use the value from metadata
         if (target == null)
@@ -1917,10 +1987,11 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             target = m_dependencyMetadata.getTarget();
         }
         // do nothing if target filter does not change
-        if ( ( m_target == null && target == null ) || ( m_target != null && m_target.equals( target ) ) )
+        if ((m_target == null && target == null) || (m_target != null && m_target.equals(target)))
         {
-            m_componentManager.log( LogService.LOG_DEBUG, "No change in target property for dependency {0}: currently registered: {1}", new Object[]
-                    {getName(), m_tracker != null}, null );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                "No change in target property for dependency {0}: currently registered: {1}",
+                new Object[] { getName(), m_tracker != null }, null);
             if (m_tracker != null)
             {
                 m_minCardinality = minimumCardinality;
@@ -1928,10 +1999,12 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
             }
         }
         m_target = target;
-        final boolean multipleExpr = m_target != null || m_dependencyMetadata.getScope() == ReferenceScope.prototype_required;
-        final boolean allExpr = m_target != null && m_dependencyMetadata.getScope() == ReferenceScope.prototype_required;
+        final boolean multipleExpr = m_target != null
+            || m_dependencyMetadata.getScope() == ReferenceScope.prototype_required;
+        final boolean allExpr = m_target != null
+            && m_dependencyMetadata.getScope() == ReferenceScope.prototype_required;
         final StringBuilder initialReferenceFilterSB = new StringBuilder();
-        if (multipleExpr )
+        if (multipleExpr)
         {
             initialReferenceFilterSB.append("(&");
         }
@@ -1941,47 +2014,47 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
         // if reference scope is prototype_required, we simply add
         // (service.scope=prototype) to the filter
-        if ( m_dependencyMetadata.getScope() == ReferenceScope.prototype_required )
+        if (m_dependencyMetadata.getScope() == ReferenceScope.prototype_required)
         {
             initialReferenceFilterSB.append(PROTOTYPE_SCOPE_CLAUSE);
         }
 
         // append target
-        if ( m_target != null )
+        if (m_target != null)
         {
             initialReferenceFilterSB.append(m_target);
         }
-        if (multipleExpr )
+        if (multipleExpr)
         {
             initialReferenceFilterSB.append(')');
         }
-        String initialReferenceFilterString= initialReferenceFilterSB.toString();
+        String initialReferenceFilterString = initialReferenceFilterSB.toString();
         String eventFilterString;
         if (allExpr)
         {
             StringBuilder sb = new StringBuilder("(&").append(PROTOTYPE_SCOPE_CLAUSE).append(m_target).append(")");
             eventFilterString = sb.toString();
         }
-        else 
+        else
         {
             eventFilterString = m_target;
         }
 
         final ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> oldTracker = m_tracker;
         AtomicInteger trackingCount = new AtomicInteger();
-        SortedMap<ServiceReference<T>, RefPair<S, T>> refMap = unregisterServiceListener( trackingCount );
-        if ( trackingCount.get() != -1 )
+        SortedMap<ServiceReference<T>, RefPair<S, T>> refMap = unregisterServiceListener(trackingCount);
+        if (trackingCount.get() != -1)
         {
             //wait for service events to complete before processing initial set from new tracker.
-            m_componentManager.waitForTracked( trackingCount.get() );
+            m_componentManager.waitForTracked(trackingCount.get());
         }
-        m_componentManager.log( LogService.LOG_DEBUG, "Setting target property for dependency {0} to {1}", new Object[]
-                {getName(), target}, null );
+        m_componentManager.log(LogService.LOG_DEBUG, "Setting target property for dependency {0} to {1}",
+            new Object[] { getName(), target }, null);
         BundleContext bundleContext = m_componentManager.getBundleContext();
         Filter eventFilter = null;
-        if ( bundleContext != null )
+        if (bundleContext != null)
         {
-            if ( eventFilterString != null )
+            if (eventFilterString != null)
             {
                 try
                 {
@@ -2010,34 +2083,33 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         }
         else
         {
-            m_componentManager.log( LogService.LOG_ERROR, "Bundle is shut down for dependency {0} to {1}", new Object[]
-                    {getName(), target}, null );
+            m_componentManager.log(LogService.LOG_ERROR, "Bundle is shut down for dependency {0} to {1}",
+                new Object[] { getName(), target }, null);
             return;
         }
 
-        m_customizer.setPreviousRefMap( refMap );
+        m_customizer.setPreviousRefMap(refMap);
         boolean initialActive = oldTracker != null && oldTracker.isActive();
-        m_componentManager.log( LogService.LOG_DEBUG, "New service tracker for {0}, initial active: {1}, previous references: {2}, classFilter: {3}, eventFilter {4}, initialReferenceFilter {5}", new Object[]
-                {getName(), initialActive, refMap, classFilterString, eventFilter, initialReferenceFilterString}, null );
-        ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = new ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent>( bundleContext, 
-            m_customizer, 
-            initialActive, 
-            m_componentManager.getActivator(),
-            eventFilter,
-            classFilterString,
-            initialReferenceFilterString);
-        m_customizer.setTracker( tracker );
+        m_componentManager.log(LogService.LOG_DEBUG,
+            "New service tracker for {0}, initial active: {1}, previous references: {2}, classFilter: {3}, eventFilter {4}, initialReferenceFilter {5}",
+            new Object[] { getName(), initialActive, refMap, classFilterString, eventFilter,
+                    initialReferenceFilterString },
+            null);
+        ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = new ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent>(
+            bundleContext, m_customizer, initialActive, m_componentManager.getActivator(), eventFilter,
+            classFilterString, initialReferenceFilterString);
+        m_customizer.setTracker(tracker);
         //set minimum cardinality
         m_minCardinality = minimumCardinality;
 
-        tracker.open( m_componentManager.getTrackingCount() );
+        tracker.open(m_componentManager.getTrackingCount());
         m_customizer.setTrackerOpened();
-        if ( oldTracker != null )
+        if (oldTracker != null)
         {
-            oldTracker.completeClose( refMap );
+            oldTracker.completeClose(refMap);
         }
-        m_componentManager.log( LogService.LOG_DEBUG, "registering service listener for dependency {0}", new Object[]
-                {getName()}, null );
+        m_componentManager.log(LogService.LOG_DEBUG, "registering service listener for dependency {0}",
+            new Object[] { getName() }, null);
     }
 
     private Customizer<S, T> newCustomizer()
@@ -2046,18 +2118,18 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         if (!hasGetPermission())
         {
             customizer = new NoPermissionsCustomizer();
-            m_componentManager.log( LogService.LOG_INFO, "No permission to get services for {0}", new Object[]
-                    {getName()}, null );
+            m_componentManager.log(LogService.LOG_INFO, "No permission to get services for {0}",
+                new Object[] { getName() }, null);
         }
         else if (m_componentManager.isFactory())
         {
             customizer = new FactoryCustomizer();
         }
-        else if ( isMultiple() )
+        else if (isMultiple())
         {
-            if ( isStatic() )
+            if (isStatic())
             {
-                if ( isReluctant() )
+                if (isReluctant())
                 {
                     customizer = new MultipleStaticReluctantCustomizer();
                 }
@@ -2073,7 +2145,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         }
         else
         {
-            if ( isStatic() )
+            if (isStatic())
             {
                 customizer = new SingleStaticCustomizer();
             }
@@ -2085,38 +2157,36 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
         return customizer;
     }
 
-    SortedMap<ServiceReference<T>, RefPair<S, T>> unregisterServiceListener( AtomicInteger trackingCount )
+    SortedMap<ServiceReference<T>, RefPair<S, T>> unregisterServiceListener(AtomicInteger trackingCount)
     {
         SortedMap<ServiceReference<T>, RefPair<S, T>> refMap;
         ServiceTracker<T, RefPair<S, T>, ExtendedServiceEvent> tracker = m_tracker;
-        if ( tracker != null )
+        if (tracker != null)
         {
-            refMap = tracker.close( trackingCount );
+            refMap = tracker.close(trackingCount);
             m_tracker = null;
-            m_componentManager.log( LogService.LOG_DEBUG, "unregistering service listener for dependency {0}", new Object[]
-                    {getName()}, null );
+            m_componentManager.log(LogService.LOG_DEBUG, "unregistering service listener for dependency {0}",
+                new Object[] { getName() }, null);
         }
         else
         {
             refMap = new TreeMap<ServiceReference<T>, RefPair<S, T>>(Collections.reverseOrder());
-            m_componentManager.log( LogService.LOG_DEBUG, " No existing service listener to unregister for dependency {0}", new Object[]
-                    {getName()}, null );
-            trackingCount.set( -1 );
+            m_componentManager.log(LogService.LOG_DEBUG,
+                " No existing service listener to unregister for dependency {0}", new Object[] { getName() }, null);
+            trackingCount.set(-1);
         }
-//        m_registered = false;
+        //        m_registered = false;
         return refMap;
     }
 
-
     /* (non-Javadoc)
-	 * @see org.apache.felix.scr.impl.manager.ReferenceManager#getTarget()
-	 */
+     * @see org.apache.felix.scr.impl.manager.ReferenceManager#getTarget()
+     */
     public String getTarget()
     {
         return m_target;
     }
 
-
     @Override
     public String toString()
     {
@@ -2126,9 +2196,9 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
     boolean getServiceObject(ComponentContextImpl<S> key, ReferenceMethod bindMethod, RefPair<S, T> refPair)
     {
         BundleContext bundleContext = m_componentManager.getBundleContext();
-        if ( bundleContext != null )
+        if (bundleContext != null)
         {
-            return bindMethod.getServiceObject( key, refPair, bundleContext, m_componentManager );
+            return bindMethod.getServiceObject(key, refPair, bundleContext, m_componentManager);
         }
         else
         {
@@ -2139,11 +2209,11 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
     RefPair<S, T> newRefPair(ServiceReference<T> serviceReference)
     {
-        if ( m_dependencyMetadata.getScope() == ReferenceScope.bundle )
+        if (m_dependencyMetadata.getScope() == ReferenceScope.bundle)
         {
-            return new SingleRefPair<S, T>( serviceReference  );
+            return new SingleRefPair<S, T>(serviceReference);
         }
-        if ( m_componentManager.getComponentMetadata().getServiceScope() == Scope.singleton )
+        if (m_componentManager.getComponentMetadata().getServiceScope() == Scope.singleton)
         {
             return new SinglePrototypeRefPair<S, T>(m_componentManager.getBundleContext(), serviceReference);
         }
@@ -2152,7 +2222,7 @@ public class DependencyManager<S, T> implements ReferenceManager<S, T>
 
     private void deactivateComponentManager()
     {
-        m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false );
+        m_componentManager.deactivateInternal(ComponentConstants.DEACTIVATION_REASON_REFERENCE, false, false);
     }
 
 }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
index 144f814bbe..561036a47e 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
@@ -321,7 +321,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                 activator.leaveCreate(getServiceReference());
             }
             //this may cause a getService as properties now match a filter.
-            setServiceProperties( result );
+            setServiceProperties( result, null );
         }
 
         return implementationObject;
@@ -344,7 +344,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                     componentContext, reason, null, this );
             if ( result != null )
             {
-                setServiceProperties( result );
+                setServiceProperties( result, null );
             }
             // 2. Unbind any bound services
             for ( DependencyManager<S, ?> md: getReversedDependencyManagers() )
@@ -748,7 +748,7 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
             // 6. update service registration properties if we didn't just do it
             if ( result.hasResult() )
             {
-                setServiceProperties( result );
+                setServiceProperties( result, null );
             }
             else
             {
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/ComponentTestBase.java b/scr/src/test/java/org/apache/felix/scr/integration/ComponentTestBase.java
index 2f44318773..627c552859 100644
--- a/scr/src/test/java/org/apache/felix/scr/integration/ComponentTestBase.java
+++ b/scr/src/test/java/org/apache/felix/scr/integration/ComponentTestBase.java
@@ -18,7 +18,6 @@
  */
 package org.apache.felix.scr.integration;
 
-
 import static org.ops4j.pax.exam.CoreOptions.frameworkProperty;
 import static org.ops4j.pax.exam.CoreOptions.junitBundles;
 import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
@@ -43,7 +42,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
@@ -52,14 +50,10 @@ import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
 import javax.inject.Inject;
 
-import junit.framework.Assert;
-import junit.framework.TestCase;
-
 import org.apache.felix.scr.impl.ScrCommand;
 import org.apache.felix.scr.integration.components.SimpleComponent;
 import org.junit.After;
@@ -89,6 +83,8 @@ import org.osgi.service.component.runtime.dto.ComponentDescriptionDTO;
 import org.osgi.service.log.LogService;
 import org.osgi.util.tracker.ServiceTracker;
 
+import junit.framework.Assert;
+import junit.framework.TestCase;
 
 public abstract class ComponentTestBase
 {
@@ -128,11 +124,10 @@ public abstract class ComponentTestBase
     protected static String descriptorFile = "/integration_test_simple_components.xml";
     protected static String COMPONENT_PACKAGE = "org.apache.felix.scr.integration.components";
 
-
     protected static boolean NONSTANDARD_COMPONENT_FACTORY_BEHAVIOR = false;
     protected volatile Log log;
 
-	protected static String[] ignoredWarnings; //null unless you need it.
+    protected static String[] ignoredWarnings; //null unless you need it.
 
     //set to true to only get last 1000 lines of log.
     protected static boolean restrictedLogging;
@@ -141,7 +136,6 @@ public abstract class ComponentTestBase
 
     protected static final String PROP_NAME_FACTORY = ComponentTestBase.PROP_NAME + ".factory";
 
-
     static
     {
         theConfig = new Hashtable<String, Object>();
@@ -149,19 +143,22 @@ public abstract class ComponentTestBase
     }
 
     @ProbeBuilder
-    public TestProbeBuilder extendProbe(TestProbeBuilder builder) {
-        builder.setHeader("Export-Package", "org.apache.felix.scr.integration.components," +
-            "org.apache.felix.scr.integration.components.activatesignature," +
-            "org.apache.felix.scr.integration.components.annoconfig," +
-                                            "org.apache.felix.scr.integration.components.circular," +
-                                            "org.apache.felix.scr.integration.components.circularFactory," +
-                                            "org.apache.felix.scr.integration.components.concurrency," +
-                                            "org.apache.felix.scr.integration.components.deadlock," +
-                                            "org.apache.felix.scr.integration.components.felix3680," +
-                                            "org.apache.felix.scr.integration.components.felix4984," +
-                                            "org.apache.felix.scr.integration.components.felix3680_2");
-        builder.setHeader("Import-Package", "org.apache.felix.scr.component");
-        builder.setHeader("Bundle-ManifestVersion", "2");
+    public TestProbeBuilder extendProbe(TestProbeBuilder builder)
+    {
+        builder.setHeader( "Export-Package",
+            "org.apache.felix.scr.integration.components,"
+                + "org.apache.felix.scr.integration.components.activatesignature,"
+                + "org.apache.felix.scr.integration.components.annoconfig,"
+                + "org.apache.felix.scr.integration.components.circular,"
+                + "org.apache.felix.scr.integration.components.circularFactory,"
+                + "org.apache.felix.scr.integration.components.concurrency,"
+                + "org.apache.felix.scr.integration.components.deadlock,"
+                + "org.apache.felix.scr.integration.components.felix3680,"
+                + "org.apache.felix.scr.integration.components.felix4984,"
+                + "org.apache.felix.scr.integration.components.felix3680_2,"
+                + "org.apache.felix.scr.integration.components.felix5276" );
+        builder.setHeader( "Import-Package", "org.apache.felix.scr.component" );
+        builder.setHeader( "Bundle-ManifestVersion", "2" );
         return builder;
     }
 
@@ -177,41 +174,38 @@ public abstract class ComponentTestBase
         }
 
         final Option[] base = options(
-            provision(
-                CoreOptions.bundle( bundleFile.toURI().toString() ),
+            provision( CoreOptions.bundle( bundleFile.toURI().toString() ),
                 mavenBundle( "org.ops4j.pax.tinybundles", "tinybundles", "1.0.0" ),
-                mavenBundle( "org.apache.felix", "org.apache.felix.configadmin", felixCaVersion )
-             ),
-             junitBundles(),
-             frameworkProperty( "org.osgi.framework.bsnversion" ).value( bsnVersionUniqueness ),
-             systemProperty( "ds.factory.enabled" ).value( Boolean.toString( NONSTANDARD_COMPONENT_FACTORY_BEHAVIOR ) ),
-             systemProperty( "ds.loglevel" ).value( DS_LOGLEVEL )
+                mavenBundle( "org.apache.felix", "org.apache.felix.configadmin", felixCaVersion ) ),
+            junitBundles(), frameworkProperty( "org.osgi.framework.bsnversion" ).value( bsnVersionUniqueness ),
+            systemProperty( "ds.factory.enabled" ).value( Boolean.toString( NONSTANDARD_COMPONENT_FACTORY_BEHAVIOR ) ),
+            systemProperty( "ds.loglevel" ).value( DS_LOGLEVEL )
 
         );
-        final Option vmOption = ( paxRunnerVmOption != null ) ? CoreOptions.vmOption( paxRunnerVmOption ) : null;
+        final Option vmOption = ( paxRunnerVmOption != null )? CoreOptions.vmOption( paxRunnerVmOption ): null;
         NONSTANDARD_COMPONENT_FACTORY_BEHAVIOR = false;
         return OptionUtils.combine( base, vmOption );
     }
 
-
     @Before
     public void setUp() throws BundleException
     {
-        log = new Log(restrictedLogging, ignoredWarnings);
+        log = new Log( restrictedLogging, ignoredWarnings );
         log.start();
         bundleContext.addFrameworkListener( log );
         bundleContext.registerService( LogService.class.getName(), log, null );
 
-        scrTracker = new ServiceTracker<ServiceComponentRuntime, ServiceComponentRuntime>( bundleContext, ServiceComponentRuntime.class, null );
+        scrTracker = new ServiceTracker<ServiceComponentRuntime, ServiceComponentRuntime>( bundleContext,
+            ServiceComponentRuntime.class, null );
         scrTracker.open();
-        configAdminTracker = new ServiceTracker<ConfigurationAdmin, ConfigurationAdmin>( bundleContext, ConfigurationAdmin.class, null );
+        configAdminTracker = new ServiceTracker<ConfigurationAdmin, ConfigurationAdmin>( bundleContext,
+            ConfigurationAdmin.class, null );
         configAdminTracker.open();
 
         bundle = installBundle( descriptorFile, COMPONENT_PACKAGE );
         bundle.start();
     }
 
-
     @After
     public void tearDown() throws BundleException
     {
@@ -234,245 +228,257 @@ public abstract class ComponentTestBase
         }
     }
 
-
     protected Collection<ComponentDescriptionDTO> getComponentDescriptions()
     {
         ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr == null )
         {
-        	TestCase.fail("no ServiceComponentRuntime");
+            TestCase.fail( "no ServiceComponentRuntime" );
         }
-            return scr.getComponentDescriptionDTOs();
+        return scr.getComponentDescriptionDTOs();
     }
 
-
-    protected ComponentDescriptionDTO findComponentDescriptorByName( String name )
+    protected ComponentDescriptionDTO findComponentDescriptorByName(String name)
     {
         ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr == null )
         {
-        	TestCase.fail("no ServiceComponentRuntime");
+            TestCase.fail( "no ServiceComponentRuntime" );
         }
-            return scr.getComponentDescriptionDTO(bundle, name);
+        return scr.getComponentDescriptionDTO( bundle, name );
     }
 
-
-    protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName( Bundle b, String name, int expected )
+    protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName(Bundle b, String name,
+        int expected)
     {
         ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr == null )
         {
-        	TestCase.fail("no ServiceComponentRuntime");
+            TestCase.fail( "no ServiceComponentRuntime" );
         }
-        ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO(b, name);
-        Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs(cd);
-        
-        if (expected != 0)
+        ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO( b, name );
+        Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs( cd );
+
+        if ( expected != 0 )
         {
             String sep = "[";
             StringBuffer sb = new StringBuffer();
-            for (Map.Entry<Integer, String> entry: STATES.entrySet()) 
+            for ( Map.Entry<Integer, String> entry : STATES.entrySet() )
             {
-                if ((expected & entry.getKey()) != 0)
+                if ( ( expected & entry.getKey() ) != 0 )
                 {
-                    sb.append(sep).append(entry.getValue());
+                    sb.append( sep ).append( entry.getValue() );
                     sep = ", ";
                 }
             }
-            sb.append("]");
-        	for (ComponentConfigurationDTO cc: ccs)
-        	{
-        		Assert.assertTrue( "for ComponentConfiguration name: " + cc.description.name + " properties" + cc.properties + "Expected one of state " + sb.toString() + " but was " + STATES.get(cc.state), 
-        		    (expected & cc.state) == cc.state);
-        	}
+            sb.append( "]" );
+            for ( ComponentConfigurationDTO cc : ccs )
+            {
+                Assert.assertTrue(
+                    "for ComponentConfiguration name: " + cc.description.name + " properties" + cc.properties
+                        + "Expected one of state " + sb.toString() + " but was " + STATES.get( cc.state ),
+                    ( expected & cc.state ) == cc.state );
+            }
         }
         return ccs;
     }
 
-    protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName( String name, int expected )
+    protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName(String name, int expected)
     {
-    	return findComponentConfigurationsByName(bundle, name, expected);
+        return findComponentConfigurationsByName( bundle, name, expected );
     }
 
-    protected ComponentConfigurationDTO findComponentConfigurationByName( Bundle b, String name, int expected )
+    protected ComponentConfigurationDTO findComponentConfigurationByName(Bundle b, String name, int expected)
     {
-    	Collection<ComponentConfigurationDTO> ccs = findComponentConfigurationsByName( b, name, expected);
-    	Assert.assertEquals(1, ccs.size());
-    	return ccs.iterator().next();
+        Collection<ComponentConfigurationDTO> ccs = findComponentConfigurationsByName( b, name, expected );
+        Assert.assertEquals( 1, ccs.size() );
+        return ccs.iterator().next();
     }
 
-    protected ComponentConfigurationDTO findComponentConfigurationByName( String name, int expected )
+    protected ComponentConfigurationDTO findComponentConfigurationByName(String name, int expected)
     {
-    	return findComponentConfigurationByName( bundle, name, expected );
+        return findComponentConfigurationByName( bundle, name, expected );
     }
 
     static final Map<Integer, String> STATES = new HashMap<Integer, String>();
 
-    static {
-    	STATES.put(ComponentConfigurationDTO.UNSATISFIED_REFERENCE, "Unsatisfied (" + ComponentConfigurationDTO.UNSATISFIED_REFERENCE + ")" );
-    	STATES.put(ComponentConfigurationDTO.SATISFIED, "Satisified (" + ComponentConfigurationDTO.SATISFIED + ")" );
-    	STATES.put(ComponentConfigurationDTO.ACTIVE, "Active (" + ComponentConfigurationDTO.ACTIVE + ")" );
+    static
+    {
+        STATES.put( ComponentConfigurationDTO.UNSATISFIED_REFERENCE,
+            "Unsatisfied (" + ComponentConfigurationDTO.UNSATISFIED_REFERENCE + ")" );
+        STATES.put( ComponentConfigurationDTO.SATISFIED, "Satisified (" + ComponentConfigurationDTO.SATISFIED + ")" );
+        STATES.put( ComponentConfigurationDTO.ACTIVE, "Active (" + ComponentConfigurationDTO.ACTIVE + ")" );
     }
 
-    protected ComponentConfigurationDTO getDisabledConfigurationAndEnable( Bundle b, String name, int initialState ) throws InvocationTargetException, InterruptedException
+    protected ComponentConfigurationDTO getDisabledConfigurationAndEnable(Bundle b, String name, int initialState)
+        throws InvocationTargetException, InterruptedException
     {
-    	int count = 1;
-        Collection<ComponentConfigurationDTO> ccs = getConfigurationsDisabledThenEnable(
-				b, name, count, initialState);
-		ComponentConfigurationDTO cc = ccs.iterator().next();
-    	return cc;
+        int count = 1;
+        Collection<ComponentConfigurationDTO> ccs = getConfigurationsDisabledThenEnable( b, name, count, initialState );
+        ComponentConfigurationDTO cc = ccs.iterator().next();
+        return cc;
     }
 
-    protected ComponentConfigurationDTO getDisabledConfigurationAndEnable( String name, int initialState ) throws InvocationTargetException, InterruptedException
+    protected ComponentConfigurationDTO getDisabledConfigurationAndEnable(String name, int initialState)
+        throws InvocationTargetException, InterruptedException
     {
-    	return getDisabledConfigurationAndEnable( bundle, name, initialState );
+        return getDisabledConfigurationAndEnable( bundle, name, initialState );
     }
 
-    protected Collection<ComponentConfigurationDTO> getConfigurationsDisabledThenEnable( Bundle b, String name, int count, int initialState) throws InvocationTargetException, InterruptedException
+    protected Collection<ComponentConfigurationDTO> getConfigurationsDisabledThenEnable(Bundle b, String name,
+        int count, int initialState) throws InvocationTargetException, InterruptedException
     {
-		ServiceComponentRuntime scr = scrTracker.getService();
+        ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr == null )
         {
-        	TestCase.fail("no ServiceComponentRuntime");
+            TestCase.fail( "no ServiceComponentRuntime" );
         }
-    	ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO(b, name);
-    	Assert.assertFalse("Expected component disabled", scr.isComponentEnabled(cd));
-    	scr.enableComponent(cd).getValue();
-    	Assert.assertTrue("Expected component enabled", scr.isComponentEnabled(cd));
-
-    	Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs(cd);
-    	Assert.assertEquals(count, ccs.size());
-    	for (ComponentConfigurationDTO cc: ccs) {
-			Assert.assertEquals("Expected state " + STATES.get(initialState)
-					+ " but was " + STATES.get(cc.state), initialState,
-					cc.state);
-		}
-		return ccs;
-	}
+        ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO( b, name );
+        Assert.assertFalse( "Expected component disabled", scr.isComponentEnabled( cd ) );
+        scr.enableComponent( cd ).getValue();
+        Assert.assertTrue( "Expected component enabled", scr.isComponentEnabled( cd ) );
+
+        Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs( cd );
+        Assert.assertEquals( count, ccs.size() );
+        for ( ComponentConfigurationDTO cc : ccs )
+        {
+            Assert.assertEquals( "Expected state " + STATES.get( initialState ) + " but was " + STATES.get( cc.state ),
+                initialState, cc.state );
+        }
+        return ccs;
+    }
 
-    protected Collection<ComponentConfigurationDTO> getConfigurationsDisabledThenEnable( String name, int count, int initialState) throws InvocationTargetException, InterruptedException
+    protected Collection<ComponentConfigurationDTO> getConfigurationsDisabledThenEnable(String name, int count,
+        int initialState) throws InvocationTargetException, InterruptedException
     {
-    	return getConfigurationsDisabledThenEnable(bundle, name, count, initialState);
+        return getConfigurationsDisabledThenEnable( bundle, name, count, initialState );
     }
 
-    protected ComponentDescriptionDTO checkConfigurationCount( Bundle b, String name, int count, int expectedState )
+    protected ComponentDescriptionDTO checkConfigurationCount(Bundle b, String name, int count, int expectedState)
     {
-    	ServiceComponentRuntime scr = scrTracker.getService();
-    	if ( scr == null )
-    	{
-    		TestCase.fail("no ServiceComponentRuntime");
-    	}
-    	ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO(b, name);
-    	Assert.assertTrue("Expected component enabled", scr.isComponentEnabled(cd));
-
-    	Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs(cd);
-    	Assert.assertEquals(count, ccs.size());
-    	if (expectedState != -1)
-    	{
-    		for (ComponentConfigurationDTO cc: ccs)
-    		{
-    			Assert.assertEquals("Expected state " + STATES.get(expectedState)
-    					+ " but was " + STATES.get(cc.state), expectedState,
-    					cc.state);
-    		}
-    	}
-    	return cd;
+        ServiceComponentRuntime scr = scrTracker.getService();
+        if ( scr == null )
+        {
+            TestCase.fail( "no ServiceComponentRuntime" );
+        }
+        ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO( b, name );
+        Assert.assertTrue( "Expected component enabled", scr.isComponentEnabled( cd ) );
+
+        Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs( cd );
+        Assert.assertEquals( count, ccs.size() );
+        if ( expectedState != -1 )
+        {
+            for ( ComponentConfigurationDTO cc : ccs )
+            {
+                Assert.assertEquals(
+                    "Expected state " + STATES.get( expectedState ) + " but was " + STATES.get( cc.state ),
+                    expectedState, cc.state );
+            }
+        }
+        return cd;
     }
 
-    protected ComponentDescriptionDTO checkConfigurationCount( String name, int count, int expectedState )
+    protected ComponentDescriptionDTO checkConfigurationCount(String name, int count, int expectedState)
     {
-    	return checkConfigurationCount(bundle, name, count, expectedState);
+        return checkConfigurationCount( bundle, name, count, expectedState );
     }
 
-    protected <S> S getServiceFromConfiguration( ComponentConfigurationDTO dto, Class<S> clazz )
+    protected <S> S getServiceFromConfiguration(ComponentConfigurationDTO dto, Class<S> clazz)
     {
         long id = dto.id;
         String filter = "(component.id=" + id + ")";
         Collection<ServiceReference<S>> srs;
-        try {
-            srs = bundleContext.getServiceReferences(clazz, filter);
-            Assert.assertEquals("Nothing for filter: " + filter, 1, srs.size());
+        try
+        {
+            srs = bundleContext.getServiceReferences( clazz, filter );
+            Assert.assertEquals( "Nothing for filter: " + filter, 1, srs.size() );
             ServiceReference<S> sr = srs.iterator().next();
-            S s = bundleContext.getService(sr);
-            Assert.assertNotNull(s);
+            S s = bundleContext.getService( sr );
+            Assert.assertNotNull( s );
             return s;
-        } catch (InvalidSyntaxException e) {
-            TestCase.fail(e.getMessage());
+        }
+        catch ( InvalidSyntaxException e )
+        {
+            TestCase.fail( e.getMessage() );
             return null;//unreachable in fact
         }
     }
 
-    protected <S> void ungetServiceFromConfiguration( ComponentConfigurationDTO dto, Class<S> clazz )
+    protected <S> void ungetServiceFromConfiguration(ComponentConfigurationDTO dto, Class<S> clazz)
     {
         long id = dto.id;
         String filter = "(component.id=" + id + ")";
         Collection<ServiceReference<S>> srs;
-        try {
-            srs = bundleContext.getServiceReferences(clazz, filter);
-            Assert.assertEquals(1, srs.size());
+        try
+        {
+            srs = bundleContext.getServiceReferences( clazz, filter );
+            Assert.assertEquals( 1, srs.size() );
             ServiceReference<S> sr = srs.iterator().next();
-            bundleContext.ungetService(sr);
-        } catch (InvalidSyntaxException e) {
-            TestCase.fail(e.getMessage());
+            bundleContext.ungetService( sr );
+        }
+        catch ( InvalidSyntaxException e )
+        {
+            TestCase.fail( e.getMessage() );
         }
     }
 
-    protected void enableAndCheck( ComponentDescriptionDTO cd ) throws InvocationTargetException, InterruptedException
+    protected void enableAndCheck(ComponentDescriptionDTO cd) throws InvocationTargetException, InterruptedException
     {
         ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr != null )
         {
-            scr.enableComponent(cd).getValue();
-        	Assert.assertTrue("Expected component enabled", scr.isComponentEnabled(cd));
+            scr.enableComponent( cd ).getValue();
+            Assert.assertTrue( "Expected component enabled", scr.isComponentEnabled( cd ) );
         }
         else
         {
-        	throw new NullPointerException("no ServiceComponentRuntime");
+            throw new NullPointerException( "no ServiceComponentRuntime" );
         }
 
     }
 
-    protected void disableAndCheck( ComponentConfigurationDTO cc ) throws InvocationTargetException, InterruptedException
+    protected void disableAndCheck(ComponentConfigurationDTO cc) throws InvocationTargetException, InterruptedException
     {
-    	ComponentDescriptionDTO cd = cc.description;
-        disableAndCheck(cd);
+        ComponentDescriptionDTO cd = cc.description;
+        disableAndCheck( cd );
     }
 
-	protected void disableAndCheck(ComponentDescriptionDTO cd) throws InvocationTargetException, InterruptedException {
-		ServiceComponentRuntime scr = scrTracker.getService();
+    protected void disableAndCheck(ComponentDescriptionDTO cd) throws InvocationTargetException, InterruptedException
+    {
+        ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr != null )
         {
-        	scr.disableComponent(cd).getValue();
-        	Assert.assertFalse("Expected component disabled", scr.isComponentEnabled(cd));
+            scr.disableComponent( cd ).getValue();
+            Assert.assertFalse( "Expected component disabled", scr.isComponentEnabled( cd ) );
         }
         else
         {
-        	throw new NullPointerException("no ServiceComponentRuntime");
+            throw new NullPointerException( "no ServiceComponentRuntime" );
         }
-	}
+    }
 
-	protected void disableAndCheck(String name) throws InvocationTargetException, InterruptedException {
-		ComponentDescriptionDTO cd = findComponentDescriptorByName(name);
-		disableAndCheck(cd);
-	}
+    protected void disableAndCheck(String name) throws InvocationTargetException, InterruptedException
+    {
+        ComponentDescriptionDTO cd = findComponentDescriptorByName( name );
+        disableAndCheck( cd );
+    }
 
     protected static void delay()
     {
-        delay(300);
+        delay( 300 );
     }
 
     protected static void delay(int millis)
     {
         try
         {
-            Thread.sleep(millis);
+            Thread.sleep( millis );
         }
-        catch (InterruptedException ie)
+        catch ( InterruptedException ie )
         {
         }
     }
 
-
     protected ConfigurationAdmin getConfigurationAdmin()
     {
         ConfigurationAdmin ca = configAdminTracker.getService();
@@ -483,25 +489,25 @@ public abstract class ComponentTestBase
         return ca;
     }
 
-    protected org.osgi.service.cm.Configuration configure( String pid )
+    protected org.osgi.service.cm.Configuration configure(String pid)
     {
         return configure( pid, null );
 
     }
 
-    protected org.osgi.service.cm.Configuration configure( String pid, String bundleLocation )
+    protected org.osgi.service.cm.Configuration configure(String pid, String bundleLocation)
     {
-        return configure(pid, bundleLocation, theConfig);
+        return configure( pid, bundleLocation, theConfig );
     }
 
-    protected org.osgi.service.cm.Configuration configure(String pid,
-        String bundleLocation, Dictionary<String, Object> props)
+    protected org.osgi.service.cm.Configuration configure(String pid, String bundleLocation,
+        Dictionary<String, Object> props)
     {
         ConfigurationAdmin ca = getConfigurationAdmin();
         try
         {
             org.osgi.service.cm.Configuration config = ca.getConfiguration( pid, null );
-            if (bundleLocation != null)
+            if ( bundleLocation != null )
             {
                 config.setBundleLocation( bundleLocation );
             }
@@ -515,8 +521,7 @@ public abstract class ComponentTestBase
         return null;
     }
 
-
-    protected void deleteConfig( String pid )
+    protected void deleteConfig(String pid)
     {
         ConfigurationAdmin ca = getConfigurationAdmin();
         try
@@ -530,8 +535,7 @@ public abstract class ComponentTestBase
         }
     }
 
-
-    protected String createFactoryConfiguration( String factoryPid )
+    protected String createFactoryConfiguration(String factoryPid)
     {
         ConfigurationAdmin ca = getConfigurationAdmin();
         try
@@ -547,8 +551,7 @@ public abstract class ComponentTestBase
         }
     }
 
-
-    protected void deleteFactoryConfigurations( String factoryPid )
+    protected void deleteFactoryConfigurations(String factoryPid)
     {
         ConfigurationAdmin ca = getConfigurationAdmin();
         try
@@ -574,28 +577,26 @@ public abstract class ComponentTestBase
     }
 
     //component factory test helper methods
-    protected ComponentFactory getComponentFactory(final String componentfactory)
-        throws InvalidSyntaxException
+    protected ComponentFactory getComponentFactory(final String componentfactory) throws InvalidSyntaxException
     {
-        final ServiceReference[] refs = bundleContext.getServiceReferences( ComponentFactory.class.getName(), "("
-            + ComponentConstants.COMPONENT_FACTORY + "=" + componentfactory + ")" );
+        final ServiceReference[] refs = bundleContext.getServiceReferences( ComponentFactory.class.getName(),
+            "(" + ComponentConstants.COMPONENT_FACTORY + "=" + componentfactory + ")" );
         TestCase.assertNotNull( refs );
         TestCase.assertEquals( 1, refs.length );
-        final ComponentFactory factory = ( ComponentFactory ) bundleContext.getService( refs[0] );
+        final ComponentFactory factory = (ComponentFactory) bundleContext.getService( refs[0] );
         TestCase.assertNotNull( factory );
         return factory;
     }
 
-
     protected void checkFactory(final String componentfactory, boolean expectFactoryPresent)
         throws InvalidSyntaxException
     {
-        ServiceReference[] refs = bundleContext.getServiceReferences( ComponentFactory.class.getName(), "("
-            + ComponentConstants.COMPONENT_FACTORY + "=" + componentfactory + ")" );
+        ServiceReference[] refs = bundleContext.getServiceReferences( ComponentFactory.class.getName(),
+            "(" + ComponentConstants.COMPONENT_FACTORY + "=" + componentfactory + ")" );
         if ( expectFactoryPresent )
         {
             TestCase.assertNotNull( refs );
-            TestCase.assertEquals(1, refs.length);
+            TestCase.assertEquals( 1, refs.length );
 
         }
         else
@@ -610,15 +611,13 @@ public abstract class ComponentTestBase
         Hashtable<String, String> props = new Hashtable<String, String>();
         props.put( PROP_NAME_FACTORY, PROP_NAME_FACTORY );
 
-        return createFactoryComponentInstance(componentfactory, props);
+        return createFactoryComponentInstance( componentfactory, props );
     }
 
-
-    protected ComponentInstance createFactoryComponentInstance(
-        final String componentfactory, Hashtable<String, String> props)
-        throws InvalidSyntaxException
+    protected ComponentInstance createFactoryComponentInstance(final String componentfactory,
+        Hashtable<String, String> props) throws InvalidSyntaxException
     {
-        final ComponentFactory factory = getComponentFactory(componentfactory);
+        final ComponentFactory factory = getComponentFactory( componentfactory );
 
         final ComponentInstance instance = factory.newInstance( props );
         TestCase.assertNotNull( instance );
@@ -629,10 +628,7 @@ public abstract class ComponentTestBase
         return instance;
     }
 
-
-
-
-    protected static Class<?> getType( Object object, String desiredName )
+    protected static Class<?> getType(Object object, String desiredName)
     {
         Class<?> ccImpl = object.getClass();
         while ( ccImpl != null && !desiredName.equals( ccImpl.getSimpleName() ) )
@@ -647,8 +643,7 @@ public abstract class ComponentTestBase
         return ccImpl;
     }
 
-
-    protected static Object getFieldValue( Object object, String fieldName )
+    protected static Object getFieldValue(Object object, String fieldName)
     {
         try
         {
@@ -662,23 +657,22 @@ public abstract class ComponentTestBase
         }
     }
 
-    protected Object getComponentManagerFromComponentInstance( Object instance )
+    protected Object getComponentManagerFromComponentInstance(Object instance)
     {
-        Object cc = getFieldValue( instance, "m_componentContext");
+        Object cc = getFieldValue( instance, "m_componentContext" );
         return getFieldValue( cc, "m_componentManager" );
     }
 
-
-    protected static Field getField( Class<?> type, String fieldName ) throws NoSuchFieldException
+    protected static Field getField(Class<?> type, String fieldName) throws NoSuchFieldException
     {
         Class<?> clazz = type;
-        while (clazz != null)
+        while ( clazz != null )
         {
             Field[] fields = clazz.getDeclaredFields();
-            for (int i = 0; i < fields.length; i++)
+            for ( int i = 0; i < fields.length; i++ )
             {
                 Field field = fields[i];
-                if (field.getName().equals(fieldName))
+                if ( field.getName().equals( fieldName ) )
                 {
                     field.setAccessible( true );
                     return field;
@@ -686,26 +680,26 @@ public abstract class ComponentTestBase
             }
             clazz = clazz.getSuperclass();
         }
-        throw new NoSuchFieldException(fieldName);
+        throw new NoSuchFieldException( fieldName );
     }
 
-
-    protected Bundle installBundle( final String descriptorFile, String componentPackage ) throws BundleException
+    protected Bundle installBundle(final String descriptorFile, String componentPackage) throws BundleException
     {
-        return installBundle(descriptorFile, componentPackage, "simplecomponent", "0.0.11", null);
+        return installBundle( descriptorFile, componentPackage, "simplecomponent", "0.0.11", null );
     }
 
-    protected Bundle installBundle( final String descriptorFile, String componentPackage, String symbolicName, String version, String location ) throws BundleException
+    protected Bundle installBundle(final String descriptorFile, String componentPackage, String symbolicName,
+        String version, String location) throws BundleException
     {
-        final InputStream bundleStream = bundle()
-                .add("OSGI-INF/components.xml", getClass().getResource(descriptorFile))
+        final InputStream bundleStream = bundle().add( "OSGI-INF/components.xml",
+            getClass().getResource( descriptorFile ) )
 
-                .set(Constants.BUNDLE_SYMBOLICNAME, symbolicName)
-                .set(Constants.BUNDLE_VERSION, version)
-                .set(Constants.IMPORT_PACKAGE, componentPackage)
-                .set("Service-Component", "OSGI-INF/components.xml")
-                .set(Constants.REQUIRE_CAPABILITY, ExtenderNamespace.EXTENDER_NAMESPACE + ";filter:=\"(&(osgi.extender=osgi.component)(version>=1.3)(!(version>=2.0)))\"")
-                .build(withBnd());
+            .set( Constants.BUNDLE_SYMBOLICNAME, symbolicName ).set( Constants.BUNDLE_VERSION, version ).set(
+                Constants.IMPORT_PACKAGE, componentPackage ).set( "Service-Component", "OSGI-INF/components.xml" ).set(
+                    Constants.REQUIRE_CAPABILITY,
+                    ExtenderNamespace.EXTENDER_NAMESPACE
+                        + ";filter:=\"(&(osgi.extender=osgi.component)(version>=1.3)(!(version>=2.0)))\"" ).build(
+                            withBnd() );
 
         try
         {
@@ -732,7 +726,7 @@ public abstract class ComponentTestBase
     public void testDescription()
     {
         PrintStream out = System.out;
-        info( new PrintWriter(out) );
+        info( new PrintWriter( out ) );
     }
 
     private static class InfoWriter extends ScrCommand
@@ -740,31 +734,31 @@ public abstract class ComponentTestBase
 
         protected InfoWriter(ServiceComponentRuntime scrService)
         {
-            super(null, scrService, null);
+            super( null, scrService, null );
         }
 
     }
 
-    void info( PrintWriter out )
+    void info(PrintWriter out)
     {
         ServiceComponentRuntime scr = scrTracker.getService();
         if ( scr == null )
         {
-            TestCase.fail("no ServiceComponentRuntime");
+            TestCase.fail( "no ServiceComponentRuntime" );
         }
-        new InfoWriter(scr).list(null, out);
+        new InfoWriter( scr ).list( null, out );
     }
 
     protected boolean isAtLeastR5()
     {
         try
         {
-            Method m = org.osgi.service.cm.Configuration.class.getDeclaredMethod( "getChangeCount");
+            Method m = org.osgi.service.cm.Configuration.class.getDeclaredMethod( "getChangeCount" );
             return true;
         }
         catch ( SecurityException e )
         {
-            throw new RuntimeException(e);
+            throw new RuntimeException( e );
         }
         catch ( NoSuchMethodException e )
         {
@@ -779,13 +773,13 @@ public abstract class ComponentTestBase
     {
         NullStdout()
         {
-            super(new OutputStream()
+            super( new OutputStream()
             {
                 @Override
                 public void write(int b) throws IOException
                 {
                 }
-            });
+            } );
         }
     }
 
@@ -797,8 +791,7 @@ public abstract class ComponentTestBase
         private final long m_time;
         private final Thread m_thread;
 
-
-        LogEntry( int level, String msg, Throwable t )
+        LogEntry(int level, String msg, Throwable t)
         {
             m_level = level;
             m_msg = msg;
@@ -807,38 +800,32 @@ public abstract class ComponentTestBase
             m_thread = Thread.currentThread();
         }
 
-
         @Override
         public String toString()
         {
             return m_msg;
         }
 
-
         public int getLevel()
         {
             return m_level;
         }
 
-
         public String getMessage()
         {
             return m_msg;
         }
 
-
         public Throwable getError()
         {
             return m_err;
         }
 
-
         public long getTime()
         {
             return m_time;
         }
 
-
         public Thread getThread()
         {
             return m_thread;
@@ -849,8 +836,8 @@ public abstract class ComponentTestBase
     {
         private static final int RESTRICTED_LOG_SIZE = 1000;
         private final SimpleDateFormat m_sdf = new SimpleDateFormat( "HH:mm:ss,S" );
-        private final static PrintStream m_out = new PrintStream( new BufferedOutputStream( new FileOutputStream(
-            FileDescriptor.err ), 128 ) );
+        private final static PrintStream m_out = new PrintStream(
+            new BufferedOutputStream( new FileOutputStream( FileDescriptor.err ), 128 ) );
         private final List<String> m_warnings = Collections.synchronizedList( new ArrayList<String>() );
         private LinkedBlockingQueue<LogEntry> m_logQueue = new LinkedBlockingQueue<LogEntry>();
         private volatile Thread m_logThread;
@@ -864,7 +851,7 @@ public abstract class ComponentTestBase
         private final String[] log = new String[1000];
         private int i = 0;
 
-        public Log( boolean restrictedLogging, String[] ignoredWarnings )
+        public Log(boolean restrictedLogging, String[] ignoredWarnings)
         {
             this.restrictedLogging = restrictedLogging;
             this.ignoredWarnings = ignoredWarnings;
@@ -880,20 +867,20 @@ public abstract class ComponentTestBase
             m_logThread.start();
         }
 
-
         public void stop()
         {
-            System.setOut(m_realOut);
-            System.setErr(m_realErr);
+            System.setOut( m_realOut );
+            System.setErr( m_realErr );
             if ( restrictedLogging )
             {
-                for (int j = 0; j < RESTRICTED_LOG_SIZE; j++)
+                for ( int j = 0; j < RESTRICTED_LOG_SIZE; j++ )
                 {
                     if ( log[i] != null )
                     {
-                        m_realErr.println(log[i++]);
+                        m_realErr.println( log[i++] );
                     }
-                    if (i == RESTRICTED_LOG_SIZE) i = 0;
+                    if ( i == RESTRICTED_LOG_SIZE )
+                        i = 0;
                 }
             }
             else
@@ -911,7 +898,6 @@ public abstract class ComponentTestBase
             }
         }
 
-
         List<String> foundWarnings()
         {
             return m_warnings;
@@ -922,8 +908,6 @@ public abstract class ComponentTestBase
             return firstFrameworkThrowable;
         }
 
-
-
         public void run()
         {
             try
@@ -962,7 +946,8 @@ public abstract class ComponentTestBase
                     if ( restrictedLogging )
                     {
                         log[i++] = sw.toString();
-                        if ( i == RESTRICTED_LOG_SIZE ) i = 0;
+                        if ( i == RESTRICTED_LOG_SIZE )
+                            i = 0;
                     }
                     else
                     {
@@ -977,43 +962,43 @@ public abstract class ComponentTestBase
             }
         }
 
-
         // ------------- FrameworkListener -----------------------------------------------------------
 
-        private boolean acceptWarning(String message) {
-        	if ( ignoredWarnings != null )
-        	{
-				for (String ignore : ignoredWarnings) {
-					if (message.contains(ignore)) {
-						return false;
-					}
-				}
-			}
-			return true;
-		}
+        private boolean acceptWarning(String message)
+        {
+            if ( ignoredWarnings != null )
+            {
+                for ( String ignore : ignoredWarnings )
+                {
+                    if ( message.contains( ignore ) )
+                    {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
 
-		public void frameworkEvent( final FrameworkEvent event )
+        public void frameworkEvent(final FrameworkEvent event)
         {
             int eventType = event.getType();
             String msg = getFrameworkEventMessage( eventType );
-            int level = ( eventType == FrameworkEvent.ERROR ) ? LogService.LOG_ERROR : LogService.LOG_WARNING;
+            int level = ( eventType == FrameworkEvent.ERROR )? LogService.LOG_ERROR: LogService.LOG_WARNING;
             log( level, msg, event.getThrowable() );
-            if (event.getThrowable() != null && firstFrameworkThrowable == null)
+            if ( event.getThrowable() != null && firstFrameworkThrowable == null )
             {
                 firstFrameworkThrowable = event.getThrowable();
             }
         }
 
-
         // ------------ LogService ----------------------------------------------------------------
 
-        public void log( int level, String message )
+        public void log(int level, String message)
         {
             log( level, message, null );
         }
 
-
-        public void log( int level, String message, Throwable exception )
+        public void log(int level, String message, Throwable exception)
         {
             if ( level > getEnabledLogLevel() )
             {
@@ -1022,14 +1007,12 @@ public abstract class ComponentTestBase
             m_logQueue.offer( new LogEntry( level, message, exception ) );
         }
 
-
-        public void log( ServiceReference sr, int osgiLevel, String message )
+        public void log(ServiceReference sr, int osgiLevel, String message)
         {
             log( sr, osgiLevel, message, null );
         }
 
-
-        public void log( ServiceReference sr, int level, String msg, Throwable exception )
+        public void log(ServiceReference sr, int level, String msg, Throwable exception)
         {
             if ( sr != null )
             {
@@ -1048,7 +1031,6 @@ public abstract class ComponentTestBase
             }
         }
 
-
         private int getEnabledLogLevel()
         {
             if ( DS_LOGLEVEL.regionMatches( true, 0, "err", 0, "err".length() ) )
@@ -1069,10 +1051,9 @@ public abstract class ComponentTestBase
             }
         }
 
-
-        private String getFrameworkEventMessage( int event )
+        private String getFrameworkEventMessage(int event)
         {
-            switch ( event )
+            switch (event)
             {
                 case FrameworkEvent.ERROR:
                     return "FrameworkEvent: ERROR";
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/Felix5276Test.java b/scr/src/test/java/org/apache/felix/scr/integration/Felix5276Test.java
new file mode 100644
index 0000000000..a5110bc6bd
--- /dev/null
+++ b/scr/src/test/java/org/apache/felix/scr/integration/Felix5276Test.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.scr.integration;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.Hashtable;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.service.cm.Configuration;
+import org.osgi.service.component.runtime.dto.ComponentConfigurationDTO;
+import org.osgi.service.log.LogService;
+
+@RunWith(JUnit4TestRunner.class)
+public class Felix5276Test extends ComponentTestBase
+{
+    static
+    {
+        descriptorFile = "/integration_test_FELIX_5276.xml";
+        COMPONENT_PACKAGE = COMPONENT_PACKAGE + ".felix5276";
+        DS_LOGLEVEL = "debug";
+    }
+
+    @Test
+    public void test_servicePropsCauseDeactivation() throws Exception
+    {
+        Hashtable<String, Object> props = new Hashtable<String, Object>();
+        Configuration configC = configure("C", null, props);
+        log.log(LogService.LOG_INFO, "configC updated with empty props");
+        delay();
+
+        String componentNameA = "A";
+        ComponentConfigurationDTO componentA = findComponentConfigurationByName(componentNameA,
+            ComponentConfigurationDTO.ACTIVE);
+        log.log(LogService.LOG_INFO, "A checked active");
+
+        String componentNameB = "B";
+        findComponentConfigurationByName(componentNameB, ComponentConfigurationDTO.ACTIVE);
+        log.log(LogService.LOG_INFO, "B checked active");
+        String componentNameC = "C";
+        findComponentConfigurationByName(componentNameC, ComponentConfigurationDTO.ACTIVE);
+        log.log(LogService.LOG_INFO, "C checked active");
+
+        props.put("b.target", "(foo=bar)");
+        configC.update(props);
+        log.log(LogService.LOG_INFO, "configC updated with target filter");
+        delay();
+
+        findComponentConfigurationByName(componentNameC, ComponentConfigurationDTO.ACTIVE);
+        log.log(LogService.LOG_INFO, "C checked active");
+
+        disableAndCheck(componentA);
+
+        log.log(LogService.LOG_INFO, "A disabled");
+        findComponentConfigurationByName(componentNameC, ComponentConfigurationDTO.ACTIVE);
+        log.log(LogService.LOG_INFO, "C checked active");
+        findComponentConfigurationByName(componentNameB, ComponentConfigurationDTO.SATISFIED);
+        log.log(LogService.LOG_INFO, "B checked satisfied");
+
+        assertTrue("Expected no errors or warnings: " + log.foundWarnings(), log.foundWarnings().isEmpty());
+    }
+}
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/A.java b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/A.java
new file mode 100644
index 0000000000..7cb36153d5
--- /dev/null
+++ b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/A.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.scr.integration.components.felix5276;
+
+public class A
+{
+
+}
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/B.java b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/B.java
new file mode 100644
index 0000000000..6c7e792334
--- /dev/null
+++ b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/B.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.scr.integration.components.felix5276;
+
+import java.util.Collections;
+import java.util.Map;
+
+public class B
+{
+    private A a;
+
+    private Map<String, Object> setA(A a)
+    {
+        this.a = a;
+        return Collections.<String, Object> singletonMap("foo", "bar");
+    }
+
+    private Map<String, Object> unsetA(A a)
+    {
+        if (this.a == a)
+        {
+            this.a = null;
+            return Collections.emptyMap();
+        }
+        return Collections.<String, Object> singletonMap("foo", "bar");
+    }
+
+}
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/C.java b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/C.java
new file mode 100644
index 0000000000..7c48d768e9
--- /dev/null
+++ b/scr/src/test/java/org/apache/felix/scr/integration/components/felix5276/C.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.scr.integration.components.felix5276;
+
+import java.util.Map;
+
+public class C
+{
+    private B b;
+
+    void modify(Map<String, Object> props)
+    {
+
+    }
+
+    private void setB(B b)
+    {
+        this.b = b;
+    }
+
+    private void unsetB(B b)
+    {
+        if (this.b == b)
+        {
+            this.b = null;
+        }
+    }
+
+}
diff --git a/scr/src/test/resources/integration_test_FELIX_5276.xml b/scr/src/test/resources/integration_test_FELIX_5276.xml
new file mode 100644
index 0000000000..54aec15f39
--- /dev/null
+++ b/scr/src/test/resources/integration_test_FELIX_5276.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+    
+        http://www.apache.org/licenses/LICENSE-2.0
+    
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+-->
+<components xmlns:scr="http://www.osgi.org/xmlns/scr/v1.1.0">
+
+    <scr:component name="A"
+        configuration-policy="ignore">
+        <implementation class="org.apache.felix.scr.integration.components.felix5276.A" />
+        <service>
+            <provide interface="org.apache.felix.scr.integration.components.felix5276.A" />
+        </service>
+    </scr:component>
+    
+    <scr:component name="B"
+        xmlns:scr="http://felix.apache.org/xmlns/scr/v1.2.0-felix"
+        configuration-policy="ignore">
+        <implementation class="org.apache.felix.scr.integration.components.felix5276.B" />
+        <service>
+            <provide interface="org.apache.felix.scr.integration.components.felix5276.B" />
+        </service>
+        <reference
+            name="a"
+            interface="org.apache.felix.scr.integration.components.felix5276.A"
+            cardinality="0..1"
+            policy="dynamic"
+            bind="setA"
+            unbind="unsetA"
+        />
+    </scr:component>
+    
+   <scr:component name="C"
+        modified="modify"
+        configuration-policy="require">
+        <implementation class="org.apache.felix.scr.integration.components.felix5276.C" />
+        <reference
+            name="b"
+            interface="org.apache.felix.scr.integration.components.felix5276.B"
+            cardinality="0..1"
+            policy="dynamic"
+            bind="setB"
+            unbind="unsetB"
+        />
+    </scr:component>
+    
+</components>
\ No newline at end of file
