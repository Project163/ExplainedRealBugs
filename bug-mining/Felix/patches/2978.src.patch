diff --git a/osgi-r7/http/base/src/test/java/org/apache/felix/http/base/internal/handler/HttpSessionWrapperTest.java b/osgi-r7/http/base/src/test/java/org/apache/felix/http/base/internal/handler/HttpSessionWrapperTest.java
index 71857a328a..35a3499630 100644
--- a/osgi-r7/http/base/src/test/java/org/apache/felix/http/base/internal/handler/HttpSessionWrapperTest.java
+++ b/osgi-r7/http/base/src/test/java/org/apache/felix/http/base/internal/handler/HttpSessionWrapperTest.java
@@ -27,11 +27,18 @@ import static org.mockito.Mockito.when;
 
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Set;
 
 import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionListener;
 
+import org.apache.felix.http.base.internal.context.ExtServletContext;
 import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
 /**
  * Test cases for {@link HttpSessionWrapper}.
@@ -75,4 +82,56 @@ public class HttpSessionWrapperTest
 
         return session;
     }
+
+    /**
+     * FELIX-5819 : Container session should not be invalidated
+     */
+    @Test
+    public void testContainerSessionInvalidation()
+    {
+        // create container session
+        final Map<String, Object> attributes = new HashMap<>();
+        final HttpSession containerSession = mock(HttpSession.class);
+        when(containerSession.getAttributeNames()).thenReturn(Collections.enumeration(attributes.keySet()));
+        when(containerSession.getAttribute(Mockito.anyString())).thenAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                return attributes.get(invocation.getArgumentAt(0, String.class));
+            }
+        });
+        when(containerSession.getAttribute(Mockito.anyString())).thenAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                return attributes.get(invocation.getArgumentAt(0, String.class));
+            }
+        });
+        Mockito.doAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                attributes.put(invocation.getArgumentAt(0, String.class), invocation.getArgumentAt(1, Object.class));
+                return null;
+            }
+        }).when(containerSession).setAttribute(Mockito.anyString(), Mockito.any());
+        Mockito.doAnswer(new Answer<Object>() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                attributes.remove(invocation.getArgumentAt(0, String.class));
+                return null;
+            }
+        }).when(containerSession).removeAttribute(Mockito.anyString());
+
+        final HttpSessionListener listener = mock(HttpSessionListener.class);
+
+        // create context session
+        final ExtServletContext context = mock(ExtServletContext.class);
+        when(context.getServletContextName()).thenReturn("default");
+        when(context.getHttpSessionListener()).thenReturn(listener);
+
+        final HttpSession contextSession = new HttpSessionWrapper(containerSession, context, false);
+        // invalidate context session and verify that invalidate is not called on the container session
+        contextSession.invalidate();
+        assertTrue(attributes.isEmpty());
+        Mockito.verify(containerSession, Mockito.never()).invalidate();
+    }
+
 }
