diff --git a/fileinstall/src/main/java/org/apache/felix/fileinstall/internal/DirectoryWatcher.java b/fileinstall/src/main/java/org/apache/felix/fileinstall/internal/DirectoryWatcher.java
index 37e75fdf19..5ee3f7dda0 100644
--- a/fileinstall/src/main/java/org/apache/felix/fileinstall/internal/DirectoryWatcher.java
+++ b/fileinstall/src/main/java/org/apache/felix/fileinstall/internal/DirectoryWatcher.java
@@ -138,6 +138,7 @@ public class DirectoryWatcher extends Thread implements BundleListener
     String fragmentScope;
     String optionalScope;
     boolean disableNio2;
+    int frameworkStartLevel;
 
     // Map of all installed artifacts
     final Map<File, Artifact> currentManagedArtifacts = new HashMap<File, Artifact>();
@@ -503,20 +504,25 @@ public class DirectoryWatcher extends Thread implements BundleListener
             }
         }
 
-        if (startBundles && isStateChanged())
-        {
-            // Try to start all the bundles that are not persistently stopped
-            startAllBundles();
-            
-            delayedStart.addAll(installedBundles);
-            delayedStart.removeAll(uninstalledBundles);
-            // Try to start newly installed bundles, or bundles which we missed on a previous round
-            startBundles(delayedStart);
-            consistentlyFailingBundles.clear();
-            consistentlyFailingBundles.addAll(delayedStart);
-
-            // set the state as unchanged to not reattempt starting failed bundles
-            setStateChanged(false);
+        if (startBundles) {
+            int startLevel = systemBundle.adapt(FrameworkStartLevel.class).getStartLevel();
+            boolean doStart = isStateChanged() || startLevel != frameworkStartLevel;
+            frameworkStartLevel = startLevel;
+            if (doStart)
+            {
+                // Try to start all the bundles that are not persistently stopped
+                startAllBundles();
+
+                delayedStart.addAll(installedBundles);
+                delayedStart.removeAll(uninstalledBundles);
+                // Try to start newly installed bundles, or bundles which we missed on a previous round
+                startBundles(delayedStart);
+                consistentlyFailingBundles.clear();
+                consistentlyFailingBundles.addAll(delayedStart);
+
+                // set the state as unchanged to not reattempt starting failed bundles
+                setStateChanged(false);
+            }
         }
     }
 
@@ -1233,7 +1239,6 @@ public class DirectoryWatcher extends Thread implements BundleListener
       */
     private boolean startBundle(Bundle bundle, boolean logFailures)
     {
-        FrameworkStartLevel startLevelSvc = systemBundle.adapt(FrameworkStartLevel.class);
         // Fragments can never be started.
         // Bundles can only be started transient when the start level of the framework is high
         // enough. Persistent (i.e. non-transient) starts will simply make the framework start the
@@ -1241,7 +1246,7 @@ public class DirectoryWatcher extends Thread implements BundleListener
         if (startBundles
                 && bundle.getState() != Bundle.UNINSTALLED
                 && !isFragment(bundle)
-                && startLevelSvc.getStartLevel() >= bundle.adapt(BundleStartLevel.class).getStartLevel())
+                && frameworkStartLevel >= bundle.adapt(BundleStartLevel.class).getStartLevel())
         {
             try
             {
