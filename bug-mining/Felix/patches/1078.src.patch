diff --git a/framework/src/main/java/org/apache/felix/framework/Felix.java b/framework/src/main/java/org/apache/felix/framework/Felix.java
index 0225f6152e..47eed2ad8d 100644
--- a/framework/src/main/java/org/apache/felix/framework/Felix.java
+++ b/framework/src/main/java/org/apache/felix/framework/Felix.java
@@ -3419,9 +3419,8 @@ ex.printStackTrace();
             {
                 Bundle b = ((ModuleImpl) ex.getModule()).getBundle();
                 throw new BundleException(
-                    "Unresolved constraint in bundle " + b + ": "
-                    + ((ex.getRequirement() == null)
-                        ? ex.getMessage() : ex.getMessage() + " - " + ex.getRequirement().toString()));
+                    "Unresolved constraint in bundle "
+                    + b + ": " + ex.getMessage());
             }
             else
             {
diff --git a/framework/src/main/java/org/apache/felix/framework/resolver/ResolverImpl.java b/framework/src/main/java/org/apache/felix/framework/resolver/ResolverImpl.java
index 39fe78fb87..0ef75f2fb9 100644
--- a/framework/src/main/java/org/apache/felix/framework/resolver/ResolverImpl.java
+++ b/framework/src/main/java/org/apache/felix/framework/resolver/ResolverImpl.java
@@ -415,7 +415,18 @@ public class ResolverImpl implements Resolver
             for (Iterator<Capability> itCandCap = candidates.iterator(); itCandCap.hasNext(); )
             {
                 Capability candCap = itCandCap.next();
-                if (!candCap.getModule().isResolved())
+
+                // If the candidate module is not resolved and not the current
+                // module we are trying to populate, then try to populate the
+                // candidate module as well.
+                // NOTE: Technically, we don't have to check to see if the
+                // candidate module is equal to the current module, but this
+                // saves us from recursing and also simplifies exceptions messages
+                // since we effectively chain exception messages for each level
+                // of recursion; thus, any avoided recursion results in fewer
+                // exceptions to chain when an error does occur.
+                if (!candCap.getModule().isResolved()
+                    && !candCap.getModule().equals(module))
                 {
                     try
                     {
