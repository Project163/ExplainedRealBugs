diff --git a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTest.java b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTest.java
index 4c0f89aafd..ab77a1b6a1 100644
--- a/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTest.java
+++ b/configadmin/src/test/java/org/apache/felix/cm/integration/ConfigurationTest.java
@@ -46,6 +46,7 @@ import org.osgi.framework.BundleContext;
 import org.osgi.framework.BundleException;
 import org.osgi.framework.Constants;
 import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
 import org.osgi.service.cm.Configuration;
 import org.osgi.service.cm.ConfigurationAdmin;
 import org.osgi.util.tracker.ServiceTracker;
@@ -106,7 +107,7 @@ public class ConfigurationTest
 
 
     @Test
-    public void test_configuration_unbound_on_uninstall() throws IOException, BundleException
+    public void test_configuration_unbound_on_uninstall() throws BundleException
     {
         String pid = "test.pid";
         configure( pid );
@@ -143,6 +144,8 @@ public class ConfigurationTest
 
         bundle.stop();
 
+        delay();
+
         // ensure configuration still bound
         TestCase.assertEquals( beforeInstall.getBundleLocation(), bundle.getLocation() );
         TestCase.assertEquals( beforeStart.getBundleLocation(), bundle.getLocation() );
@@ -155,6 +158,8 @@ public class ConfigurationTest
         bundle.uninstall();
         bundle = null;
 
+        delay();
+
         // ensure configuration is not bound any more
         TestCase.assertNull( beforeInstall.getBundleLocation() );
         TestCase.assertNull( beforeStart.getBundleLocation() );
@@ -171,7 +176,218 @@ public class ConfigurationTest
 
 
     @Test
-    public void test_start_bundle_configure_stop_start_bundle() throws IOException, BundleException
+    public void test_multi_value_pid_array() throws BundleException
+    {
+        final String pid1 = "test.pid.1";
+        final String pid2 = "test.pid.2";
+
+        configure( pid1 );
+        configure( pid2 );
+
+        final Configuration config1 = getConfiguration( pid1 );
+        TestCase.assertEquals( pid1, config1.getPid() );
+        TestCase.assertNull( config1.getBundleLocation() );
+
+        final Configuration config2 = getConfiguration( pid2 );
+        TestCase.assertEquals( pid2, config2.getPid() );
+        TestCase.assertNull( config2.getBundleLocation() );
+
+        // multi-pid with array
+        bundle = installBundle( pid1 + "," + pid2 );
+        bundle.start();
+
+        // give cm time for distribution
+        delay();
+
+        final TestActivator tester = TestActivator.INSTANCE;
+        TestCase.assertNotNull( "Activator not started !!", tester );
+
+        // assert activater has configuration (two calls, one per pid)
+        TestCase.assertNotNull( "Expect Properties after Service Registration", tester.props );
+        TestCase.assertEquals( "Expect a single update call", 2, tester.numUpdatedCalls );
+
+        TestCase.assertEquals( bundle.getLocation(), config1.getBundleLocation() );
+        TestCase.assertEquals( bundle.getLocation(), config2.getBundleLocation() );
+
+        bundle.uninstall();
+        bundle = null;
+
+        delay();
+
+        TestCase.assertNull( config1.getBundleLocation() );
+        TestCase.assertNull( config2.getBundleLocation() );
+
+        // remove the configuration for good
+        deleteConfig( pid1 );
+        deleteConfig( pid2 );
+    }
+
+
+    @Test
+    public void test_multi_value_pid_collection() throws BundleException
+    {
+        String pid1 = "test.pid.1";
+        String pid2 = "test.pid.2";
+
+        configure( pid1 );
+        configure( pid2 );
+
+        final Configuration config1 = getConfiguration( pid1 );
+        TestCase.assertEquals( pid1, config1.getPid() );
+        TestCase.assertNull( config1.getBundleLocation() );
+
+        final Configuration config2 = getConfiguration( pid2 );
+        TestCase.assertEquals( pid2, config2.getPid() );
+        TestCase.assertNull( config2.getBundleLocation() );
+
+        // multi-pid with collection
+        bundle = installBundle( pid1 + ";" + pid2 );
+        bundle.start();
+
+        // give cm time for distribution
+        delay();
+
+        final TestActivator tester = TestActivator.INSTANCE;
+        TestCase.assertNotNull( "Activator not started !!", tester );
+
+        // assert activater has configuration (two calls, one per pid)
+        TestCase.assertNotNull( "Expect Properties after Service Registration", tester.props );
+        TestCase.assertEquals( "Expect a single update call", 2, tester.numUpdatedCalls );
+
+        TestCase.assertEquals( bundle.getLocation(), config1.getBundleLocation() );
+        TestCase.assertEquals( bundle.getLocation(), config2.getBundleLocation() );
+
+        bundle.uninstall();
+        bundle = null;
+
+        delay();
+
+        TestCase.assertNull( config1.getBundleLocation() );
+        TestCase.assertNull( config2.getBundleLocation() );
+
+        // remove the configuration for good
+        deleteConfig( pid1 );
+        deleteConfig( pid2 );
+    }
+
+
+    @Test
+    public void test_configuration_unbound_on_uninstall_with_cm_restart() throws BundleException
+    {
+        final String pid = "test.pid";
+        configure( pid );
+        final Bundle cmBundle = getCmBundle();
+
+        // ensure configuration is unbound
+        final Configuration beforeInstall = getConfiguration( pid );
+        TestCase.assertNull( beforeInstall.getBundleLocation() );
+
+        bundle = installBundle( pid );
+
+        // ensure no configuration bound before start
+        final Configuration beforeStart = getConfiguration( pid );
+        TestCase.assertNull( beforeInstall.getBundleLocation() );
+        TestCase.assertNull( beforeStart.getBundleLocation() );
+
+        bundle.start();
+        final TestActivator tester = TestActivator.INSTANCE;
+        TestCase.assertNotNull( "IOActivator not started !!", tester );
+
+        // give cm time for distribution
+        delay();
+
+        // assert activater has configuration
+        TestCase.assertNotNull( "Expect Properties after Service Registration", tester.props );
+        TestCase.assertEquals( "Expect a single update call", 1, tester.numUpdatedCalls );
+
+        // ensure a freshly retrieved object also has the location
+        final Configuration beforeStop = getConfiguration( pid );
+        TestCase.assertEquals( beforeStop.getBundleLocation(), bundle.getLocation() );
+
+        // check whether bundle context is set on first configuration
+        TestCase.assertEquals( beforeInstall.getBundleLocation(), bundle.getLocation() );
+        TestCase.assertEquals( beforeStart.getBundleLocation(), bundle.getLocation() );
+
+        bundle.stop();
+
+        // ensure configuration still bound
+        TestCase.assertEquals( beforeInstall.getBundleLocation(), bundle.getLocation() );
+        TestCase.assertEquals( beforeStart.getBundleLocation(), bundle.getLocation() );
+        TestCase.assertEquals( beforeStop.getBundleLocation(), bundle.getLocation() );
+
+        // ensure a freshly retrieved object also has the location
+        final Configuration beforeUninstall = getConfiguration( pid );
+        TestCase.assertEquals( beforeUninstall.getBundleLocation(), bundle.getLocation() );
+
+        // stop cm bundle now before uninstalling configured bundle
+        cmBundle.stop();
+        delay();
+
+        // assert configuration admin service is gone
+        TestCase.assertNull( configAdminTracker.getService() );
+
+        // uninstall bundle while configuration admin is stopped
+        bundle.uninstall();
+        bundle = null;
+
+        // start cm bundle again after uninstallation
+        cmBundle.start();
+        delay();
+
+        // ensure a freshly retrieved object also does not have the location
+        // FELIX-1484: this test fails due to bundle location not verified
+        //    at first configuration access
+        final Configuration atEnd = getConfiguration( pid );
+        TestCase.assertNull( atEnd.getBundleLocation() );
+
+        // remove the configuration for good
+        deleteConfig( pid );
+    }
+
+
+    @Test
+    public void test_not_updated_new_configuration_not_bound_after_bundle_uninstall() throws IOException, BundleException
+    {
+        final String pid = "test_not_updated_new_configuration_not_bound_after_bundle_uninstall";
+
+        // create a configuration but do not update with properties
+        final ConfigurationAdmin ca = getConfigurationAdmin();
+        final Configuration newConfig = ca.getConfiguration( pid, null );
+        TestCase.assertNull( newConfig.getProperties() );
+        TestCase.assertNull( newConfig.getBundleLocation() );
+
+        // start and settle bundle
+        bundle = installBundle( pid );
+        bundle.start();
+        delay();
+
+        // ensure no properties provided to bundle
+        final TestActivator tester = TestActivator.INSTANCE;
+        TestCase.assertNotNull( "Activator not started !!", tester );
+        TestCase.assertNull( "Expect no properties after Service Registration", tester.props );
+        TestCase.assertEquals( "Expect a single update call", 1, tester.numUpdatedCalls );
+
+        // assert configuration is still unset but bound
+        TestCase.assertNull( newConfig.getProperties() );
+        TestCase.assertEquals( bundle.getLocation(), newConfig.getBundleLocation() );
+
+        // uninstall bundle, should unbind configuration
+        bundle.uninstall();
+        bundle = null;
+
+        delay();
+
+        // assert configuration is still unset and unbound
+        TestCase.assertNull( newConfig.getProperties() );
+        TestCase.assertNull( newConfig.getBundleLocation() );
+
+        // remove the configuration for good
+        deleteConfig( pid );
+    }
+
+
+    @Test
+    public void test_start_bundle_configure_stop_start_bundle() throws BundleException
     {
         String pid = "test_start_bundle_configure_stop_start_bundle";
 
@@ -226,10 +442,8 @@ public class ConfigurationTest
     }
 
 
-
-
     @Test
-    public void test_configure_start_bundle_stop_start_bundle() throws IOException, BundleException
+    public void test_configure_start_bundle_stop_start_bundle() throws BundleException
     {
         String pid = "test_configure_start_bundle_stop_start_bundle";
         configure( pid );
@@ -277,6 +491,50 @@ public class ConfigurationTest
     }
 
 
+    @Test
+    public void test_statically_bound() throws BundleException
+    {
+        final String pid = "test_statically_bound";
+
+        // install the bundle (we need the location)
+        bundle = installBundle( pid);
+        final String location = bundle.getLocation();
+
+        // create and statically bind the configuration
+        configure( pid );
+        final Configuration config = getConfiguration( pid );
+        TestCase.assertEquals( pid, config.getPid() );
+        TestCase.assertNull( config.getBundleLocation() );
+        config.setBundleLocation( location );
+        TestCase.assertEquals( location, config.getBundleLocation() );
+
+        bundle.start();
+
+        // give cm time for distribution
+        delay();
+
+        final TestActivator tester = TestActivator.INSTANCE;
+        TestCase.assertNotNull( "Activator not started !!", tester );
+
+        // assert activater has configuration (two calls, one per pid)
+        TestCase.assertNotNull( "Expect Properties after Service Registration", tester.props );
+        TestCase.assertEquals( "Expect a single update call", 1, tester.numUpdatedCalls );
+
+        TestCase.assertEquals( location, config.getBundleLocation() );
+
+        bundle.uninstall();
+        bundle = null;
+
+        delay();
+
+        // statically bound configurations must remain bound after bundle uninstall
+        TestCase.assertEquals( location, config.getBundleLocation() );
+
+        // remove the configuration for good
+        deleteConfig( pid );
+    }
+
+
     /*
     @Test
     public void test_() throws BundleException
@@ -336,6 +594,13 @@ public class ConfigurationTest
     }
 
 
+    private Bundle getCmBundle()
+    {
+        final ServiceReference caref = configAdminTracker.getServiceReference();
+        return ( caref == null ) ? null : caref.getBundle();
+    }
+
+
     private ConfigurationAdmin getConfigurationAdmin()
     {
         ConfigurationAdmin ca = ( ConfigurationAdmin ) configAdminTracker.getService();
