diff --git a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/ExplodingOutputtingInputStream.java b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/ExplodingOutputtingInputStream.java
index 0cf664ac99..06043534c2 100644
--- a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/ExplodingOutputtingInputStream.java
+++ b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/ExplodingOutputtingInputStream.java
@@ -136,7 +136,7 @@ class ExplodingOutputtingInputStream extends OutputtingInputStream implements Ru
                 writer.close();
             }
         }
-        
+
         try {
             byte[] buffer = new byte[1024];
             int c = m_input.read(buffer);
@@ -158,7 +158,7 @@ class ExplodingOutputtingInputStream extends OutputtingInputStream implements Ru
             }
         }
     }
-    
+
     private void pushException(Exception e) {
         Exception e2 = new Exception(e.getMessage());
         e2.setStackTrace(e.getStackTrace());
@@ -171,7 +171,7 @@ class ExplodingOutputtingInputStream extends OutputtingInputStream implements Ru
     public static boolean replace(File target, File source) {
         return delete(target, true) && rename(source, target);
     }
-    
+
     public static boolean copy(File from, File to) {
         boolean result = true;
         if (from.isDirectory()) {
@@ -223,7 +223,7 @@ class ExplodingOutputtingInputStream extends OutputtingInputStream implements Ru
         }
         return result;
     }
-    
+
     public static boolean rename(File from, File to) {
         if (!from.renameTo(to)) {
             if (copy(from, to)) {
@@ -265,7 +265,7 @@ class ExplodingOutputtingInputStream extends OutputtingInputStream implements Ru
         List result = new ArrayList(targetFiles);
 
         File manifestFile = new File(source, (String) sourceFiles.remove(0));
-        Manifest resultManifest = new Manifest(new GZIPInputStream(new FileInputStream(manifestFile)));
+        Manifest resultManifest = Utils.readManifest(manifestFile);
 
         resultManifest.getMainAttributes().remove(new Name(Constants.DEPLOYMENTPACKAGE_FIXPACK));
 
diff --git a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/FileDeploymentPackage.java b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/FileDeploymentPackage.java
index 8d5f4dc3e5..64341deee4 100644
--- a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/FileDeploymentPackage.java
+++ b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/FileDeploymentPackage.java
@@ -53,27 +53,11 @@ public class FileDeploymentPackage extends AbstractDeploymentPackage {
     }
 
     private FileDeploymentPackage(List index, File packageDir, BundleContext bundleContext, DeploymentAdminImpl deploymentAdmin) throws DeploymentException, IOException {
-        super(readManifest(index, packageDir), bundleContext, deploymentAdmin);
+        super(Utils.readManifest(new File(packageDir, (String) index.remove(0))), bundleContext, deploymentAdmin);
         m_index = index;
         m_contentsDir = packageDir;
     }
 
-    private static Manifest readManifest(List index, File packageDir) throws FileNotFoundException, IOException {
-        final File manifestFile = new File(packageDir, (String) index.remove(0));
-        InputStream is = null;
-        Manifest mf = null;
-        try {
-            is = new GZIPInputStream(new FileInputStream(manifestFile));
-            mf = new Manifest(is);
-        }
-        finally {
-            if (is != null) {
-                is.close();
-            }
-        }
-        return mf;
-    }
-
     public BundleInfoImpl[] getOrderedBundleInfos() {
         List result = new ArrayList();
         for(Iterator i = m_index.iterator(); i.hasNext();) {
diff --git a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/Utils.java b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/Utils.java
new file mode 100644
index 0000000000..aa9c94a512
--- /dev/null
+++ b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/Utils.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.felix.deploymentadmin;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.jar.Manifest;
+import java.util.zip.GZIPInputStream;
+
+public class Utils {
+    public static Manifest readManifest(File manifestFile) throws IOException {
+        InputStream is = null;
+        Manifest mf = null;
+        try {
+            is = new GZIPInputStream(new FileInputStream(manifestFile));
+            mf = new Manifest(is);
+        }
+        finally {
+            if (is != null) {
+                is.close();
+            }
+        }
+        return mf;
+    }
+}
diff --git a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/DropBundleCommand.java b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/DropBundleCommand.java
index ce74ba756e..3f2ddd32a0 100644
--- a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/DropBundleCommand.java
+++ b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/DropBundleCommand.java
@@ -47,37 +47,47 @@ public class DropBundleCommand extends Command {
                 try {
                     Bundle bundle = target.getBundle(symbolicName);
                     bundle.uninstall();
-                    addRollback(new InstallBundleRunnable(bundle, target.getBundleStream(symbolicName), log));
+                    addRollback(new InstallBundleRunnable(bundle, target, log));
                 }
                 catch (BundleException be) {
                     log.log(LogService.LOG_WARNING, "Bundle '" + symbolicName + "' could not be uninstalled", be);
                 }
-                catch (IOException e) {
-                    log.log(LogService.LOG_WARNING, "Could not get bundle data stream for bundle '" + symbolicName + "'", e);
-                    throw new DeploymentException(DeploymentException.CODE_OTHER_ERROR, "Could not prepare rollback for uninstalling bundle '" + symbolicName + "'");
-                }
             }
         }
     }
 
     private static class InstallBundleRunnable implements Runnable {
 
-        private final InputStream m_bundleStream;
+        private final AbstractDeploymentPackage m_target;
         private final Bundle m_bundle;
         private final LogService m_log;
 
-        public InstallBundleRunnable(Bundle bundle, InputStream bundleStream, LogService log) {
+        public InstallBundleRunnable(Bundle bundle, AbstractDeploymentPackage target, LogService log) {
             m_bundle = bundle;
-            m_bundleStream = bundleStream;
+            m_target = target;
             m_log = log;
         }
 
         public void run() {
+            InputStream is = null;
             try {
-                m_bundle.update(m_bundleStream);
+                is = m_target.getBundleStream(m_bundle.getSymbolicName());
+                if (is != null) {
+                    m_bundle.update(is);
+                }
+                throw new Exception("Unable to get Inputstream for bundle " + m_bundle.getSymbolicName());
             }
-            catch (BundleException e) {
-                m_log.log(LogService.LOG_WARNING, "Could not rollback uninstallation of bundle '" + m_bundle.getSymbolicName() + "'", e);
+            catch (Exception e) {
+                m_log.log(LogService.LOG_WARNING,
+                    "Could not rollback uninstallation of bundle '" + m_bundle.getSymbolicName() + "'", e);
+            }
+            finally {
+                if (is != null) {
+                    try {
+                        is.close();
+                    }
+                    catch (IOException e) {}
+                }
             }
         }
     }
diff --git a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/UpdateCommand.java b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/UpdateCommand.java
index 14e5cf33be..5159d29032 100644
--- a/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/UpdateCommand.java
+++ b/deploymentadmin/deploymentadmin/src/main/java/org/apache/felix/deploymentadmin/spi/UpdateCommand.java
@@ -32,6 +32,7 @@ import org.osgi.framework.BundleContext;
 import org.osgi.framework.BundleException;
 import org.osgi.framework.Version;
 import org.osgi.service.deploymentadmin.DeploymentException;
+import org.osgi.service.log.LogService;
 
 /**
  * Command that installs all bundles described in the source deployment package of a deployment
@@ -44,6 +45,7 @@ public class UpdateCommand extends Command {
         AbstractDeploymentPackage source = session.getSourceAbstractDeploymentPackage();
         AbstractDeploymentPackage targetPackage = session.getTargetAbstractDeploymentPackage();
         BundleContext context = session.getBundleContext();
+        LogService log = session.getLog();
 
         Map expectedBundles = new HashMap();
         AbstractInfo[] bundleInfos = (AbstractInfo[]) source.getBundleInfos();
@@ -72,14 +74,14 @@ public class UpdateCommand extends Command {
                     if (bundle == null) {
                         // new bundle, install it
                         bundle = context.installBundle(Constants.BUNDLE_LOCATION_PREFIX + bundleInfo.getSymbolicName(), new BundleInputStream(source.getCurrentEntryStream()));
-                        addRollback(new UninstallBundleRunnable(bundle));
+                        addRollback(new UninstallBundleRunnable(bundle, log));
                     } else {
                         // existing bundle, update it
                         Version sourceVersion = bundleInfo.getVersion();
                         Version targetVersion = Version.parseVersion((String) bundle.getHeaders().get(org.osgi.framework.Constants.BUNDLE_VERSION));
                         if (!sourceVersion.equals(targetVersion)) {
                             bundle.update(new BundleInputStream(source.getCurrentEntryStream()));
-                            addRollback(new UpdateBundleRunnable(bundle, targetPackage, bundleInfo.getSymbolicName()));
+                            addRollback(new UpdateBundleRunnable(bundle, targetPackage, log));
                         }
                     }
                 }
@@ -102,9 +104,11 @@ public class UpdateCommand extends Command {
     private static class UninstallBundleRunnable implements Runnable {
 
         private final Bundle m_bundle;
+        private final LogService m_log;
 
-        public UninstallBundleRunnable(Bundle bundle) {
+        public UninstallBundleRunnable(Bundle bundle, LogService log) {
             m_bundle = bundle;
+            m_log = log;
         }
 
         public void run() {
@@ -112,31 +116,43 @@ public class UpdateCommand extends Command {
                 m_bundle.uninstall();
             }
             catch (BundleException e) {
-                // TODO: log this
-                e.printStackTrace();
+                m_log.log(LogService.LOG_WARNING, "Could not rollback update of bundle '" + m_bundle.getSymbolicName() + "'", e);
             }
         }
     }
 
     private static class UpdateBundleRunnable implements Runnable {
 
-        private final Bundle m_bundle;
         private final AbstractDeploymentPackage m_targetPackage;
-        private final String m_symbolicName;
+        private final Bundle m_bundle;
+        private final LogService m_log;
 
-        public UpdateBundleRunnable(Bundle bundle, AbstractDeploymentPackage targetPackage, String symbolicName) {
+        public UpdateBundleRunnable(Bundle bundle, AbstractDeploymentPackage targetPackage, LogService log) {
             m_bundle = bundle;
             m_targetPackage = targetPackage;
-            m_symbolicName = symbolicName;
+            m_log = log;
         }
 
         public void run() {
+            InputStream is = null;
             try {
-                m_bundle.update(m_targetPackage.getBundleStream(m_symbolicName));
+                is = m_targetPackage.getBundleStream(m_bundle.getSymbolicName());
+                if(is != null){
+                    m_bundle.update(is);                    
+                }
+                throw new Exception("Unable to get Inputstream for bundle " + m_bundle.getSymbolicName());
             }
             catch (Exception e) {
-                // TODO: log this
-                e.printStackTrace();
+                m_log.log(LogService.LOG_WARNING, "Could not rollback update of bundle '" + m_bundle.getSymbolicName() + "'", e);
+            } finally {
+                if(is != null){
+                    try {
+                        is.close();
+                    }
+                    catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                }
             }
         }
     }
