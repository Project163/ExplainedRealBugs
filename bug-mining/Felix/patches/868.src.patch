diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/HandlerManager.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/HandlerManager.java
index 261055ee1d..2e1e740092 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/HandlerManager.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/HandlerManager.java
@@ -82,6 +82,32 @@ public class HandlerManager extends InstanceManager {
         if (m_handler != null) { return; }
         m_handler = (Handler) createPojoObject();
     }
+    
+    /**
+     * Creates an instance of the content.
+     * This method needs to be called once only for singleton provided service.
+     * This methods call the {@link InstanceManager#createObject()} method, and adds
+     * the created object to the {@link InstanceManager#m_pojoObjects} list. Then,
+     * it calls the {@link PrimitiveHandler#onCreation(Object)} methods on attached
+     * handlers.
+     * @return a new instance or <code>null</code> if an error occurs during the
+     * creation.
+     */
+    public Object createPojoObject() {
+        Object instance = createObject();
+
+        // Add the new instance in the instance list.
+        synchronized (this) {
+            if (m_pojoObjects == null) {
+                m_pojoObjects = new ArrayList(1);
+            }
+            m_pojoObjects.add(instance);
+        }
+        
+        //Do not call onCreation, this will be done in the start method.
+        
+        return instance;
+    }
 
     /**
      * Starts the instance manager.
@@ -95,13 +121,21 @@ public class HandlerManager extends InstanceManager {
             }
         }
 
+        // Start attached handler.
         for (int i = 0; i < m_handlers.length; i++) {
             m_handlers[i].addInstanceStateListener(this);
             m_handlers[i].start();
         }
         
-        m_handler.start(); // Call the handler start method.
+        // Call the onCreation method.
+        for (int i = 0; i < m_handlers.length; i++) {
+            ((PrimitiveHandler) m_handlers[i].getHandler()).onCreation(m_handler);
+        }
 
+        
+        m_handler.start(); // Call the handler start method, the instance might be invalid.
+        
+        
         for (int i = 0; i < m_handlers.length; i++) {
             if (!m_handlers[i].getHandler().isValid()) {
                 setState(INVALID);
diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/InstanceManager.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/InstanceManager.java
index 92cebf4de5..95679e9f42 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/InstanceManager.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/InstanceManager.java
@@ -109,7 +109,7 @@ public class InstanceManager implements ComponentInstance, InstanceStateListener
     /**
      * The content of the current instance.
      */
-    private List m_pojoObjects;
+    protected List m_pojoObjects;
 
     /**
      * The factory method used to create content objects.
@@ -559,7 +559,7 @@ public class InstanceManager implements ComponentInstance, InstanceStateListener
 
     /**
      * Creates a POJO objects.
-     * This method is not synchronized and does require any locks.
+     * This method is not synchronized and does not require any locks.
      * If a {@link InstanceManager#m_factoryMethod} is specified,
      * this method called this static method to creates the object.
      * Otherwise, the methods uses the regular constructor.
@@ -568,7 +568,7 @@ public class InstanceManager implements ComponentInstance, InstanceStateListener
      * @return the created object or <code>null</code> if an error
      * occurs during the creation.
      */
-    private Object createObject() {
+    protected Object createObject() {
         if (m_clazz == null) {
             load();
         }
diff --git a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
index 1b258b7994..c1821de861 100644
--- a/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
+++ b/ipojo/core/src/main/java/org/apache/felix/ipojo/handlers/dependency/Dependency.java
@@ -231,6 +231,7 @@ public class Dependency extends DependencyModel implements FieldInterceptor, Met
      * @param pojo : pojo instance on which calling the bind method.
      */
     protected void onObjectCreation(Object pojo) {
+                
         ServiceReference[] refs;
         synchronized (this) {
             if (!m_isStarted) { return; }
diff --git a/ipojo/examples/tutorial-maven/hello.client.annotation/src/main/java/ipojo/example/hello/client/HelloClient.java b/ipojo/examples/tutorial-maven/hello.client.annotation/src/main/java/ipojo/example/hello/client/HelloClient.java
index 45c7574fba..1ba3bac6d6 100644
--- a/ipojo/examples/tutorial-maven/hello.client.annotation/src/main/java/ipojo/example/hello/client/HelloClient.java
+++ b/ipojo/examples/tutorial-maven/hello.client.annotation/src/main/java/ipojo/example/hello/client/HelloClient.java
@@ -20,8 +20,6 @@ package ipojo.example.hello.client;
 
 import ipojo.example.hello.Hello;
 
-import java.util.Set;
-
 import org.apache.felix.ipojo.annotations.Component;
 import org.apache.felix.ipojo.annotations.Invalidate;
 import org.apache.felix.ipojo.annotations.Requires;
diff --git a/ipojo/examples/tutorial-maven/hello.impl.annotation/src/main/java/ipojo/example/hello/impl/HelloImpl.java b/ipojo/examples/tutorial-maven/hello.impl.annotation/src/main/java/ipojo/example/hello/impl/HelloImpl.java
index 8b37c2fb44..703ea604e0 100644
--- a/ipojo/examples/tutorial-maven/hello.impl.annotation/src/main/java/ipojo/example/hello/impl/HelloImpl.java
+++ b/ipojo/examples/tutorial-maven/hello.impl.annotation/src/main/java/ipojo/example/hello/impl/HelloImpl.java
@@ -22,6 +22,7 @@ import ipojo.example.hello.Hello;
 
 import org.apache.felix.ipojo.annotations.Component;
 import org.apache.felix.ipojo.annotations.Provides;
+import org.apache.felix.ipojo.annotations.ServiceProperty;
 
 /**
  * Component implementing the Hello service.
@@ -32,6 +33,14 @@ import org.apache.felix.ipojo.annotations.Provides;
 @Provides
 public class HelloImpl implements Hello {
     
+    
+    @ServiceProperty
+    public String boo = "boo";
+    
+    @ServiceProperty
+    public String bla = "bla";
+
+    
     /**
      * Returns an 'Hello' message.
      * @param name : name
diff --git a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/pom.xml b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/pom.xml
index e3e164fcff..db9c9698a0 100644
--- a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/pom.xml
+++ b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/pom.xml
@@ -7,6 +7,13 @@
   <version>1.5.0-SNAPSHOT</version>
   <name>BundleAsiPOJO</name>
 
+
+  <parent>
+    <artifactId>felix-parent</artifactId>
+    <groupId>org.apache.felix</groupId>
+    <version>1.2.0</version>
+  </parent>
+  
   <dependencies>
     <dependency>
       <groupId>junit</groupId>
@@ -17,7 +24,7 @@
     <dependency>
         <groupId>org.ops4j.pax.swissbox</groupId>
         <artifactId>pax-swissbox-tinybundles</artifactId>
-        <version>1.0.0</version>
+        <version>1.2.0</version>
     </dependency>
     <dependency>
       <groupId>org.apache.felix</groupId>
diff --git a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
index 155aec1202..e98efa92ef 100644
--- a/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
+++ b/ipojo/tests/bundleAsiPOJO/bundleAsiPOJO/src/main/java/org/apache/felix/ipojo/tinybundles/BundleAsiPOJO.java
@@ -1,24 +1,44 @@
 package org.apache.felix.ipojo.tinybundles;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.net.URL;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Properties;
 
 import org.apache.felix.ipojo.manipulator.Pojoization;
-import org.ops4j.pax.swissbox.tinybundles.core.BundleAs;
-import org.ops4j.pax.swissbox.tinybundles.core.targets.BundleAsFile;
+import org.ops4j.pax.swissbox.bnd.BndUtils;
+import org.ops4j.pax.swissbox.tinybundles.core.BuildableBundle;
+import org.ops4j.pax.swissbox.tinybundles.core.metadata.RawBuilder;
+import org.ops4j.pax.swissbox.tinybundles.core.metadata.UIDProvider;
 
 
-public class BundleAsiPOJO implements BundleAs<URL> {
+public class BundleAsiPOJO implements BuildableBundle {
+    
+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
 
     private File m_metadata;
     private File m_file;
 
 
-    public static BundleAs<URL> asiPOJOBundle(File file, File metadata) {
+    public static BuildableBundle asiPOJOBundle(File file, File metadata) {
         return (new BundleAsiPOJO(file, metadata));
     }
+    
+    public static BuildableBundle asiPOJOBundle(File metadata) {
+        try {
+            File file = File.createTempFile("tinybundle_ipojo", ".jar");
+            return asiPOJOBundle(file, metadata);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
 
     public BundleAsiPOJO (File file, File metadata) {
         m_metadata = metadata;
@@ -28,15 +48,10 @@ public class BundleAsiPOJO implements BundleAs<URL> {
         }
     }
 
-    public URL make(InputStream arg0) {
+    public InputStream pojoize(File in) {
         Pojoization pojoizator = new Pojoization();
         try {
-            File fout = File.createTempFile( "tinybundle_", ".jar" );
-            fout.deleteOnExit();
-            File out = new BundleAsFile(fout).make(arg0);
-            pojoizator.pojoization(out, m_file, m_metadata);
-
-
+            pojoizator.pojoization(in, m_file, m_metadata);
             List<String> list = (List<String>) pojoizator.getErrors();
             if (list != null  && ! list.isEmpty()) {
                 for (String s : list) {
@@ -51,7 +66,7 @@ public class BundleAsiPOJO implements BundleAs<URL> {
                     System.err.println("[WARNING]" + s);
                 }
             }
-            return m_file.toURL();
+            return new FileInputStream(m_file);
         } catch (Exception e) {
             List<String> list = (List<String>) pojoizator.getErrors();
             if (list != null) {
@@ -65,4 +80,42 @@ public class BundleAsiPOJO implements BundleAs<URL> {
 
     }
 
+    public InputStream build(Map<String, URL> resources, Map<String, String> headers) {
+        InputStream in = new RawBuilder().build(resources,
+                new HashMap<String, String>());
+        try {
+            Properties p = new Properties();
+            p.putAll(headers);
+            InputStream bnd =  BndUtils.createBundle(in, p, "BuildByTinyBundles"
+                    + UIDProvider.getUID());
+            File tmp = File.createTempFile("tinybundle_", ".jar");
+            tmp.deleteOnExit();
+            copy(bnd, new FileOutputStream(tmp));
+            return pojoize(tmp);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    
+    /**
+     * Copy bytes from an InputStream to an OutputStream.
+     * @param input the InputStream to read from
+     * @param output the OutputStream to write to
+     * @return the number of bytes copied
+     * @throws IOException In case of an I/O problem
+     */
+    public static int copy(
+            InputStream input,
+            OutputStream output)
+                throws IOException {
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
+        int count = 0;
+        int n = 0;
+        while (-1 != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
 }
diff --git a/ipojo/tests/bundleAsiPOJO/tests/pom.xml b/ipojo/tests/bundleAsiPOJO/tests/pom.xml
index dd456e07a4..1780d9fbd2 100644
--- a/ipojo/tests/bundleAsiPOJO/tests/pom.xml
+++ b/ipojo/tests/bundleAsiPOJO/tests/pom.xml
@@ -2,7 +2,8 @@
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
   <groupId>ipojo.tests</groupId>
-  <artifactId>org.apache.felix.ipojo.tinybundle.bundleAsiPOJO.test</artifactId>
+  <artifactId>org.apache.felix.ipojo.tinybundle.bundleAsiPOJO.test
+  </artifactId>
   <packaging>jar</packaging>
   <version>1.5.0-SNAPSHOT</version>
   <name>bundleAsiPOJO Tests</name>
@@ -28,88 +29,93 @@
           </execution>
         </executions>
       </plugin>
-
-      <!--  <plugin>
-        <groupId>org.ops4j.pax.exam</groupId>
-        <artifactId>maven-paxexam-plugin</artifactId>
-        <executions>
-          <execution>
-          <id>generate-paxexam-config</id>
-          <goals>
-            <goal>generate-paxexam-config</goal>
-          </goals>
-          </execution>
-        </executions>
-        <configuration>
-        <settings>
-          <platform>felix</platform>
-        </settings>
-        </configuration>
-      </plugin> -->
     </plugins>
   </build>
 
   <dependencies>
 
-  <!--
-    Pax Exam API:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam</artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <!--
-    During runtime Pax Exam will discover the OSGi container to use by
-    searching metadata available into classpath. Pax Exam comes with a
-    default container that uses [Pax Runner] for implementing the
-    container requirements:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam-container-default
-    </artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <!--
-    If your test code is based on JUnit you will have to have the Junit
-    support artifact:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam-junit</artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <dependency>
-    <groupId>junit</groupId>
-    <artifactId>junit</artifactId>
-    <version>4.5</version>
-    <type>jar</type>
-    <scope>test</scope>
-  </dependency>
+    <!-- Pax Exam API: -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <!--
+      During runtime Pax Exam will discover the OSGi container to use by
+      searching metadata available into classpath. Pax Exam comes with a
+      default container that uses [Pax Runner] for implementing the
+      container requirements:
+    -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam-container-default
+          </artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <!--
+      If your test code is based on JUnit you will have to have the Junit
+      support artifact:
+    -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam-junit</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.5</version>
+      <type>jar</type>
+      <scope>test</scope>
+    </dependency>
+
+    <!--  TinyBundle -->
+    <dependency>
+      <groupId>org.ops4j.pax.swissbox</groupId>
+      <artifactId>pax-swissbox-tinybundles</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.ops4j.base</groupId>
+      <artifactId>ops4j-base</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.ops4j.pax.swissbox</groupId>
+      <artifactId>pax-swissbox-bnd</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+
 
 
-  <!-- TinyBundle -->
-  <dependency>
-    <groupId>org.ops4j.pax.swissbox</groupId>
-    <artifactId>pax-swissbox-tinybundles</artifactId>
-    <version>1.0.0</version>
-  </dependency>
-  <dependency>
-    <groupId>org.apache.felix</groupId>
-    <artifactId>org.apache.felix.ipojo.tinybundles.bundleAsiPOJO</artifactId>
-    <version>${pom.version}</version>
-  </dependency>
-  <dependency>
-    <groupId>org.apache.felix</groupId>
-    <artifactId>org.apache.felix.ipojo.annotations</artifactId>
-    <version>${pom.version}</version>
-  </dependency>
-  <dependency>
-    <groupId>org.apache.felix</groupId>
-    <artifactId>org.apache.felix.ipojo</artifactId>
-    <version>${pom.version}</version>
-  </dependency>
+    <!-- TinyBundle -->
+    <dependency>
+      <groupId>org.ops4j.pax.swissbox</groupId>
+      <artifactId>pax-swissbox-tinybundles</artifactId>
+      <version>1.2.0</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo.tinybundles.bundleAsiPOJO
+      </artifactId>
+      <version>${pom.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo.annotations</artifactId>
+      <version>${pom.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo</artifactId>
+      <version>${pom.version}</version>
+    </dependency>
 
   </dependencies>
 
diff --git a/ipojo/tests/bundleAsiPOJO/tests/src/test/java/org/apache/felix/ipojo/tinybundles/tests/BundleCreationTest.java b/ipojo/tests/bundleAsiPOJO/tests/src/test/java/org/apache/felix/ipojo/tinybundles/tests/BundleCreationTest.java
index 2aaec705db..234b133256 100644
--- a/ipojo/tests/bundleAsiPOJO/tests/src/test/java/org/apache/felix/ipojo/tinybundles/tests/BundleCreationTest.java
+++ b/ipojo/tests/bundleAsiPOJO/tests/src/test/java/org/apache/felix/ipojo/tinybundles/tests/BundleCreationTest.java
@@ -9,7 +9,6 @@ import static org.ops4j.pax.exam.CoreOptions.equinox;
 import static org.ops4j.pax.exam.CoreOptions.knopflerfish;
 import static org.ops4j.pax.exam.MavenUtils.asInProject;
 
-import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.asURL;
 import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
 import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.with;
 
@@ -26,6 +25,7 @@ import org.ops4j.pax.exam.Inject;
 import org.ops4j.pax.exam.Option;
 import org.ops4j.pax.exam.junit.Configuration;
 import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.ops4j.pax.swissbox.tinybundles.core.TinyBundles;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.BundleException;
@@ -66,37 +66,26 @@ public class BundleCreationTest {
                     .artifactId("org.apache.felix.ipojo")
                     .version ( asInProject() )
             ),
+             provision(newBundle()
+                     .add(Hello.class)
+                     .set(Constants.BUNDLE_SYMBOLICNAME,"ServiceInterface")
+                     .set(Constants.EXPORT_PACKAGE,"org.apache.felix.ipojo.tinybundles.tests.service")
+                     .build(TinyBundles.withBnd())),
             provision(
-                            newBundle()
-                                .addClass( Hello.class )
-                                .prepare()
-                               .set(Constants.BUNDLE_SYMBOLICNAME,"ServiceInterface")
-                               .set(Constants.EXPORT_PACKAGE, "org.apache.felix.ipojo.tinybundles.tests.service")
-                                .build( asURL() ).toExternalForm()
-                        ),
+                    newBundle()
+                    .add(MyProvider.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME,"Provider")
+                    .set(Constants.IMPORT_PACKAGE, "org.apache.felix.ipojo.tinybundles.tests.service")
+                    .build( asiPOJOBundle(new File("provider.jar"), new File("provider.xml")))),
             provision(
                     newBundle()
-                    .addClass(MyProvider.class)
-                    .prepare(
-                        with()
-                            .set(Constants.BUNDLE_SYMBOLICNAME,"Provider")
-                            .set(Constants.IMPORT_PACKAGE, "org.apache.felix.ipojo.tinybundles.tests.service")
-                        )
-                        .build( asiPOJOBundle(new File("provider.jar"), new File("provider.xml"))  ).toExternalForm()
-                        ),
-                provision(newBundle()
-                        .addClass(Consumer.class)
-                        .prepare(
-                                with()
-                                        .set(Constants.BUNDLE_SYMBOLICNAME, "Consumer")
-                                        .set(Constants.IMPORT_PACKAGE,
-                                                "org.apache.felix.ipojo.tinybundles.tests.service"))
-                        .build(
-                                asiPOJOBundle(new File("cons.jar"),
-                                        new File("consumer.xml")))
-                        .toExternalForm())
-
-        );
+                    .add(Consumer.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME, "Consumer")
+                    .set(Constants.IMPORT_PACKAGE,
+                             "org.apache.felix.ipojo.tinybundles.tests.service")
+                    .build(
+                           asiPOJOBundle(new File("consumer.xml"))
+                    )));
     }
 
     @Test
diff --git a/ipojo/tests/core/handler/pom.xml b/ipojo/tests/core/handler/pom.xml
index 274147b9b9..08d962dd22 100644
--- a/ipojo/tests/core/handler/pom.xml
+++ b/ipojo/tests/core/handler/pom.xml
@@ -28,24 +28,6 @@
           </execution>
         </executions>
       </plugin>
-
-      <!--  <plugin>
-        <groupId>org.ops4j.pax.exam</groupId>
-        <artifactId>maven-paxexam-plugin</artifactId>
-        <executions>
-          <execution>
-          <id>generate-paxexam-config</id>
-          <goals>
-            <goal>generate-paxexam-config</goal>
-          </goals>
-          </execution>
-        </executions>
-        <configuration>
-        <settings>
-          <platform>felix</platform>
-        </settings>
-        </configuration>
-      </plugin> -->
     </plugins>
   </build>
 
@@ -56,53 +38,85 @@
       <version>${pom.version}</version>
     </dependency>
 
-  <!--
-    Pax Exam API:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam</artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <!--
-    During runtime Pax Exam will discover the OSGi container to use by
-    searching metadata available into classpath. Pax Exam comes with a
-    default container that uses [Pax Runner] for implementing the
-    container requirements:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam-container-default
-    </artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <!--
-    If your test code is based on JUnit you will have to have the Junit
-    support artifact:
-  -->
-  <dependency>
-    <groupId>org.ops4j.pax.exam</groupId>
-    <artifactId>pax-exam-junit</artifactId>
-    <version>1.1.0</version>
-  </dependency>
-  <dependency>
-    <groupId>junit</groupId>
-    <artifactId>junit</artifactId>
-    <version>4.5</version>
-    <type>jar</type>
-    <scope>test</scope>
-  </dependency>
-  <!--  Tinybundles -->
-  <dependency>
-    <groupId>org.ops4j.pax.swissbox</groupId>
-    <artifactId>pax-swissbox-tinybundles</artifactId>
-    <version>1.0.0</version>
-  </dependency>
+  <!-- Pax Exam API: -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <!--
+      During runtime Pax Exam will discover the OSGi container to use by
+      searching metadata available into classpath. Pax Exam comes with a
+      default container that uses [Pax Runner] for implementing the
+      container requirements:
+    -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam-container-default
+          </artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <!--
+      If your test code is based on JUnit you will have to have the Junit
+      support artifact:
+    -->
+    <dependency>
+      <groupId>org.ops4j.pax.exam</groupId>
+      <artifactId>pax-exam-junit</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.5</version>
+      <type>jar</type>
+      <scope>test</scope>
+    </dependency>
+
+    <!--  TinyBundle -->
+    <dependency>
+      <groupId>org.ops4j.pax.swissbox</groupId>
+      <artifactId>pax-swissbox-tinybundles</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.ops4j.base</groupId>
+      <artifactId>ops4j-base</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.ops4j.pax.swissbox</groupId>
+      <artifactId>pax-swissbox-bnd</artifactId>
+      <version>1.2.0</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- mockito -->
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-all</artifactId>
+      <version>1.7</version>
+      <scope>test</scope>
+    </dependency>
+  
   <dependency>
-    <groupId>org.apache.felix</groupId>
-    <artifactId>org.apache.felix.ipojo.tinybundles.bundleAsiPOJO</artifactId>
-    <version>${pom.version}</version>
-  </dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo.tinybundles.bundleAsiPOJO
+      </artifactId>
+      <version>1.5.0-SNAPSHOT</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.felix</groupId>
+      <artifactId>org.apache.felix.ipojo.test.helpers</artifactId>
+      <version>1.5.0-SNAPSHOT</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <repositories>
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/DummyHandlerTest.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/DummyHandlerTest.java
new file mode 100644
index 0000000000..bb5997379a
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/DummyHandlerTest.java
@@ -0,0 +1,237 @@
+package org.apache.felix.ipojo.tests.core;
+
+import static org.apache.felix.ipojo.tinybundles.BundleAsiPOJO.asiPOJOBundle;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+
+import junit.framework.Assert;
+
+import org.apache.felix.ipojo.ComponentInstance;
+import org.apache.felix.ipojo.ConfigurationException;
+import org.apache.felix.ipojo.Factory;
+import org.apache.felix.ipojo.MissingHandlerException;
+import org.apache.felix.ipojo.UnacceptableConfiguration;
+import org.apache.felix.ipojo.test.helpers.OSGiHelper;
+import org.apache.felix.ipojo.tests.core.component.DummyImpl;
+import org.apache.felix.ipojo.tests.core.handler.DummyHandler;
+import org.apache.felix.ipojo.tests.core.service.Dummy;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Inject;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.OptionUtils;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.ops4j.pax.exam.junit.JUnitOptions;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.service.useradmin.User;
+
+import aQute.lib.osgi.Constants;
+
+@RunWith(JUnit4TestRunner.class)
+public class DummyHandlerTest {
+
+    private static final String DUMMY_TEST_FACTORY = "dummy.test";
+
+    /*
+     * Number of mock object by test.
+     */
+    private static final int NB_MOCK = 10;
+
+  
+    @Inject
+    private BundleContext context;
+
+    private OSGiHelper osgi;
+
+    @Before
+    public void setUp() {
+        osgi = new OSGiHelper(context);
+    }
+
+    @After
+    public void tearDown() {
+        osgi.dispose();
+    }
+
+    @Configuration
+    public static Option[] configure() {
+        Option[] platform = options(CoreOptions.felix());
+
+        Option[] bundles = 
+            options(
+                    provision(
+                         newBundle()
+                             .add(DummyHandler.class) 
+                             .build(asiPOJOBundle(new File("src/test/resources/dummy-handler.xml")))
+                         ),
+                     provision(
+                         newBundle()
+                             .add(Dummy.class)
+                             .add(DummyImpl.class)
+                             .set(Constants.EXPORT_PACKAGE, "org.apache.felix.ipojo.handler.dummy.test")
+                             .build(asiPOJOBundle(new File("src/test/resources/dummy-component.xml")))
+                         ),
+                    provision(
+                        mavenBundle().groupId("org.apache.felix").artifactId("org.osgi.compendium").versionAsInProject()
+                            ));
+        Option[] r = OptionUtils.combine(platform, bundles);
+
+        return r;
+    }
+
+    /**
+     * iPOJO Bunles
+     * @return
+     */
+    @Configuration
+    public static Option[] configAdminBundle() {
+        return options(
+                mavenBundle().groupId("org.apache.felix").artifactId("org.apache.felix.ipojo").versionAsInProject(), 
+                mavenBundle().groupId("org.apache.felix").artifactId("org.apache.felix.ipojo.test.helpers").versionAsInProject());
+    }
+
+    /**
+     * Mockito bundle
+     * @return
+     */
+    @Configuration
+    public static Option[] mockitoBundle() {
+        return options(JUnitOptions.mockitoBundles());
+    }
+
+    /**
+     * Basic Test, in order to know if the instance is correctly create.
+     */
+    @Test
+    public void testDummyTestInstance() {
+        ComponentInstance instance = null;
+
+        // Get the factory
+        Factory factory = Tools.getValidFactory(osgi, DUMMY_TEST_FACTORY);
+        Assert.assertNotNull(factory);
+
+        // Create an instance
+        try {
+            instance = factory.createComponentInstance(null);
+        } catch (UnacceptableConfiguration e) {
+            new AssertionError(e);
+        } catch (MissingHandlerException e) {
+            new AssertionError(e);
+            e.printStackTrace();
+        } catch (ConfigurationException e) {
+            new AssertionError(e);
+        }
+
+        // Must be valid now
+        Assert.assertEquals(instance.getState(), ComponentInstance.VALID);
+
+        // Stop the instance
+        instance.stop();
+        Assert.assertEquals(instance.getState(), ComponentInstance.STOPPED);
+
+        // Start the instance
+        instance.start();
+        Assert.assertEquals(instance.getState(), ComponentInstance.VALID);
+    }
+
+    /**
+     * Test if the bind and unbind methods are called when the bind service are registered after the instance creation
+     */
+    @Test
+    public void testDummyTestBindAfterStart() {
+        ComponentInstance instance = null;
+
+        // Get the factory
+        Factory factory = Tools.getValidFactory(osgi, DUMMY_TEST_FACTORY);
+
+        // Create an instance
+        try {
+            instance = factory.createComponentInstance(null);
+        } catch (UnacceptableConfiguration e) {
+        } catch (MissingHandlerException e) {
+        } catch (ConfigurationException e) {
+        }
+
+        Map<User, ServiceRegistration> registrations = new HashMap<User, ServiceRegistration>();
+
+        for (int i = 0; i < NB_MOCK; i++) {
+            User service = mock(User.class);
+            ServiceRegistration sr = context.registerService(User.class.getName(), service, null);
+            registrations.put(service, sr);
+        }
+        
+        //verify that the bind method of the handler has been called
+        for (User user : registrations.keySet()) {
+                verify(user).getName();
+        }
+        
+        //verify that the unbind has been called
+        for (User user : registrations.keySet()) {
+            registrations.get(user).unregister();
+            verify(user).getType();
+        }
+        
+        //verify no more interaction
+        for (User user : registrations.keySet()) {
+                Mockito.verifyNoMoreInteractions(user);
+        }
+    }
+    
+
+    /**
+     * Test if the bind and unbind methods when the bind services are registered before the instance creation
+     */
+    @Test
+    public void testDummyTestBindBeforeStart() {
+        ComponentInstance instance = null;
+        
+        Map<User, ServiceRegistration> registrations = new HashMap<User, ServiceRegistration>();
+
+        for (int i = 0; i < NB_MOCK; i++) {
+            User service = mock(User.class);
+            ServiceRegistration sr = context.registerService(User.class.getName(), service, null);
+            registrations.put(service, sr);
+        }
+
+        // Get the factory
+        Factory factory = Tools.getValidFactory(osgi, DUMMY_TEST_FACTORY);
+
+        // Create an instance
+        try {
+            instance = factory.createComponentInstance(null);
+        } catch (UnacceptableConfiguration e) {
+        } catch (MissingHandlerException e) {
+        } catch (ConfigurationException e) {
+        }
+        
+        //verify that the bind method of the handler has been called
+        for (User user : registrations.keySet()) {
+                verify(user).getName();
+        }
+        
+        //verify that the unbind has been called
+        for (User user : registrations.keySet()) {
+            registrations.get(user).unregister();
+            verify(user).getType();
+        }
+        
+        //verify no more interaction
+        for (User user : registrations.keySet()) {
+                Mockito.verifyNoMoreInteractions(user);
+        }
+    }
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java
deleted file mode 100644
index 7755c085c9..0000000000
--- a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IPOJOHelper.java
+++ /dev/null
@@ -1,730 +0,0 @@
-/* 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.felix.ipojo.tests.core;
-
-import java.util.ArrayList;
-import java.util.Dictionary;
-import java.util.List;
-import java.util.Properties;
-
-import org.apache.felix.ipojo.ComponentInstance;
-import org.apache.felix.ipojo.Factory;
-import org.apache.felix.ipojo.Handler;
-import org.apache.felix.ipojo.HandlerFactory;
-import org.apache.felix.ipojo.ServiceContext;
-import org.apache.felix.ipojo.architecture.Architecture;
-import org.apache.felix.ipojo.metadata.Element;
-import org.apache.felix.ipojo.parser.ManifestMetadataParser;
-import org.apache.felix.ipojo.parser.ParseException;
-import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.framework.ServiceReference;
-import org.osgi.service.cm.ManagedServiceFactory;
-
-/**
- * iPOJO Helper.
- * This helper helps getting {@link Factory}, and managing
- * {@link ComponentInstance}.
- * @author <a href="mailto:dev@felix.apache.org">Felix Project Team</a>
- */
-public class IPOJOHelper {
-
-    /**
-     * The bundle context.
-     */
-    private BundleContext m_context;
-
-
-    /**
-     * List of instances.
-     */
-    private List<ComponentInstance> m_instances;
-
-    /**
-     * Creates a IPOJOHelper.
-     * @param tc the OSGi Test Case
-     */
-    public IPOJOHelper(BundleContext context) {
-        m_context = context;
-        m_instances = new ArrayList<ComponentInstance>();
-    }
-
-    /**
-     * Disposes created instances.
-     * @see org.apache.felix.ipojo.junit4osgi.Helper#dispose()
-     */
-    public void dispose() {
-        for (int i = 0; i < m_instances.size(); i++) {
-            ((ComponentInstance) m_instances.get(i)).dispose();
-        }
-        m_instances.clear();
-    }
-
-    /**
-     * Gets a created instance from the instance name.
-     * @param name the instance name.
-     * @return the created {@link ComponentInstance} or <code>null</code>
-     * if the instance was not created during the session.
-     */
-    public ComponentInstance getInstanceByName(String name) {
-        for (int i = 0; i < m_instances.size(); i++) {
-            if (((ComponentInstance) m_instances.get(i)).getInstanceName()
-                    .equals(name)) {
-                return (ComponentInstance) m_instances.get(i);
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Creates a new component instance with the given name (and empty
-     * configuration), from the factory specified in the given bundle.
-     * 
-     * @param bundle the bundle from which the component factory is defined.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified bundle.
-     * @param instanceName the name of the component instance to create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(Bundle bundle,
-            String factoryName, String instanceName) {
-
-        // Create the instance configuration
-        Properties configuration = new Properties();
-        configuration.put("instance.name", instanceName);
-
-        return createComponentInstance(bundle, factoryName, configuration);
-    }
-
-    /**
-     * Creates a new component instance with the given configuration, from the
-     * factory specified in the given bundle.
-     * 
-     * @param bundle the bundle from which the component factory is defined.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified bundle.
-     * @param configuration the configuration of the component instance to
-     *            create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(Bundle bundle,
-            String factoryName, Dictionary configuration) {
-
-        // Retrieve the component factory.
-        Factory fact = getFactory(bundle, factoryName);
-
-        if (fact == null) {
-            // Factory not found...
-            throw new IllegalArgumentException(
-                    "Cannot find the component factory (" + factoryName
-                            + ") in the specified bundle ("
-                            + bundle.getSymbolicName() + ").");
-        }
-
-        try {
-            return fact.createComponentInstance(configuration);
-        } catch (Exception e) {
-            throw new IllegalArgumentException(
-                    "Cannot create the component instance with the given configuration:"
-                            + e.getMessage());
-        }
-    }
-
-    /**
-     * Creates a new component instance with the given name and configuration,
-     * from the factory specified in the given bundle.
-     * 
-     * @param bundle the bundle from which the component factory is defined.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified bundle.
-     * @param instanceName the name of the component instance to create.
-     * @param configuration the configuration of the instance to create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(Bundle bundle,
-            String factoryName, String instanceName, Dictionary configuration) {
-
-        // Add the instance name to the configuration
-        configuration.put("instance.name", instanceName);
-
-        return createComponentInstance(bundle, factoryName, configuration);
-    }
-
-    /**
-     * Creates a new component instance with the given name (and an empty
-     * configuration), from the factory specified in the given service context.
-     * 
-     * @param serviceContext the service context in which the component factory
-     *            service is registered.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified service context.
-     * @param instanceName the name of the component instance to create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(
-            ServiceContext serviceContext, String factoryName,
-            String instanceName) {
-
-        // Create the instance configuration
-        Properties configuration = new Properties();
-        configuration.put("instance.name", instanceName);
-
-        return createComponentInstance(serviceContext, factoryName,
-                configuration);
-    }
-
-    /**
-     * Creates a new component instance with the given name and configuration,
-     * from the factory specified in the given service context.
-     * 
-     * @param serviceContext the service context in which the component factory
-     *            service is registered.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified service context.
-     * @param configuration the configuration of the instance to create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(
-            ServiceContext serviceContext, String factoryName,
-            Dictionary configuration) {
-
-        // Retrieve the component factory.
-        Factory fact = getFactory(serviceContext, factoryName);
-
-        if (fact == null) {
-            // Factory not found...
-            throw new IllegalArgumentException(
-                    "Cannot find the component factory (" + factoryName
-                            + ") in the specified service context.");
-        }
-
-        try {
-            return fact.createComponentInstance(configuration);
-        } catch (Exception e) {
-            throw new IllegalArgumentException(
-                    "Cannot create the component instance with the given configuration: "
-                            + e.getMessage());
-        }
-    }
-
-    /**
-     * Creates a new component instance with the given name and configuration,
-     * from the factory specified in the given service context.
-     * 
-     * @param serviceContext the service context in which the component factory
-     *            service is registered.
-     * @param factoryName the name of the component factory, defined in the
-     *            specified service context.
-     * @param instanceName the name of the component instance to create.
-     * @param configuration the configuration of the instance to create.
-     * @return the newly created component instance.
-     */
-    public static ComponentInstance createComponentInstance(
-            ServiceContext serviceContext, String factoryName,
-            String instanceName, Dictionary configuration) {
-
-        // Add the instance name to the configuration
-        configuration.put("instance.name", instanceName);
-
-        return createComponentInstance(serviceContext, factoryName,
-                configuration);
-    }
-
-    /**
-     * Creates a new component instance with the given name (and empty
-     * configuration), from the factory specified in the local bundle.
-     * 
-     * @param factoryName the name of the component factory, defined in the
-     *            local bundle.
-     * @param instanceName the name of the component instance to create.
-     * @return the newly created component instance.
-     */
-    public ComponentInstance createComponentInstance(String factoryName,
-            String instanceName) {
-        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
-                factoryName, instanceName);
-        m_instances.add(ci);
-        return ci;
-    }
-
-    /**
-     * Creates a new component instance with the given configuration, from the
-     * factory specified in the local bundle.
-     * 
-     * @param factoryName the name of the component factory, in the local
-     *            bundle.
-     * @param configuration the configuration of the component instance to
-     *            create.
-     * @return the newly created component instance.
-     */
-    public ComponentInstance createComponentInstance(String factoryName,
-            Dictionary configuration) {
-        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
-                factoryName, configuration);
-        m_instances.add(ci);
-        return ci;
-    }
-
-    /**
-     * Creates a new component instance with no configuration, from the factory
-     * specified in the local bundle.
-     * 
-     * @param factoryName the name of the component factory, in the local
-     *            bundle.
-     * @return the newly created component instance.
-     */
-    public ComponentInstance createComponentInstance(String factoryName) {
-        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
-                factoryName, (Dictionary) null);
-        m_instances.add(ci);
-        return ci;
-    }
-
-    /**
-     * Creates a new component instance with the given name and configuration,
-     * from the factory specified in the given bundle.
-     * 
-     * @param factoryName the name of the component factory, defined in the
-     *            specified bundle.
-     * @param instanceName the name of the component instance to create.
-     * @param configuration the configuration of the instance to create.
-     * @return the newly created component instance.
-     */
-    public ComponentInstance createComponentInstance(String factoryName,
-            String instanceName, Dictionary configuration) {
-        ComponentInstance ci = createComponentInstance(m_context.getBundle(),
-                factoryName, instanceName, configuration);
-        m_instances.add(ci);
-        return ci;
-    }
-
-    /**
-     * Returns the component factory with the given name in the local bundle.
-     * 
-     * @param factoryName the name of the factory to retrieve.
-     * @return the component factory with the given name in the local bundle, or
-     *         {@code null} if not found.
-     */
-    public Factory getFactory(String factoryName) {
-        return getFactory(m_context.getBundle(), factoryName);
-    }
-
-    /**
-     * Returns the handler factory with the given name in the local bundle.
-     * 
-     * @param factoryName the name of the handler factory to retrieve.
-     * @return the handler factory with the given name in the local bundle, or
-     *         {@code null} if not found.
-     */
-    public HandlerFactory getHandlerFactory(String factoryName) {
-        return getHandlerFactory(m_context.getBundle(), factoryName);
-    }
-
-    /**
-     * Returns the metadata description of the component defined in this bundle.
-     * 
-     * @param component the name of the locally defined component.
-     * @return the metadata description of the component with the given name,
-     *         defined in this given bundle, or {@code null} if not found.
-     */
-    public Element getMetadata(String component) {
-        return getMetadata(m_context.getBundle(), component);
-    }
-
-    /**
-     * Returns the component factory with the given name in the given bundle.
-     * 
-     * @param bundle the bundle from which the component factory is defined.
-     * @param factoryName the name of the defined factory.
-     * @return the component factory with the given name in the given bundle, or
-     *         {@code null} if not found.
-     */
-    public static Factory getFactory(Bundle bundle, String factoryName) {
-        ServiceReference[] refs;
-        try {
-            // Retrieves the component factories services in the bundle.
-            refs = bundle.getBundleContext().getServiceReferences(
-                    Factory.class.getName(),
-                    "(factory.name=" + factoryName + ")");
-            if (refs != null) {
-                return (Factory) bundle.getBundleContext().getService(refs[0]);
-            }
-
-            // Factory not found...
-            return null;
-
-        } catch (InvalidSyntaxException e) {
-            throw new IllegalArgumentException(
-                    "Cannot get the component factory services: "
-                            + e.getMessage());
-        }
-    }
-
-    /**
-     * Returns the component factory with the given name, registered in the
-     * given service context.
-     * 
-     * @param serviceContext the service context in which the factory service is
-     *            defined.
-     * @param factoryName the name of the factory.
-     * @return the component factory with the given name, registered in the
-     *         given service context.
-     */
-    public static Factory getFactory(ServiceContext serviceContext,
-            String factoryName) {
-        ServiceReference[] refs;
-        try {
-            // Retrieves the component factories services in the service
-            // context.
-            refs = serviceContext.getServiceReferences(Factory.class.getName(),
-                    "(factory.name=" + factoryName + ")");
-            if (refs != null) {
-                return (Factory) serviceContext.getService(refs[0]);
-            }
-            return null;
-
-        } catch (InvalidSyntaxException e) {
-            System.err.println("Cannot get the factory " + factoryName + " : "
-                    + e.getMessage());
-            return null;
-        }
-    }
-
-    /**
-     * Returns the handler factory with the given name in the given bundle.
-     * 
-     * @param bundle the bundle from which the handler factory is defined.
-     * @param factoryName the name of the handler factory to retrieve.
-     * @return the handler factory with the given name in the given bundle, or
-     *         {@code null} if not found.
-     */
-    public static HandlerFactory getHandlerFactory(Bundle bundle,
-            String factoryName) {
-        ServiceReference[] refs;
-        try {
-            // Retrieves the handler factories services in the bundle.
-            refs = bundle.getBundleContext().getServiceReferences(
-                    HandlerFactory.class.getName(),
-                    "(" + Handler.HANDLER_NAME_PROPERTY + "=" + factoryName
-                            + ")");
-            if (refs != null) {
-                return (HandlerFactory) bundle.getBundleContext().getService(
-                        refs[0]);
-            }
-
-            // Factory not found...
-            return null;
-        } catch (InvalidSyntaxException e) {
-            throw new IllegalArgumentException(
-                    "Cannot get the handler factory services: "
-                            + e.getMessage());
-        }
-    }
-
-    /**
-     * Returns the metadata description of the component with the given name,
-     * defined in the given bundle.
-     * 
-     * @param bundle the bundle from which the component is defined.
-     * @param component the name of the defined component.
-     * @return the metadata description of the component with the given name,
-     *         defined in the given bundle, or {@code null} if not found.
-     */
-    public static Element getMetadata(Bundle bundle, String component) {
-
-        // Retrieves the component description from the bundle's manifest.
-        String elem = (String) bundle.getHeaders().get("iPOJO-Components");
-        if (elem == null) {
-            throw new IllegalArgumentException(
-                    "Cannot find iPOJO-Components descriptor in the specified bundle ("
-                            + bundle.getSymbolicName()
-                            + "). Not an iPOJO bundle.");
-        }
-
-        // Parses the retrieved description and find the component with the
-        // given name.
-        try {
-            Element element = ManifestMetadataParser.parseHeaderMetadata(elem);
-            Element[] childs = element.getElements("component");
-            for (int i = 0; i < childs.length; i++) {
-                String name = childs[i].getAttribute("name");
-                String clazz = childs[i].getAttribute("classname");
-                if (name != null && name.equalsIgnoreCase(component)) {
-                    return childs[i];
-                }
-                if (clazz.equalsIgnoreCase(component)) {
-                    return childs[i];
-                }
-            }
-
-            // Component not found...
-            return null;
-
-        } catch (ParseException e) {
-            throw new IllegalStateException(
-                    "Cannot parse the components from specified bundle ("
-                            + bundle.getSymbolicName() + "): " + e.getMessage());
-        }
-    }
-
-    /**
-     * Returns the service object of a service registered in the specified
-     * service context, offering the specified interface and matching the given
-     * filter.
-     * 
-     * @param serviceContext the service context in which the service is
-     *            searched.
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service object provided by the specified bundle, offering the
-     *         specified interface and matching the given filter.
-     */
-    public static Object getServiceObject(ServiceContext serviceContext,
-            String itf, String filter) {
-        ServiceReference ref = getServiceReference(serviceContext, itf, filter);
-        if (ref != null) {
-            return serviceContext.getService(ref);
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Returns the service objects of the services registered in the specified
-     * service context, offering the specified interface and matching the given
-     * filter.
-     * 
-     * @param serviceContext the service context in which services are searched.
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service objects provided by the specified bundle, offering
-     *         the specified interface and matching the given filter.
-     */
-    public static Object[] getServiceObjects(ServiceContext serviceContext,
-            String itf, String filter) {
-        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
-                filter);
-        if (refs != null) {
-            Object[] list = new Object[refs.length];
-            for (int i = 0; i < refs.length; i++) {
-                list[i] = serviceContext.getService(refs[i]);
-            }
-            return list;
-        } else {
-            return new Object[0];
-        }
-    }
-
-    /**
-     * Returns the service reference of a service registered in the specified
-     * service context, offering the specified interface and matching the given
-     * filter.
-     * 
-     * @param serviceContext the service context in which services are searched.
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return a service reference registered in the specified service context,
-     *         offering the specified interface and matching the given filter.
-     *         If no service is found, {@code null} is returned.
-     */
-    public static ServiceReference getServiceReference(
-            ServiceContext serviceContext, String itf, String filter) {
-        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
-                filter);
-        if (refs.length != 0) {
-            return refs[0];
-        } else {
-            // No service found
-            return null;
-        }
-    }
-
-    /**
-     * Returns the service reference of the service registered in the specified
-     * service context, offering the specified interface and having the given
-     * persistent ID.
-     * 
-     * @param serviceContext the service context in which services are searched.
-     * @param itf the interface provided by the searched service.
-     * @param pid the persistent ID of the searched service.
-     * @return a service registered in the specified service context, offering
-     *         the specified interface and having the given persistent ID.
-     */
-    public static ServiceReference getServiceReferenceByPID(
-            ServiceContext serviceContext, String itf, String pid) {
-        String filter = "(" + "service.pid" + "=" + pid + ")";
-        ServiceReference[] refs = getServiceReferences(serviceContext, itf,
-                filter);
-        if (refs == null) {
-            return null;
-        } else if (refs.length == 1) {
-            return refs[0];
-        } else {
-            throw new IllegalStateException(
-                    "A service lookup by PID returned several providers ("
-                            + refs.length + ")" + " for " + itf + " with pid="
-                            + pid);
-        }
-    }
-
-    /**
-     * Returns the service reference of all the services registered in the
-     * specified service context, offering the specified interface and matching
-     * the given filter.
-     * 
-     * @param serviceContext the service context in which services are searched.
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return all the service references registered in the specified service
-     *         context, offering the specified interface and matching the given
-     *         filter. If no service matches, an empty array is returned.
-     */
-    public static ServiceReference[] getServiceReferences(
-            ServiceContext serviceContext, String itf, String filter) {
-        ServiceReference[] refs = null;
-        try {
-            // Get all the service references
-            refs = serviceContext.getServiceReferences(itf, filter);
-        } catch (InvalidSyntaxException e) {
-            throw new IllegalArgumentException(
-                    "Cannot get service references: " + e.getMessage());
-        }
-        if (refs == null) {
-            return new ServiceReference[0];
-        } else {
-            return refs;
-        }
-    }
-
-    /**
-     * Returns the service reference of a service registered in the specified
-     * service context, offering the specified interface and having the given
-     * name.
-     * 
-     * @param serviceContext the service context in which services are searched.
-     * @param itf the interface provided by the searched service.
-     * @param name the name of the searched service.
-     * @return a service registered in the specified service context, offering
-     *         the specified interface and having the given name.
-     */
-    public static ServiceReference getServiceReferenceByName(
-            ServiceContext serviceContext, String itf, String name) {
-        String filter = null;
-        if (itf.equals(Factory.class.getName())
-                || itf.equals(ManagedServiceFactory.class.getName())) {
-            filter = "(" + "factory.name" + "=" + name + ")";
-        } else if (itf.equals(Architecture.class.getName())) {
-            filter = "(" + "architecture.instance" + "=" + name + ")";
-        } else {
-            filter = "(" + "instance.name" + "=" + name + ")";
-        }
-        return getServiceReference(serviceContext, itf, filter);
-    }
-
-    /**
-     * Checks the availability of a service inside the given service context.
-     * @param sc the service context
-     * @param itf the service interface to found
-     * @return <code>true</code> if the service is available in the service
-     *         context, <code>false</code> otherwise.
-     */
-    public static boolean isServiceAvailable(ServiceContext sc, String itf) {
-        ServiceReference ref = getServiceReference(sc, itf, null);
-        return ref != null;
-    }
-
-    /**
-     * Checks the availability of a service inside the given service context.
-     * @param sc the service context
-     * @param itf the service interface to found
-     * @param name the service provider name
-     * @return <code>true</code> if the service is available in the service
-     *         context, <code>false</code> otherwise.
-     */
-    public static boolean isServiceAvailableByName(ServiceContext sc,
-            String itf, String name) {
-        ServiceReference ref = getServiceReferenceByName(sc, itf, name);
-        return ref != null;
-    }
-
-    /**
-     * Checks the availability of a service inside the given service context.
-     * @param sc the service context
-     * @param itf the service interface to found
-     * @param pid the pid of the service
-     * @return <code>true</code> if the service is available in the service
-     *         context, <code>false</code> otherwise.
-     */
-    public static boolean isServiceAvailableByPID(ServiceContext sc,
-            String itf, String pid) {
-        ServiceReference ref = getServiceReferenceByPID(sc, itf, pid);
-        return ref != null;
-    }
-
-    /**
-     * Returns the service reference of a service provided by the specified
-     * bundle, offering the specified interface and having the given name.
-     * 
-     * @param bundle the bundle from which the service is searched.
-     * @param itf the interface provided by the searched service.
-     * @param name the name of the searched service.
-     * @return a service provided by the specified bundle, offering the
-     *         specified interface and having the given name.
-     */
-    public static ServiceReference getServiceReferenceByName(Bundle bundle,
-            String itf, String name) {
-        String filter = null;
-        if (itf.equals(Factory.class.getName())
-                || itf.equals(ManagedServiceFactory.class.getName())) {
-            filter = "(" + "factory.name" + "=" + name + ")";
-        } else if (itf.equals(Architecture.class.getName())) {
-            filter = "(" + "architecture.instance" + "=" + name + ")";
-        } else {
-            filter = "(" + "instance.name" + "=" + name + ")";
-        }
-        return OSGiHelper.getServiceReference(bundle, itf, filter);
-    }
-
-    /**
-     * Returns the service reference of a service provided by the local bundle,
-     * offering the specified interface and having the given name.
-     * 
-     * @param itf the interface provided by the searched service.
-     * @param name the name of the searched service.
-     * @return a service provided by the specified bundle, offering the
-     *         specified interface and having the given name.
-     */
-    public ServiceReference getServiceReferenceByName(String itf, String name) {
-        return getServiceReferenceByName(m_context.getBundle(), itf, name);
-    }
-
-    /**
-     * Checks if the service is available.
-     * @param itf the service interface
-     * @param name the service provider name
-     * @return <code>true</code> if the service is available, <code>false</code>
-     *         otherwise.
-     */
-    public boolean isServiceAvailableByName(String itf, String name) {
-        ServiceReference ref = getServiceReferenceByName(itf, name);
-        return ref != null;
-    }
-
-}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java
index 6899ab3d21..72e2bd578d 100644
--- a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/IgnoreCaseHandlerSelectionTest.java
@@ -8,9 +8,7 @@ import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
 import static org.ops4j.pax.exam.CoreOptions.options;
 import static org.ops4j.pax.exam.CoreOptions.provision;
 import static org.ops4j.pax.exam.MavenUtils.asInProject;
-import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.asURL;
 import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
-import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.with;
 
 import java.io.File;
 
@@ -19,6 +17,8 @@ import org.apache.felix.ipojo.Factory;
 import org.apache.felix.ipojo.HandlerFactory;
 import org.apache.felix.ipojo.architecture.Architecture;
 import org.apache.felix.ipojo.architecture.HandlerDescription;
+import org.apache.felix.ipojo.test.helpers.IPOJOHelper;
+import org.apache.felix.ipojo.test.helpers.OSGiHelper;
 import org.apache.felix.ipojo.tests.core.component.MyComponent;
 import org.apache.felix.ipojo.tests.core.handler.EmptyHandler;
 import org.apache.felix.ipojo.tests.core.service.MyService;
@@ -31,6 +31,7 @@ import org.ops4j.pax.exam.Inject;
 import org.ops4j.pax.exam.Option;
 import org.ops4j.pax.exam.junit.Configuration;
 import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.ops4j.pax.swissbox.tinybundles.core.TinyBundles;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.Constants;
@@ -72,6 +73,7 @@ public class IgnoreCaseHandlerSelectionTest {
         File tmp = new File("target/tmp");
         tmp.mkdirs();
 
+        
         Option[] opt =  options(
                 felix(),
                 equinox(),
@@ -79,27 +81,26 @@ public class IgnoreCaseHandlerSelectionTest {
                 provision(
                         // Runtime.
                         mavenBundle().groupId("org.apache.felix").artifactId("org.apache.felix.ipojo").version(asInProject()),
-                        mavenBundle().groupId( "org.ops4j.pax.swissbox" ).artifactId( "pax-swissbox-tinybundles" ).version(asInProject())
+                        mavenBundle().groupId("org.apache.felix").artifactId("org.apache.felix.ipojo.test.helpers").versionAsInProject()
                         ),
                 provision(
                         newBundle()
-                            .addClass( MyService.class )
-                            .prepare()
-                           .set(Constants.BUNDLE_SYMBOLICNAME,"ServiceInterface")
-                           .set(Constants.EXPORT_PACKAGE, "org.apache.felix.ipojo.tests.core.service")
-                            .build( asURL() ).toExternalForm()
+                            .add( MyService.class )
+                            .set( Constants.BUNDLE_SYMBOLICNAME, "ServiceInterface" )
+                            .set( Constants.EXPORT_PACKAGE, "org.apache.felix.ipojo.tests.core.service" )
+                            .build( TinyBundles.withBnd() ) 
                     ),
                provision(
                        // Components and the handler
                         newBundle()
-                            .addClass(MyComponent.class) // Component Implementation
-                            .addClass(EmptyHandler.class) // Handler.
-                            .prepare(
-                                    with()
-                                        .set(Constants.BUNDLE_SYMBOLICNAME,"IgnoreCase")
-                                        .set(Constants.IMPORT_PACKAGE, "org.apache.felix.ipojo.tests.core.service, org.apache.felix.ipojo, org.apache.felix.ipojo.metadata")
-                                    )
-                            .build( asiPOJOBundle(new File(tmp, "ignorecase.jar"), new File("ignorecase.xml"))).toExternalForm()));
+                            .add(MyComponent.class) // Component Implementation
+                            .add(EmptyHandler.class) // Handler.
+                            .set(Constants.BUNDLE_SYMBOLICNAME,"IgnoreCase")
+                            .set(Constants.IMPORT_PACKAGE, 
+                                    "org.apache.felix.ipojo.tests.core.service, " +
+                                    "org.apache.felix.ipojo, " +
+                                    "org.apache.felix.ipojo.metadata")
+                            .build(asiPOJOBundle(new File(tmp, "ignorecase.jar"), new File("src/test/resources/ignorecase.xml")))));
         return opt;
     }
 
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java
deleted file mode 100644
index bf880f1e15..0000000000
--- a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/OSGiHelper.java
+++ /dev/null
@@ -1,456 +0,0 @@
-package org.apache.felix.ipojo.tests.core;
-
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.BundleException;
-import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.framework.ServiceReference;
-import org.osgi.service.packageadmin.PackageAdmin;
-
-import static org.junit.Assert.fail;
-
-
-public class OSGiHelper {
-    
-    /**
-     * The bundle context.
-     */
-    private BundleContext context;
-    
-    /**
-     * List of get references.
-     */
-    private List<ServiceReference> m_references = new ArrayList<ServiceReference>();
-    
-    public OSGiHelper(BundleContext context) {
-        this.context = context;
-    }
-    
-    public void dispose() {
-        // Unget services
-        for (int i = 0; i < m_references.size(); i++) {
-            context.ungetService((ServiceReference) m_references.get(i));
-        }
-        m_references.clear();
-    }
-    
-    /**
-     * Gets the Bundle Context.
-     * @return the bundle context.
-     */
-    public BundleContext getContext() {
-        return context;
-    }
-    
-    /**
-     * Returns the service object of a service provided by the specified bundle,
-     * offering the specified interface and matching the given filter.
-     * 
-     * @param bundle the bundle from which the service is searched.
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service object provided by the specified bundle, offering the
-     *         specified interface and matching the given filter.
-     */
-    public static Object getServiceObject(Bundle bundle, String itf,
-            String filter) {
-        ServiceReference ref = getServiceReference(bundle, itf, filter);
-        if (ref != null) {
-            return bundle.getBundleContext().getService(ref);
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Returns the service objects of the services provided by the specified
-     * bundle, offering the specified interface and matching the given filter.
-     * 
-     * @param bundle the bundle from which services are searched.
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service objects provided by the specified bundle, offering
-     *         the specified interface and matching the given filter.
-     */
-    public static Object[] getServiceObjects(Bundle bundle, String itf,
-            String filter) {
-        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
-        if (refs != null) {
-            Object[] list = new Object[refs.length];
-            for (int i = 0; i < refs.length; i++) {
-                list[i] = bundle.getBundleContext().getService(refs[i]);
-            }
-            return list;
-        } else {
-            return new Object[0];
-        }
-    }
-
-    /**
-     * Returns the service reference of a service provided by the specified
-     * bundle, offering the specified interface and matching the given filter.
-     * 
-     * @param bundle the bundle from which the service is searched.
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return a service reference provided by the specified bundle, offering
-     *         the specified interface and matching the given filter. If no
-     *         service is found, {@code null} is returned.
-     */
-    public static ServiceReference getServiceReference(Bundle bundle,
-            String itf, String filter) {
-        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
-        if (refs.length != 0) {
-            return refs[0];
-        } else {
-            // No service found
-            return null;
-        }
-    }
-
-    /**
-     * Checks if the service is available.
-     * @param itf the service interface
-     * @return <code>true</code> if the service is available, <code>false</code>
-     *         otherwise.
-     */
-    public boolean isServiceAvailable(String itf) {
-        ServiceReference ref = getServiceReference(itf, null);
-        return ref != null;
-    }
-
-    /**
-     * Checks if the service is available.
-     * @param itf the service interface
-     * @param pid the service pid
-     * @return <code>true</code> if the service is available, <code>false</code>
-     *         otherwise.
-     */
-    public boolean isServiceAvailableByPID(String itf, String pid) {
-        ServiceReference ref = getServiceReferenceByPID(itf, pid);
-        return ref != null;
-    }
-
-    /**
-     * Returns the service reference of the service provided by the specified
-     * bundle, offering the specified interface and having the given persistent
-     * ID.
-     * 
-     * @param bundle the bundle from which the service is searched.
-     * @param itf the interface provided by the searched service.
-     * @param pid the persistent ID of the searched service.
-     * @return a service provided by the specified bundle, offering the
-     *         specified interface and having the given persistent ID.
-     */
-    public static ServiceReference getServiceReferenceByPID(Bundle bundle,
-            String itf, String pid) {
-        String filter = "(" + "service.pid" + "=" + pid + ")";
-        ServiceReference[] refs = getServiceReferences(bundle, itf, filter);
-        if (refs == null) {
-            return null;
-        } else if (refs.length == 1) {
-            return refs[0];
-        } else {
-            throw new IllegalStateException(
-                    "A service lookup by PID returned several providers ("
-                            + refs.length + ")" + " for " + itf + " with pid="
-                            + pid);
-        }
-    }
-
-    /**
-     * Returns the service reference of all the services provided in the
-     * specified bundle, offering the specified interface and matching the given
-     * filter.
-     * 
-     * @param bundle the bundle from which services are searched.
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return all the service references provided in the specified bundle,
-     *         offering the specified interface and matching the given filter.
-     *         If no service matches, an empty array is returned.
-     */
-    public static ServiceReference[] getServiceReferences(Bundle bundle,
-            String itf, String filter) {
-        ServiceReference[] refs = null;
-        try {
-            // Get all the service references
-            refs = bundle.getBundleContext().getServiceReferences(itf, filter);
-        } catch (InvalidSyntaxException e) {
-            throw new IllegalArgumentException(
-                    "Cannot get service references: " + e.getMessage());
-        }
-        if (refs == null) {
-            return new ServiceReference[0];
-        } else {
-            return refs;
-        }
-    }
-
-    /**
-     * Returns the service object of a service provided by the local bundle,
-     * offering the specified interface and matching the given filter.
-     * 
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service object provided by the local bundle, offering the
-     *         specified interface and matching the given filter.
-     */
-    public Object getServiceObject(String itf, String filter) {
-        ServiceReference ref = getServiceReference(itf, filter);
-        if (ref != null) {
-            m_references.add(ref);
-            return context.getService(ref);
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Returns the service object associated with this service reference.
-     * 
-     * @param ref service reference
-     * @return the service object.
-     */
-    public Object getServiceObject(ServiceReference ref) {
-        if (ref != null) {
-            m_references.add(ref);
-            return context.getService(ref);
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Returns the service objects of the services provided by the local bundle,
-     * offering the specified interface and matching the given filter.
-     * 
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return the service objects provided by the local bundle, offering the
-     *         specified interface and matching the given filter.
-     */
-    public Object[] getServiceObjects(String itf, String filter) {
-        ServiceReference[] refs = getServiceReferences(itf, filter);
-        if (refs != null) {
-            Object[] list = new Object[refs.length];
-            for (int i = 0; i < refs.length; i++) {
-                m_references.add(refs[i]);
-                list[i] = context.getService(refs[i]);
-            }
-            return list;
-        } else {
-            return new Object[0];
-        }
-    }
-
-    /**
-     * Returns the service reference of a service provided by the local bundle,
-     * offering the specified interface and matching the given filter.
-     * 
-     * @param itf the interface provided by the searched service.
-     * @param filter an additional filter (can be {@code null}).
-     * @return a service reference provided by the local bundle, offering the
-     *         specified interface and matching the given filter. If no service
-     *         is found, {@code null} is returned.
-     */
-    public ServiceReference getServiceReference(String itf, String filter) {
-        return getServiceReference(context.getBundle(), itf, filter);
-    }
-
-    /**
-     * Returns the service reference of a service provided offering the
-     * specified interface.
-     * 
-     * @param itf the interface provided by the searched service.
-     * @return a service reference provided by the local bundle, offering the
-     *         specified interface and matching the given filter. If no service
-     *         is found, {@code null} is returned.
-     */
-    public ServiceReference getServiceReference(String itf) {
-        return getServiceReference(context.getBundle(), itf, null);
-    }
-
-    /**
-     * Returns the service reference of the service provided by the local
-     * bundle, offering the specified interface and having the given persistent
-     * ID.
-     * 
-     * @param itf the interface provided by the searched service.
-     * @param pid the persistent ID of the searched service.
-     * @return a service provided by the local bundle, offering the specified
-     *         interface and having the given persistent ID.
-     */
-    public ServiceReference getServiceReferenceByPID(String itf, String pid) {
-        return getServiceReferenceByPID(context.getBundle(), itf, pid);
-    }
-
-    /**
-     * Returns the service reference of all the services provided in the local
-     * bundle, offering the specified interface and matching the given filter.
-     * 
-     * @param itf the interface provided by the searched services.
-     * @param filter an additional filter (can be {@code null}).
-     * @return all the service references provided in the local bundle, offering
-     *         the specified interface and matching the given filter. If no
-     *         service matches, an empty array is returned.
-     */
-    public ServiceReference[] getServiceReferences(String itf, String filter) {
-        return getServiceReferences(context.getBundle(), itf, filter);
-    }
-    
-    /**
-     * Gets the package admin exposed by the framework.
-     * Fails if the package admin is not available. 
-     * @return the package admin service.
-     */
-    public PackageAdmin getPackageAdmin() {
-        PackageAdmin pa = (PackageAdmin) getServiceObject(PackageAdmin.class.getName(), null);
-        if (pa == null) {
-            fail("No package admin available");
-        }
-        return pa;
-    }
-    
-    /**
-     * Refresh the packages.
-     * Fails if the package admin service is not available.
-     */
-    public void refresh() {
-        getPackageAdmin().refreshPackages(null);
-    }
-    
-    /**
-     * Waits for a service. Fails on timeout.
-     * If timeout is set to 0, it sets the timeout to 10s.
-     * @param itf the service interface
-     * @param filter  the filter
-     * @param timeout the timeout
-     */
-    public void waitForService(String itf, String filter, long timeout) {
-        if (timeout == 0) {
-            timeout = 10000; // Default 10 secondes.
-        }
-        ServiceReference[] refs = getServiceReferences(itf, filter);
-        long begin = System.currentTimeMillis();
-        if (refs.length != 0) {
-            return;
-        } else {
-            while(refs.length == 0) {
-                try {
-                    Thread.sleep(5);
-                } catch (InterruptedException e) {
-                    // Interrupted
-                }
-                long now = System.currentTimeMillis();
-                
-                if ((now - begin) > timeout) {
-                    fail("Timeout ... no services matching with the request after " + timeout + "ms");
-                }
-                refs = getServiceReferences(itf, filter);
-            }
-        }
-    }
-    
-    
-    /**
-     * Installs a bundle.
-     * Fails if the bundle cannot be installed.
-     * Be aware that you have to uninstall the bundle yourself.
-     * @param url bundle url
-     * @return the installed bundle
-     */
-    public Bundle installBundle(String url) {
-        try {
-            return context.installBundle(url);
-        } catch (BundleException e) {
-            fail("Cannot install the bundle " + url + " : " + e.getMessage());
-        }
-        return null; // Can not happen
-    }
-    
-    /**
-     * Installs a bundle.
-     * Fails if the bundle cannot be installed.
-     * Be aware that you have to uninstall the bundle yourself.
-     * @param url bundle url
-     * @param stream input stream containing the bundle
-     * @return the installed bundle
-     */
-    public Bundle installBundle(String url, InputStream stream) {
-        try {
-            return context.installBundle(url, stream);
-        } catch (BundleException e) {
-            fail("Cannot install the bundle " + url + " : " + e.getMessage());
-        }
-        return null; // Can not happen
-    }
-    
-    /**
-     * Installs and starts a bundle.
-     * Fails if the bundle cannot be installed or an error occurs
-     * during startup. Be aware that you have to uninstall the bundle
-     * yourself.
-     * @param url the bundle url
-     * @return the Bundle object.
-     */
-    public Bundle installAndStart(String url) {
-        Bundle bundle = installBundle(url);
-        try {
-            bundle.start();
-        } catch (BundleException e) {
-           fail("Cannot start the bundle " + url + " : " + e.getMessage());
-        }
-        return bundle;
-    }
-    
-    /**
-     * Installs and starts a bundle.
-     * Fails if the bundle cannot be installed or an error occurs
-     * during startup. Be aware that you have to uninstall the bundle
-     * yourself.
-     * @param url the bundle url
-     * @param stream input stream containing the bundle
-     * @return the Bundle object.
-     */
-    public Bundle installAndStart(String url, InputStream stream) {
-        Bundle bundle = installBundle(url, stream);
-        try {
-            bundle.start();
-        } catch (BundleException e) {
-           fail("Cannot start the bundle " + url + " : " + e.getMessage());
-        }
-        return bundle;
-    }
-    
-    /**
-     * Get the bundle by its id.
-     * @param bundleId the bundle id.
-     * @return the bundle with the given id.
-     */
-    public Bundle getBundle(long bundleId) {
-        return context.getBundle(bundleId);
-    }
-    
-    /**
-     * Gets a bundle by its symbolic name.
-     * Fails if no bundle matches.
-     * @param name the symbolic name of the bundle
-     * @return the bundle object.
-     */
-    public Bundle getBundle(String name) {
-        Bundle[] bundles = context.getBundles();
-        for (int i = 0; i < bundles.length; i++) {
-            if (name.equals(bundles[i].getSymbolicName())) {
-                return bundles[i];
-            }
-        }
-        fail("No bundles with the given symbolic name " + name);
-        return null; // should not happen
-    }
-
-}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/Tools.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/Tools.java
new file mode 100644
index 0000000000..65a3ef1eda
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/Tools.java
@@ -0,0 +1,25 @@
+package org.apache.felix.ipojo.tests.core;
+
+import org.apache.felix.ipojo.Factory;
+import org.apache.felix.ipojo.test.helpers.OSGiHelper;
+import org.osgi.framework.ServiceReference;
+
+public class Tools {
+
+
+    /**
+     * Get the Factory linked to the given pid
+     * @param osgi
+     * @param name
+     * @return The factory
+     */
+    public static Factory getValidFactory(final OSGiHelper osgi, final String name) {
+        // Get The Factory ServiceReference
+        ServiceReference facref = osgi.getServiceReference(Factory.class.getName(), "(&(factory.state=1)(factory.name=" + name + "))");
+        // Get the factory
+        Factory factory = (Factory) osgi.getServiceObject(facref);
+
+        return factory;
+    }
+
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/DummyImpl.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/DummyImpl.java
new file mode 100644
index 0000000000..afcaff5f6d
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/component/DummyImpl.java
@@ -0,0 +1,16 @@
+package org.apache.felix.ipojo.tests.core.component;
+
+import org.apache.felix.ipojo.tests.core.service.Dummy;
+
+
+/**
+ * Just a Dummy test 
+ */
+public class DummyImpl implements Dummy{
+
+    private void start() {
+    }
+
+    private void stop() {
+    }    
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/DummyHandler.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/DummyHandler.java
new file mode 100644
index 0000000000..fbb886ca75
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/handler/DummyHandler.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2009 OW2 Chameleon Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package org.apache.felix.ipojo.tests.core.handler;
+
+import java.util.Dictionary;
+
+import org.apache.felix.ipojo.ConfigurationException;
+import org.apache.felix.ipojo.PrimitiveHandler;
+import org.apache.felix.ipojo.architecture.ComponentTypeDescription;
+import org.apache.felix.ipojo.metadata.Element;
+import org.osgi.service.useradmin.User;
+
+
+public class DummyHandler extends PrimitiveHandler {
+
+    public DummyHandler() {
+    }
+
+    /*------------------------------------------------------------*
+     *      Handler Specific Methods                              *
+     *------------------------------------------------------------*/
+
+    @Override
+    public void initializeComponentFactory(ComponentTypeDescription typeDesc, Element metadata) throws ConfigurationException {
+        // Initialize
+        super.initializeComponentFactory(typeDesc, metadata);
+    }
+
+    @Override
+    public void configure(Element metadata, Dictionary configuration) throws ConfigurationException {
+    }
+
+
+    private void bindUser(User user) {
+        // in order to test
+        user.getName();
+    }
+
+    private void unBindUser(User user) {
+        // in order to test
+        user.getType();
+    }
+
+    @Override
+    public void start() {
+    }
+
+    @Override
+    public void stop() {
+    }
+}
diff --git a/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/Dummy.java b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/Dummy.java
new file mode 100644
index 0000000000..7c317d7bfe
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/java/org/apache/felix/ipojo/tests/core/service/Dummy.java
@@ -0,0 +1,5 @@
+package org.apache.felix.ipojo.tests.core.service;
+
+public interface Dummy {
+}
+
diff --git a/ipojo/tests/core/handler/src/test/resources/dummy-component.xml b/ipojo/tests/core/handler/src/test/resources/dummy-component.xml
new file mode 100644
index 0000000000..b92629347d
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/resources/dummy-component.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<iPOJO xmlns:dummy="org.apache.felix.ipojo.test.dummy.handler.dummyhandler">
+  <component className="org.apache.felix.ipojo.tests.core.component.DummyImpl" name="dummy.test">
+    <callback transition="validate" method="start" />
+    <callback transition="invalidate" method="stop" />
+
+    <dummy:dummy/>
+  </component>
+</iPOJO>
diff --git a/ipojo/tests/core/handler/src/test/resources/dummy-handler.xml b/ipojo/tests/core/handler/src/test/resources/dummy-handler.xml
new file mode 100644
index 0000000000..19cc660973
--- /dev/null
+++ b/ipojo/tests/core/handler/src/test/resources/dummy-handler.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+  <!--
+    <iPOJO xmlns:wbp="org.apache.felix.ipojo.whiteboard"
+    xmlns:jmx="org.apache.felix.ipojo.handlers.jmx">
+  -->
+<iPOJO>
+  <!-- Declare the handler -->
+  <handler classname="org.apache.felix.ipojo.tests.core.handler.DummyHandler" name="dummy"
+    namespace="org.apache.felix.ipojo.test.dummy.handler.dummyhandler">
+
+
+    <requires optional="true" aggregate="true">
+      <callback type="bind" method="bindUser" />
+      <callback type="unbind" method="unBindUser" />
+    </requires>
+  </handler>
+</iPOJO>
diff --git a/ipojo/tests/core/handler/ignorecase.xml b/ipojo/tests/core/handler/src/test/resources/ignorecase.xml
similarity index 100%
rename from ipojo/tests/core/handler/ignorecase.xml
rename to ipojo/tests/core/handler/src/test/resources/ignorecase.xml
