diff --git a/converter/persister/src/main/java/org/apache/felix/persister/impl/StandardPersister.java b/converter/persister/src/main/java/org/apache/felix/persister/impl/StandardPersister.java
index 84fcfc6564..336cc89b87 100644
--- a/converter/persister/src/main/java/org/apache/felix/persister/impl/StandardPersister.java
+++ b/converter/persister/src/main/java/org/apache/felix/persister/impl/StandardPersister.java
@@ -40,7 +40,7 @@ public class StandardPersister<D> implements Persister<D> {
     @Override
     public void serialize(OutputStream out, D entity) {
         try {
-            serializer.serialize(entity).with(getConverter()).to( out );
+            serializer.serialize(entity).convertWith(getConverter()).to( out );
         } catch ( IOException e ) {
             // TODO: Handle this
             e.printStackTrace();
@@ -51,7 +51,7 @@ public class StandardPersister<D> implements Persister<D> {
     public D deserialize(InputStream in) {
       return (D)serializer
               .deserialize(dataType)
-              .with(getConverter())
+              .convertWith(getConverter())
               .from(in);
     }
 
diff --git a/converter/schematizer/src/test/java/org/apache/felix/serializer/impl/json/JsonDeserializationTest.java b/converter/schematizer/src/test/java/org/apache/felix/serializer/impl/json/JsonDeserializationTest.java
index 814c6e784f..ec91e688a3 100644
--- a/converter/schematizer/src/test/java/org/apache/felix/serializer/impl/json/JsonDeserializationTest.java
+++ b/converter/schematizer/src/test/java/org/apache/felix/serializer/impl/json/JsonDeserializationTest.java
@@ -55,10 +55,10 @@ public class JsonDeserializationTest {
         Converter c = new SchematizerImpl()
                 .schematize("MyDTO", new TypeReference<MyDTO>(){})
                 .converterFor("MyDTO");
-        String serialized = new JsonSerializerImpl().serialize(dto).with(c).toString();
+        String serialized = new JsonSerializerImpl().serialize(dto).convertWith(c).toString();
         MyDTO result = new JsonSerializerImpl()
                 .deserialize(MyDTO.class)
-                .with(c)
+                .convertWith(c)
                 .from(serialized);
 
         assertEquals(dto.ping, result.ping);
@@ -88,7 +88,7 @@ public class JsonDeserializationTest {
                 .converterFor("MyDTO");
         MyDTO2<MyEmbeddedDTO2<String>> result = new JsonSerializerImpl()
                 .deserialize(new TypeReference<MyDTO2<MyEmbeddedDTO2<String>>>(){})
-                .with(c)
+                .convertWith(c)
                 .from(serialized);
 
         assertEquals(dto.ping, result.ping);
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/Activator.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/Activator.java
index 881df75b29..68e4dd7001 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/Activator.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/Activator.java
@@ -20,10 +20,13 @@ import java.util.Dictionary;
 import java.util.Hashtable;
 
 import org.apache.felix.serializer.impl.json.JsonSerializerImpl;
+import org.apache.felix.serializer.impl.json.JsonWriterFactory;
 import org.apache.felix.serializer.impl.yaml.YamlSerializerImpl;
+import org.apache.felix.serializer.impl.yaml.YamlWriterFactory;
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
 import org.osgi.service.serializer.Serializer;
+import org.osgi.service.serializer.WriterFactory;
 
 public class Activator implements BundleActivator {
     @Override
@@ -32,13 +35,27 @@ public class Activator implements BundleActivator {
         jsonProps.put("mimetype", new String[] {
                 "application/json", "application/x-javascript", "text/javascript",
                 "text/x-javascript", "text/x-json" });
-        context.registerService(Serializer.class, new JsonSerializerImpl(), jsonProps);
+        context.registerService(
+                new String[]{Serializer.class.getName(), Serializer.JsonSerializer.class.getName()}, 
+                new JsonSerializerImpl(), 
+                jsonProps);
+        context.registerService(
+                new String[]{WriterFactory.class.getName(), WriterFactory.JsonWriterFactory.class.getName()}, 
+                new JsonWriterFactory(), 
+                jsonProps);
 
         Dictionary<String, Object> yamlProps = new Hashtable<>();
         yamlProps.put("mimetype", new String[] {
                 "text/yaml", "text/x-yaml", "application/yaml",
                 "application/x-yaml" });
-        context.registerService(Serializer.class, new YamlSerializerImpl(), yamlProps);
+        context.registerService(
+                new String[]{Serializer.class.getName(), Serializer.YamlSerializer.class.getName()}, 
+                new YamlSerializerImpl(), 
+                yamlProps);
+        context.registerService(
+                new String[]{WriterFactory.class.getName(), WriterFactory.YamlWriterFactory.class.getName()}, 
+                new YamlWriterFactory(), 
+                yamlProps);
     }
 
     @Override
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java
new file mode 100644
index 0000000000..74801ed5ec
--- /dev/null
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DebugJsonWriter.java
@@ -0,0 +1,135 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.felix.serializer.impl.json;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.Map.Entry;
+
+import org.osgi.dto.DTO;
+import org.osgi.service.serializer.Writer;
+import org.osgi.util.converter.Converter;
+
+public class DebugJsonWriter implements Writer {
+
+    private final Converter converter;
+    private final boolean ignoreNull = false;
+    private final int indentation = 2;
+
+    public DebugJsonWriter(Converter c) {
+        converter = c;
+    }
+
+    @Override
+    public String write(Object obj) {
+        return encode(obj, 0).trim();
+    }
+
+    @SuppressWarnings("rawtypes")
+    private String encode(Object obj, int level) {
+        if (obj == null) {
+            return ignoreNull ? "" : "null";
+        }
+
+        if (obj instanceof String) {
+            return "\"" + (String)obj + "\"";
+        } else if (obj instanceof Map) {
+            return encodeMap((Map) obj, level);
+        } else if (obj instanceof Collection) {
+            return encodeCollection((Collection) obj, level);
+        } else if (obj instanceof DTO) {
+            return encodeMap(converter.convert(obj).sourceAsDTO().to(Map.class), level);
+        } else if (obj.getClass().isArray()) {
+            return encodeCollection(asCollection(obj), level);
+        } else if (obj instanceof Number) {
+            return obj.toString();
+        } else if (obj instanceof Boolean) {
+            return obj.toString();
+        }
+
+        return "\"" + converter.convert(obj).to(String.class) + "\"";
+    }
+
+    private Collection<?> asCollection(Object arr) {
+        // Arrays.asList() doesn't work for primitive arrays
+        int len = Array.getLength(arr);
+        List<Object> l = new ArrayList<>(len);
+        for (int i=0; i<len; i++) {
+            l.add(Array.get(arr, i));
+        }
+        return l;
+    }
+
+    private String encodeCollection(Collection<?> collection, int level) {
+        level++;
+        StringBuilder sb = new StringBuilder("[\n");
+
+        boolean first = true;
+        for (Object o : collection) {
+            if (first)
+                first = false;
+            else
+                sb.append(",\n");
+
+            sb.append( getIdentPrefix(level));
+            sb.append(encode(o, level));
+        }
+
+        sb.append("\n");
+        sb.append( getIdentPrefix(--level));
+        sb.append("]");
+        return sb.toString();
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    private String encodeMap(Map m, int level) {
+        level++;
+        Map orderedMap = new TreeMap<>(m);
+        StringBuilder sb = new StringBuilder("{\n");
+        for (Entry entry : (Set<Entry>) orderedMap.entrySet()) {
+            if (entry.getKey() == null || entry.getValue() == null)
+                if (ignoreNull)
+                    continue;
+
+            if (sb.length() > 2)
+                sb.append(",\n");
+            sb.append(getIdentPrefix(level));
+            sb.append('"');
+            sb.append(entry.getKey().toString());
+            sb.append("\":");
+            sb.append(encode(entry.getValue(), level));
+        }
+        sb.append("\n");
+        sb.append(getIdentPrefix(--level));
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    private String getIdentPrefix(int level) {
+        int numSpaces = indentation * level;
+        StringBuilder sb = new StringBuilder(numSpaces);
+        for (int i=0; i < numSpaces; i++)
+            sb.append(' ');
+        return sb.toString();
+    }
+}
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultParser.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonParser.java
similarity index 96%
rename from converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultParser.java
rename to converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonParser.java
index bcd83f0836..36374ff273 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultParser.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonParser.java
@@ -24,7 +24,7 @@ import java.util.Map;
 import org.apache.felix.utils.json.JSONParser;
 import org.osgi.service.serializer.Parser;
 
-public class DefaultParser implements Parser {
+public class DefaultJsonParser implements Parser {
 
     @Override
     public Map<String, Object> parse(InputStream in)
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java
new file mode 100644
index 0000000000..3b9e9f8366
--- /dev/null
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/DefaultJsonWriter.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.felix.serializer.impl.json;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import org.osgi.dto.DTO;
+import org.osgi.service.serializer.Writer;
+import org.osgi.util.converter.Converter;
+
+public class DefaultJsonWriter implements Writer {
+
+    private final Converter converter;
+    private final boolean ignoreNull = false;
+
+    public DefaultJsonWriter(Converter c) {
+        converter = c;
+    }
+
+    @Override
+    public String write(Object obj) {
+        return encode(obj);
+    }
+
+    @SuppressWarnings("rawtypes")
+    private String encode(Object obj) {
+        if (obj == null) {
+            return ignoreNull ? "" : "null";
+        }
+
+        if (obj instanceof String) {
+            // Optimization for when the value is already a String
+            // David B.: is this ok? Or does the Converter do something else
+            //           other than just returning a String??
+            //           I noticed that a lot of calculations were going on, just
+            //           to return a String anyway.
+            return "\"" + (String)obj + "\"";
+        } else if (obj instanceof Map) {
+            return encodeMap((Map) obj);
+        } else if (obj instanceof Collection) {
+            return encodeCollection((Collection) obj);
+        } else if (obj instanceof DTO) {
+            return encodeMap(converter.convert(obj).sourceAsDTO().to(Map.class));
+        } else if (obj.getClass().isArray()) {
+            return encodeCollection(asCollection(obj));
+        } else if (obj instanceof Number) {
+            return obj.toString();
+        } else if (obj instanceof Boolean) {
+            return obj.toString();
+        }
+
+        return "\"" + converter.convert(obj).to(String.class) + "\"";
+    }
+
+    private Collection<?> asCollection(Object arr) {
+        // Arrays.asList() doesn't work for primitive arrays
+        int len = Array.getLength(arr);
+        List<Object> l = new ArrayList<>(len);
+        for (int i=0; i<len; i++) {
+            l.add(Array.get(arr, i));
+        }
+        return l;
+    }
+
+    private String encodeCollection(Collection<?> collection) {
+        StringBuilder sb = new StringBuilder("[");
+
+        boolean first = true;
+        for (Object o : collection) {
+            if (first)
+                first = false;
+            else
+                sb.append(',');
+
+            sb.append(encode(o));
+        }
+
+        sb.append("]");
+        return sb.toString();
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    private String encodeMap(Map m) {
+        StringBuilder sb = new StringBuilder("{");
+        for (Entry entry : (Set<Entry>) m.entrySet()) {
+            if (entry.getKey() == null || entry.getValue() == null)
+                if (ignoreNull)
+                    continue;
+
+            if (sb.length() > 1)
+                sb.append(',');
+            sb.append('"');
+            sb.append(entry.getKey().toString());
+            sb.append("\":");
+            sb.append(encode(entry.getValue()));
+        }
+        sb.append("}");
+
+        return sb.toString();
+    }
+}
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
index 5a2c9949d1..4ebe3de5f0 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonDeserializingImpl.java
@@ -77,13 +77,13 @@ public class JsonDeserializingImpl<T> implements Deserializing<T> {
     }
 
     @Override
-    public Deserializing<T> with(Converter c) {
+    public Deserializing<T> convertWith(Converter c) {
         converter = c;
         return this;
     }
 
     @Override
-    public Deserializing<T> with(Parser p) {
+    public Deserializing<T> parseWith(Parser p) {
         parser = p;
         return this;
     }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializerImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializerImpl.java
index 9a9d715c90..e852f600fc 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializerImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializerImpl.java
@@ -16,28 +16,21 @@
  */
 package org.apache.felix.serializer.impl.json;
 
-import java.io.IOException;
-import java.io.OutputStream;
 import java.lang.reflect.Type;
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.felix.serializer.impl.AbstractSpecifying;
 import org.osgi.service.serializer.Deserializing;
 import org.osgi.service.serializer.Parser;
 import org.osgi.service.serializer.Serializer;
 import org.osgi.service.serializer.Serializing;
+import org.osgi.service.serializer.Writer;
 import org.osgi.util.converter.Converter;
 import org.osgi.util.converter.Converters;
 import org.osgi.util.converter.TypeReference;
 
 public class JsonSerializerImpl implements Serializer {
-    private final Map<String, Object> configuration = new ConcurrentHashMap<>();
-    private final ThreadLocal<Boolean> threadLocal = new ThreadLocal<>();
     private final Converter converter = Converters.standardConverter();
-    private final Parser parser = new DefaultParser();
+    private final Parser parser = new DefaultJsonParser();
+    private final Writer writer = new DefaultJsonWriter(converter);
 
     @Override
     public <T> Deserializing<T> deserialize(Class<T> cls) {
@@ -46,79 +39,7 @@ public class JsonSerializerImpl implements Serializer {
 
     @Override
     public Serializing serialize(Object obj) {
-        Serializing encoding = new JsonSerializingImpl(converter, configuration, obj);
-
-        if (pretty()) {
-            Boolean top = threadLocal.get();
-            if (top == null) {
-                threadLocal.set(Boolean.TRUE);
-
-                // TODO implement this properly, the following it just a dev temp thing
-                encoding = new EncodingWrapper("{}{}{}{}{}", encoding, "{}{}{}{}{}");
-            }
-        }
-        return encoding;
-    }
-
-    private boolean pretty() {
-        return Boolean.TRUE.equals(Boolean.parseBoolean((String) configuration.get("pretty")));
-    }
-
-    private class EncodingWrapper extends AbstractSpecifying<Serializing> implements Serializing {
-        private final Serializing delegate;
-        private String prefix;
-        private String postfix;
-
-        EncodingWrapper(String pre, Serializing encoding, String post) {
-            prefix = pre;
-            delegate = encoding;
-            postfix = post;
-        }
-
-        @Override
-        public void to(OutputStream os) {
-            try {
-                os.write(toString().getBytes(StandardCharsets.UTF_8));
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public String toString() {
-            try {
-                return prefix + delegate.toString() + postfix;
-            } finally {
-                threadLocal.set(null);
-            }
-        }
-
-        @Override
-        public Serializing ignoreNull() {
-            return this;
-        }
-
-        @Override
-        public Serializing pretty() {
-            return this;
-        }
-
-        @Override
-        public void to(OutputStream out, Charset charset) {
-            // TODO Auto-generated method stub
-        }
-
-        @Override
-        public Appendable to(Appendable out) {
-            // TODO Auto-generated method stub
-            return null;
-        }
-
-        @Override
-        public Serializing with(Converter converter) {
-            delegate.with(converter);
-            return this;
-        }
+        return new JsonSerializingImpl(converter, writer, obj);
     }
 
     @Override
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializingImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializingImpl.java
index cae7437655..428ec5a0f9 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializingImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonSerializingImpl.java
@@ -18,39 +18,31 @@ package org.apache.felix.serializer.impl.json;
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.lang.reflect.Array;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
 import org.apache.felix.serializer.impl.AbstractSpecifying;
-import org.osgi.dto.DTO;
 import org.osgi.service.serializer.Serializing;
+import org.osgi.service.serializer.Writer;
 import org.osgi.util.converter.ConversionException;
 import org.osgi.util.converter.Converter;
 
 public class JsonSerializingImpl extends AbstractSpecifying<Serializing> implements Serializing {
     private volatile Converter converter;
-    private final Map<String, Object> configuration;
+    private volatile boolean useCustomWriter;
+    private volatile Writer writer;
     private final Object object;
-    private final boolean ignoreNull;
 
-    JsonSerializingImpl(Converter c, Map<String, Object> cfg, Object obj) {
+    JsonSerializingImpl(Converter c, Writer w, Object obj) {
         converter = c;
-        configuration = cfg;
-        ignoreNull = Boolean.TRUE.equals(Boolean.parseBoolean((String) configuration.get("ignoreNull")));
+        writer = w;
         object = obj;
     }
 
     @Override
     public Appendable to(Appendable out) {
         try {
-            out.append(encode(object));
+            out.append(writer.write(object));
             return out;
         } catch (IOException e) {
             throw new ConversionException("Problem converting to JSON", e);
@@ -60,7 +52,7 @@ public class JsonSerializingImpl extends AbstractSpecifying<Serializing> impleme
     @Override
     public void to(OutputStream os, Charset charset) {
         try {
-            os.write(encode(object).getBytes(charset));
+            os.write(writer.write(object).getBytes(charset));
         } catch (IOException e) {
             throw new ConversionException("Problem converting to JSON", e);
         }
@@ -73,99 +65,20 @@ public class JsonSerializingImpl extends AbstractSpecifying<Serializing> impleme
 
     @Override
     public String toString() {
-        return encode(object);
-    }
-
-    @SuppressWarnings("rawtypes")
-    private String encode(Object obj) {
-        if (obj == null) {
-            return ignoreNull ? "" : "null";
-        }
-
-        if (obj instanceof String) {
-            // Optimization for when the value is already a String
-            // David B.: is this ok? Or does the Converter do something else
-            //           other than just returning a String??
-            //           I noticed that a lot of calculations were going on, just
-            //           to return a String anyway.
-            return "\"" + (String)obj + "\"";
-        } else if (obj instanceof Map) {
-            return encodeMap((Map) obj);
-        } else if (obj instanceof Collection) {
-            return encodeCollection((Collection) obj);
-        } else if (sourceAsDTO || obj instanceof DTO) { // TODO: Use isDTOTYPE() or instanceOf??
-            return encodeMap(converter.convert(obj).sourceAsDTO().to(Map.class));
-        } else if (obj.getClass().isArray()) {
-            return encodeCollection(asCollection(obj));
-        } else if (obj instanceof Number) {
-            return obj.toString();
-        } else if (obj instanceof Boolean) {
-            return obj.toString();
-        }
-
-        return "\"" + converter.convert(obj).to(String.class) + "\"";
-    }
-
-    private Collection<?> asCollection(Object arr) {
-        // Arrays.asList() doesn't work for primitive arrays
-        int len = Array.getLength(arr);
-        List<Object> l = new ArrayList<>(len);
-        for (int i=0; i<len; i++) {
-            l.add(Array.get(arr, i));
-        }
-        return l;
-    }
-
-    private String encodeCollection(Collection<?> collection) {
-        StringBuilder sb = new StringBuilder("[");
-
-        boolean first = true;
-        for (Object o : collection) {
-            if (first)
-                first = false;
-            else
-                sb.append(',');
-
-            sb.append(encode(o));
-        }
-
-        sb.append("]");
-        return sb.toString();
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private String encodeMap(Map m) {
-        StringBuilder sb = new StringBuilder("{");
-        for (Entry entry : (Set<Entry>) m.entrySet()) {
-            if (entry.getKey() == null || entry.getValue() == null)
-                if (ignoreNull)
-                    continue;
-
-            if (sb.length() > 1)
-                sb.append(',');
-            sb.append('"');
-            sb.append(entry.getKey().toString());
-            sb.append("\":");
-            sb.append(encode(entry.getValue()));
-        }
-        sb.append("}");
-
-        return sb.toString();
+        return writer.write(object);
     }
 
     @Override
-    public Serializing ignoreNull() {
-        return this;
-    }
-
-    @Override
-    public Serializing pretty() {
+    public Serializing convertWith(Converter c) {
+        converter = c;
+        if (!useCustomWriter)
+            writer = new DefaultJsonWriter(converter);
         return this;
     }
 
     @Override
-    public Serializing with(Converter c) {
-        converter = c;
+    public Serializing writeWith(Writer w) {
+        writer = w;
         return this;
     }
 }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java
new file mode 100644
index 0000000000..7e9ecb72a0
--- /dev/null
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/json/JsonWriterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.felix.serializer.impl.json;
+
+import org.osgi.service.serializer.Writer;
+import org.osgi.service.serializer.WriterFactory;
+import org.osgi.util.converter.Converter;
+
+public class JsonWriterFactory implements WriterFactory {
+
+    @Override
+    public Writer newDefaultWriter(Converter c) {
+        return new DefaultJsonWriter(c);
+    }
+
+    @Override
+    public Writer newDebugWriter(Converter c) {
+        return new DebugJsonWriter(c);
+    }
+}
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultParser.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlParser.java
similarity index 96%
rename from converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultParser.java
rename to converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlParser.java
index 3b55674564..742ab935e4 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultParser.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlParser.java
@@ -23,7 +23,7 @@ import java.util.Map;
 import org.osgi.service.serializer.Parser;
 import org.yaml.snakeyaml.Yaml;
 
-public class DefaultParser implements Parser {
+public class DefaultYamlParser implements Parser {
 
     @Override
     public Map<String, Object> parse(InputStream in)
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlWriter.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlWriter.java
new file mode 100644
index 0000000000..360780d1eb
--- /dev/null
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/DefaultYamlWriter.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.felix.serializer.impl.yaml;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import org.osgi.service.serializer.Writer;
+import org.osgi.util.converter.Converter;
+
+public class DefaultYamlWriter implements Writer {
+
+    private final Converter converter;
+    private final int indentation = 2;
+
+    public DefaultYamlWriter(Converter c) {
+        converter = c;
+    }
+
+    @Override
+    public String write(Object obj) {
+        return encode(obj, 0).trim();
+    }
+
+    @SuppressWarnings("rawtypes")
+    private String encode(Object obj, int level) {
+        if (obj == null)
+            return "";
+
+        if (obj instanceof Map) {
+            return encodeMap((Map) obj, level);
+        } else if (obj instanceof Collection) {
+            return encodeCollection((Collection) obj, level);
+        } else if (obj.getClass().isArray()) {
+            return encodeCollection(asCollection(obj), level);
+        } else if (obj instanceof Number)  {
+            return obj.toString();
+        } else if (obj instanceof Boolean) {
+            return obj.toString();
+        }
+
+        return "'" + converter.convert(obj).to(String.class) + "'";
+    }
+
+    private Collection<?> asCollection(Object arr) {
+        // Arrays.asList() doesn't work for primitive arrays
+        int len = Array.getLength(arr);
+        List<Object> l = new ArrayList<>(len);
+        for (int i=0; i<len; i++) {
+            l.add(Array.get(arr, i));
+        }
+        return l;
+    }
+
+    private String encodeCollection(Collection<?> collection, int level) {
+        StringBuilder sb = new StringBuilder();
+        for (Object o : collection) {
+            sb.append("\n");
+            sb.append(getIdentPrefix(level));
+            sb.append("- ");
+            sb.append(encode(o, level + 1));
+        }
+        return sb.toString();
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    private String encodeMap(Map m, int level) {
+        StringBuilder sb = new StringBuilder();
+        for (Entry entry : (Set<Entry>) m.entrySet()) {
+            sb.append("\n");
+            sb.append(getIdentPrefix(level));
+            sb.append(entry.getKey().toString());
+            sb.append(": ");
+            sb.append(encode(entry.getValue(), level + 1));
+        }
+
+        return sb.toString();
+    }
+
+    private String getIdentPrefix(int level) {
+        int numSpaces = indentation * level;
+        StringBuilder sb = new StringBuilder(numSpaces);
+        for (int i=0; i < numSpaces; i++)
+            sb.append(' ');
+        return sb.toString();
+    }
+}
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlDeserializingImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlDeserializingImpl.java
index 99d7f4905d..f23511593d 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlDeserializingImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlDeserializingImpl.java
@@ -77,13 +77,13 @@ public class YamlDeserializingImpl<T> implements Deserializing<T> {
     }
 
     @Override
-    public Deserializing<T> with(Converter c) {
+    public Deserializing<T> convertWith(Converter c) {
         converter = c;
         return this;
     }
 
     @Override
-    public Deserializing<T> with(Parser p) {
+    public Deserializing<T> parseWith(Parser p) {
         parser = p;
         return this;
     }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializerImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializerImpl.java
index c6f7d0f5b2..05aa95f80e 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializerImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializerImpl.java
@@ -17,21 +17,20 @@
 package org.apache.felix.serializer.impl.yaml;
 
 import java.lang.reflect.Type;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.osgi.service.serializer.Deserializing;
 import org.osgi.service.serializer.Parser;
 import org.osgi.service.serializer.Serializer;
 import org.osgi.service.serializer.Serializing;
+import org.osgi.service.serializer.Writer;
 import org.osgi.util.converter.Converter;
 import org.osgi.util.converter.Converters;
 import org.osgi.util.converter.TypeReference;
 
 public class YamlSerializerImpl implements Serializer {
-    private final Map<String, Object> configuration = new ConcurrentHashMap<>();
     private final Converter converter = Converters.standardConverter();
-    private final Parser parser = new DefaultParser();
+    private final Parser parser = new DefaultYamlParser();
+    private final Writer writer = new DefaultYamlWriter(converter);
 
     @Override
     public <T> Deserializing<T> deserialize(Class<T> cls) {
@@ -50,6 +49,6 @@ public class YamlSerializerImpl implements Serializer {
 
     @Override
     public Serializing serialize(Object obj) {
-        return new YamlSerializingImpl(converter, configuration, obj);
+        return new YamlSerializingImpl(converter, writer, obj);
     }
 }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializingImpl.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializingImpl.java
index 154bfafb15..965c1b14ce 100644
--- a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializingImpl.java
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlSerializingImpl.java
@@ -18,37 +18,31 @@ package org.apache.felix.serializer.impl.yaml;
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.lang.reflect.Array;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
 import org.apache.felix.serializer.impl.AbstractSpecifying;
 import org.osgi.service.serializer.Serializing;
+import org.osgi.service.serializer.Writer;
 import org.osgi.util.converter.ConversionException;
 import org.osgi.util.converter.Converter;
 
 public class YamlSerializingImpl extends AbstractSpecifying<Serializing> implements Serializing {
     private volatile Converter converter;
-    private final Map<String, Object> configuration;
+    private volatile boolean useCustomWriter;
+    private volatile Writer writer;
     private final Object object;
-    private final int indentation = 2;
 
-    public YamlSerializingImpl(Converter c, Map<String, Object> cfg, Object obj) {
+    public YamlSerializingImpl(Converter c, Writer w, Object obj) {
         converter = c;
-        configuration = cfg;
+        writer = w;
         object = obj;
     }
 
     @Override
     public Appendable to(Appendable out) {
         try {
-            out.append(encode(object));
+            out.append(writer.write(object));
             return out;
         } catch (IOException e) {
             throw new ConversionException("Problem converting to YAML", e);
@@ -64,7 +58,7 @@ public class YamlSerializingImpl extends AbstractSpecifying<Serializing> impleme
     @Override
     public void to(OutputStream os, Charset charset) {
         try {
-            os.write(encode(object).getBytes(charset));
+            os.write(writer.write(object).getBytes(charset));
         } catch (IOException e) {
             throw new ConversionException("Problem converting to YAML", e);
         }
@@ -72,89 +66,21 @@ public class YamlSerializingImpl extends AbstractSpecifying<Serializing> impleme
 
     @Override
     public String toString() {
-        return encode(object);
-    }
-
-    private String encode(Object obj) {
-        return encode(obj, 0).trim();
-    }
-
-    @SuppressWarnings("rawtypes")
-    private String encode(Object obj, int level) {
-        if (obj == null)
-            return "";
-
-        if (obj instanceof Map) {
-            return encodeMap((Map) obj, level);
-        } else if (obj instanceof Collection) {
-            return encodeCollection((Collection) obj, level);
-        } else if (obj.getClass().isArray()) {
-            return encodeCollection(asCollection(obj), level);
-        } else if (obj instanceof Number)  {
-            return obj.toString();
-        } else if (obj instanceof Boolean) {
-            return obj.toString();
-        }
-
-        return "'" + converter.convert(obj).to(String.class) + "'";
-    }
-
-    private Collection<?> asCollection(Object arr) {
-        // Arrays.asList() doesn't work for primitive arrays
-        int len = Array.getLength(arr);
-        List<Object> l = new ArrayList<>(len);
-        for (int i=0; i<len; i++) {
-            l.add(Array.get(arr, i));
-        }
-        return l;
-    }
-
-    private String encodeCollection(Collection<?> collection, int level) {
-        StringBuilder sb = new StringBuilder();
-        for (Object o : collection) {
-            sb.append("\n");
-            sb.append(getIdentPrefix(level));
-            sb.append("- ");
-            sb.append(encode(o, level + 1));
-        }
-        return sb.toString();
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private String encodeMap(Map m, int level) {
-        StringBuilder sb = new StringBuilder();
-        for (Entry entry : (Set<Entry>) m.entrySet()) {
-            sb.append("\n");
-            sb.append(getIdentPrefix(level));
-            sb.append(entry.getKey().toString());
-            sb.append(": ");
-            sb.append(encode(entry.getValue(), level + 1));
-        }
-
-        return sb.toString();
-    }
-
-    private String getIdentPrefix(int level) {
-        int numSpaces = indentation * level;
-        StringBuilder sb = new StringBuilder(numSpaces);
-        for (int i=0; i < numSpaces; i++)
-            sb.append(' ');
-        return sb.toString();
+        return writer.write(object);
     }
 
     @Override
-    public Serializing pretty() {
-        return this;
-    }
-
-    @Override
-    public Serializing ignoreNull() {
+    public Serializing convertWith(Converter c) {
+        converter = c;
+        if (!useCustomWriter)
+            writer = new DefaultYamlWriter(converter);
         return this;
     }
 
     @Override
-    public Serializing with(Converter c) {
-        converter = c;
+    public Serializing writeWith(Writer w) {
+        writer = w;
+        useCustomWriter = true;
         return this;
     }
 }
diff --git a/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java
new file mode 100644
index 0000000000..7531e9b26b
--- /dev/null
+++ b/converter/serializer/src/main/java/org/apache/felix/serializer/impl/yaml/YamlWriterFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.felix.serializer.impl.yaml;
+
+import org.osgi.service.serializer.Writer;
+import org.osgi.service.serializer.WriterFactory;
+import org.osgi.util.converter.Converter;
+
+public class YamlWriterFactory implements WriterFactory {
+
+    @Override
+    public Writer newDefaultWriter(Converter c) {
+        return new DefaultYamlWriter(c);
+    }
+
+    @Override
+    public Writer newDebugWriter(Converter c) {
+        return new DefaultYamlWriter(c);
+    }
+}
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/Deserializing.java b/converter/serializer/src/main/java/org/osgi/service/serializer/Deserializing.java
index d75f869a04..b586c48e96 100644
--- a/converter/serializer/src/main/java/org/osgi/service/serializer/Deserializing.java
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/Deserializing.java
@@ -71,14 +71,14 @@ public interface Deserializing<T> {
 	 * @param converter The converter to use.
 	 * @return This Deserializing object to allow further invocations on it.
 	 */
-	Deserializing<T> with(Converter converter);
+	Deserializing<T> convertWith(Converter converter);
 
     /**
      * Specify the parser to be used, if an alternative to the default internal
      * parser is required.
      * 
      * @param parser the parser to use.
-     * @return This Serializing object to allow further invocations on it.
+     * @return This Deserializing object to allow further invocations on it.
      */
-	Deserializing<T> with(Parser parser);
+	Deserializing<T> parseWith(Parser parser);
 }
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/Serializer.java b/converter/serializer/src/main/java/org/osgi/service/serializer/Serializer.java
index 9a9fe70be6..ec2e0ed550 100644
--- a/converter/serializer/src/main/java/org/osgi/service/serializer/Serializer.java
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/Serializer.java
@@ -69,4 +69,16 @@ public interface Serializer {
 	 *         operation.
 	 */
 	Serializing serialize(Object obj);
+
+    /**
+     * A convenience means of obtaining a JsonSerializer without having to
+     * configure service settings.
+     */
+    static interface JsonSerializer extends Serializer {}
+
+    /**
+     * A convenience means of obtaining a YamlWriterFactory without having to
+     * configure service settings.
+     */
+    static interface YamlSerializer extends Serializer {}
 }
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/Serializing.java b/converter/serializer/src/main/java/org/osgi/service/serializer/Serializing.java
index 325a8a2ea7..48ff0f5a01 100644
--- a/converter/serializer/src/main/java/org/osgi/service/serializer/Serializing.java
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/Serializing.java
@@ -31,24 +31,6 @@ import org.osgi.util.converter.Specifying;
  */
 @ProviderType
 public interface Serializing extends Specifying<Serializing> {
-	/**
-	 * Specify that keys with a {@code null} value must not appear in the
-	 * result. If not specified {@code null} values will be included in the
-	 * result.
-	 *
-	 * @return This Serializing object to allow further invocations on it.
-	 */
-	Serializing ignoreNull();
-
-	/**
-	 * Specify that the encoded output should be formatted to look 'pretty',
-	 * which may make it easier for humans to read. If not specified, the
-	 * encoded output should be formatted to be compact, so save space.
-	 *
-	 * @return This Serializing object to allow further invocations on it.
-	 */
-	Serializing pretty();
-
 	/**
 	 * Use an output stream as the target of the encoding operation. UTF-8 will
 	 * be used if applicable, the character set may not apply to binary
@@ -93,5 +75,15 @@ public interface Serializing extends Specifying<Serializing> {
 	 * @param converter The converter to use.
 	 * @return This Serializing object to allow further invocations on it.
 	 */
-	Serializing with(Converter converter);
+	Serializing convertWith(Converter converter);
+
+    /**
+     * Specify the writer to be used, if an alternative to the default internal
+     * writer is required. A selection of Writers are available via the WriterFactory,
+     * or a completely different Writer can be provided directly.
+     * 
+     * @param parser the writer to use.
+     * @return This Serializing object to allow further invocations on it.
+     */
+    Serializing writeWith(Writer writer);
 }
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/Writer.java b/converter/serializer/src/main/java/org/osgi/service/serializer/Writer.java
new file mode 100644
index 0000000000..ddcc65163c
--- /dev/null
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/Writer.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) OSGi Alliance (2016). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.service.serializer;
+
+/**
+ * Common interface for a writer, which can be provided by the client.
+ */
+public interface Writer {
+    String write(Object obj);
+}
diff --git a/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java b/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java
new file mode 100644
index 0000000000..d46b50aefd
--- /dev/null
+++ b/converter/serializer/src/main/java/org/osgi/service/serializer/WriterFactory.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) OSGi Alliance (2017). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.service.serializer;
+
+import org.osgi.annotation.versioning.ProviderType;
+import org.osgi.util.converter.Converter;
+
+/**
+ * A factory to create a writer with the desired behaviour.
+ *
+ * @author $Id:$
+ */
+@ProviderType
+public interface WriterFactory {
+
+    /**
+     * A default Writer, but which will use a custom Converter.
+     *  
+     * @param c the custom Converter that will be used by the Writer
+     * @return a default Writer, but one which will use a custom Converter
+     */
+    Writer newDefaultWriter(Converter c);
+
+    /**
+     * A writer that is useful for debugging. This write outputs "pretty"
+     * format.
+     *
+     * @param c the custom Converter that will be used by the Writer
+     * @return A new writer useful for debugging
+     */
+    Writer newDebugWriter(Converter c);
+
+    /**
+     * A convenience means of obtaining a JsonWriterFactory without having to
+     * configure service settings.
+     */
+    static interface JsonWriterFactory extends WriterFactory {}
+
+    /**
+     * A convenience means of obtaining a YamlWriterFactory without having to
+     * configure service settings.
+     */
+    static interface YamlWriterFactory extends WriterFactory {}
+}
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
index 2301264645..a215fd00fd 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonBackingObjectSerializationTest.java
@@ -17,10 +17,14 @@
 package org.apache.felix.serializer.impl.json;
 
 import java.lang.reflect.Type;
+import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import org.junit.Test;
 import org.osgi.dto.DTO;
+import org.osgi.util.converter.Converter;
 import org.osgi.util.converter.ConverterFunction;
 import org.osgi.util.converter.Converters;
 import org.osgi.util.converter.TargetRule;
@@ -38,62 +42,55 @@ public class JsonBackingObjectSerializationTest {
                 .sourceAsDTO()
                 .to(Map.class);
 
-        final String expected = 
-                "{\"a\":\"A\","
-                        + "\"o\":{\"a\":\"AA\",\"b\":\"BB\"},"
-                        + "\"b\":\"B\"}";
-
-        final String actual = new JsonSerializerImpl().serialize(m).toString();
+        final String actual = new JsonSerializerImpl()
+                .serialize(m)
+                .writeWith(new JsonWriterFactory().newDebugWriter(Converters.standardConverter()))
+                .toString();
 
-        // TODO: Cannot predict order of elements for equals comparison//
-//        assertEquals(expected, actual);
+        assertEquals(EXPECTED, actual);
     }
 
     @Test
     public void testComplexMapSerializationWithoutUsingPreConversion() {
-        final String expected = 
-                "{\"a\":\"A\","
-                + "\"o\":{\"a\":\"AA\",\"b\":\"BB\"},"
-                + "\"b\":\"B\"}";
-
+        final JsonWriterFactory factory = new JsonWriterFactory();
         final String actual = new JsonSerializerImpl()
-                .serialize(MyDTOishObject.factory( "A", "B" ))
-                .sourceAsDTO()
+                .serialize(MyDTOishObject.factory("A", "B"))
+                .writeWith(factory.newDebugWriter(Converters.standardConverter()))
                 .toString();
 
-        // TODO: Cannot predict order of elements for equals comparison//
-//        assertEquals(expected, actual);
+        assertEquals(EXPECTED, actual);
     }
 
     @Test
     public void testComplexMapSerializationUsingRule() {
-        final String expected = 
-                "{\"o\":{\"a\":\"AA\",\"b\":\"BB\"},"
-                        + "\"a\":\"A\","
-                        + "\"b\":\"B\"}";
-
+        final Converter converter = Converters.newConverterBuilder().rule(new MapTargetRule()).build();
+        final JsonWriterFactory factory = new JsonWriterFactory();
         final String actual = new JsonSerializerImpl()
-                .serialize(MyDTOishObject.factory( "A", "B" ))
-                .with(Converters.newConverterBuilder().rule(new MapTargetRule()).build())
+                .serialize(MyDTOishObject.factory("A", "B"))
+                .convertWith(converter)
+                .writeWith(factory.newDebugWriter(converter))
                 .toString();
 
-        // Cannot get result to behave predictably... Order is random.
-//        assertEquals(expected.length(), actual.length());
+        assertEquals(EXPECTED, actual);
     }
 
     public static class MyDTOishObject extends DTO {
         public String a;
         public String b;
         public OtherObject o;
+        public List<String> l1;
+        public List<OtherObject> l2;
 
         public MyDTOishObject( String a, String b ) {
             this.a = a;
             this.b = b;
-            o = OtherObject.factory( a + a, b + b );
+            o = OtherObject.factory(a + a, b + b);
+            l1 = Stream.of("one", "two", "three", "four").collect(Collectors.toList());
+            l2 = Stream.of(OtherObject.factory(a, b), OtherObject.factory(a + a, b + b)).collect(Collectors.toList());
         }
 
         public static MyDTOishObject factory( String a, String b ) {
-            return new MyDTOishObject( a, b );
+            return new MyDTOishObject(a, b);
         }
     }
 
@@ -101,13 +98,13 @@ public class JsonBackingObjectSerializationTest {
         public String a;
         public String b;
 
-        public OtherObject( String a, String b ) {
+        public OtherObject(String a, String b) {
             this.a = a;
             this.b = b;
         }
 
-        public static OtherObject factory( String a, String b ) {
-            return new OtherObject( a, b );
+        public static OtherObject factory(String a, String b) {
+            return new OtherObject(a, b);
         }
     }
 
@@ -135,4 +132,30 @@ public class JsonBackingObjectSerializationTest {
                     .to(targetType);
         }
     }    
+
+    private static final String EXPECTED =
+            "{\n" +
+            "  \"a\":\"A\",\n" +
+            "  \"b\":\"B\",\n" +
+            "  \"l1\":[\n" +
+            "    \"one\",\n" +
+            "    \"two\",\n" +
+            "    \"three\",\n" +
+            "    \"four\"\n" +
+            "  ],\n" +
+            "  \"l2\":[\n" +
+            "    {\n" +
+            "      \"a\":\"A\",\n" +
+            "      \"b\":\"B\"\n" +
+            "    },\n" +
+            "    {\n" +
+            "      \"a\":\"AA\",\n" +
+            "      \"b\":\"BB\"\n" +
+            "    }\n" +
+            "  ],\n" +
+            "  \"o\":{\n" +
+            "    \"a\":\"AA\",\n" +
+            "    \"b\":\"BB\"\n" +
+            "  }\n" +
+            "}";
 }
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
index bc14ce85d1..6b3f545fe7 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonParserTest.java
@@ -34,7 +34,7 @@ public class JsonParserTest {
 
     @Before
     public void setup() {
-        parser = new DefaultParser();        
+        parser = new DefaultJsonParser();        
     }
 
     @Test
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonSerializerTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonSerializerTest.java
index c3f4ec8bc0..c662f70c9d 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonSerializerTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/json/JsonSerializerTest.java
@@ -88,7 +88,7 @@ public class JsonSerializerTest {
                 rule(new TypeRule<String, Foo>(String.class, Foo.class, v -> Foo.fsFun(v))).build();
 
         JsonSerializerImpl jsonCodec = new JsonSerializerImpl();
-        String json = jsonCodec.serialize(m).with(ca).toString();
+        String json = jsonCodec.serialize(m).convertWith(ca).toString();
 
         JSONObject jo = new JSONObject(json);
         assertEquals(1, jo.length());
@@ -97,7 +97,7 @@ public class JsonSerializerTest {
 
         // And convert back
         Map<String,Map<String,Foo>> m2 = jsonCodec.deserialize(new TypeReference<Map<String,Map<String,Foo>>>(){}).
-                with(ca).from(json);
+                convertWith(ca).from(json);
         assertEquals(m, m2);
     }
 
diff --git a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/yaml/YamlSerializerTest.java b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/yaml/YamlSerializerTest.java
index 0b6f9999ff..86403e5823 100644
--- a/converter/serializer/src/test/java/org/apache/felix/serializer/impl/yaml/YamlSerializerTest.java
+++ b/converter/serializer/src/test/java/org/apache/felix/serializer/impl/yaml/YamlSerializerTest.java
@@ -83,14 +83,14 @@ public class YamlSerializerTest {
                 rule(new TypeRule<String, Foo>(String.class, Foo.class, v -> Foo.fsFun(v))).build();
 
         YamlSerializerImpl yamlCodec = new YamlSerializerImpl();
-        String yaml = yamlCodec.serialize(m).with(ca).toString();
+        String yaml = yamlCodec.serialize(m).convertWith(ca).toString();
 
         assertEquals("submap: \n" +
                 "  f: '<fofofo>'", yaml);
 
         // And convert back
         Map<String,Map<String,Foo>> m2 = yamlCodec.deserialize(new TypeReference<Map<String,Map<String,Foo>>>(){}).
-                with(ca).from(yaml);
+                convertWith(ca).from(yaml);
         assertEquals(m, m2);
     }
 
