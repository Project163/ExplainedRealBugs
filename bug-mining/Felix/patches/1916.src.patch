diff --git a/scr/src/main/java/org/apache/felix/scr/impl/ComponentActorThread.java b/scr/src/main/java/org/apache/felix/scr/impl/ComponentActorThread.java
index 1a1638b292..8083ee7b94 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/ComponentActorThread.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/ComponentActorThread.java
@@ -77,6 +77,7 @@ class ComponentActorThread implements Runnable
                     }
                     catch ( InterruptedException ie )
                     {
+                        Thread.currentThread().interrupt();
                         // don't care
                     }
                 }
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 41069a856b..f428c90b11 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -186,10 +186,21 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
         }
         catch ( InterruptedException e )
         {
+            try
+            {
+                if (!m_stateLock.tryLock( getLockTimeout(), TimeUnit.MILLISECONDS ) )
+                {
+                    dumpThreads();
+                    throw new IllegalStateException( "Could not obtain lock" );
+                }
+            }
+            catch ( InterruptedException e1 )
+            {
+                Thread.currentThread().interrupt();
+                //TODO is there a better exception to throw?
+                throw new IllegalStateException( "Interrupted twice: Could not obtain lock" );
+            }
             Thread.currentThread().interrupt();
-            dumpThreads();
-            //TODO this is so wrong
-            throw new IllegalStateException( "Could not obtain lock (Reason: " + e + ")" );
         }
     }
 
@@ -268,20 +279,26 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
                         new Object[] {trackingCount, ceiling, missing}, null );
                 try
                 {
-                    if ( !missingCondition.await( getLockTimeout(), TimeUnit.MILLISECONDS ))
+                    if ( !doMissingWait())
                     {
-                        log( LogService.LOG_ERROR, "waitForTracked timed out: {0} ceiling: {1} missing: {2},  Expect further errors",
-                                new Object[] {trackingCount, ceiling, missing}, null );
-                        dumpThreads();
-                        missing.clear();
-                        return;
-                        
+                        return;                        
                     }
                 }
                 catch ( InterruptedException e )
                 {
+                    try
+                    {
+                        if ( !doMissingWait())
+                        {
+                            return;                        
+                        }
+                    }
+                    catch ( InterruptedException e1 )
+                    {
+                        log( LogService.LOG_ERROR, "waitForTracked interrupted twice: {0} ceiling: {1} missing: {2},  Expect further errors",
+                                new Object[] {trackingCount, ceiling, missing}, e1 );
+                    }
                     Thread.currentThread().interrupt();
-                    dumpThreads();
                 }
             }
         }
@@ -290,6 +307,19 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
             missingLock.unlock();
         }
     }
+    
+    private boolean doMissingWait() throws InterruptedException
+    {
+        if ( !missingCondition.await( getLockTimeout(), TimeUnit.MILLISECONDS ))
+        {
+            log( LogService.LOG_ERROR, "waitForTracked timed out: {0} ceiling: {1} missing: {2},  Expect further errors",
+                    new Object[] {trackingCount, ceiling, missing}, null );
+            dumpThreads();
+            missing.clear();
+            return false;
+        }
+        return true;
+    }
 
 //---------- Component ID management
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentContextImpl.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentContextImpl.java
index 9475e702f5..2203fed606 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentContextImpl.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentContextImpl.java
@@ -31,6 +31,7 @@ import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
 import org.osgi.service.component.ComponentInstance;
+import org.osgi.service.log.LogService;
 
 
 /**
@@ -187,8 +188,18 @@ public class ComponentContextImpl<S> implements ExtComponentContext {
         }
         catch ( InterruptedException e )
         {
+            try
+            {
+                if (accessibleLatch.await( m_componentManager.getLockTimeout(), TimeUnit.MILLISECONDS ) && m_implementationAccessible)
+                {
+                    return m_implementationObject;
+                }
+            }
+            catch ( InterruptedException e1 )
+            {
+                m_componentManager.log( LogService.LOG_INFO, "Interrupted twice waiting for implementation object to become accessible", e1 );
+            }
             Thread.currentThread().interrupt();
-            getComponentManager().dumpThreads();
             return null;
         }
         return null;
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 60492d5fe4..d6b319afed 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -1645,9 +1645,22 @@ public class DependencyManager<S, T> implements Reference
             }
             catch ( InterruptedException e )
             {
+                try
+                {
+                    if (!info.getOpenLatch().await( getLockTimeout(), TimeUnit.MILLISECONDS ))
+                    {
+                        m_componentManager.log( LogService.LOG_ERROR,
+                                "DependencyManager : invokeUpdatedMethod : timeout on open latch {0}",  new Object[] {getName()}, null );
+                        m_componentManager.dumpThreads();
+                    }
+                }
+                catch ( InterruptedException e1 )
+                {
+                    m_componentManager.log( LogService.LOG_ERROR,
+                            "DependencyManager : invokeUpdatedMethod : Interrupted twice on open latch {0}",  new Object[] {getName()}, null );
+                    Thread.currentThread().interrupt();
+                }
                 Thread.currentThread().interrupt();
-                m_componentManager.dumpThreads();
-                //ignore
             }
             if ( !getServiceObject( m_bindMethods.getUpdated(), refPair ))
             {
@@ -1708,9 +1721,21 @@ public class DependencyManager<S, T> implements Reference
                     }
                     catch ( InterruptedException e )
                     {
+                        try
+                        {
+                            if (!info.getCloseLatch().await( getLockTimeout(), TimeUnit.MILLISECONDS ) )
+                            {
+                                m_componentManager.log( LogService.LOG_ERROR,
+                                        "DependencyManager : invokeUnbindMethod : timeout on close latch {0}",  new Object[] {getName()}, null );
+                                m_componentManager.dumpThreads();
+                            }
+                        }
+                        catch ( InterruptedException e1 )
+                        {
+                            m_componentManager.log( LogService.LOG_ERROR,
+                                    "DependencyManager : invokeUnbindMethod : Interrupted twice on close latch {0}",  new Object[] {getName()}, null );
+                        }
                         Thread.currentThread().interrupt();
-                        m_componentManager.dumpThreads();
-                        //ignore
                     }
                 }
                 //ignore events after close started or we will have duplicate unbinds.
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/RegistrationManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/RegistrationManager.java
index be5c514749..adabae5104 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/RegistrationManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/RegistrationManager.java
@@ -178,10 +178,21 @@ abstract class RegistrationManager<T>
                 }
                 catch ( InterruptedException e )
                 {
+                    try
+                    {
+                        if ( !rsw.getLatch().await( getTimeout(), TimeUnit.MILLISECONDS ))
+                        {
+                            log( LogService.LOG_ERROR, "Timeout waiting for reg change to complete {0}", new Object[]
+                                    {rsw.getRegState()}, null);
+                            reportTimeout();
+                        }
+                    }
+                    catch ( InterruptedException e1 )
+                    {
+                        log( LogService.LOG_ERROR, "Interrupted twice waiting for reg change to complete {0}", new Object[]
+                                {rsw.getRegState()}, null);
+                    }
                     Thread.currentThread().interrupt();
-                    log( LogService.LOG_ERROR, "Interrupted exception waiting for reg change to complete {0}", new Object[]
-                            {rsw.getRegState()}, null);
-                    reportTimeout();
                 }
             }
         }
