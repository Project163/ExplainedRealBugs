diff --git a/scr/src/main/java/org/apache/felix/scr/impl/config/ImmediateComponentHolder.java b/scr/src/main/java/org/apache/felix/scr/impl/config/ImmediateComponentHolder.java
index 63220f8014..c46c9a127d 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/config/ImmediateComponentHolder.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/config/ImmediateComponentHolder.java
@@ -297,12 +297,26 @@ public class ImmediateComponentHolder implements ComponentHolder, SimpleLogger
                 }
 
                 // configure the component
+                log( LogService.LOG_DEBUG, "ImmediateComponentHolder About to actually configure the dependency managers for component for pid {0} ",
+                        new Object[] {pid}, null );
                 newIcm.reconfigure( props );
+                log( LogService.LOG_DEBUG, "ImmediateComponentHolder Finished configuring the dependency managers for component for pid {0} ",
+                        new Object[] {pid}, null );
 
                 // enable the component if it is initially enabled
                 if ( m_enabled && getComponentMetadata().isEnabled() )
                 {
+                    log( LogService.LOG_DEBUG, "ImmediateComponentHolder About to enable component for pid {0} ",
+                            new Object[] {pid}, null );
                     newIcm.enable( false );
+                    log( LogService.LOG_DEBUG, "ImmediateComponentHolder Finished enabling component for pid {0} ",
+                            new Object[] {pid}, null );
+                }
+                else
+                {
+                    log( LogService.LOG_DEBUG, "ImmediateComponentHolder Will not enable component for pid {0}: holder enabled state: {1}, metadata enabled: {2} ",
+                            new Object[] {pid, m_enabled, getComponentMetadata().isEnabled()}, null );
+
                 }
 
                 // store the component in the map
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
index 719fee720a..07ad20f6e5 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/AbstractComponentManager.java
@@ -97,6 +97,8 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
     protected volatile boolean enabled;
     protected volatile CountDownLatch enabledLatch;
     private final Object enabledLatchLock = new Object();
+
+    protected volatile boolean m_internalEnabled;
     /**
      * synchronizing while creating the service registration is safe as long as the bundle is not stopped
      * during some service registrations.  So, avoid synchronizing during unregister service if the component is being
@@ -587,6 +589,7 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
     final void enableInternal()
     {
         m_state.enable( this );
+        m_internalEnabled = true;
     }
 
     final boolean activateInternal( int trackingCount )
@@ -601,6 +604,7 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
 
     final void disableInternal()
     {
+        m_internalEnabled = false;
         m_state.disable( this );
     }
 
@@ -966,20 +970,20 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
 
     private void enableDependencyManagers() throws InvalidSyntaxException
     {
-        if ( !m_componentMetadata.isConfigurationRequired() )
+        if ( !m_componentMetadata.isConfigurationRequired() || hasConfiguration() )
         {
-            for ( DependencyManager dm: getDependencyManagers() )
-            {
-                dm.enable();
-            }
+            updateTargets( getProperties() );
         }
     }
 
     protected void updateTargets(Dictionary properties)
     {
-        for ( DependencyManager dm: getDependencyManagers() )
+        if ( m_internalEnabled )
         {
-            dm.setTargetFilter( properties );
+            for ( DependencyManager dm: getDependencyManagers() )
+            {
+                dm.setTargetFilter( properties );
+            }
         }
     }
 
@@ -1358,20 +1362,8 @@ public abstract class AbstractComponentManager<S> implements Component, SimpleLo
             }
 
             acm.registerComponentId();
-            try
-            {
-                acm.enableDependencyManagers();
-                acm.changeState( Unsatisfied.getInstance() );
-                acm.log( LogService.LOG_DEBUG, "Component enabled", null );
-            }
-            catch ( InvalidSyntaxException ise )
-            {
-                // one of the reference target filters is invalid, fail
-                acm.log( LogService.LOG_ERROR, "Failed enabling Component", ise );
-                acm.disableDependencyManagers();
-                acm.unregisterComponentId();
-                acm.changeState( Disabled.getInstance() );
-            }
+            acm.changeState( Unsatisfied.getInstance() );
+            acm.log( LogService.LOG_DEBUG, "Component enabled", null );
         }
 
         void deactivate( AbstractComponentManager acm, int reason, boolean disable )
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index e5af9f9b35..babf5004d6 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -879,6 +879,58 @@ public class DependencyManager<S, T> implements Reference
         }
     }
 
+    private class NoPermissionsCustomizer implements Customizer<T>
+    {
+
+        public boolean open()
+        {
+            return false;
+        }
+
+        public void close()
+        {
+        }
+
+        public Collection<RefPair<T>> getRefs( AtomicInteger trackingCount )
+        {
+            return null;
+        }
+
+        public boolean isSatisfied()
+        {
+            return isOptional();
+        }
+
+        public void setTracker( ServiceTracker<T, RefPair<T>> tRefPairServiceTracker )
+        {
+        }
+
+        public void setTrackerOpened()
+        {
+        }
+
+        public void setPreviousRefMap( Map<ServiceReference<T>, RefPair<T>> previousRefMap )
+        {
+        }
+
+        public RefPair<T> addingService( ServiceReference<T> tServiceReference )
+        {
+            return null;
+        }
+
+        public void addedService( ServiceReference<T> tServiceReference, RefPair<T> service, int trackingCount )
+        {
+        }
+
+        public void modifiedService( ServiceReference<T> tServiceReference, RefPair<T> service, int trackingCount )
+        {
+        }
+
+        public void removedService( ServiceReference<T> tServiceReference, RefPair<T> service, int trackingCount )
+        {
+        }
+    }
+
     //---------- Reference interface ------------------------------------------
 
     public String getServiceName()
@@ -928,31 +980,6 @@ public class DependencyManager<S, T> implements Reference
 
     //---------- Service tracking support -------------------------------------
 
-    /**
-     * Enables this dependency manager by starting to listen for service
-     * events.
-     * @throws InvalidSyntaxException if the target filter is invalid
-     */
-    void enable() throws InvalidSyntaxException
-    {
-        if ( hasGetPermission() )
-        {
-            // setup the target filter from component descriptor
-            setTargetFilter( m_dependencyMetadata.getTarget() );
-
-            m_componentManager.log( LogService.LOG_DEBUG,
-                    "Registered for service events, currently {0} service(s) match the filter", new Object[]
-                    {new Integer( size() )}, null );
-        }
-        else
-        {
-            // no services available
-            m_componentManager.log( LogService.LOG_DEBUG,
-                    "Not registered for service events since the bundle has no permission to get service {0}", new Object[]
-                    {m_dependencyMetadata.getInterface()}, null );
-        }
-    }
-
 
     void deactivate()
     {
@@ -1684,8 +1711,20 @@ public class DependencyManager<S, T> implements Reference
      * @param target The new target filter to be set. This may be
      *      <code>null</code> if no target filtering is to be used.
      */
-    private void setTargetFilter( String target ) throws InvalidSyntaxException
+    private void setTargetFilter( String target) throws InvalidSyntaxException
     {
+        if (!hasGetPermission())
+        {
+            customizerRef.set( new NoPermissionsCustomizer() );
+            m_componentManager.log( LogService.LOG_INFO, "No permission to get services for {0}", new Object[]
+                    {m_dependencyMetadata.getName()}, null );
+            return;
+        }
+        // if configuration does not set filter, use the value from metadata
+        if (target == null)
+        {
+            target = m_dependencyMetadata.getTarget();
+        }
         // do nothing if target filter does not change
         if ( ( m_target == null && target == null ) || ( m_target != null && m_target.equals( target ) ) )
         {
