diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
index 3ad3f58d06..e5af9f9b35 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/DependencyManager.java
@@ -1345,6 +1345,10 @@ public class DependencyManager<S, T> implements Reference
         latch.countDown();
     }
 
+    void cleanup( S componentInstance)
+    {
+        edgeInfoMap.remove( componentInstance );
+    }
 
     public void invokeBindMethodLate( final ServiceReference<T> ref, int trackingCount )
     {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
index fd8af5a630..cbb67e3e81 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ImmediateComponentManager.java
@@ -164,9 +164,11 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
         }
         if ( m_implementationObject != null )
         {
-            disposeImplementationObject( m_implementationObject, m_componentContext, reason );
+            S implementationObject = m_implementationObject;
+            disposeImplementationObject( implementationObject, m_componentContext, reason );
             m_useCount.set( 0 );
             m_implementationObject = null;
+            cleanupImplementationObject( implementationObject );
             log( LogService.LOG_DEBUG, "Unset implementation object for component {0} in deleteComponent for reason {1}", new Object[] { getName(), reason },  null );
             m_componentContext = null;
             m_properties = null;
@@ -335,6 +337,16 @@ public class ImmediateComponentManager<S> extends AbstractComponentManager<S> im
         // nothing to do, we keep no references on per-Bundle services
     }
 
+    protected void cleanupImplementationObject( Object implementationObject )
+    {
+
+        for ( DependencyManager md: getReversedDependencyManagers() )
+        {
+            md.cleanup( implementationObject );
+        }
+
+    }
+
     State getSatisfiedState()
     {
         return Registered.getInstance();
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
index eee0f6bbc8..e4e609cf52 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ServiceFactoryComponentManager.java
@@ -89,8 +89,9 @@ public class ServiceFactoryComponentManager<S> extends ImmediateComponentManager
         for (Iterator i = serviceContexts.values().iterator(); i.hasNext(); )
         {
             BundleComponentContext componentContext = ( BundleComponentContext ) i.next();
-            i.remove();
             disposeImplementationObject( componentContext.getInstance(), componentContext, reason );
+            i.remove();
+            cleanupImplementationObject( componentContext.getInstance() );
             log( LogService.LOG_DEBUG, "Unset implementation object for component {0} in deleteComponent", new Object[] { getName() },  null );
         }
     }
@@ -195,10 +196,11 @@ public class ServiceFactoryComponentManager<S> extends ImmediateComponentManager
         // When the ungetServiceMethod is called, the implementation object must be deactivated
         // private ComponentContext and implementation instances
         final ComponentContext serviceContext;
-        serviceContext = ( ComponentContext ) serviceContexts.remove( service );
+        serviceContext = serviceContexts.get( service );
 
         disposeImplementationObject( service, serviceContext, ComponentConstants.DEACTIVATION_REASON_DISPOSED );
-
+        serviceContexts.remove( service );
+        cleanupImplementationObject( service );
         // if this was the last use of the component, go back to REGISTERED state
         if ( serviceContexts.isEmpty() && getState() == STATE_ACTIVE )
         {
