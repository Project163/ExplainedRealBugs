diff --git a/scr/src/main/java/org/apache/felix/scr/XmlHandler.java b/scr/src/main/java/org/apache/felix/scr/XmlHandler.java
index a9b43e77cc..6c50234c05 100644
--- a/scr/src/main/java/org/apache/felix/scr/XmlHandler.java
+++ b/scr/src/main/java/org/apache/felix/scr/XmlHandler.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -26,23 +26,25 @@ import org.apache.felix.scr.parser.KXml2SAXHandler;
 import org.apache.felix.scr.parser.ParseException;
 
 /**
- * 
- * 
+ *
+ *
  */
 public class XmlHandler implements KXml2SAXHandler {
 
+    public static final String NAMESPACE_URI = "http://www.osgi.org/xmlns/scr/v1.0.0";
+
     // A reference to the current component
-    private ComponentMetadata m_currentComponent = null;
+    private ComponentMetadata m_currentComponent;
 
     // The current service
-    private ServiceMetadata m_currentService = null;
-    
+    private ServiceMetadata m_currentService;
+
     // A list of component descriptors contained in the file
     private List m_components = new ArrayList();
 
     // PropertyMetaData whose value attribute is missing, hence has element data
     private PropertyMetadata m_pendingProperty;
-    
+
     /**
      * Method called when a tag opens
      *
@@ -52,113 +54,117 @@ public class XmlHandler implements KXml2SAXHandler {
      * @param   attrib
      * @exception   ParseException
     **/
-    public void startElement(String uri,String localName,String qName,Properties attrib) throws ParseException
-    {
-    	try {
-    		
-	    	// 112.4.3 Component Element
-	        if (qName.equals("component")) {
-
-	        	// Create a new ComponentMetadata
-	        	m_currentComponent = new ComponentMetadata();
-
-	        	// name attribute is mandatory
-	        	m_currentComponent.setName(attrib.getProperty("name"));
-	        	
-	        	// enabled attribute is optional
-	        	if(attrib.getProperty("enabled") != null) {
-	        		m_currentComponent.setEnabled(attrib.getProperty("enabled").equals("true"));
-	        	}
-
-	        	// immediate attribute is optional
-	        	if(attrib.getProperty("immediate") != null) {
-	        		m_currentComponent.setImmediate(attrib.getProperty("immediate").equals("true"));
-	        	}
-	        	
-	        	// factory attribute is optional
-	        	if(attrib.getProperty("factory") != null) {
-	        		m_currentComponent.setFactoryIdentifier(attrib.getProperty("factory"));
-	        	}
-		        	
-	        	// Add this component to the list
-	            m_components.add(m_currentComponent);
-	        }
-	        
-	        // 112.4.4 Implementation
-	        else if (qName.equals("implementation"))
-	        {
-	        	// Set the implementation class name (mandatory)
-	        	m_currentComponent.setImplementationClassName(attrib.getProperty("class"));
-	        }
-	        // 112.4.5 Properties and Property Elements
-	        else if (qName.equals("property")) {
-                PropertyMetadata prop = new PropertyMetadata();
-                
-                // name attribute is mandatory
-                prop.setName(attrib.getProperty("name"));
-                
-                // type attribute is optional
-                if(attrib.getProperty("type") != null) {
-                    prop.setType(attrib.getProperty("type"));
-                }
-
-                // 112.4.5: If the value attribute is specified, the body of the element is ignored.
-	        	if( attrib.getProperty("value") != null) {
-        			prop.setValue(attrib.getProperty("value"));
-	            	m_currentComponent.addProperty(prop);
-	        	}
-	        	else {
-	        		// hold the metadata pending
-                    m_pendingProperty = prop;
-	        	}
-	        	// TODO: treat the case where a properties file name is provided (p. 292)
-	        }
-	        else if(qName.equals("properties")) {
-	        	// TODO: implement the properties tag
-	        }
-	        // 112.4.6 Service Element
-	        else if (qName.equals("service")) {
-	        	
-	        	m_currentService = new ServiceMetadata();
-	        	
-	        	// servicefactory attribute is optional
-	        	if(attrib.getProperty("servicefactory") != null) {
-	        		m_currentService.setServiceFactory(attrib.getProperty("servicefactory").equals("true"));
-	        	}      	
-	        	
-	            m_currentComponent.setService(m_currentService);
-	        }
-	        else if (qName.equals("provide")) {
-	            m_currentService.addProvide(attrib.getProperty("interface"));
-	        }
-	        
-	        // 112.4.7 Reference element
-	        else if (qName.equals("reference")) {
-	            ReferenceMetadata ref=new ReferenceMetadata ();
-	            ref.setName(attrib.getProperty("name"));
-	            ref.setInterface(attrib.getProperty("interface"));
-	            
-	            // Cardinality 
-	            if(attrib.getProperty("cardinality")!= null) {
-	            	ref.setCardinality(attrib.getProperty("cardinality"));
-	            }
-	            
-	            if(attrib.getProperty("policy") != null) {
-	            	ref.setPolicy(attrib.getProperty("policy"));
-	            }
-	            
-	            //if
-	            ref.setTarget(attrib.getProperty("target"));
-	            ref.setBind(attrib.getProperty("bind"));
-	            ref.setUnbind(attrib.getProperty("unbind"));
-	
-	            m_currentComponent.addDependency(ref);
-	        }
-    	}
-    	catch(Exception ex) {
-    		ex.printStackTrace();
-    		throw new ParseException("Exception during parsing",ex);
-    	}
+    public void startElement(String uri, String localName, String qName, Properties attrib)
+    throws ParseException {
+        // we process elements in the default namespace and in the scr namespace only
+        // TODO - To be 100% correct we should only listen to the scr namespace
+        if ( "".equals(uri) || NAMESPACE_URI.equals(uri) ) {
+        	try {
+
+    	    	// 112.4.3 Component Element
+    	        if (localName.equals("component")) {
+
+    	        	// Create a new ComponentMetadata
+    	        	this.m_currentComponent = new ComponentMetadata();
+
+    	        	// name attribute is mandatory
+    	        	this.m_currentComponent.setName(attrib.getProperty("name"));
+
+    	        	// enabled attribute is optional
+    	        	if(attrib.getProperty("enabled") != null) {
+    	        		this.m_currentComponent.setEnabled(attrib.getProperty("enabled").equals("true"));
+    	        	}
+
+    	        	// immediate attribute is optional
+    	        	if(attrib.getProperty("immediate") != null) {
+    	        		this.m_currentComponent.setImmediate(attrib.getProperty("immediate").equals("true"));
+    	        	}
+
+    	        	// factory attribute is optional
+    	        	if(attrib.getProperty("factory") != null) {
+    	        		this.m_currentComponent.setFactoryIdentifier(attrib.getProperty("factory"));
+    	        	}
+
+    	        	// Add this component to the list
+    	            this.m_components.add(this.m_currentComponent);
+    	        }
+
+    	        // 112.4.4 Implementation
+    	        else if (localName.equals("implementation"))
+    	        {
+    	        	// Set the implementation class name (mandatory)
+    	        	this.m_currentComponent.setImplementationClassName(attrib.getProperty("class"));
+    	        }
+    	        // 112.4.5 Properties and Property Elements
+    	        else if (localName.equals("property")) {
+                    PropertyMetadata prop = new PropertyMetadata();
+
+                    // name attribute is mandatory
+                    prop.setName(attrib.getProperty("name"));
+
+                    // type attribute is optional
+                    if(attrib.getProperty("type") != null) {
+                        prop.setType(attrib.getProperty("type"));
+                    }
+
+                    // 112.4.5: If the value attribute is specified, the body of the element is ignored.
+    	        	if( attrib.getProperty("value") != null) {
+            			prop.setValue(attrib.getProperty("value"));
+    	            	this.m_currentComponent.addProperty(prop);
+    	        	}
+    	        	else {
+    	        		// hold the metadata pending
+                        this.m_pendingProperty = prop;
+    	        	}
+    	        	// TODO: treat the case where a properties file name is provided (p. 292)
+    	        }
+    	        else if(localName.equals("properties")) {
+    	        	// TODO: implement the properties tag
+    	        }
+    	        // 112.4.6 Service Element
+    	        else if (localName.equals("service")) {
+
+    	        	this.m_currentService = new ServiceMetadata();
+
+    	        	// servicefactory attribute is optional
+    	        	if(attrib.getProperty("servicefactory") != null) {
+    	        		this.m_currentService.setServiceFactory(attrib.getProperty("servicefactory").equals("true"));
+    	        	}
+
+    	            this.m_currentComponent.setService(this.m_currentService);
+    	        }
+    	        else if (localName.equals("provide")) {
+    	            this.m_currentService.addProvide(attrib.getProperty("interface"));
+    	        }
+
+    	        // 112.4.7 Reference element
+    	        else if (localName.equals("reference")) {
+    	            ReferenceMetadata ref=new ReferenceMetadata ();
+    	            ref.setName(attrib.getProperty("name"));
+    	            ref.setInterface(attrib.getProperty("interface"));
+
+    	            // Cardinality
+    	            if(attrib.getProperty("cardinality")!= null) {
+    	            	ref.setCardinality(attrib.getProperty("cardinality"));
+    	            }
+
+    	            if(attrib.getProperty("policy") != null) {
+    	            	ref.setPolicy(attrib.getProperty("policy"));
+    	            }
+
+    	            //if
+    	            ref.setTarget(attrib.getProperty("target"));
+    	            ref.setBind(attrib.getProperty("bind"));
+    	            ref.setUnbind(attrib.getProperty("unbind"));
+
+    	            this.m_currentComponent.addDependency(ref);
+    	        }
+        	}
+        	catch(Exception ex) {
+        		ex.printStackTrace();
+        		throw new ParseException("Exception during parsing",ex);
+        	}
+        }
     }
 
     /**
@@ -169,18 +175,22 @@ public class XmlHandler implements KXml2SAXHandler {
     * @param   qName
     * @exception   ParseException
     */
-    public void endElement(java.lang.String uri,java.lang.String localName,java.lang.String qName) throws ParseException
+    public void endElement(String uri, String localName, String qName) throws ParseException
     {
-        if (qName.equals("component"))
-        {
-        	// When the closing tag for a component is found, the component is validated to check if 
-        	// the implementation class has been set
-        	m_currentComponent.validate();
-        } else if (qName.equals("property") && m_pendingProperty != null) {
-            // 112.4.5 body expected to contain property value
-            // if so, the m_pendingProperty field would be null
-            // currently, we just ignore this situation
-            m_pendingProperty = null;
+        // we process elements in the default namespace and in the scr namespace only
+        // TODO - To be 100% correct we should only listen to the scr namespace
+        if ( "".equals(uri) || NAMESPACE_URI.equals(uri) ) {
+            if (localName.equals("component"))
+            {
+            	// When the closing tag for a component is found, the component is validated to check if
+            	// the implementation class has been set
+            	this.m_currentComponent.validate();
+            } else if (localName.equals("property") && this.m_pendingProperty != null) {
+                // 112.4.5 body expected to contain property value
+                // if so, the m_pendingProperty field would be null
+                // currently, we just ignore this situation
+                this.m_pendingProperty = null;
+            }
         }
     }
 
@@ -191,33 +201,33 @@ public class XmlHandler implements KXml2SAXHandler {
     */
     List getComponentMetadataList()
     {
-        return m_components;
+        return this.m_components;
     }
 
 	public void characters( char[] ch, int offset, int length ) throws Exception
     {
         // 112.4.5 If the value attribute is not specified, the body must contain one or more values
-        if ( m_pendingProperty != null )
+        if ( this.m_pendingProperty != null )
         {
-            m_pendingProperty.setValues( new String( ch, offset, length ) );
-            m_currentComponent.addProperty( m_pendingProperty );
-            m_pendingProperty = null;
+            this.m_pendingProperty.setValues( new String( ch, offset, length ) );
+            this.m_currentComponent.addProperty( this.m_pendingProperty );
+            this.m_pendingProperty = null;
         }
     }
 
 	public void processingInstruction(String target, String data) throws Exception {
 		// Not used
-		
+
 	}
 
 	public void setLineNumber(int lineNumber) {
 		// Not used
-		
+
 	}
 
 	public void setColumnNumber(int columnNumber) {
 		// Not used
-		
+
 	}
 }
 
diff --git a/scr/src/main/java/org/apache/felix/scr/parser/KXml2SAXParser.java b/scr/src/main/java/org/apache/felix/scr/parser/KXml2SAXParser.java
index e8db250ed3..3808eb8a06 100644
--- a/scr/src/main/java/org/apache/felix/scr/parser/KXml2SAXParser.java
+++ b/scr/src/main/java/org/apache/felix/scr/parser/KXml2SAXParser.java
@@ -1,4 +1,4 @@
-/* 
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -31,23 +31,20 @@ import org.xmlpull.v1.XmlPullParserException;
  *
  */
 public class KXml2SAXParser extends KXmlParser {
-	
+
 	public String uri="uri";
 
-	private Reader reader;
-	
 	/**
 	* The constructor for a parser, it receives a java.io.Reader.
 	*
 	* @param   reader  The reader
-	* @throws XmlPullParserException 
+	* @throws XmlPullParserException
 	*/
 	public KXml2SAXParser(Reader reader) throws XmlPullParserException {
 		super();
-		this.reader=reader;
-	    setInput(reader);
+	    this.setInput(reader);
 	}
-	
+
 	/**
 	* Parser from the reader provided in the constructor, and call
 	* the startElement and endElement in a KxmlHandler
@@ -57,30 +54,30 @@ public class KXml2SAXParser extends KXmlParser {
 	*/
 	public void parseXML(KXml2SAXHandler handler) throws Exception {
 
-		while (next() != XmlPullParser.END_DOCUMENT) {
-			handler.setLineNumber(getLineNumber());
-			handler.setColumnNumber(getColumnNumber());
-			if (getEventType() == XmlPullParser.START_TAG) {
+		while (this.next() != XmlPullParser.END_DOCUMENT) {
+			handler.setLineNumber(this.getLineNumber());
+			handler.setColumnNumber(this.getColumnNumber());
+			if (this.getEventType() == XmlPullParser.START_TAG) {
 				Properties props = new Properties();
-				for (int i = 0; i < getAttributeCount(); i++) {
-					props.put(getAttributeName(i), getAttributeValue(i));
+				for (int i = 0; i < this.getAttributeCount(); i++) {
+					props.put(this.getAttributeName(i), this.getAttributeValue(i));
 				}
 				handler.startElement(
-					getNamespace(),
-					getName(),
-					getName(),
+					this.getNamespace(),
+					this.getName(),
+					this.getName(),
 					props);
-			} else if (getEventType() == XmlPullParser.END_TAG) {
-				handler.endElement(getNamespace(), getName(), getName());
-			} else if (getEventType() == XmlPullParser.TEXT) {
-				String text = getText();
+			} else if (this.getEventType() == XmlPullParser.END_TAG) {
+				handler.endElement(this.getNamespace(), this.getName(), this.getName());
+			} else if (this.getEventType() == XmlPullParser.TEXT) {
+				String text = this.getText();
 				handler.characters(text.toCharArray(),0,text.length());
-			} else if (getEventType() == XmlPullParser.PROCESSING_INSTRUCTION) {
+			} else if (this.getEventType() == XmlPullParser.PROCESSING_INSTRUCTION) {
 				// TODO extract the target from the evt.getText()
-				handler.processingInstruction(null,getText()); 
+				handler.processingInstruction(null,this.getText());
 			} else {
 				// do nothing
 			}
 		}
-	}	
+	}
 }
