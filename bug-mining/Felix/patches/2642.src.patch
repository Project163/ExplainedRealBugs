diff --git a/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java b/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
index 43a98607b0..a302a1a567 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/BundleComponentActivator.java
@@ -839,6 +839,16 @@ public class BundleComponentActivator implements ComponentActivator
             }
         }
     }
+    
+    public <T> boolean enterCreate(ServiceReference<T> serviceReference)
+    {
+        return m_componentRegistry.enterCreate(serviceReference);
+    }
+    
+    public <T> void leaveCreate(ServiceReference<T> serviceReference)
+    {
+        m_componentRegistry.leaveCreate(serviceReference);
+    }
 
     public <T> void missingServicePresent(ServiceReference<T> serviceReference)
     {
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
index e8c6ac58dc..f0f6950323 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/ComponentRegistry.java
@@ -471,21 +471,76 @@ public class ComponentRegistry
         // fall back: bundle is not considered active
         return false;
     }
+    
+    private final ThreadLocal<List<ServiceReference<?>>> circularInfos = new ThreadLocal<List<ServiceReference<?>>> (); 
+    
+    
+    public <T> boolean enterCreate(final ServiceReference<T> serviceReference)
+    {
+        List<ServiceReference<?>> info = circularInfos.get();
+        if (info == null) {
+            circularInfos.set(info = new ArrayList<ServiceReference<?>>());
+        }
+        if (info.contains(serviceReference))
+        {
+            m_logger.log(LogService.LOG_ERROR,
+                "Circular reference detected trying to get service {0}: stack of references: {1}",
+                new Object[] {serviceReference, info},
+                null);
+            return true;
+        }
+        m_logger.log(LogService.LOG_DEBUG,
+            "getService  {0}: stack of references: {1}",
+            new Object[] {serviceReference, info},
+            null);
+        info.add(serviceReference);
+        return false;
+    }
+    
+    public <T> void leaveCreate(final ServiceReference<T> serviceReference)
+    {
+        List<ServiceReference<?>> info = circularInfos.get();
+        if (info != null)
+        {
+            if (!info.isEmpty() && info.iterator().next().equals(serviceReference))
+            {
+                circularInfos.remove();
+            }
+            else
+            {
+                info.remove(serviceReference);
+            } 
+        }
+        
+    }
 
+    /**
+     * Schedule late binding of now-available reference on a different thread.  The late binding cannot occur on this thread
+     * due to service registry circular reference detection. We cannot wait for the late binding before returning from the initial
+     * getService call because of synchronization in the service registry.
+     * @param serviceReference
+     * @param actor
+     */
     public synchronized <T> void missingServicePresent( final ServiceReference<T> serviceReference, ComponentActorThread actor )
     {
         final List<Entry<?, ?>> dependencyManagers = m_missingDependencies.remove( serviceReference );
         if ( dependencyManagers != null )
         {
-            actor.schedule( new Runnable()
+            
+            Runnable runnable = new Runnable()
             {
 
+                @SuppressWarnings("unchecked")
                 public void run()
                 {
                     for ( Entry<?, ?> entry : dependencyManagers )
                     {
                         ((DependencyManager<?, T>)entry.getDm()).invokeBindMethodLate( serviceReference, entry.getTrackingCount() );
                     }
+                    m_logger.log(LogService.LOG_DEBUG,
+                        "Ran {0} asynchronously",
+                        new Object[] {this},
+                        null);
                 }
 
                 @Override
@@ -494,7 +549,12 @@ public class ComponentRegistry
                     return "Late binding task of reference " + serviceReference + " for dependencyManagers " + dependencyManagers;
                 }
 
-            } );
+            } ;
+            m_logger.log(LogService.LOG_DEBUG,
+                "Scheduling runnable {0} asynchronously",
+                new Object[] {runnable},
+                null);
+            actor.schedule( runnable );
         }
     }
 
@@ -503,6 +563,10 @@ public class ComponentRegistry
         //check that the service reference is from scr
         if ( serviceReference.getProperty( ComponentConstants.COMPONENT_NAME ) == null || serviceReference.getProperty( ComponentConstants.COMPONENT_ID ) == null )
         {
+            m_logger.log(LogService.LOG_DEBUG,
+                "Missing service {0} for dependency manager {1} is not a DS service, cannot resolve circular dependency",
+                new Object[] {serviceReference, dependencyManager},
+                null);
             return;
         }
         List<Entry<?, ?>> dependencyManagers = m_missingDependencies.get( serviceReference );
@@ -512,7 +576,11 @@ public class ComponentRegistry
             m_missingDependencies.put( serviceReference, dependencyManagers );
         }
         dependencyManagers.add( new Entry<S, T>( dependencyManager, trackingCount ) );
-    }
+        m_logger.log(LogService.LOG_DEBUG,
+            "Dependency managers {0} waiting for missing service {1}",
+            new Object[] {dependencyManagers, serviceReference},
+            null);
+        }
 
     private static class Entry<S,T>
     {
@@ -534,6 +602,12 @@ public class ComponentRegistry
         {
             return trackingCount;
         }
+        
+        @Override
+        public String toString() 
+        {
+            return dm.toString() + "@" + trackingCount;
+        }
     }
     
     private final ConcurrentMap<Long, RegionConfigurationSupport> bundleToRcsMap = new ConcurrentHashMap<Long, RegionConfigurationSupport>();
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentActivator.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentActivator.java
index 0d80bcfbe3..1ed7f4bb77 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentActivator.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/ComponentActivator.java
@@ -37,6 +37,10 @@ public interface ComponentActivator extends Logger, ExtendedServiceListenerConte
 
     void unregisterComponentId(AbstractComponentManager<?> sAbstractComponentManager);
 
+    <T> boolean enterCreate(ServiceReference<T> reference);
+
+    <T> void leaveCreate(ServiceReference<T> reference);
+
     <S, T> void registerMissingDependency(DependencyManager<S, T> dependencyManager,
                                               ServiceReference<T> serviceReference, int trackingCount);
 
diff --git a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
index 67e3983b14..b06ff761af 100644
--- a/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
+++ b/scr/src/main/java/org/apache/felix/scr/impl/manager/SingleComponentManager.java
@@ -67,8 +67,6 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
     // null if properties are not to be overwritten
     private Dictionary<String, Object> m_serviceProperties;
 
-    private final ThreadLocal<Boolean> m_circularReferences = new ThreadLocal<Boolean>();
-
    /**
      * The constructor receives both the activator and the metadata
      * @param componentMethods
@@ -315,7 +313,6 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
         else
         {
             componentContext.setImplementationAccessible( true );
-            m_circularReferences.remove();
             //this may cause a getService as properties now match a filter.
             setServiceProperties( result );
         }
@@ -835,13 +832,10 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
     @Override
     boolean getServiceInternal(ServiceRegistration<S> serviceRegistration)
     {
-        if (m_circularReferences.get() != null)
+        if ( serviceRegistration != null && getActivator().enterCreate(serviceRegistration.getReference()))
         {
-            log( LogService.LOG_ERROR,  "Circular reference detected, getService returning null", null );
-            dumpThreads();
             return false;
         }
-        m_circularReferences.set( Boolean.TRUE );
         try
         {
             boolean success = true;
@@ -850,15 +844,13 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
                 ComponentContextImpl<S> componentContext = new ComponentContextImpl<S>(this, this.getBundle(), serviceRegistration);
                 if ( collectDependencies(componentContext))
                 {
-                        log(
-                                LogService.LOG_DEBUG,
-                                "getService (single component manager) dependencies collected.",
-                                null );
+                    log( LogService.LOG_DEBUG,
+                        "getService (single component manager) dependencies collected.",
+                        null );
                 }
                 else
                 {
-                    log(
-                            LogService.LOG_INFO,
+                    log( LogService.LOG_INFO,
                             "Could not obtain all required dependencies, getService returning null",
                             null );
                     success = false;
@@ -889,8 +881,10 @@ public class SingleComponentManager<S> extends AbstractComponentManager<S> imple
         }
         finally
         {
-            //normally this will have been done after object becomes accessible.  This is double-checking.
-            m_circularReferences.remove();
+            if (serviceRegistration != null)
+            {
+                getActivator().leaveCreate(serviceRegistration.getReference());
+            }
         }
     }
 
diff --git a/scr/src/test/java/org/apache/felix/scr/integration/CircularReferenceTest.java b/scr/src/test/java/org/apache/felix/scr/integration/CircularReferenceTest.java
index 5b95e22e40..de33fe7d1b 100644
--- a/scr/src/test/java/org/apache/felix/scr/integration/CircularReferenceTest.java
+++ b/scr/src/test/java/org/apache/felix/scr/integration/CircularReferenceTest.java
@@ -290,9 +290,9 @@ public class CircularReferenceTest extends ComponentTestBase
         A a = bundleContext.getService( serviceReferenceA );
         assertNotNull( a );
         assertEquals( 1, a.getBs().size());
-  //test currently does not show desired result.              
-//        assertEquals( 1, b.getAs().size() );
-//        assertNotNull( b.getAs().get(0) );
+        delay();
+        assertEquals( 1, b.getAs().size() );
+        assertNotNull( b.getAs().get(0) );
 
     }
 }
