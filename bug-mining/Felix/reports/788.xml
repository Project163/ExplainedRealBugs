<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 15:14:56 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-1841] SCR invokes bind method twice when dependency service properties are modified</title>
                <link>https://issues.apache.org/jira/browse/FELIX-1841</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;p&gt;It seems that when a service S is depending on another service D, and when D service properties are modified (using ServiceRegistration.setProperties method), then D is &lt;br/&gt;
re-bound twice into the using service S.&lt;/p&gt;

&lt;p&gt;For example, I have a service &quot;Client&quot; has a &quot;1..1&quot; dependency over &quot;Service&quot;:&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
&amp;lt;component name=&quot;Client&quot;&amp;gt;&lt;br/&gt;
  &amp;lt;implementation class=&quot;client.Client&quot;/&amp;gt;&lt;br/&gt;
  &amp;lt;reference name=&quot;SERVICE&quot; &lt;br/&gt;
    interface=&quot;service.Service&quot;&lt;br/&gt;
    policy=&quot;dynamic&quot;&lt;br/&gt;
    cardinality=&quot;1..1&quot;&lt;br/&gt;
    target=&quot;(foo=bar)&quot;&lt;br/&gt;
    bind=&quot;bind&quot;/&amp;gt;&lt;br/&gt;
&amp;lt;/component&amp;gt;&lt;/p&gt;

&lt;p&gt;public class Client {&lt;br/&gt;
  protected void bind(Service s) &lt;/p&gt;
{
    System.out.println(&quot;Client:: bound Service : &quot; + s);
    Thread.dumpStack();
  }
&lt;p&gt;}&lt;/p&gt;



&lt;p&gt;I have another bundle which provide the &quot;Service&quot; dependency, and sometimes, the &quot;Service&quot; properties are modified like this:&lt;/p&gt;

&lt;p&gt;        ServiceRegistration reg ...&lt;br/&gt;
        reg.setProperties(...)&lt;/p&gt;

&lt;p&gt;So, when the setProperties takes place, &quot;Client&quot; is re-bound twice with the service &quot;Service&quot;.&lt;br/&gt;
Indeed, in DependencyManager, when a ServiceEvent.MODIFIED event. is caught, the following code is invoked (line 170):&lt;/p&gt;


&lt;p&gt;            case ServiceEvent.MODIFIED:&lt;br/&gt;
                m_componentManager.log( LogService.LOG_DEBUG, &quot;Dependency Manager: Updating &lt;/p&gt;
{0}
&lt;p&gt;&quot;, new Object[]&lt;br/&gt;
                    &lt;/p&gt;
{ serviceString }
&lt;p&gt;, null );&lt;/p&gt;

&lt;p&gt;                // remove the service first&lt;br/&gt;
                // only continue with further event handling if the service&lt;br/&gt;
                // removal did not cause the component to be deactivated&lt;br/&gt;
                if ( serviceRemoved( ref ) )&lt;br/&gt;
                {&lt;br/&gt;
                    // recalculate the number of services matching the filter&lt;br/&gt;
                    // because we don&apos;t know whether this service previously matched&lt;br/&gt;
                    // or not&lt;br/&gt;
                    ServiceReference refs[] = getFrameworkServiceReferences();&lt;br/&gt;
                    m_size = ( refs == null ) ? 0 : refs.length;&lt;/p&gt;

&lt;p&gt;                    // now try to bind the service - if it matches the target filter&lt;br/&gt;
                    // without recalculating the size (already done).&lt;br/&gt;
                    if ( targetFilterMatch( ref ) )&lt;/p&gt;
                    {
                        serviceAdded( ref );
                    }
&lt;p&gt;                }&lt;/p&gt;

&lt;p&gt;                break;&lt;/p&gt;

&lt;p&gt;So, the service is first re-bound to the Client, when the serviceRemoved() method is invoked (it&apos;s a bound service replacement, I guess).&lt;br/&gt;
But the problem here is that the modified service is also re-bound, when serviceAdded is invoked (line 189).&lt;br/&gt;
Don&apos;t you think that this is a bug and the service should be re-bound only once, not twice ?&lt;/p&gt;

&lt;p&gt;Here is the first stacktrace of the first bind:&lt;/p&gt;

&lt;p&gt;java.lang.Exception: Stack trace&lt;br/&gt;
        at java.lang.Thread.dumpStack(Thread.java:1158)&lt;br/&gt;
        at client.Client.bind(Client.java:13)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:592)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.invokeMethod(BaseMethod.java:213)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.access$500(BaseMethod.java:38)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod$Resolved.invoke(BaseMethod.java:542)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.invoke(BaseMethod.java:434)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.invokeBindMethod(DependencyManager.java:948)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.bind(DependencyManager.java:884)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.serviceRemoved(DependencyManager.java:367)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.serviceChanged(DependencyManager.java:177)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:878)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:732)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:662)&lt;br/&gt;
        at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:3587)&lt;br/&gt;
        at org.apache.felix.framework.Felix.access$000(Felix.java:40)&lt;br/&gt;
        at org.apache.felix.framework.Felix$1.serviceChanged(Felix.java:625)&lt;br/&gt;
        at org.apache.felix.framework.ServiceRegistry.servicePropertiesModified(ServiceRegistry.java:505)&lt;br/&gt;
        at org.apache.felix.framework.ServiceRegistrationImpl.setProperties(ServiceRegistrationImpl.java:116)&lt;br/&gt;
        at service.impl.ServiceFactory.run(ServiceFactory.java:48)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:595)&lt;/p&gt;

&lt;p&gt;and here is the second stacktrace, when Service is re-bound:&lt;/p&gt;

&lt;p&gt;Client: bound Service : service.impl.ServiceImpl@142a80d&lt;br/&gt;
java.lang.Exception: Stack trace&lt;br/&gt;
        at java.lang.Thread.dumpStack(Thread.java:1158)&lt;br/&gt;
        at client.Client.bind(Client.java:13)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:592)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.invokeMethod(BaseMethod.java:213)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.access$500(BaseMethod.java:38)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod$Resolved.invoke(BaseMethod.java:542)&lt;br/&gt;
        at org.apache.felix.scr.impl.helper.BaseMethod.invoke(BaseMethod.java:434)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.invokeBindMethod(DependencyManager.java:948)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.serviceAdded(DependencyManager.java:271)&lt;br/&gt;
        at org.apache.felix.scr.impl.manager.DependencyManager.serviceChanged(DependencyManager.java:189)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:878)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:732)&lt;br/&gt;
        at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:662)&lt;br/&gt;
        at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:3587)&lt;br/&gt;
        at org.apache.felix.framework.Felix.access$000(Felix.java:40)&lt;br/&gt;
        at org.apache.felix.framework.Felix$1.serviceChanged(Felix.java:625)&lt;br/&gt;
        at org.apache.felix.framework.ServiceRegistry.servicePropertiesModified(ServiceRegistry.java:505)&lt;br/&gt;
        at org.apache.felix.framework.ServiceRegistrationImpl.setProperties(ServiceRegistrationImpl.java:116)&lt;br/&gt;
        at service.impl.ServiceFactory.run(ServiceFactory.java:48)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:595)&lt;/p&gt;</description>
                <environment></environment>
        <key id="12439756">FELIX-1841</key>
            <summary>SCR invokes bind method twice when dependency service properties are modified</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fmeschbe">Felix Meschberger</assignee>
                                    <reporter username="pderop">Pierre De Rop</reporter>
                        <labels>
                    </labels>
                <created>Tue, 3 Nov 2009 12:45:38 +0000</created>
                <updated>Fri, 30 Jul 2010 11:42:05 +0000</updated>
                            <resolved>Thu, 26 Nov 2009 07:27:04 +0000</resolved>
                                    <version>scr-1.2.0</version>
                                    <fixVersion> scr-1.4.0</fixVersion>
                                    <component>Declarative Services (SCR)</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="12773264" author="pderop" created="Tue, 3 Nov 2009 23:00:24 +0000"  >&lt;p&gt;Felix,&lt;/p&gt;

&lt;p&gt;I&apos;m not sure, but it seems that the issue comes from the DependencyManager.ungetService(), which is wrongly invoked&lt;br/&gt;
from the DependencyManager.serviceRemoved() method:&lt;/p&gt;

&lt;p&gt;Let me try to explain:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The service &quot;Service&quot; is injected to &quot;Client&quot; service, which do have a (1..1) dependency over &quot;Service&quot;.&lt;/li&gt;
	&lt;li&gt;Then the &quot;Service&quot; service properties are updated.&lt;/li&gt;
	&lt;li&gt;So, in DependencyManager.java, the serviceChanged is called with a MODIFIED event:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;            case ServiceEvent.MODIFIED:&lt;br/&gt;
                m_componentManager.log( LogService.LOG_DEBUG, &quot;Dependency Manager: Updating &lt;/p&gt;
{0}&quot;, new Object[]&lt;br/&gt;
                    { serviceString }, null );&lt;br/&gt;
&lt;br/&gt;
                // remove the service first&lt;br/&gt;
                // only continue with further event handling if the service&lt;br/&gt;
                // removal did not cause the component to be deactivated&lt;br/&gt;
                if ( serviceRemoved( ref ) )&lt;br/&gt;
                {&lt;br/&gt;
                    // recalculate the number of services matching the filter&lt;br/&gt;
                    // because we don&apos;t know whether this service previously matched&lt;br/&gt;
                    // or not&lt;br/&gt;
                    ServiceReference refs[] = getFrameworkServiceReferences();&lt;br/&gt;
                    m_size = ( refs == null ) ? 0 : refs.length;&lt;br/&gt;
&lt;br/&gt;
                    // now try to bind the service - if it matches the target filter&lt;br/&gt;
                    // without recalculating the size (already done).&lt;br/&gt;
                    if ( targetFilterMatch( ref ) )&lt;br/&gt;
                    {
                        serviceAdded( ref );
                    }&lt;br/&gt;
                }&lt;br/&gt;
&lt;br/&gt;
- Here, the serviceRemoved method is then invoked, which ends up in doing a bound service replacement (line 358):&lt;br/&gt;
&lt;br/&gt;
            else&lt;br/&gt;
            {&lt;br/&gt;
&lt;br/&gt;
                // try to bind a replacement service first if this is a unary&lt;br/&gt;
                // cardinality reference and a replacement is available.&lt;br/&gt;
                if ( !m_dependencyMetadata.isMultiple() )&lt;br/&gt;
                {&lt;br/&gt;
                    // if the dependency is mandatory and no replacement is&lt;br/&gt;
                    // available, bind returns false and we deactivate&lt;br/&gt;
                    if ( !bind() )&lt;br/&gt;
                    {&lt;br/&gt;
                        m_componentManager&lt;br/&gt;
                            .log(&lt;br/&gt;
                                LogService.LOG_DEBUG,&lt;br/&gt;
                                &quot;Dependency Manager: Deactivating component due to mandatory dependency on {0}
&lt;p&gt;/&lt;/p&gt;
{1} not satisfied&quot;,&lt;br/&gt;
                                new Object[]&lt;br/&gt;
                                    { m_dependencyMetadata.getName(), m_dependencyMetadata.getInterface() }, null );&lt;br/&gt;
                        m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE );&lt;br/&gt;
&lt;br/&gt;
                        // required service could not be replaced, component&lt;br/&gt;
                        // is deactivated and we are done&lt;br/&gt;
                        return false;&lt;br/&gt;
                    }&lt;br/&gt;
                }&lt;br/&gt;
&lt;br/&gt;
                // call the unbind method if one is defined&lt;br/&gt;
                if ( m_dependencyMetadata.getUnbind() != null )&lt;br/&gt;
                {
                    invokeUnbindMethod( reference );
                }&lt;br/&gt;
&lt;br/&gt;
                // make sure the service is returned&lt;br/&gt;
                ungetService( reference );&lt;br/&gt;
            }&lt;br/&gt;
&lt;br/&gt;
- the &quot;if (!bind())&quot; line will re-bind &quot;Client&quot; to the same &quot;Service&quot; service, as &quot;Service&quot; properties are just modified (and &quot;Service&quot; is still present)&lt;br/&gt;
- The invokeUnbindMethod will then unbind the same service&lt;br/&gt;
- And the ungetService method will remove the bound service from the m_bound map -&amp;gt; but I think that this is the issue, because the map should contain the same &quot;Service&quot; service, which has just been re-bound, in the bind() method.&lt;br/&gt;
- So, let&apos;s follow up with the issue: the &quot;serviceAdded&quot; method is then called from the serviceChanged() method.&lt;br/&gt;
- The serviceAdded method will then attempt to bind the same service, line 268 (but we already did it from the serviceRemoved method), and here, the isBound() returns false because the m_bound map has been wrongly emptied previously.&lt;br/&gt;
&lt;br/&gt;
                // multiple bindings or not bound at all yet&lt;br/&gt;
                if ( m_dependencyMetadata.isMultiple() || !isBound() )&lt;br/&gt;
                {
                    // bind the service, getting it if required
                    invokeBindMethod( reference );
                }&lt;br/&gt;
            }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
So, I replaced the else bloc (line 358) with the following patch (which is attached to this issue): and the problem seems to disappear:&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
            // dynamic dependency, multiple or single but this service is the bound one&lt;br/&gt;
            else&lt;br/&gt;
            {&lt;br/&gt;
                boolean doUnget = true;&lt;br/&gt;
                &lt;br/&gt;
                // try to bind a replacement service first if this is a unary&lt;br/&gt;
                // cardinality reference and a replacement is available.&lt;br/&gt;
                if ( !m_dependencyMetadata.isMultiple() )&lt;br/&gt;
                {&lt;br/&gt;
                    // if the dependency is mandatory and no replacement is&lt;br/&gt;
                    // available, bind returns false and we deactivate&lt;br/&gt;
                    if ( !bind() )&lt;br/&gt;
                    {&lt;br/&gt;
                        m_componentManager&lt;br/&gt;
                            .log(&lt;br/&gt;
                                LogService.LOG_DEBUG,&lt;br/&gt;
                                &quot;Dependency Manager: Deactivating component due to mandatory dependency on {0}/{1}
&lt;p&gt; not satisfied&quot;,&lt;br/&gt;
                                new Object[]&lt;br/&gt;
                                    &lt;/p&gt;
{ m_dependencyMetadata.getName(), m_dependencyMetadata.getInterface() }
&lt;p&gt;, null );&lt;br/&gt;
                        m_componentManager.deactivateInternal( ComponentConstants.DEACTIVATION_REASON_REFERENCE );&lt;/p&gt;

&lt;p&gt;                        // required service could not be replaced, component&lt;br/&gt;
                        // is deactivated and we are done&lt;br/&gt;
                        return false;&lt;br/&gt;
                    }&lt;/p&gt;

&lt;p&gt;                    // Check if we have been rebound to the same (modified) service.&lt;br/&gt;
                    if (m_bound.size() == 1 &amp;amp;&amp;amp; getBoundService( reference ) != null)  &lt;/p&gt;
{
                        // the same (modified) service has been re-bound: don&apos;t unget.
                        doUnget = false;
                    }
&lt;p&gt;                }&lt;/p&gt;

&lt;p&gt;                // call the unbind method if one is defined&lt;br/&gt;
                if ( m_dependencyMetadata.getUnbind() != null )&lt;/p&gt;
                {
                    invokeUnbindMethod( reference );
                }

&lt;p&gt;                // make sure the service is returned.&lt;br/&gt;
                if (doUnget) &lt;/p&gt;
{
                    ungetService( reference );
                }
&lt;p&gt;            }&lt;/p&gt;


&lt;p&gt;Does this make sense to you ? Am I correct or did I miss something else ?&lt;/p&gt;


&lt;p&gt;Thanks;&lt;br/&gt;
/pierre&lt;/p&gt;</comment>
                            <comment id="12773334" author="fmeschbe" created="Wed, 4 Nov 2009 01:36:31 +0000"  >&lt;p&gt;Your are correct: The problem is that the serviceRemoved method correctly tries to bind another service to the component for the service that was &quot;removed&quot;. Now the problem is, that this is just the same service because it has not really been removed.&lt;/p&gt;

&lt;p&gt;This can probably be solved with your patch (I just glanced over it) &amp;#8211; the point is that we should not try to bind to the same service, we intend to unbind.&lt;/p&gt;

&lt;p&gt;The other problem in this concrete case is, that actually, we cannot unbind, check and rebind because the dependency is required and thus unbinding the service would actually (theoretically) require to take down the component  and reactivate component. And this is not what I would like to do in this case...&lt;/p&gt;

&lt;p&gt;Maybe I should really be doing more in the serviceChanged method handling the MODIFIED event: Check whether the service in question is actually bind and only if it is bound check whether the target filter still matches and ensure the service is removed if not matching anymore and doing nothing if not.&lt;/p&gt;

&lt;p&gt;But then: we would probably want to inform the client that the server has modified its properties, so rebinding is definitely the option to follow up on.&lt;/p&gt;

&lt;p&gt;Not sure right now ....&lt;/p&gt;</comment>
                            <comment id="12773406" author="pderop" created="Wed, 4 Nov 2009 07:41:20 +0000"  >&lt;p&gt;Ok. I do agree;&lt;/p&gt;

&lt;p&gt;Just calling back the &quot;Client&quot; in its bind method, when the &quot;Service&quot; properties are modified sounds like to be enough, and as you said, we don&apos;t really want to reactivate the &quot;Client ...&lt;/p&gt;

&lt;p&gt;I checked in the specification, but I did not find anything regarding this issue. &lt;br/&gt;
I think that this use case is a sub-set of the &quot;bound service replacement&quot; feature: the &quot;bind&quot; is called with the same service, but not the &quot;unbind&quot; ...&lt;/p&gt;

&lt;p&gt;For now, we&apos;ll use my patch in our application server, because, well, we really need it.&lt;/p&gt;

&lt;p&gt;thanks;&lt;br/&gt;
/pierre&lt;/p&gt;</comment>
                            <comment id="12774002" author="fmeschbe" created="Thu, 5 Nov 2009 17:53:32 +0000"  >&lt;p&gt;Good. If this works out for you. In the meantime I try to find out how we could solve this problem...&lt;/p&gt;</comment>
                            <comment id="12778118" author="fmeschbe" created="Sun, 15 Nov 2009 16:15:54 +0000"  >&lt;p&gt;Another proposed patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;If the service is not currently bound, bind if the filter matches and binding makes sense&lt;/li&gt;
	&lt;li&gt;If the service is currently bound, check whether the filter matches and bind if it matches.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12778154" author="pderop" created="Sun, 15 Nov 2009 19:03:19 +0000"  >&lt;p&gt;Felix,&lt;/p&gt;

&lt;p&gt;I have tested the patch for this issue and for the other &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1866&quot; title=&quot;SCR 1.1 restarts components when service properties are changed, even if &amp;quot;modified&amp;quot; attributed is specified&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1866&quot;&gt;&lt;del&gt;FELIX-1866&lt;/del&gt;&lt;/a&gt; issue.&lt;br/&gt;
Indeed, when the service properties are changed, no re-bind is attempted at all.&lt;/p&gt;

&lt;p&gt;But I am confused now and I realize that I did not initially state my problems clearly.&lt;br/&gt;
So, let me try to go to the right point and reformulate my problems:&lt;/p&gt;

&lt;p&gt;I have two problems:&lt;/p&gt;

&lt;p&gt;1) Using CM, When I update some public service properties (not starting with a &quot;.&quot;), I would like to re-bind&lt;br/&gt;
the modified service to the other components which depend on it (just once, not twice)&lt;/p&gt;

&lt;p&gt;2) When I update (using CM) only some private service properties (prefixed with a &quot;.&quot;), then I would like to get my&lt;br/&gt;
component called in its &quot;modified&quot; callback but the component should not be re-bound to other &lt;br/&gt;
components which depend on it, because the modified private properties are not supposed to be published &lt;br/&gt;
(see 112.6.1, in spec, am I correct ?)&lt;/p&gt;

&lt;p&gt;So, what do you think about the following strategy:&lt;/p&gt;

&lt;p&gt;1) add a &quot;else&quot; in your patch in order to re-bind once:&lt;/p&gt;

&lt;p&gt;                ...&lt;br/&gt;
                else if ( !targetFilterMatch( ref ) )&lt;br/&gt;
                &lt;/p&gt;
{
                    m_size--;
                    serviceRemoved( ref );
                }
&lt;p&gt; else &lt;/p&gt;
{
-&amp;gt;                bind(); // -&amp;gt; re-bind once.
                }

&lt;p&gt;2) in ImmediateComponentManager.java, around line 472 -&amp;gt; check if the properties modified from CM are private (start with a &quot;.&quot;) and don&apos;t invoke &quot;sr.setProperties( regProps )&quot; if modified properties are private.&lt;/p&gt;

&lt;p&gt;Does this make sense ?&lt;/p&gt;</comment>
                            <comment id="12778181" author="pderop" created="Sun, 15 Nov 2009 21:54:22 +0000"  >&lt;p&gt;Felix,&lt;br/&gt;
I tried to implement about what I was talking earlier.&lt;br/&gt;
Please review &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1841&quot; title=&quot;SCR invokes bind method twice when dependency service properties are modified&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1841&quot;&gt;&lt;del&gt;FELIX-1841&lt;/del&gt;&lt;/a&gt;.patch.2 (I probably missed something, but it seems to work).&lt;/p&gt;

&lt;p&gt;/pierre &lt;/p&gt;</comment>
                            <comment id="12781873" author="fmeschbe" created="Tue, 24 Nov 2009 11:21:15 +0000"  >&lt;p&gt;Applied the ImmediateComponentManager part of the Felix-1841.patch.2 supplied by Pierre de Rop (thanks alot) in Rev. 883652. This now prevents an update of the service registration  if the configuration update does not have an influence on the service registration (such as is the case if the configuration update only is for private properties)&lt;/p&gt;</comment>
                            <comment id="12782457" author="fmeschbe" created="Wed, 25 Nov 2009 14:53:34 +0000"  >&lt;p&gt;Commited the DependencyManager part of the patch in Rev. 884122 along with a series of integration tests verifying that the bind methods are not called without need.&lt;/p&gt;</comment>
                            <comment id="12782779" author="fmeschbe" created="Thu, 26 Nov 2009 07:27:04 +0000"  >&lt;p&gt;Applied a final patch to the DependencyManager in Rev. 884427. The component&apos;s bind method is now called from the DependencyManager.update(ServiceReference) method, which in turns diretcly uses the DependencyManager.invokeBindMethod(ServiceReference) method to call the corrent bind method with the correct service.&lt;/p&gt;

&lt;p&gt;This shoould finally resolve this issue.&lt;/p&gt;

&lt;p&gt;Yet, this starts another issue: Calling the bind method for an updated service reference is not technically completely correct. Rather a special method should be definable, which is called in case a service updates its service properties. This will be the goal of &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1893&quot; title=&quot;Add &amp;quot;update&amp;quot; callback support to inform components of modified service properties&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1893&quot;&gt;&lt;del&gt;FELIX-1893&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12894011" author="fmeschbe" created="Fri, 30 Jul 2010 11:42:05 +0000"  >&lt;p&gt;Closing since version is released.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12440695">FELIX-1866</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12423965" name="DependencyManager.java" size="45258" author="pderop" created="Tue, 3 Nov 2009 23:01:45 +0000"/>
                            <attachment id="12425006" name="FELIX-1841.patch" size="2872" author="fmeschbe" created="Sun, 15 Nov 2009 16:15:54 +0000"/>
                            <attachment id="12425032" name="FELIX-1841.patch.2" size="5516" author="pderop" created="Sun, 15 Nov 2009 21:54:22 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>57200</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            15 years, 17 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1arvb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>270981</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>