<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 15:50:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-1131] ServiceReference.isAssignableTo fails when using a factory that can not see the exported class and the bundle exporting the service does not have a direct wire to this class</title>
                <link>https://issues.apache.org/jira/browse/FELIX-1131</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;ul&gt;
	&lt;li&gt;bundle A defines an interface R and a class S in different packages, whith S implementing R&lt;/li&gt;
	&lt;li&gt;bundle B defines a class T extending S, it has an import statement on S package, but not on R package&lt;/li&gt;
	&lt;li&gt;bundle C defines a ServiceFactory that export T service without any import on any package from R, S, T&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;in this case, the line 426 of ServiceRegistrationImpl is executed:&lt;/p&gt;

&lt;p&gt;                       allow = getServiceRegistration().isClassAccessible(requestClass);&lt;/p&gt;

&lt;p&gt;which looks like:&lt;/p&gt;

&lt;p&gt;   protected boolean isClassAccessible(Class clazz)&lt;br/&gt;
   {&lt;br/&gt;
       try&lt;/p&gt;
       {
           // Try to load from the service object or service factory class.
           Class sourceClass = (m_factory != null)
               ? m_factory.getClass() : m_svcObj.getClass();
           Class targetClass = Util.loadClassUsingClass(sourceClass, clazz.getName());
           return (targetClass == clazz);
       }
&lt;p&gt;       catch (Exception ex)&lt;/p&gt;
       {
           // Ignore this and return false.
       }
&lt;p&gt;       return false;&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;So felix checks if the classloader used to load the factory can also load the interface, which is not the case in my example.&lt;br/&gt;
So isClassAccessible returns false and the event is not dispatched to the service listener.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12424812">FELIX-1131</key>
            <summary>ServiceReference.isAssignableTo fails when using a factory that can not see the exported class and the bundle exporting the service does not have a direct wire to this class</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rickhall">Richard S. Hall</assignee>
                                    <reporter username="gnodet">Guillaume Nodet</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 May 2009 12:51:02 +0000</created>
                <updated>Wed, 10 Jul 2013 09:55:54 +0000</updated>
                            <resolved>Tue, 9 Jul 2013 14:25:54 +0000</resolved>
                                    <version>framework-1.6.0</version>
                                    <fixVersion>framework-4.4.0</fixVersion>
                                    <component>Framework</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="12707049" author="rickhall" created="Thu, 7 May 2009 19:11:56 +0000"  >&lt;p&gt;The only thing we could do in this case is get the service object and test that, which loses lazy creation.&lt;/p&gt;

&lt;p&gt;The real question here is whether or not we should be forced to do this, since this example shows, it may not be sufficient to look at the factory class, since it could be registering something via reflection and may not be wired to the same definition of the package as the service object. In other words, we might always have to get the service object eagerly. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12707127" author="rickhall" created="Thu, 7 May 2009 21:25:16 +0000"  >&lt;p&gt;Thinking about this some more, I believe that even though service factories were not necessarily intended to address laziness, it is the case that this is a major use case nowadays (e.g., iPOJO, DS, etc.), so breaking this by eagerly getting the service object would be a mistake.&lt;/p&gt;

&lt;p&gt;The use case here is not particularly clear to me, but I would have to almost say it is invalid. The situation for the framework is that it needs to try to make some sort of good faith guarantee for the client that it won&apos;t get a class cast exception. It can only do this based on knowledge of the provider and the client.&lt;/p&gt;

&lt;p&gt;This use case basically hides the provider and wants to get a guarantee from the framework that everything will be okay for the client. That doesn&apos;t really seem possible. Is it possible that bundle C could register the service factory using the bundle context of whoever the actual provider is, which does have a wire for the package?&lt;/p&gt;</comment>
                            <comment id="12708924" author="gnt" created="Wed, 13 May 2009 13:49:33 +0000"  >&lt;p&gt;Just had a chat with Peter Kriens and B.J. about that and their answer was that the isAssignable should only fail if you &lt;b&gt;know&lt;/b&gt; that the classes are incompatible (wired to different packages).&lt;br/&gt;
So if the exporter has no wire to the package, we should just return true and not try to load the class at all.&lt;/p&gt;</comment>
                            <comment id="12708942" author="rickhall" created="Wed, 13 May 2009 14:27:39 +0000"  >&lt;p&gt;The JavaDoc sort of says the opposite, see #2 below:&lt;/p&gt;

&lt;p&gt;&quot;This method performs the following checks:&lt;br/&gt;
1 Get the package name from the specified class name.&lt;br/&gt;
2 For the bundle that registered the service referenced by this ServiceReference&lt;br/&gt;
(registrant bundle); find the source for the package. If no source is&lt;br/&gt;
found then return true if the registrant bundle is equal to the specified&lt;br/&gt;
bundle; otherwise return false.&lt;br/&gt;
3 If the package source of the registrant bundle is equal to the package&lt;br/&gt;
source of the specified bundle then return true; otherwise return false.&quot;&lt;/p&gt;</comment>
                            <comment id="12708945" author="gnt" created="Wed, 13 May 2009 14:32:46 +0000"  >&lt;p&gt;Well, my understanding of &quot;if no source if found then returns true&quot; is not really ambiguous.&lt;br/&gt;
IIUC, this is the case when no provider wire is found, so we should just return true.&lt;/p&gt;</comment>
                            <comment id="12708950" author="rickhall" created="Wed, 13 May 2009 14:44:55 +0000"  >&lt;p&gt;Yeah, if you can stop reading a sentence whenever you like you can probably make the spec bend to any interpretation. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The full sentence is:&lt;/p&gt;

&lt;p&gt;&quot;If no source is found then return true if the registrant bundle is equal to the specified bundle; otherwise return false.&quot;&lt;/p&gt;

&lt;p&gt;Notice the &quot;...return true if...&quot; portion.&lt;/p&gt;</comment>
                            <comment id="12709298" author="gnt" created="Thu, 14 May 2009 07:31:04 +0000"  >&lt;p&gt;Right.  This means the framework is more conservative.&lt;br/&gt;
 I guess this means we should then return false.  We still need to avoid the class loading imho.&lt;/p&gt;</comment>
                            <comment id="12709391" author="rickhall" created="Thu, 14 May 2009 13:17:21 +0000"  >&lt;p&gt;I agree we should avoid loading the class, so the question remains...how do you resolve your situation? It would be nice if we could find some way to improve the check, but I don&apos;t see how in this case. Even if you registered the factory using B&apos;s context, it wouldn&apos;t solve the issue if I understand correctly.&lt;/p&gt;</comment>
                            <comment id="12712302" author="rickhall" created="Fri, 22 May 2009 23:15:50 +0000"  >&lt;p&gt;So, can we close this?&lt;/p&gt;</comment>
                            <comment id="12718883" author="rickhall" created="Fri, 12 Jun 2009 15:41:41 +0000"  >&lt;p&gt;I am closing this for now. I think the current behavior is correct as far as the spec is concerned.&lt;/p&gt;</comment>
                            <comment id="13686445" author="gnt" created="Tue, 18 Jun 2013 06:41:15 +0000"  >&lt;p&gt;I have another use case which may be possibly improved.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;bundle A defines a package in version v1, exports it using a factory and registers a service with an interface from this package&lt;/li&gt;
	&lt;li&gt;bundle B defines the same package with version v2, exports it using a factory and registers a service with this pacakge&lt;/li&gt;
	&lt;li&gt;bundle C imports that package and grabs a service reference. Both references are deemed compatible by the framework&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The reason why this use case could be improved is that both bundles A and B can see the package and the service object is supposed to implement the interface.  So this is different from the original use case where the registrant bundle did not even see the package.&lt;br/&gt;
This checks is not performed because felix only verify imported packages, not exported packages.  I&apos;ll try to see if I can provide a patch.&lt;/p&gt;</comment>
                            <comment id="13686460" author="gnt" created="Tue, 18 Jun 2013 07:17:39 +0000"  >&lt;p&gt;In this use case, isAssignableTo falls into the case #3 (The provider does not have a wire for the package.) because the provider exports the package, but it&apos;s not the one imported, so both are incompatible.&lt;br/&gt;
So the getRegistration().isClassAccessible(requestClass) method is called but returns true because of the use of a factory.&lt;br/&gt;
I wonder if we could, even when using a factory, try to load the exposed class from the provider bundle and compare it with the requested one instead of simply returning true in that case.&lt;/p&gt;</comment>
                            <comment id="13686466" author="gnt" created="Tue, 18 Jun 2013 07:24:28 +0000"  >&lt;p&gt;Proposing the following patch which fixes the problem:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;diff --git a/framework/src/main/java/org/apache/felix/framework/ServiceRegistrationImpl.java b/framework/src/main/java/org/apache/felix/framework/ServiceRegistrationImpl.java
index b41d900..51571cf 100644
--- a/framework/src/main/java/org/apache/felix/framework/ServiceRegistrationImpl.java
+++ b/framework/src/main/java/org/apache/felix/framework/ServiceRegistrationImpl.java
@@ -165,6 +165,18 @@ &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ServiceRegistrationImpl &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; ServiceRegistration
             &amp;amp;&amp;amp; !((BundleReference) m_factory.getClass()
                 .getClassLoader()).getBundle().equals(m_bundle))
         {
+            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;
+            {
+                &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; providedClazz = m_bundle.loadClass(clazz.getName());
+                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (providedClazz != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
+                {
+                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; providedClazz == clazz;
+                }
+            }
+            &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException ex)
+            {
+                &lt;span class=&quot;code-comment&quot;&gt;// Ignore and &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;loaders.
&lt;/span&gt;+            }
             &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
         }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13686486" author="gnt" created="Tue, 18 Jun 2013 08:05:55 +0000"  >&lt;p&gt;Attached is a better diff which, in addition to checking imported packages, also checks exported packages and early succeed / fail when one bundle is importing and the other one exporting the same package.&lt;/p&gt;</comment>
                            <comment id="13686729" author="rickhall" created="Tue, 18 Jun 2013 13:54:35 +0000"  >&lt;p&gt;I don&apos;t think you can do short circuiting early based on whether the bundles export/import the package because you still have the case that the provider of the service factory is exporting the package, but is providing a service factory on behalf of another bundle.&lt;/p&gt;

&lt;p&gt;Also, I&apos;m confused about your scenario, since I don&apos;t know what &quot;exports it using a factory and registers a service with an interface from this package&quot; means.&lt;/p&gt;

&lt;p&gt;If your bundle exports a package and registers a service factory for a service object implementing an interface from that package, then it shouldn&apos;t be hitting case 2 in isClassAccessible() since that is for the case where the factory provider and the service registerer aren&apos;t the same bundle. It sounds like you should hit case 1 in isClassAccessible(), since your bundle is the creator of the service factory as well as the bundle context used to register the service factory. For case 1, we explicitly load the classes to determine whether to filter or not, which would then fail.&lt;/p&gt;

&lt;p&gt;So, perhaps I don&apos;t understand your scenario.&lt;/p&gt;</comment>
                            <comment id="13687753" author="gnt" created="Wed, 19 Jun 2013 08:10:10 +0000"  >&lt;p&gt;My use case is using blueprint which registers service factories on behalf of the extended bundle.&lt;/p&gt;

&lt;p&gt;When using service factories on behalf of other bundles, the extender is supposed to use the extended bundle context to register the services. If it doesn&apos;t, the class space consistency is lost. &lt;br/&gt;
As we can imagine the extender exporting a package and the extended bundle exporting the same package.  If the extender registers a service created for the extendee on its own bundle context (or the opposite), you&apos;ll soon hit a ClastCastException. &lt;/p&gt;

&lt;p&gt;On my patch, it&apos;s a short circuit only when the consumer and the provider have direct visibility (either import or export) on a package.  I don&apos;t see how things could go wrong here, because if both see the package, either it&apos;s the same and that&apos;s ok, or those are different and the consumer can&apos;t see the service, or one has no visibility and we use additional checks.  The use of service factories is irrelevant here, as we&apos;re considering the exposed classes, not the factory class, and only the consumer and provider exports, not the possible extender class space.&lt;/p&gt;


</comment>
                            <comment id="13687976" author="rickhall" created="Wed, 19 Jun 2013 13:26:56 +0000"  >&lt;p&gt;Ok, in your original description it was unclear that it was registering a service factory using the context of another bundle. So, yes, what you describe is case 2 in isClassAccessible().&lt;/p&gt;

&lt;p&gt;Unfortunately, we did have a case where the extender did have access to the service package, but it was different than the extendee, but it was still expected to inject. In this case, I don&apos;t remember if the extender was importing or exporting the service package. Consider a simple scenario of a log service, the extender may have access to the service, but it is not clear whether that should impact which log service the extendee can be injected with.&lt;/p&gt;

&lt;p&gt;This is the problem with service factories, we cannot know for certain unless we get the service object and check which class it is using.&lt;/p&gt;

&lt;p&gt;I feel that if we make the change you are proposing we&apos;ll just break the other case, so it is a question of which case should we break? Another possibility is to aggressively get the service object, but only in case 2.&lt;/p&gt;</comment>
                            <comment id="13698939" author="gnt" created="Wed, 3 Jul 2013 13:16:23 +0000"  >&lt;p&gt;Are you saying a bundle&apos;s context can be used to register services that are known incompatible with that bundle class space ?&lt;/p&gt;

&lt;p&gt;Because that&apos;s what your use case leads to, even if it&apos;s done through an extender and a service factory.  Actually, I think the current implementation allows registering such a service (even if not using an extender or a service factory), but that will certainly lead to a ClassCastException because the ServiceReference#isAssignableTo() check assumes that registered services are compatible with the bundle class space of the provider.&lt;/p&gt;</comment>
                            <comment id="13699002" author="rickhall" created="Wed, 3 Jul 2013 14:14:17 +0000"  >&lt;p&gt;I looked more closely at your patch and I don&apos;t really have any issues with it. It seems reasonable, so I&apos;ll commit it after I can run it against the CT. If we run across a degenerate case that fails with the patch, we&apos;ll address it at that time.&lt;/p&gt;</comment>
                            <comment id="13703320" author="rickhall" created="Tue, 9 Jul 2013 14:25:54 +0000"  >&lt;p&gt;I committed the patch after checking it against the R4.3 CT. Please close if satisfied, thanks.&lt;/p&gt;</comment>
                            <comment id="13704383" author="gnt" created="Wed, 10 Jul 2013 09:55:54 +0000"  >&lt;p&gt;Thx for applying the patch.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12588306" name="FELIX-1131.txt" size="6225" author="gnodet" created="Tue, 18 Jun 2013 08:05:55 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>57886</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 20 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0vw4v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>184179</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>