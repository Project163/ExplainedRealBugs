<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 15:42:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-3456] Component ignores required static service addition when in Activating state</title>
                <link>https://issues.apache.org/jira/browse/FELIX-3456</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;p&gt;I have a component with two required static service references (A and B). In my scenario A and B are registered nearly simultaneously on different threads and this causes the DependencyManager to ignore the addition of one of these two services (B). This causes the component to remain unsatisfied and never activate, since the service that was ignored is not re-registered at any time and nothing subsequently causes the component to re-activate.&lt;/p&gt;

&lt;p&gt;This happens as follows:&lt;br/&gt;
12:30:59:317 Thread 1 - Registers Service B/257&lt;br/&gt;
12:30:59:320 Thread 2 - Registers Service A/258&lt;br/&gt;
12:30:59:320 Thread 2 - Dependency Manager: Adding Service A/258&lt;br/&gt;
12:30:59:321 Thread 2 - Dependency Manager: Service serviceA registered, activate component&lt;br/&gt;
12:30:59:321 Thread 2 - State transition : Unsatisfied -&amp;gt; Activating&lt;br/&gt;
12:30:59:321 Thread 2 - Activating component&lt;br/&gt;
12:30:59:321 Thread 1 - Dependency Manager: Adding Service B/257&lt;br/&gt;
12:30:59:321 Thread 2 - Dependency not satisfied: serviceB&lt;br/&gt;
12:30:59:321 Thread 1 - Dependency Manager: Added service serviceB is ignored for static reference &amp;lt;--- I believe we end up here because Thread 2 has moved the component from Unsatisfied to Activating and the reference is a static reference&lt;br/&gt;
12:30:59:321 Thread 2 - Not all dependencies satisified, cannot activate&lt;br/&gt;
12:30:59:321 Thread 2 - State transition : Activating -&amp;gt; Unsatisfied&lt;/p&gt;

&lt;p&gt;Because the addition of Service B has been ignored and serviceB is a required dependency my component then never activates even though my reqiured service is present.&lt;/p&gt;

&lt;p&gt;There is a comment in DependencyManager#serviceAdded method:&lt;br/&gt;
// &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1413&quot; title=&quot;Newly registered services must not immediately bound for static references&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1413&quot;&gt;&lt;del&gt;FELIX-1413&lt;/del&gt;&lt;/a&gt;: if the dependency is static and the component is&lt;br/&gt;
// satisfied (active) added services are not considered until&lt;br/&gt;
// the component is reactivated for other reasons.&lt;/p&gt;

&lt;p&gt;This suggests that the static service should only be ignored if the component is satisfied(active), which would be correct, but in this case the component is only activating (and will fail to activate because one of the two dependencies is not yet satisfied) and there is no check of state at this time.&lt;br/&gt;
A simple fix would be to check the state of the component as well as if the service is static e.g.&lt;br/&gt;
replace if ( m_dependencyMetadata.isStatic() )&lt;br/&gt;
with if ( m_dependencyMetadata.isStatic() &amp;amp;&amp;amp; m_componentManager.getState() == AbstractComponentManager.STATE_ACTIVE )&lt;/p&gt;

&lt;p&gt;This is an easy fix, but I guess may leave a small window where a static reference could get replaced while a component was still activating if another instance of the same service was registered on a different thread.&lt;br/&gt;
There are other fixes that could be done by synchronizing more around service additions.&lt;/p&gt;

&lt;p&gt;Is anyone willing to make this fix or does anyone have any thoughts about this issue?&lt;br/&gt;
Thanks&lt;/p&gt;</description>
                <environment>Using org.apache.felix.scr svn rev 1298268 on Mac</environment>
        <key id="12550715">FELIX-3456</key>
            <summary>Component ignores required static service addition when in Activating state</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="djencks">David Jencks</assignee>
                                    <reporter username="ricellis">Richard Ellis</reporter>
                        <labels>
                    </labels>
                <created>Thu, 12 Apr 2012 17:00:27 +0000</created>
                <updated>Tue, 20 Nov 2012 10:58:17 +0000</updated>
                            <resolved>Fri, 5 Oct 2012 18:42:30 +0000</resolved>
                                    <version> scr-1.6.0</version>
                                    <fixVersion>scr-1.6.2</fixVersion>
                                    <component>Declarative Services (SCR)</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="13252637" author="djencks" created="Thu, 12 Apr 2012 17:38:20 +0000"  >&lt;p&gt;After a very brief look I don&apos;t understand how this would result in correct behavior.  I think that if the state is &quot;activating&quot; we would need to wait until it gets back to &quot;unsatisfied&quot; and then try activateInternal again.  Otherwise won&apos;t we be binding the service but not checking if all the activation conditions are met?  What will check and get the service to activate if all the conditions are now met?  How about if there are 3 required services and we only have 2 of them?&lt;/p&gt;

&lt;p&gt;I think we need some thread synchronization and if the state is not unsatisified or active wait until it gets to one of those before proceeding.&lt;/p&gt;

&lt;p&gt;As I said this is after a very brief look, please think carefully before agreeing with me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13252653" author="ricellis" created="Thu, 12 Apr 2012 17:47:30 +0000"  >&lt;p&gt;On second thoughts I&apos;m not sure my proposed fix goes far enough because even though it allows the second service to attempt to be bound, there is no guarantee that this bind operation will complete in a timely enough fashion for the activate process triggered by the first service to complete successfully. I think some synchronization will probably be required.&lt;/p&gt;</comment>
                            <comment id="13252655" author="ricellis" created="Thu, 12 Apr 2012 17:50:01 +0000"  >&lt;p&gt;If only my browser had refreshed faster I could have agreed with you already David instead of disagreeing with myself &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I do agree David, my hasty attempt at a fix without a full understanding of the code is not correct.&lt;/p&gt;</comment>
                            <comment id="13253191" author="djencks" created="Fri, 13 Apr 2012 07:15:26 +0000"  >&lt;p&gt;This synchronized some state changes in Componentmanager and uses an AtomicInteger for DependencyManager.size.  I realize that using modern concurrency techniques is going to require some debate &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; but I&apos;m putting this out for review and testing.&lt;/p&gt;</comment>
                            <comment id="13253605" author="fmeschbe" created="Fri, 13 Apr 2012 18:20:00 +0000"  >&lt;p&gt;Thanks for reporting. This is in fact an issue.&lt;/p&gt;

&lt;p&gt;I am not against replacing the size int by an AtomicInteger; in the interest of concurrency stability this might make sense. (though this might prevent SCR from being used in pre-Java 5 setups; we still consider this requirement valid for SCR)&lt;/p&gt;

&lt;p&gt;But I am not convinced with the state lock. This going to be dangerous for deadlocks because during activate and deactive services may be registered or unregistered, which may cause deadlocks: We currently have one single situation where we synchronize (creation of delayed component service instances) and we realize occasional deadlocks.&lt;/p&gt;

&lt;p&gt;Thinking the other way around: We have some transient states during which events may happen which may get lost. One such transient state is the activating state. And this is such an event which may get lost. Another event may be a configuration update.&lt;/p&gt;

&lt;p&gt;I have been contemplating some kind of event queuing and some way of processing such a queue when leaving the transient state.&lt;/p&gt;

&lt;p&gt;In the concrete example:&lt;/p&gt;

&lt;p&gt;T1 registers Service A, causes component into the ACTIVATING state&lt;br/&gt;
T2 registers Service B, enqueues event since component is ACTIVATING&lt;br/&gt;
T1 terminates ACTIVATING, checks queue and handles event.&lt;/p&gt;

&lt;p&gt;The queue could be as simple as a list of Runnable on each component manager.&lt;/p&gt;</comment>
                            <comment id="13253938" author="djencks" created="Sat, 14 Apr 2012 02:13:47 +0000"  >&lt;p&gt;Just in case anyone was wondering, as I was, I checked the spec and (4.3 section 5.3) all service events must be delivered synchronously.  Thus there is definitely a possibility of deadlocks if we&apos;re not careful (more careful than my patch).&lt;/p&gt;

&lt;p&gt;A colleague tried a completely asynchronous model for service events in scr and although start seemed to work, stopping resulted in a lot of work on stopped bundles and component objects.  I think if we can convince ourselves that it conforms to the spec this is a viable approach but it will take quite a bit of work to identify all the cases where we&apos;re working with closed stuff.&lt;/p&gt;

&lt;p&gt;I wonder to what extent we can remove the deadlock scenarios by&lt;br/&gt;
(a) avoiding the synchronized block entirely when possible.  For instance the first place we found this, DependencyManager.serviceAdded, I think we can skip the block I synchronized if the dependency is not mandatory, because if its not mandatory it showing up can&apos;t result in service activation.&lt;br/&gt;
(b) avoiding calling out, such as the bind and unbind methods, from a synchronized block.  This might be a wacky and non-plausible idea....  We might have an internal and external state.  for instance:&lt;/p&gt;

&lt;p&gt;thread 1 supplies service A&lt;br/&gt;
thread 1 gets the lock and updates internal and external state to &quot;activating&quot;&lt;br/&gt;
thread 2 supplies service B and can&apos;t get the lock&lt;br/&gt;
thread 1 does the calculations in Unsatisfied.activate up to the point where it calls out to the bind methods, and then updates the internal state to &quot;active&quot; and releases the lock&lt;br/&gt;
thread 2 gets the lock and sees the internal state is &quot;active&quot; so it doesn&apos;t do much except release the lock&lt;br/&gt;
thread 1 finishes calling the bind methods and updates the external state to &quot;active&quot;.&lt;/p&gt;</comment>
                            <comment id="13254080" author="fmeschbe" created="Sat, 14 Apr 2012 11:15:06 +0000"  >&lt;p&gt;&amp;gt; A colleague tried a completely asynchronous model for service events in scr and although start seemed to work,&lt;br/&gt;
&amp;gt; stopping resulted in a lot of work on stopped bundles and component objects&lt;/p&gt;

&lt;p&gt;Been there done that ... SCR was fully asynchronous at one point in time.&lt;/p&gt;

&lt;p&gt;Stopping failed miserably because services have been gone when the component was about to be stopped and expected statically bound services to still be available.&lt;/p&gt;

&lt;p&gt;Startup worked correctly and the spec does not favor one or the other (I think there is nothing about synchronicity in the spec). I converted to synchronous startup to have better control during system startup (namely to have all components activated when the FRAMEWORK_STARTED event is fired by the framework). In fact, it is quite nice to have all components fuly handled once the bundle&apos;s STARTED or STOPPED event is fired. (This is one of my concerns with blueprint which is asynchronous and makes it hard to reason about system state).&lt;/p&gt;

&lt;p&gt;Overall and in hindsight it looks like synchronous startup is preferable to asynchronous startup.&lt;/p&gt;

&lt;p&gt;BTW: The last time I checked, Equinox DS was also fully synchronous.&lt;/p&gt;

&lt;p&gt;&amp;gt; We might have an internal and external state.&lt;/p&gt;

&lt;p&gt;In your proposal thread 2 waits for the lock and thus thread 1 and thread 2 are susceptive to deadlocks. Particularly if you take another service into account .... The reason for this is, that when a service is supplied we are called back from the framework and thus have to be extremely carefull since the framework may still hold locks (for example bundle locks during bundle start)&lt;/p&gt;</comment>
                            <comment id="13256125" author="djencks" created="Wed, 18 Apr 2012 01:19:53 +0000"  >&lt;p&gt;This implementation synchronizes larger chunks of code and uses locks so that a possible deadlock will timeout.  The idea is to have a queue of work to do.  A thread will add its work to the queue and try to get the lock if it doesn&apos;t already have it.  If it succeeds within the timeout then it will run all the work items in the queue.&lt;/p&gt;

&lt;p&gt;I believe this means that unless there is a timeout, the work will complete before the thread returns.  The work may get done on a different thread.&lt;/p&gt;</comment>
                            <comment id="13257339" author="djencks" created="Thu, 19 Apr 2012 07:41:48 +0000"  >&lt;p&gt;This uses the same idea as the previous patch but fully synchronizes the enable and disable methods and the service factory getService and ungetService methods.&lt;/p&gt;</comment>
                            <comment id="13263274" author="fraenkel" created="Fri, 27 Apr 2012 00:32:02 +0000"  >&lt;p&gt;The first patch needs to synchronize access when retrieving the actual Service.&lt;br/&gt;
There is a race when a component is activated and then registers its service.  If you have multiple dependents, one of them can request the service before it completes all binds.  Logically, the transition to REGISTERED is not complete until the service has completed registration.&lt;/p&gt;</comment>
                            <comment id="13269001" author="fmeschbe" created="Sat, 5 May 2012 16:32:30 +0000"  >&lt;p&gt;Here is a patch following my earlier proposal with an added delay to give the component a chance to settle on a steady state.&lt;/p&gt;

&lt;p&gt;This implements the activate, deactivate and disable methods in the Activating state which is the transient state active while the component is being activated in the Unsatisifed.activate method.&lt;/p&gt;

&lt;p&gt;These implementations delay for 500ms and check the current state again (whether it is still Activating). If not, the original call is tried again on the AbstractComponentManager. If still Activating, a Runnable is enqueued which calls the original method again on the AbstractComponentManager.&lt;/p&gt;

&lt;p&gt;The Unsatisifed.activate method checks whether there are any enqueued Runnable instances and executes them one after the other, if so.&lt;/p&gt;

&lt;p&gt;This patch has a slight problem: It may treat reactivation (deactivate-then-activate) incorrectly in that deactivate might be enqueued while activate might be called directly. This could be solved by introducing a new reactivate method comprising both state transitions.&lt;/p&gt;</comment>
                            <comment id="13274780" author="djencks" created="Mon, 14 May 2012 17:37:21 +0000"  >&lt;p&gt;I&apos;m afraid I don&apos;t think the approach in &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-3456&quot; title=&quot;Component ignores required static service addition when in Activating state&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-3456&quot;&gt;&lt;del&gt;FELIX-3456&lt;/del&gt;&lt;/a&gt;-fmeschbe.patch is workable.   I have 3 main objections:&lt;/p&gt;

&lt;p&gt;1. I don&apos;t think it is acceptable to return from a event that might have changed the state without doing the work.  Thus I don&apos;t think any asynchronous processing is acceptable unless specifically mandated by the spec (as for enable/disable).  One of my suggestions had a similar &quot;queue work we can&apos;t do right now&quot; approach and the results were too unpredictable.&lt;/p&gt;

&lt;p&gt;2. A hardcoded wait time is a bad solution to the problem.  You can avoid the fixed wait by using a lock with a timeout.  Also this is a radically out of order proposal.  In the half-second the state may have gone back and forth between e.g. active and inactive and enabled and disabled many times.&lt;/p&gt;

&lt;p&gt;3. If you replace the delayAndCheck with a lock, or regard it as a new style of lock, the locks are too small.  The locks should be around the entire event processing.  The only part of the processing that can take any time is calling out to the framework and config admin, which has to happen in the locked region anyway.  So locking the entire event processing won&apos;t take any longer and will make the effect of the code more possible to understand.&lt;/p&gt;</comment>
                            <comment id="13275116" author="djencks" created="Tue, 15 May 2012 01:24:23 +0000"  >&lt;p&gt;Here&apos;s my latest suggestion.  This involves using java 5 concurrency.  We can discuss how to handle backwards compatibility but lets decide on the code changes first.&lt;/p&gt;

&lt;p&gt;the 5a patch removes the *ing states which won&apos;t really be visible except accidentally due to locking, and makes the enable/activate and disable/deactivate happen per spec as enable/disable immediate and activate/deactivate asynchronous.&lt;/p&gt;

&lt;p&gt;the 5b patch uses a fair reentrant lock with timeout exception around the large-scale events that can change state.&lt;/p&gt;

&lt;p&gt;the 5 patch combines 5a and 5b.&lt;/p&gt;

&lt;p&gt;Since attach-file isn&apos;t working right now I&apos;ve uploaded the diffs to&lt;br/&gt;
&lt;a href=&quot;https://people.apache.org/~djencks/FELIX-3456-5a.diff&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://people.apache.org/~djencks/FELIX-3456-5a.diff&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://people.apache.org/~djencks/FELIX-3456-5b.diff&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://people.apache.org/~djencks/FELIX-3456-5b.diff&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://people.apache.org/~djencks/FELIX-3456-5.diff&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://people.apache.org/~djencks/FELIX-3456-5.diff&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13276047" author="djencks" created="Tue, 15 May 2012 17:48:02 +0000"  >&lt;p&gt;I think these are an OK solution to the concurrency problems.  They use java 5 concurrency and don&apos;t yet address pre-1.5 compatibility.&lt;/p&gt;</comment>
                            <comment id="13277809" author="fmeschbe" created="Thu, 17 May 2012 13:51:20 +0000"  >&lt;p&gt;&amp;gt; makes the enable/activate and disable/deactivate happen per spec as&lt;br/&gt;
&amp;gt; enable/disable immediate and activate/deactivate asynchronous. &lt;/p&gt;

&lt;p&gt;As I said before, these are already asynchronous because the BundleComponentActivator.enableComponent and .disableComponent schedule the actual call to activateInternal and deactivateInternal for asynchronous execution.&lt;/p&gt;</comment>
                            <comment id="13278354" author="djencks" created="Thu, 17 May 2012 22:31:04 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; makes the enable/activate and disable/deactivate happen per spec as&lt;br/&gt;
&amp;gt;&amp;gt; enable/disable immediate and activate/deactivate asynchronous.&lt;/p&gt;

&lt;p&gt;&amp;gt;As I said before, these are already asynchronous because the BundleComponentActivator.enableComponent and .disableComponent schedule the actual call to activateInternal and deactivateInternal for asynchronous execution. &lt;/p&gt;

&lt;p&gt;The activate/deactivate were already asynchronous but the enable/disable were too, which is contrary to the spec and IMO a pretty bad idea.  This part of my change is to separate the enable from activate and disable from deactivate.  I think we haven&apos;t heard of problems only because no one uses this much.  But, maybe the requirement in the spec just makes no sense and I don&apos;t see why yet.&lt;/p&gt;</comment>
                            <comment id="13279226" author="fmeschbe" created="Fri, 18 May 2012 21:46:53 +0000"  >&lt;p&gt;Modified patch 5:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Use Doug Lea&apos;s ReentrantLock from his concurrent library. Is also embedded in the final bundle.&lt;/li&gt;
	&lt;li&gt;The satisfied state has to be set before creating the component in the Unsatisified.activate method. Otherwise a stack overflow may happen (if the component registers services in the activator to which it has a reference).&lt;/li&gt;
	&lt;li&gt;Slight fix to the AbstractComponentManager.getSatisfiedState method due to moved state change (see above) for ComponentFactory component instances.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I checked this patch with our application, which seems to work.&lt;/p&gt;

&lt;p&gt;I am still not fully convinced with locking and throwing. On the other hand this gives log messages in case of concurrency issues as opposed to today, where such issues are not recognized/recorded.&lt;/p&gt;

&lt;p&gt;In the end I think, I can live with this patch now.&lt;/p&gt;

&lt;p&gt;Does it fix your problem ?&lt;/p&gt;</comment>
                            <comment id="13280662" author="djencks" created="Tue, 22 May 2012 01:04:59 +0000"  >&lt;p&gt;I like most of your patch and appreciate your fixing the sync enable for default-enabled components.&lt;/p&gt;

&lt;p&gt;There are still a couple problems:&lt;br/&gt;
1. I&apos;d like a fair reentrant lock, doug lea&apos;s original doesn&apos;t appear to be fair.  I tried to use the emory dcl backport-util-concurrent which does implement a fair lock but AFAICT it would require exporting sun.misc from the framework which I don&apos;t think is acceptable.  So, I implemented something I think will work where the java.util.concurrent reentrant lock is used if available and if not doug lea&apos;s unfair lock.&lt;/p&gt;

&lt;p&gt;2. There were some problems around state change and trying to activate while binding services.  Basically the solution to 3317 is no longer relevant and we can simplify the code a bit more.  The state change to Active has to happen earlier before checking the dependency managers or you always get the component created several times, registered, and then unregistered.  We have enough locking already &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13280664" author="djencks" created="Tue, 22 May 2012 01:05:43 +0000"  >&lt;p&gt;oops, 7 is the full patch, 7a is a diff from your -6 patch.&lt;/p&gt;</comment>
                            <comment id="13286524" author="fmeschbe" created="Thu, 31 May 2012 12:29:21 +0000"  >&lt;p&gt;&amp;gt; So, I implemented something I think will work where the java.util.concurrent&lt;br/&gt;
&amp;gt; reentrant lock is used if available and if not doug lea&apos;s unfair lock.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; Basically the solution to 3317 is no longer relevant and we can simplify the code a bit more.&lt;/p&gt;

&lt;p&gt;Right.&lt;/p&gt;</comment>
                            <comment id="13286547" author="fmeschbe" created="Thu, 31 May 2012 13:07:20 +0000"  >&lt;p&gt;I have commited the final patch 7 in Rev. 1344701&lt;/p&gt;

&lt;p&gt;Tests still pass. Please verify in your environment. Thanks.&lt;/p&gt;</comment>
                            <comment id="13295973" author="djencks" created="Fri, 15 Jun 2012 22:41:02 +0000"  >&lt;p&gt;We&apos;re finding some deadlocks with the current code.   Following some suggestions from Michael Fraenkel, I changed to a read-write lock for creating the component instance and a CAS strategy for registering the service.  This patch is not complete, it doesn&apos;t deal with ServiceFactory or (I think) ComponentFactory and I didn&apos;t implement the backwards compatible lock wrapper yet, but I&apos;m putting it out for comments anyway.&lt;/p&gt;</comment>
                            <comment id="13396397" author="djencks" created="Tue, 19 Jun 2012 00:09:35 +0000"  >&lt;p&gt;same result as previous patch but applies to current trunk.  I&apos;m not sure how to functionally improve this, I&apos;m tempted to suggest applying it.&lt;/p&gt;</comment>
                            <comment id="13470539" author="djencks" created="Fri, 5 Oct 2012 18:42:30 +0000"  >&lt;p&gt;This problem is fixed, although there are other concurrency problems remaining.&lt;/p&gt;</comment>
                            <comment id="13501048" author="fmeschbe" created="Tue, 20 Nov 2012 10:58:16 +0000"  >&lt;p&gt;Close after release&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12524796" name="FELIX-3456-1.1.diff" size="1524" author="fraenkel" created="Fri, 27 Apr 2012 00:32:02 +0000"/>
                            <attachment id="12522537" name="FELIX-3456-1.diff" size="16101" author="djencks" created="Fri, 13 Apr 2012 07:15:25 +0000"/>
                            <attachment id="12523061" name="FELIX-3456-3.diff" size="24498" author="djencks" created="Wed, 18 Apr 2012 01:19:53 +0000"/>
                            <attachment id="12523313" name="FELIX-3456-4.diff" size="28863" author="djencks" created="Thu, 19 Apr 2012 07:41:39 +0000"/>
                            <attachment id="12527477" name="FELIX-3456-5.diff" size="55495" author="djencks" created="Tue, 15 May 2012 17:48:02 +0000"/>
                            <attachment id="12527478" name="FELIX-3456-5a.diff" size="25273" author="djencks" created="Tue, 15 May 2012 17:48:02 +0000"/>
                            <attachment id="12527479" name="FELIX-3456-5b.diff" size="34520" author="djencks" created="Tue, 15 May 2012 17:48:02 +0000"/>
                            <attachment id="12528543" name="FELIX-3456-7.diff" size="70093" author="djencks" created="Tue, 22 May 2012 01:04:59 +0000"/>
                            <attachment id="12528544" name="FELIX-3456-7a.diff" size="12720" author="djencks" created="Tue, 22 May 2012 01:04:59 +0000"/>
                            <attachment id="12532254" name="FELIX-3456-8.diff" size="58199" author="djencks" created="Fri, 15 Jun 2012 22:41:02 +0000"/>
                            <attachment id="12532484" name="FELIX-3456-8a.diff" size="57258" author="djencks" created="Tue, 19 Jun 2012 00:09:35 +0000"/>
                            <attachment id="12528173" name="FELIX-3456-fmeschbe-6.patch" size="58271" author="fmeschbe" created="Fri, 18 May 2012 21:46:53 +0000"/>
                            <attachment id="12525732" name="FELIX-3456-fmeschbe.patch" size="9420" author="fmeschbe" created="Sat, 5 May 2012 16:32:29 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>13.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>235579</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 1 week, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i05fj3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29613</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>