<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 15:10:09 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-1185] If a static/mandatory reference to a service is unregistered, the component should be deactivated synchronously instead of asynchronously</title>
                <link>https://issues.apache.org/jira/browse/FELIX-1185</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;p&gt;In the specification cmpn 112.3.3 Reference Policy, it says &quot;Component configurations are deactivated before any bound service for a reference having a static policy becomes unavailable.&quot;&lt;/p&gt;

&lt;p&gt;My understanding is the deactivate method of the component must be called before any unbind method for a static/mandatory reference is called. And it&apos;s reasonable for a static/mandatory reference to be still available in the deactivate method.&lt;/p&gt;

&lt;p&gt;If the component is deactivated asynchronously when a static/mandatory reference to a service is unregistered, then it&apos;s possible that the unbind method is called before the deactivate method is called, which makes the service unavailable in the deactivate method.&lt;/p&gt;

&lt;p&gt;This bug may relate to &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1178&quot; title=&quot;Component may remain deactivated after a reference has been unregistered and registered again&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1178&quot;&gt;&lt;del&gt;FELIX-1178&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The fix for this bug should also fix &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1178&quot; title=&quot;Component may remain deactivated after a reference has been unregistered and registered again&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1178&quot;&gt;&lt;del&gt;FELIX-1178&lt;/del&gt;&lt;/a&gt;. No need to add a new flag.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12426553">FELIX-1185</key>
            <summary>If a static/mandatory reference to a service is unregistered, the component should be deactivated synchronously instead of asynchronously</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fmeschbe">Felix Meschberger</assignee>
                                    <reporter username="agemocui">Agemo Cui</reporter>
                        <labels>
                    </labels>
                <created>Thu, 28 May 2009 05:13:51 +0000</created>
                <updated>Fri, 31 Jul 2009 15:07:36 +0000</updated>
                            <resolved>Wed, 3 Jun 2009 13:18:32 +0000</resolved>
                                    <version>scr-1.0.8</version>
                                    <fixVersion>scr-1.2.0</fixVersion>
                                    <component>Declarative Services (SCR)</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="12713987" author="agemocui" created="Thu, 28 May 2009 14:29:40 +0000"  >&lt;p&gt;Sorry, the description of the problem is not quite correct.&lt;br/&gt;
The unbind method does be called after the deactivate method is called.&lt;/p&gt;

&lt;p&gt;The problem is the component is deactivated after the mandatory dependency component is deactivated.&lt;br/&gt;
That is to say, a bound service for a reference having a static policy becomes unavailable before the component is deactivated.&lt;/p&gt;

&lt;p&gt;For example, component A is dependent on component B. And component A is disposed before component B is disposed.&lt;br/&gt;
Since the tasks of disposing components are queued, component A is always deactivated before component B is deactivated. So when the deactivate method of B is called, component A has already been unavailable.&lt;/p&gt;</comment>
                            <comment id="12713989" author="agemocui" created="Thu, 28 May 2009 14:33:59 +0000"  >&lt;p&gt;Sorry, correct the example.&lt;/p&gt;

&lt;p&gt;Component A is dependent on component B.&lt;br/&gt;
And component B is disposed before component A.&lt;/p&gt;

&lt;p&gt;So when the deactivate method of A is called, component B has already been disposed and has become unavailable, which means component B cannot be used in the deactivate method of A.&lt;/p&gt;</comment>
                            <comment id="12713994" author="fmeschbe" created="Thu, 28 May 2009 14:51:04 +0000"  >&lt;p&gt;Thanks for reporting this issue.&lt;/p&gt;

&lt;p&gt;I am fully aware of it, but there is a catch with it: If the component is deactivated the following tasks occurr:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;unregister the service&lt;/li&gt;
	&lt;li&gt;call deactivate&lt;/li&gt;
	&lt;li&gt;unbind services (mostly statically bound, but may also be dynamic ones)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now, when the component is deactivated while the dependency is uregistered, we may cause further components to unregister and so forth. And this all takes place in the thread of the initial service unregistration.&lt;/p&gt;

&lt;p&gt;And this may lead to deadlock situations, unfortunately. So I decided against synchronous deactivation for now in favor of preventing deadlocks.&lt;/p&gt;

&lt;p&gt;And yes, if we would deactivate immediately, then the flag introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-1178&quot; title=&quot;Component may remain deactivated after a reference has been unregistered and registered again&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-1178&quot;&gt;&lt;del&gt;FELIX-1178&lt;/del&gt;&lt;/a&gt; would not be needed.&lt;/p&gt;

&lt;p&gt;If you want to test, simply call deactivateInternal() from the AbstractComponentManager.deactivate() method instead of scheduling the call for asynchronous execution.&lt;/p&gt;</comment>
                            <comment id="12714013" author="agemocui" created="Thu, 28 May 2009 15:35:31 +0000"  >&lt;p&gt;I understand what you concern.&lt;br/&gt;
Since I just looked at the scr code and didn&apos;t read it completely, it&apos;s a big risk to make the deactivation synchronous.&lt;/p&gt;

&lt;p&gt;However, I have the alternate way that could fix this problem too. But I&apos;m not sure whether it will cause other problems or will cause a big code change which is also a big risk.&lt;/p&gt;

&lt;p&gt;The dependency relation is in fact a tree. If we look at the dependent component as the parent node of a certain component, then before we schedule a disposal task of a dependent component, could we use Depth First algorithm to schedule all the disposal tasks.&lt;br/&gt;
That is to say, if component A is dependent on component B and now B is going to be disposed, could we schedule A&apos;s disabling before B&apos;s disabling? Since the tasks are queued, that should work though asynchronously.&lt;/p&gt;</comment>
                            <comment id="12714028" author="agemocui" created="Thu, 28 May 2009 15:59:34 +0000"  >&lt;p&gt;Actually, if we can take the unregistering of the component&apos;s services out of the &quot;Disable&quot; task, it will work.&lt;/p&gt;

&lt;p&gt;I mean when disabling a component, all the services this component provides should be unregistered synchronously instead of being scheduled to execute along with the deactivation.&lt;/p&gt;

&lt;p&gt;What do you think of?&lt;/p&gt;</comment>
                            <comment id="12714041" author="agemocui" created="Thu, 28 May 2009 16:21:43 +0000"  >&lt;p&gt;Sorry, I just noticed that the task could also be scheduled to run synchronously if the componentActorThread is not running.&lt;br/&gt;
That makes things quite complicated.&lt;/p&gt;</comment>
                            <comment id="12714052" author="agemocui" created="Thu, 28 May 2009 16:50:05 +0000"  >&lt;p&gt;It looks like the field m_componentActor is set to null nowhere. So the synchronous execution of the task &quot;may not&quot; exist.&lt;br/&gt;
I just checked &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-550&quot; title=&quot;SCR registers service component twice after stopping/starting a bundle&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-550&quot;&gt;&lt;del&gt;FELIX-550&lt;/del&gt;&lt;/a&gt; because of some indirect relation to this problem.&lt;/p&gt;

&lt;p&gt;I&apos;m just not clear if all the activation/deactivation tasks are queued to run, why would there be a race condition for the serviceRegistration? If we gonna take the calling unregister services out of the &quot;Disable&quot; task, then that would be a race condition for that field.  Or actually the code now is quite different from the code at that time?&lt;/p&gt;

&lt;p&gt;Sorry, I&apos;m just trying to learn the current code.&lt;/p&gt;

&lt;p&gt;Your advise will be appreciated.&lt;br/&gt;
Thanks.&lt;/p&gt;</comment>
                            <comment id="12714732" author="agemocui" created="Sat, 30 May 2009 15:42:33 +0000"  >&lt;p&gt;I use State design pattern to have refactoried the class AbstractComponentManager.&lt;/p&gt;

&lt;p&gt;There are 8 states in all.&lt;br/&gt;
They are: Disabled, Enabled(Unsatisfied), Registered, Factory, Active, Destroyed, Activating and Deactivating.&lt;br/&gt;
State Unsatisfied is duplicate to State Enabled so it&apos;s removed.&lt;br/&gt;
State Registered, Factory and Active are the &quot;Satisfied&quot; state in concept. Only DelayedComponentManager can transit to the State Registered. Only FactoryServiceComponentManager can transit to the State Factory.&lt;br/&gt;
State Activating and Deactivating are transient ones. They will be changed to other &quot;stable&quot; state automatically when the corresponding work is done.&lt;/p&gt;

&lt;p&gt;The transition cases are listed below.&lt;br/&gt;
1. Disabled -&lt;del&gt;(enable)&lt;/del&gt;&amp;gt; Enabled&lt;br/&gt;
2. Disabled -&lt;del&gt;(dispose)&lt;/del&gt;&amp;gt; Destoryed&lt;br/&gt;
3. Enabled -&lt;del&gt;(activate)&lt;/del&gt;&amp;gt; Satisfied (Registered, Factory or Active, depends on the type of the component)&lt;br/&gt;
4. Enabled -&lt;del&gt;(disable)&lt;/del&gt;&amp;gt; Disabled&lt;br/&gt;
5. Enabled -&lt;del&gt;(dispose)&lt;/del&gt;&amp;gt; Destroyed&lt;br/&gt;
6. Registered -&lt;del&gt;(getService, SUCCESS)&lt;/del&gt;&amp;gt; Active&lt;br/&gt;
7. Registered -&lt;del&gt;(getService, FAIL)&lt;/del&gt;&amp;gt; Enabled&lt;br/&gt;
8. Factory -&lt;del&gt;(getService)&lt;/del&gt;&amp;gt; Active&lt;br/&gt;
9. Satisfied -&lt;del&gt;(deactivate)&lt;/del&gt;&amp;gt; Enabled&lt;/p&gt;


&lt;p&gt;Each event specified above is mapped to a method xxxxxInternal in the code. They are all atomic operation that is &quot;synchonized&quot;.&lt;/p&gt;

&lt;p&gt;If a event is applied to a State, which is not in the above case list, nothing will be done(A debug log will be printed).&lt;/p&gt;

&lt;p&gt;So for a enable calling(not the same meaning event in the transition case), it consists of the following primitive operations: enabledInternal and activateInternal.&lt;br/&gt;
For a dispose calling(not the same meaning event in the transition case), it consists of the following primitive operations: deactivateInternal and disposeInternal.&lt;/p&gt;

&lt;p&gt;With these changes, I have confidence of no deadlock after making the deactivation synchronous which is described in this problem.&lt;br/&gt;
Because there&apos;s no crossing lock and there&apos;s no circular dependency.&lt;/p&gt;


&lt;p&gt;All the changed source files are attached.&lt;/p&gt;

&lt;p&gt;Please review. If it&apos;s OK and you approve, I hope my changes could be committed.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12714768" author="fmeschbe" created="Sat, 30 May 2009 20:54:52 +0000"  >&lt;p&gt;Thanks for providing this patch and the interesting analysis. I came to similar conclusions, but your implementation looks more elegant than mine at first sight.&lt;/p&gt;

&lt;p&gt;I will look into it in more depth and check it out.&lt;/p&gt;</comment>
                            <comment id="12714963" author="agemocui" created="Mon, 1 Jun 2009 04:11:40 +0000"  >&lt;p&gt;I investigated the state transition case further and found the State Unsatisfied is not a duplicate one to State Enabled. So it cannot be removed. The State Enabled aforementioned is actually the State Unsatisfied. So State Enabled is renamed to Unsatisfied and a &quot;new&quot; State Enabled is added. It will be useful when we make changes for R4.2. For now, the behavior is only a little different from before. That is: when method enable is called, the component will transit into State Enabled immediately but the activating work will be run asynchronously, which is just like the R4 spec says.&lt;/p&gt;

&lt;p&gt;I fixed the code accordingly.  The changed files are attached.&lt;/p&gt;

&lt;p&gt;New transition cases are listed below.&lt;/p&gt;

&lt;p&gt;Disabled &lt;del&gt;(enable)&lt;/del&gt;&amp;gt; Enabled&lt;br/&gt;
Disabled &lt;del&gt;(dispose)&lt;/del&gt;&amp;gt; Destoryed&lt;br/&gt;
Enabled &lt;del&gt;(activate, SUCCESS)&lt;/del&gt;&amp;gt; Satisfied(Registered, Factory or Active)&lt;br/&gt;
Enabled &lt;del&gt;(activate, FAIL)&lt;/del&gt;&amp;gt; Unsatisfied&lt;br/&gt;
Enabled &lt;del&gt;(disable)&lt;/del&gt;&amp;gt; Disabled&lt;br/&gt;
Enabled &lt;del&gt;(dispose)&lt;/del&gt;&amp;gt; Destroyed&lt;br/&gt;
Unsatisfied &lt;del&gt;(activate, SUCCESS)&lt;/del&gt;&amp;gt; Satisfied(Registered, Factory or Active)&lt;br/&gt;
Unsatisfied &lt;del&gt;(activate, FAIL)&lt;/del&gt;&amp;gt; Unsatisfied&lt;br/&gt;
Unsatisfied &lt;del&gt;(disable)&lt;/del&gt;&amp;gt; Disabled&lt;br/&gt;
Unsatisfied &lt;del&gt;(dispose)&lt;/del&gt;&amp;gt; Destroyed&lt;br/&gt;
Registered &lt;del&gt;(getService, SUCCESS)&lt;/del&gt;&amp;gt; Active&lt;br/&gt;
Registered &lt;del&gt;(getService, FAIL)&lt;/del&gt;&amp;gt; Unsatisfied&lt;br/&gt;
Satisfied &lt;del&gt;(deactivate)&lt;/del&gt;&amp;gt; Unsatisfied&lt;/p&gt;</comment>
                            <comment id="12714965" author="agemocui" created="Mon, 1 Jun 2009 04:22:08 +0000"  >&lt;p&gt;Sorry, the AbstractComponentManager.java attached previously has a little problem that Disabled doesn&apos;t change to Enabled on an enable event.&lt;br/&gt;
Now attach the new fixed one.&lt;/p&gt;</comment>
                            <comment id="12715224" author="agemocui" created="Mon, 1 Jun 2009 20:00:06 +0000"  >&lt;p&gt;Sorry, I realized I made a mistake on the AbstractCompnentManager.getSatisfiedState() after reading the code further.&lt;/p&gt;


</comment>
                            <comment id="12715225" author="agemocui" created="Mon, 1 Jun 2009 20:00:48 +0000"  >&lt;p&gt;The original implementation of the method AbstractCompnentManager.getSatisfiedState() must be restored.&lt;/p&gt;</comment>
                            <comment id="12715430" author="fmeschbe" created="Tue, 2 Jun 2009 09:00:30 +0000"  >&lt;p&gt;I have applied your latest patches and tested them in our application running on Felix Framework 1.6.0. I only had a small issue:&lt;/p&gt;

&lt;p&gt;The AbstractComponentManager.Unsatisfied.activateInternal method does the following at the end:&lt;/p&gt;

&lt;p&gt;            acm.registerComponentService();&lt;br/&gt;
            acm.changeState( acm.getSatisfiedState() );&lt;/p&gt;

&lt;p&gt;This registers the service of the provider component causing any consumer components to try to get the service immediately. If the provider component is a service factory (delayed component), this causes the DelayedComponentManager to try to create the actual component instance, which fails because the state is not active.&lt;/p&gt;

&lt;p&gt;The correct order here is probably:&lt;/p&gt;

&lt;p&gt;            acm.changeState( acm.getSatisfiedState() );&lt;br/&gt;
            acm.registerComponentService();&lt;/p&gt;

&lt;p&gt;thus changing the component state &lt;em&gt;before&lt;/em&gt; registering the service. This way, the consumer component will get the service, since the new state will be able to create the actual component instance and return it.&lt;/p&gt;

&lt;p&gt;This change works in my application, you might want to verify in your environment.&lt;/p&gt;</comment>
                            <comment id="12715514" author="agemocui" created="Tue, 2 Jun 2009 13:03:16 +0000"  >&lt;p&gt;Yes, you are right.&lt;/p&gt;

&lt;p&gt;And for a natural understanding, only when a component is satisfied then its service could be registered.&lt;br/&gt;
So it should enter the satisfied state first.&lt;/p&gt;

&lt;p&gt;Many thanks for your reviewing and correction.&lt;/p&gt;

</comment>
                            <comment id="12715541" author="fmeschbe" created="Tue, 2 Jun 2009 14:38:07 +0000"  >&lt;p&gt;&amp;gt; And for a natural understanding, only when a component is satisfied then its service could be registered.&lt;br/&gt;
&amp;gt; So it should enter the satisfied state first.&lt;/p&gt;

&lt;p&gt;Yeah, right. Good explanation.&lt;/p&gt;</comment>
                            <comment id="12715543" author="fmeschbe" created="Tue, 2 Jun 2009 14:46:54 +0000"  >&lt;p&gt;I have now committed your fixes in Rev. 781045. I only changed the order of service registration and status change as described above.&lt;/p&gt;

&lt;p&gt;Deplyoed SNAPSHOT version 1.0.9-20090602.144612-4.&lt;/p&gt;

&lt;p&gt;If this works for you, please close this issue. Thanks.&lt;/p&gt;</comment>
                            <comment id="12715560" author="agemocui" created="Tue, 2 Jun 2009 15:53:50 +0000"  >&lt;p&gt;Sorry, my bad.&lt;br/&gt;
I didn&apos;t give the final fixed version.&lt;/p&gt;

&lt;p&gt;The original implementation of the method AbstractComponentManager.getSatisfiedState has to be restored as follows:&lt;/p&gt;

&lt;p&gt;    final State getSatisfiedState()&lt;br/&gt;
    {&lt;br/&gt;
        if ( m_componentMetadata.isFactory() )&lt;/p&gt;
        {
            return Factory.getInstance();
        }
&lt;p&gt;        else if ( m_componentMetadata.isImmediate() )&lt;/p&gt;
        {
            return Active.getInstance();
        }
&lt;p&gt;        else&lt;/p&gt;
        {
            return Registered.getInstance();
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;And remove all the override implementations in ImmediateComponentManager, DelayedComponentManager and ServiceFactoryComponentManager.&lt;/p&gt;

&lt;p&gt;And in all those debug log in class State, It should use &quot;m_name&quot; rather than &quot;m_state&quot;.&lt;/p&gt;

&lt;p&gt;Really sorry, my bad.&lt;/p&gt;</comment>
                            <comment id="12715683" author="agemocui" created="Tue, 2 Jun 2009 21:00:51 +0000"  >&lt;p&gt;Hi Felix,&lt;/p&gt;

&lt;p&gt;Could you be kind to review the method AbstractComponentManager.getStatisfiedState(also ServiceFactoryComponentManager.getService and ungetService)?&lt;br/&gt;
Because my changes give them a different path from the original implementation.&lt;br/&gt;
So I&apos;m afraid that could be a problem. Need your help.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Agemo&lt;/p&gt;</comment>
                            <comment id="12715881" author="fmeschbe" created="Wed, 3 Jun 2009 09:34:44 +0000"  >&lt;p&gt;Reopening issue to apply cleanup fixes by Agemo Cui&lt;/p&gt;</comment>
                            <comment id="12715882" author="fmeschbe" created="Wed, 3 Jun 2009 09:37:04 +0000"  >&lt;p&gt;I have applied the getSatisifiedState() method changes and the debug message changes in Rev. 781316&lt;/p&gt;</comment>
                            <comment id="12715890" author="agemocui" created="Wed, 3 Jun 2009 10:15:04 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Another problem is that I also made the change to ServiceFactoryComponentManager.getService() and ungetService().&lt;br/&gt;
The original implementation was to check state &quot;Registered&quot; not the current &quot;Factory&quot;.&lt;br/&gt;
Would that be a problem? I&apos;m not sure about that. Sorry, please review again.&lt;/p&gt;

&lt;p&gt;If that&apos;s OK, I would close this bug.&lt;/p&gt;

&lt;p&gt;Many thanks.&lt;/p&gt;</comment>
                            <comment id="12715894" author="agemocui" created="Wed, 3 Jun 2009 10:37:25 +0000"  >&lt;p&gt;OK, I think I understand the original state transition now.&lt;br/&gt;
Factory state is only for those factory component and they never transit to Active(Actually, factory means active for them).&lt;/p&gt;

&lt;p&gt;So in the getService and ungetService of ServiceFactoryComponentManager, the check for Factory state need be changed back to check for Registered state.&lt;/p&gt;

&lt;p&gt;And for the safety of the double check, it&apos;s better to add &quot;volatile&quot; modifier to the AbstractComponentManager.m_state .&lt;/p&gt;


&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12715896" author="fmeschbe" created="Wed, 3 Jun 2009 10:45:29 +0000"  >&lt;p&gt;Thanks for pointing this out, I missed it.&lt;/p&gt;

&lt;p&gt;Yes, you are right, this is probably wrong because the ServiceFactoryComponentManager is used if the component is defined as a service factory component (this is not the same as a ComponentFactory). In such a component each consumer bundle gets its own component instance.&lt;/p&gt;

&lt;p&gt;The state of a ServiceFactory component is like that of a delayed component, REGISTERED. Only after the first bundle has asked for the service will the state change to ACTIVE.&lt;/p&gt;

&lt;p&gt;The factory state is only used for component factories, which create component instances on-demand or upon configuration.&lt;/p&gt;

&lt;p&gt;I fixed this in Rev. 781335&lt;/p&gt;

&lt;p&gt;So, it this would be all for this bug, you may go ahead and close it. Thanks.&lt;/p&gt;</comment>
                            <comment id="12715897" author="fmeschbe" created="Wed, 3 Jun 2009 10:47:42 +0000"  >&lt;p&gt;&amp;gt; And for the safety of the double check, it&apos;s better to add &quot;volatile&quot; modifier to the AbstractComponentManager.m_state . &lt;/p&gt;

&lt;p&gt;Done in Rev. 781336&lt;/p&gt;</comment>
                            <comment id="12715916" author="agemocui" created="Wed, 3 Jun 2009 13:18:32 +0000"  >&lt;p&gt;Got it. Thanks.&lt;/p&gt;</comment>
                            <comment id="12737551" author="fmeschbe" created="Fri, 31 Jul 2009 15:07:36 +0000"  >&lt;p&gt;Retargeting fixes for SCR 1.2.0 release. There will be no 1.0.10 release.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12409526" name="AbstractComponentManager.java" size="26697" author="agemocui" created="Mon, 1 Jun 2009 04:22:08 +0000"/>
                            <attachment id="12409523" name="AbstractComponentManager.java" size="26701" author="agemocui" created="Mon, 1 Jun 2009 04:11:40 +0000"/>
                            <attachment id="12409524" name="ComponentFactoryImpl.java" size="7683" author="agemocui" created="Mon, 1 Jun 2009 04:11:40 +0000"/>
                            <attachment id="12409467" name="scr-changes on revision 778604.zip" size="31322" author="agemocui" created="Sat, 30 May 2009 15:42:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>57833</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            16 years, 17 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0vz67:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>184671</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>