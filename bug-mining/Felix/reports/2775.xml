<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 16:06:28 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-5471] Ensure that unbound services are always handled synchronously</title>
                <link>https://issues.apache.org/jira/browse/FELIX-5471</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;p&gt;When a component loses a service dependency, it should handle the lost service synchronously. For example, if service A loses a dependency on B (because B is being unregistered),  then A.remove(B) should be called synchronously (when B is being unregistered from the service registry), else the A.remove(B) callback could possibly be invoked while B is already unregistered and stopped.&lt;/p&gt;

&lt;p&gt;Currently, unbound services may be handled asynchronously if DM is used in a concurrent mode (using a threadpool). And even if no threadpool is used, the issue may happen if there is a highly concurrent situation where services are registered/removed concurrently from multiple threads.&lt;/p&gt;

&lt;p&gt;So, a patch should be done in order to ensure that a service dependency remove event is always handled synchronously (especially if DM is used with a threadpool).&lt;/p&gt;

&lt;p&gt;I will provide a testcase soon.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="13031278">FELIX-5471</key>
            <summary>Ensure that unbound services are always handled synchronously</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pderop">Pierre De Rop</assignee>
                                    <reporter username="pderop">Pierre De Rop</reporter>
                        <labels>
                    </labels>
                <created>Fri, 30 Dec 2016 14:10:51 +0000</created>
                <updated>Mon, 6 Feb 2017 15:08:42 +0000</updated>
                            <resolved>Mon, 6 Feb 2017 15:08:42 +0000</resolved>
                                    <version>org.apache.felix.dependencymanager-r1</version>
                                    <fixVersion>org.apache.felix.dependencymanager-r9</fixVersion>
                                    <component>Dependency Manager</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="15787744" author="pderop" created="Fri, 30 Dec 2016 14:13:06 +0000"  >&lt;p&gt;Added test in revision 1776573:&lt;/p&gt;

&lt;p&gt;org.apache.felix.dependencymanager.itest/src/org/apache/felix/dm/itest/api/FELIX5471_SynchronousUnbindTest.java&lt;/p&gt;</comment>
                            <comment id="15787762" author="pderop" created="Fri, 30 Dec 2016 14:25:39 +0000"  >&lt;p&gt;Committed patch in 1776574.&lt;/p&gt;

&lt;p&gt;A new schedule(boolean synchronous, Runnable task) has been added in ComponentImpl.java, allowing to possibly schedule a task synchronously through the internal component executor queue. The method uses a timeout of 30 seconds to protect against infinite wait, and the timeout can be configured using the DependencyManager.SCHEDULE_TIMEOUT constant, which is a bundle context property. it may take a value in  millis. (30000 by default).&lt;/p&gt;

&lt;p&gt;So, ComponentImpl class is now using the new schedule method in order to handle removed dependency events synchronously. The ComponentImpl.stop() method is now also using the same schedule method, and the InvokcationUtil.invokeUpdated callback is also reusing the DependencyManager.SCHEDULE_TIMEOUT constant, when handling CM configuration update events.&lt;/p&gt;</comment>
                            <comment id="15791022" author="jeroendaanen" created="Sun, 1 Jan 2017 12:07:32 +0000"  >&lt;p&gt;Indeed this solves the problems we talked about in the felix user mailing list.&lt;br/&gt;
However, I am wondering wether it is a good decision to introduce the timeout. &lt;br/&gt;
If I am correct, the timeout for instance occurs when handling the remove callback takes a long time e.g. when the component is just processing the services its requires in a synchronized block, while the remove callback is synchronized on the same, or the implementation of the remove call back triggers a lot. This could easily take some time depending on your implementation, so you could run into this timeout pretty quickly. &lt;br/&gt;
My suggestion would be to remove the timeout and the configurable property and just wait endlessly, because if thats happening I think there is another programming error (a deadlock or something) which must not be just &apos;ignored&apos; by the warning message which is logged now when the timeout occurs.&lt;br/&gt;
What do you think Pierre?&lt;/p&gt;</comment>
                            <comment id="15792465" author="pderop" created="Mon, 2 Jan 2017 08:20:55 +0000"  >&lt;p&gt;Hello Jeroen;&lt;/p&gt;

&lt;p&gt;The timeout I introduced last friday was because I wanted to avoid a corner case where lost dependencies could be stopped before calling &quot;removed&quot; callbacks (I will explain this below).&lt;br/&gt;
But to be honest, I should not have added this timeout because I realize that it may generate some deadlocks. I have added the FELIX5471_CyclicDependencyTest.java which demonstrates the deadlock:&lt;br/&gt;
So, running this test with the timeout guard in the ComponentImpl.schedule method (ComponentImpl.java, in revision 1776641) produces a deadlock, and after 30 seconds, we see this message log:&lt;/p&gt;

&lt;p&gt;&amp;lt;code&amp;gt;&lt;br/&gt;
WARN - pool-3-thread-2 : &lt;span class=&quot;error&quot;&gt;&amp;#91;pool-3-thread-2&amp;#93;&lt;/span&gt; task could not be scheduled timely in component org.apache.felix.dm.itest.api.FELIX5471_CyclidDependencyTest$A (exception: java.util.concurrent.TimeoutException)&lt;br/&gt;
WARN - pool-3-thread-1 : &lt;span class=&quot;error&quot;&gt;&amp;#91;pool-3-thread-1&amp;#93;&lt;/span&gt; task could not be scheduled timely in component org.apache.felix.dm.itest.api.FELIX5471_CyclidDependencyTest$B (exception: java.util.concurrent.TimeoutException)&lt;br/&gt;
&amp;lt;/code&amp;gt;&lt;/p&gt;

&lt;p&gt;So, for now, I have committed a new patch (in revision 1776903.) which includes the FELIX5471_CyclicDependencyTest.java test. The patch does not use the timeout in the ComponentImpl.schedule method anymore.&lt;/p&gt;

&lt;p&gt;Now, actually, the real patch which (partially) resolves the issue you found is that now, when we are&lt;br/&gt;
handling a REMOVED service event, then if a threadpool is used we try to not reschedule the REMOVED event it it and we try to call the handleRemoved method synchronously. Initially, the problem was that if a threadpool was used, then the REMOVED event was always scheduled in it, and the event was always handled asynchronously.&lt;/p&gt;

&lt;p&gt;So, let me try to explain deeper what was going on using the scenario you gave in the users mailing list (that is: M depends on X, and M.remove(X) is called but at this point, X is already stopped):&lt;/p&gt;

&lt;p&gt;1) So, X is being unregistered from the OSGi service registry. That is: the ComponentImpl for X is currently invoking m_registration.unregister() in the ComponentImpl.unregisterService() method.&lt;/p&gt;

&lt;p&gt;2) Then, the framework callbacks the tracker of the M component, which ends up calling the ComponentImpl.handleEvent() method with the event for X being unregistered.&lt;br/&gt;
At this point, we are still in the call stack of the unregisterService for X (see step 1).&lt;br/&gt;
But the bug is that if we are using a threadpool, then the Component.handleRemoved() method was always executed asynchronously in the threadpool.&lt;/p&gt;

&lt;p&gt;3) So, while the Component.handleRemoved method (for M) is being scheduled in the threadpool, then we return from the handleEvent method and then&lt;br/&gt;
the ComponentImpl.unregisterService() method returns (from step 1). So, then, at this point the thread from (1) ends up calling the X.stop() method, but&lt;br/&gt;
at a point where M.unbind(X) method has not been yet been scheduled and executed in the threadpool. So, in this case, X.stop() is called , and then, M.remove(X) is&lt;br/&gt;
called.&lt;/p&gt;

&lt;p&gt;So, now, the Component.handleRemoved() method is not rescheduled in the threadpool (if possible). see the schedule method which invokes the DispatchExecutor.execute method:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-comment&quot;&gt;// Try to execute the task from the current thread &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the threadpool is not currently running our queue.
&lt;/span&gt;    ((DispatchExecutor) exec).execute(task, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, the patch will try to not schedule the Component.handleRemoved()  in the threadpool, but instead will invoke the method synchronously.&lt;/p&gt;

&lt;p&gt;Unfortunately, the patch is not perfect, because the DispatchExecutor won&apos;t invoke the task synchronously if the queue for the Component is currently executing another task (like a concurrent service ADD event). This may happen in a highly concurrent situations, and for now, I don&apos;t see an easy solution in order to make sure M.remove(X) is called before X.stop().&lt;/p&gt;

&lt;p&gt;For example, if during the unregistration of the X service, then at the same time another thread is registering a Z service on which M depends on, then it is possible that&lt;br/&gt;
at the time the ComponentImpl for M is called in handleEvent for the REMOVED X event , then the threadpool may possibly be currently handling the ADDED Z event.&lt;br/&gt;
In this case, since the state machine is single threaded, it won&apos;t be possible to handle the REMOVED X event synchronously, and the Component.handleRemoved() method call will be&lt;br/&gt;
scheduled in the threadpool, which will be executed after the handling of the Z ADDED event, but in this case, X.stop() will possibly be called before M.remove(X) is invoked.&lt;/p&gt;

&lt;p&gt;Please notice that this can also happen even if no threadpool is used (antoher master thread me be running the queue while we are handling the REMOVED X event).&lt;/p&gt;

&lt;p&gt;So, this is for this reason that I also introduced last friday the timeout guard in the schedule method (if the synchronous flag is true).&lt;br/&gt;
However, it does not work because it may introduce a nasty deadlock which is reproduced in the FELIX5471_CyclicDependencyTest.java test.&lt;/p&gt;

&lt;p&gt;So, for now, I have simply removed the usage of the timeout guard.&lt;/p&gt;

&lt;p&gt;it means that for most situations (whether or not you are using a threadpool), the ordering will be guaranteed.&lt;br/&gt;
But if there is a highly concurrent situation where some services are unregistered while others are added from multiple distinct threads, then the ordering can&apos;t be guaranteed in all cases.&lt;br/&gt;
Always ensuring the ordering guarantee seems that we would have to rework the state machine thread model with complex internal locking policy, and I&apos;m not sure it&apos;s worth doing this.&lt;br/&gt;
Anyway, I will try to contact Marcel and see what he is thinking and will get back to this issue in case some more rework has to really be done.&lt;/p&gt;

&lt;p&gt;Now,  I would also be interested to have your opinion ? do you think what is committed is reasonable ?&lt;/p&gt;

&lt;p&gt;thanks a lot Jeroen;&lt;br/&gt;
/Pierre&lt;/p&gt;</comment>
                            <comment id="15792649" author="jeroendaanen" created="Mon, 2 Jan 2017 10:41:14 +0000"  >&lt;p&gt;I am glad you could remove the timeout. The new implementation looks good to me, only the comments on line 1695-1697 of ComponentImpl are a bit confusing (how would it be possible to don&apos;t have the SerialExecutor at that point when trySynchronous is true (except when someone overrides getExecutor)).&lt;/p&gt;

&lt;p&gt;In order to create stable and reliable software, I do have to be sure that the order is guaranteed. Also I think the usage of the dependency manager is pretty concurrent in our software (when setting it to parallel), but I cannot estimate what the actual chance is of the order not being guaranteed? Can it be reproduced in a unit test? &lt;br/&gt;
Anyway, I would really appreciate if this can be fixed and the order is always guaranteed.&lt;/p&gt;</comment>
                            <comment id="15799473" author="pderop" created="Wed, 4 Jan 2017 21:57:24 +0000"  >&lt;p&gt;Hi Jeroen,&lt;/p&gt;

&lt;p&gt;I have committed a patch in rv 1777378 in ComponentImpl class in order to clarify the javadoc for the schedule method, and I renamed the &quot;trySynchronous&quot; argument of the schedule method to &quot;bypassThreadPoolIfPossible&quot; in order to make the method less confusing. So if there is no threadpool, the flag is ignored and then the default serial queue executor is used (the task is scheduled synchronously if the queue is not currently being run by another master thread). If now a threadpool is used and if bypassThreadPoolIfPossible is true, then the task is also run synchronously if the queue is not currently being run from the threadpool.&lt;/p&gt;

&lt;p&gt;So, whether or not a ComponentExecutorFactory is used, we always try to handle removed service events synchronously if the component is not currently handling a service dependency (if its queue is idle, not busy).&lt;/p&gt;

&lt;p&gt;Now let&apos;s try to clarify so you can estimate if you may or may not have the issue (whether or not you use a ComponentExecutorFactory):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;First let&apos;s recap the issue: sometimes, when a service X is being unregistered, then the other services (M for example) depending on X may not be called in M.unbind(X) synchronously while X is being unregistered. So X may then be stopped at a point where M.unbind(X) is not yet called (but will be called eventually, soon).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;When the issue does not happen ? you won&apos;t have the ordering issue if you stop your components synchronously from a single thread and after all components have been started (like it is the case for example when the framework is shutting down or when you manually stop a bundle from the gogo shell).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;When the issue may happen ? you may have the issue if you concurrently add &lt;b&gt;and&lt;/b&gt; remove some components at the same time. For example you may have the issue in the following use case (whether or not you use concurrent DM):
	&lt;ul&gt;
		&lt;li&gt;X, and Y are available, and M optionally depends on X, Y.&lt;/li&gt;
		&lt;li&gt;you add M from thread T1&lt;/li&gt;
		&lt;li&gt;then concurrently, you remove X from thread T2&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So, using the scenario above,  it may happen that M.unbind(X) is called after X.stop().&lt;br/&gt;
This is because we have implemented the thread model in a non blocking way, using queues.&lt;/p&gt;

&lt;p&gt;So to summarize: if you manage to stop components from a single thread  and at a point where components are all fully started, then there is no issue.&lt;/p&gt;

&lt;p&gt;Now, I also added two concurrent test cases:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ServiceRaceWithOrderedUnbindTest.java: this junit test does not use DM in concurrent mode (no ComponentExecutorFactory is used, as it is the case in default DM). So, the test uses manually created threads in order to perform concurrent component creations. Then, the components are unregistered from a single thread. And the test verifies if the unbound methods are called synchronously while the lost service dependencies are being unregistered.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ServiceRaceParallelWithOrderedUnbindTest.java: same test as above, but this time we are using a ComponentExecutorFactory (concurrent DM is used).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So, are you stopping components while some other components are starting concurrently ?&lt;/p&gt;

&lt;p&gt;thank you.&lt;/p&gt;</comment>
                            <comment id="15801235" author="jeroendaanen" created="Thu, 5 Jan 2017 12:29:12 +0000"  >&lt;p&gt;Yes we are stopping components while some other components are starting concurrently.&lt;br/&gt;
For instance, we use the dependency manager to create services based on what an end user has configured. So a configuration change may trigger the removal services, which will be replaced by other or new services. On top of that we have services launching other services, which are being required/used in other services.&lt;/p&gt;</comment>
                            <comment id="15809817" author="pderop" created="Sun, 8 Jan 2017 18:34:55 +0000"  >&lt;p&gt;Hello Jeroen,&lt;/p&gt;

&lt;p&gt;Ok; so last week, I made an attempt to try to introduce some locking in the component state machine in order to block&lt;br/&gt;
unregistering threads until listeners are called (like blocking the thread which is unregistering X until M.unbind(X) is called).&lt;br/&gt;
So, I tried to introduce a &quot;Future&quot; object in the Component.schedule() method in order to block the thread which is calling handleEvent() method with a REMOVED event (as I did in the previous patch which I reverted).&lt;/p&gt;

&lt;p&gt;However, I came across some deadlocks especially when you have some cycles between components.&lt;/p&gt;

&lt;p&gt;Then I tried to invoke the Component.unregisterService() method outside of the Component queue, but I then had to create a new UNREGISTERING state and I had to also implement a mechanism in order to allow to schedule a task outside the queue.&lt;br/&gt;
But even after having done that, I then came across some remaining concurrency issues and some concurrent tests were not working anymore.&lt;/p&gt;

&lt;p&gt;I then abandoned and finally had the opportunity to have a long discussion with Marcel, and we came to the conclusion that&lt;br/&gt;
implementing synchronous listener notification (that is: M.unbind(X)) for service unregistration (when S is unregistering) in all concurrent scenarios would definitely weaken a lot the locking model currently used in DM (it could be possible but at a very high cost and with a major refactoring, and it&apos;s not reasonable to do that for the moment).&lt;/p&gt;

&lt;p&gt;that being said, there is now some other aspects to consider: if the X service is already stopped at the time M.unbind(X) is called, then the X service is said to be &quot;stale&quot; in the osgi spec, and in this case, the behavior of a &quot;stale&quot; service object that becomes unregistered is undefined.&lt;br/&gt;
Such service objects may continue to work properly or throw an exception at their discretion (see 5.7 &quot;Stale Reference&quot; in core spec), or the objects could simply silently ignore further method calls after they are stopped.&lt;/p&gt;

&lt;p&gt;So, in the framework there is a runtime org.osgi.framework.ServiceException exception which you could throw from X component in case M.unbind(X) calls some X methods after X has been stopped.&lt;br/&gt;
That exception also allows you to specify a reason why the call failed, and M.unbind method could then just log it.&lt;/p&gt;

&lt;p&gt;So, all in all, it&apos;s not worth doing a massive refactoring for the moment, it would be too dangerous. If now you would like avoid the situation where the stale components can be temporarily called when unbound from other services, then may be the option is for the moment to not use the concurrent mode of DM  and use the single thread mode, as before (sorry about that).&lt;/p&gt;
</comment>
                            <comment id="15814707" author="jeroendaanen" created="Tue, 10 Jan 2017 11:22:43 +0000"  >&lt;p&gt;Ok, I understand that. &lt;br/&gt;
Now we know that if using the dependency manager in parallel you might, in highly concurrent situations, encounter a service being removed which is already &apos;stale&apos;/stopped and just have to account for that.&lt;br/&gt;
Thanks a lot for investigating and discussing this, Pierre!&lt;/p&gt;</comment>
                            <comment id="15854180" author="pderop" created="Mon, 6 Feb 2017 15:08:42 +0000"  >&lt;p&gt;Just putting this issue to resolved before doing the release ...&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 41 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i384yf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>