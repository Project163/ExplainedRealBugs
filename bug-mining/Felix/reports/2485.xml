<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 15:58:42 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FELIX-4987] Dynamic package resolution with unresolvable or fragment package exports can lead to invalid wirings</title>
                <link>https://issues.apache.org/jira/browse/FELIX-4987</link>
                <project id="12310100" key="FELIX">Felix</project>
                    <description>&lt;p&gt;With the latest code in trunk calling org.apache.felix.resolver.ResolverImpl.resolve(ResolveContext, Resource, Requirement, List&amp;lt;Capability&amp;gt;) with a List&amp;lt;Capability&amp;gt; containing a Capability from a fragment will lead to an invalid Wire.&lt;/p&gt;

&lt;p&gt;This looks similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/FELIX-4897&quot; title=&quot;Dynamic package resolution with fragment package exports can lead to invalid wirings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FELIX-4897&quot;&gt;&lt;del&gt;FELIX-4897&lt;/del&gt;&lt;/a&gt; and appears to be a regression.&lt;/p&gt;

&lt;p&gt;There are two types of failures.&lt;br/&gt;
1) Where the fragment has a valid host to resolve against.  In this case I would expect the Wire.getProvider() to be the host revision for the fragment, but the current code returns the fragment revision&lt;/p&gt;

&lt;p&gt;2) Where the fragment has no valid host available.  In this case I would expect no Wire to be returned in the result from the ResolverImpl.resolve call.&lt;/p&gt;</description>
                <environment>All</environment>
        <key id="12851135">FELIX-4987</key>
            <summary>Dynamic package resolution with unresolvable or fragment package exports can lead to invalid wirings</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="gnodet">Guillaume Nodet</assignee>
                                    <reporter username="tjwatson">Tom Watson</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Aug 2015 15:50:26 +0000</created>
                <updated>Fri, 21 Aug 2015 18:17:01 +0000</updated>
                            <resolved>Thu, 20 Aug 2015 12:33:12 +0000</resolved>
                                                    <fixVersion>resolver-1.6.0</fixVersion>
                                    <component>Resolver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="14652341" author="tjwatson" created="Mon, 3 Aug 2015 19:33:54 +0000"  >&lt;p&gt;There is a third case that is failing that involves no fragments.  If a candidate is passed in from an unresolvable host bundle then the resolver will return a Wire to the capability with an unresolvable revision.&lt;/p&gt;

&lt;p&gt;I have not been able to track down what is missing, but some processing seems to be completely missing now on the dynamic import path.&lt;/p&gt;</comment>
                            <comment id="14703112" author="gnt" created="Wed, 19 Aug 2015 14:39:53 +0000"  >&lt;p&gt;For #1, the behaviour has not changed afaik.  I tried a simple test with the previous resolver, and it also returns the fragment as the provider.  I don&apos;t mind changing that behavior, but it&apos;s not really a regression imho.&lt;/p&gt;

&lt;p&gt;For #2 and #3, I think there are some test cases available in equinox.  I&apos;ve cloned the &lt;a href=&quot;https://git.eclipse.org/r/equinox/rt.equinox.bundles&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://git.eclipse.org/r/equinox/rt.equinox.bundles&lt;/a&gt; git repo, but I run into some build issues.  Could you give me the steps to run your tests please ?&lt;/p&gt;

&lt;p&gt;Also, as a side question, can you confirm that a dynamic resolution can lead to fragments being attached to new hosts and new hosts to be resolved ?&lt;/p&gt;</comment>
                            <comment id="14703599" author="tjwatson" created="Wed, 19 Aug 2015 19:17:07 +0000"  >&lt;p&gt;To run the Equinox tests you need 4 projects (which are located across 3 repositories).  First clone the following repositories:&lt;/p&gt;

&lt;p&gt;git clone &lt;a href=&quot;http://git.eclipse.org/gitroot/equinox/rt.equinox.framework.git&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://git.eclipse.org/gitroot/equinox/rt.equinox.framework.git&lt;/a&gt;&lt;br/&gt;
git clone &lt;a href=&quot;http://git.eclipse.org/gitroot/platform/eclipse.platform.runtime.git&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://git.eclipse.org/gitroot/platform/eclipse.platform.runtime.git&lt;/a&gt;&lt;br/&gt;
git clone &lt;a href=&quot;http://git.eclipse.org/gitroot/platform/eclipse.platform.releng.git&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://git.eclipse.org/gitroot/platform/eclipse.platform.releng.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;rt.equinox.framework.git contains the framework implementation.  I created a branch there called twatson/newResolver that should have the latest felix resolver source.&lt;/p&gt;

&lt;p&gt;Then import the following 4 projects into Eclipse (hope you don&apos;t mind using Eclipse):&lt;/p&gt;

&lt;p&gt;rt.equinox.framework\bundles\org.eclipse.osgi - contains the framework implementation&lt;br/&gt;
rt.equinox.framework\bundles\org.eclipse.osgi.tests - contains the tests&lt;br/&gt;
eclipse.platform.runtime\tests\org.eclipse.core.tests.harness - harness for the tests&lt;br/&gt;
eclipse.platform.releng\bundles\org.eclipse.test.performance - something the harness needs&lt;/p&gt;

&lt;p&gt;Once you have these 4 projects imported into Eclipse.  Then the easiest way to run all the tests is to use the Run-&amp;gt;Run Configurations... menu to bring up the Run Configurations dialog.  There should be a predefined launch configuration under &quot;JUnit Plug-in Tests&quot; called &quot;All OSGi Tests&quot;.  Run that.&lt;/p&gt;

&lt;p&gt;This will run all the framework tests.  The important test suite to pay attention to is org.eclipse.osgi.tests.container.TestModuleContainer.  That suite has 3 failures with tests that start with testDynamicImport.  If you want you can run only the org.eclipse.osgi.tests.container.TestModuleContainer by modifying the &quot;All OSGi Tests&quot; launch config to use that class.&lt;/p&gt;

&lt;p&gt;Dynamic resolution can lead to fragments being attached to new hosts.  I added a new test just now that tests that directly.  If you run the TestModuleContainer tests with the master branch they all pass.  With the twatson/newResolver branch 4 testDynamicImport tests fail.&lt;/p&gt;</comment>
                            <comment id="14704772" author="gnt" created="Thu, 20 Aug 2015 12:33:12 +0000"  >&lt;p&gt;Committing to &lt;a href=&quot;https://svn.apache.org/repos/asf/felix/trunk&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/repos/asf/felix/trunk&lt;/a&gt; ...&lt;br/&gt;
	M	resolver/src/main/java/org/apache/felix/resolver/Candidates.java&lt;br/&gt;
	M	resolver/src/main/java/org/apache/felix/resolver/ResolverImpl.java&lt;br/&gt;
	M	resolver/src/test/java/org/apache/felix/resolver/test/ResolverTest.java&lt;br/&gt;
Committed r1696779&lt;/p&gt;


&lt;p&gt;The above commit seems to fix the use cases mentioned.&lt;br/&gt;
Could you please double check ?&lt;/p&gt;</comment>
                            <comment id="14705581" author="tjwatson" created="Thu, 20 Aug 2015 19:10:03 +0000"  >&lt;p&gt;This does seem to solve my problems.  One question on the fix.  The new method org.apache.felix.resolver.Candidates.getHosts() is misleading because it can return fragment resources.  I assume this is not your intention?&lt;/p&gt;

&lt;p&gt;It seems to me that you need additional (!Util.isFragment(res)) checks in each loop before putting the resource in the hosts map.&lt;/p&gt;</comment>
                            <comment id="14705609" author="gnt" created="Thu, 20 Aug 2015 19:36:47 +0000"  >&lt;p&gt;That makes sense, thx for reporting.&lt;br/&gt;
I&apos;ve fixed it.&lt;/p&gt;

&lt;p&gt;Committing to &lt;a href=&quot;https://svn.apache.org/repos/asf/felix/trunk&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/repos/asf/felix/trunk&lt;/a&gt; ...&lt;br/&gt;
	M	resolver/src/main/java/org/apache/felix/resolver/Candidates.java&lt;br/&gt;
Committed r1696846&lt;/p&gt;</comment>
                            <comment id="14706838" author="tjwatson" created="Fri, 21 Aug 2015 15:05:43 +0000"  >&lt;p&gt;Thanks.  I merged the latest felix into my twatson/newResolver branch.  I&apos;m still doing some work to figure out the best settings to use for the executor for the framework&apos;s use of the resolver.  You have any idea what the felix framework is going to do here?&lt;/p&gt;</comment>
                            <comment id="14706960" author="gnt" created="Fri, 21 Aug 2015 16:26:19 +0000"  >&lt;p&gt;Currently, it lets the ResolverImpl handle threading with the default parameters, i.e. no Executor and a parallelisation equals to the number of cores.&lt;/p&gt;

&lt;p&gt;The drawback is that it creates threads for each resolution. &lt;br/&gt;
I suppose the best settings would be to give the ResolverImpl an Executor created with &lt;tt&gt;Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())&lt;/tt&gt; with a lifecycle controlled by the framework.&lt;/p&gt;</comment>
                            <comment id="14707184" author="tjwatson" created="Fri, 21 Aug 2015 18:17:01 +0000"  >&lt;p&gt;I&apos;m going to try something like the following so that the pool of threads quickly can go to zero threads when idle which is shortly after startup.&lt;/p&gt;

&lt;p&gt;new ThreadPoolExecutor(&lt;br/&gt;
	// Always want to go to zero threads when idle&lt;br/&gt;
	0,&lt;br/&gt;
	// use the number of processors - 1 because we use the current thread when rejected&lt;br/&gt;
	Math.max(Runtime.getRuntime().availableProcessors() - 1, 1),&lt;br/&gt;
	// idle timeout; make it short to get rid of threads quickly after resolve&lt;br/&gt;
	5,&lt;br/&gt;
	// unit for timeout&lt;br/&gt;
	TimeUnit.SECONDS,&lt;br/&gt;
	// use sync queue to force thread creation&lt;br/&gt;
	new SynchronousQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;
	// try to name the threads with useful name&lt;br/&gt;
	new ThreadFactory() {&lt;br/&gt;
		@Override&lt;br/&gt;
		public Thread newThread(Runnable r) &lt;/p&gt;
{
			return new Thread(r, &quot;Resolver thread - &quot; + adaptor.toString()); //$NON-NLS-1$
		}
&lt;p&gt;	},&lt;br/&gt;
	// use a rejection policy that simply runs the task in the current thread once the max threads is reached&lt;br/&gt;
	new RejectedExecutionHandler() {&lt;br/&gt;
		@Override&lt;br/&gt;
		public void rejectedExecution(Runnable r, ThreadPoolExecutor exe) &lt;/p&gt;
{
			r.run();
		}
&lt;p&gt;	});&lt;/p&gt;

&lt;p&gt;I register a different instance of the resolver as a service, for that I will likely use the default behavior which will create/shutdown the internal executor.  If that proves to be an issue then I may register it using a PrototypeSeviceFactory such that the executor is created/shutdown when the new service object is created/destroyed.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 13 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2i9tj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>