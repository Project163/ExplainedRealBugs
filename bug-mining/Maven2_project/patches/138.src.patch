diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
index c8c5a9d59..86c03d93b 100644
--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
@@ -51,16 +51,16 @@ import org.apache.maven.project.inheritance.ModelInheritanceAssembler;
 import org.codehaus.plexus.util.xml.Xpp3Dom;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.TreeMap;
-import java.util.HashMap;
 
 public final class ModelUtils
 {
-    
+
     /**
      * Given this plugin list:
      *
@@ -111,74 +111,74 @@ public final class ModelUtils
 
     /**
      * This should be the resulting ordering of plugins after merging:
-     * 
+     *
      * Given:
-     * 
+     *
      *   parent: X -> A -> B -> D -> E
      *   child: Y -> A -> C -> D -> F
-     *  
-     * Result: 
-     * 
+     *
+     * Result:
+     *
      *   X -> Y -> A -> B -> C -> D -> E -> F
      */
     public static void mergePluginLists( PluginContainer childContainer, PluginContainer parentContainer,
                                          boolean handleAsInheritance )
     {
-        if ( childContainer == null || parentContainer == null )
+        if ( ( childContainer == null ) || ( parentContainer == null ) )
         {
             // nothing to do.
             return;
         }
 
         List parentPlugins = parentContainer.getPlugins();
-        
-        if ( parentPlugins != null && !parentPlugins.isEmpty() )
+
+        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )
         {
             parentPlugins = new ArrayList( parentPlugins );
-            
-            // If we're processing this merge as an inheritance, we have to build up a list of 
+
+            // If we're processing this merge as an inheritance, we have to build up a list of
             // plugins that were considered for inheritance.
             if ( handleAsInheritance )
             {
                 for ( Iterator it = parentPlugins.iterator(); it.hasNext(); )
                 {
                     Plugin plugin = (Plugin) it.next();
-                    
+
                     String inherited = plugin.getInherited();
-                    
-                    if ( inherited != null && !Boolean.valueOf( inherited ).booleanValue() )
+
+                    if ( ( inherited != null ) && !Boolean.valueOf( inherited ).booleanValue() )
                     {
                         it.remove();
                     }
                 }
             }
-            
+
             List assembledPlugins = new ArrayList();
 
             Map childPlugins = childContainer.getPluginsAsMap();
-            
+
             for ( Iterator it = parentPlugins.iterator(); it.hasNext(); )
             {
                 Plugin parentPlugin = (Plugin) it.next();
 
                 String parentInherited = parentPlugin.getInherited();
 
-                // only merge plugin definition from the parent if at least one 
+                // only merge plugin definition from the parent if at least one
                 // of these is true:
                 // 1. we're not processing the plugins in an inheritance-based merge
                 // 2. the parent's <inherited/> flag is not set
                 // 3. the parent's <inherited/> flag is set to true
-                if ( !handleAsInheritance || parentInherited == null ||
+                if ( !handleAsInheritance || ( parentInherited == null ) ||
                     Boolean.valueOf( parentInherited ).booleanValue() )
                 {
                     Plugin childPlugin = (Plugin) childPlugins.get( parentPlugin.getKey() );
 
-                    if ( childPlugin != null && !assembledPlugins.contains( childPlugin ) )
+                    if ( ( childPlugin != null ) && !assembledPlugins.contains( childPlugin ) )
                     {
                         Plugin assembledPlugin = childPlugin;
 
                         mergePluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );
-                        
+
                         // fix for MNG-2221 (assembly cache was not being populated for later reference):
                         assembledPlugins.add( assembledPlugin );
                     }
@@ -186,18 +186,18 @@ public final class ModelUtils
                     // if we're processing this as an inheritance-based merge, and
                     // the parent's <inherited/> flag is not set, then we need to
                     // clear the inherited flag in the merge result.
-                    if ( handleAsInheritance && parentInherited == null )
+                    if ( handleAsInheritance && ( parentInherited == null ) )
                     {
                         parentPlugin.unsetInheritanceApplied();
                     }
                 }
-                
+
                 // very important to use the parentPlugins List, rather than parentContainer.getPlugins()
                 // since this list is a local one, and may have been modified during processing.
                 List results = ModelUtils.orderAfterMerge( assembledPlugins, parentPlugins,
                                                                         childContainer.getPlugins() );
-                
-                
+
+
                 childContainer.setPlugins( results );
 
                 childContainer.flushPluginMap();
@@ -208,40 +208,40 @@ public final class ModelUtils
     public static List orderAfterMerge( List merged, List highPrioritySource, List lowPrioritySource )
     {
         List results = new ArrayList();
-        
+
         if ( !merged.isEmpty() )
         {
             results.addAll( merged );
         }
-        
+
         List missingFromResults = new ArrayList();
-        
+
         List sources = new ArrayList();
-        
+
         sources.add( highPrioritySource );
         sources.add( lowPrioritySource );
-        
+
         for ( Iterator sourceIterator = sources.iterator(); sourceIterator.hasNext(); )
         {
             List source = (List) sourceIterator.next();
-            
+
             for ( Iterator it = source.iterator(); it.hasNext(); )
             {
                 Object item = it.next();
-                
+
                 if ( results.contains( item ) )
                 {
                     if ( !missingFromResults.isEmpty() )
                     {
                         int idx = results.indexOf( item );
-                        
+
                         if ( idx < 0 )
                         {
                             idx = 0;
                         }
-                        
+
                         results.addAll( idx, missingFromResults );
-                        
+
                         missingFromResults.clear();
                     }
                 }
@@ -250,21 +250,21 @@ public final class ModelUtils
                     missingFromResults.add( item );
                 }
             }
-            
+
             if ( !missingFromResults.isEmpty() )
             {
                 results.addAll( missingFromResults );
-                
+
                 missingFromResults.clear();
             }
         }
-        
+
         return results;
     }
 
     public static void mergeReportPluginLists( Reporting child, Reporting parent, boolean handleAsInheritance )
     {
-        if ( child == null || parent == null )
+        if ( ( child == null ) || ( parent == null ) )
         {
             // nothing to do.
             return;
@@ -272,7 +272,7 @@ public final class ModelUtils
 
         List parentPlugins = parent.getPlugins();
 
-        if ( parentPlugins != null && !parentPlugins.isEmpty() )
+        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )
         {
             Map assembledPlugins = new TreeMap();
 
@@ -284,7 +284,7 @@ public final class ModelUtils
 
                 String parentInherited = parentPlugin.getInherited();
 
-                if ( !handleAsInheritance || parentInherited == null ||
+                if ( !handleAsInheritance || ( parentInherited == null ) ||
                     Boolean.valueOf( parentInherited ).booleanValue() )
                 {
 
@@ -299,7 +299,7 @@ public final class ModelUtils
                         mergeReportPluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );
                     }
 
-                    if ( handleAsInheritance && parentInherited == null )
+                    if ( handleAsInheritance && ( parentInherited == null ) )
                     {
                         assembledPlugin.unsetInheritanceApplied();
                     }
@@ -326,7 +326,7 @@ public final class ModelUtils
 
     public static void mergePluginDefinitions( Plugin child, Plugin parent, boolean handleAsInheritance )
     {
-        if ( child == null || parent == null )
+        if ( ( child == null ) || ( parent == null ) )
         {
             // nothing to do.
             return;
@@ -337,7 +337,7 @@ public final class ModelUtils
             child.setExtensions( true );
         }
 
-        if ( child.getVersion() == null && parent.getVersion() != null )
+        if ( ( child.getVersion() == null ) && ( parent.getVersion() != null ) )
         {
             child.setVersion( parent.getVersion() );
         }
@@ -354,14 +354,14 @@ public final class ModelUtils
         // from here to the end of the method is dealing with merging of the <executions/> section.
         String parentInherited = parent.getInherited();
 
-        boolean parentIsInherited = parentInherited == null || Boolean.valueOf( parentInherited ).booleanValue();
+        boolean parentIsInherited = ( parentInherited == null ) || Boolean.valueOf( parentInherited ).booleanValue();
 
         List parentExecutions = parent.getExecutions();
 
-        if ( parentExecutions != null && !parentExecutions.isEmpty() )
+        if ( ( parentExecutions != null ) && !parentExecutions.isEmpty() )
         {
             List mergedExecutions = new ArrayList();
-            
+
             Map assembledExecutions = new TreeMap();
 
             Map childExecutions = child.getExecutionsAsMap();
@@ -370,7 +370,11 @@ public final class ModelUtils
             {
                 PluginExecution parentExecution = (PluginExecution) it.next();
 
-                if ( !handleAsInheritance || parentIsInherited )
+                String inherited = parentExecution.getInherited();
+
+                boolean parentExecInherited = parentIsInherited && ( ( inherited == null ) || Boolean.valueOf( inherited ).booleanValue() );
+
+                if ( !handleAsInheritance || parentExecInherited )
                 {
                     PluginExecution assembled = parentExecution;
 
@@ -382,7 +386,7 @@ public final class ModelUtils
 
                         assembled = childExecution;
                     }
-                    else if ( handleAsInheritance && parentInherited == null )
+                    else if ( handleAsInheritance && ( parentInherited == null ) )
                     {
                         parentExecution.unsetInheritanceApplied();
                     }
@@ -412,13 +416,13 @@ public final class ModelUtils
     public static void mergeReportPluginDefinitions( ReportPlugin child, ReportPlugin parent,
                                                      boolean handleAsInheritance )
     {
-        if ( child == null || parent == null )
+        if ( ( child == null ) || ( parent == null ) )
         {
             // nothing to do.
             return;
         }
 
-        if ( child.getVersion() == null && parent.getVersion() != null )
+        if ( ( child.getVersion() == null ) && ( parent.getVersion() != null ) )
         {
             child.setVersion( parent.getVersion() );
         }
@@ -426,11 +430,11 @@ public final class ModelUtils
         // from here to the end of the method is dealing with merging of the <executions/> section.
         String parentInherited = parent.getInherited();
 
-        boolean parentIsInherited = parentInherited == null || Boolean.valueOf( parentInherited ).booleanValue();
+        boolean parentIsInherited = ( parentInherited == null ) || Boolean.valueOf( parentInherited ).booleanValue();
 
         List parentReportSets = parent.getReportSets();
 
-        if ( parentReportSets != null && !parentReportSets.isEmpty() )
+        if ( ( parentReportSets != null ) && !parentReportSets.isEmpty() )
         {
             Map assembledReportSets = new TreeMap();
 
@@ -452,7 +456,7 @@ public final class ModelUtils
 
                         assembledReportSet = childReportSet;
                     }
-                    else if ( handleAsInheritance && parentInherited == null )
+                    else if ( handleAsInheritance && ( parentInherited == null ) )
                     {
                         parentReportSet.unsetInheritanceApplied();
                     }
@@ -492,7 +496,7 @@ public final class ModelUtils
 
         List goals = new ArrayList();
 
-        if ( childGoals != null && !childGoals.isEmpty() )
+        if ( ( childGoals != null ) && !childGoals.isEmpty() )
         {
             goals.addAll( childGoals );
         }
@@ -527,7 +531,7 @@ public final class ModelUtils
 
         List reports = new ArrayList();
 
-        if ( childReports != null && !childReports.isEmpty() )
+        if ( ( childReports != null ) && !childReports.isEmpty() )
         {
             reports.addAll( childReports );
         }
@@ -616,7 +620,7 @@ public final class ModelUtils
 
             List modules = profile.getModules();
 
-            if ( modules != null && !modules.isEmpty() )
+            if ( ( modules != null ) && !modules.isEmpty() )
             {
                 newProfile.setModules( new ArrayList( modules ) );
             }
@@ -1010,7 +1014,7 @@ public final class ModelUtils
 
                 List goals = exec.getGoals();
 
-                if ( goals != null && !goals.isEmpty() )
+                if ( ( goals != null ) && !goals.isEmpty() )
                 {
                     newExec.setGoals( new ArrayList( goals ) );
                 }
diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
index 38903ee8c..3050dc9a1 100644
--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
@@ -33,7 +33,6 @@ import org.apache.maven.project.ModelUtils;
 import org.codehaus.plexus.util.StringUtils;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
@@ -336,13 +335,13 @@ public class DefaultModelInheritanceAssembler
             ModelUtils.mergeFilterLists( childBuild.getFilters(), parentBuild.getFilters() );
 
             List resources = childBuild.getResources();
-            if ( resources == null || resources.isEmpty() )
+            if ( ( resources == null ) || resources.isEmpty() )
             {
                 childBuild.setResources( parentBuild.getResources() );
             }
 
             resources = childBuild.getTestResources();
-            if ( resources == null || resources.isEmpty() )
+            if ( ( resources == null ) || resources.isEmpty() )
             {
                 childBuild.setTestResources( parentBuild.getTestResources() );
             }
@@ -354,8 +353,9 @@ public class DefaultModelInheritanceAssembler
             PluginManagement dominantPM = childBuild.getPluginManagement();
             PluginManagement recessivePM = parentBuild.getPluginManagement();
 
-            if ( dominantPM == null && recessivePM != null )
+            if ( ( dominantPM == null ) && ( recessivePM != null ) )
             {
+                // FIXME: Filter out the inherited == false stuff!
                 childBuild.setPluginManagement( recessivePM );
             }
             else
@@ -494,10 +494,14 @@ public class DefaultModelInheritanceAssembler
         if ( appendPaths )
         {
             if ( pathAdjustment != null )
+            {
                 uncleanPath += "/" + pathAdjustment;
+            }
 
             if ( childPath != null )
+            {
                 uncleanPath += "/" + childPath;
+            }
         }
 
         String cleanedPath = "";
@@ -511,7 +515,9 @@ public class DefaultModelInheritanceAssembler
         }
 
         if ( uncleanPath.startsWith( "/" ) )
+        {
             cleanedPath += "/";
+        }
 
         return cleanedPath + resolvePath( uncleanPath );
     }
@@ -525,7 +531,7 @@ public class DefaultModelInheritanceAssembler
 
         while ( tokenizer.hasMoreTokens() )
         {
-            String token = (String) tokenizer.nextToken();
+            String token = tokenizer.nextToken();
 
             if ( token.equals( "" ) )
             {
@@ -557,7 +563,9 @@ public class DefaultModelInheritanceAssembler
         {
             cleanedPath.append( pathElements.removeFirst() );
             if ( !pathElements.isEmpty() )
+            {
                 cleanedPath.append( '/' );
+            }
         }
 
         return cleanedPath.toString();
diff --git a/maven-project/src/test/java/org/apache/maven/project/ModelUtilsTest.java b/maven-project/src/test/java/org/apache/maven/project/ModelUtilsTest.java
index d99be75da..0b4170fa1 100644
--- a/maven-project/src/test/java/org/apache/maven/project/ModelUtilsTest.java
+++ b/maven-project/src/test/java/org/apache/maven/project/ModelUtilsTest.java
@@ -19,13 +19,11 @@ package org.apache.maven.project;
  * under the License.
  */
 
-import junit.framework.TestCase;
-
 import org.apache.maven.model.Build;
+import org.apache.maven.model.Dependency;
 import org.apache.maven.model.Plugin;
 import org.apache.maven.model.PluginContainer;
 import org.apache.maven.model.PluginExecution;
-import org.apache.maven.model.Dependency;
 import org.codehaus.plexus.util.xml.Xpp3Dom;
 
 import java.util.Collections;
@@ -33,10 +31,12 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
+import junit.framework.TestCase;
+
 public class ModelUtilsTest
     extends TestCase
 {
-    
+
     public void testShouldUseMainPluginDependencyVersionOverManagedDepVersion()
     {
         Plugin mgtPlugin = createPlugin( "group", "artifact", "1", Collections.EMPTY_MAP );
@@ -67,104 +67,104 @@ public class ModelUtilsTest
     public void testShouldNotInheritPluginWithInheritanceSetToFalse()
     {
         PluginContainer parent = new PluginContainer();
-        
+
         Plugin parentPlugin = createPlugin( "group", "artifact", "1.0", Collections.EMPTY_MAP );
         parentPlugin.setInherited( "false" );
-        
+
         parent.addPlugin( parentPlugin );
-        
+
         PluginContainer child = new PluginContainer();
-        
+
         child.addPlugin( createPlugin( "group3", "artifact3", "1.0", Collections.EMPTY_MAP ) );
-        
+
         ModelUtils.mergePluginLists( child, parent, true );
-        
+
         List results = child.getPlugins();
-        
+
         assertEquals( 1, results.size() );
-        
+
         Plugin result1 = (Plugin) results.get( 0 );
         assertEquals( "group3", result1.getGroupId() );
         assertEquals( "artifact3", result1.getArtifactId() );
     }
-    
+
     /**
      * Test that this is the resulting ordering of plugins after merging:
-     * 
+     *
      * Given:
-     * 
+     *
      *   parent: X -> A -> B -> D -> E
      *   child: Y -> A -> C -> D -> F
-     *  
-     * Result: 
-     * 
+     *
+     * Result:
+     *
      *   X -> Y -> A -> B -> C -> D -> E -> F
      */
     public void testShouldPreserveChildOrderingOfPluginsAfterParentMerge()
     {
         PluginContainer parent = new PluginContainer();
-        
+
         parent.addPlugin( createPlugin( "group", "artifact", "1.0", Collections.EMPTY_MAP ) );
         parent.addPlugin( createPlugin( "group2", "artifact2", "1.0", Collections.singletonMap( "key", "value" ) ) );
-        
+
         PluginContainer child = new PluginContainer();
-        
+
         child.addPlugin( createPlugin( "group3", "artifact3", "1.0", Collections.EMPTY_MAP ) );
         child.addPlugin( createPlugin( "group2", "artifact2", "1.0", Collections.singletonMap( "key2", "value2" ) ) );
-        
+
         ModelUtils.mergePluginLists( child, parent, true );
-        
+
         List results = child.getPlugins();
-        
+
         assertEquals( 3, results.size() );
-        
+
         Plugin result1 = (Plugin) results.get( 0 );
-        
+
         assertEquals( "group", result1.getGroupId() );
         assertEquals( "artifact", result1.getArtifactId() );
-        
+
         Plugin result2 = (Plugin) results.get( 1 );
-        
+
         assertEquals( "group3", result2.getGroupId() );
         assertEquals( "artifact3", result2.getArtifactId() );
-        
+
         Plugin result3 = (Plugin) results.get( 2 );
-        
+
         assertEquals( "group2", result3.getGroupId() );
         assertEquals( "artifact2", result3.getArtifactId() );
-        
+
         Xpp3Dom result3Config = (Xpp3Dom) result3.getConfiguration();
-        
+
         assertNotNull( result3Config );
-        
+
         assertEquals( "value", result3Config.getChild( "key" ).getValue() );
         assertEquals( "value2", result3Config.getChild( "key2" ).getValue() );
     }
-    
+
     private Plugin createPlugin( String groupId, String artifactId, String version, Map configuration )
     {
         Plugin plugin = new Plugin();
         plugin.setGroupId( groupId );
         plugin.setArtifactId( artifactId );
         plugin.setVersion( version );
-        
+
         Xpp3Dom config = new Xpp3Dom( "configuration" );
-        
+
         if( configuration != null )
         {
             for ( Iterator it = configuration.entrySet().iterator(); it.hasNext(); )
             {
                 Map.Entry entry = (Map.Entry) it.next();
-                
+
                 Xpp3Dom param = new Xpp3Dom( String.valueOf( entry.getKey() ) );
                 param.setValue( String.valueOf( entry.getValue() ) );
-                
+
                 config.addChild( param );
             }
         }
-        
+
         plugin.setConfiguration( config );
-        
+
         return plugin;
     }
 
@@ -228,7 +228,7 @@ public class ModelUtilsTest
         parentExecution.setId( "testExecution" );
 
         parent.addExecution( parentExecution );
-        
+
         Build parentContainer = new Build();
         parentContainer.addPlugin( parent );
 
@@ -236,18 +236,18 @@ public class ModelUtilsTest
         child.setArtifactId( "testArtifact" );
         child.setGroupId( "testGroup" );
         child.setVersion( "1.0" );
-        
+
         Build childContainer = new Build();
         childContainer.addPlugin( child );
 
         ModelUtils.mergePluginLists( childContainer, parentContainer, true );
-        
+
         List plugins = childContainer.getPlugins();
-        
+
         assertEquals( 1, plugins.size() );
-        
+
         Plugin plugin = (Plugin) plugins.get( 0 );
-        
+
         assertEquals( 1, plugin.getExecutions().size() );
     }
 
@@ -262,7 +262,7 @@ public class ModelUtilsTest
         parentExecution.setId( "testExecution" );
 
         parent.addExecution( parentExecution );
-        
+
         Build parentContainer = new Build();
         parentContainer.addPlugin( parent );
 
@@ -276,18 +276,18 @@ public class ModelUtilsTest
 
         child.addExecution( childExecution );
 
-        
+
         Build childContainer = new Build();
         childContainer.addPlugin( child );
 
         ModelUtils.mergePluginLists( childContainer, parentContainer, true );
-        
+
         List plugins = childContainer.getPlugins();
-        
+
         assertEquals( 1, plugins.size() );
-        
+
         Plugin plugin = (Plugin) plugins.get( 0 );
-        
+
         assertEquals( 2, plugin.getExecutions().size() );
     }
 
@@ -455,4 +455,125 @@ public class ModelUtilsTest
 
         assertEquals( 2, ((Plugin)first.getPlugins().get( 0 ) ).getDependencies().size() );
     }
+
+    public void testShouldNotMergePluginExecutionWhenExecInheritedIsFalseAndTreatAsInheritanceIsTrue()
+    {
+        String gid = "group";
+        String aid = "artifact";
+        String ver = "1";
+
+        PluginContainer parent = new PluginContainer();
+        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+
+        pParent.setInherited( Boolean.toString( true ) );
+
+        PluginExecution eParent = new PluginExecution();
+
+        String testId = "test";
+
+        eParent.setId( testId );
+        eParent.addGoal( "run" );
+        eParent.setPhase( "initialize" );
+        eParent.setInherited( Boolean.toString( false ) );
+
+        pParent.addExecution( eParent );
+        parent.addPlugin( pParent );
+
+        PluginContainer child = new PluginContainer();
+        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+        PluginExecution eChild = new PluginExecution();
+
+        eChild.setId( "child-specified" );
+        eChild.addGoal( "child" );
+        eChild.setPhase( "compile" );
+
+        pChild.addExecution( eChild );
+        child.addPlugin( pChild );
+
+        ModelUtils.mergePluginDefinitions( pChild, pParent, true );
+
+        Map executionMap = pChild.getExecutionsAsMap();
+        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
+    }
+
+    public void testShouldNotMergePluginExecutionWhenPluginInheritedIsFalseAndTreatAsInheritanceIsTrue()
+    {
+        String gid = "group";
+        String aid = "artifact";
+        String ver = "1";
+
+        PluginContainer parent = new PluginContainer();
+        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+
+        pParent.setInherited( Boolean.toString( false ) );
+
+        PluginExecution eParent = new PluginExecution();
+
+        String testId = "test";
+
+        eParent.setId( testId );
+        eParent.addGoal( "run" );
+        eParent.setPhase( "initialize" );
+        eParent.setInherited( Boolean.toString( true ) );
+
+        pParent.addExecution( eParent );
+        parent.addPlugin( pParent );
+
+        PluginContainer child = new PluginContainer();
+        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+        PluginExecution eChild = new PluginExecution();
+
+        eChild.setId( "child-specified" );
+        eChild.addGoal( "child" );
+        eChild.setPhase( "compile" );
+
+        pChild.addExecution( eChild );
+        child.addPlugin( pChild );
+
+        ModelUtils.mergePluginDefinitions( pChild, pParent, true );
+
+        Map executionMap = pChild.getExecutionsAsMap();
+        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
+    }
+
+    public void testShouldMergePluginExecutionWhenExecInheritedIsTrueAndTreatAsInheritanceIsTrue()
+    {
+        String gid = "group";
+        String aid = "artifact";
+        String ver = "1";
+
+        PluginContainer parent = new PluginContainer();
+        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+
+        pParent.setInherited( Boolean.toString( true ) );
+
+        PluginExecution eParent = new PluginExecution();
+
+        String testId = "test";
+
+        eParent.setId( testId );
+        eParent.addGoal( "run" );
+        eParent.setPhase( "initialize" );
+        eParent.setInherited( Boolean.toString( true ) );
+
+        pParent.addExecution( eParent );
+        parent.addPlugin( pParent );
+
+        PluginContainer child = new PluginContainer();
+        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
+        PluginExecution eChild = new PluginExecution();
+
+        eChild.setId( "child-specified" );
+        eChild.addGoal( "child" );
+        eChild.setPhase( "compile" );
+
+        pChild.addExecution( eChild );
+        child.addPlugin( pChild );
+
+        ModelUtils.mergePluginDefinitions( pChild, pParent, true );
+
+        Map executionMap = pChild.getExecutionsAsMap();
+        assertNotNull( "test execution should be inherited from parent.", executionMap.get( testId ) );
+    }
+
 }
diff --git a/maven-project/src/test/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssemblerTest.java b/maven-project/src/test/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssemblerTest.java
index 7affed328..05a2fa67b 100644
--- a/maven-project/src/test/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssemblerTest.java
+++ b/maven-project/src/test/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssemblerTest.java
@@ -19,7 +19,6 @@ package org.apache.maven.project.inheritance;
  * under the License.
  */
 
-import junit.framework.TestCase;
 import org.apache.maven.model.Build;
 import org.apache.maven.model.Dependency;
 import org.apache.maven.model.DependencyManagement;
@@ -45,6 +44,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
+import junit.framework.TestCase;
+
 /**
  * @author jdcasey
  */
@@ -52,129 +53,129 @@ public class DefaultModelInheritanceAssemblerTest
     extends TestCase
 {
     private ModelInheritanceAssembler assembler = new DefaultModelInheritanceAssembler();
-    
+
     public void testShouldAdjustChildUrlBasedOnParentAndModulePathInSiblingDir()
     {
         Model parent = makeBaseModel( "parent" );
-        
+
         parent.setUrl( "http://www.google.com/parent" );
-        
+
         Model child = makeBaseModel( "child" );
-        
+
         // TODO: this is probably what we should be appending...
 //        child.setUrl( "/child.dir" );
-        
+
         parent.addModule( "../child" );
-        
+
         assembler.assembleModelInheritance( child, parent, ".." );
-        
+
         String resultingUrl = child.getUrl();
-        
+
         System.out.println( resultingUrl );
-        
+
         assertEquals( "http://www.google.com/child", resultingUrl );
     }
-    
+
     public void testShouldAdjustPathsThreeLevelsDeepAncestryInRepoAndNonStandardModulePaths()
     {
         Model top = makeBaseModel( "top" );
-        
+
         top.setUrl( "http://www.google.com/top" );
-        
+
         Model middle = makeBaseModel( "middle" );
-        
+
         top.addModule( "../middle" );
-        
+
         Model bottom = makeBaseModel( "bottom" );
-        
+
         middle.addModule( "../bottom" );
-        
+
         assembler.assembleModelInheritance( middle, top, ".." );
         assembler.assembleModelInheritance( bottom, middle, ".." );
-        
+
         String resultingUrl = bottom.getUrl();
-        
+
         System.out.println( resultingUrl );
-        
+
         assertEquals( "http://www.google.com/bottom", resultingUrl );
     }
-    
+
     public void testShouldMergeSuccessiveDependencyManagementSectionsOverThreeLevels()
     {
         Model top = makeBaseModel( "top" );
-        
+
         DependencyManagement topMgmt = new DependencyManagement();
-        
+
         topMgmt.addDependency( makeDep( "top-dep" ) );
-        
+
         top.setDependencyManagement( topMgmt );
-        
+
         Model mid = makeBaseModel( "mid" );
-        
+
         DependencyManagement midMgmt = new DependencyManagement();
-        
+
         midMgmt.addDependency( makeDep( "mid-dep" ) );
-        
+
         mid.setDependencyManagement( midMgmt );
-        
+
         Model bottom = makeBaseModel( "bottom" );
-        
+
         DependencyManagement bottomMgmt = new DependencyManagement();
-        
+
         bottomMgmt.addDependency( makeDep( "bottom-dep" ) );
-        
+
         bottom.setDependencyManagement( bottomMgmt );
-        
+
         assembler.assembleModelInheritance( mid, top );
-        
+
         assembler.assembleModelInheritance( bottom, mid );
-        
+
         DependencyManagement result = bottom.getDependencyManagement();
-        
+
         List resultDeps = result.getDependencies();
-        
+
         assertEquals( 3, resultDeps.size() );
     }
-    
+
     public void testShouldMergeDependencyManagementSectionsFromTopTwoLevelsToBottomLevel()
     {
         Model top = makeBaseModel( "top" );
-        
+
         DependencyManagement topMgmt = new DependencyManagement();
-        
+
         topMgmt.addDependency( makeDep( "top-dep" ) );
-        
+
         top.setDependencyManagement( topMgmt );
-        
+
         Model mid = makeBaseModel( "mid" );
-        
+
         DependencyManagement midMgmt = new DependencyManagement();
-        
+
         midMgmt.addDependency( makeDep( "mid-dep" ) );
-        
+
         mid.setDependencyManagement( midMgmt );
-        
+
         Model bottom = makeBaseModel( "bottom" );
-        
+
         assembler.assembleModelInheritance( mid, top );
-        
+
         assembler.assembleModelInheritance( bottom, mid );
-        
+
         DependencyManagement result = bottom.getDependencyManagement();
-        
+
         List resultDeps = result.getDependencies();
-        
+
         assertEquals( 2, resultDeps.size() );
     }
-    
+
     private Dependency makeDep( String artifactId )
     {
         Dependency dep = new Dependency();
-        
+
         dep.setGroupId( "maven" );
         dep.setArtifactId( artifactId );
         dep.setVersion( "1.0" );
-        
+
         return dep;
     }
 
@@ -590,7 +591,7 @@ public class DefaultModelInheritanceAssemblerTest
     {
         Build childBuild = child.getBuild();
 
-        if ( expectedPlugins != null && !expectedPlugins.isEmpty() )
+        if ( ( expectedPlugins != null ) && !expectedPlugins.isEmpty() )
         {
             assertNotNull( childBuild );
 
@@ -616,7 +617,7 @@ public class DefaultModelInheritanceAssemblerTest
         }
         else
         {
-            assertTrue( childBuild == null || childBuild.getPlugins() == null || childBuild.getPlugins().isEmpty() );
+            assertTrue( ( childBuild == null ) || ( childBuild.getPlugins() == null ) || childBuild.getPlugins().isEmpty() );
         }
     }
 
@@ -628,9 +629,9 @@ public class DefaultModelInheritanceAssemblerTest
         List referenceExecutions = reference.getExecutions();
         Map testExecutionsMap = test.getExecutionsAsMap();
 
-        if ( referenceExecutions != null && !referenceExecutions.isEmpty() )
+        if ( ( referenceExecutions != null ) && !referenceExecutions.isEmpty() )
         {
-            assertTrue( "Missing goals specification", ( testExecutionsMap != null && !testExecutionsMap.isEmpty() ) );
+            assertTrue( "Missing goals specification", ( ( testExecutionsMap != null ) && !testExecutionsMap.isEmpty() ) );
 
             for ( Iterator it = referenceExecutions.iterator(); it.hasNext(); )
             {
@@ -648,7 +649,7 @@ public class DefaultModelInheritanceAssemblerTest
         else
         {
             assertTrue( "Unexpected goals specification",
-                        ( testExecutionsMap == null || testExecutionsMap.isEmpty() ) );
+                        ( ( testExecutionsMap == null ) || testExecutionsMap.isEmpty() ) );
         }
     }
 
@@ -746,11 +747,129 @@ public class DefaultModelInheritanceAssemblerTest
         assertReports( new ArrayList(), child );
     }
 
+    public void testPluginExecInheritanceWhereExecInheritedSetToFalse()
+    {
+        String testId = "test";
+        String gid = "group";
+        String aid = "artifact";
+        String ver = "1";
+
+        Model child = makeBaseModel( "child" );
+
+        Plugin pChild = new Plugin();
+        pChild.setGroupId( gid );
+        pChild.setArtifactId( aid );
+        pChild.setVersion( ver );
+
+        PluginExecution eChild = new PluginExecution();
+        eChild.setId( "normal" );
+        eChild.addGoal( "run" );
+
+        pChild.addExecution( eChild );
+
+        Build bChild = new Build();
+        bChild.addPlugin( pChild );
+
+        child.setBuild( bChild );
+
+        Model parent = makeBaseModel( "parent" );
+
+        Plugin pParent = new Plugin();
+        pParent.setGroupId( gid );
+        pParent.setArtifactId( aid );
+        pParent.setVersion( ver );
+
+        pParent.setInherited( Boolean.toString( true ) );
+
+        PluginExecution eParent = new PluginExecution();
+        eParent.setId( testId );
+        eParent.addGoal( "test" );
+        eParent.setInherited( Boolean.toString( false ) );
+
+        pParent.addExecution( eParent );
+
+        Build bParent = new Build();
+        bParent.addPlugin( pParent );
+
+        parent.setBuild( bParent );
+
+        assembler.assembleModelInheritance( child, parent );
+
+        Map pluginMap = bChild.getPluginsAsMap();
+        assertNotNull( pluginMap );
+
+        Plugin plugin = (Plugin) pluginMap.get( gid + ":" + aid );
+        assertNotNull( plugin );
+
+        Map executionMap = plugin.getExecutionsAsMap();
+        assertNotNull( executionMap );
+
+        assertNull( "test execution with inherited == false should NOT be inherited to child model.", executionMap.get( testId ) );
+    }
+
+    public void testPluginExecInheritanceWhereExecInheritedSetToFalseAndPluginInheritedNotSet()
+    {
+        String testId = "test";
+        String gid = "group";
+        String aid = "artifact";
+        String ver = "1";
+
+        Model child = makeBaseModel( "child" );
+
+        Plugin pChild = new Plugin();
+        pChild.setGroupId( gid );
+        pChild.setArtifactId( aid );
+        pChild.setVersion( ver );
+
+        PluginExecution eChild = new PluginExecution();
+        eChild.setId( "normal" );
+        eChild.addGoal( "run" );
+
+        pChild.addExecution( eChild );
+
+        Build bChild = new Build();
+        bChild.addPlugin( pChild );
+
+        child.setBuild( bChild );
+
+        Model parent = makeBaseModel( "parent" );
+
+        Plugin pParent = new Plugin();
+        pParent.setGroupId( gid );
+        pParent.setArtifactId( aid );
+        pParent.setVersion( ver );
+
+        PluginExecution eParent = new PluginExecution();
+        eParent.setId( testId );
+        eParent.addGoal( "test" );
+        eParent.setInherited( Boolean.toString( false ) );
+
+        pParent.addExecution( eParent );
+
+        Build bParent = new Build();
+        bParent.addPlugin( pParent );
+
+        parent.setBuild( bParent );
+
+        assembler.assembleModelInheritance( child, parent );
+
+        Map pluginMap = bChild.getPluginsAsMap();
+        assertNotNull( pluginMap );
+
+        Plugin plugin = (Plugin) pluginMap.get( gid + ":" + aid );
+        assertNotNull( plugin );
+
+        Map executionMap = plugin.getExecutionsAsMap();
+        assertNotNull( executionMap );
+
+        assertNull( "test execution with inherited == false should NOT be inherited to child model.", executionMap.get( testId ) );
+    }
+
     private void assertReports( List expectedPlugins, Model child )
     {
         Reporting childBuild = child.getReporting();
 
-        if ( expectedPlugins != null && !expectedPlugins.isEmpty() )
+        if ( ( expectedPlugins != null ) && !expectedPlugins.isEmpty() )
         {
             assertNotNull( childBuild );
 
@@ -776,7 +895,7 @@ public class DefaultModelInheritanceAssemblerTest
         }
         else
         {
-            assertTrue( childBuild == null || childBuild.getPlugins() == null || childBuild.getPlugins().isEmpty() );
+            assertTrue( ( childBuild == null ) || ( childBuild.getPlugins() == null ) || childBuild.getPlugins().isEmpty() );
         }
     }
 
@@ -788,9 +907,9 @@ public class DefaultModelInheritanceAssemblerTest
         List referenceReportSets = reference.getReportSets();
         Map testReportSetsMap = test.getReportSetsAsMap();
 
-        if ( referenceReportSets != null && !referenceReportSets.isEmpty() )
+        if ( ( referenceReportSets != null ) && !referenceReportSets.isEmpty() )
         {
-            assertTrue( "Missing goals specification", ( testReportSetsMap != null && !testReportSetsMap.isEmpty() ) );
+            assertTrue( "Missing goals specification", ( ( testReportSetsMap != null ) && !testReportSetsMap.isEmpty() ) );
 
             for ( Iterator it = referenceReportSets.iterator(); it.hasNext(); )
             {
@@ -808,7 +927,7 @@ public class DefaultModelInheritanceAssemblerTest
         else
         {
             assertTrue( "Unexpected goals specification",
-                        ( testReportSetsMap == null || testReportSetsMap.isEmpty() ) );
+                        ( ( testReportSetsMap == null ) || testReportSetsMap.isEmpty() ) );
         }
     }
 
@@ -851,7 +970,7 @@ public class DefaultModelInheritanceAssemblerTest
     {
         Model model = makeBaseModel( artifactId );
 
-        if ( connection != null || developerConnection != null || url != null )
+        if ( ( connection != null ) || ( developerConnection != null ) || ( url != null ) )
         {
             Scm scm = new Scm();
 
diff --git a/maven-project/src/test/java/org/apache/maven/project/inheritance/t12/ProjectInheritanceTest.java b/maven-project/src/test/java/org/apache/maven/project/inheritance/t12/ProjectInheritanceTest.java
new file mode 100644
index 000000000..9ba260e7c
--- /dev/null
+++ b/maven-project/src/test/java/org/apache/maven/project/inheritance/t12/ProjectInheritanceTest.java
@@ -0,0 +1,65 @@
+package org.apache.maven.project.inheritance.t12;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import org.apache.maven.model.Plugin;
+import org.apache.maven.project.MavenProject;
+import org.apache.maven.project.inheritance.AbstractProjectInheritanceTestCase;
+
+import java.io.File;
+import java.util.Map;
+
+/**
+ * Verifies that plugin execution sections in the parent POM that have
+ * inherit == false are not inherited to the child POM.
+ */
+public class ProjectInheritanceTest extends AbstractProjectInheritanceTestCase
+{
+    // ----------------------------------------------------------------------
+    //
+    // p1 inherits from p0
+    // p0 inherits from super model
+    //
+    // or we can show it graphically as:
+    //
+    // p1 ---> p0 --> super model
+    //
+    // ----------------------------------------------------------------------
+
+    public void testFalsePluginExecutionInheritValue() throws Exception
+    {
+        File localRepo = getLocalRepositoryPath();
+
+        File pom0 = new File( localRepo, "p0/pom.xml" );
+        File pom0Basedir = pom0.getParentFile();
+        File pom1 = new File( pom0Basedir, "p1/pom.xml" );
+
+        getProjectWithDependencies( pom0 );
+        MavenProject project1 = getProjectWithDependencies( pom1 );
+
+        Map pluginMap = project1.getBuild().getPluginsAsMap();
+        Plugin compilerPlugin = (Plugin) pluginMap.get( "org.apache.maven.plugins:maven-compiler-plugin" );
+
+        assertNotNull( compilerPlugin );
+
+        Map executionMap = compilerPlugin.getExecutionsAsMap();
+        assertNull( "Plugin execution: \'test\' should NOT exist in the compiler plugin specification for the child project!", executionMap.get( "test" ) );
+    }
+}
\ No newline at end of file
diff --git a/maven-project/src/test/resources/inheritance-repo/t12/p0/p1/pom.xml b/maven-project/src/test/resources/inheritance-repo/t12/p0/p1/pom.xml
new file mode 100644
index 000000000..c97995654
--- /dev/null
+++ b/maven-project/src/test/resources/inheritance-repo/t12/p0/p1/pom.xml
@@ -0,0 +1,29 @@
+<project>
+  <parent>
+    <artifactId>p0</artifactId>
+    <groupId>maven</groupId>
+    <version>1.0</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>p1</artifactId>
+  <packaging>jar</packaging>
+  
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>normal</id>
+            
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+
+</project>
\ No newline at end of file
diff --git a/maven-project/src/test/resources/inheritance-repo/t12/p0/pom.xml b/maven-project/src/test/resources/inheritance-repo/t12/p0/pom.xml
new file mode 100644
index 000000000..54356618b
--- /dev/null
+++ b/maven-project/src/test/resources/inheritance-repo/t12/p0/pom.xml
@@ -0,0 +1,30 @@
+<project>
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>maven</groupId>
+  <artifactId>p0</artifactId>
+  <packaging>pom</packaging>
+  <version>1.0</version>
+  
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>test</id>
+            
+            <!--  The key to this test... -->
+            <inherited>false</inherited>
+            
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <phase>install</phase>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+
+</project>
\ No newline at end of file
