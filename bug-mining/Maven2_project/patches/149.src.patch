diff --git a/maven-project/src/main/java/org/apache/maven/project/DefaultMavenProjectBuilder.java b/maven-project/src/main/java/org/apache/maven/project/DefaultMavenProjectBuilder.java
index ea59d4fbc..9cd88b5ad 100644
--- a/maven-project/src/main/java/org/apache/maven/project/DefaultMavenProjectBuilder.java
+++ b/maven-project/src/main/java/org/apache/maven/project/DefaultMavenProjectBuilder.java
@@ -46,9 +46,11 @@ import org.apache.maven.model.Extension;
 import org.apache.maven.model.Model;
 import org.apache.maven.model.Parent;
 import org.apache.maven.model.Plugin;
+import org.apache.maven.model.PluginManagement;
 import org.apache.maven.model.Profile;
 import org.apache.maven.model.ReportPlugin;
 import org.apache.maven.model.Repository;
+import org.apache.maven.model.Resource;
 import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
 import org.apache.maven.profiles.DefaultProfileManager;
 import org.apache.maven.profiles.MavenProfilesBuilder;
@@ -893,10 +895,6 @@ public class DefaultMavenProjectBuilder
         // this only happens if we are building from a source file
         if ( projectDescriptor != null )
         {
-            // Only translate the base directory for files in the source tree
-            pathTranslator.alignToBaseDirectory( project.getModel(),
-                                                 projectDir );
-
             Build build = project.getBuild();
 
             project.addCompileSourceRoot( build.getSourceDirectory() );
@@ -909,6 +907,15 @@ public class DefaultMavenProjectBuilder
             project.setFile( projectDescriptor );
         }
 
+//        try
+//        {
+//            calculateConcreteState( project, config );
+//        }
+//        catch ( ModelInterpolationException e )
+//        {
+//            throw new InvalidProjectModelException( projectId, pomLocation, e.getMessage(), e );
+//        }
+
         project.setManagedVersionMap( createManagedVersionMap( projectId,
                                                                project.getDependencyManagement(),
                                                                project.getParent() ) );
@@ -983,46 +990,15 @@ public class DefaultMavenProjectBuilder
 
         activeProfiles.addAll( injectedProfiles );
 
-        // We don't need all the project methods that are added over those in the model, but we do need basedir
-        Map context = new HashMap();
-
-        Build build = model.getBuild();
-
-        if ( projectDir != null )
-        {
-            context.put( "basedir", projectDir.getAbsolutePath() );
-
-            // MNG-1927, MNG-2124, MNG-3355:
-            // If the build section is present and the project directory is non-null, we should make
-            // sure interpolation of the directories below uses translated paths.
-            // Afterward, we'll double back and translate any paths that weren't covered during interpolation via the
-            // code below...
-            context.put( "build.directory", pathTranslator.alignToBaseDirectory( build.getDirectory(), projectDir ) );
-            context.put( "build.outputDirectory", pathTranslator.alignToBaseDirectory( build.getOutputDirectory(), projectDir ) );
-            context.put( "build.testOutputDirectory", pathTranslator.alignToBaseDirectory( build.getTestOutputDirectory(), projectDir ) );
-            context.put( "build.sourceDirectory", pathTranslator.alignToBaseDirectory( build.getSourceDirectory(), projectDir ) );
-            context.put( "build.testSourceDirectory", pathTranslator.alignToBaseDirectory( build.getTestSourceDirectory(), projectDir ) );
-        }
+        Build dynamicBuild = model.getBuild();
 
-        if ( !isSuperPom )
-        {
-            Properties userProps = config.getUserProperties();
-            if ( userProps != null )
-            {
-                context.putAll( userProps );
-            }
-        }
+        model.setBuild( ModelUtils.cloneBuild( dynamicBuild ) );
 
-        model = modelInterpolator.interpolate( model, context, strict );
+        model = interpolate( model, projectDir, isSuperPom, config, strict );
 
-        // second pass allows ${user.home} to work, if it needs to.
-        // [MNG-2339] ensure the system properties are still interpolated for backwards compat, but the model values must win
-        if ( config.getExecutionProperties() != null && !config.getExecutionProperties().isEmpty() )
-        {
-            context.putAll( config.getExecutionProperties() );
-        }
+        mergeDeterministicBuildElements( model.getBuild(), dynamicBuild );
 
-        model = modelInterpolator.interpolate( model, context, strict );
+        model.setBuild( dynamicBuild );
 
         // MNG-3482: Make sure depMgmt is interpolated before merging.
         if ( !isSuperPom )
@@ -1122,6 +1098,106 @@ public class DefaultMavenProjectBuilder
         return project;
     }
 
+    private Model interpolate( Model model,
+                              File projectDir,
+                              boolean isSuperPom,
+                              ProjectBuilderConfiguration config,
+                              boolean strict )
+        throws ModelInterpolationException
+    {
+        // We don't need all the project methods that are added over those in the model, but we do need basedir
+        Map context = new HashMap();
+
+        Build build = model.getBuild();
+
+        if ( projectDir != null )
+        {
+            context.put( "basedir", projectDir.getAbsolutePath() );
+
+            // MNG-1927, MNG-2124, MNG-3355:
+            // If the build section is present and the project directory is non-null, we should make
+            // sure interpolation of the directories below uses translated paths.
+            // Afterward, we'll double back and translate any paths that weren't covered during interpolation via the
+            // code below...
+            context.put( "build.directory", pathTranslator.alignToBaseDirectory( build.getDirectory(), projectDir ) );
+            context.put( "build.outputDirectory", pathTranslator.alignToBaseDirectory( build.getOutputDirectory(), projectDir ) );
+            context.put( "build.testOutputDirectory", pathTranslator.alignToBaseDirectory( build.getTestOutputDirectory(), projectDir ) );
+            context.put( "build.sourceDirectory", pathTranslator.alignToBaseDirectory( build.getSourceDirectory(), projectDir ) );
+            context.put( "build.testSourceDirectory", pathTranslator.alignToBaseDirectory( build.getTestSourceDirectory(), projectDir ) );
+        }
+
+        if ( !isSuperPom )
+        {
+            Properties userProps = config.getUserProperties();
+            if ( userProps != null )
+            {
+                getLogger().debug( "Using user-defined properties for interpolation:\n" + String.valueOf( userProps ).replace( ',', '\n' ) );
+                context.putAll( userProps );
+            }
+        }
+
+        model = modelInterpolator.interpolate( model, context, strict );
+
+        // second pass allows ${user.home} to work, if it needs to.
+        // [MNG-2339] ensure the system properties are still interpolated for backwards compat, but the model values must win
+        if ( config.getExecutionProperties() != null && !config.getExecutionProperties().isEmpty() )
+        {
+            context.putAll( config.getExecutionProperties() );
+        }
+
+        model = modelInterpolator.interpolate( model, context, strict );
+
+        return model;
+    }
+
+    private void mergeDeterministicBuildElements( Build interpolatedBuild,
+                                                  Build dynamicBuild )
+    {
+        List dPlugins = dynamicBuild.getPlugins();
+
+        if ( dPlugins != null )
+        {
+            List iPlugins = interpolatedBuild.getPlugins();
+
+            for ( int i = 0; i < dPlugins.size(); i++ )
+            {
+                Plugin dPlugin = (Plugin) dPlugins.get( i );
+                Plugin iPlugin = (Plugin) iPlugins.get( i );
+
+                dPlugin.setGroupId( iPlugin.getGroupId() );
+                dPlugin.setArtifactId( iPlugin.getArtifactId() );
+                dPlugin.setVersion( iPlugin.getVersion() );
+            }
+        }
+
+        PluginManagement dPluginMgmt = dynamicBuild.getPluginManagement();
+
+        if ( dPluginMgmt != null )
+        {
+            PluginManagement iPluginMgmt = interpolatedBuild.getPluginManagement();
+            dPlugins = dPluginMgmt.getPlugins();
+            if ( dPlugins != null )
+            {
+                List iPlugins = iPluginMgmt.getPlugins();
+
+                for ( int i = 0; i < dPlugins.size(); i++ )
+                {
+                    Plugin dPlugin = (Plugin) dPlugins.get( i );
+                    Plugin iPlugin = (Plugin) iPlugins.get( i );
+
+                    dPlugin.setGroupId( iPlugin.getGroupId() );
+                    dPlugin.setArtifactId( iPlugin.getArtifactId() );
+                    dPlugin.setVersion( iPlugin.getVersion() );
+                }
+            }
+        }
+
+        if ( dynamicBuild.getExtensions() != null )
+        {
+            dynamicBuild.setExtensions( interpolatedBuild.getExtensions() );
+        }
+    }
+
     /**
      * @noinspection CollectionDeclaredAsConcreteClass
      * @todo We need to find an effective way to unit test parts of this method!
@@ -1778,4 +1854,511 @@ public class DefaultMavenProjectBuilder
         container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
     }
 
+    public void calculateConcreteState( MavenProject project, ProjectBuilderConfiguration config )
+        throws ModelInterpolationException
+    {
+        if ( project.isConcrete() )
+        {
+            return;
+        }
+
+        Model model = ModelUtils.cloneModel( project.getModel() );
+
+        // We don't need all the project methods that are added over those in the model, but we do need basedir
+        Map context = new HashMap();
+
+        boolean isSuperPom = project.getGroupId().equals( STANDALONE_SUPERPOM_GROUPID )
+                             && project.getArtifactId().equals( STANDALONE_SUPERPOM_ARTIFACTID )
+                             && project.getVersion().equals( STANDALONE_SUPERPOM_VERSION );
+
+        File basedir = project.getBasedir();
+
+        model = interpolate( model, basedir, isSuperPom, config, true );
+
+        List originalInterpolatedCompileSourceRoots = interpolateListOfStrings( project.getCompileSourceRoots(),
+                                                                           model,
+                                                                           context );
+
+        project.preserveCompileSourceRoots( originalInterpolatedCompileSourceRoots );
+
+        project.setCompileSourceRoots( originalInterpolatedCompileSourceRoots == null ? null
+                        : translateListOfPaths( originalInterpolatedCompileSourceRoots, basedir ) );
+
+        List originalInterpolatedTestCompileSourceRoots = interpolateListOfStrings( project.getTestCompileSourceRoots(),
+                                                                               model,
+                                                                               context );
+
+        project.preserveTestCompileSourceRoots( originalInterpolatedTestCompileSourceRoots );
+        project.setTestCompileSourceRoots( originalInterpolatedTestCompileSourceRoots == null ? null
+                        : translateListOfPaths( originalInterpolatedTestCompileSourceRoots, basedir ) );
+
+        List originalInterpolatedScriptSourceRoots = interpolateListOfStrings( project.getScriptSourceRoots(),
+                                                                          model,
+                                                                          context );
+
+        project.preserveScriptSourceRoots( originalInterpolatedScriptSourceRoots );
+        project.setScriptSourceRoots( originalInterpolatedScriptSourceRoots == null ? null
+                        : translateListOfPaths( originalInterpolatedScriptSourceRoots, basedir ) );
+
+        Model model2 = ModelUtils.cloneModel( model );
+
+        pathTranslator.alignToBaseDirectory( model, basedir );
+
+        project.preserveBuild( model2.getBuild() );
+        project.setBuild( model.getBuild() );
+
+        calculateConcreteProjectReferences( project, config );
+
+        if ( project.getExecutionProject() != null )
+        {
+            calculateConcreteState( project.getExecutionProject(), config );
+        }
+
+        project.setConcrete( true );
+    }
+
+    private void calculateConcreteProjectReferences( MavenProject project,
+                                                     ProjectBuilderConfiguration config )
+        throws ModelInterpolationException
+    {
+        Map projectRefs = project.getProjectReferences();
+
+        if ( projectRefs != null )
+        {
+            for ( Iterator it = projectRefs.values().iterator(); it.hasNext(); )
+            {
+                MavenProject reference = (MavenProject) it.next();
+                calculateConcreteState( reference, config );
+            }
+        }
+    }
+
+    private List translateListOfPaths( List paths, File basedir )
+    {
+        if ( paths == null )
+        {
+            return null;
+        }
+        else if ( basedir == null )
+        {
+            return paths;
+        }
+
+        List result = new ArrayList( paths.size() );
+        for ( Iterator it = paths.iterator(); it.hasNext(); )
+        {
+            String path = (String) it.next();
+
+            String aligned = pathTranslator.alignToBaseDirectory( path, basedir );
+
+            result.add( aligned );
+        }
+
+        return result;
+    }
+
+    public void restoreDynamicState( MavenProject project, ProjectBuilderConfiguration config )
+        throws ModelInterpolationException
+    {
+        if ( !project.isConcrete() )
+        {
+            return;
+        }
+
+        Build changedBuild = project.getBuild();
+
+        Map context = new HashMap();
+        populateBuildPaths( changedBuild, context, project.getBasedir() );
+        populateExecutionProperties( config, context );
+
+        restoreBuildRoots( project, config, context );
+        restoreModelBuildSection( project, config, context );
+
+        restoreDynamicProjectReferences( project, config );
+        if ( project.getExecutionProject() != null )
+        {
+            restoreDynamicState( project.getExecutionProject(), config );
+        }
+
+        project.setConcrete( false );
+    }
+
+    private void restoreDynamicProjectReferences( MavenProject project,
+                                                  ProjectBuilderConfiguration config )
+        throws ModelInterpolationException
+    {
+        Map projectRefs = project.getProjectReferences();
+        if ( projectRefs != null )
+        {
+            for ( Iterator it = projectRefs.values().iterator(); it.hasNext(); )
+            {
+                MavenProject projectRef = (MavenProject) it.next();
+                restoreDynamicState( projectRef, config );
+            }
+        }
+    }
+
+    private void restoreBuildRoots( MavenProject project,
+                                    ProjectBuilderConfiguration config,
+                                    Map context )
+        throws ModelInterpolationException
+    {
+        project.setCompileSourceRoots( restoreListOfStrings( project.getDynamicCompileSourceRoots(),
+                                                             project.getOriginalInterpolatedCompileSourceRoots(),
+                                                             project.getCompileSourceRoots(),
+                                                             project,
+                                                             context ) );
+
+        project.setTestCompileSourceRoots( restoreListOfStrings( project.getDynamicTestCompileSourceRoots(),
+                                                                 project.getOriginalInterpolatedTestCompileSourceRoots(),
+                                                                 project.getTestCompileSourceRoots(),
+                                                                 project,
+                                                                 context ) );
+
+        project.setScriptSourceRoots( restoreListOfStrings( project.getDynamicScriptSourceRoots(),
+                                                            project.getOriginalInterpolatedScriptSourceRoots(),
+                                                            project.getScriptSourceRoots(),
+                                                            project,
+                                                            context ) );
+
+        project.clearRestorableRoots();
+    }
+
+    private void restoreModelBuildSection( MavenProject project,
+                                           ProjectBuilderConfiguration config,
+                                           Map context )
+        throws ModelInterpolationException
+    {
+        Build changedBuild = project.getBuild();
+        Build dynamicBuild = project.getDynamicBuild();
+        Build originalInterpolatedBuild = project.getOriginalInterpolatedBuild();
+
+        dynamicBuild.setResources( restoreResources( dynamicBuild.getResources(),
+                                                         originalInterpolatedBuild.getResources(),
+                                                         changedBuild.getResources(),
+                                                         project,
+                                                         context ) );
+
+        dynamicBuild.setTestResources( restoreResources( dynamicBuild.getTestResources(),
+                                                         originalInterpolatedBuild.getTestResources(),
+                                                         changedBuild.getTestResources(),
+                                                         project,
+                                                         context ) );
+
+        dynamicBuild.setFilters( restoreListOfStrings( dynamicBuild.getFilters(),
+                                                           originalInterpolatedBuild.getFilters(),
+                                                           changedBuild.getFilters(),
+                                                           project,
+                                                           context ) );
+
+        dynamicBuild.setFinalName( restoreString( dynamicBuild.getFinalName(),
+                                                  originalInterpolatedBuild.getFinalName(),
+                                                  changedBuild.getFinalName(),
+                                                  project,
+                                                  context ) );
+
+        dynamicBuild.setDefaultGoal( restoreString( dynamicBuild.getDefaultGoal(),
+                                                  originalInterpolatedBuild.getDefaultGoal(),
+                                                  changedBuild.getDefaultGoal(),
+                                                  project,
+                                                  context ) );
+
+        dynamicBuild.setSourceDirectory( restoreString( dynamicBuild.getSourceDirectory(),
+                                                            originalInterpolatedBuild.getSourceDirectory(),
+                                                            changedBuild.getSourceDirectory(),
+                                                            project,
+                                                            context ) );
+
+        dynamicBuild.setTestSourceDirectory( restoreString( dynamicBuild.getTestSourceDirectory(),
+                                                                originalInterpolatedBuild.getTestSourceDirectory(),
+                                                                changedBuild.getTestSourceDirectory(),
+                                                                project,
+                                                                context ) );
+
+        dynamicBuild.setScriptSourceDirectory( restoreString( dynamicBuild.getScriptSourceDirectory(),
+                                                                  originalInterpolatedBuild.getScriptSourceDirectory(),
+                                                                  changedBuild.getScriptSourceDirectory(),
+                                                                  project,
+                                                                  context ) );
+
+        dynamicBuild.setOutputDirectory( restoreString( dynamicBuild.getOutputDirectory(),
+                                                            originalInterpolatedBuild.getOutputDirectory(),
+                                                            changedBuild.getOutputDirectory(),
+                                                            project,
+                                                            context ) );
+
+        dynamicBuild.setTestOutputDirectory( restoreString( dynamicBuild.getTestOutputDirectory(),
+                                                                originalInterpolatedBuild.getTestOutputDirectory(),
+                                                                changedBuild.getTestOutputDirectory(),
+                                                                project,
+                                                                context ) );
+
+        dynamicBuild.setDirectory( restoreString( dynamicBuild.getDirectory(),
+                                                      originalInterpolatedBuild.getDirectory(),
+                                                      changedBuild.getDirectory(),
+                                                      project,
+                                                      context ) );
+
+        project.setBuild( dynamicBuild );
+
+        project.clearRestorableBuild();
+    }
+
+    private List interpolateListOfStrings( List originalStrings,
+                                           Model model,
+                                           Map context )
+        throws ModelInterpolationException
+    {
+        if ( originalStrings == null )
+        {
+            return null;
+        }
+
+        List result = new ArrayList();
+
+        for ( Iterator it = originalStrings.iterator(); it.hasNext(); )
+        {
+            String original = (String) it.next();
+            String interpolated = modelInterpolator.interpolate( original, model, context );
+
+            result.add( interpolated );
+        }
+
+        return result;
+    }
+
+    private String restoreString( String originalString,
+                                      String originalInterpolatedString,
+                                      String changedString,
+                                      MavenProject project,
+                                      Map context )
+        throws ModelInterpolationException
+    {
+        if ( originalString == null )
+        {
+            return changedString;
+        }
+        else if ( changedString == null )
+        {
+            return originalString;
+        }
+
+        Model model = project.getModel();
+
+        String relativeChangedString;
+        if ( project.getBasedir() != null )
+        {
+            relativeChangedString = pathTranslator.unalignFromBaseDirectory( changedString, project.getBasedir() );
+        }
+        else
+        {
+            relativeChangedString = changedString;
+        }
+
+        String interpolatedOriginal = modelInterpolator.interpolate( originalString, model, context );
+        String interpolatedOriginal2 = modelInterpolator.interpolate( originalInterpolatedString,
+                                                                 model,
+                                                                 context );
+
+        String interpolatedChanged = modelInterpolator.interpolate( changedString, model, context );
+        String relativeInterpolatedChanged = modelInterpolator.interpolate( relativeChangedString, model, context );
+
+        if ( interpolatedOriginal.equals( interpolatedChanged )
+             || interpolatedOriginal2.equals( interpolatedChanged ) )
+        {
+            return originalString;
+        }
+        else if ( interpolatedOriginal.equals( relativeInterpolatedChanged )
+                        || interpolatedOriginal2.equals( relativeInterpolatedChanged ) )
+       {
+           return originalString;
+       }
+
+        return relativeChangedString;
+    }
+
+    private List restoreListOfStrings( List originalStrings,
+                                           List originalInterpolatedStrings,
+                                           List changedStrings,
+                                           MavenProject project,
+                                           Map context )
+        throws ModelInterpolationException
+    {
+        if ( originalStrings == null )
+        {
+            return changedStrings;
+        }
+        else if ( changedStrings == null )
+        {
+            return originalStrings;
+        }
+
+        List result = new ArrayList();
+
+        Map orig = new HashMap();
+        for ( int idx = 0; idx < originalStrings.size(); idx++ )
+        {
+            String[] permutations = new String[2];
+
+            permutations[0] = (String) originalInterpolatedStrings.get( idx );
+            permutations[1] = (String) originalStrings.get( idx );
+
+            orig.put( permutations[0], permutations );
+        }
+
+        for ( Iterator it = changedStrings.iterator(); it.hasNext(); )
+        {
+            String changedString = (String) it.next();
+            String relativeChangedString;
+            if ( project.getBasedir() != null )
+            {
+                relativeChangedString = pathTranslator.unalignFromBaseDirectory( changedString, project.getBasedir() );
+            }
+            else
+            {
+                relativeChangedString = changedString;
+            }
+
+            String interpolated = modelInterpolator.interpolate( changedString, project.getModel(), orig );
+            String relativeInterpolated = modelInterpolator.interpolate( relativeChangedString, project.getModel(), orig );
+
+            String[] original = (String[]) orig.get( interpolated );
+            if ( original == null )
+            {
+                original = (String[]) orig.get( relativeInterpolated );
+            }
+
+            if ( original == null )
+            {
+                result.add( relativeChangedString );
+            }
+            else
+            {
+                result.add( original[1] );
+            }
+        }
+
+        return result;
+    }
+
+    private List restoreResources( List originalResources,
+                                       List originalInterpolatedResources,
+                                       List changedResources,
+                                       MavenProject project,
+                                       Map context )
+        throws ModelInterpolationException
+    {
+        if ( originalResources == null || changedResources == null )
+        {
+            return originalResources;
+        }
+
+        List result = new ArrayList();
+
+        Map orig = new HashMap();
+        for ( int idx = 0; idx < originalResources.size(); idx++ )
+        {
+            Resource[] permutations = new Resource[2];
+
+            permutations[0] = (Resource) originalInterpolatedResources.get( idx );
+            permutations[1] = (Resource) originalResources.get( idx );
+
+            orig.put( permutations[0].getDirectory(), permutations );
+        }
+
+        for ( Iterator it = changedResources.iterator(); it.hasNext(); )
+        {
+            Resource resource = (Resource) it.next();
+            String rDir = modelInterpolator.interpolate( resource.getDirectory(), project.getModel(), orig );
+
+            String relativeDir;
+            if ( project.getBasedir() != null )
+            {
+                relativeDir = pathTranslator.unalignFromBaseDirectory( resource.getDirectory(),
+                                                                       project.getBasedir() );
+            }
+            else
+            {
+                relativeDir = resource.getDirectory();
+            }
+
+            String relativeRDir = modelInterpolator.interpolate( relativeDir, project.getModel(), context );
+
+            Resource[] original = (Resource[]) orig.get( rDir );
+            if ( original == null )
+            {
+                original = (Resource[]) orig.get( relativeRDir );
+            }
+
+            if ( original == null )
+            {
+                result.add( resource );
+            }
+            else
+            {
+                // TODO: Synchronize all non-directory fields, such as targetPath, includes, and excludes.
+//                String target = interpolator.interpolate( resource.getTargetPath(), model, context );
+//                String oTarget = interpolator.interpolate( originalResource.getTargetPath(), model, context );
+
+                result.add( original[1] );
+            }
+        }
+
+        return result;
+    }
+
+    private void populateExecutionProperties( ProjectBuilderConfiguration config,
+                                              Map context )
+    {
+        // second pass allows ${user.home} to work, if it needs to.
+        // [MNG-2339] ensure the system properties are still interpolated for backwards compat, but the model values must win
+        if ( config.getExecutionProperties() != null
+             && !config.getExecutionProperties().isEmpty() )
+        {
+            for ( Iterator it = config.getExecutionProperties().entrySet().iterator(); it.hasNext(); )
+            {
+                Map.Entry entry = (Map.Entry) it.next();
+
+                String key = (String) entry.getKey();
+                if ( "basedir".equals( key ) )
+                {
+                    continue;
+                }
+                else
+                {
+                    context.put( key, entry.getValue() );
+                }
+            }
+        }
+    }
+
+    private void populateBuildPaths( Build build,
+                                     Map context,
+                                     File projectDir )
+    {
+        if ( projectDir != null )
+        {
+            context.put( "basedir", projectDir.getAbsolutePath() );
+
+            // MNG-1927, MNG-2124, MNG-3355:
+            // If the build section is present and the project directory is non-null, we should make
+            // sure interpolation of the directories below uses translated paths.
+            // Afterward, we'll double back and translate any paths that weren't covered during interpolation via the
+            // code below...
+//            context.put( "build.directory",
+//                         pathTranslator.alignToBaseDirectory( build.getDirectory(), projectDir ) );
+//            context.put( "build.outputDirectory",
+//                         pathTranslator.alignToBaseDirectory( build.getOutputDirectory(),
+//                                                              projectDir ) );
+//            context.put( "build.testOutputDirectory",
+//                         pathTranslator.alignToBaseDirectory( build.getTestOutputDirectory(),
+//                                                              projectDir ) );
+//            context.put( "build.sourceDirectory",
+//                         pathTranslator.alignToBaseDirectory( build.getSourceDirectory(),
+//                                                              projectDir ) );
+//            context.put( "build.testSourceDirectory",
+//                         pathTranslator.alignToBaseDirectory( build.getTestSourceDirectory(),
+//                                                              projectDir ) );
+        }
+    }
 }
diff --git a/maven-project/src/main/java/org/apache/maven/project/MavenProject.java b/maven-project/src/main/java/org/apache/maven/project/MavenProject.java
index 0096d6cd1..2d2d9260c 100644
--- a/maven-project/src/main/java/org/apache/maven/project/MavenProject.java
+++ b/maven-project/src/main/java/org/apache/maven/project/MavenProject.java
@@ -280,6 +280,35 @@ public class MavenProject
         {
             setSnapshotArtifactRepository( project.getSnapshotArtifactRepository() );
         }
+
+        if ( project.isConcrete() )
+        {
+            setDynamicBuild( ModelUtils.cloneBuild( project.getDynamicBuild() ) );
+            setOriginalInterpolatedBuild( ModelUtils.cloneBuild( project.getOriginalInterpolatedBuild() ) );
+
+            List dynamicRoots = project.getDynamicCompileSourceRoots();
+            if ( dynamicRoots != null )
+            {
+                setDynamicCompileSourceRoots( new ArrayList( dynamicRoots ) );
+                setOriginalInterpolatedCompileSourceRoots( new ArrayList( project.getOriginalInterpolatedCompileSourceRoots() ) );
+            }
+
+            dynamicRoots = project.getDynamicTestCompileSourceRoots();
+            if ( dynamicRoots != null )
+            {
+                setDynamicTestCompileSourceRoots( new ArrayList( dynamicRoots ) );
+                setOriginalInterpolatedTestCompileSourceRoots( new ArrayList( project.getOriginalInterpolatedTestCompileSourceRoots() ) );
+            }
+
+            dynamicRoots = project.getDynamicScriptSourceRoots();
+            if ( dynamicRoots != null )
+            {
+                setDynamicScriptSourceRoots( new ArrayList( dynamicRoots ) );
+                setOriginalInterpolatedScriptSourceRoots( new ArrayList( project.getOriginalInterpolatedScriptSourceRoots() ) );
+            }
+        }
+
+        setConcrete( project.isConcrete() );
     }
     
     public String getModulePathAdjustment( MavenProject moduleProject ) throws IOException
@@ -1583,7 +1612,7 @@ public class MavenProject
         projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );
     }
 
-    private static String getProjectReferenceId( String groupId, String artifactId, String version )
+    public static String getProjectReferenceId( String groupId, String artifactId, String version )
     {
         return groupId + ":" + artifactId + ":" + version;
     }
@@ -1795,4 +1824,159 @@ public class MavenProject
         return clone;
     }
 
+// ----------------------------------------------------------------------------
+// CODE BELOW IS USED TO PRESERVE DYNAMISM IN THE BUILD SECTION OF THE POM.
+// ----------------------------------------------------------------------------
+
+    private Build dynamicBuild;
+
+    private Build originalInterpolatedBuild;
+
+    private List dynamicCompileSourceRoots;
+
+    private List originalInterpolatedCompileSourceRoots;
+
+    private List dynamicTestCompileSourceRoots;
+
+    private List originalInterpolatedTestCompileSourceRoots;
+
+    private List dynamicScriptSourceRoots;
+
+    private List originalInterpolatedScriptSourceRoots;
+
+    private boolean isConcrete = false;
+
+    public boolean isConcrete()
+    {
+        return isConcrete;
+    }
+
+    public void setConcrete( boolean concrete )
+    {
+        isConcrete = concrete;
+    }
+
+    public Build getDynamicBuild()
+    {
+        return dynamicBuild;
+    }
+
+    public Build getOriginalInterpolatedBuild()
+    {
+        return originalInterpolatedBuild;
+    }
+
+    public List getDynamicCompileSourceRoots()
+    {
+        return dynamicCompileSourceRoots;
+    }
+
+    public List getOriginalInterpolatedCompileSourceRoots()
+    {
+        return originalInterpolatedCompileSourceRoots;
+    }
+
+    public List getDynamicTestCompileSourceRoots()
+    {
+        return dynamicTestCompileSourceRoots;
+    }
+
+    public List getOriginalInterpolatedTestCompileSourceRoots()
+    {
+        return originalInterpolatedTestCompileSourceRoots;
+    }
+
+    public List getDynamicScriptSourceRoots()
+    {
+        return dynamicScriptSourceRoots;
+    }
+
+    public List getOriginalInterpolatedScriptSourceRoots()
+    {
+        return originalInterpolatedScriptSourceRoots;
+    }
+
+    public void clearRestorableRoots()
+    {
+        dynamicCompileSourceRoots = null;
+        dynamicTestCompileSourceRoots = null;
+        dynamicScriptSourceRoots = null;
+        originalInterpolatedCompileSourceRoots = null;
+        originalInterpolatedScriptSourceRoots = null;
+        originalInterpolatedTestCompileSourceRoots = null;
+    }
+
+    public void clearRestorableBuild()
+    {
+        dynamicBuild = null;
+        originalInterpolatedBuild = null;
+    }
+
+    public void preserveCompileSourceRoots( List originalInterpolatedCompileSourceRoots )
+    {
+        dynamicCompileSourceRoots = getCompileSourceRoots();
+        this.originalInterpolatedCompileSourceRoots = originalInterpolatedCompileSourceRoots;
+    }
+
+    public void preserveTestCompileSourceRoots( List originalInterpolatedTestCompileSourceRoots )
+    {
+        dynamicTestCompileSourceRoots = getTestCompileSourceRoots();
+        this.originalInterpolatedTestCompileSourceRoots = originalInterpolatedTestCompileSourceRoots;
+    }
+
+    public void preserveScriptSourceRoots( List originalInterpolatedScriptSourceRoots )
+    {
+        dynamicScriptSourceRoots = getScriptSourceRoots();
+        this.originalInterpolatedScriptSourceRoots = originalInterpolatedScriptSourceRoots;
+    }
+
+    public void preserveBuild( Build originalInterpolatedBuild )
+    {
+        dynamicBuild = getBuild();
+        this.originalInterpolatedBuild = originalInterpolatedBuild;
+
+        this.originalInterpolatedBuild.setPluginManagement( null );
+        this.originalInterpolatedBuild.setPlugins( null );
+    }
+
+    protected void setDynamicBuild( Build dynamicBuild )
+    {
+        this.dynamicBuild = dynamicBuild;
+    }
+
+    protected void setOriginalInterpolatedBuild( Build originalInterpolatedBuild )
+    {
+        this.originalInterpolatedBuild = originalInterpolatedBuild;
+    }
+
+    protected void setDynamicCompileSourceRoots( List dynamicCompileSourceRoots )
+    {
+        this.dynamicCompileSourceRoots = dynamicCompileSourceRoots;
+    }
+
+    protected void setOriginalInterpolatedCompileSourceRoots( List originalInterpolatedCompileSourceRoots )
+    {
+        this.originalInterpolatedCompileSourceRoots = originalInterpolatedCompileSourceRoots;
+    }
+
+    protected void setDynamicTestCompileSourceRoots( List dynamicTestCompileSourceRoots )
+    {
+        this.dynamicTestCompileSourceRoots = dynamicTestCompileSourceRoots;
+    }
+
+    protected void setOriginalInterpolatedTestCompileSourceRoots( List originalInterpolatedTestCompileSourceRoots )
+    {
+        this.originalInterpolatedTestCompileSourceRoots = originalInterpolatedTestCompileSourceRoots;
+    }
+
+    protected void setDynamicScriptSourceRoots( List dynamicScriptSourceRoots )
+    {
+        this.dynamicScriptSourceRoots = dynamicScriptSourceRoots;
+    }
+
+    protected void setOriginalInterpolatedScriptSourceRoots( List originalInterpolatedScriptSourceRoots )
+    {
+        this.originalInterpolatedScriptSourceRoots = originalInterpolatedScriptSourceRoots;
+    }
+
 }
diff --git a/maven-project/src/main/java/org/apache/maven/project/MavenProjectBuilder.java b/maven-project/src/main/java/org/apache/maven/project/MavenProjectBuilder.java
index 8d6e6b16c..ae3557d6c 100644
--- a/maven-project/src/main/java/org/apache/maven/project/MavenProjectBuilder.java
+++ b/maven-project/src/main/java/org/apache/maven/project/MavenProjectBuilder.java
@@ -24,6 +24,7 @@ import org.apache.maven.artifact.repository.ArtifactRepository;
 import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
 import org.apache.maven.artifact.resolver.ArtifactResolutionException;
 import org.apache.maven.profiles.ProfileManager;
+import org.apache.maven.project.interpolation.ModelInterpolationException;
 import org.apache.maven.wagon.events.TransferListener;
 
 import java.io.File;
@@ -113,4 +114,14 @@ public interface MavenProjectBuilder
                         ProjectBuilderConfiguration config,
                         boolean checkDistributionManagementStatus )
         throws ProjectBuildingException;
+
+ // ----------------------------------------------------------------------------
+ // API BELOW IS USED TO PRESERVE DYNAMISM IN THE BUILD SECTION OF THE POM.
+ // ----------------------------------------------------------------------------
+
+    void calculateConcreteState( MavenProject project, ProjectBuilderConfiguration config )
+        throws ModelInterpolationException;
+
+    void restoreDynamicState( MavenProject project, ProjectBuilderConfiguration config )
+        throws ModelInterpolationException;
 }
diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
index 86c03d93b..b78857d11 100644
--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java
@@ -581,6 +581,17 @@ public final class ModelUtils
         return newModel;
     }
 
+    public static Build cloneBuild( Build build )
+    {
+        ModelInheritanceAssembler assembler = new DefaultModelInheritanceAssembler();
+
+        Build clone = new Build();
+
+        assembler.assembleBuildInheritance( clone, build );
+
+        return clone;
+    }
+
     private static List cloneProfiles( List profiles )
     {
         if ( profiles == null )
diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
index 4825945ec..e786d4cfe 100644
--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java
@@ -289,83 +289,89 @@ public class DefaultModelInheritanceAssembler
                 child.setBuild( childBuild );
             }
 
-            // The build has been set but we want to step in here and fill in
-            // values that have not been set by the child.
+            assembleBuildInheritance( childBuild, parentBuild );
+        }
+    }
 
-            if ( childBuild.getSourceDirectory() == null )
-            {
-                childBuild.setSourceDirectory( parentBuild.getSourceDirectory() );
-            }
+    public void assembleBuildInheritance( Build childBuild,
+                                           Build parentBuild )
+    {
+        // The build has been set but we want to step in here and fill in
+        // values that have not been set by the child.
 
-            if ( childBuild.getScriptSourceDirectory() == null )
-            {
-                childBuild.setScriptSourceDirectory( parentBuild.getScriptSourceDirectory() );
-            }
+        if ( childBuild.getSourceDirectory() == null )
+        {
+            childBuild.setSourceDirectory( parentBuild.getSourceDirectory() );
+        }
 
-            if ( childBuild.getTestSourceDirectory() == null )
-            {
-                childBuild.setTestSourceDirectory( parentBuild.getTestSourceDirectory() );
-            }
+        if ( childBuild.getScriptSourceDirectory() == null )
+        {
+            childBuild.setScriptSourceDirectory( parentBuild.getScriptSourceDirectory() );
+        }
 
-            if ( childBuild.getOutputDirectory() == null )
-            {
-                childBuild.setOutputDirectory( parentBuild.getOutputDirectory() );
-            }
+        if ( childBuild.getTestSourceDirectory() == null )
+        {
+            childBuild.setTestSourceDirectory( parentBuild.getTestSourceDirectory() );
+        }
 
-            if ( childBuild.getTestOutputDirectory() == null )
-            {
-                childBuild.setTestOutputDirectory( parentBuild.getTestOutputDirectory() );
-            }
+        if ( childBuild.getOutputDirectory() == null )
+        {
+            childBuild.setOutputDirectory( parentBuild.getOutputDirectory() );
+        }
 
-            // Extensions are accumlated
-            ModelUtils.mergeExtensionLists( childBuild, parentBuild );
+        if ( childBuild.getTestOutputDirectory() == null )
+        {
+            childBuild.setTestOutputDirectory( parentBuild.getTestOutputDirectory() );
+        }
 
-            if ( childBuild.getDirectory() == null )
-            {
-                childBuild.setDirectory( parentBuild.getDirectory() );
-            }
+        // Extensions are accumlated
+        ModelUtils.mergeExtensionLists( childBuild, parentBuild );
 
-            if ( childBuild.getDefaultGoal() == null )
-            {
-                childBuild.setDefaultGoal( parentBuild.getDefaultGoal() );
-            }
+        if ( childBuild.getDirectory() == null )
+        {
+            childBuild.setDirectory( parentBuild.getDirectory() );
+        }
 
-            if ( childBuild.getFinalName() == null )
-            {
-                childBuild.setFinalName( parentBuild.getFinalName() );
-            }
+        if ( childBuild.getDefaultGoal() == null )
+        {
+            childBuild.setDefaultGoal( parentBuild.getDefaultGoal() );
+        }
 
-            ModelUtils.mergeFilterLists( childBuild.getFilters(), parentBuild.getFilters() );
+        if ( childBuild.getFinalName() == null )
+        {
+            childBuild.setFinalName( parentBuild.getFinalName() );
+        }
 
-            List resources = childBuild.getResources();
-            if ( ( resources == null ) || resources.isEmpty() )
-            {
-                childBuild.setResources( parentBuild.getResources() );
-            }
+        ModelUtils.mergeFilterLists( childBuild.getFilters(), parentBuild.getFilters() );
 
-            resources = childBuild.getTestResources();
-            if ( ( resources == null ) || resources.isEmpty() )
-            {
-                childBuild.setTestResources( parentBuild.getTestResources() );
-            }
+        List resources = childBuild.getResources();
+        if ( ( resources == null ) || resources.isEmpty() )
+        {
+            childBuild.setResources( parentBuild.getResources() );
+        }
 
-            // Plugins are aggregated if Plugin.inherit != false
-            ModelUtils.mergePluginLists( childBuild, parentBuild, true );
+        resources = childBuild.getTestResources();
+        if ( ( resources == null ) || resources.isEmpty() )
+        {
+            childBuild.setTestResources( parentBuild.getTestResources() );
+        }
 
-            // Plugin management :: aggregate
-            PluginManagement dominantPM = childBuild.getPluginManagement();
-            PluginManagement recessivePM = parentBuild.getPluginManagement();
+        // Plugins are aggregated if Plugin.inherit != false
+        ModelUtils.mergePluginLists( childBuild, parentBuild, true );
 
-            if ( ( dominantPM == null ) && ( recessivePM != null ) )
-            {
-                // FIXME: Filter out the inherited == false stuff!
-                childBuild.setPluginManagement( recessivePM );
-            }
-            else
-            {
-                ModelUtils.mergePluginLists( childBuild.getPluginManagement(), parentBuild.getPluginManagement(),
-                                             false );
-            }
+        // Plugin management :: aggregate
+        PluginManagement dominantPM = childBuild.getPluginManagement();
+        PluginManagement recessivePM = parentBuild.getPluginManagement();
+
+        if ( ( dominantPM == null ) && ( recessivePM != null ) )
+        {
+            // FIXME: Filter out the inherited == false stuff!
+            childBuild.setPluginManagement( recessivePM );
+        }
+        else
+        {
+            ModelUtils.mergePluginLists( childBuild.getPluginManagement(), parentBuild.getPluginManagement(),
+                                         false );
         }
     }
 
diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/ModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/ModelInheritanceAssembler.java
index 76d00b169..b0c612b32 100644
--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/ModelInheritanceAssembler.java
+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/ModelInheritanceAssembler.java
@@ -19,6 +19,7 @@ package org.apache.maven.project.inheritance;
  * under the License.
  */
 
+import org.apache.maven.model.Build;
 import org.apache.maven.model.Model;
 
 /**
@@ -33,5 +34,8 @@ public interface ModelInheritanceAssembler
 
     void assembleModelInheritance( Model child, Model parent );
 
+    public void assembleBuildInheritance( Build childBuild,
+                                          Build parentBuild );
+
     void copyModel( Model dest, Model source );
 }
diff --git a/maven-project/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java b/maven-project/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java
index 7a90b5e98..daf5ae90b 100644
--- a/maven-project/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java
+++ b/maven-project/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java
@@ -31,7 +31,13 @@ import java.util.List;
 public class DefaultPathTranslator
     implements PathTranslator
 {
-    private String FILE_SEPARATOR = "/";
+    private static final String FILE_SEPARATOR = "/";
+
+    private static final String[] BASEDIR_NAMES = {
+        "${basedir}",
+        "${pom.basedir}",
+        "${project.basedir}"
+    };
 
     public void alignToBaseDirectory( Model model, File basedir )
     {
@@ -91,13 +97,25 @@ public class DefaultPathTranslator
 
     private String stripBasedirToken( String s )
     {
-        String basedirExpr = "${basedir}";
-
         if ( s != null )
         {
             s = s.trim();
 
-            if ( s.startsWith( basedirExpr ) )
+            String basedirExpr = null;
+            for ( int i = 0; i < BASEDIR_NAMES.length; i++ )
+            {
+                basedirExpr = BASEDIR_NAMES[i];
+                if ( s.startsWith( basedirExpr ) )
+                {
+                    break;
+                }
+                else
+                {
+                    basedirExpr = null;
+                }
+            }
+
+            if ( basedirExpr != null )
             {
                 if ( s.length() > basedirExpr.length() )
                 {
diff --git a/maven-project/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java b/maven-project/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java
index 522f72b58..5da53ecea 100644
--- a/maven-project/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java
+++ b/maven-project/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java
@@ -180,6 +180,7 @@ public class DefaultMavenProjectBuilderTest
          File pom = getTestFile( "src/test/resources/projects/build-path-expression-pom.xml" );
 
          MavenProject project = getProject( pom );
+         projectBuilder.calculateConcreteState( project, new DefaultProjectBuilderConfiguration() );
 
          Build build = project.getBuild();
          assertNotNull( "Project should have a build section containing the test resource.", build );
diff --git a/maven-project/src/test/java/org/apache/maven/project/MavenProjectDynamismTest.java b/maven-project/src/test/java/org/apache/maven/project/MavenProjectDynamismTest.java
new file mode 100644
index 000000000..7d94821a2
--- /dev/null
+++ b/maven-project/src/test/java/org/apache/maven/project/MavenProjectDynamismTest.java
@@ -0,0 +1,569 @@
+package org.apache.maven.project;
+
+import org.apache.maven.model.Build;
+import org.apache.maven.model.Plugin;
+import org.apache.maven.model.Resource;
+import org.apache.maven.project.interpolation.ModelInterpolationException;
+import org.codehaus.plexus.PlexusTestCase;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.Iterator;
+import java.util.List;
+
+public class MavenProjectDynamismTest
+    extends PlexusTestCase
+{
+
+    private MavenProjectBuilder projectBuilder;
+
+    public void setUp()
+        throws Exception
+    {
+        super.setUp();
+
+        projectBuilder = (MavenProjectBuilder) lookup( MavenProjectBuilder.class.getName() );
+    }
+
+    public void testBuildSectionGroupIdInterpolation()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom-interp.xml" );
+
+        projectBuilder.calculateConcreteState( project, new DefaultProjectBuilderConfiguration() );
+
+        String basepath = "/" + project.getGroupId();
+
+        Build build = project.getBuild();
+
+        assertTrue( build.getSourceDirectory().startsWith( basepath ) );
+        assertTrue( build.getTestSourceDirectory().startsWith( basepath ) );
+        assertTrue( build.getScriptSourceDirectory().startsWith( basepath ) );
+
+        List plugins = build.getPlugins();
+        assertNotNull( plugins );
+        assertEquals( 1, plugins.size() );
+
+        Plugin plugin = (Plugin) plugins.get( 0 );
+        assertEquals( "my-plugin", plugin.getArtifactId() );
+
+        Xpp3Dom conf = (Xpp3Dom) plugin.getConfiguration();
+        assertNotNull( conf );
+
+        Xpp3Dom[] children = conf.getChildren();
+        assertEquals( 3, children.length );
+
+        for ( int i = 0; i < children.length; i++ )
+        {
+            assertEquals( "Configuration parameter: "
+                                          + children[i].getName()
+                                          + " should have a an interpolated POM groupId as its value.",
+                          children[i].getValue(),
+                          project.getGroupId() );
+        }
+
+        projectBuilder.restoreDynamicState( project, new DefaultProjectBuilderConfiguration() );
+
+        String projectGidExpr = "${project.groupId}";
+        String pomGidExpr = "${pom.groupId}";
+        String nakedGidExpr = "${groupId}";
+
+        build = project.getBuild();
+
+        assertTrue( build.getSourceDirectory().startsWith( "/" + projectGidExpr ) );
+        assertTrue( build.getTestSourceDirectory().startsWith( "/" + pomGidExpr ) );
+        assertTrue( build.getScriptSourceDirectory().startsWith( "/" + nakedGidExpr ) );
+
+        plugins = build.getPlugins();
+        assertNotNull( plugins );
+        assertEquals( 1, plugins.size() );
+
+        plugin = (Plugin) plugins.get( 0 );
+        assertEquals( "my-plugin", plugin.getArtifactId() );
+
+        conf = (Xpp3Dom) plugin.getConfiguration();
+        assertNotNull( conf );
+
+        children = conf.getChildren();
+        assertEquals( 3, children.length );
+
+        assertEquals( "Configuration parameter: " + children[0].getName() + " should have "
+                      + projectGidExpr + " as its value.", children[0].getValue(), projectGidExpr );
+
+        assertEquals( "Configuration parameter: " + children[1].getName() + " should have "
+                      + pomGidExpr + " as its value.", children[1].getValue(), pomGidExpr );
+
+        assertEquals( "Configuration parameter: " + children[2].getName() + " should have "
+                      + nakedGidExpr + " as its value.", children[2].getValue(), nakedGidExpr );
+    }
+
+    public void testRoundTrip()
+        throws IOException, XmlPullParserException, URISyntaxException,
+        ModelInterpolationException, ProjectBuildingException
+    {
+        MavenProject project = buildProject( "pom.xml" );
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+        projectBuilder.calculateConcreteState( project, config );
+
+        File baseDir = project.getBasedir();
+        File buildDir = new File( baseDir, "target" );
+
+        String basedirExpr = "${pom.basedir}";
+        String buildDirExpr = "${pom.build.directory}";
+
+        assertTrue( project.isConcrete() );
+
+        Build build = project.getBuild();
+
+        assertEquals( "Concrete source directory should be absolute.",
+                      new File( baseDir, "/src/main/java" ).getAbsolutePath(),
+                      build.getSourceDirectory() );
+
+        assertEquals( "Concrete test-source directory should be absolute.",
+                      new File( baseDir, "/src/test/java" ).getAbsolutePath(),
+                      build.getTestSourceDirectory() );
+
+        assertEquals( "Concrete script-source directory should be absolute.",
+                      new File( baseDir, "/src/main/scripts" ).getAbsolutePath(),
+                      build.getScriptSourceDirectory() );
+
+        List compileSourceRoots = project.getCompileSourceRoots();
+
+        assertNotNull( "Concrete compile-source roots should not be null.", compileSourceRoots );
+
+        assertEquals( "Concrete compile-source roots should contain one entry.",
+                      1,
+                      compileSourceRoots.size() );
+
+        assertEquals( "Concrete compile-source roots should contain interpolated source-directory value.",
+                      new File( baseDir, "/src/main/java" ).getAbsolutePath(),
+                      compileSourceRoots.get( 0 ) );
+
+        List testCompileSourceRoots = project.getTestCompileSourceRoots();
+
+        assertNotNull( "Concrete test-compile-source roots should not be null.",
+                       testCompileSourceRoots );
+
+        assertEquals( "Concrete test-compile-source roots should contain one entry.",
+                      1,
+                      testCompileSourceRoots.size() );
+
+        assertEquals( "Concrete test-compile-source roots should contain interpolated test-source-directory value.",
+                      new File( baseDir, "/src/test/java" ).getAbsolutePath(),
+                      testCompileSourceRoots.get( 0 ) );
+
+        List scriptSourceRoots = project.getScriptSourceRoots();
+
+        assertNotNull( "Concrete script-source roots should not be null.", scriptSourceRoots );
+
+        assertEquals( "Concrete script-source roots should contain one entry.",
+                      1,
+                      scriptSourceRoots.size() );
+
+        assertEquals( "Concrete script-source roots should contain interpolated script-source-directory value.",
+                      new File( baseDir, "/src/main/scripts" ).getAbsolutePath(),
+                      scriptSourceRoots.get( 0 ) );
+
+        List resources = build.getResources();
+
+        assertNotNull( "Concrete resources should not be null.", resources );
+
+        assertEquals( "Concrete resources should contain one entry.", 1, resources.size() );
+
+        assertEquals( "Concrete resource should contain absolute path.",
+                      new File( buildDir, "generated-resources/plexus" ).getAbsolutePath(),
+                      ( (Resource) resources.get( 0 ) ).getDirectory() );
+
+        List filters = build.getFilters();
+
+        assertNotNull( "Concrete filters should not be null.", filters );
+
+        assertEquals( "Concrete filters should contain one entry.", 1, filters.size() );
+
+        assertEquals( "Concrete filter entry should contain absolute path.",
+                      new File( buildDir, "/generated-filters.properties" ).getAbsolutePath(),
+                      filters.get( 0 ) );
+
+        assertEquals( "Concrete output-directory should be absolute.",
+                      new File( buildDir, "/classes" ).getAbsolutePath(),
+                      build.getOutputDirectory() );
+
+        assertEquals( "Concrete test-output-directory should be absolute.",
+                      new File( buildDir, "/test-classes" ).getAbsolutePath(),
+                      build.getTestOutputDirectory() );
+
+        assertEquals( "Concrete build directory should be absolute.",
+                      new File( baseDir, "target" ).getAbsolutePath(),
+                      build.getDirectory() );
+
+        // --------------------------------------------------------------------
+        // NOW, RESTORE THE DYNAMIC STATE FOR THE BUILD SECTION AND
+        // ASSOCIATED DIRECTORIES ATTACHED TO THE PROJECT INSTANCE.
+        // --------------------------------------------------------------------
+
+        projectBuilder.restoreDynamicState( project, config );
+
+        assertFalse( project.isConcrete() );
+
+        build = project.getBuild();
+
+        assertEquals( "Restored source directory should be expressed in terms of the basedir.",
+                      basedirExpr + "/src/main/java",
+                      build.getSourceDirectory() );
+
+        assertEquals( "Restored test-source directory should be expressed in terms of the basedir.",
+                      basedirExpr + "/src/test/java",
+                      build.getTestSourceDirectory() );
+
+        assertEquals( "Restored script-source directory should be expressed in terms of the basedir.",
+                      basedirExpr + "/src/main/scripts",
+                      build.getScriptSourceDirectory() );
+
+        compileSourceRoots = project.getCompileSourceRoots();
+
+        assertNotNull( "Restored compile-source roots should not be null.", compileSourceRoots );
+
+        assertEquals( "Restored compile-source roots should contain one entry.",
+                      1,
+                      compileSourceRoots.size() );
+
+        assertEquals( "Restored compile-source roots should contain uninterpolated source-directory value.",
+                      "src/main/java",
+                      compileSourceRoots.get( 0 ) );
+
+        testCompileSourceRoots = project.getTestCompileSourceRoots();
+
+        assertNotNull( "Restored test-compile-source roots should not be null.",
+                       testCompileSourceRoots );
+
+        assertEquals( "Restored test-compile-source roots should contain one entry.",
+                      1,
+                      testCompileSourceRoots.size() );
+
+        assertEquals( "Restored test-compile-source roots should contain uninterpolated test-source-directory value.",
+                      "src/test/java",
+                      testCompileSourceRoots.get( 0 ) );
+
+        scriptSourceRoots = project.getScriptSourceRoots();
+
+        assertNotNull( "Restored script-source roots should not be null.", scriptSourceRoots );
+
+        assertEquals( "Restored script-source roots should contain one entry.",
+                      1,
+                      scriptSourceRoots.size() );
+
+        assertEquals( "Restored script-source roots should contain uninterpolated script-source-directory value.",
+                      "src/main/scripts",
+                      scriptSourceRoots.get( 0 ) );
+
+        resources = build.getResources();
+
+        assertNotNull( "Restored resources should not be null.", resources );
+
+        assertEquals( "Restored resources should contain one entry.", 1, resources.size() );
+
+        assertEquals( "Restored resource should contain uninterpolated reference to build directory.",
+                      buildDirExpr + "/generated-resources/plexus",
+                      ( (Resource) resources.get( 0 ) ).getDirectory() );
+
+        filters = build.getFilters();
+
+        assertNotNull( "Restored filters should not be null.", filters );
+
+        assertEquals( "Restored filters should contain one entry.", 1, filters.size() );
+
+        assertEquals( "Restored filter entry should contain uninterpolated reference to build directory.",
+                      buildDirExpr + "/generated-filters.properties",
+                      filters.get( 0 ) );
+
+        assertEquals( "Restored output-directory should be expressed in terms of the build-directory.",
+                      buildDirExpr + "/classes",
+                      build.getOutputDirectory() );
+
+        assertEquals( "Restored test-output-directory should be expressed in terms of the build-directory.",
+                      buildDirExpr + "/test-classes",
+                      build.getTestOutputDirectory() );
+
+        assertEquals( "Restored build directory should be relative.",
+                      "target",
+                      build.getDirectory() );
+    }
+
+    public void testShouldPreserveAddedResourceInRestoredState()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom.xml" );
+
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+
+        projectBuilder.calculateConcreteState( project, config );
+
+        Build build = project.getBuild();
+
+        Resource r = new Resource();
+        r.setDirectory( "myDir" );
+
+        build.addResource( r );
+
+        List resources = build.getResources();
+        assertNotNull( "Concrete resources should not be null.", resources );
+        assertEquals( "Concrete resources should contain two entries.", 2, resources.size() );
+        assertResourcePresent( "concrete resources",
+                               new File( build.getDirectory(), "generated-resources/plexus" ).getAbsolutePath(),
+                               resources );
+        assertResourcePresent( "concrete resources", "myDir", resources );
+
+        projectBuilder.restoreDynamicState( project, config );
+
+        build = project.getBuild();
+
+        resources = build.getResources();
+        assertNotNull( "Restored resources should not be null.", resources );
+        assertEquals( "Restored resources should contain two entries.", 2, resources.size() );
+        assertResourcePresent( "restored resources",
+                               "${pom.build.directory}/generated-resources/plexus",
+                               resources );
+        assertResourcePresent( "restored resources", "myDir", resources );
+    }
+
+    public void testShouldPreserveAddedFilterInRestoredState()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom.xml" );
+
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+        projectBuilder.calculateConcreteState( project, config );
+
+        Build build = project.getBuild();
+
+        build.addFilter( "myDir/filters.properties" );
+
+        List filters = build.getFilters();
+        assertNotNull( "Concrete filters should not be null.", filters );
+        assertEquals( "Concrete filters should contain two entries.", 2, filters.size() );
+        assertFilterPresent( "concrete filters",
+                             new File( build.getDirectory(), "generated-filters.properties" ).getAbsolutePath(),
+                             filters );
+
+        assertFilterPresent( "concrete filters", "myDir/filters.properties", filters );
+
+        projectBuilder.restoreDynamicState( project, config );
+
+        build = project.getBuild();
+
+        filters = build.getFilters();
+        assertNotNull( "Restored filters should not be null.", filters );
+        assertEquals( "Restored filters should contain two entries.", 2, filters.size() );
+        assertFilterPresent( "restored filters",
+                             "${pom.build.directory}/generated-filters.properties",
+                             filters );
+        assertFilterPresent( "restored filters", "myDir/filters.properties", filters );
+    }
+
+    public void testShouldIncorporateChangedBuildDirectoryViaExpressionsOnNextConcreteCalculation()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom.xml" );
+
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+        projectBuilder.calculateConcreteState( project, config );
+
+        Build build = project.getBuild();
+
+        assertEquals( "First concrete build directory should be absolute and point to target dir.",
+                      new File( project.getBasedir(), "target" ).getAbsolutePath(),
+                      build.getDirectory() );
+        assertEquals( "First concrete build output-directory should be absolute and point to target/classes dir.",
+                      new File( project.getBasedir(), "target/classes" ).getAbsolutePath(),
+                      build.getOutputDirectory() );
+
+        build.setDirectory( "target2" );
+
+        assertEquals( "AFTER CHANGING BUILD DIRECTORY, build directory should be relative and point to target2 dir.",
+                      "target2",
+                      build.getDirectory() );
+        assertEquals( "AFTER CHANGING BUILD DIRECTORY, build output-directory should be absolute and still point to target/classes dir.",
+                      new File( project.getBasedir(), "target/classes" ).getAbsolutePath(),
+                      build.getOutputDirectory() );
+
+        projectBuilder.restoreDynamicState( project, config );
+        projectBuilder.calculateConcreteState( project, config );
+
+        build = project.getBuild();
+
+        assertEquals( "Second concrete build directory should be absolute and point to target2 dir.",
+                      new File( project.getBasedir(), "target2" ).getAbsolutePath(),
+                      build.getDirectory() );
+        assertEquals( "Second concrete build output-directory should be absolute and point to target2/classes dir.",
+                      new File( project.getBasedir(), "target2/classes" ).getAbsolutePath(),
+                      build.getOutputDirectory() );
+    }
+
+    public void testShouldPreserveInitialValuesForPropertiesReferencingBuildPaths()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom.xml" );
+
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+        projectBuilder.calculateConcreteState( project, config );
+
+        project.getBuild().setDirectory( "target2" );
+
+        String originalValue = project.getProperties().getProperty( "myProperty" );
+
+        projectBuilder.restoreDynamicState( project, config );
+        projectBuilder.calculateConcreteState( project, config );
+
+        assertEquals( "After resetting build-directory and going through a recalculation phase for the project, "
+                                      + "property value for 'myProperty' should STILL be the absolute initial build directory.",
+                      originalValue,
+                      project.getProperties().getProperty( "myProperty" ) );
+    }
+
+    public void testShouldAlignCompileSourceRootsInConcreteState()
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException,
+        ModelInterpolationException
+    {
+        MavenProject project = buildProject( "pom-relative.xml" );
+
+        ProjectBuilderConfiguration config = new DefaultProjectBuilderConfiguration();
+        projectBuilder.calculateConcreteState( project, config );
+
+        List compileSourceRoots = project.getCompileSourceRoots();
+        assertNotNull( "First concrete state compile-source roots should not be null.",
+                       compileSourceRoots );
+        assertEquals( "First concrete state should contain one compile-source root.",
+                      1,
+                      compileSourceRoots.size() );
+        assertEquals( "First concrete state should have an absolute path for compile-source root.",
+                      new File( project.getBasedir(), "src/main/java" ).getAbsolutePath(),
+                      compileSourceRoots.get( 0 ) );
+
+        String newSourceRoot = new File( project.getBuild().getDirectory(),
+                                         "generated-sources/modello" ).getAbsolutePath();
+
+        project.addCompileSourceRoot( newSourceRoot );
+
+        projectBuilder.restoreDynamicState( project, config );
+
+        compileSourceRoots = project.getCompileSourceRoots();
+        assertNotNull( "Restored dynamic state compile-source roots should not be null.",
+                       compileSourceRoots );
+        assertEquals( "Restored dynamic state should contain two compile-source roots.",
+                      2,
+                      compileSourceRoots.size() );
+        assertEquals( "Restored dynamic state should have a relative path for original compile-source root.",
+                      "src/main/java",
+                      compileSourceRoots.get( 0 ) );
+        assertEquals( "Restored dynamic state should have a relative path for new compile-source root.",
+                      "target/generated-sources/modello",
+                      compileSourceRoots.get( 1 ) );
+
+        projectBuilder.calculateConcreteState( project, config );
+
+        compileSourceRoots = project.getCompileSourceRoots();
+        assertNotNull( "Second concrete state compile-source roots should not be null.",
+                       compileSourceRoots );
+        assertEquals( "Second concrete state should contain two compile-source roots.",
+                      2,
+                      compileSourceRoots.size() );
+        assertEquals( "Second concrete state should have an absolute path for original compile-source root.",
+                      new File( project.getBasedir(), "src/main/java" ).getAbsolutePath(),
+                      compileSourceRoots.get( 0 ) );
+        assertEquals( "Second concrete state should have an absolute path for new compile-source root.",
+                      newSourceRoot,
+                      compileSourceRoots.get( 1 ) );
+    }
+
+    // Useful for diagnostics.
+//    private void displayPOM( Model model )
+//        throws IOException
+//    {
+//        StringWriter writer = new StringWriter();
+//        new MavenXpp3Writer().write( writer, model );
+//
+//        System.out.println( writer.toString() );
+//    }
+
+    private void assertResourcePresent( String testLabel,
+                                        String directory,
+                                        List resources )
+    {
+        boolean found = false;
+
+        if ( resources != null )
+        {
+            for ( Iterator it = resources.iterator(); it.hasNext(); )
+            {
+                Resource resource = (Resource) it.next();
+                if ( directory.equals( resource.getDirectory() ) )
+                {
+                    found = true;
+                    break;
+                }
+            }
+        }
+
+        if ( !found )
+        {
+            fail( "Missing resource with directory: " + directory + " in " + testLabel );
+        }
+    }
+
+    private void assertFilterPresent( String testLabel,
+                                      String path,
+                                      List filters )
+    {
+        boolean found = false;
+
+        if ( filters != null )
+        {
+            for ( Iterator it = filters.iterator(); it.hasNext(); )
+            {
+                String filterPath = (String) it.next();
+                if ( path.equals( filterPath ) )
+                {
+                    found = true;
+                    break;
+                }
+            }
+        }
+
+        if ( !found )
+        {
+            fail( "Missing filter with path: " + path + " in " + testLabel );
+        }
+    }
+
+    private MavenProject buildProject( String path )
+        throws IOException, XmlPullParserException, URISyntaxException, ProjectBuildingException
+    {
+        ClassLoader cloader = Thread.currentThread().getContextClassLoader();
+        URL resource = cloader.getResource( "project-dynamism/" + path );
+
+        if ( resource == null )
+        {
+            fail( "Cannot find classpath resource for POM: " + path );
+        }
+
+        File pomFile = new File( resource.getPath() );
+        pomFile = pomFile.getAbsoluteFile();
+
+        MavenProject project = projectBuilder.build( pomFile,
+                                                     new DefaultProjectBuilderConfiguration() );
+
+        assertEquals( pomFile, project.getFile() );
+
+        return project;
+    }
+
+}
diff --git a/maven-project/src/test/java/org/apache/maven/project/ProjectBaseDirectoryAlignmentTest.java b/maven-project/src/test/java/org/apache/maven/project/ProjectBaseDirectoryAlignmentTest.java
index 573c883a6..960b2abdf 100644
--- a/maven-project/src/test/java/org/apache/maven/project/ProjectBaseDirectoryAlignmentTest.java
+++ b/maven-project/src/test/java/org/apache/maven/project/ProjectBaseDirectoryAlignmentTest.java
@@ -35,6 +35,7 @@ public class ProjectBaseDirectoryAlignmentTest
         File f = getTestFile( dir + "project-which-needs-directory-alignment.xml" );
 
         MavenProject project = getProject( f );
+        projectBuilder.calculateConcreteState( project, new DefaultProjectBuilderConfiguration() );
 
         assertNotNull( "Test project can't be null!", project );
 
diff --git a/maven-project/src/test/resources/project-dynamism/pom-interp.xml b/maven-project/src/test/resources/project-dynamism/pom-interp.xml
new file mode 100644
index 000000000..2ad098aab
--- /dev/null
+++ b/maven-project/src/test/resources/project-dynamism/pom-interp.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+         
+  <modelVersion>4.0.0</modelVersion>
+  
+  <groupId>org.test</groupId>
+  <artifactId>test-build-dynamism</artifactId>
+  <version>1</version>
+  
+  <build>
+    <sourceDirectory>/${project.groupId}/src/main/java</sourceDirectory>
+    <testSourceDirectory>/${pom.groupId}/src/test/java</testSourceDirectory>
+    <scriptSourceDirectory>/${groupId}/src/main/scripts</scriptSourceDirectory>
+    
+    <plugins>
+      <plugin>
+        <artifactId>my-plugin</artifactId>
+        <configuration>
+          <testOne>${project.groupId}</testOne>
+          <testTwo>${pom.groupId}</testTwo>
+          <testThree>${groupId}</testThree>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+
+</project>
\ No newline at end of file
diff --git a/maven-project/src/test/resources/project-dynamism/pom-relative.xml b/maven-project/src/test/resources/project-dynamism/pom-relative.xml
new file mode 100644
index 000000000..a24aebe68
--- /dev/null
+++ b/maven-project/src/test/resources/project-dynamism/pom-relative.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+         
+  <modelVersion>4.0.0</modelVersion>
+  
+  <groupId>org.test</groupId>
+  <artifactId>test-build-dynamism</artifactId>
+  <version>1</version>
+  
+  <properties>
+    <myProperty>${pom.build.directory}</myProperty>
+  </properties>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>${pom.build.directory}/generated-resources/plexus</directory>
+      </resource>
+    </resources>
+    
+    <filters>
+      <filter>${pom.build.directory}/generated-filters.properties</filter>
+    </filters>
+    
+    <directory>target</directory>
+    
+    <sourceDirectory>src/main/java</sourceDirectory>
+    <testSourceDirectory>src/test/java</testSourceDirectory>
+    <scriptSourceDirectory>src/main/scripts</scriptSourceDirectory>
+    
+    <outputDirectory>${pom.build.directory}/classes</outputDirectory>
+    <testOutputDirectory>${pom.build.directory}/test-classes</testOutputDirectory>
+  </build>
+
+</project>
\ No newline at end of file
diff --git a/maven-project/src/test/resources/project-dynamism/pom.xml b/maven-project/src/test/resources/project-dynamism/pom.xml
new file mode 100644
index 000000000..02bbed08f
--- /dev/null
+++ b/maven-project/src/test/resources/project-dynamism/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+         
+  <modelVersion>4.0.0</modelVersion>
+  
+  <groupId>org.test</groupId>
+  <artifactId>test-build-dynamism</artifactId>
+  <version>1</version>
+  
+  <properties>
+    <myProperty>${pom.build.directory}</myProperty>
+  </properties>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>${pom.build.directory}/generated-resources/plexus</directory>
+      </resource>
+    </resources>
+    
+    <filters>
+      <filter>${pom.build.directory}/generated-filters.properties</filter>
+    </filters>
+    
+    <directory>target</directory>
+    
+    <sourceDirectory>${pom.basedir}/src/main/java</sourceDirectory>
+    <testSourceDirectory>${pom.basedir}/src/test/java</testSourceDirectory>
+    <scriptSourceDirectory>${pom.basedir}/src/main/scripts</scriptSourceDirectory>
+    
+    <outputDirectory>${pom.build.directory}/classes</outputDirectory>
+    <testOutputDirectory>${pom.build.directory}/test-classes</testOutputDirectory>
+  </build>
+
+</project>
\ No newline at end of file
