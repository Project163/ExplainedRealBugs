diff --git a/src/test/shell/bazel/starlark_repository_test.sh b/src/test/shell/bazel/starlark_repository_test.sh
index b35051c9e3..9a65fd3d18 100755
--- a/src/test/shell/bazel/starlark_repository_test.sh
+++ b/src/test/shell/bazel/starlark_repository_test.sh
@@ -3476,4 +3476,56 @@ EOF
   [[ -f "$output_base/external/+repo+foo/ruff" ]] || fail "Expected ruff binary to be extracted"
 }
 
+# Regression test for https://github.com/bazelbuild/bazel/issues/27446.
+function do_test_local_module_file_patch() {
+  cat > $(setup_module_dot_bazel) <<'EOF'
+http_archive = use_repo_rule('@bazel_tools//tools/build_defs/repo:http.bzl', 'http_archive')
+# The MODULE.bazel file in this archive is not writeable.
+http_archive(
+  name = "rules_license",
+  urls = ["https://github.com/bazelbuild/rules_license/releases/download/1.0.0/rules_license-1.0.0.tar.gz"],
+  integrity = "sha256-JtQCH2iY4juC75UweDid1JrCtWGKxWSt5O+HzO0Uezg=",
+  patches = ["//:rules_license-rules_python-is-required-currently.patch"],
+  remote_module_file_urls = ["https://bcr.bazel.build/modules/rules_license/1.0.0/MODULE.bazel"],
+  remote_module_file_integrity = "sha256-p/2mDu/fPYyCcmK6SZlX5N8G9lkzC75s29uXW3aLtlw=",
+  patch_args = ["-p1"],
+)
+EOF
+
+  touch BUILD
+  cat > rules_license-rules_python-is-required-currently.patch <<'EOF'
+diff --git a/MODULE.bazel b/MODULE.bazel
+index 639c7c3..a880bbf 100644
+--- a/MODULE.bazel
++++ b/MODULE.bazel
+@@ -11,8 +11,9 @@ module(
+ # That will require rules_python, which we do not want to force on people who
+ # do not need //tools.
+
++bazel_dep(name = "rules_python", version = "0.35.0")
++
+ # Only for development
+ bazel_dep(name = "bazel_skylib", version = "1.7.1", dev_dependency = True)
+ bazel_dep(name = "rules_pkg", version = "1.0.1", dev_dependency = True)
+-bazel_dep(name = "rules_python", version = "0.35.0", dev_dependency = True)
+ bazel_dep(name = "stardoc", version = "0.6.2", dev_dependency = True)
+EOF
+
+  bazel query "$1" @rules_license//:all \
+    >& $TEST_log || fail "Expected bazel to succeed"
+
+  # Verify that the patch was applied.
+  external_repo_dir="$(bazel info output_base)/external/+http_archive+rules_license"
+  grep -q 'bazel_dep(name = "rules_python", version = "0.35.0")' \
+    "$external_repo_dir/MODULE.bazel" || fail "Patch was not applied"
+}
+
+function test_local_module_file_patch_with_hardlinks() {
+  do_test_local_module_file_patch "--experimental_repository_cache_hardlinks"
+}
+
+function test_local_module_file_patch_with_copy() {
+  do_test_local_module_file_patch "--noexperimental_repository_cache_hardlinks"
+}
+
 run_suite "local repository tests"
diff --git a/src/test/tools/bzlmod/MODULE.bazel.lock b/src/test/tools/bzlmod/MODULE.bazel.lock
index e88445554e..79dd55c3ca 100644
--- a/src/test/tools/bzlmod/MODULE.bazel.lock
+++ b/src/test/tools/bzlmod/MODULE.bazel.lock
@@ -186,7 +186,7 @@
   "moduleExtensions": {
     "@@pybind11_bazel+//:internal_configure.bzl%internal_configure_extension": {
       "general": {
-        "bzlTransitiveDigest": "X6LjWsFJ2Lt4rTFqqPZXOgcO+G9HyBOTNQ+Z4iS0m84=",
+        "bzlTransitiveDigest": "KZmG+HXFo6h6+eo0EHaCTECvOyY2l/VFoUYsOr0Phhk=",
         "usagesDigest": "D1r3lfzMuUBFxgG8V6o0bQTLMk3GkaGOaPzw53wrwyw=",
         "recordedFileInputs": {
           "@@pybind11_bazel+//MODULE.bazel": "e6f4c20442eaa7c90d7190d8dc539d0ab422f95c65a57cc59562170c58ae3d34"
@@ -216,7 +216,7 @@
     },
     "@@rules_kotlin+//src/main/starlark/core/repositories:bzlmod_setup.bzl%rules_kotlin_extensions": {
       "general": {
-        "bzlTransitiveDigest": "2Uvmven5Eh3Sc+TsuBRbsFlsQXIIlg02oPwrWY9Vtbc=",
+        "bzlTransitiveDigest": "BcC1+HOMyQbaxCezYLAcpAFojGIgibGrmncgO+T2cCU=",
         "usagesDigest": "QI2z8ZUR+mqtbwsf2fLqYdJAkPOHdOV+tF2yVAUgRzw=",
         "recordedFileInputs": {},
         "recordedDirentsInputs": {},
@@ -280,7 +280,7 @@
     },
     "@@rules_python+//python/uv:uv.bzl%uv": {
       "general": {
-        "bzlTransitiveDigest": "V/KJrfLTSOJoXsjGVd9Ty04FLKbPlisl4MEGeg4lkio=",
+        "bzlTransitiveDigest": "8vT1ddXtljNxYD0tJkksqzeKE6xqx4Ix+tXthAppjTI=",
         "usagesDigest": "p80sy6cYQuWxx5jhV3fOTu+N9EyIUFG9+F7UC/nhXic=",
         "recordedFileInputs": {},
         "recordedDirentsInputs": {},
diff --git a/tools/build_defs/repo/http.bzl b/tools/build_defs/repo/http.bzl
index bdb8705218..fdc0bd3020 100644
--- a/tools/build_defs/repo/http.bzl
+++ b/tools/build_defs/repo/http.bzl
@@ -135,10 +135,10 @@ def _update_http_archive_integrity_attrs(ctx, attrs, integrity):
     integrity_override = {}
 
     # We don't need to override the integrity attribute if sha256 is already specified.
+    # remote_module_file_integrity is for internal use by Bazel only and always
+    # set correctly.
     if not ctx.attr.sha256 and not ctx.attr.integrity:
         integrity_override["integrity"] = integrity.archive
-    if ctx.attr.remote_module_file_urls and not ctx.attr.remote_module_file_integrity:
-        integrity_override["remote_module_file_integrity"] = integrity.remote_module_file
     if ctx.attr.remote_file_integrity != integrity.remote_files:
         integrity_override["remote_file_integrity"] = integrity.remote_files
     if ctx.attr.remote_patches != integrity.remote_patches:
@@ -169,23 +169,10 @@ def _http_archive_impl(ctx):
     remote_patches_info = patch(ctx)
     symlink_files(ctx)
 
-    # Download the module file after applying patches since modules may decide
-    # to patch their packaged module and the patch may not apply to the file
-    # checked in to the registry. This overrides the file if it exists.
-    remote_module_file_integrity = ""
-    if ctx.attr.remote_module_file_urls:
-        remote_module_file_integrity = ctx.download(
-            ctx.attr.remote_module_file_urls,
-            "MODULE.bazel",
-            auth = get_auth(ctx, ctx.attr.remote_module_file_urls),
-            integrity = ctx.attr.remote_module_file_integrity,
-        ).integrity
-
     integrity = struct(
         archive = download_info.integrity,
         remote_files = {path: info.integrity for path, info in remote_files_info.items()},
         remote_patches = {url: info.integrity for url, info in remote_patches_info.items()},
-        remote_module_file = remote_module_file_integrity,
     )
 
     return _update_http_archive_integrity_attrs(ctx, _http_archive_attrs, integrity)
diff --git a/tools/build_defs/repo/utils.bzl b/tools/build_defs/repo/utils.bzl
index 983b5d238d..39c8aa8347 100644
--- a/tools/build_defs/repo/utils.bzl
+++ b/tools/build_defs/repo/utils.bzl
@@ -220,6 +220,25 @@ def patch(ctx, patches = None, patch_cmds = None, patch_cmds_win = None, patch_t
         ctx.delete(patchfile)
     ctx.delete(ctx.path(_REMOTE_PATCH_DIR))
 
+    # Support for the remote_module_file_urls attribute, which is only meant for
+    # internal use by Bazel when defining a Bazel module repository.
+    # Download the module file after applying remote (i.e., registry) patches
+    # since modules may decide to patch their packaged module and the patch may
+    # not apply to the file checked in to the registry.
+    # Download the module file before applying local patches since users should
+    # still be able to modify it via a single_version_override.
+    remote_module_file_urls = getattr(ctx.attr, "remote_module_file_urls", [])
+    if remote_module_file_urls:
+        if not ctx.attr.remote_module_file_integrity:
+            fail("remote_module_file_integrity must be set when remote_module_file_urls is set")
+        ctx.delete("MODULE.bazel")
+        ctx.download(
+            remote_module_file_urls,
+            "MODULE.bazel",
+            auth = get_auth(ctx, ctx.attr.remote_module_file_urls),
+            integrity = ctx.attr.remote_module_file_integrity,
+        )
+
     # Apply local patches
     if native_patch and _use_native_patch(patch_args):
         if patch_args:
