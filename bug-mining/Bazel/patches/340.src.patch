diff --git a/src/main/cpp/blaze.cc b/src/main/cpp/blaze.cc
index fa076ee453..cc48b56e32 100644
--- a/src/main/cpp/blaze.cc
+++ b/src/main/cpp/blaze.cc
@@ -1347,31 +1347,31 @@ static map<string, EnvVarValue> PrepareEnvironmentForJvm() {
   // TODO(bazel-team):  We've also seen a failure during loading (creating
   // threads?) when ulimit -Hs 8192.  Characterize that and check for it here.
 
-  // Make the JVM use ISO-8859-1 for parsing its command line because "blaze
-  // run" doesn't handle non-ASCII command line arguments. This is apparently
-  // the most reliable way to select the platform default encoding.
-  //
-  // On Linux, only do this if the locale is available to avoid the JVM
-  // falling back to ASCII-only mode.
-
-  const char *want_locale = "en_US.ISO-8859-1";
-  bool override_locale = true;
-#ifndef _WIN32
-  locale_t iso_locale = newlocale(LC_CTYPE_MASK, want_locale, (locale_t)0);
-  if (iso_locale == 0) {
-    // ISO-8859-1 locale not available, use whatever the user has defined.
-    override_locale = false;
-  } else {
-    freelocale(iso_locale);
+  // Ensure that the JVM runs with a locale that supports Unicode characters in
+  // filenames, environment variables, etc. The approach differs by OS:
+  // - On macOS, the JVM always uses UTF-8, so we don't need to do anything.
+  // - On Windows, the JVM uses the system code page to determine the encoding.
+  //   For the embedded JDK, we force this to UTF-8 in minimize_jdk.sh.
+  // - On Linux, the JVM goes through the regular locale mechanism. In
+  //   particular, we can only force UTF-8 if we can find a locale that supports
+  //   it. Furthermore, for backwards compatibility with setups using other
+  //   encodings, we pick a Latin-1 locale if possible to support arbitrary byte
+  //   sequences, not just valid UTF-8.
+#ifdef __linux__
+  const char *want_locale = nullptr;
+  for (auto candidate_locale : {"en_US.ISO-8859-1", "C.UTF-8", "en_US.UTF-8"}) {
+    locale_t locale = newlocale(LC_CTYPE_MASK, candidate_locale, nullptr);
+    if (locale != nullptr) {
+      freelocale(locale);
+      want_locale = candidate_locale;
+      break;
+    }
   }
-#endif
 
-  if (override_locale) {
-    result["LANG"] = EnvVarValue(EnvVarAction::SET, want_locale);
-    result["LANGUAGE"] = EnvVarValue(EnvVarAction::SET, want_locale);
+  if (want_locale != nullptr) {
     result["LC_ALL"] = EnvVarValue(EnvVarAction::SET, want_locale);
-    result["LC_CTYPE"] = EnvVarValue(EnvVarAction::SET, want_locale);
   }
+#endif
 
   return result;
 }
diff --git a/src/main/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcher.java b/src/main/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcher.java
index 6ad3425e45..af8ff01d13 100644
--- a/src/main/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcher.java
+++ b/src/main/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcher.java
@@ -17,6 +17,8 @@ import static com.google.devtools.build.lib.runtime.BlazeOptionHandler.BAD_OPTIO
 import static com.google.devtools.build.lib.runtime.BlazeOptionHandler.ERROR_SEPARATOR;
 import static com.google.devtools.build.lib.util.DetailedExitCode.DetailedExitCodeComparator.chooseMoreImportantWithFirstIfTie;
 import static com.google.devtools.common.options.Converters.BLAZE_ALIASING_FLAG;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.github.benmanes.caffeine.cache.Caffeine;
@@ -63,6 +65,7 @@ import com.google.devtools.build.lib.util.DetailedExitCode;
 import com.google.devtools.build.lib.util.ExitCode;
 import com.google.devtools.build.lib.util.InterruptedFailureDetails;
 import com.google.devtools.build.lib.util.LoggingUtil;
+import com.google.devtools.build.lib.util.OS;
 import com.google.devtools.build.lib.util.Pair;
 import com.google.devtools.build.lib.util.io.CommandExtensionReporter;
 import com.google.devtools.build.lib.util.io.DelegatingOutErr;
@@ -79,6 +82,7 @@ import com.google.protobuf.Any;
 import java.io.BufferedOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.charset.Charset;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -531,6 +535,8 @@ public class BlazeCommandDispatcher implements CommandDispatcher {
         }
       }
 
+      warnIfUsingUnusupportedEncoding(runtime.getProductName(), reporter);
+
       try (SilentCloseable closeable = Profiler.instance().profile("replay stored events")) {
         // Now we're ready to replay the events.
         storedEventHandler.replayOn(reporter);
@@ -977,4 +983,18 @@ public class BlazeCommandDispatcher implements CommandDispatcher {
                 .setCommand(FailureDetails.Command.newBuilder().setCode(detailedCode))
                 .build()));
   }
+
+  private static void warnIfUsingUnusupportedEncoding(String productName, Reporter reporter) {
+    // The user can only influence the JVM's encoding on Linux. See blaze.cc for details.
+    if (OS.getCurrent() != OS.LINUX) {
+      return;
+    }
+    var sunJnuEncoding = Charset.forName(System.getProperty("sun.jnu.encoding"));
+    if (!sunJnuEncoding.equals(UTF_8) && !sunJnuEncoding.equals(ISO_8859_1)) {
+      reporter.handle(
+          Event.warn(
+              "%1$s has been started with an unsupported encoding (%2$s) and may not support Unicode filenames. Make sure that the C.UTF-8 or en_US.UTF-8 locale is installed on your system and restart %1$s."
+                  .formatted(productName, sunJnuEncoding)));
+    }
+  }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcherTest.java b/src/test/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcherTest.java
index f2fee8df91..5fad9f23a2 100644
--- a/src/test/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcherTest.java
+++ b/src/test/java/com/google/devtools/build/lib/runtime/BlazeCommandDispatcherTest.java
@@ -244,8 +244,8 @@ public final class BlazeCommandDispatcherTest {
     String[] args = {"foo", "--stdout=Hello, out.",
                      "--stderr=Hello, err.", "--success=false"};
     BlazeCommandResult result = dispatch.exec(Arrays.asList(args), "test", outErr);
-    assertThat(outErr.outAsLatin1()).isEqualTo("Hello, out.");
-    assertThat(outErr.errAsLatin1()).isEqualTo("Hello, err.");
+    assertThat(outErr.outAsLatin1()).endsWith("Hello, out.");
+    assertThat(outErr.errAsLatin1()).endsWith("Hello, err.");
     assertThat(result.getExitCode()).isEqualTo(ExitCode.BUILD_FAILURE);
   }
 
@@ -561,7 +561,7 @@ public final class BlazeCommandDispatcherTest {
     assertThat(outErr.outAsLatin1()).isEqualTo("stdout");
     // TODO(bazel-team): Fix inconsistent line breaks that make the regex match necessary.
     assertThat(outErr.errAsLatin1())
-        .matches(
+        .containsMatch(
             "INFO: Reading rc options for 'foo' from /home/jrluser/.blazerc:\\s+"
                 + "  'foo' options: --stdout stdout --stderr stderr\\s+"
                 + "stderr");
@@ -608,7 +608,7 @@ public final class BlazeCommandDispatcherTest {
     assertThat(outErr.outAsLatin1()).isEqualTo("stdout");
     // TODO(bazel-team): Fix inconsistent line breaks that make the regex match necessary.
     assertThat(outErr.errAsLatin1())
-        .matches(
+        .containsMatch(
             "INFO: Reading rc options for 'wiz' from /home/jrluser/.blazerc:\\s+"
                 + "  Inherited 'foo' options: --stdout stdout --stderr stderr\\s+"
                 + "stderr");
