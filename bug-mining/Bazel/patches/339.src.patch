diff --git a/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java b/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
index 4049160a0c..340c0031cd 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
@@ -273,7 +273,7 @@ public final class ConfiguredTargetFactory {
                   analysisEnvironment
                       .getStarlarkSemantics()
                       .getBool(BuildLanguageOptions.EXPERIMENTAL_SIBLING_REPOSITORY_LAYOUT)),
-              inputFile.getPackageMetadata().sourceRoot().get(),
+              inputFile.getPackageMetadata().sourceRoot(),
               ConfiguredTargetKey.builder()
                   .setLabel(target.getLabel())
                   .setConfiguration(config)
@@ -385,15 +385,6 @@ public final class ConfiguredTargetFactory {
       final ConfiguredTarget target;
 
       if (ruleClass.isStarlark()) {
-        if (ruleClass.getRuleClassType().equals(RuleClass.Builder.RuleClassType.WORKSPACE)) {
-          ruleContext.ruleError(
-              "Found reference to a workspace rule in a context where a build"
-                  + " rule was expected; probably a reference to a target in that external"
-                  + " repository, properly specified as @reponame//path/to/package:target,"
-                  + " should have been specified by the requesting rule.");
-          return erroredConfiguredTarget(ruleContext, null);
-        }
-
         final Object rawProviders;
         final boolean isDefaultExecutableCreated;
         @Nullable final RequiredConfigFragmentsProvider requiredConfigFragmentsProvider;
diff --git a/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleClassFunctions.java b/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleClassFunctions.java
index e36244d3f3..962889bc5c 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleClassFunctions.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleClassFunctions.java
@@ -86,7 +86,6 @@ import com.google.devtools.build.lib.packages.ImplicitOutputsFunction.StarlarkIm
 import com.google.devtools.build.lib.packages.LabelConverter;
 import com.google.devtools.build.lib.packages.MacroClass;
 import com.google.devtools.build.lib.packages.MacroInstance;
-import com.google.devtools.build.lib.packages.Package;
 import com.google.devtools.build.lib.packages.PredicateWithMessage;
 import com.google.devtools.build.lib.packages.Rule;
 import com.google.devtools.build.lib.packages.RuleClass;
@@ -1474,8 +1473,7 @@ public class StarlarkRuleClassFunctions implements StarlarkRuleFunctionsApi {
     public Object call(StarlarkThread thread, Tuple args, Dict<String, Object> kwargs)
         throws EvalException, InterruptedException {
       TargetDefinitionContext targetDefinitionContext =
-          TargetDefinitionContext.fromOrFailDisallowWorkspace(
-              thread, "a symbolic macro", "instantiated");
+          TargetDefinitionContext.fromOrFail(thread, "a symbolic macro", "instantiated");
 
       if (macroClass == null) {
         throw Starlark.errorf(
@@ -1650,11 +1648,7 @@ public class StarlarkRuleClassFunctions implements StarlarkRuleFunctionsApi {
         throw new EvalException("Invalid rule class hasn't been exported by a bzl file");
       }
       TargetDefinitionContext targetDefinitionContext =
-          ruleClass.getWorkspaceOnly()
-              ? Package.Builder.fromOrFailAllowModuleExtension(
-                  thread, "a repository rule", "instantiated")
-              : TargetDefinitionContext.fromOrFailDisallowWorkspace(
-                  thread, "a rule", "instantiated");
+          TargetDefinitionContext.fromOrFail(thread, "a rule", "instantiated");
 
       validateRulePropagatedAspects(ruleClass);
 
diff --git a/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleContext.java b/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleContext.java
index 4e9499f013..f19c335d64 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleContext.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleContext.java
@@ -994,7 +994,6 @@ public final class StarlarkRuleContext
     Package.Metadata pkgMetadata = ruleContext.getRule().getPackageMetadata();
     return pkgMetadata
         .sourceRoot()
-        .get()
         .relativize(pkgMetadata.buildFilename().asPath())
         .getPathString();
   }
diff --git a/src/main/java/com/google/devtools/build/lib/packages/Package.java b/src/main/java/com/google/devtools/build/lib/packages/Package.java
index fdb45fbd04..be4a16fd88 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/Package.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/Package.java
@@ -24,18 +24,15 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedMap;
-import com.google.common.collect.Interner;
 import com.google.common.collect.Iterables;
 import com.google.devtools.build.lib.cmdline.BazelModuleContext;
 import com.google.devtools.build.lib.cmdline.BazelModuleContext.LoadGraphVisitor;
 import com.google.devtools.build.lib.cmdline.Label;
-import com.google.devtools.build.lib.cmdline.LabelConstants;
 import com.google.devtools.build.lib.cmdline.LabelSyntaxException;
 import com.google.devtools.build.lib.cmdline.PackageIdentifier;
 import com.google.devtools.build.lib.cmdline.RepositoryMapping;
 import com.google.devtools.build.lib.cmdline.StarlarkThreadContext;
 import com.google.devtools.build.lib.collect.CollectionUtils;
-import com.google.devtools.build.lib.concurrent.BlazeInterners;
 import com.google.devtools.build.lib.events.Event;
 import com.google.devtools.build.lib.events.EventHandler;
 import com.google.devtools.build.lib.packages.Package.Builder.PackageLimits;
@@ -74,7 +71,6 @@ import java.util.concurrent.Semaphore;
 import javax.annotation.Nullable;
 import net.starlark.java.eval.EvalException;
 import net.starlark.java.eval.Module;
-import net.starlark.java.eval.Starlark;
 import net.starlark.java.eval.StarlarkSemantics;
 import net.starlark.java.eval.StarlarkThread;
 import net.starlark.java.eval.SymbolGenerator;
@@ -102,7 +98,6 @@ public class Package extends Packageoid {
   //     afterwards
   //   - utility logical like validating names, checking for conflicts, etc.
   //   - tracking and enforcement of limits
-  //   - machinery specific to external package / WORKSPACE / bzlmod
 
   // ==== Static fields and enums ====
 
@@ -122,20 +117,6 @@ public class Package extends Packageoid {
     DEFAULT_STANDARD
   }
 
-  /**
-   * The "workspace name" of packages generated by Bzlmod to contain repo rules.
-   *
-   * <p>Normally, packages containing repo rules are differentiated from packages containing build
-   * rules by the {@link PackageIdentifier}: The singular repo-rule-containing package is {@code
-   * //external}. However, in Bzlmod, packages containing repo rules need to have meaningful {@link
-   * PackageIdentifier}s, so there needs to be some other way to distinguish them from
-   * build-rule-containing packages. We use the following magic string as the "workspace name" for
-   * repo-rule-containing packages generated by Bzlmod.
-   *
-   * @see Metadata#isRepoRulePackage()
-   */
-  private static final String DUMMY_WORKSPACE_NAME_FOR_BZLMOD_PACKAGES = "__dummy_workspace_bzlmod";
-
   // Can be changed during BUILD file evaluation due to exports_files() modifying its visibility.
   // Cannot be in Declarations because, since it's a Target, it holds a back reference to this
   // Package object.
@@ -244,8 +225,6 @@ public class Package extends Packageoid {
   /**
    * How to enforce visibility on <code>config_setting</code> See {@link
    * ConfigSettingVisibilityPolicy} for details.
-   *
-   * <p>Null for repo rule packages.
    */
   @Nullable
   public ConfigSettingVisibilityPolicy getConfigSettingVisibilityPolicy() {
@@ -276,13 +255,12 @@ public class Package extends Packageoid {
   }
 
   /**
-   * Returns the root of the source tree beneath which this package's BUILD file was found, or
-   * {@link Optional#empty} if this package was derived from a WORKSPACE file.
+   * Returns the root of the source tree beneath which this package's BUILD file was found.
    *
-   * <p>Assumes invariant: If non-empty, {@code
-   * getSourceRoot().get().getRelative(packageId.getSourceRoot()).equals(getPackageDirectory())}
+   * <p>Assumes invariant: {@code
+   * getSourceRoot().getRelative(packageId.getSourceRoot()).equals(getPackageDirectory())}
    */
-  public Optional<Root> getSourceRoot() {
+  public Root getSourceRoot() {
     return metadata.sourceRoot();
   }
 
@@ -588,10 +566,7 @@ public class Package extends Packageoid {
 
   // ==== Builders ====
 
-  /**
-   * Returns a new {@link Builder} suitable for constructing an ordinary package (i.e. not one for
-   * WORKSPACE or bzlmod).
-   */
+  /** Returns a new {@link Builder} suitable for constructing an ordinary package. */
   public static Builder newPackageBuilder(
       PackageSettings packageSettings,
       PackageIdentifier id,
@@ -612,19 +587,10 @@ public class Package extends Packageoid {
       boolean enableNameConflictChecking,
       boolean trackFullMacroInformation,
       PackageLimits packageLimits) {
-    // Determine whether this is for a repo rule package. We shouldn't actually have to do this
-    // because newPackageBuilder() is supposed to only be called for normal packages. Unfortunately
-    // serialization still uses the same code path for deserializing BUILD and WORKSPACE files,
-    // violating this method's contract.
-    boolean isRepoRulePackage =
-        id.equals(LabelConstants.EXTERNAL_PACKAGE_IDENTIFIER)
-            || workspaceName.equals(DUMMY_WORKSPACE_NAME_FOR_BZLMOD_PACKAGES);
-
     return new Builder(
         Metadata.builder()
             .packageIdentifier(id)
             .buildFilename(filename)
-            .isRepoRulePackage(isRepoRulePackage)
             .repositoryMapping(repositoryMapping)
             .associatedModuleName(associatedModuleName)
             .associatedModuleVersion(associatedModuleVersion)
@@ -646,48 +612,6 @@ public class Package extends Packageoid {
         packageLimits);
   }
 
-  // Bzlmod creates one fake package per external repository. The repos created by a given
-  // extension, which can be 1000s, share the same metadata.
-  private static final Interner<Metadata> bzlmodMetadataInterner = BlazeInterners.newWeakInterner();
-
-  public static Builder newExternalPackageBuilderForBzlmod(
-      RootedPath moduleFilePath,
-      boolean noImplicitFileExport,
-      boolean simplifyUnconditionalSelectsInRuleAttrs,
-      PackageIdentifier basePackageId,
-      RepositoryMapping repoMapping) {
-    // moduleFilePath is turned into a string and retained as the Location of
-    // the created package. Ensure that this string is the same instance as
-    // the one in the interned Metadata object.
-    RootedPath absoluteRootModuleFilePath =
-        RootedPath.toRootedPath(
-            Root.absoluteRoot(moduleFilePath.getRoot().getFileSystem()), moduleFilePath.asPath());
-    return new Builder(
-            bzlmodMetadataInterner.intern(
-                Metadata.builder()
-                    .packageIdentifier(basePackageId)
-                    .buildFilename(absoluteRootModuleFilePath)
-                    .isRepoRulePackage(true)
-                    .repositoryMapping(repoMapping)
-                    .succinctTargetNotFoundErrors(
-                        PackageSettings.DEFAULTS.succinctTargetNotFoundErrors())
-                    .build()),
-            SymbolGenerator.create(basePackageId),
-            PackageSettings.DEFAULTS.precomputeTransitiveLoads(),
-            noImplicitFileExport,
-            simplifyUnconditionalSelectsInRuleAttrs,
-            /* workspaceName= */ DUMMY_WORKSPACE_NAME_FOR_BZLMOD_PACKAGES,
-            /* mainRepositoryMapping= */ null,
-            /* cpuBoundSemaphore= */ null,
-            PackageOverheadEstimator.NOOP_ESTIMATOR,
-            /* generatorMap= */ null,
-            /* globber= */ null,
-            /* enableNameConflictChecking= */ true,
-            /* trackFullMacroInformation= */ true,
-            PackageLimits.DEFAULTS)
-        .setLoads(ImmutableList.of());
-  }
-
   // ==== Non-trivial nested classes ====
 
   /**
@@ -727,10 +651,7 @@ public class Package extends Packageoid {
         return builder;
       }
       throw newFromOrFailException(
-          what,
-          participle,
-          thread.getSemantics(),
-          EnumSet.of(FromOrFailMode.NO_MACROS, FromOrFailMode.NO_WORKSPACE));
+          what, participle, thread.getSemantics(), EnumSet.of(FromOrFailMode.NO_MACROS));
     }
 
     /**
@@ -1195,23 +1116,6 @@ public class Package extends Packageoid {
       return ctx instanceof Builder builder ? builder : null;
     }
 
-    /**
-     * Retrieves this object from a Starlark thread. If not present, or if this object is not a repo
-     * rule package builder, throws an {@link EvalException} with an error message indicating that
-     * {@code what} can only be used in a module extension.
-     */
-    @CanIgnoreReturnValue
-    public static Builder fromOrFailAllowModuleExtension(
-        StarlarkThread thread, String what, String participle) throws EvalException {
-      @Nullable StarlarkThreadContext ctx = thread.getThreadLocal(StarlarkThreadContext.class);
-      if (ctx instanceof Package.Builder pkgBuilder && pkgBuilder.isRepoRulePackage()) {
-        return pkgBuilder;
-      }
-      throw Starlark.errorf(
-          "%s can only be %s while evaluating the implementation function of a module extension",
-          what, participle);
-    }
-
     Package getPackage() {
       return (Package) pkg;
     }
@@ -1427,13 +1331,12 @@ public class Package extends Packageoid {
       PackageIdentifier packageIdentifier,
       RootedPath buildFilename,
       Label buildFileLabel,
-      boolean isRepoRulePackage,
       RepositoryMapping repositoryMapping,
       Optional<String> associatedModuleName,
       Optional<String> associatedModuleVersion,
       @Nullable ConfigSettingVisibilityPolicy configSettingVisibilityPolicy,
       boolean succinctTargetNotFoundErrors,
-      Optional<Root> sourceRoot) {
+      Root sourceRoot) {
 
     public static Builder builder() {
       return new AutoBuilder_Package_Metadata_Builder();
@@ -1446,8 +1349,6 @@ public class Package extends Packageoid {
 
       Builder buildFilename(RootedPath buildFilename);
 
-      Builder isRepoRulePackage(boolean isRepoRulePackage);
-
       Builder repositoryMapping(RepositoryMapping repositoryMapping);
 
       Builder associatedModuleName(Optional<String> associatedModuleName);
@@ -1465,7 +1366,6 @@ public class Package extends Packageoid {
     static Metadata of(
         PackageIdentifier packageIdentifier,
         RootedPath buildFilename,
-        boolean isRepoRulePackage,
         RepositoryMapping repositoryMapping,
         Optional<String> associatedModuleName,
         Optional<String> associatedModuleVersion,
@@ -1483,13 +1383,12 @@ public class Package extends Packageoid {
           packageIdentifier,
           buildFilename,
           buildFileLabel,
-          isRepoRulePackage,
           repositoryMapping,
           associatedModuleName,
           associatedModuleVersion,
           configSettingVisibilityPolicy,
           succinctTargetNotFoundErrors,
-          computeSourceRoot(packageIdentifier, buildFilename, isRepoRulePackage));
+          computeSourceRoot(packageIdentifier, buildFilename));
     }
 
     /**
@@ -1503,13 +1402,6 @@ public class Package extends Packageoid {
       Preconditions.checkNotNull(associatedModuleName);
       Preconditions.checkNotNull(associatedModuleVersion);
       Preconditions.checkNotNull(sourceRoot);
-
-      // Check for consistency between isRepoRulePackage and whether the buildFilename is a
-      // MODULE.bazel file.
-      String baseName = buildFilename.asPath().getBaseName();
-      boolean isModuleDotBazelFile =
-          baseName.equals(LabelConstants.MODULE_DOT_BAZEL_FILE_NAME.getPathString());
-      Preconditions.checkArgument(isRepoRulePackage == isModuleDotBazelFile);
     }
 
     /** Returns the name of this package (sans repository), e.g. "foo/bar". */
@@ -1535,13 +1427,10 @@ public class Package extends Packageoid {
       return buildFilename.asPath().getParentDirectory();
     }
 
-    private static Optional<Root> computeSourceRoot(
-        PackageIdentifier packageIdentifier, RootedPath buildFilename, boolean isRepoRulePackage) {
+    private static Root computeSourceRoot(
+        PackageIdentifier packageIdentifier, RootedPath buildFilename) {
       Preconditions.checkNotNull(packageIdentifier);
       Preconditions.checkNotNull(buildFilename);
-      if (isRepoRulePackage) {
-        return Optional.empty();
-      }
 
       RootedPath buildFileRootedPath = buildFilename;
       Root buildFileRoot = buildFileRootedPath.getRoot();
@@ -1578,7 +1467,7 @@ public class Package extends Packageoid {
           getPackageDirectory(buildFilename),
           packageIdentifier.getSourceRoot());
 
-      return Optional.of(sourceRoot);
+      return sourceRoot;
     }
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/packages/PackageFactory.java b/src/main/java/com/google/devtools/build/lib/packages/PackageFactory.java
index a8001c63db..0727f7d181 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/PackageFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/PackageFactory.java
@@ -138,9 +138,6 @@ public final class PackageFactory {
    * <p>Do not call this constructor directly in tests; please use
    * TestConstants#PACKAGE_FACTORY_BUILDER_FACTORY_FOR_TESTING instead.
    */
-  // TODO(bazel-team): Maybe store `version` in the RuleClassProvider rather than passing it in
-  // here? It's an extra constructor parameter that all the tests have to give, and it's only needed
-  // so WorkspaceFactory can add an extra top-level builtin.
   public PackageFactory(
       RuleClassProvider ruleClassProvider,
       ForkJoinPool executorForGlobbing,
diff --git a/src/main/java/com/google/devtools/build/lib/packages/PackagePiece.java b/src/main/java/com/google/devtools/build/lib/packages/PackagePiece.java
index 89a2e54d9a..80b68fe56d 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/PackagePiece.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/PackagePiece.java
@@ -219,7 +219,6 @@ public abstract sealed class PackagePiece extends Packageoid
           Metadata.builder()
               .packageIdentifier(identifier.getPackageIdentifier())
               .buildFilename(filename)
-              .isRepoRulePackage(false)
               .repositoryMapping(repositoryMapping)
               .associatedModuleName(associatedModuleName)
               .associatedModuleVersion(associatedModuleVersion)
diff --git a/src/main/java/com/google/devtools/build/lib/packages/RuleClass.java b/src/main/java/com/google/devtools/build/lib/packages/RuleClass.java
index ec937e6be8..0277d742e2 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/RuleClass.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/RuleClass.java
@@ -29,7 +29,6 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableTable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
@@ -41,7 +40,6 @@ import com.google.devtools.build.lib.analysis.config.transitions.TransitionFacto
 import com.google.devtools.build.lib.analysis.platform.PlatformConstants;
 import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.cmdline.LabelSyntaxException;
-import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.events.EventHandler;
 import com.google.devtools.build.lib.packages.Attribute.StarlarkComputedDefaultTemplate.CannotPrecomputeDefaultsException;
 import com.google.devtools.build.lib.packages.ConfigurationFragmentPolicy.MissingFragmentPolicy;
@@ -414,22 +412,6 @@ public class RuleClass implements RuleClassData {
         }
       },
 
-      /**
-       * Workspace rules can only be instantiated from a WORKSPACE file. Their names obey the rule
-       * for identifiers.
-       */
-      WORKSPACE {
-        @Override
-        public void checkName(String name) {
-          Preconditions.checkArgument(RULE_NAME_PATTERN.matcher(name).matches());
-        }
-
-        @Override
-        public void checkAttributes(Map<String, Attribute> attributes) {
-          // No required attributes.
-        }
-      },
-
       /**
        * Test rules are instantiable by BUILD files and are handled specially when run with the
        * 'test' command. Their names must obey the rules for identifiers in the BUILD language and
@@ -710,7 +692,6 @@ public class RuleClass implements RuleClassData {
     private boolean starlarkTestable = false;
     private boolean documented;
     private boolean outputsToBindir = true;
-    private boolean workspaceOnly = false;
     private boolean dependencyResolutionRule = false;
     private boolean isExecutableStarlark = false;
     private boolean isAnalysisTest = false;
@@ -742,11 +723,6 @@ public class RuleClass implements RuleClassData {
     // May be non-null only if the rule is Starlark-defined.
     @Nullable private String starlarkDocumentation = null;
 
-    /** This field is non-null iff the rule is a Starlark repo rule. */
-    @Nullable
-    private ImmutableTable<RepositoryName, String, RepositoryName>
-        ruleDefinitionEnvironmentRepoMappingEntries;
-
     private final ConfigurationFragmentPolicy.Builder configurationFragmentPolicy =
         new ConfigurationFragmentPolicy.Builder();
 
@@ -860,17 +836,12 @@ public class RuleClass implements RuleClassData {
      * @param name rule class name; if the builder was initialized with an empty name, this value
      *     will override it.
      * @param starlarkExtensionLabel the label of the Starlark file where the rule class was
-     *     exported. Permitted to be null only as a workaround for unexported repository rules in
-     *     legacy code - see https://github.com/bazelbuild/bazel/issues/10441 and b/111199163.
+     *     exported.
      */
-    public RuleClass buildStarlark(String name, @Nullable Label starlarkExtensionLabel) {
+    public RuleClass buildStarlark(String name, Label starlarkExtensionLabel) {
       Preconditions.checkState(starlark);
       this.starlarkExtensionLabel = starlarkExtensionLabel;
-      Label keyLabel =
-          this.starlarkExtensionLabel != null
-              ? this.starlarkExtensionLabel
-              : ruleDefinitionEnvironmentLabel;
-      return build(name, keyLabel + "%" + name);
+      return build(name, starlarkExtensionLabel + "%" + name);
     }
 
     /**
@@ -899,7 +870,7 @@ public class RuleClass implements RuleClassData {
           type,
           configuredTargetFactory,
           configuredTargetFunction);
-      if (!workspaceOnly && starlark) {
+      if (starlark) {
         assertStarlarkRuleClassHasImplementationFunction();
         assertStarlarkRuleClassHasEnvironmentLabel();
       }
@@ -958,7 +929,6 @@ public class RuleClass implements RuleClassData {
           starlarkTestable,
           documented,
           outputsToBindir,
-          workspaceOnly,
           dependencyResolutionRule,
           isExecutableStarlark,
           isAnalysisTest,
@@ -973,7 +943,6 @@ public class RuleClass implements RuleClassData {
           optionReferenceFunction,
           ruleDefinitionEnvironmentLabel,
           ruleDefinitionEnvironmentDigest,
-          ruleDefinitionEnvironmentRepoMappingEntries,
           configurationFragmentPolicy.build(),
           supportsConstraintChecking,
           toolchainTypes,
@@ -1143,12 +1112,6 @@ public class RuleClass implements RuleClassData {
       return this;
     }
 
-    @CanIgnoreReturnValue
-    public Builder setWorkspaceOnly() {
-      workspaceOnly = true;
-      return this;
-    }
-
     /**
      * Determines the outputs of this rule to be created beneath the {@code genfiles} directory. By
      * default, files are created beneath the {@code bin} directory.
@@ -1431,13 +1394,6 @@ public class RuleClass implements RuleClassData {
       return this.ruleDefinitionEnvironmentLabel;
     }
 
-    @CanIgnoreReturnValue
-    public Builder setRuleDefinitionEnvironmentRepoMappingEntries(
-        ImmutableTable<RepositoryName, String, RepositoryName> recordedRepoMappingEntries) {
-      this.ruleDefinitionEnvironmentRepoMappingEntries = recordedRepoMappingEntries;
-      return this;
-    }
-
     /**
      * Removes an attribute with the same name from this rule class.
      *
@@ -1722,7 +1678,6 @@ public class RuleClass implements RuleClassData {
   private final boolean starlarkTestable;
   private final boolean documented;
   private final boolean outputsToBindir;
-  private final boolean workspaceOnly;
   private final boolean dependencyResolutionRule;
   private final boolean isExecutableStarlark;
   private final boolean isAnalysisTest;
@@ -1776,10 +1731,6 @@ public class RuleClass implements RuleClassData {
 
   @Nullable private final byte[] ruleDefinitionEnvironmentDigest;
 
-  @Nullable
-  private final ImmutableTable<RepositoryName, String, RepositoryName>
-      ruleDefinitionEnvironmentRepoMappingEntries;
-
   private final OutputFile.Kind outputFileKind;
 
   /**
@@ -1837,7 +1788,6 @@ public class RuleClass implements RuleClassData {
       boolean starlarkTestable,
       boolean documented,
       boolean outputsToBindir,
-      boolean workspaceOnly,
       boolean dependencyResolutionRule,
       boolean isExecutableStarlark,
       boolean isAnalysisTest,
@@ -1852,9 +1802,6 @@ public class RuleClass implements RuleClassData {
       Function<? super Rule, ? extends Set<String>> optionReferenceFunction,
       @Nullable Label ruleDefinitionEnvironmentLabel,
       @Nullable byte[] ruleDefinitionEnvironmentDigest,
-      @Nullable
-          ImmutableTable<RepositoryName, String, RepositoryName>
-              ruleDefinitionEnvironmentRepoMappingEntries,
       ConfigurationFragmentPolicy configurationFragmentPolicy,
       boolean supportsConstraintChecking,
       Set<ToolchainTypeRequirement> toolchainTypes,
@@ -1889,9 +1836,7 @@ public class RuleClass implements RuleClassData {
     this.optionReferenceFunction = optionReferenceFunction;
     this.ruleDefinitionEnvironmentLabel = ruleDefinitionEnvironmentLabel;
     this.ruleDefinitionEnvironmentDigest = ruleDefinitionEnvironmentDigest;
-    this.ruleDefinitionEnvironmentRepoMappingEntries = ruleDefinitionEnvironmentRepoMappingEntries;
     this.outputFileKind = outputFileKind;
-    this.workspaceOnly = workspaceOnly;
     this.dependencyResolutionRule = dependencyResolutionRule;
     this.isExecutableStarlark = isExecutableStarlark;
     this.isAnalysisTest = isAnalysisTest;
@@ -1985,8 +1930,8 @@ public class RuleClass implements RuleClassData {
 
   /**
    * Returns the stack of Starlark active function calls at the moment this rule class was created.
-   * Entries appear outermost first, and exclude the built-in itself ('rule' or 'repository_rule').
-   * Empty for non-Starlark rules.
+   * Entries appear outermost first, and exclude the built-in itself ('rule'). Empty for
+   * non-Starlark rules.
    */
   public ImmutableList<StarlarkThread.CallStackEntry> getCallStack() {
     return callstack;
@@ -2013,10 +1958,6 @@ public class RuleClass implements RuleClassData {
     return targetKind;
   }
 
-  public boolean getWorkspaceOnly() {
-    return workspaceOnly;
-  }
-
   /**
    * Returns the attribute provider for this rule class. This can be queried to understand the
    * attribute schema associated with the rule.
@@ -2114,7 +2055,6 @@ public class RuleClass implements RuleClassData {
     return rule;
   }
 
- 
   /**
    * Report an error for each label that appears more than once in a LABEL_LIST attribute of the
    * given rule.
@@ -2242,9 +2182,8 @@ public class RuleClass implements RuleClassData {
    * For Starlark rule classes, returns this RuleClass's rule definition environment's label, which
    * is never null. Is null for native rules' RuleClass objects.
    *
-   * <p>In certain unusual cases (for example, unexported repository rules or analysis test rule
-   * classes), the values of {@link #getRuleDefinitionEnvironmentLabel()} and {@link
-   * #getStarlarkExtensionLabel()} may differ.
+   * <p>In certain unusual cases (for example, analysis test rule classes), the values of {@link
+   * #getRuleDefinitionEnvironmentLabel()} and {@link #getStarlarkExtensionLabel()} may differ.
    */
   // TODO(b/366027483): unify starlarkExtensionLabel and ruleDefinitionEnvironmentLabel.
   @Nullable
@@ -2275,12 +2214,6 @@ public class RuleClass implements RuleClassData {
     return ruleDefinitionEnvironmentDigest;
   }
 
-  @Nullable
-  public ImmutableTable<RepositoryName, String, RepositoryName>
-      getRuleDefinitionEnvironmentRepoMappingEntries() {
-    return ruleDefinitionEnvironmentRepoMappingEntries;
-  }
-
   /** Returns true if this RuleClass is a Starlark-defined RuleClass. */
   @Override
   public boolean isStarlark() {
@@ -2295,11 +2228,9 @@ public class RuleClass implements RuleClassData {
    * <p>If a Starlark rule class has been exported, the tuple (rule name, starlark extension label)
    * uniquely identifies it.
    *
-   * <p>In certain unusual cases (for example, unexported repository rules or analysis test rule
-   * classes), the values of {@link #getRuleDefinitionEnvironmentLabel()} and {@link
-   * #getStarlarkExtensionLabel()} may differ.
+   * <p>In certain unusual cases (for example, analysis test rule classes), the values of {@link
+   * #getRuleDefinitionEnvironmentLabel()} and {@link #getStarlarkExtensionLabel()} may differ.
    */
-  // TODO(b/111199163): prohibit use of unexported repository rules.
   // TODO(b/366027483): unify starlarkExtensionLabel and ruleDefinitionEnvironmentLabel.
   @Nullable
   public Label getStarlarkExtensionLabel() {
diff --git a/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java b/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
index a3b7df6b2f..025ab6d3bd 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
@@ -79,14 +79,6 @@ public class RuleFactory {
     } catch (LabelSyntaxException e) {
       throw new InvalidRuleException("illegal rule name: " + name + ": " + e.getMessage());
     }
-    boolean inWorkspaceFile = targetDefinitionContext.isRepoRulePackage();
-    if (ruleClass.getWorkspaceOnly() && !inWorkspaceFile) {
-      throw new RuleFactory.InvalidRuleException(
-          ruleClass + " must be in the WORKSPACE file " + "(used by " + label + ")");
-    } else if (!ruleClass.getWorkspaceOnly() && inWorkspaceFile) {
-      throw new RuleFactory.InvalidRuleException(
-          ruleClass + " cannot be in the WORKSPACE file " + "(used by " + label + ")");
-    }
 
     // Add the generator_name attribute.
     BuildLangTypedAttributeValuesMap processedAttributes;
@@ -320,12 +312,7 @@ public class RuleFactory {
               case BUILD_ONLY ->
                   Package.AbstractBuilder.fromOrFailAllowBuildOnly(
                       thread, String.format("%s rule", ruleClass.getName()), "instantiated");
-              case WORKSPACE ->
-                  Package.Builder.fromOrFailAllowModuleExtension(
-                      thread, "a repository rule", "instantiated");
-              default ->
-                  TargetDefinitionContext.fromOrFailDisallowWorkspace(
-                      thread, "a rule", "instantiated");
+              default -> TargetDefinitionContext.fromOrFail(thread, "a rule", "instantiated");
             };
         RuleFactory.createAndAddRule(
             targetDefinitionContext,
diff --git a/src/main/java/com/google/devtools/build/lib/packages/StarlarkNativeModule.java b/src/main/java/com/google/devtools/build/lib/packages/StarlarkNativeModule.java
index 627eded4cc..ad54d0b5f4 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/StarlarkNativeModule.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/StarlarkNativeModule.java
@@ -525,7 +525,7 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
       String name, Sequence<?> packagesO, Sequence<?> includesO, StarlarkThread thread)
       throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "package_group()");
+        TargetDefinitionContext.fromOrFail(thread, "package_group()");
 
     List<String> packages =
         Types.STRING_LIST.convert(packagesO, "'package_group.packages argument'");
@@ -563,7 +563,7 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
       Sequence<?> srcs, Object visibilityO, Object licensesO, StarlarkThread thread)
       throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "exports_files()");
+        TargetDefinitionContext.fromOrFail(thread, "exports_files()");
     List<String> files = Types.STRING_LIST.convert(srcs, "'exports_files' operand");
 
     RuleVisibility visibility =
@@ -615,14 +615,14 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
   @Override
   public String packageName(StarlarkThread thread) throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "package_name()");
+        TargetDefinitionContext.fromOrFail(thread, "package_name()");
     return targetDefinitionContext.getPackageIdentifier().getPackageFragment().getPathString();
   }
 
   @Override
   public List<Label> packageDefaultVisibility(StarlarkThread thread) throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "package_default_visibility()");
+        TargetDefinitionContext.fromOrFail(thread, "package_default_visibility()");
     return targetDefinitionContext
         .getPartialPackageArgs()
         .defaultVisibility()
@@ -635,14 +635,14 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
   @Override
   public String repositoryName(StarlarkThread thread) throws EvalException {
     // for legacy reasons, this is prefixed with a single '@'.
-    TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "repository_name()");
+    TargetDefinitionContext.fromOrFail(thread, "repository_name()");
     return '@' + repoName(thread);
   }
 
   @Override
   public String repoName(StarlarkThread thread) throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "repo_name()");
+        TargetDefinitionContext.fromOrFail(thread, "repo_name()");
     return targetDefinitionContext.getPackageIdentifier().getRepository().getName();
   }
 
@@ -652,7 +652,7 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
     LabelConverter labelConverter = thread.getThreadLocal(LabelConverter.class);
     if (labelConverter == null) {
       TargetDefinitionContext targetDefinitionContext =
-          TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "package_relative_label()");
+          TargetDefinitionContext.fromOrFail(thread, "package_relative_label()");
       labelConverter = targetDefinitionContext.getLabelConverter();
     }
     if (input instanceof Label inputLabel) {
@@ -669,7 +669,7 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
   @Nullable
   public String moduleName(StarlarkThread thread) throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "module_name()");
+        TargetDefinitionContext.fromOrFail(thread, "module_name()");
     return targetDefinitionContext.getAssociatedModuleName().orElse(null);
   }
 
@@ -677,7 +677,7 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
   @Nullable
   public String moduleVersion(StarlarkThread thread) throws EvalException {
     TargetDefinitionContext targetDefinitionContext =
-        TargetDefinitionContext.fromOrFailDisallowWorkspace(thread, "module_version()");
+        TargetDefinitionContext.fromOrFail(thread, "module_version()");
     return targetDefinitionContext.getAssociatedModuleVersion().orElse(null);
   }
 
@@ -872,8 +872,6 @@ public class StarlarkNativeModule implements StarlarkNativeModuleApi {
         // being acquired more times than it is released.
         cpuSemaphore.release();
       }
-      // getGlobber() is not null because we're called from glob() and subpackages(), both of which
-      // are guarded with Package.AbstractBuilder.fromOrFailDisallowingWorkspace().
       Globber.Token globToken =
           pkgBuilder.getGlobber().runAsync(includes, excludes, operation, allowEmpty);
       return pkgBuilder.getGlobber().fetchUnsorted(globToken);
diff --git a/src/main/java/com/google/devtools/build/lib/packages/TargetDefinitionContext.java b/src/main/java/com/google/devtools/build/lib/packages/TargetDefinitionContext.java
index ce100c8153..209327d4c4 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/TargetDefinitionContext.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/TargetDefinitionContext.java
@@ -101,9 +101,7 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
   // detected.
   protected final TargetRecorder recorder;
 
-  // Initialized from outside but also potentially set by `workspace()` function in WORKSPACE
-  // file.
-  protected String workspaceName;
+  protected final String workspaceName;
 
   private final boolean simplifyUnconditionalSelectsInRuleAttrs;
 
@@ -132,8 +130,7 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
   @Nullable protected IOException ioException = null;
   @Nullable protected DetailedExitCode ioExceptionDetailedExitCode = null;
 
-  // Used by glob(). Null for contexts where glob() is disallowed, including WORKSPACE files and
-  // some tests.
+  // Used by glob(). Null for contexts where glob() is disallowed, like some tests.
   @Nullable private final Globber globber;
 
   protected final Map<Label, EnvironmentGroup> environmentGroups = new HashMap<>();
@@ -175,71 +172,50 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
   /**
    * Retrieves this object from a Starlark thread. If not present, throws an {@link EvalException}
    * with an error message indicating that {@code what} can only be used in a target definition
-   * context - meaning in a BUILD file, a legacy or symbolic macro, or a WORKSPACE file.
+   * context - meaning in a BUILD file, or a legacy or symbolic macro.
    */
   @CanIgnoreReturnValue
   public static TargetDefinitionContext fromOrFail(StarlarkThread thread, String what)
       throws EvalException {
-    @Nullable StarlarkThreadContext ctx = thread.getThreadLocal(StarlarkThreadContext.class);
-    if (ctx instanceof TargetDefinitionContext targetDefinitionContext) {
-      return targetDefinitionContext;
-    }
-    boolean symbolicMacrosEnabled =
-        thread.getSemantics().getBool(BuildLanguageOptions.EXPERIMENTAL_ENABLE_FIRST_CLASS_MACROS);
-    throw Starlark.errorf(
-        "%s can only be used while evaluating a BUILD file, a %smacro, or a WORKSPACE file",
-        what, symbolicMacrosEnabled ? "legacy or symbolic " : "");
+    return fromOrFail(thread, what, "used");
   }
 
   /**
    * Retrieves this object from a Starlark thread. If not present, throws an {@link EvalException}
-   * with an error message indicating that {@code what} can only be used in a BUILD file, a
-   * finalizer symbolic macro, or a WORKSPACE file.
+   * with an error message indicating that {@code what} can only be {@code participle}d in a target
+   * definition context - meaning in a BUILD file, or a legacy or symbolic macro.
    */
   @CanIgnoreReturnValue
-  public static TargetDefinitionContext fromOrFailDisallowNonFinalizerMacros(
-      StarlarkThread thread, String what) throws EvalException {
+  public static TargetDefinitionContext fromOrFail(
+      StarlarkThread thread, String what, String participle) throws EvalException {
     @Nullable StarlarkThreadContext ctx = thread.getThreadLocal(StarlarkThreadContext.class);
-    if (ctx instanceof TargetDefinitionContext targetDefinitionContext
-        && !targetDefinitionContext.recorder.currentlyInNonFinalizerMacro()) {
+    if (ctx instanceof TargetDefinitionContext targetDefinitionContext) {
       return targetDefinitionContext;
     }
     throw newFromOrFailException(
-        what, thread.getSemantics(), EnumSet.of(FromOrFailMode.ONLY_FINALIZER_MACROS));
+        what, participle, thread.getSemantics(), EnumSet.noneOf(FromOrFailMode.class));
   }
 
   /**
    * Retrieves this object from a Starlark thread. If not present, throws an {@link EvalException}
-   * with an error message indicating that {@code what} can only be used in a BUILD file or a legacy
-   * or symbolic macro.
+   * with an error message indicating that {@code what} can only be used in a BUILD file or a
+   * finalizer symbolic macro.
    */
   @CanIgnoreReturnValue
-  public static TargetDefinitionContext fromOrFailDisallowWorkspace(
-      StarlarkThread thread, String what, String participle) throws EvalException {
+  public static TargetDefinitionContext fromOrFailDisallowNonFinalizerMacros(
+      StarlarkThread thread, String what) throws EvalException {
     @Nullable StarlarkThreadContext ctx = thread.getThreadLocal(StarlarkThreadContext.class);
     if (ctx instanceof TargetDefinitionContext targetDefinitionContext
-        && !targetDefinitionContext.isRepoRulePackage()) {
+        && !targetDefinitionContext.recorder.currentlyInNonFinalizerMacro()) {
       return targetDefinitionContext;
     }
     throw newFromOrFailException(
-        what, participle, thread.getSemantics(), EnumSet.of(FromOrFailMode.NO_WORKSPACE));
-  }
-
-  /**
-   * Retrieves this object from a Starlark thread. If not present, throws an {@link EvalException}
-   * with an error message indicating that {@code what} can only be used in a BUILD file or a legacy
-   * or symbolic macro.
-   */
-  @CanIgnoreReturnValue
-  public static TargetDefinitionContext fromOrFailDisallowWorkspace(
-      StarlarkThread thread, String what) throws EvalException {
-    return fromOrFailDisallowWorkspace(thread, what, "used");
+        what, thread.getSemantics(), EnumSet.of(FromOrFailMode.ONLY_FINALIZER_MACROS));
   }
 
   enum FromOrFailMode {
     NO_MACROS,
     ONLY_FINALIZER_MACROS,
-    NO_WORKSPACE,
   }
 
   static EvalException newFromOrFailException(
@@ -268,9 +244,6 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
     if (symbolicMacrosEnabled && modes.contains(FromOrFailMode.ONLY_FINALIZER_MACROS)) {
       allowedUses.add("a rule finalizer");
     }
-    if (!modes.contains(FromOrFailMode.NO_WORKSPACE)) {
-      allowedUses.add("a WORKSPACE file");
-    }
 
     return Starlark.errorf(
         "%s can only be %s while evaluating %s",
@@ -467,36 +440,18 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
   }
 
   /**
-   * Determine whether this package should contain build rules (returns {@code false}) or repo rules
-   * (returns {@code true}).
-   */
-  public boolean isRepoRulePackage() {
-    return metadata.isRepoRulePackage();
-  }
-
-  /**
-   * Returns the name of the workspace this package is in. Used as a prefix for the runfiles
-   * directory. This can be set in the WORKSPACE file. This must be a valid target name.
-   */
-  String getWorkspaceName() {
-    // Current value is stored in the builder field, final value is copied to the Package in
-    // finishInit().
-    return workspaceName;
-  }
-
-  /**
-   * Returns the name of the Bzlmod module associated with the repo this package is in. If this
-   * package is not from a Bzlmod repo, this is empty. For repos generated by module extensions,
-   * this is the name of the module hosting the extension.
+   * Returns the name of the Bazel module associated with the repo this package is in. If this
+   * package is in the special {@code @_builtins} pseudo-repo, this is empty. For repos generated by
+   * module extensions, this is the name of the module hosting the extension.
    */
   Optional<String> getAssociatedModuleName() {
     return metadata.associatedModuleName();
   }
 
   /**
-   * Returns the version of the Bzlmod module associated with the repo this package is in. If this
-   * package is not from a Bzlmod repo, this is empty. For repos generated by module extensions,
-   * this is the version of the module hosting the extension.
+   * Returns the version of the Bazel module associated with the repo this package is in. If this
+   * package is in the special {@code @_builtins} pseudo-repo, this is empty. For repos generated by
+   * module extensions, this is the version of the module hosting the extension.
    */
   Optional<String> getAssociatedModuleVersion() {
     return metadata.associatedModuleVersion();
@@ -554,8 +509,7 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
 
   /**
    * Returns the {@link Globber} used to implement {@code glob()} functionality during BUILD
-   * evaluation. Null for contexts where globbing is not possible, including WORKSPACE files and
-   * some tests.
+   * evaluation. Null for contexts where globbing is not possible, like some tests.
    */
   @Nullable
   public Globber getGlobber() {
@@ -809,7 +763,6 @@ public abstract class TargetDefinitionContext extends StarlarkThreadContext {
   }
 
   public void addMacro(MacroInstance macro) throws NameConflictException {
-    checkState(!isRepoRulePackage(), "Cannot instantiate symbolic macros in this context");
     recorder.addMacro(macro);
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/pkgcache/FilteringPolicies.java b/src/main/java/com/google/devtools/build/lib/pkgcache/FilteringPolicies.java
index 97516e1397..b9a458f9ee 100644
--- a/src/main/java/com/google/devtools/build/lib/pkgcache/FilteringPolicies.java
+++ b/src/main/java/com/google/devtools/build/lib/pkgcache/FilteringPolicies.java
@@ -100,10 +100,7 @@ public final class FilteringPolicies {
   private static class RulesOnly extends AbstractFilteringPolicy {
     @Override
     public boolean shouldRetain(Target target, boolean explicit) {
-      // With the sibling repository layout in effect, TargetPatternFunction tries to recurse into
-      // the special //external package even when there are no build rules. Prevent it by excluding
-      // WORKSPACE-only rules in addition to checking if target is a Rule object.
-      return target instanceof Rule && !((Rule) target).getRuleClassObject().getWorkspaceOnly();
+      return target instanceof Rule;
     }
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/query2/query/output/FormatUtils.java b/src/main/java/com/google/devtools/build/lib/query2/query/output/FormatUtils.java
index 24c3531309..2383fb0592 100644
--- a/src/main/java/com/google/devtools/build/lib/query2/query/output/FormatUtils.java
+++ b/src/main/java/com/google/devtools/build/lib/query2/query/output/FormatUtils.java
@@ -86,8 +86,8 @@ final class FormatUtils {
 
   private static Location getLocationUnderAlternateRoot(
       Location location, @Nullable Package.Metadata base, PathFragment alternateRoot) {
-    if (base != null && base.sourceRoot().isPresent()) { // !isPresent => WORKSPACE pseudo-package
-      Root root = base.sourceRoot().get();
+    if (base != null) {
+      Root root = base.sourceRoot();
       PathFragment file = PathFragment.create(location.file());
       if (root.contains(file)) {
         PathFragment rel = root.relativize(file);
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/IncrementalPackageRoots.java b/src/main/java/com/google/devtools/build/lib/skyframe/IncrementalPackageRoots.java
index 2289ace733..4101ecd58e 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/IncrementalPackageRoots.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/IncrementalPackageRoots.java
@@ -277,12 +277,12 @@ public class IncrementalPackageRoots implements PackageRoots {
       Package.Metadata pkg, Set<Path> lazilyPlantedSymlinksRef) throws AbruptExitException {
     try {
       PackageIdentifier pkgId = pkg.packageIdentifier();
-      if (isExternalRepository(pkgId) && pkg.sourceRoot().isPresent()) {
+      if (isExternalRepository(pkgId)) {
         threadSafeExternalRepoPackageRootsMap.putIfAbsent(
-            pkg.packageIdentifier(), pkg.sourceRoot().get());
+            pkg.packageIdentifier(), pkg.sourceRoot());
         SymlinkForest.plantSingleSymlinkForExternalRepo(
             pkgId.getRepository(),
-            pkg.sourceRoot().get().asPath(),
+            pkg.sourceRoot().asPath(),
             execroot,
             useSiblingRepositoryLayout,
             lazilyPlantedSymlinksRef);
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/PackageFunction.java b/src/main/java/com/google/devtools/build/lib/skyframe/PackageFunction.java
index 5078a57e34..61289f30af 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/PackageFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/PackageFunction.java
@@ -379,9 +379,8 @@ public abstract class PackageFunction implements SkyFunction {
           .setTransience(Transience.PERSISTENT)
           .setPackageIdentifier(LabelConstants.EXTERNAL_PACKAGE_IDENTIFIER)
           .setMessage(
-              "//external package is not available since the WORKSPACE file is disabled, please"
-                  + " migrate to Bzlmod or temporarily enable WORKSPACE via --enable_workspace. See"
-                  + " https://bazel.build/external/migration#bind-targets.")
+              "//external package is not available since the WORKSPACE file is deprecated, please"
+                  + " migrate to Bzlmod. See https://bazel.build/external/migration#bind-targets.")
           .setPackageLoadingCode(PackageLoading.Code.WORKSPACE_FILE_ERROR)
           .build();
     }
@@ -651,17 +650,16 @@ public abstract class PackageFunction implements SkyFunction {
    *
    * <p>The {@code packageId} is used only for error reporting.
    *
-   * <p>This function is called for load statements in BUILD and WORKSPACE files. For loads in .bzl
-   * files, see {@link BzlLoadFunction}.
+   * <p>This function is called for load statements in BUILD files. For loads in .bzl files, see
+   * {@link BzlLoadFunction}.
    */
   /*
    * TODO(b/237658764): This logic has several problems:
    *
    * - It is partly duplicated by loadPrelude() below.
    * - The meaty computeBzlLoads* helpers are almost copies of BzlLoadFunction#computeBzlLoads*.
-   * - This function is called from WorkspaceFileFunction and BzlmodRepoRuleFunction (and morally
-   *   probably should be called by SingleExtensionEvalFunction rather than requesting a BzlLoadKey
-   *   directly). But the API is awkward for these callers.
+   * - This function should morally probably be called by {Innate,Regular}RunnableExtension rather
+   *   than requesting a BzlLoadKey directly. But the API is awkward for these callers.
    * - InliningState is not shared across all callers within a BUILD file; see the comment in
    *   computeBzlLoadsWithInlining.
    *
@@ -700,8 +698,7 @@ public abstract class PackageFunction implements SkyFunction {
       if (bzlLoads == null) {
         return null; // Skyframe deps unavailable
       }
-      // Validate that the current BUILD/WORKSPACE file satisfies each loaded dependency's
-      // load visibility.
+      // Validate that the current BUILD file satisfies each loaded dependency's load visibility.
       if (checkVisibility) {
         BzlLoadFunction.checkLoadVisibilities(
             packageId,
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/SkyframeExecutor.java b/src/main/java/com/google/devtools/build/lib/skyframe/SkyframeExecutor.java
index 06f6eeb433..f8b9759b3f 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/SkyframeExecutor.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/SkyframeExecutor.java
@@ -2401,10 +2401,7 @@ public abstract class SkyframeExecutor implements WalkableGraphFactory {
               if (key instanceof PackageIdentifier && nodeEntry.isDone()) {
                 PackageValue packageValue = (PackageValue) nodeEntry.getValue();
                 if (packageValue != null) { // Null for errors e.g. "no such package"
-                  Optional<Root> sourceRoot = packageValue.getPackage().getSourceRoot();
-                  if (sourceRoot.isPresent()) {
-                    roots.put((PackageIdentifier) key, sourceRoot.get());
-                  }
+                  roots.put((PackageIdentifier) key, packageValue.getPackage().getSourceRoot());
                 }
               }
             });
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/TransitiveDependencyStateTest.java b/src/test/java/com/google/devtools/build/lib/analysis/TransitiveDependencyStateTest.java
index 4adac5dba8..cf98a1a5e1 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/TransitiveDependencyStateTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/TransitiveDependencyStateTest.java
@@ -153,7 +153,6 @@ public final class TransitiveDependencyStateTest {
         .buildFilename(
             RootedPath.toRootedPath(
                 fakeRoot, fakeRoot.getRelative(id.getPackageFragment().getRelative("BUILD"))))
-        .isRepoRulePackage(false)
         .repositoryMapping(RepositoryMapping.EMPTY)
         .succinctTargetNotFoundErrors(PackageSettings.DEFAULTS.succinctTargetNotFoundErrors())
         .build();
diff --git a/src/test/java/com/google/devtools/build/lib/packages/RuleClassTest.java b/src/test/java/com/google/devtools/build/lib/packages/RuleClassTest.java
index 1fd4877102..1584846e23 100644
--- a/src/test/java/com/google/devtools/build/lib/packages/RuleClassTest.java
+++ b/src/test/java/com/google/devtools/build/lib/packages/RuleClassTest.java
@@ -104,7 +104,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         false,
         false,
         false,
-        false,
         SafeImplicitOutputsFunction.NONE,
         null,
         DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -136,7 +135,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         false,
         false,
         false,
-        false,
         SafeImplicitOutputsFunction.NONE,
         null,
         DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -301,7 +299,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -343,7 +340,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -379,7 +375,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -427,7 +422,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -469,7 +463,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -511,7 +504,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -607,7 +599,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             ImplicitOutputsFunction.fromTemplates(
                 "foo-%{name}.bar", "lib%{name}-wazoo-%{name}.mumble", "stuff-%{outs}-bar"),
             null,
@@ -643,7 +634,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             ImplicitOutputsFunction.fromTemplates("%{dirname}lib%{basename}.bar"),
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -671,7 +661,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             ImplicitOutputsFunction.fromTemplates("%{truthiness}"),
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -705,7 +694,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         false,
         false,
         false,
-        false,
         ImplicitOutputsFunction.fromTemplates("empty"),
         null,
         DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -873,7 +861,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             ImplicitOutputsFunction.fromTemplates("first-%{name}", "second-%{name}", "out-%{outs}"),
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -910,7 +897,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
             false,
             false,
             false,
-            false,
             SafeImplicitOutputsFunction.NONE,
             null,
             DUMMY_CONFIGURED_TARGET_FACTORY,
@@ -1057,7 +1043,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
       boolean starlarkExecutable,
       boolean documented,
       boolean binaryOutput,
-      boolean workspaceOnly,
       boolean outputsDefaultExecutable,
       boolean isAnalysisTest,
       ImplicitOutputsFunction implicitOutputsFunction,
@@ -1084,7 +1069,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         /* starlarkTestable= */ false,
         documented,
         binaryOutput,
-        workspaceOnly,
         /* dependencyResolutionRule= */ false,
         outputsDefaultExecutable,
         isAnalysisTest,
@@ -1099,7 +1083,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         /* optionReferenceFunction= */ RuleClass.NO_OPTION_REFERENCE,
         /* ruleDefinitionEnvironmentLabel= */ null,
         /* ruleDefinitionEnvironmentDigest= */ null,
-        /* ruleDefinitionEnvironmentRepoMappingEntries= */ null,
         new ConfigurationFragmentPolicy.Builder()
             .requiresConfigurationFragments(allowedConfigurationFragments)
             .build(),
@@ -1128,7 +1111,6 @@ public final class RuleClassTest extends PackageLoadingTestCase {
         false,
         false,
         false,
-        false,
         SafeImplicitOutputsFunction.NONE,
         null,
         DUMMY_CONFIGURED_TARGET_FACTORY,
diff --git a/src/test/java/com/google/devtools/build/lib/pkgcache/PackageLoadingTest.java b/src/test/java/com/google/devtools/build/lib/pkgcache/PackageLoadingTest.java
index 22ee46a00a..59a91ca838 100644
--- a/src/test/java/com/google/devtools/build/lib/pkgcache/PackageLoadingTest.java
+++ b/src/test/java/com/google/devtools/build/lib/pkgcache/PackageLoadingTest.java
@@ -329,7 +329,7 @@ public class PackageLoadingTest extends FoundationTestCase {
     Package oldPkg = getPackage("pkg");
     assertThat(getPackage("pkg")).isSameInstanceAs(oldPkg); // change not yet visible
     assertThat(oldPkg.getFilename().asPath()).isEqualTo(buildFile1);
-    assertThat(oldPkg.getSourceRoot().get()).isEqualTo(Root.fromPath(rootDirectory));
+    assertThat(oldPkg.getSourceRoot()).isEqualTo(Root.fromPath(rootDirectory));
 
     buildFile1.delete();
     invalidatePackages();
@@ -337,7 +337,7 @@ public class PackageLoadingTest extends FoundationTestCase {
     Package newPkg = getPackage("pkg");
     assertThat(newPkg).isNotSameInstanceAs(oldPkg);
     assertThat(newPkg.getFilename().asPath()).isEqualTo(buildFile2);
-    assertThat(newPkg.getSourceRoot().get()).isEqualTo(Root.fromPath(scratch.dir("/otherroot")));
+    assertThat(newPkg.getSourceRoot()).isEqualTo(Root.fromPath(scratch.dir("/otherroot")));
 
     // TODO(bazel-team): (2009) test BUILD file moves in the other direction too.
   }
diff --git a/src/test/java/com/google/devtools/build/lib/starlark/StarlarkRuleClassFunctionsTest.java b/src/test/java/com/google/devtools/build/lib/starlark/StarlarkRuleClassFunctionsTest.java
index 50e844eff7..ea4702f04a 100644
--- a/src/test/java/com/google/devtools/build/lib/starlark/StarlarkRuleClassFunctionsTest.java
+++ b/src/test/java/com/google/devtools/build/lib/starlark/StarlarkRuleClassFunctionsTest.java
@@ -4624,8 +4624,8 @@ public final class StarlarkRuleClassFunctionsTest extends BuildViewTestCase {
     getConfiguredTarget("//initializer_testing:my_target");
 
     ev.assertContainsError(
-        "existing_rules() can only be used while evaluating a BUILD file, a legacy macro, a rule"
-            + " finalizer, or a WORKSPACE file");
+        "existing_rules() can only be used while evaluating a BUILD file, a legacy macro, or a rule"
+            + " finalizer");
   }
 
   @Test
