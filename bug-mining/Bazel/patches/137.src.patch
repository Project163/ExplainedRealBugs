diff --git a/BUILD b/BUILD
index 28804531e1..ca81b1d268 100644
--- a/BUILD
+++ b/BUILD
@@ -168,7 +168,9 @@ pkg_tar(
 write_file(
     name = "gen_maven_repo_name",
     out = "MAVEN_CANONICAL_REPO_NAME",
-    content = [get_canonical_repo_name("@maven")],
+    # TODO: Use this instead after building with Bazel 7.1.0 or later.
+    #    content = [get_canonical_repo_name("@maven")],
+    content = ["rules_jvm_external~~maven~maven"],
 )
 
 # The @maven repository is created by maven_install from rules_jvm_external.
diff --git a/MODULE.bazel.lock b/MODULE.bazel.lock
index 2856f563d2..1b9df002f5 100644
--- a/MODULE.bazel.lock
+++ b/MODULE.bazel.lock
@@ -2598,7 +2598,7 @@
   "moduleExtensions": {
     "//:extensions.bzl%bazel_android_deps": {
       "general": {
-        "bzlTransitiveDigest": "wiyY30lgHvAgghminN0h4lxMWexDIg/6r/+eOIA5bPU=",
+        "bzlTransitiveDigest": "uzRwJ/aaGLzKqN69Hz+DktJFrVeKCjILtM+t4Hirz0M=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
@@ -2739,9 +2739,9 @@
     },
     "//:extensions.bzl%bazel_build_deps": {
       "general": {
-        "bzlTransitiveDigest": "wiyY30lgHvAgghminN0h4lxMWexDIg/6r/+eOIA5bPU=",
+        "bzlTransitiveDigest": "uzRwJ/aaGLzKqN69Hz+DktJFrVeKCjILtM+t4Hirz0M=",
         "accumulatedFileDigests": {
-          "@@//src/test/tools/bzlmod:MODULE.bazel.lock": "fe01365e67163a67a1620e4aeb3aec24e8d6b4cc20c49ca9582a5d090b8185b4",
+          "@@//src/test/tools/bzlmod:MODULE.bazel.lock": "e591609d4999da0cac2aad19df3ff8a1e42f3f032fb16308037d0d9e555f369f",
           "@@//:MODULE.bazel": "f291782aef1d2989f49c0e884b32ec8d7814ae48c598b6f3060870ccb3f5c0b6"
         },
         "envVariables": {},
@@ -3122,7 +3122,7 @@
     },
     "//:extensions.bzl%bazel_test_deps": {
       "general": {
-        "bzlTransitiveDigest": "wiyY30lgHvAgghminN0h4lxMWexDIg/6r/+eOIA5bPU=",
+        "bzlTransitiveDigest": "uzRwJ/aaGLzKqN69Hz+DktJFrVeKCjILtM+t4Hirz0M=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
diff --git a/scripts/bootstrap/compile.sh b/scripts/bootstrap/compile.sh
index dac9f88b79..468cd91111 100755
--- a/scripts/bootstrap/compile.sh
+++ b/scripts/bootstrap/compile.sh
@@ -254,6 +254,10 @@ EOF
   link_file "${PWD}/src/MODULE.tools" "${BAZEL_TOOLS_REPO}/MODULE.bazel"
   new_hash=$(shasum -a 256 "${BAZEL_TOOLS_REPO}/MODULE.bazel" | awk '{print $1}')
   sed -i.bak "/\"bazel_tools\":/s/\"[a-f0-9]*\"/\"$new_hash\"/" MODULE.bazel.lock
+  # TODO: Temporary hack for lockfile version mismatch, remove these lines after updating to 7.1.0
+  sed -i.bak 's/"lockFileVersion": 3/"lockFileVersion": 4/' MODULE.bazel.lock
+  # Replace canonical repository names and parts thereof of the form rules_foo~1.2.3 with rules_foo~
+  sed -i.bak -E 's/([a-z]([a-z0-9._-]*[a-z0-9]){0,1})~[a-zA-Z0-9.]{1,}(-[0-9.-]{1,}){0,1}(\+[0-9.-]{1,}){0,1}/\1/g' MODULE.bazel.lock
   rm MODULE.bazel.lock.bak
 
   mkdir -p "${BAZEL_TOOLS_REPO}/src/conditions"
diff --git a/site/en/external/mod-command.md b/site/en/external/mod-command.md
index 9914d7c9d5..f3ebbe8eaf 100644
--- a/site/en/external/mod-command.md
+++ b/site/en/external/mod-command.md
@@ -395,7 +395,7 @@ use_repo(toolchains, my_jdk="remotejdk17_linux")
     ## rules_cc@0.0.1:
     # <builtin>
     http_archive(
-      name = "rules_cc~0.0.1",
+      name = "rules_cc~",
       urls = ["https://bcr.bazel.build/test-mirror/github.com/bazelbuild/rules_cc/releases/download/0.0.1/rules_cc-0.0.1.tar.gz", "https://github.com/bazelbuild/rules_cc/releases/download/0.0.1/rules_cc-0.0.1.tar.gz"],
       integrity = "sha256-Tcy/0iwN7xZMj0dFi9UODHFI89kgAs20WcKpamhJgkE=",
       strip_prefix = "",
@@ -408,7 +408,7 @@ use_repo(toolchains, my_jdk="remotejdk17_linux")
     ## stardoc:
     # <builtin>
     http_archive(
-      name = "stardoc~0.5.0",
+      name = "stardoc~",
       urls = ["https://bcr.bazel.build/test-mirror/github.com/bazelbuild/stardoc/releases/download/0.5.0/stardoc-0.5.0.tar.gz", "https://github.com/bazelbuild/stardoc/releases/download/0.5.0/stardoc-0.5.0.tar.gz"],
       integrity = "sha256-yXlNzIAmow/2fPfPkeviRcopSyCwcYRdEsGSr+JDrXI=",
       strip_prefix = "",
@@ -538,7 +538,7 @@ use_repo(toolchains, my_jdk="remotejdk17_linux")
     ## @remote_java_tools:
     # <builtin>
     http_archive(
-      name = "rules_java~5.0.0~toolchains~remote_java_tools",
+      name = "rules_java~~toolchains~remote_java_tools",
       urls = ["https://mirror.bazel.build/bazel_java_tools/releases/java/v11.5/java_tools-v11.5.zip", "https://github.com/bazelbuild/java_tools/releases/download/java_v11.5/java_tools-v11.5.zip"],
       sha256 = "b763ee80e5754e593fd6d5be6d7343f905bc8b73d661d36d842b024ca11b6793",
     )
diff --git a/site/en/external/module.md b/site/en/external/module.md
index 3403d9e857..75ace138d7 100644
--- a/site/en/external/module.md
+++ b/site/en/external/module.md
@@ -190,13 +190,6 @@ flexibility.
 
 ## Repository names and strict deps
 
-The [canonical name](/external/overview#canonical-repo-name) of a repo backing a
-module is `{{ "<var>" }}module_name{{ "</var>" }}~{{ "<var>" }}version{{
-"</var>" }}` (for example, `bazel_skylib~1.0.3`). For modules with a
-non-registry override, replace the `{{ "<var>" }}version{{ "</var>" }}` part
-with the string `override`. Note that the canonical name format is not an API
-you should depend on and is subject to change at any time.
-
 The [apparent name](/external/overview#apparent-repo-name) of a repo backing a
 module to its direct dependents defaults to its module name, unless the
 `repo_name` attribute of the [`bazel_dep`](/rules/lib/globals/module#bazel_dep)
@@ -204,5 +197,27 @@ directive says otherwise. Note that this means a module can only find its direct
 dependencies. This helps prevent accidental breakages due to changes in
 transitive dependencies.
 
+The [canonical name](/external/overview#canonical-repo-name) of a repo backing a
+module is either `{{ "<var>" }}module_name{{ "</var>" }}~{{ "<var>" }}version{{
+"</var>" }}` (for example, `bazel_skylib~1.0.3`) or `{{ "<var>" }}module_name{{
+"</var>" }}~` (for example, `bazel_features~`), depending on whether there are
+multiple versions of the module in the entire dependency graph (see
+[`multiple_version_override`](/rules/lib/globals/module#multiple_version_override)).
+Note that **the canonical name format** is not an API you should depend on and
+**is subject to change at any time**. Instead of hard-coding the canonical name,
+use a supported way to get it directly from Bazel:
+* In BUILD and `.bzl` files, use
+  [`Label.repo_name`](/rules/lib/builtins/Label#repo_name) on a `Label` instance
+  constructed from a label string given by the apparent name of the repo, e.g.,
+  `Label("@bazel_skylib").repo_name`.
+* When looking up runfiles, use
+  [`$(rlocationpath ...)`](https://bazel.build/reference/be/make-variables#predefined_label_variables)
+  or one of the runfiles libraries in
+  `@bazel_tools//tools/{bash,cpp,java}/runfiles` or, for a ruleset `rules_foo`,
+  in `@rules_foo//foo/runfiles`.
+* When interacting with Bazel from an external tool such as an IDE or language
+  server, use the `bazel mod dump_repo_mapping` command to get the mapping from
+  apparent names to canonical names for a given set of repositories.
+
 [Module extensions](/external/extension) can also introduce additional repos
 into the visible scope of a module.
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/AbridgedModule.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/AbridgedModule.java
index 97756f20d7..215d935c20 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/AbridgedModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/AbridgedModule.java
@@ -16,7 +16,6 @@
 package com.google.devtools.build.lib.bazel.bzlmod;
 
 import com.google.auto.value.AutoValue;
-import com.google.devtools.build.lib.cmdline.RepositoryName;
 
 /**
  * An abridged version of a {@link Module}, with a reduced set of information available, used for
@@ -30,10 +29,6 @@ public abstract class AbridgedModule {
 
   public abstract ModuleKey getKey();
 
-  public final RepositoryName getCanonicalRepoName() {
-    return getKey().getCanonicalRepoName();
-  }
-
   public static AbridgedModule from(Module module) {
     return new AutoValue_AbridgedModule(module.getName(), module.getVersion(), module.getKey());
   }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
index ce8d22920e..6ecf0be408 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
@@ -325,6 +325,7 @@ java_library(
     deps = [
         ":common",
         ":module_extension",
+        "//src/main/java/com/google/devtools/build/lib/cmdline",
         "//src/main/java/com/google/devtools/build/lib/skyframe:sky_functions",
         "//src/main/java/com/google/devtools/build/lib/skyframe/serialization/autocodec:serialization-constant",
         "//src/main/java/com/google/devtools/build/skyframe:skyframe-objects",
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunction.java
index 29f1a41621..b809961553 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunction.java
@@ -16,8 +16,12 @@
 package com.google.devtools.build.lib.bazel.bzlmod;
 
 import static com.google.common.base.Strings.nullToEmpty;
+import static com.google.common.collect.ImmutableBiMap.toImmutableBiMap;
 import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
+import static java.util.stream.Collectors.counting;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.toSet;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
@@ -31,6 +35,7 @@ import com.google.devtools.build.lib.bazel.bzlmod.ModuleFileValue.RootModuleFile
 import com.google.devtools.build.lib.bazel.repository.RepositoryOptions.LockfileMode;
 import com.google.devtools.build.lib.cmdline.LabelSyntaxException;
 import com.google.devtools.build.lib.cmdline.PackageIdentifier;
+import com.google.devtools.build.lib.cmdline.RepositoryMapping;
 import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.packages.LabelConverter;
 import com.google.devtools.build.lib.server.FailureDetails.ExternalDeps.Code;
@@ -44,6 +49,7 @@ import com.google.devtools.build.skyframe.SkyKey;
 import com.google.devtools.build.skyframe.SkyValue;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
@@ -113,13 +119,11 @@ public class BazelDepGraphFunction implements SkyFunction {
       depGraph = selectionResult.getResolvedDepGraph();
     }
 
-    ImmutableMap<RepositoryName, ModuleKey> canonicalRepoNameLookup =
-        depGraph.keySet().stream()
-            .collect(toImmutableMap(ModuleKey::getCanonicalRepoName, key -> key));
-
+    ImmutableBiMap<RepositoryName, ModuleKey> canonicalRepoNameLookup =
+        computeCanonicalRepoNameLookup(depGraph);
     ImmutableTable<ModuleExtensionId, ModuleKey, ModuleExtensionUsage> extensionUsagesById;
     try {
-      extensionUsagesById = getExtensionUsagesById(depGraph);
+      extensionUsagesById = getExtensionUsagesById(depGraph, canonicalRepoNameLookup.inverse());
     } catch (ExternalDepsException e) {
       throw new BazelDepGraphFunctionException(e, Transience.PERSISTENT);
     }
@@ -214,13 +218,23 @@ public class BazelDepGraphFunction implements SkyFunction {
   public static ImmutableTable<ModuleExtensionId, ModuleKey, ModuleExtensionUsage>
       getExtensionUsagesById(ImmutableMap<ModuleKey, Module> depGraph)
           throws ExternalDepsException {
+    return getExtensionUsagesById(depGraph, computeCanonicalRepoNameLookup(depGraph).inverse());
+  }
+
+  private static ImmutableTable<ModuleExtensionId, ModuleKey, ModuleExtensionUsage>
+      getExtensionUsagesById(
+          ImmutableMap<ModuleKey, Module> depGraph,
+          ImmutableMap<ModuleKey, RepositoryName> moduleKeyToRepositoryNames)
+          throws ExternalDepsException {
     ImmutableTable.Builder<ModuleExtensionId, ModuleKey, ModuleExtensionUsage>
         extensionUsagesTableBuilder = ImmutableTable.builder();
     for (Module module : depGraph.values()) {
+      RepositoryMapping repoMapping =
+          module.getRepoMappingWithBazelDepsOnly(moduleKeyToRepositoryNames);
       LabelConverter labelConverter =
           new LabelConverter(
-              PackageIdentifier.create(module.getCanonicalRepoName(), PathFragment.EMPTY_FRAGMENT),
-              module.getRepoMappingWithBazelDepsOnly());
+              PackageIdentifier.create(repoMapping.ownerRepo(), PathFragment.EMPTY_FRAGMENT),
+              module.getRepoMappingWithBazelDepsOnly(moduleKeyToRepositoryNames));
       for (ModuleExtensionUsage usage : module.getExtensionUsages()) {
         ModuleExtensionId moduleExtensionId;
         try {
@@ -249,6 +263,37 @@ public class BazelDepGraphFunction implements SkyFunction {
     return extensionUsagesTableBuilder.buildOrThrow();
   }
 
+  private static ImmutableBiMap<RepositoryName, ModuleKey> computeCanonicalRepoNameLookup(
+      ImmutableMap<ModuleKey, Module> depGraph) {
+    // Find modules with multiple versions in the dep graph. Currently, the only source of such
+    // modules is multiple_version_override.
+    Set<String> multipleVersionsModules =
+        depGraph.keySet().stream()
+            .collect(groupingBy(ModuleKey::getName, counting()))
+            .entrySet()
+            .stream()
+            .filter(entry -> entry.getValue() > 1)
+            .map(Entry::getKey)
+            .collect(toSet());
+
+    // If there is a unique version of this module in the entire dep graph, we elide the version
+    // from the canonical repository name. This has a number of benefits:
+    // * It prevents the output base from being polluted with repository directories corresponding
+    //   to outdated versions of modules, which can be large and would otherwise only be cleaned
+    //   up by the discouraged bazel clean --expunge.
+    // * It improves cache hit rates by ensuring that a module update doesn't e.g. cause the paths
+    //   of all toolchains provided by its extensions to change, which would result in widespread
+    //   cache misses on every update.
+    return depGraph.keySet().stream()
+        .collect(
+            toImmutableBiMap(
+                key ->
+                    multipleVersionsModules.contains(key.getName())
+                        ? key.getCanonicalRepoNameWithVersion()
+                        : key.getCanonicalRepoNameWithoutVersion(),
+                key -> key));
+  }
+
   private ImmutableBiMap<String, ModuleExtensionId> calculateUniqueNameForUsedExtensionId(
       ImmutableTable<ModuleExtensionId, ModuleKey, ModuleExtensionUsage> extensionUsagesById) {
     // Calculate a unique name for each used extension id with the following property that is
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphValue.java
index 4a7b597f49..1a5a9e1b0e 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphValue.java
@@ -18,6 +18,7 @@ package com.google.devtools.build.lib.bazel.bzlmod;
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableTable;
@@ -45,7 +46,7 @@ public abstract class BazelDepGraphValue implements SkyValue {
       ImmutableMap<ModuleExtensionId, String> extensionUniqueNames) {
     return new AutoValue_BazelDepGraphValue(
         depGraph,
-        canonicalRepoNameLookup,
+        ImmutableBiMap.copyOf(canonicalRepoNameLookup),
         abridgedModules,
         extensionUsagesTable,
         extensionUniqueNames);
@@ -67,7 +68,12 @@ public abstract class BazelDepGraphValue implements SkyValue {
 
     ImmutableMap<RepositoryName, ModuleKey> canonicalRepoNameLookup =
         emptyDepGraph.keySet().stream()
-            .collect(toImmutableMap(ModuleKey::getCanonicalRepoName, key -> key));
+            .collect(
+                toImmutableMap(
+                    // All modules in the empty dep graph (just the root module) have an empty
+                    // version, so the choice of including it in the canonical repo name does not
+                    // matter.
+                    ModuleKey::getCanonicalRepoNameWithoutVersion, key -> key));
 
     return BazelDepGraphValue.create(
         emptyDepGraph,
@@ -83,8 +89,8 @@ public abstract class BazelDepGraphValue implements SkyValue {
    */
   public abstract ImmutableMap<ModuleKey, Module> getDepGraph();
 
-  /** A mapping from a canonical repo name to the key of the module backing it. */
-  public abstract ImmutableMap<RepositoryName, ModuleKey> getCanonicalRepoNameLookup();
+  /** A mapping from a canonical repo name to the key of the module backing it and back. */
+  public abstract ImmutableBiMap<RepositoryName, ModuleKey> getCanonicalRepoNameLookup();
 
   /** All modules in the same order as {@link #getDepGraph}, but with limited information. */
   public abstract ImmutableList<AbridgedModule> getAbridgedModules();
@@ -124,7 +130,7 @@ public abstract class BazelDepGraphValue implements SkyValue {
     }
     return getDepGraph()
         .get(key)
-        .getRepoMappingWithBazelDepsOnly()
+        .getRepoMappingWithBazelDepsOnly(getCanonicalRepoNameLookup().inverse())
         .withAdditionalMappings(mapping.buildOrThrow());
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
index e8563e8f60..3ae71c57c6 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
@@ -37,7 +37,7 @@ import java.util.Map;
 @GenerateTypeAdapter
 public abstract class BazelLockFileValue implements SkyValue, Postable {
 
-  public static final int LOCK_FILE_VERSION = 3;
+  public static final int LOCK_FILE_VERSION = 4;
 
   @SerializationConstant public static final SkyKey KEY = () -> SkyFunctions.BAZEL_LOCK_FILE;
 
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorFunction.java
index ea36b034bb..e7bb90791b 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorFunction.java
@@ -82,7 +82,11 @@ public class BazelModuleInspectorFunction implements SkyFunction {
                         AugmentedModule::getName,
                         Collectors.mapping(AugmentedModule::getKey, toImmutableSet()))));
 
-    return BazelModuleInspectorValue.create(depGraph, modulesIndex, extensionToRepoInternalNames);
+    return BazelModuleInspectorValue.create(
+        depGraph,
+        modulesIndex,
+        extensionToRepoInternalNames,
+        depGraphValue.getCanonicalRepoNameLookup().inverse());
   }
 
   public static ImmutableMap<ModuleKey, AugmentedModule> computeAugmentedGraph(
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorValue.java
index ef7242dc9a..ceac3f425b 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleInspectorValue.java
@@ -21,6 +21,7 @@ import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedMap;
+import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.skyframe.SkyFunctions;
 import com.google.devtools.build.lib.skyframe.serialization.autocodec.SerializationConstant;
 import com.google.devtools.build.skyframe.SkyKey;
@@ -42,9 +43,10 @@ public abstract class BazelModuleInspectorValue implements SkyValue {
   public static BazelModuleInspectorValue create(
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
-      ImmutableSetMultimap<ModuleExtensionId, String> extensionToRepoInternalNames) {
+      ImmutableSetMultimap<ModuleExtensionId, String> extensionToRepoInternalNames,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames) {
     return new AutoValue_BazelModuleInspectorValue(
-        depGraph, modulesIndex, extensionToRepoInternalNames);
+        depGraph, modulesIndex, extensionToRepoInternalNames, moduleKeyToCanonicalNames);
   }
 
   /**
@@ -69,6 +71,9 @@ public abstract class BazelModuleInspectorValue implements SkyValue {
    */
   public abstract ImmutableSetMultimap<ModuleExtensionId, String> getExtensionToRepoInternalNames();
 
+  /** A mapping from a module key to the canonical repository name of the module repository. */
+  public abstract ImmutableMap<ModuleKey, RepositoryName> getModuleKeyToCanonicalNames();
+
   /**
    * A wrapper for {@link Module}, augmented with references to dependants (and also those who are
    * not used in the final dep graph).
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Module.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Module.java
index 36166367cb..132fd2c306 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Module.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Module.java
@@ -48,7 +48,8 @@ public abstract class Module extends ModuleBase {
    * Returns a {@link RepositoryMapping} with only Bazel module repos and no repos from module
    * extensions. For the full mapping, see {@link BazelDepGraphValue#getFullRepoMapping}.
    */
-  public final RepositoryMapping getRepoMappingWithBazelDepsOnly() {
+  public final RepositoryMapping getRepoMappingWithBazelDepsOnly(
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToRepositoryNames) {
     ImmutableMap.Builder<String, RepositoryName> mapping = ImmutableMap.builder();
     // If this is the root module, then the main repository should be visible as `@`.
     if (getKey().equals(ModuleKey.ROOT)) {
@@ -56,15 +57,16 @@ public abstract class Module extends ModuleBase {
     }
     // Every module should be able to reference itself as @<module repo name>.
     // If this is the root module, this perfectly falls into @<module repo name> => @
+    RepositoryName owner = moduleKeyToRepositoryNames.get(getKey());
     if (!getRepoName().isEmpty()) {
-      mapping.put(getRepoName(), getCanonicalRepoName());
+      mapping.put(getRepoName(), owner);
     }
     for (Map.Entry<String, ModuleKey> dep : getDeps().entrySet()) {
       // Special note: if `dep` is actually the root module, its ModuleKey would be ROOT whose
       // canonicalRepoName is the empty string. This perfectly maps to the main repo ("@").
-      mapping.put(dep.getKey(), dep.getValue().getCanonicalRepoName());
+      mapping.put(dep.getKey(), moduleKeyToRepositoryNames.get(dep.getValue()));
     }
-    return RepositoryMapping.create(mapping.buildOrThrow(), getCanonicalRepoName());
+    return RepositoryMapping.create(mapping.buildOrThrow(), owner);
   }
 
   /**
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleBase.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleBase.java
index 67e8d37588..958b55e64a 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleBase.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleBase.java
@@ -16,7 +16,6 @@
 package com.google.devtools.build.lib.bazel.bzlmod;
 
 import com.google.common.collect.ImmutableList;
-import com.google.devtools.build.lib.cmdline.RepositoryName;
 
 /** Represents a node in the external dependency graph. */
 abstract class ModuleBase {
@@ -49,10 +48,6 @@ abstract class ModuleBase {
    */
   public abstract ModuleKey getKey();
 
-  public final RepositoryName getCanonicalRepoName() {
-    return getKey().getCanonicalRepoName();
-  }
-
   /**
    * The name of the repository representing this module, as seen by the module itself. By default,
    * the name of the repo is the name of the module. This can be specified to ease migration for
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunction.java
index 084d8de95c..2134adf2fd 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunction.java
@@ -25,7 +25,9 @@ import com.google.common.collect.Maps;
 import com.google.devtools.build.lib.actions.FileValue;
 import com.google.devtools.build.lib.bazel.bzlmod.ModuleFileValue.NonRootModuleFileValue;
 import com.google.devtools.build.lib.bazel.bzlmod.ModuleFileValue.RootModuleFileValue;
+import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.cmdline.LabelConstants;
+import com.google.devtools.build.lib.cmdline.PackageIdentifier;
 import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.events.Event;
 import com.google.devtools.build.lib.events.ExtendedEventHandler;
@@ -43,6 +45,7 @@ import com.google.devtools.build.lib.skyframe.PrecomputedValue.Precomputed;
 import com.google.devtools.build.lib.util.Fingerprint;
 import com.google.devtools.build.lib.vfs.FileSystemUtils;
 import com.google.devtools.build.lib.vfs.Path;
+import com.google.devtools.build.lib.vfs.PathFragment;
 import com.google.devtools.build.lib.vfs.Root;
 import com.google.devtools.build.lib.vfs.RootedPath;
 import com.google.devtools.build.skyframe.SkyFunction;
@@ -305,7 +308,10 @@ public class ModuleFileFunction implements SkyFunction {
             .stream()
             .collect(
                 toImmutableMap(
-                    name -> ModuleKey.create(name, Version.EMPTY).getCanonicalRepoName(),
+                    // A module with a non-registry override always has a unique version across the
+                    // entire dep graph.
+                    name ->
+                        ModuleKey.create(name, Version.EMPTY).getCanonicalRepoNameWithoutVersion(),
                     name -> name));
     return RootModuleFileValue.create(
         module, moduleFileHash, overrides, nonRegistryOverrideCanonicalRepoNameLookup);
@@ -384,7 +390,9 @@ public class ModuleFileFunction implements SkyFunction {
     // If there is a non-registry override for this module, we need to fetch the corresponding repo
     // first and read the module file from there.
     if (override instanceof NonRegistryOverride) {
-      RepositoryName canonicalRepoName = key.getCanonicalRepoName();
+      // A module with a non-registry override always has a unique version across the entire dep
+      // graph.
+      RepositoryName canonicalRepoName = key.getCanonicalRepoNameWithoutVersion();
       RepositoryDirectoryValue repoDir =
           (RepositoryDirectoryValue) env.getValue(RepositoryDirectoryValue.key(canonicalRepoName));
       if (repoDir == null) {
@@ -397,10 +405,14 @@ public class ModuleFileFunction implements SkyFunction {
         return null;
       }
       GetModuleFileResult result = new GetModuleFileResult();
+      Label moduleFileLabel =
+          Label.createUnvalidated(
+              PackageIdentifier.create(canonicalRepoName, PathFragment.EMPTY_FRAGMENT),
+              LabelConstants.MODULE_DOT_BAZEL_FILE_NAME.getBaseName());
       result.moduleFile =
           ModuleFile.create(
               readModuleFile(moduleFilePath.asPath()),
-              key.moduleFileLabel().getUnambiguousCanonicalForm());
+              moduleFileLabel.getUnambiguousCanonicalForm());
       return result;
     }
 
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleKey.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleKey.java
index 8e52311d9f..64663a2279 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleKey.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleKey.java
@@ -16,13 +16,10 @@
 package com.google.devtools.build.lib.bazel.bzlmod;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableMap;
-import com.google.devtools.build.lib.cmdline.Label;
-import com.google.devtools.build.lib.cmdline.LabelConstants;
-import com.google.devtools.build.lib.cmdline.PackageIdentifier;
 import com.google.devtools.build.lib.cmdline.RepositoryName;
-import com.google.devtools.build.lib.vfs.PathFragment;
 import java.util.Comparator;
 import java.util.List;
 
@@ -34,8 +31,9 @@ public abstract class ModuleKey {
    * A mapping from module name to repository name for certain special "well-known" modules.
    *
    * <p>The repository name of certain modules are required to be exact strings (instead of the
-   * normal format seen in {@link #getCanonicalRepoName()}) due to backwards compatibility reasons.
-   * For example, bazel_tools must be known as "@bazel_tools" for WORKSPACE repos to work correctly.
+   * normal format seen in {@link #getCanonicalRepoName(boolean)}) due to backwards compatibility
+   * reasons. For example, bazel_tools must be known as "@bazel_tools" for WORKSPACE repos to work
+   * correctly.
    */
   // Keep in sync with src/tools/bzlmod/utils.bzl.
   private static final ImmutableMap<String, RepositoryName> WELL_KNOWN_MODULES =
@@ -67,13 +65,6 @@ public abstract class ModuleKey {
   /** The version of the module. Must be empty iff the module has a {@link NonRegistryOverride}. */
   public abstract Version getVersion();
 
-  /** Returns the label that points to the MODULE.bazel file of this module. */
-  public final Label moduleFileLabel() {
-    return Label.createUnvalidated(
-        PackageIdentifier.create(getCanonicalRepoName(), PathFragment.EMPTY_FRAGMENT),
-        LabelConstants.MODULE_DOT_BAZEL_FILE_NAME.getBaseName());
-  }
-
   @Override
   public final String toString() {
     if (this.equals(ROOT)) {
@@ -82,16 +73,56 @@ public abstract class ModuleKey {
     return getName() + "@" + (getVersion().isEmpty() ? "_" : getVersion().toString());
   }
 
-  /** Returns the canonical name of the repo backing this module. */
-  public RepositoryName getCanonicalRepoName() {
+  /**
+   * Returns the canonical name of the repo backing this module, including its version. This name is
+   * always guaranteed to be unique.
+   *
+   * <p>This method must not be called if the module has a {@link NonRegistryOverride}.
+   */
+  public RepositoryName getCanonicalRepoNameWithVersion() {
+    return getCanonicalRepoName(/* includeVersion= */ true);
+  }
+
+  /**
+   * Returns the canonical name of the repo backing this module, excluding its version. This name is
+   * only guaranteed to be unique when there is a single version of the module in the entire dep
+   * graph.
+   */
+  public RepositoryName getCanonicalRepoNameWithoutVersion() {
+    return getCanonicalRepoName(/* includeVersion= */ false);
+  }
+
+  private RepositoryName getCanonicalRepoName(boolean includeVersion) {
     if (WELL_KNOWN_MODULES.containsKey(getName())) {
       return WELL_KNOWN_MODULES.get(getName());
     }
     if (ROOT.equals(this)) {
       return RepositoryName.MAIN;
     }
-    return RepositoryName.createUnvalidated(
-        String.format("%s~%s", getName(), getVersion().isEmpty() ? "override" : getVersion()));
+    String suffix;
+    if (includeVersion) {
+      // getVersion().isEmpty() is true only for modules with non-registry overrides, which enforce
+      // that there is a single version of the module in the dep graph.
+      Preconditions.checkState(!getVersion().isEmpty());
+      suffix = getVersion().toString();
+    } else {
+      // This results in canonical repository names such as `rules_foo~` for the module `rules_foo`.
+      // This particular format is chosen since:
+      // * The tilde ensures that canonical and apparent repository names can be distinguished even
+      //   in contexts where users don't rely on `@` vs. `@@` to distinguish between them. For
+      //   example, this means that the repo mapping as applied by runfiles libraries is idempotent.
+      // * Appending a tilde even in the case of a unique version means that module repository
+      //   names always contain the same number of tilde-separated components, which improves
+      //   compatibility with existing logic based on the `rules_foo~1.2.3` format.
+      // * By making it so that the module name and the canonical repository name of a module are
+      //   never identical, even when using an override, we introduce "grease" that intentionally
+      //   tickles bugs in code that doesn't properly distinguish between the two, e.g., by not
+      //   applying repo mappings. Otherwise, these bugs could go unnoticed in BCR test modules and
+      //   would only be discovered when used with a `multiple_version_override`, which is very
+      //   rarely used.
+      suffix = "";
+    }
+    return RepositoryName.createUnvalidated(String.format("%s~%s", getName(), suffix));
   }
 
   public static ModuleKey fromString(String s) throws Version.ParseException {
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
index 45abfdef90..5a68996357 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
@@ -21,7 +21,6 @@ import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.collect.ImmutableSet.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -607,15 +606,13 @@ public class SingleExtensionEvalFunction implements SkyFunction {
           Transience.PERSISTENT);
     }
     ModuleKey moduleKey = Iterables.getOnlyElement(usagesValue.getExtensionUsages().keySet());
-    Preconditions.checkState(moduleKey.moduleFileLabel().equals(extensionId.getBzlFileLabel()));
     ImmutableList<Tag> tags =
         Iterables.getOnlyElement(usagesValue.getExtensionUsages().values()).getTags();
     RepositoryMapping repoMapping = usagesValue.getRepoMappings().get(moduleKey);
 
     // Each tag of this usage defines a repo. The name of the tag is of the form
     // "<bzl_file_label>%<rule_name>". Collect the .bzl files referenced and load them.
-    Label.RepoContext repoContext =
-        Label.RepoContext.of(moduleKey.getCanonicalRepoName(), repoMapping);
+    Label.RepoContext repoContext = Label.RepoContext.of(repoMapping.ownerRepo(), repoMapping);
     ArrayList<InnateExtensionRepo.Builder> repoBuilders = new ArrayList<>(tags.size());
     for (Tag tag : tags) {
       Iterator<String> parts = Splitter.on('%').split(tag.getTagName()).iterator();
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModule.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModule.java
index af13cff890..90b28b87ed 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModule.java
@@ -111,7 +111,7 @@ public class StarlarkBazelModule implements StarlarkValue {
       throws ExternalDepsException {
     LabelConverter labelConverter =
         new LabelConverter(
-            PackageIdentifier.create(module.getCanonicalRepoName(), PathFragment.EMPTY_FRAGMENT),
+            PackageIdentifier.create(repoMapping.ownerRepo(), PathFragment.EMPTY_FRAGMENT),
             repoMapping);
     ImmutableList<Tag> tags = usage == null ? ImmutableList.of() : usage.getTags();
     HashMap<String, ArrayList<TypeCheckedTag>> typeCheckedTags = new HashMap<>();
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArg.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArg.java
index b92d5f5eed..720846f92e 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArg.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArg.java
@@ -27,6 +27,7 @@ import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.cmdline.Label.RepoContext;
 import com.google.devtools.build.lib.cmdline.LabelSyntaxException;
 import com.google.devtools.build.lib.cmdline.RepositoryMapping;
+import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.server.FailureDetails.ModCommand.Code;
 import com.google.devtools.common.options.Converter;
 import com.google.devtools.common.options.Converters.CommaSeparatedNonEmptyOptionListConverter;
@@ -56,6 +57,7 @@ public abstract class ExtensionArg {
   public final ModuleExtensionId resolveToExtensionId(
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
       ImmutableBiMap<String, ModuleKey> baseModuleDeps,
       ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps)
       throws InvalidArgumentException {
@@ -64,6 +66,7 @@ public abstract class ExtensionArg {
             .resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ false,
@@ -82,9 +85,9 @@ public abstract class ExtensionArg {
           Label.parseWithRepoContext(
               repoRelativeBzlLabel(),
               RepoContext.of(
-                  key.getCanonicalRepoName(),
+                  moduleKeyToCanonicalNames.get(key),
                   // Intentionally allow no repo mapping here: it's a repo-relative label!
-                  RepositoryMapping.create(ImmutableMap.of(), key.getCanonicalRepoName())));
+                  RepositoryMapping.create(ImmutableMap.of(), moduleKeyToCanonicalNames.get(key))));
       // TODO(wyv): support isolated extension usages?
       return ModuleExtensionId.create(label, extensionName(), Optional.empty());
     } catch (LabelSyntaxException e) {
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArg.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArg.java
index 9490f9bf5c..359f6204bb 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArg.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArg.java
@@ -47,6 +47,7 @@ public interface ModuleArg {
   ImmutableSet<ModuleKey> resolveToModuleKeys(
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
       ImmutableBiMap<String, ModuleKey> baseModuleDeps,
       ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
       boolean includeUnused,
@@ -57,6 +58,7 @@ public interface ModuleArg {
   ImmutableMap<String, RepositoryName> resolveToRepoNames(
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
       RepositoryMapping mapping)
       throws InvalidArgumentException;
 
@@ -116,6 +118,7 @@ public interface ModuleArg {
     public final ImmutableSet<ModuleKey> resolveToModuleKeys(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         ImmutableBiMap<String, ModuleKey> baseModuleDeps,
         ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
         boolean includeUnused,
@@ -129,11 +132,12 @@ public interface ModuleArg {
     public ImmutableMap<String, RepositoryName> resolveToRepoNames(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         RepositoryMapping mapping)
         throws InvalidArgumentException {
       throwIfNonexistent(
           modulesIndex, depGraph, /* includeUnused= */ false, /* warnUnused= */ false);
-      return ImmutableMap.of(moduleKey().toString(), moduleKey().getCanonicalRepoName());
+      return ImmutableMap.of(moduleKey().toString(), moduleKeyToCanonicalNames.get(moduleKey()));
     }
 
     @Override
@@ -187,6 +191,7 @@ public interface ModuleArg {
     public ImmutableSet<ModuleKey> resolveToModuleKeys(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         ImmutableBiMap<String, ModuleKey> baseModuleDeps,
         ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
         boolean includeUnused,
@@ -199,12 +204,13 @@ public interface ModuleArg {
     public ImmutableMap<String, RepositoryName> resolveToRepoNames(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         RepositoryMapping mapping)
         throws InvalidArgumentException {
       return resolveInternal(
               modulesIndex, depGraph, /* includeUnused= */ false, /* warnUnused= */ false)
           .stream()
-          .collect(toImmutableMap(ModuleKey::toString, ModuleKey::getCanonicalRepoName));
+          .collect(toImmutableMap(ModuleKey::toString, moduleKeyToCanonicalNames::get));
     }
 
     @Override
@@ -230,6 +236,7 @@ public interface ModuleArg {
     public ImmutableSet<ModuleKey> resolveToModuleKeys(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         ImmutableBiMap<String, ModuleKey> baseModuleDeps,
         ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
         boolean includeUnused,
@@ -258,6 +265,7 @@ public interface ModuleArg {
     public ImmutableMap<String, RepositoryName> resolveToRepoNames(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         RepositoryMapping mapping)
         throws InvalidArgumentException {
       RepositoryName repoName = mapping.get(name());
@@ -289,6 +297,7 @@ public interface ModuleArg {
     public ImmutableSet<ModuleKey> resolveToModuleKeys(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         ImmutableBiMap<String, ModuleKey> baseModuleDeps,
         ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
         boolean includeUnused,
@@ -296,7 +305,7 @@ public interface ModuleArg {
         throws InvalidArgumentException {
       Optional<AugmentedModule> mod =
           depGraph.values().stream()
-              .filter(m -> m.getKey().getCanonicalRepoName().equals(repoName()))
+              .filter(m -> moduleKeyToCanonicalNames.get(m.getKey()).equals(repoName()))
               .findAny();
       if (mod.isPresent() && !includeUnused && warnUnused && !mod.get().isUsed()) {
         // Warn the user when unused modules are allowed and the specified version exists, but the
@@ -324,10 +333,11 @@ public interface ModuleArg {
     public ImmutableMap<String, RepositoryName> resolveToRepoNames(
         ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
         ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+        ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
         RepositoryMapping mapping)
         throws InvalidArgumentException {
       if (depGraph.values().stream()
-          .filter(m -> m.getKey().getCanonicalRepoName().equals(repoName()) && m.isUsed())
+          .filter(m -> moduleKeyToCanonicalNames.get(m.getKey()).equals(repoName()) && m.isUsed())
           .findAny()
           .isEmpty()) {
         throw new InvalidArgumentException(
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java b/src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java
index 47ad7e198e..611764b553 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java
@@ -295,6 +295,7 @@ public final class ModCommand implements BlazeCommand {
           modOptions.baseModule.resolveToModuleKeys(
               moduleInspector.getModulesIndex(),
               moduleInspector.getDepGraph(),
+              moduleInspector.getModuleKeyToCanonicalNames(),
               rootModule.getDeps(),
               rootModule.getUnusedDeps(),
               false,
@@ -346,6 +347,7 @@ public final class ModCommand implements BlazeCommand {
                       .resolveToRepoNames(
                           moduleInspector.getModulesIndex(),
                           moduleInspector.getDepGraph(),
+                          moduleInspector.getModuleKeyToCanonicalNames(),
                           baseModuleMapping));
             } catch (InvalidArgumentException | OptionsParsingException e) {
               throw new InvalidArgumentException(
@@ -369,6 +371,7 @@ public final class ModCommand implements BlazeCommand {
                       .resolveToExtensionId(
                           moduleInspector.getModulesIndex(),
                           moduleInspector.getDepGraph(),
+                          moduleInspector.getModuleKeyToCanonicalNames(),
                           baseModule.getDeps(),
                           baseModule.getUnusedDeps()));
             } catch (InvalidArgumentException | OptionsParsingException e) {
@@ -390,6 +393,7 @@ public final class ModCommand implements BlazeCommand {
                       .resolveToModuleKeys(
                           moduleInspector.getModulesIndex(),
                           moduleInspector.getDepGraph(),
+                          moduleInspector.getModuleKeyToCanonicalNames(),
                           baseModule.getDeps(),
                           baseModule.getUnusedDeps(),
                           modOptions.includeUnused,
@@ -414,6 +418,7 @@ public final class ModCommand implements BlazeCommand {
               modOptions.modulesFrom,
               moduleInspector.getModulesIndex(),
               moduleInspector.getDepGraph(),
+              moduleInspector.getModuleKeyToCanonicalNames(),
               baseModule.getDeps(),
               baseModule.getUnusedDeps(),
               modOptions.includeUnused);
@@ -430,6 +435,7 @@ public final class ModCommand implements BlazeCommand {
               modOptions.extensionUsages,
               moduleInspector.getModulesIndex(),
               moduleInspector.getDepGraph(),
+              moduleInspector.getModuleKeyToCanonicalNames(),
               baseModule.getDeps(),
               baseModule.getUnusedDeps(),
               modOptions.includeUnused);
@@ -457,6 +463,7 @@ public final class ModCommand implements BlazeCommand {
                           modOptions.extensionFilter,
                           moduleInspector.getModulesIndex(),
                           moduleInspector.getDepGraph(),
+                          moduleInspector.getModuleKeyToCanonicalNames(),
                           baseModule.getDeps(),
                           baseModule.getUnusedDeps())));
         } catch (InvalidArgumentException e) {
@@ -656,6 +663,7 @@ public final class ModCommand implements BlazeCommand {
       ImmutableList<ModuleArg> argList,
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
       ImmutableBiMap<String, ModuleKey> baseModuleDeps,
       ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps,
       boolean includeUnused)
@@ -664,7 +672,13 @@ public final class ModCommand implements BlazeCommand {
     for (ModuleArg moduleArg : argList) {
       allTargetKeys.addAll(
           moduleArg.resolveToModuleKeys(
-              modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps, includeUnused, true));
+              modulesIndex,
+              depGraph,
+              moduleKeyToCanonicalNames,
+              baseModuleDeps,
+              baseModuleUnusedDeps,
+              includeUnused,
+              true));
     }
     return allTargetKeys.build();
   }
@@ -673,6 +687,7 @@ public final class ModCommand implements BlazeCommand {
       ImmutableList<ExtensionArg> args,
       ImmutableMap<String, ImmutableSet<ModuleKey>> modulesIndex,
       ImmutableMap<ModuleKey, AugmentedModule> depGraph,
+      ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames,
       ImmutableBiMap<String, ModuleKey> baseModuleDeps,
       ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps)
       throws InvalidArgumentException {
@@ -680,7 +695,12 @@ public final class ModCommand implements BlazeCommand {
         new ImmutableSortedSet.Builder<>(ModuleExtensionId.LEXICOGRAPHIC_COMPARATOR);
     for (ExtensionArg arg : args) {
       extensionsBuilder.add(
-          arg.resolveToExtensionId(modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps));
+          arg.resolveToExtensionId(
+              modulesIndex,
+              depGraph,
+              moduleKeyToCanonicalNames,
+              baseModuleDeps,
+              baseModuleUnusedDeps));
     }
     return extensionsBuilder.build();
   }
diff --git a/src/main/java/com/google/devtools/build/lib/cmdline/RepositoryMapping.java b/src/main/java/com/google/devtools/build/lib/cmdline/RepositoryMapping.java
index b15bdadc61..6bffe81b4b 100644
--- a/src/main/java/com/google/devtools/build/lib/cmdline/RepositoryMapping.java
+++ b/src/main/java/com/google/devtools/build/lib/cmdline/RepositoryMapping.java
@@ -77,6 +77,11 @@ public class RepositoryMapping {
     return Objects.hashCode(entries, ownerRepo);
   }
 
+  @Override
+  public String toString() {
+    return String.format("RepositoryMapping{entries=%s, ownerRepo=%s}", entries, ownerRepo);
+  }
+
   public static RepositoryMapping create(
       Map<String, RepositoryName> entries, RepositoryName ownerRepo) {
     return new RepositoryMapping(
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunction.java b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunction.java
index 9aaa1ecf5b..67d6df879c 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunction.java
@@ -197,7 +197,7 @@ public class RegisteredExecutionPlatformsFunction implements SkyFunction {
       TargetPattern.Parser parser =
           new TargetPattern.Parser(
               PathFragment.EMPTY_FRAGMENT,
-              module.getCanonicalRepoName(),
+              bazelDepGraphValue.getCanonicalRepoNameLookup().inverse().get(module.getKey()),
               bazelDepGraphValue.getFullRepoMapping(module.getKey()));
       for (String pattern : module.getExecutionPlatformsToRegister()) {
         try {
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunction.java b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunction.java
index 50ea6cdb16..af61c4304e 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunction.java
@@ -199,7 +199,7 @@ public class RegisteredToolchainsFunction implements SkyFunction {
       TargetPattern.Parser parser =
           new TargetPattern.Parser(
               PathFragment.EMPTY_FRAGMENT,
-              module.getCanonicalRepoName(),
+              bazelDepGraphValue.getCanonicalRepoNameLookup().inverse().get(module.getKey()),
               bazelDepGraphValue.getFullRepoMapping(module.getKey()));
       for (String pattern : module.getToolchainsToRegister()) {
         try {
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/RunfilesRepoMappingManifestTest.java b/src/test/java/com/google/devtools/build/lib/analysis/RunfilesRepoMappingManifestTest.java
index 523d6fec46..669352d0cd 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/RunfilesRepoMappingManifestTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/RunfilesRepoMappingManifestTest.java
@@ -151,13 +151,13 @@ public class RunfilesRepoMappingManifestTest extends BuildViewTestCase {
         .containsExactly(
             ",aaa," + getRuleClassProvider().getRunfilesPrefix(),
             ",aaa_ws," + getRuleClassProvider().getRunfilesPrefix(),
-            ",bbb,bbb~1.0",
-            "bbb~1.0,bbb,bbb~1.0",
-            "bbb~1.0,ddd,ddd~2.0",
-            "ddd~2.0,ddd,ddd~2.0")
+            ",bbb,bbb~",
+            "bbb~,bbb,bbb~",
+            "bbb~,ddd,ddd~",
+            "ddd~,ddd,ddd~")
         .inOrder();
-    assertThat(getRepoMappingManifestForTarget("@@ccc~2.0//:ccc"))
-        .containsExactly("ccc~2.0,ccc,ccc~2.0", "ccc~2.0,ddd,ddd~2.0", "ddd~2.0,ddd,ddd~2.0")
+    assertThat(getRepoMappingManifestForTarget("@@ccc~//:ccc"))
+        .containsExactly("ccc~,ccc,ccc~", "ccc~,ddd,ddd~", "ddd~,ddd,ddd~")
         .inOrder();
   }
 
@@ -220,8 +220,8 @@ public class RunfilesRepoMappingManifestTest extends BuildViewTestCase {
     assertThat(getRepoMappingManifestForTarget("//:tooled"))
         .containsExactly(
             ",main," + getRuleClassProvider().getRunfilesPrefix(),
-            "bare_rule~1.0,bare_rule,bare_rule~1.0",
-            "tooled_rule~1.0,bare_rule,bare_rule~1.0")
+            "bare_rule~,bare_rule,bare_rule~",
+            "tooled_rule~,bare_rule,bare_rule~")
         .inOrder();
   }
 
@@ -361,7 +361,7 @@ public class RunfilesRepoMappingManifestTest extends BuildViewTestCase {
         "bare_binary(name='ddd')");
     invalidatePackages();
 
-    RunfilesSupport runfilesSupport = getRunfilesSupport("@aaa~1.0//:aaa");
+    RunfilesSupport runfilesSupport = getRunfilesSupport("@aaa~//:aaa");
     ImmutableList<String> runfilesPaths =
         runfilesSupport
             .getRunfiles()
@@ -372,21 +372,21 @@ public class RunfilesRepoMappingManifestTest extends BuildViewTestCase {
             .collect(toImmutableList());
     assertThat(runfilesPaths)
         .containsAtLeast(
-            "aaa~1.0/aaa",
+            "aaa~/aaa",
             getRuleClassProvider().getRunfilesPrefix() + "/path/to/pkg/symlink",
-            "symlinks~1.0/path/to/pkg/root_symlink",
+            "symlinks~/path/to/pkg/root_symlink",
             "_repo_mapping");
 
-    assertThat(getRepoMappingManifestForTarget("@aaa~1.0//:aaa"))
+    assertThat(getRepoMappingManifestForTarget("@aaa~//:aaa"))
         .containsExactly(
-            // @aaa~1.0 contributes the top-level executable to runfiles.
-            "aaa~1.0,aaa,aaa~1.0",
+            // @aaa~ contributes the top-level executable to runfiles.
+            "aaa~,aaa,aaa~",
             // The symlink is staged under the main repository's runfiles directory and aaa has a
             // repo mapping entry for it.
-            "aaa~1.0,my_module," + getRuleClassProvider().getRunfilesPrefix(),
-            // @symlinks~1.0 appears as the first segment of a root symlink.
-            "aaa~1.0,symlinks,symlinks~1.0",
-            "symlinks~1.0,symlinks,symlinks~1.0")
+            "aaa~,my_module," + getRuleClassProvider().getRunfilesPrefix(),
+            // @symlinks~ appears as the first segment of a root symlink.
+            "aaa~,symlinks,symlinks~",
+            "symlinks~,symlinks,symlinks~")
         .inOrder();
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
index 31aacbcbe3..d7aa55ea13 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
@@ -196,9 +196,9 @@ public class BazelDepGraphFunctionTest extends FoundationTestCase {
             createModuleKey("dep", "1.0"),
             RepositoryName.create("dep~2.0"),
             createModuleKey("dep", "2.0"),
-            RepositoryName.create("rules_cc~1.0"),
+            RepositoryName.create("rules_cc~"),
             createModuleKey("rules_cc", "1.0"),
-            RepositoryName.create("rules_java~override"),
+            RepositoryName.create("rules_java~"),
             createModuleKey("rules_java", ""));
     assertThat(value.getAbridgedModules())
         .containsExactlyElementsIn(
@@ -263,16 +263,16 @@ public class BazelDepGraphFunctionTest extends FoundationTestCase {
 
     ModuleExtensionId maven =
         ModuleExtensionId.create(
-            Label.parseCanonical("@@rules_jvm_external~1.0//:defs.bzl"), "maven", Optional.empty());
+            Label.parseCanonical("@@rules_jvm_external~//:defs.bzl"), "maven", Optional.empty());
     ModuleExtensionId pip =
         ModuleExtensionId.create(
-            Label.parseCanonical("@@rules_python~2.0//:defs.bzl"), "pip", Optional.empty());
+            Label.parseCanonical("@@rules_python~//:defs.bzl"), "pip", Optional.empty());
     ModuleExtensionId myext =
         ModuleExtensionId.create(
-            Label.parseCanonical("@@dep~2.0//:defs.bzl"), "myext", Optional.empty());
+            Label.parseCanonical("@@dep~//:defs.bzl"), "myext", Optional.empty());
     ModuleExtensionId myext2 =
         ModuleExtensionId.create(
-            Label.parseCanonical("@@dep~2.0//incredible:conflict.bzl"), "myext", Optional.empty());
+            Label.parseCanonical("@@dep~//incredible:conflict.bzl"), "myext", Optional.empty());
 
     resolutionFunctionMock.setDepGraph(depGraph);
     EvaluationResult<BazelDepGraphValue> result =
@@ -296,10 +296,10 @@ public class BazelDepGraphFunctionTest extends FoundationTestCase {
 
     assertThat(value.getExtensionUniqueNames())
         .containsExactly(
-            maven, "rules_jvm_external~1.0~maven",
-            pip, "rules_python~2.0~pip",
-            myext, "dep~2.0~myext",
-            myext2, "dep~2.0~myext2");
+            maven, "rules_jvm_external~~maven",
+            pip, "rules_python~~pip",
+            myext, "dep~~myext",
+            myext2, "dep~~myext2");
 
     assertThat(value.getFullRepoMapping(ModuleKey.ROOT))
         .isEqualTo(
@@ -310,27 +310,27 @@ public class BazelDepGraphFunctionTest extends FoundationTestCase {
                 "root",
                 "",
                 "rje",
-                "rules_jvm_external~1.0",
+                "rules_jvm_external~",
                 "rpy",
-                "rules_python~2.0",
+                "rules_python~",
                 "av",
-                "rules_jvm_external~1.0~maven~autovalue",
+                "rules_jvm_external~~maven~autovalue",
                 "numpy",
-                "rules_python~2.0~pip~numpy"));
+                "rules_python~~pip~numpy"));
     assertThat(value.getFullRepoMapping(depKey))
         .isEqualTo(
             createRepositoryMapping(
                 depKey,
                 "dep",
-                "dep~2.0",
+                "dep~",
                 "rules_python",
-                "rules_python~2.0",
+                "rules_python~",
                 "np",
-                "rules_python~2.0~pip~numpy",
+                "rules_python~~pip~numpy",
                 "oneext",
-                "dep~2.0~myext~myext",
+                "dep~~myext~myext",
                 "twoext",
-                "dep~2.0~myext2~myext"));
+                "dep~~myext2~myext"));
   }
 
   @Test
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodRepoRuleFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodRepoRuleFunctionTest.java
index 010b56d916..6ecd28bf1e 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodRepoRuleFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodRepoRuleFunctionTest.java
@@ -167,7 +167,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
             .addModule(createModuleKey("ccc", "2.0"), "module(name='ccc', version='2.0')");
     ModuleFileFunction.REGISTRIES.set(differencer, ImmutableList.of(registry.getUrl()));
 
-    RepositoryName repo = RepositoryName.create("ccc~2.0");
+    RepositoryName repo = RepositoryName.create("ccc~");
     EvaluationResult<BzlmodRepoRuleValue> result =
         evaluator.evaluate(ImmutableList.of(BzlmodRepoRuleValue.key(repo)), evaluationContext);
     if (result.hasError()) {
@@ -178,7 +178,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
 
     assertThat(repoRule.getRuleClassObject().isStarlark()).isFalse();
     assertThat(repoRule.getRuleClass()).isEqualTo("local_repository");
-    assertThat(repoRule.getName()).isEqualTo("ccc~2.0");
+    assertThat(repoRule.getName()).isEqualTo("ccc~");
     assertThat(repoRule.getAttr("path", Type.STRING)).isEqualTo("/usr/local/modules/ccc~2.0");
   }
 
@@ -198,7 +198,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
             .addModule(createModuleKey("ccc", "2.0"), "module(name='ccc', version='2.0')");
     ModuleFileFunction.REGISTRIES.set(differencer, ImmutableList.of(registry.getUrl()));
 
-    RepositoryName repo = RepositoryName.create("ccc~override");
+    RepositoryName repo = RepositoryName.create("ccc~");
     EvaluationResult<BzlmodRepoRuleValue> result =
         evaluator.evaluate(ImmutableList.of(BzlmodRepoRuleValue.key(repo)), evaluationContext);
     if (result.hasError()) {
@@ -209,7 +209,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
 
     assertThat(repoRule.getRuleClassObject().isStarlark()).isFalse();
     assertThat(repoRule.getRuleClass()).isEqualTo("local_repository");
-    assertThat(repoRule.getName()).isEqualTo("ccc~override");
+    assertThat(repoRule.getName()).isEqualTo("ccc~");
     assertThat(repoRule.getAttr("path", Type.STRING)).isEqualTo("/foo/bar/C");
   }
 
@@ -231,7 +231,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
             .addModule(createModuleKey("ccc", "3.0"), "module(name='ccc', version='3.0')");
     ModuleFileFunction.REGISTRIES.set(differencer, ImmutableList.of(registry.getUrl()));
 
-    RepositoryName repo = RepositoryName.create("ccc~3.0");
+    RepositoryName repo = RepositoryName.create("ccc~");
     EvaluationResult<BzlmodRepoRuleValue> result =
         evaluator.evaluate(ImmutableList.of(BzlmodRepoRuleValue.key(repo)), evaluationContext);
     if (result.hasError()) {
@@ -242,7 +242,7 @@ public final class BzlmodRepoRuleFunctionTest extends FoundationTestCase {
 
     assertThat(repoRule.getRuleClassObject().isStarlark()).isFalse();
     assertThat(repoRule.getRuleClass()).isEqualTo("local_repository");
-    assertThat(repoRule.getName()).isEqualTo("ccc~3.0");
+    assertThat(repoRule.getName()).isEqualTo("ccc~");
     assertThat(repoRule.getAttr("path", Type.STRING)).isEqualTo("/usr/local/modules/ccc~3.0");
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodTestUtil.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodTestUtil.java
index 17dd5a4f5f..d27f684d94 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodTestUtil.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BzlmodTestUtil.java
@@ -306,7 +306,8 @@ public final class BzlmodTestUtil {
     for (int i = 0; i < names.length; i += 2) {
       mappingBuilder.put(names[i], RepositoryName.createUnvalidated(names[i + 1]));
     }
-    return RepositoryMapping.create(mappingBuilder.buildOrThrow(), key.getCanonicalRepoName());
+    return RepositoryMapping.create(
+        mappingBuilder.buildOrThrow(), key.getCanonicalRepoNameWithoutVersion());
   }
 
   public static TagClass createTagClass(Attribute... attrs) {
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/FakeRegistry.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/FakeRegistry.java
index 23561e6b49..eae5c80b9b 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/FakeRegistry.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/FakeRegistry.java
@@ -80,7 +80,8 @@ public class FakeRegistry implements Registry {
         .setRuleClassName("local_repository")
         .setAttributes(
             AttributeValues.create(
-                ImmutableMap.of("path", rootPath + "/" + key.getCanonicalRepoName().getName())))
+                ImmutableMap.of(
+                    "path", rootPath + "/" + key.getCanonicalRepoNameWithVersion().getName())))
         .build();
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
index c2916c1efc..f72ca1d308 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
@@ -669,7 +669,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
     ModuleFileFunction.IGNORE_DEV_DEPS.set(differencer, true);
 
     SkyKey skyKey =
-        BzlLoadValue.keyForBuild(Label.parseCanonical("@@ext~1.0~ext~ext_repo//:data.bzl"));
+        BzlLoadValue.keyForBuild(Label.parseCanonical("@@ext~~ext~ext_repo//:data.bzl"));
     EvaluationResult<BzlLoadValue> result =
         evaluator.evaluate(ImmutableList.of(skyKey), evaluationContext);
     if (result.hasError()) {
@@ -766,7 +766,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
     assertThat(result.get(skyKey).getModule().getGlobal("isolated_dev_data"))
         .isEqualTo("root@1.0 (root): root_isolated_dev\n");
 
-    skyKey = BzlLoadValue.keyForBuild(Label.parseCanonical("@foo~1.0//:data.bzl"));
+    skyKey = BzlLoadValue.keyForBuild(Label.parseCanonical("@foo~//:data.bzl"));
     result = evaluator.evaluate(ImmutableList.of(skyKey), evaluationContext);
     if (result.hasError()) {
       throw result.getError().getException();
@@ -1427,7 +1427,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
     scratch.file(
         workspaceRoot.getRelative("defs.bzl").getPathString(),
         "load('@data_repo//:defs.bzl','data_repo')",
-        "load('@@ext~1.0~ext~candy//:data.bzl', candy='data')",
+        "load('@@ext~~ext~candy//:data.bzl', candy='data')",
         "load('@exposed_candy//:data.bzl', exposed_candy='data')",
         "def _ext_impl(ctx):",
         "  data_str = exposed_candy + ' (and ' + candy + ')'",
@@ -1974,7 +1974,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
     assertThat(result.getError().getException())
         .hasMessageThat()
         .isEqualTo(
-            "module extension \"ext\" from \"@@ext~1.0//:defs.bzl\" does not generate repository "
+            "module extension \"ext\" from \"@@ext~//:defs.bzl\" does not generate repository "
                 + "\"invalid_dep\", yet it is imported as \"invalid_dep\" in the usage at "
                 + "/ws/MODULE.bazel:3:20");
 
@@ -2060,7 +2060,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
     assertThat(result.getError().getException())
         .hasMessageThat()
         .isEqualTo(
-            "module extension \"ext\" from \"@@ext~1.0//:defs.bzl\" does not generate repository "
+            "module extension \"ext\" from \"@@ext~//:defs.bzl\" does not generate repository "
                 + "\"invalid_dep\", yet it is imported as \"invalid_dep\" in the usage at "
                 + "/ws/MODULE.bazel:3:20");
 
@@ -2131,7 +2131,7 @@ public class ModuleExtensionResolutionTest extends FoundationTestCase {
         "load('@indirect_dep//:data.bzl', indirect_dep_data='data')",
         "data = indirect_dep_data");
 
-    SkyKey skyKey = BzlLoadValue.keyForBuild(Label.parseCanonical("@ext~1.0//:data.bzl"));
+    SkyKey skyKey = BzlLoadValue.keyForBuild(Label.parseCanonical("@ext~//:data.bzl"));
     EvaluationResult<BzlLoadValue> result =
         evaluator.evaluate(ImmutableList.of(skyKey), evaluationContext);
     assertThat(result.get(skyKey).getModule().getGlobal("data")).isEqualTo("indirect_dep_data");
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
index 0a6b801c45..7b39e553c7 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
@@ -236,8 +236,8 @@ public class ModuleFileFunctionTest extends FoundationTestCase {
                     0));
     assertThat(rootModuleFileValue.getNonRegistryOverrideCanonicalRepoNameLookup())
         .containsExactly(
-            RepositoryName.create("eee~override"), "eee",
-            RepositoryName.create("ggg~override"), "ggg");
+            RepositoryName.create("eee~"), "eee",
+            RepositoryName.create("ggg~"), "ggg");
   }
 
   @Test
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleTest.java
index d0a5b62ce9..1ce7566e16 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleTest.java
@@ -14,11 +14,13 @@
 
 package com.google.devtools.build.lib.bazel.bzlmod;
 
+import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.buildModule;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.createModuleKey;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.createRepositoryMapping;
 
+import java.util.stream.Stream;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,35 +32,46 @@ public class ModuleTest {
   @Test
   public void getRepoMapping() throws Exception {
     ModuleKey key = createModuleKey("test_module", "1.0");
+    ModuleKey fooKey = createModuleKey("foo", "1.0");
+    ModuleKey barKey = createModuleKey("bar", "2.0");
     Module module =
         buildModule("test_module", "1.0")
-            .addDep("my_foo", createModuleKey("foo", "1.0"))
-            .addDep("my_bar", createModuleKey("bar", "2.0"))
+            .addDep("my_foo", fooKey)
+            .addDep("my_bar", barKey)
             .addDep("my_root", ModuleKey.ROOT)
             .build();
-    assertThat(module.getRepoMappingWithBazelDepsOnly())
+    assertThat(
+            module.getRepoMappingWithBazelDepsOnly(
+                Stream.of(key, fooKey, barKey, ModuleKey.ROOT)
+                    .collect(
+                        toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithoutVersion))))
         .isEqualTo(
             createRepositoryMapping(
                 key,
                 "test_module",
-                "test_module~1.0",
+                "test_module~",
                 "my_foo",
-                "foo~1.0",
+                "foo~",
                 "my_bar",
-                "bar~2.0",
+                "bar~",
                 "my_root",
                 ""));
   }
 
   @Test
   public void getRepoMapping_asMainModule() throws Exception {
+    ModuleKey fooKey = createModuleKey("foo", "1.0");
+    ModuleKey barKey = createModuleKey("bar", "2.0");
     Module module =
         buildModule("test_module", "1.0")
             .setKey(ModuleKey.ROOT)
             .addDep("my_foo", createModuleKey("foo", "1.0"))
             .addDep("my_bar", createModuleKey("bar", "2.0"))
             .build();
-    assertThat(module.getRepoMappingWithBazelDepsOnly())
+    assertThat(
+            module.getRepoMappingWithBazelDepsOnly(
+                Stream.of(ModuleKey.ROOT, fooKey, barKey)
+                    .collect(toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithVersion))))
         .isEqualTo(
             createRepositoryMapping(
                 ModuleKey.ROOT,
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModuleTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModuleTest.java
index 3b4b96538a..e444e44381 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModuleTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/StarlarkBazelModuleTest.java
@@ -91,16 +91,20 @@ public class StarlarkBazelModuleTest {
                                 .allowedFileTypes(FileTypeSet.ANY_FILE)
                                 .build())))
             .build();
-    Module module =
-        buildModule("foo", "1.0")
-            .setKey(createModuleKey("foo", ""))
-            .addDep("bar", createModuleKey("bar", "2.0"))
-            .build();
+    ModuleKey fooKey = createModuleKey("foo", "");
+    ModuleKey barKey = createModuleKey("bar", "2.0");
+    Module module = buildModule("foo", "1.0").setKey(fooKey).addDep("bar", barKey).build();
     AbridgedModule abridgedModule = AbridgedModule.from(module);
 
     StarlarkBazelModule moduleProxy =
         StarlarkBazelModule.create(
-            abridgedModule, extension, module.getRepoMappingWithBazelDepsOnly(), usage);
+            abridgedModule,
+            extension,
+            module.getRepoMappingWithBazelDepsOnly(
+                ImmutableMap.of(
+                    fooKey, fooKey.getCanonicalRepoNameWithoutVersion(),
+                    barKey, barKey.getCanonicalRepoNameWithoutVersion())),
+            usage);
 
     assertThat(moduleProxy.getName()).isEqualTo("foo");
     assertThat(moduleProxy.getVersion()).isEqualTo("1.0");
@@ -125,8 +129,8 @@ public class StarlarkBazelModuleTest {
     assertThat(pomTags.get(0).getValue("pom_xmls"))
         .isEqualTo(
             StarlarkList.immutableOf(
-                Label.parseCanonical("@@foo~override//:pom.xml"),
-                Label.parseCanonical("@@bar~2.0//:pom.xml")));
+                Label.parseCanonical("@@foo~//:pom.xml"),
+                Label.parseCanonical("@@bar~//:pom.xml")));
   }
 
   @Test
@@ -134,7 +138,8 @@ public class StarlarkBazelModuleTest {
     ModuleExtensionUsage usage = getBaseUsageBuilder().addTag(buildTag("blep").build()).build();
     ModuleExtension extension =
         getBaseExtensionBuilder().setTagClasses(ImmutableMap.of("dep", createTagClass())).build();
-    Module module = buildModule("foo", "1.0").setKey(createModuleKey("foo", "")).build();
+    ModuleKey fooKey = createModuleKey("foo", "");
+    Module module = buildModule("foo", "1.0").setKey(fooKey).build();
     AbridgedModule abridgedModule = AbridgedModule.from(module);
 
     ExternalDepsException e =
@@ -142,7 +147,11 @@ public class StarlarkBazelModuleTest {
             ExternalDepsException.class,
             () ->
                 StarlarkBazelModule.create(
-                    abridgedModule, extension, module.getRepoMappingWithBazelDepsOnly(), usage));
+                    abridgedModule,
+                    extension,
+                    module.getRepoMappingWithBazelDepsOnly(
+                        ImmutableMap.of(fooKey, fooKey.getCanonicalRepoNameWithoutVersion())),
+                    usage));
     assertThat(e).hasMessageThat().contains("does not have a tag class named blep");
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArgTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArgTest.java
index c8edcf3020..64efc14981 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArgTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ExtensionArgTest.java
@@ -14,6 +14,7 @@
 
 package com.google.devtools.build.lib.bazel.bzlmod.modcommand;
 
+import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.AugmentedModuleBuilder.buildAugmentedModule;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.createModuleKey;
@@ -86,12 +87,20 @@ public class ExtensionArgTest {
             .put(buildAugmentedModule("", "").addDep("fred", "foo", "1.0").buildEntry())
             .put(buildAugmentedModule("foo", "1.0").addStillDependant(ModuleKey.ROOT).buildEntry())
             .buildOrThrow();
+    ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames =
+        depGraph.keySet().stream()
+            .collect(toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithVersion));
     ImmutableBiMap<String, ModuleKey> baseModuleDeps = ImmutableBiMap.of("fred", key);
     ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps = ImmutableBiMap.of();
 
     assertThat(
             ExtensionArg.create(SpecificVersionOfModule.create(key), "//:abc.bzl", "def")
-                .resolveToExtensionId(modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps))
+                .resolveToExtensionId(
+                    modulesIndex,
+                    depGraph,
+                    moduleKeyToCanonicalNames,
+                    baseModuleDeps,
+                    baseModuleUnusedDeps))
         .isEqualTo(
             ModuleExtensionId.create(
                 Label.parseCanonical("@@foo~1.0//:abc.bzl"), "def", Optional.empty()));
@@ -107,6 +116,9 @@ public class ExtensionArgTest {
             .put(buildAugmentedModule("", "").addDep("fred", "foo", "1.0").buildEntry())
             .put(buildAugmentedModule("foo", "1.0").addStillDependant(ModuleKey.ROOT).buildEntry())
             .buildOrThrow();
+    ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames =
+        depGraph.keySet().stream()
+            .collect(toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithVersion));
     ImmutableBiMap<String, ModuleKey> baseModuleDeps = ImmutableBiMap.of("fred", key);
     ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps = ImmutableBiMap.of();
 
@@ -115,13 +127,21 @@ public class ExtensionArgTest {
         () ->
             ExtensionArg.create(SpecificVersionOfModule.create(key), "/:def.bzl", "ext")
                 .resolveToExtensionId(
-                    modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps));
+                    modulesIndex,
+                    depGraph,
+                    moduleKeyToCanonicalNames,
+                    baseModuleDeps,
+                    baseModuleUnusedDeps));
     assertThrows(
         InvalidArgumentException.class,
         () ->
             ExtensionArg.create(SpecificVersionOfModule.create(key), "///////", "ext")
                 .resolveToExtensionId(
-                    modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps));
+                    modulesIndex,
+                    depGraph,
+                    moduleKeyToCanonicalNames,
+                    baseModuleDeps,
+                    baseModuleUnusedDeps));
   }
 
   @Test
@@ -140,6 +160,9 @@ public class ExtensionArgTest {
             .put(buildAugmentedModule("foo", "1.0").addStillDependant(ModuleKey.ROOT).buildEntry())
             .put(buildAugmentedModule("foo", "2.0").addStillDependant(ModuleKey.ROOT).buildEntry())
             .buildOrThrow();
+    ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames =
+        depGraph.keySet().stream()
+            .collect(toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithVersion));
     ImmutableBiMap<String, ModuleKey> baseModuleDeps =
         ImmutableBiMap.of("foo1", foo1, "foo2", foo2);
     ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps = ImmutableBiMap.of();
@@ -150,13 +173,21 @@ public class ExtensionArgTest {
         () ->
             ExtensionArg.create(AllVersionsOfModule.create("foo"), "//:def.bzl", "ext")
                 .resolveToExtensionId(
-                    modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps));
+                    modulesIndex,
+                    depGraph,
+                    moduleKeyToCanonicalNames,
+                    baseModuleDeps,
+                    baseModuleUnusedDeps));
     // Found none, bad!
     assertThrows(
         InvalidArgumentException.class,
         () ->
             ExtensionArg.create(AllVersionsOfModule.create("bar"), "//:def.bzl", "ext")
                 .resolveToExtensionId(
-                    modulesIndex, depGraph, baseModuleDeps, baseModuleUnusedDeps));
+                    modulesIndex,
+                    depGraph,
+                    moduleKeyToCanonicalNames,
+                    baseModuleDeps,
+                    baseModuleUnusedDeps));
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArgTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArgTest.java
index b63d5bea40..6a9079a889 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArgTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/modcommand/ModuleArgTest.java
@@ -14,6 +14,7 @@
 
 package com.google.devtools.build.lib.bazel.bzlmod.modcommand;
 
+import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.AugmentedModuleBuilder.buildAugmentedModule;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.createModuleKey;
@@ -76,6 +77,10 @@ public class ModuleArgTest {
           .put(buildAugmentedModule("foo", "1.0").addOriginalDependant(ModuleKey.ROOT).buildEntry())
           .put(buildAugmentedModule("foo", "2.0").addStillDependant(ModuleKey.ROOT).buildEntry())
           .buildOrThrow();
+
+  ImmutableMap<ModuleKey, RepositoryName> moduleKeyToCanonicalNames =
+      depGraph.keySet().stream()
+          .collect(toImmutableMap(k -> k, ModuleKey::getCanonicalRepoNameWithVersion));
   ImmutableBiMap<String, ModuleKey> baseModuleDeps = ImmutableBiMap.of("fred", foo2);
   ImmutableBiMap<String, ModuleKey> baseModuleUnusedDeps = ImmutableBiMap.of("fred", foo1);
   RepositoryMapping rootMapping = createRepositoryMapping(ModuleKey.ROOT, "fred", "foo~2.0");
@@ -89,13 +94,15 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ false,
                 /* warnUnused= */ false))
         .containsExactly(foo2);
 
-    assertThat(arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping))
+    assertThat(
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping))
         .containsExactly("foo@2.0", RepositoryName.create("foo~2.0"));
   }
 
@@ -108,13 +115,15 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
                 /* warnUnused= */ true));
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 
   @Test
@@ -128,6 +137,7 @@ public class ModuleArgTest {
                     arg.resolveToModuleKeys(
                         modulesIndex,
                         depGraph,
+                        moduleKeyToCanonicalNames,
                         baseModuleDeps,
                         baseModuleUnusedDeps,
                         /* includeUnused= */ false,
@@ -139,6 +149,7 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
@@ -148,7 +159,8 @@ public class ModuleArgTest {
     // resolving to repo names doesn't care about unused deps.
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 
   @Test
@@ -159,6 +171,7 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ false,
@@ -169,6 +182,7 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
@@ -176,7 +190,8 @@ public class ModuleArgTest {
         .containsExactly(foo2, foo1);
 
     // resolving to repo names doesn't care about unused deps.
-    assertThat(arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping))
+    assertThat(
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping))
         .containsExactly("foo@2.0", RepositoryName.create("foo~2.0"));
   }
 
@@ -190,13 +205,15 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
                 /* warnUnused= */ true));
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 
   @Test
@@ -207,6 +224,7 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ false,
@@ -217,13 +235,15 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
                 /* warnUnused= */ false))
         .containsExactly(foo2, foo1);
 
-    assertThat(arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping))
+    assertThat(
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping))
         .containsExactly("@fred", RepositoryName.create("foo~2.0"));
   }
 
@@ -237,30 +257,34 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
                 /* warnUnused= */ true));
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 
   @Test
   public void resolve_canonicalRepoName_good() throws Exception {
-    var arg = CanonicalRepoName.create(foo2.getCanonicalRepoName());
+    var arg = CanonicalRepoName.create(foo2.getCanonicalRepoNameWithVersion());
 
     assertThat(
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ false,
                 /* warnUnused= */ false))
         .containsExactly(foo2);
 
-    assertThat(arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping))
+    assertThat(
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping))
         .containsExactly("@@foo~2.0", RepositoryName.create("foo~2.0"));
   }
 
@@ -274,18 +298,20 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
                 /* warnUnused= */ true));
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 
   @Test
   public void resolve_canonicalRepoName_unused() throws Exception {
-    var arg = CanonicalRepoName.create(foo1.getCanonicalRepoName());
+    var arg = CanonicalRepoName.create(foo1.getCanonicalRepoNameWithVersion());
 
     // Without --include_unused, this doesn't resolve, as foo@1.0 has been replaced by foo@2.0.
     assertThat(
@@ -295,6 +321,7 @@ public class ModuleArgTest {
                     arg.resolveToModuleKeys(
                         modulesIndex,
                         depGraph,
+                        moduleKeyToCanonicalNames,
                         baseModuleDeps,
                         baseModuleUnusedDeps,
                         /* includeUnused= */ false,
@@ -306,6 +333,7 @@ public class ModuleArgTest {
             arg.resolveToModuleKeys(
                 modulesIndex,
                 depGraph,
+                moduleKeyToCanonicalNames,
                 baseModuleDeps,
                 baseModuleUnusedDeps,
                 /* includeUnused= */ true,
@@ -315,6 +343,7 @@ public class ModuleArgTest {
     // resolving to repo names doesn't care about unused deps.
     assertThrows(
         InvalidArgumentException.class,
-        () -> arg.resolveToRepoNames(modulesIndex, depGraph, rootMapping));
+        () ->
+            arg.resolveToRepoNames(modulesIndex, depGraph, moduleKeyToCanonicalNames, rootMapping));
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/query2/testutil/AbstractQueryTest.java b/src/test/java/com/google/devtools/build/lib/query2/testutil/AbstractQueryTest.java
index 2fe2d04469..f1e5b55763 100644
--- a/src/test/java/com/google/devtools/build/lib/query2/testutil/AbstractQueryTest.java
+++ b/src/test/java/com/google/devtools/build/lib/query2/testutil/AbstractQueryTest.java
@@ -2327,16 +2327,16 @@ public abstract class AbstractQueryTest<T> {
         "sh_library(name = 'a_b_shar')");
     RepositoryMapping mapping =
         RepositoryMapping.create(
-            ImmutableMap.of("my_repo", RepositoryName.create("repo~1.0")), RepositoryName.MAIN);
+            ImmutableMap.of("my_repo", RepositoryName.create("repo~")), RepositoryName.MAIN);
     helper.setMainRepoTargetParser(mapping);
   }
 
-  protected static final String REPO_A_RULES = "@@repo~1.0//a:a_shar";
-  protected static final String REPO_AB_RULES = "@@repo~1.0//a/b:a_b_shar";
+  protected static final String REPO_A_RULES = "@@repo~//a:a_shar";
+  protected static final String REPO_AB_RULES = "@@repo~//a/b:a_b_shar";
   protected static final String REPO_AB_ALL =
-      "@@repo~1.0//a/b:BUILD @@repo~1.0//a/b:a_b_shar @@repo~1.0//a/b:p @@repo~1.0//a/b:q";
+      "@@repo~//a/b:BUILD @@repo~//a/b:a_b_shar @@repo~//a/b:p @@repo~//a/b:q";
   protected static final String REPO_A_ALL =
-      "@@repo~1.0//a:BUILD @@repo~1.0//a:a_shar @@repo~1.0//a:x @@repo~1.0//a:y @@repo~1.0//a:z";
+      "@@repo~//a:BUILD @@repo~//a:a_shar @@repo~//a:x @@repo~//a:y @@repo~//a:z";
   protected static final String REPO_A_AB_RULES = REPO_AB_RULES + " " + REPO_A_RULES;
   protected static final String REPO_A_AB_ALL = REPO_AB_ALL + " " + REPO_A_ALL;
 
diff --git a/src/test/java/com/google/devtools/build/lib/rules/starlarkdocextract/StarlarkDocExtractTest.java b/src/test/java/com/google/devtools/build/lib/rules/starlarkdocextract/StarlarkDocExtractTest.java
index 24ab021fc4..3fddb8ee9e 100644
--- a/src/test/java/com/google/devtools/build/lib/rules/starlarkdocextract/StarlarkDocExtractTest.java
+++ b/src/test/java/com/google/devtools/build/lib/rules/starlarkdocextract/StarlarkDocExtractTest.java
@@ -1040,7 +1040,7 @@ public final class StarlarkDocExtractTest extends BuildViewTestCase {
         ")");
     invalidatePackages();
 
-    ModuleInfo moduleInfo = protoFromConfiguredTarget("@dep_mod~0.1//:extract");
+    ModuleInfo moduleInfo = protoFromConfiguredTarget("@dep_mod~//:extract");
     assertThat(moduleInfo.getFile()).isEqualTo("@dep_mod//:foo.bzl");
     assertThat(moduleInfo.getFuncInfo(0).getParameter(0).getDefaultValue())
         .isEqualTo("Label(\"@dep_mod//target:target\")");
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/BzlLoadFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/BzlLoadFunctionTest.java
index bb75e65f7f..8313ee130a 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/BzlLoadFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/BzlLoadFunctionTest.java
@@ -1085,7 +1085,7 @@ public class BzlLoadFunctionTest extends BuildViewTestCase {
     scratch.file(barDir.getRelative("BUILD").getPathString());
     scratch.file(barDir.getRelative("test.scl").getPathString(), "haha = 5");
 
-    SkyKey skyKey = BzlLoadValue.keyForBzlmod(Label.parseCanonical("@@foo~1.0//:test.bzl"));
+    SkyKey skyKey = BzlLoadValue.keyForBzlmod(Label.parseCanonical("@@foo~//:test.bzl"));
     EvaluationResult<BzlLoadValue> result =
         SkyframeExecutorTestUtils.evaluate(
             getSkyframeExecutor(), skyKey, /*keepGoing=*/ false, reporter);
@@ -1096,9 +1096,9 @@ public class BzlLoadFunctionTest extends BuildViewTestCase {
     assertThat(bzlLoadValue.getRecordedRepoMappings().cellSet())
         .containsExactly(
             Tables.immutableCell(
-                RepositoryName.create("foo~1.0"), "bar_alias", RepositoryName.create("bar~2.0")),
+                RepositoryName.create("foo~"), "bar_alias", RepositoryName.create("bar~")),
             Tables.immutableCell(
-                RepositoryName.create("foo~1.0"), "foo", RepositoryName.create("foo~1.0")))
+                RepositoryName.create("foo~"), "foo", RepositoryName.create("foo~")))
         .inOrder();
     // Note that we're not testing the case of a non-registry override using @bazel_tools here, but
     // that is incredibly hard to set up in a unit test. So we should just rely on integration tests
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/PrepareDepsOfPatternsFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/PrepareDepsOfPatternsFunctionTest.java
index f120a34c6e..977db081bd 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/PrepareDepsOfPatternsFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/PrepareDepsOfPatternsFunctionTest.java
@@ -213,9 +213,9 @@ public class PrepareDepsOfPatternsFunctionTest extends BuildViewTestCase {
     WalkableGraph walkableGraph = getGraphFromPatternsEvaluation(patternSequence);
 
     // Then the graph contains a value for the target "@//rinne:rinne" and the dep
-    // "@@repo~1.0//a:x",
+    // "@@repo~//a:x",
     assertValidValue(walkableGraph, getKeyForLabel(Label.create("//rinne", "rinne")));
-    assertValidValue(walkableGraph, getKeyForLabel(Label.create("@repo~1.0//a", "x")));
+    assertValidValue(walkableGraph, getKeyForLabel(Label.create("@repo~//a", "x")));
   }
 
   // Regression test for b/225877591 ("Unexpected missing value in PrepareDepsOfPatternsFunction
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/RepoFileFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/RepoFileFunctionTest.java
index 1fc739c78b..7ace2dbb75 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/RepoFileFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/RepoFileFunctionTest.java
@@ -69,7 +69,7 @@ public class RepoFileFunctionTest extends BuildViewTestCase {
                 .get("deprecation", Type.STRING))
         .isNull();
     assertThat(
-            getRuleContext(getConfiguredTarget("@@foo~1.0//abc/def:what"))
+            getRuleContext(getConfiguredTarget("@@foo~//abc/def:what"))
                 .attributes()
                 .get("deprecation", Type.STRING))
         .isEqualTo("EVERYTHING IS DEPRECATED");
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/RepositoryMappingFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/RepositoryMappingFunctionTest.java
index de83190f92..e45426c9c7 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/RepositoryMappingFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/RepositoryMappingFunctionTest.java
@@ -146,7 +146,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
                     TestConstants.LEGACY_WORKSPACE_NAME,
                     RepositoryName.MAIN,
                     "com_foo_bar_b",
-                    RepositoryName.create("bbb~1.0")),
+                    RepositoryName.create("bbb~")),
                 "aaa",
                 "0.1"));
   }
@@ -175,7 +175,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
                     TestConstants.LEGACY_WORKSPACE_NAME,
                     RepositoryName.MAIN,
                     "com_foo_bar_b",
-                    RepositoryName.create("bbb~1.0")),
+                    RepositoryName.create("bbb~")),
                 "aaa",
                 "0.1"));
   }
@@ -194,7 +194,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
             "module(name='ccc', version='1.0')",
             "bazel_dep(name='bbb', version='1.0', repo_name='com_foo_bar_b')");
 
-    RepositoryName name = RepositoryName.create("ccc~1.0");
+    RepositoryName name = RepositoryName.create("ccc~");
     SkyKey skyKey = RepositoryMappingValue.key(name);
     EvaluationResult<RepositoryMappingValue> result = eval(skyKey);
 
@@ -204,8 +204,8 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
         .isEqualTo(
             valueForBzlmod(
                 ImmutableMap.of(
-                    "ccc", RepositoryName.create("ccc~1.0"),
-                    "com_foo_bar_b", RepositoryName.create("bbb~1.0")),
+                    "ccc", RepositoryName.create("ccc~"),
+                    "com_foo_bar_b", RepositoryName.create("bbb~")),
                 name,
                 "ccc",
                 "1.0"));
@@ -220,7 +220,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
         "module(name='bbb', version='1.0')",
         "bazel_dep(name='aaa',version='3.0')");
 
-    RepositoryName name = RepositoryName.create("bbb~1.0");
+    RepositoryName name = RepositoryName.create("bbb~");
     SkyKey skyKey = RepositoryMappingValue.key(name);
     EvaluationResult<RepositoryMappingValue> result = eval(skyKey);
 
@@ -230,7 +230,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
         .isEqualTo(
             valueForBzlmod(
                 ImmutableMap.of(
-                    "bbb", RepositoryName.create("bbb~1.0"), "aaa", RepositoryName.create("")),
+                    "bbb", RepositoryName.create("bbb~"), "aaa", RepositoryName.create("")),
                 name,
                 "bbb",
                 "1.0"));
@@ -291,7 +291,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
         .addModule(createModuleKey("ddd", "1.0"), "module(name='ddd', version='1.0')")
         .addModule(createModuleKey("ddd", "2.0"), "module(name='ddd', version='2.0')");
 
-    RepositoryName name = RepositoryName.create("bbb~1.0");
+    RepositoryName name = RepositoryName.create("bbb~");
     SkyKey skyKey = RepositoryMappingValue.key(name);
     EvaluationResult<RepositoryMappingValue> result = eval(skyKey);
 
@@ -303,7 +303,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
         .isEqualTo(
             valueForBzlmod(
                 ImmutableMap.of(
-                    "bbb", RepositoryName.create("bbb~1.0"),
+                    "bbb", RepositoryName.create("bbb~"),
                     "ddd", RepositoryName.create("ddd~1.0")),
                 name,
                 "bbb",
@@ -339,7 +339,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
             valueForBzlmod(
                 ImmutableMap.of(
                     "bbb", RepositoryName.create("bbb~1.0"),
-                    "com_foo_bar_c", RepositoryName.create("ccc~1.0")),
+                    "com_foo_bar_c", RepositoryName.create("ccc~")),
                 name,
                 "bbb",
                 "1.0"));
@@ -452,16 +452,16 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
                     .put("", RepositoryName.MAIN)
                     .put("aaa", RepositoryName.MAIN)
                     .put("root", RepositoryName.MAIN)
-                    // mappings to @bbb get remapped to @bbb~1.0 because of root dep on bbb@1.0
-                    .put("bbb_alias", RepositoryName.create("bbb~1.0"))
-                    .put("bbb_alias2", RepositoryName.create("bbb~1.0"))
+                    // mappings to @bbb get remapped to @bbb~ because of root dep on bbb@1.0
+                    .put("bbb_alias", RepositoryName.create("bbb~"))
+                    .put("bbb_alias2", RepositoryName.create("bbb~"))
                     // mapping from @bbb to @bbb~1.0 is also created
-                    .put("bbb", RepositoryName.create("bbb~1.0"))
+                    .put("bbb", RepositoryName.create("bbb~"))
                     // mapping from @ccc to @ccc~2.0 is created despite not being mentioned
-                    .put("ccc", RepositoryName.create("ccc~2.0"))
+                    .put("ccc", RepositoryName.create("ccc~"))
                     // mapping to @ddd gets remapped to a module-extension-generated repo
-                    .put("ddd_alias", RepositoryName.create("ccc~2.0~ext~ddd"))
-                    .put("ddd", RepositoryName.create("ccc~2.0~ext~ddd"))
+                    .put("ddd_alias", RepositoryName.create("ccc~~ext~ddd"))
+                    .put("ddd", RepositoryName.create("ccc~~ext~ddd"))
                     // mapping to @eee is untouched because the root module doesn't know about it
                     .put("eee_alias", RepositoryName.create("eee"))
                     .buildOrThrow()));
@@ -493,7 +493,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
                 ImmutableMap.of(
                     "", RepositoryName.MAIN,
                     "aaa", RepositoryName.MAIN,
-                    "bbb", RepositoryName.create("bbb~1.0"),
+                    "bbb", RepositoryName.create("bbb~"),
                     "root", RepositoryName.MAIN,
                     "ws_repo", RepositoryName.create("ws_repo")),
                 "aaa",
@@ -526,7 +526,7 @@ public class RepositoryMappingFunctionTest extends BuildViewTestCase {
                 ImmutableMap.of(
                     "", RepositoryName.MAIN,
                     "aaa", RepositoryName.MAIN,
-                    "bbb", RepositoryName.create("bbb~1.0")),
+                    "bbb", RepositoryName.create("bbb~")),
                 RepositoryName.MAIN,
                 "aaa",
                 "0.1"));
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunctionTest.java
index 91b3981b8f..edc1c463f3 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredExecutionPlatformsFunctionTest.java
@@ -366,10 +366,10 @@ public class RegisteredExecutionPlatformsFunctionTest extends ToolchainTestCase
             Label.parseCanonical("//:wsplat"),
             Label.parseCanonical("//:wsplat2"),
             // Other modules' toolchains
-            Label.parseCanonical("@@bbb~1.0//:plat"),
-            Label.parseCanonical("@@ccc~1.1//:plat"),
-            Label.parseCanonical("@@eee~1.0//:plat"),
-            Label.parseCanonical("@@ddd~1.1//:plat"))
+            Label.parseCanonical("@@bbb~//:plat"),
+            Label.parseCanonical("@@ccc~//:plat"),
+            Label.parseCanonical("@@eee~//:plat"),
+            Label.parseCanonical("@@ddd~//:plat"))
         .inOrder();
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunctionTest.java b/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunctionTest.java
index 15b934e3be..d399d44090 100644
--- a/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/skyframe/toolchains/RegisteredToolchainsFunctionTest.java
@@ -476,10 +476,10 @@ public class RegisteredToolchainsFunctionTest extends ToolchainTestCase {
             Label.parseCanonical("//toolchain:suffix_toolchain_2_impl"),
             Label.parseCanonical("//:wstool2_impl"),
             // Other modules' toolchains
-            Label.parseCanonical("@@bbb~1.0//:tool_impl"),
-            Label.parseCanonical("@@ccc~1.1//:tool_impl"),
-            Label.parseCanonical("@@eee~1.0//:tool_impl"),
-            Label.parseCanonical("@@ddd~1.1//:tool_impl"),
+            Label.parseCanonical("@@bbb~//:tool_impl"),
+            Label.parseCanonical("@@ccc~//:tool_impl"),
+            Label.parseCanonical("@@eee~//:tool_impl"),
+            Label.parseCanonical("@@ddd~//:tool_impl"),
             // WORKSPACE suffix toolchains
             Label.parseCanonical("//toolchain:suffix_toolchain_1_impl"))
         .inOrder();
diff --git a/src/test/py/bazel/bzlmod/bazel_fetch_test.py b/src/test/py/bazel/bzlmod/bazel_fetch_test.py
index 506ddc2f26..2981549af4 100644
--- a/src/test/py/bazel/bzlmod/bazel_fetch_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_fetch_test.py
@@ -101,8 +101,8 @@ class BazelFetchTest(test_base.TestBase):
     self.RunBazel(['fetch', '--all'])
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
     repos_fetched = os.listdir(stdout[0] + '/external')
-    self.assertIn('aaa~1.0', repos_fetched)
-    self.assertIn('bbb~1.0', repos_fetched)
+    self.assertIn('aaa~', repos_fetched)
+    self.assertIn('bbb~', repos_fetched)
     self.assertIn('_main~ext~hello', repos_fetched)
 
   def testFetchConfig(self):
@@ -141,7 +141,7 @@ class BazelFetchTest(test_base.TestBase):
     self.RunBazel(['fetch', '--configure'])
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
     repos_fetched = os.listdir(stdout[0] + '/external')
-    self.assertNotIn('aaa~1.0', repos_fetched)
+    self.assertNotIn('aaa~', repos_fetched)
     self.assertNotIn('_main~ext~notConfig', repos_fetched)
     self.assertIn('_main~ext~IamConfig', repos_fetched)
 
@@ -179,12 +179,12 @@ class BazelFetchTest(test_base.TestBase):
     )
     self.ScratchFile('BUILD')
     # Test canonical/apparent repo names & multiple repos
-    self.RunBazel(['fetch', '--repo=@@bbb~1.0', '--repo=@my_repo'])
+    self.RunBazel(['fetch', '--repo=@@bbb~', '--repo=@my_repo'])
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
     repos_fetched = os.listdir(stdout[0] + '/external')
-    self.assertIn('bbb~1.0', repos_fetched)
-    self.assertIn('ccc~1.0', repos_fetched)
-    self.assertNotIn('aaa~1.0', repos_fetched)
+    self.assertIn('bbb~', repos_fetched)
+    self.assertIn('ccc~', repos_fetched)
+    self.assertNotIn('aaa~', repos_fetched)
 
   def testFetchInvalidRepo(self):
     # Invalid repo name (not canonical or apparent)
diff --git a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
index c7df0c9f97..4549e88370 100644
--- a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
@@ -1519,13 +1519,11 @@ class BazelLockfileTest(test_base.TestBase):
   def testExtensionRepoMappingChange(self):
     # Regression test for #20721
     self.main_registry.createCcModule('foo', '1.0')
-    self.main_registry.createCcModule('foo', '2.0')
     self.main_registry.createCcModule('bar', '1.0')
-    self.main_registry.createCcModule('bar', '2.0')
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="1.0")',
+            'bazel_dep(name="foo",version="1.0",repo_name="repo_name")',
             'bazel_dep(name="bar",version="1.0")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
@@ -1548,13 +1546,13 @@ class BazelLockfileTest(test_base.TestBase):
             'repo = repository_rule(_repo_impl,attrs={"value":attr.label()})',
             'def _ext_impl(mctx):',
             '  print("ran the extension!")',
-            '  repo(name = "repo", value = Label("@foo//:lib_foo"))',
+            '  repo(name = "repo", value = Label("@repo_name//:lib_foo"))',
             'ext = module_extension(_ext_impl)',
         ],
     )
 
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~1.0//:lib_foo', '\n'.join(stderr))
+    self.assertIn('STR=@@foo~//:lib_foo', '\n'.join(stderr))
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
@@ -1563,30 +1561,33 @@ class BazelLockfileTest(test_base.TestBase):
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # Now, for something spicy: upgrade foo to 2.0 and change nothing else.
-    # The extension should rerun despite the lockfile being present, and no
-    # usages or .bzl files having changed.
+    # Now, for something spicy: let repo_name point to bar and change nothing
+    # else. The extension should rerun despite the lockfile being present, and
+    # no usages or .bzl files having changed.
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="2.0")',
-            'bazel_dep(name="bar",version="1.0")',
+            'bazel_dep(name="foo",version="1.0")',
+            'bazel_dep(name="bar",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
     )
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~2.0//:lib_foo', '\n'.join(stderr))
+    stderr = '\n'.join(stderr)
+    self.assertIn('ran the extension!', stderr)
+    self.assertIn('STR=@@bar~//:lib_foo', stderr)
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # More spicy! upgrade bar to 2.0 and change nothing else.
-    # The extension should NOT rerun, since it never used the @bar repo mapping.
+    # More spicy! change the repo_name of foo, but nothing else.
+    # The extension should NOT rerun, since it never used the @other_name repo
+    # mapping.
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="2.0")',
-            'bazel_dep(name="bar",version="2.0")',
+            'bazel_dep(name="foo",version="1.0",repo_name="other_name")',
+            'bazel_dep(name="bar",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
@@ -1594,19 +1595,17 @@ class BazelLockfileTest(test_base.TestBase):
     _, _, stderr = self.RunBazel(['build', ':lol'])
     stderr = '\n'.join(stderr)
     self.assertNotIn('ran the extension!', stderr)
-    self.assertIn('STR=@@foo~2.0//:lib_foo', stderr)
+    self.assertIn('STR=@@bar~//:lib_foo', stderr)
 
   def testExtensionRepoMappingChange_BzlInit(self):
     # Regression test for #20721; same test as above, except that the call to
     # Label() in ext.bzl is now done at bzl load time.
     self.main_registry.createCcModule('foo', '1.0')
-    self.main_registry.createCcModule('foo', '2.0')
     self.main_registry.createCcModule('bar', '1.0')
-    self.main_registry.createCcModule('bar', '2.0')
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="1.0")',
+            'bazel_dep(name="foo",version="1.0",repo_name="repo_name")',
             'bazel_dep(name="bar",version="1.0")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
@@ -1623,7 +1622,7 @@ class BazelLockfileTest(test_base.TestBase):
     self.ScratchFile(
         'ext.bzl',
         [
-            'constant = Label("@foo//:lib_foo")',
+            'constant = Label("@repo_name//:lib_foo")',
             'def _repo_impl(rctx):',
             '  rctx.file("BUILD")',
             '  rctx.file("defs.bzl", "STR = " + repr(str(rctx.attr.value)))',
@@ -1636,7 +1635,7 @@ class BazelLockfileTest(test_base.TestBase):
     )
 
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~1.0//:lib_foo', '\n'.join(stderr))
+    self.assertIn('STR=@@foo~//:lib_foo', '\n'.join(stderr))
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
@@ -1645,30 +1644,33 @@ class BazelLockfileTest(test_base.TestBase):
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # Now, for something spicy: upgrade foo to 2.0 and change nothing else.
-    # The extension should rerun despite the lockfile being present, and no
-    # usages or .bzl files having changed.
+    # Now, for something spicy: let repo_name point to bar and change nothing
+    # else. The extension should rerun despite the lockfile being present, and
+    # no usages or .bzl files having changed.
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="2.0")',
-            'bazel_dep(name="bar",version="1.0")',
+            'bazel_dep(name="foo",version="1.0")',
+            'bazel_dep(name="bar",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
     )
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~2.0//:lib_foo', '\n'.join(stderr))
+    stderr = '\n'.join(stderr)
+    self.assertIn('ran the extension!', stderr)
+    self.assertIn('STR=@@bar~//:lib_foo', stderr)
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # More spicy! upgrade bar to 2.0 and change nothing else.
-    # The extension should NOT rerun, since it never used the @bar repo mapping.
+    # More spicy! change the repo_name of foo, but nothing else.
+    # The extension should NOT rerun, since it never used the @other_name repo
+    # mapping.
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="2.0")',
-            'bazel_dep(name="bar",version="2.0")',
+            'bazel_dep(name="foo",version="1.0",repo_name="other_name")',
+            'bazel_dep(name="bar",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
@@ -1676,34 +1678,33 @@ class BazelLockfileTest(test_base.TestBase):
     _, _, stderr = self.RunBazel(['build', ':lol'])
     stderr = '\n'.join(stderr)
     self.assertNotIn('ran the extension!', stderr)
-    self.assertIn('STR=@@foo~2.0//:lib_foo', stderr)
+    self.assertIn('STR=@@bar~//:lib_foo', stderr)
 
   def testExtensionRepoMappingChange_loadsAndRepoRelativeLabels(self):
     # Regression test for #20721; same test as above, except that the call to
-    # Label() in ext.bzl is now moved to @foo//:defs.bzl and doesn't itself
-    # use repo mapping (ie. is a repo-relative label). bar is removed as it's
-    # just a distraction.
+    # Label() in ext.bzl is now moved to @{foo,bar}//:defs.bzl and doesn't
+    # itself use repo mapping (ie. is a repo-relative label).
     self.main_registry.setModuleBasePath('projects')
     projects_dir = self.main_registry.projects
 
-    self.main_registry.createLocalPathModule('foo', '1.0', 'foo1')
-    scratchFile(projects_dir.joinpath('foo1', 'BUILD'))
+    self.main_registry.createLocalPathModule('foo', '1.0', 'foo')
+    scratchFile(projects_dir.joinpath('foo', 'BUILD'))
     scratchFile(
-        projects_dir.joinpath('foo1', 'defs.bzl'),
+        projects_dir.joinpath('foo', 'defs.bzl'),
         ['constant=Label("//:BUILD")'],
     )
-    self.main_registry.createLocalPathModule('foo', '2.0', 'foo2')
-    scratchFile(projects_dir.joinpath('foo2', 'BUILD'))
-    # Exactly the same as foo1!
+    self.main_registry.createLocalPathModule('bar', '1.0', 'bar')
+    scratchFile(projects_dir.joinpath('bar', 'BUILD'))
+    # Exactly the same as foo!
     scratchFile(
-        projects_dir.joinpath('foo2', 'defs.bzl'),
+        projects_dir.joinpath('bar', 'defs.bzl'),
         ['constant=Label("//:BUILD")'],
     )
 
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="1.0")',
+            'bazel_dep(name="foo",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
@@ -1719,7 +1720,7 @@ class BazelLockfileTest(test_base.TestBase):
     self.ScratchFile(
         'ext.bzl',
         [
-            'load("@foo//:defs.bzl", "constant")',
+            'load("@repo_name//:defs.bzl", "constant")',
             'def _repo_impl(rctx):',
             '  rctx.file("BUILD")',
             '  rctx.file("defs.bzl", "STR = " + repr(str(rctx.attr.value)))',
@@ -1732,7 +1733,7 @@ class BazelLockfileTest(test_base.TestBase):
     )
 
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~1.0//:BUILD', '\n'.join(stderr))
+    self.assertIn('STR=@@foo~//:BUILD', '\n'.join(stderr))
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
@@ -1741,54 +1742,24 @@ class BazelLockfileTest(test_base.TestBase):
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # Now, for something spicy: upgrade foo to 2.0 and change nothing else.
+    # Now, for something spicy: change repo_name to point to bar.
     # The extension should rerun despite the lockfile being present, and no
     # usages or .bzl files having changed.
     self.ScratchFile(
         'MODULE.bazel',
         [
-            'bazel_dep(name="foo",version="2.0")',
+            'bazel_dep(name="bar",version="1.0",repo_name="repo_name")',
             'ext = use_extension(":ext.bzl", "ext")',
             'use_repo(ext, "repo")',
         ],
     )
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@foo~2.0//:BUILD', '\n'.join(stderr))
+    self.assertIn('STR=@@bar~//:BUILD', '\n'.join(stderr))
 
   def testExtensionRepoMappingChange_sourceRepoNoLongerExistent(self):
-    # Regression test for #20721; a very convoluted setup to make sure that
-    # an old recorded repo mapping entry with a source repo that doesn't
-    # exist anymore doesn't cause a crash.
-    self.main_registry.setModuleBasePath('projects')
-    projects_dir = self.main_registry.projects
-
-    self.main_registry.createLocalPathModule(
-        'foo', '1.0', 'foo', {'bar': '1.0'}
-    )
-    scratchFile(projects_dir.joinpath('foo', 'BUILD'))
-    scratchFile(
-        projects_dir.joinpath('foo', 'defs.bzl'),
-        ['load("@bar//:defs.bzl","bar")', 'constant=bar'],
-    )
-    self.main_registry.createLocalPathModule(
-        'bar', '1.0', 'bar1', {'quux': '1.0'}
-    )
-    scratchFile(projects_dir.joinpath('bar1', 'BUILD'))
-    scratchFile(
-        projects_dir.joinpath('bar1', 'defs.bzl'),
-        ['bar=Label("@quux//:quux.h")'],
-    )
-    self.main_registry.createLocalPathModule(
-        'bar', '2.0', 'bar2', {'quux': '1.0'}
-    )
-    scratchFile(projects_dir.joinpath('bar2', 'BUILD'))
-    # Exactly the same as bar2!
-    scratchFile(
-        projects_dir.joinpath('bar2', 'defs.bzl'),
-        ['bar=Label("@quux//:quux.h")'],
-    )
-    self.main_registry.createCcModule('quux', '1.0')
-
+    # Regression test for #20721; verify that an old recorded repo mapping entry
+    # with a source repo that doesn't exist anymore doesn't cause a crash.
+    self.main_registry.createCcModule('foo', '1.0')
     self.ScratchFile(
         'MODULE.bazel',
         [
@@ -1808,20 +1779,19 @@ class BazelLockfileTest(test_base.TestBase):
     self.ScratchFile(
         'ext.bzl',
         [
-            'load("@foo//:defs.bzl", "constant")',
             'def _repo_impl(rctx):',
             '  rctx.file("BUILD")',
             '  rctx.file("defs.bzl", "STR = " + repr(str(rctx.attr.value)))',
             'repo = repository_rule(_repo_impl,attrs={"value":attr.label()})',
             'def _ext_impl(mctx):',
             '  print("ran the extension!")',
-            '  repo(name = "repo", value = constant)',
+            '  repo(name = "repo", value = Label("@foo//:lib_foo"))',
             'ext = module_extension(_ext_impl)',
         ],
     )
 
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('STR=@@quux~1.0//:quux.h', '\n'.join(stderr))
+    self.assertIn('STR=@@foo~//:lib_foo', '\n'.join(stderr))
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
@@ -1830,31 +1800,26 @@ class BazelLockfileTest(test_base.TestBase):
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
-    # The above should have recorded these repo mapping entries (in order):
-    #  1. <@@, "foo", @@foo~1.0>
-    #  2. <@@bar~1.0, "quux", @@quux~1.0>
-    #  3. <@@foo~1.0, "bar", @@bar~1.0>
-    # Now we add a dep on bar@2.0 from the root module (despite not using it).
-    # This causes @@bar~1.0 to be gone from the dependency graph. When we then
-    # try to see if the recorded repo mapping entries are still up-to-date,
-    # entry 2 will fail to find the source repo. The code should be resistant
-    # to failure in this case.
-    # We need this convoluted setup because we want entries before the
-    # offending entry to stay the same. In the current setup, entry 1 doesn't
-    # change; entry 3 does change (maps to @@bar~2.0 now), but it comes after
-    # entry 2.
-    self.ScratchFile(
-        'MODULE.bazel',
-        [
-            'bazel_dep(name="foo",version="1.0")',
-            'bazel_dep(name="bar",version="2.0")',
-            'ext = use_extension(":ext.bzl", "ext")',
-            'use_repo(ext, "repo")',
-        ],
-    )
+    # Now, for something spicy: edit the lockfile to add a recorded repo mapping
+    # with a source repo that doesn't exist. Editing the lockfile is much easier
+    # than setting up this situation with an actual dep graph.
+    with open(self.Path('MODULE.bazel.lock'), 'r') as f:
+      lockfile = json.loads(f.read().strip())
+      self.assertIn('//:ext.bzl%ext', lockfile['moduleExtensions'])
+      extension = lockfile['moduleExtensions']['//:ext.bzl%ext']['general']
+      self.assertIn('recordedRepoMappingEntries', extension)
+      extension['recordedRepoMappingEntries'].append(
+          ['_unknown_source_repo', 'other_name', 'bar~']
+      )
+
+    with open(self.Path('MODULE.bazel.lock'), 'w') as f:
+      json.dump(lockfile, f, indent=2)
+
+    # Verify that the extension is reevaluated without a crash.
     _, _, stderr = self.RunBazel(['build', ':lol'])
-    self.assertIn('ran the extension!', '\n'.join(stderr))
-    self.assertIn('STR=@@quux~1.0//:quux.h', '\n'.join(stderr))
+    stderr = '\n'.join(stderr)
+    self.assertIn('ran the extension!', stderr)
+    self.assertIn('STR=@@foo~//:lib_foo', stderr)
 
   def testExtensionRepoMappingChange_mainRepoEvalCycleWithWorkspace(self):
     # Regression test for #20942
@@ -1892,7 +1857,7 @@ class BazelLockfileTest(test_base.TestBase):
     self.ScratchFile('WORKSPACE.bzlmod', ['load("@repo//:defs.bzl","STR")'])
 
     _, _, stderr = self.RunBazel(['build', '--enable_workspace', ':lol'])
-    self.assertIn('STR=@@foo~1.0//:lib_foo', '\n'.join(stderr))
+    self.assertIn('STR=@@foo~//:lib_foo', '\n'.join(stderr))
 
     # Shutdown bazel to make sure we rely on the lockfile and not skyframe
     self.RunBazel(['shutdown'])
diff --git a/src/test/py/bazel/bzlmod/bazel_module_test.py b/src/test/py/bazel/bzlmod/bazel_module_test.py
index 0c7d812069..9971b4f510 100644
--- a/src/test/py/bazel/bzlmod/bazel_module_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_module_test.py
@@ -418,10 +418,10 @@ class BazelModuleTest(test_base.TestBase):
 
     _, _, stderr = self.RunBazel(['build', '@bar//quux:book'])
     stderr = '\n'.join(stderr)
-    self.assertIn('1st: @@bar~override//quux:bleb', stderr)
-    self.assertIn('2nd: @@bar~override//bleb:bleb', stderr)
+    self.assertIn('1st: @@bar~//quux:bleb', stderr)
+    self.assertIn('2nd: @@bar~//bleb:bleb', stderr)
     self.assertIn('3rd: @@//bleb:bleb', stderr)
-    self.assertIn('4th: @@bar~override//bleb:bleb', stderr)
+    self.assertIn('4th: @@bar~//bleb:bleb', stderr)
     self.assertIn('5th: @@bleb//bleb:bleb', stderr)
     self.assertIn('6th: @@//bleb:bleb', stderr)
 
@@ -461,10 +461,10 @@ class BazelModuleTest(test_base.TestBase):
     stderr = '\n'.join(stderr)
     # @bar is mapped to @@baz, which Bzlmod doesn't recognize, so we leave it be
     self.assertIn('1st: @@baz//:z', stderr)
-    # @my_aaa is mapped to @@aaa, which Bzlmod remaps to @@aaa~1.0
-    self.assertIn('2nd: @@aaa~1.0//:z', stderr)
-    # @bbb isn't mapped in WORKSPACE, but Bzlmod maps it to @@bbb~1.0
-    self.assertIn('3rd: @@bbb~1.0//:z', stderr)
+    # @my_aaa is mapped to @@aaa, which Bzlmod remaps to @@aaa~
+    self.assertIn('2nd: @@aaa~//:z', stderr)
+    # @bbb isn't mapped in WORKSPACE, but Bzlmod maps it to @@bbb~
+    self.assertIn('3rd: @@bbb~//:z', stderr)
     # @blarg isn't mapped by WORKSPACE or Bzlmod
     self.assertIn('4th: @@blarg//:z', stderr)
 
@@ -643,11 +643,9 @@ class BazelModuleTest(test_base.TestBase):
     )
     stderr = '\n'.join(stderr)
     self.assertIn('@@ reporting in: root@0.1', stderr)
-    self.assertIn('@@foo~1.0 reporting in: foo@1.0', stderr)
-    self.assertIn(
-        '@@foo~1.0~report_ext~report_repo reporting in: foo@1.0', stderr
-    )
-    self.assertIn('@@bar~override reporting in: bar@2.0', stderr)
+    self.assertIn('@@foo~ reporting in: foo@1.0', stderr)
+    self.assertIn('@@foo~~report_ext~report_repo reporting in: foo@1.0', stderr)
+    self.assertIn('@@bar~ reporting in: bar@2.0', stderr)
     self.assertIn('@@quux reporting in: None@None', stderr)
 
   def testWorkspaceToolchainRegistrationWithPlatformsConstraint(self):
@@ -793,7 +791,7 @@ class BazelModuleTest(test_base.TestBase):
     )
     self.ScratchFile('hello/MODULE.bazel', ['wat'])
     _, _, stderr = self.RunBazel(['build', '@what'], allow_failure=True)
-    self.assertIn('ERROR: @@hello~override//:MODULE.bazel', '\n'.join(stderr))
+    self.assertIn('ERROR: @@hello~//:MODULE.bazel', '\n'.join(stderr))
 
   def testLoadRulesJavaSymbolThroughBazelTools(self):
     """Tests that loads from @bazel_tools that delegate to other modules resolve."""
diff --git a/src/test/py/bazel/bzlmod/bazel_overrides_test.py b/src/test/py/bazel/bzlmod/bazel_overrides_test.py
index 158b789a34..b9db58de7b 100644
--- a/src/test/py/bazel/bzlmod/bazel_overrides_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_overrides_test.py
@@ -327,7 +327,7 @@ class BazelOverridesTest(test_base.TestBase):
     )
     # module file override should be ignored, and bb directory should be used
     self.assertIn(
-        'Target @@ss~override//:choose_me up-to-date (nothing to build)', stderr
+        'Target @@ss~//:choose_me up-to-date (nothing to build)', stderr
     )
 
   def testCmdRelativeModuleOverride(self):
@@ -365,7 +365,7 @@ class BazelOverridesTest(test_base.TestBase):
         cwd=self.Path('aa/cc'),
     )
     self.assertIn(
-        'Target @@ss~override//:choose_me up-to-date (nothing to build)', stderr
+        'Target @@ss~//:choose_me up-to-date (nothing to build)', stderr
     )
 
   def testCmdWorkspaceRelativeModuleOverride(self):
@@ -400,7 +400,7 @@ class BazelOverridesTest(test_base.TestBase):
         cwd=self.Path('aa'),
     )
     self.assertIn(
-        'Target @@ss~override//:choose_me up-to-date (nothing to build)', stderr
+        'Target @@ss~//:choose_me up-to-date (nothing to build)', stderr
     )
 
 
diff --git a/src/test/py/bazel/bzlmod/bazel_repo_mapping_test.py b/src/test/py/bazel/bzlmod/bazel_repo_mapping_test.py
index 125d9c7ed6..ea3e2c3891 100644
--- a/src/test/py/bazel/bzlmod/bazel_repo_mapping_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_repo_mapping_test.py
@@ -104,6 +104,7 @@ class BazelRepoMappingTest(test_base.TestBase):
             'bazel_dep(name="foo",version="1.0")',
             'bazel_dep(name="bar",version="2.0")',
             'bazel_dep(name="bare_rule",version="1.0")',
+            'multiple_version_override(module_name="quux",versions=["1.0","2.0"])',
         ],
     )
     self.ScratchFile('WORKSPACE.bzlmod', ['workspace(name="me_ws")'])
@@ -160,12 +161,12 @@ class BazelRepoMappingTest(test_base.TestBase):
       with open(self.Path(path), 'r') as f:
         self.assertEqual(
             f.read().strip(),
-            """,foo,foo~1.0
+            """,foo,foo~
 ,me,_main
 ,me_ws,_main
-foo~1.0,foo,foo~1.0
-foo~1.0,quux,quux~2.0
-quux~2.0,quux,quux~2.0""",
+foo~,foo,foo~
+foo~,quux,quux~1.0
+quux~1.0,quux,quux~1.0""",
         )
     with open(self.Path('bazel-bin/me.runfiles_manifest')) as f:
       self.assertIn('_repo_mapping ', f.read())
@@ -177,20 +178,18 @@ quux~2.0,quux,quux~2.0""",
         '--test_output=errors',
     ])
 
-    paths = ['bazel-bin/external/bar~2.0/bar.repo_mapping']
+    paths = ['bazel-bin/external/bar~/bar.repo_mapping']
     if not self.IsWindows():
-      paths.append('bazel-bin/external/bar~2.0/bar.runfiles/_repo_mapping')
+      paths.append('bazel-bin/external/bar~/bar.runfiles/_repo_mapping')
     for path in paths:
       with open(self.Path(path), 'r') as f:
         self.assertEqual(
             f.read().strip(),
-            """bar~2.0,bar,bar~2.0
-bar~2.0,quux,quux~2.0
+            """bar~,bar,bar~
+bar~,quux,quux~2.0
 quux~2.0,quux,quux~2.0""",
         )
-    with open(
-        self.Path('bazel-bin/external/bar~2.0/bar.runfiles_manifest')
-    ) as f:
+    with open(self.Path('bazel-bin/external/bar~/bar.runfiles_manifest')) as f:
       self.assertIn('_repo_mapping ', f.read())
 
   def testBashRunfilesLibraryRepoMapping(self):
diff --git a/src/test/py/bazel/bzlmod/bazel_vendor_test.py b/src/test/py/bazel/bzlmod/bazel_vendor_test.py
index 0b3818b48f..3fd53ad21f 100644
--- a/src/test/py/bazel/bzlmod/bazel_vendor_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_vendor_test.py
@@ -90,10 +90,10 @@ class BazelVendorTest(test_base.TestBase):
 
     # Assert repos are vendored with marker files and .vendorignore is created
     repos_vendored = os.listdir(self._test_cwd + '/vendor')
-    self.assertIn('aaa~1.0', repos_vendored)
-    self.assertIn('bbb~1.0', repos_vendored)
-    self.assertIn('@aaa~1.0.marker', repos_vendored)
-    self.assertIn('@bbb~1.0.marker', repos_vendored)
+    self.assertIn('aaa~', repos_vendored)
+    self.assertIn('bbb~', repos_vendored)
+    self.assertIn('@aaa~.marker', repos_vendored)
+    self.assertIn('@bbb~.marker', repos_vendored)
     self.assertIn('.vendorignore', repos_vendored)
 
   def testVendorFailsWithNofetch(self):
@@ -126,7 +126,7 @@ class BazelVendorTest(test_base.TestBase):
     self.RunBazel(['vendor', '--vendor_dir=vendor'])
 
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
-    repo_path = stdout[0] + '/external/aaa~1.0'
+    repo_path = stdout[0] + '/external/aaa~'
     if self.IsWindows():
       self.assertTrue(self.IsJunction(repo_path))
     else:
@@ -149,12 +149,12 @@ class BazelVendorTest(test_base.TestBase):
     self.ScratchFile('BUILD')
     # Test canonical/apparent repo names & multiple repos
     self.RunBazel(
-        ['vendor', '--vendor_dir=vendor', '--repo=@@bbb~1.0', '--repo=@my_repo']
+        ['vendor', '--vendor_dir=vendor', '--repo=@@bbb~', '--repo=@my_repo']
     )
     repos_vendored = os.listdir(self._test_cwd + '/vendor')
-    self.assertIn('bbb~1.0', repos_vendored)
-    self.assertIn('ccc~1.0', repos_vendored)
-    self.assertNotIn('aaa~1.0', repos_vendored)
+    self.assertIn('bbb~', repos_vendored)
+    self.assertIn('ccc~', repos_vendored)
+    self.assertNotIn('aaa~', repos_vendored)
 
   def testVendorInvalidRepo(self):
     # Invalid repo name (not canonical or apparent)
@@ -231,7 +231,7 @@ class BazelVendorTest(test_base.TestBase):
     )
     self.ScratchFile('BUILD')
     self.RunBazel(['vendor', '--vendor_dir=vendor'])
-    self.assertIn('aaa~1.0', os.listdir(self._test_cwd + '/vendor'))
+    self.assertIn('aaa~', os.listdir(self._test_cwd + '/vendor'))
 
     # Empty external & build with vendor
     self.RunBazel(['clean', '--expunge'])
@@ -244,7 +244,7 @@ class BazelVendorTest(test_base.TestBase):
     # Assert repo aaa in {OUTPUT_BASE}/external is a symlink (junction on
     # windows, this validates it was created from vendor and not fetched)=
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
-    repo_path = stdout[0] + '/external/aaa~1.0'
+    repo_path = stdout[0] + '/external/aaa~'
     if self.IsWindows():
       self.assertTrue(self.IsJunction(repo_path))
     else:
@@ -293,19 +293,19 @@ class BazelVendorTest(test_base.TestBase):
 
     os.makedirs(self._test_cwd + '/vendor', exist_ok=True)
     with open(self._test_cwd + '/vendor/.vendorignore', 'w') as f:
-      f.write('aaa~1.0\n')
+      f.write('aaa~\n')
 
     self.RunBazel(['vendor', '--vendor_dir=vendor'])
     repos_vendored = os.listdir(self._test_cwd + '/vendor')
 
     # Assert bbb and the regularRepo are vendored with marker files
-    self.assertIn('bbb~1.0', repos_vendored)
-    self.assertIn('@bbb~1.0.marker', repos_vendored)
+    self.assertIn('bbb~', repos_vendored)
+    self.assertIn('@bbb~.marker', repos_vendored)
     self.assertIn('_main~ext~regularRepo', repos_vendored)
     self.assertIn('@_main~ext~regularRepo.marker', repos_vendored)
 
     # Assert aaa (from .vendorignore), local and config repos are not vendored
-    self.assertNotIn('aaa~1.0', repos_vendored)
+    self.assertNotIn('aaa~', repos_vendored)
     self.assertNotIn('bazel_tools', repos_vendored)
     self.assertNotIn('local_config_platform', repos_vendored)
     self.assertNotIn('_main~ext~localRepo', repos_vendored)
@@ -378,7 +378,7 @@ class BazelVendorTest(test_base.TestBase):
         stderr,
     )
     _, stdout, _ = self.RunBazel(['info', 'output_base'])
-    self.assertFalse(os.path.islink(stdout[0] + '/external/bbb~1.0'))
+    self.assertFalse(os.path.islink(stdout[0] + '/external/bbb~'))
 
     # Assert vendoring again solves the problem
     self.RunBazel(['vendor', '--vendor_dir=vendor'])
diff --git a/src/test/py/bazel/bzlmod/bzlmod_query_test.py b/src/test/py/bazel/bzlmod/bzlmod_query_test.py
index 453cd02b17..d40eb489ec 100644
--- a/src/test/py/bazel/bzlmod/bzlmod_query_test.py
+++ b/src/test/py/bazel/bzlmod/bzlmod_query_test.py
@@ -76,7 +76,8 @@ class BzlmodQueryTest(test_base.TestBase):
         '--notool_deps',
     ])
     self.assertListEqual(
-        ['//:main', '@my_repo//:lib_aaa', '@@ccc~1.2//:lib_ccc'], stdout)
+        ['//:main', '@my_repo//:lib_aaa', '@@ccc~//:lib_ccc'], stdout
+    )
 
   def testQueryModuleRepoTransitiveDeps_consistentLabels(self):
     self.ScratchFile(
@@ -103,7 +104,7 @@ class BzlmodQueryTest(test_base.TestBase):
         '--consistent_labels',
     ])
     self.assertListEqual(
-        ['@@//:main', '@@aaa~1.0//:lib_aaa', '@@ccc~1.2//:lib_ccc'], stdout
+        ['@@//:main', '@@aaa~//:lib_aaa', '@@ccc~//:lib_ccc'], stdout
     )
 
   def testQueryModuleRepoTransitiveDeps_consistentLabels_outputPackage(self):
@@ -131,7 +132,7 @@ class BzlmodQueryTest(test_base.TestBase):
         '--consistent_labels',
         '--output=package',
     ])
-    self.assertListEqual(['@@//pkg', '@@aaa~1.0//', '@@ccc~1.2//'], stdout)
+    self.assertListEqual(['@@//pkg', '@@aaa~//', '@@ccc~//'], stdout)
 
   def testQueryModuleRepoTransitiveDeps_consistentLabels_outputBuild(self):
     self.ScratchFile(
@@ -191,7 +192,7 @@ class BzlmodQueryTest(test_base.TestBase):
     ])
     self.assertIn('Target: //:main', stdout)
     self.assertIn('Target: @my_repo//:lib_aaa', stdout)
-    self.assertIn('Target: @@ccc~1.2//:lib_ccc', stdout)
+    self.assertIn('Target: @@ccc~//:lib_ccc', stdout)
 
   def testAqueryModuleRepoTransitiveDeps_consistentLabels(self):
     self.ScratchFile(
@@ -218,8 +219,8 @@ class BzlmodQueryTest(test_base.TestBase):
         '--consistent_labels',
     ])
     self.assertIn('Target: @@//:main', stdout)
-    self.assertIn('Target: @@aaa~1.0//:lib_aaa', stdout)
-    self.assertIn('Target: @@ccc~1.2//:lib_ccc', stdout)
+    self.assertIn('Target: @@aaa~//:lib_aaa', stdout)
+    self.assertIn('Target: @@ccc~//:lib_ccc', stdout)
 
   def testCqueryModuleRepoTargetsBelow(self):
     self.ScratchFile('MODULE.bazel', [
@@ -248,7 +249,7 @@ class BzlmodQueryTest(test_base.TestBase):
     ])
     self.assertRegex(stdout[0], r'^//:main \([\w\d]+\)$')
     self.assertRegex(stdout[1], r'^@my_repo//:lib_aaa \([\w\d]+\)$')
-    self.assertRegex(stdout[2], r'^@@ccc~1.2//:lib_ccc \([\w\d]+\)$')
+    self.assertRegex(stdout[2], r'^@@ccc~//:lib_ccc \([\w\d]+\)$')
     self.assertEqual(len(stdout), 3)
 
   def testCqueryModuleRepoTransitiveDeps_consistentLabels(self):
@@ -276,8 +277,8 @@ class BzlmodQueryTest(test_base.TestBase):
         '--consistent_labels',
     ])
     self.assertRegex(stdout[0], r'^@@//:main \([\w\d]+\)$')
-    self.assertRegex(stdout[1], r'^@@aaa~1.0//:lib_aaa \([\w\d]+\)$')
-    self.assertRegex(stdout[2], r'^@@ccc~1.2//:lib_ccc \([\w\d]+\)$')
+    self.assertRegex(stdout[1], r'^@@aaa~//:lib_aaa \([\w\d]+\)$')
+    self.assertRegex(stdout[2], r'^@@ccc~//:lib_ccc \([\w\d]+\)$')
     self.assertEqual(len(stdout), 3)
 
   def testFetchModuleRepoTargetsBelow(self):
@@ -303,7 +304,7 @@ class BzlmodQueryTest(test_base.TestBase):
     self.assertIsNotNone(output_file)
     output = output_file.readlines()
     output_file.close()
-    self.assertListEqual(['@@aaa~1.0//:lib_aaa\n'], output)
+    self.assertListEqual(['@@aaa~//:lib_aaa\n'], output)
 
   def testQueryCannotResolveRepoMapping_malformedModuleFile(self):
     self.ScratchFile('MODULE.bazel', [
diff --git a/src/test/py/bazel/bzlmod/external_repo_completion_test.py b/src/test/py/bazel/bzlmod/external_repo_completion_test.py
index 5a0f1380d7..ac5f6991bd 100644
--- a/src/test/py/bazel/bzlmod/external_repo_completion_test.py
+++ b/src/test/py/bazel/bzlmod/external_repo_completion_test.py
@@ -249,12 +249,12 @@ echo ${{COMPREPLY[*]}}
 
     # Packages are completed in external repos with canonical repo names.
     self.assertCountEqual(
-        ['@@ext~1.0//tools/', '@@ext~1.0//tools:'],
-        self.complete('build @@ext~1.0//tool'),
+        ['@@ext~//tools/', '@@ext~//tools:'],
+        self.complete('build @@ext~//tool'),
     )
     self.assertCountEqual(
-        ['@@ext~1.0//tools/zip/', '@@ext~1.0//tools/zip:'],
-        self.complete('build @@ext~1.0//tools/zi'),
+        ['@@ext~//tools/zip/', '@@ext~//tools/zip:'],
+        self.complete('build @@ext~//tools/zi'),
     )
     self.assertCountEqual(
         ['@@//pkg/', '@@//pkg:'], self.complete('build @@//p')
@@ -276,7 +276,7 @@ echo ${{COMPREPLY[*]}}
     # Targets are completed in external repos with canonical repo names.
     self.assertCountEqual(['lib_foo'], self.complete('build @@foo~2.0//:'))
     self.assertCountEqual(
-        ['zipper'], self.complete('build @@ext~1.0//tools/zip:zipp')
+        ['zipper'], self.complete('build @@ext~//tools/zip:zipp')
     )
     self.assertCountEqual(['my_lib'], self.complete('build @@//pkg:my_'))
 
diff --git a/src/test/py/bazel/bzlmod/mod_command_test.py b/src/test/py/bazel/bzlmod/mod_command_test.py
index 4d29ffcf73..40e850ddb3 100644
--- a/src/test/py/bazel/bzlmod/mod_command_test.py
+++ b/src/test/py/bazel/bzlmod/mod_command_test.py
@@ -162,27 +162,27 @@ class ModCommandTest(test_base.TestBase):
         stdout,
         [
             '<root> (my_project@1.0)',
-            '|___$@@ext2~1.0//:ext.bzl%ext',
+            '|___$@@ext2~//:ext.bzl%ext',
             '|   |___repo1',
-            '|___$@@ext~1.0//:ext.bzl%ext',
+            '|___$@@ext~//:ext.bzl%ext',
             '|   |___repo1',
             '|   |...repo2',
             '|   |...repo5',
             '|___ext@1.0',
             '|___ext2@1.0',
             '|___foo@1.0',
-            '|   |___$@@ext~1.0//:ext.bzl%ext ...',
+            '|   |___$@@ext~//:ext.bzl%ext ...',
             '|   |   |___repo1',
             '|   |___ext@1.0 (*)',
             '|   |___bar@2.0',
-            '|       |___$@@ext2~1.0//:ext.bzl%ext ...',
+            '|       |___$@@ext2~//:ext.bzl%ext ...',
             '|       |   |___repo3',
-            '|       |___$@@ext~1.0//:ext.bzl%ext ...',
+            '|       |___$@@ext~//:ext.bzl%ext ...',
             '|       |   |___repo3',
             '|       |___ext@1.0 (*)',
             '|       |___ext2@1.0 (*)',
             '|___foo@2.0',
-            '    |___$@@ext~1.0//:ext.bzl%ext ...',
+            '    |___$@@ext~//:ext.bzl%ext ...',
             '    |   |___repo3',
             '    |   |___repo4',
             '    |___bar@2.0 (*)',
@@ -206,16 +206,16 @@ class ModCommandTest(test_base.TestBase):
         stdout,
         [
             '<root> (my_project@1.0)',
-            '|___$@@ext~1.0//:ext.bzl%ext',
+            '|___$@@ext~//:ext.bzl%ext',
             '|   |___repo1',
             '|___foo@1.0 #',
-            '|   |___$@@ext~1.0//:ext.bzl%ext',
+            '|   |___$@@ext~//:ext.bzl%ext',
             '|   |   |___repo1',
             '|   |___bar@2.0 #',
-            '|       |___$@@ext~1.0//:ext.bzl%ext',
+            '|       |___$@@ext~//:ext.bzl%ext',
             '|           |___repo3',
             '|___foo@2.0 #',
-            '    |___$@@ext~1.0//:ext.bzl%ext',
+            '    |___$@@ext~//:ext.bzl%ext',
             '    |   |___repo3',
             '    |   |___repo4',
             '    |___bar@2.0 (*)',
@@ -243,7 +243,7 @@ class ModCommandTest(test_base.TestBase):
     self.assertListEqual(
         stdout,
         [
-            '## @@ext~1.0//:ext.bzl%ext:',
+            '## @@ext~//:ext.bzl%ext:',
             '',
             'Fetched repositories:',
             '  - repo1 (imported by <root>, foo@1.0)',
@@ -309,7 +309,7 @@ class ModCommandTest(test_base.TestBase):
     self.assertListEqual(
         stdout,
         [
-            '## @@ext2~1.0//:ext.bzl%ext:',
+            '## @@ext2~//:ext.bzl%ext:',
             '',
             'Fetched repositories:',
             '  - repo1 (imported by <root>)',
@@ -322,7 +322,7 @@ class ModCommandTest(test_base.TestBase):
             '  my_repo2="repo3",',
             ')',
             '',
-            '## @@ext~1.0//:ext.bzl%ext:',
+            '## @@ext~//:ext.bzl%ext:',
             '',
             'Fetched repositories:',
             '  - repo1 (imported by <root>, foo@1.0)',
@@ -379,14 +379,14 @@ class ModCommandTest(test_base.TestBase):
             '## @bar_from_foo2:',
             '# <builtin>',
             'http_archive(',
-            '  name = "bar~2.0",',
+            '  name = "bar~",',
             # pop(4) -- urls=[...]
             # pop(4) -- integrity=...
             '  strip_prefix = "",',
             '  remote_patches = {},',
             '  remote_patch_strip = 0,',
             ')',
-            '# Rule bar~2.0 instantiated at (most recent call last):',
+            '# Rule bar~ instantiated at (most recent call last):',
             '#   <builtin> in <toplevel>',
             '# Rule http_archive defined at (most recent call last):',
             # pop(11)
@@ -394,19 +394,19 @@ class ModCommandTest(test_base.TestBase):
             '## ext@1.0:',
             '# <builtin>',
             'local_repository(',
-            '  name = "ext~1.0",',
+            '  name = "ext~",',
             # pop(16) -- path=...
             ')',
-            '# Rule ext~1.0 instantiated at (most recent call last):',
+            '# Rule ext~ instantiated at (most recent call last):',
             '#   <builtin> in <toplevel>',
             '',
             '## @my_repo3:',
             '# <builtin>',
             'data_repo(',
-            '  name = "ext~1.0~ext~repo3",',
+            '  name = "ext~~ext~repo3",',
             '  data = "requested repo",',
             ')',
-            '# Rule ext~1.0~ext~repo3 instantiated at (most recent call last):',
+            '# Rule ext~~ext~repo3 instantiated at (most recent call last):',
             '#   <builtin> in <toplevel>',
             '# Rule data_repo defined at (most recent call last):',
             # pop(29)
@@ -414,10 +414,10 @@ class ModCommandTest(test_base.TestBase):
             '## @my_repo4:',
             '# <builtin>',
             'data_repo(',
-            '  name = "ext~1.0~ext~repo4",',
+            '  name = "ext~~ext~repo4",',
             '  data = "requested repo",',
             ')',
-            '# Rule ext~1.0~ext~repo4 instantiated at (most recent call last):',
+            '# Rule ext~~ext~repo4 instantiated at (most recent call last):',
             '#   <builtin> in <toplevel>',
             '# Rule data_repo defined at (most recent call last):',
             # pop(39)
@@ -425,14 +425,14 @@ class ModCommandTest(test_base.TestBase):
             '## bar@2.0:',
             '# <builtin>',
             'http_archive(',
-            '  name = "bar~2.0",',
+            '  name = "bar~",',
             # pop(44) -- urls=[...]
             # pop(44) -- integrity=...
             '  strip_prefix = "",',
             '  remote_patches = {},',
             '  remote_patch_strip = 0,',
             ')',
-            '# Rule bar~2.0 instantiated at (most recent call last):',
+            '# Rule bar~ instantiated at (most recent call last):',
             '#   <builtin> in <toplevel>',
             '# Rule http_archive defined at (most recent call last):',
             # pop(51)
@@ -471,7 +471,7 @@ class ModCommandTest(test_base.TestBase):
             'my_project': '',
             'foo1': 'foo~1.0',
             'foo2': 'foo~2.0',
-            'myrepo2': 'ext2~1.0~ext~repo1',
+            'myrepo2': 'ext2~~ext~repo1',
             'bazel_tools': 'bazel_tools',
         }.items(),
         root_mapping.items(),
@@ -480,8 +480,8 @@ class ModCommandTest(test_base.TestBase):
     self.assertContainsSubset(
         {
             'foo': 'foo~2.0',
-            'ext_mod': 'ext~1.0',
-            'my_repo3': 'ext~1.0~ext~repo3',
+            'ext_mod': 'ext~',
+            'my_repo3': 'ext~~ext~repo3',
             'bazel_tools': 'bazel_tools',
         }.items(),
         foo_mapping.items(),
diff --git a/src/test/shell/bazel/bazel_determinism_test.sh b/src/test/shell/bazel/bazel_determinism_test.sh
index 0d675d56f7..ec90b701a1 100755
--- a/src/test/shell/bazel/bazel_determinism_test.sh
+++ b/src/test/shell/bazel/bazel_determinism_test.sh
@@ -72,6 +72,10 @@ function test_determinism()  {
     # Update the hash of bazel_tools in lockfile to avoid rerunning module resolution.
     new_hash=$(shasum -a 256 "src/MODULE.tools" | awk '{print $1}')
     sed -i.bak "/\"bazel_tools\":/s/\"[a-f0-9]*\"/\"$new_hash\"/" MODULE.bazel.lock
+    # TODO: Temporary hack for lockfile version mismatch, remove these lines after updating to 7.1.0
+    sed -i.bak 's/"lockFileVersion": 3/"lockFileVersion": 4/' MODULE.bazel.lock
+    # Replace canonical repository names and parts thereof of the form rules_foo~1.2.3 with rules_foo~
+    sed -i.bak -E 's/([a-z]([a-z0-9._-]*[a-z0-9]){0,1})~[a-zA-Z0-9.]{1,}(-[0-9.-]{1,}){0,1}(\+[0-9.-]{1,}){0,1}/\1/g' MODULE.bazel.lock
     rm MODULE.bazel.lock.bak
 
     # Use @bazel_tools//tools/python:autodetecting_toolchain to avoid
diff --git a/src/test/shell/bazel/python_version_test.sh b/src/test/shell/bazel/python_version_test.sh
index 9dc85ffb86..5215f36592 100755
--- a/src/test/shell/bazel/python_version_test.sh
+++ b/src/test/shell/bazel/python_version_test.sh
@@ -537,7 +537,7 @@ package_group(
     name = "allowed",
     packages = [
         "//__EXTERNAL_REPOS__/external_repo/...",
-        "//__EXTERNAL_REPOS__/external_repo~override/...",
+        "//__EXTERNAL_REPOS__/external_repo~/...",
         "//__EXTERNAL_REPOS__/bazel_tools/...",
         ##"//tools/python/windows...",
     ],
diff --git a/src/test/shell/bazel/starlark_repository_test.sh b/src/test/shell/bazel/starlark_repository_test.sh
index 12170039ec..b7df798d38 100755
--- a/src/test/shell/bazel/starlark_repository_test.sh
+++ b/src/test/shell/bazel/starlark_repository_test.sh
@@ -2643,7 +2643,7 @@ module(name="bar")
 EOF
 
   bazel build @r >& $TEST_log || fail "expected bazel to succeed"
-  expect_log "I see: @@foo~override//:data"
+  expect_log "I see: @@foo~//:data"
 
   # So far, so good. Now we make `@data` point to bar instead!
   cat > MODULE.bazel <<EOF
@@ -2656,7 +2656,7 @@ local_path_override(module_name="bar", path="bar")
 EOF
   # for the repo `r`, nothing except the repo mapping has changed.
   bazel build @r >& $TEST_log || fail "expected bazel to succeed"
-  expect_log "I see: @@bar~override//:data"
+  expect_log "I see: @@bar~//:data"
 }
 
 function test_repo_mapping_change_in_bzl_init() {
@@ -2688,7 +2688,7 @@ module(name="bar")
 EOF
 
   bazel build @r >& $TEST_log || fail "expected bazel to succeed"
-  expect_log "I see: @@foo~override//:data"
+  expect_log "I see: @@foo~//:data"
 
   # So far, so good. Now we make `@data` point to bar instead!
   cat > MODULE.bazel <<EOF
@@ -2701,7 +2701,7 @@ local_path_override(module_name="bar", path="bar")
 EOF
   # for the repo `r`, nothing except the repo mapping has changed.
   bazel build @r >& $TEST_log || fail "expected bazel to succeed"
-  expect_log "I see: @@bar~override//:data"
+  expect_log "I see: @@bar~//:data"
 }
 
 run_suite "local repository tests"
diff --git a/src/test/tools/bzlmod/MODULE.bazel.lock b/src/test/tools/bzlmod/MODULE.bazel.lock
index 940e25521d..b8c8061982 100644
--- a/src/test/tools/bzlmod/MODULE.bazel.lock
+++ b/src/test/tools/bzlmod/MODULE.bazel.lock
@@ -1,5 +1,5 @@
 {
-  "lockFileVersion": 3,
+  "lockFileVersion": 4,
   "moduleFileHash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
   "flags": {
     "cmdRegistries": [
@@ -1034,26 +1034,26 @@
     }
   },
   "moduleExtensions": {
-    "@@apple_support~1.5.0//crosstool:setup.bzl%apple_cc_configure_extension": {
+    "@@apple_support~//crosstool:setup.bzl%apple_cc_configure_extension": {
       "general": {
         "bzlTransitiveDigest": "pMLFCYaRPkgXPQ8vtuNkMfiHfPmRBy6QJfnid4sWfv0=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
           "local_config_apple_cc": {
-            "bzlFile": "@@apple_support~1.5.0//crosstool:setup.bzl",
+            "bzlFile": "@@apple_support~//crosstool:setup.bzl",
             "ruleClassName": "_apple_cc_autoconf",
             "attributes": {}
           },
           "local_config_apple_cc_toolchains": {
-            "bzlFile": "@@apple_support~1.5.0//crosstool:setup.bzl",
+            "bzlFile": "@@apple_support~//crosstool:setup.bzl",
             "ruleClassName": "_apple_cc_autoconf_toolchains",
             "attributes": {}
           }
         },
         "recordedRepoMappingEntries": [
           [
-            "apple_support~1.5.0",
+            "apple_support~",
             "bazel_tools",
             "bazel_tools"
           ]
@@ -1165,14 +1165,14 @@
         "recordedRepoMappingEntries": []
       }
     },
-    "@@buildozer~6.4.0.2//:buildozer_binary.bzl%buildozer_binary": {
+    "@@buildozer~//:buildozer_binary.bzl%buildozer_binary": {
       "general": {
         "bzlTransitiveDigest": "EleDU/FQ1+e/RgkW3aIDmdaxZEthvoWQhsqFTxiSgMI=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
           "buildozer_binary": {
-            "bzlFile": "@@buildozer~6.4.0.2//private:buildozer_binary.bzl",
+            "bzlFile": "@@buildozer~//private:buildozer_binary.bzl",
             "ruleClassName": "_buildozer_binary_repo",
             "attributes": {
               "sha256": {
@@ -1189,42 +1189,42 @@
         "recordedRepoMappingEntries": []
       }
     },
-    "@@rules_java~7.3.2//java:extensions.bzl%toolchains": {
+    "@@rules_java~//java:extensions.bzl%toolchains": {
       "general": {
         "bzlTransitiveDigest": "Bm4ulErUcJjZtKeAt2etkB6sGO8evCgHQxbw4Px8q60=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
           "remotejdk21_linux_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_21\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"21\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_linux//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_linux//:jdk\",\n)\n"
             }
           },
           "remotejdk17_linux_s390x_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:s390x\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_s390x//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:s390x\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_s390x//:jdk\",\n)\n"
             }
           },
           "remotejdk17_macos_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_macos//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_macos//:jdk\",\n)\n"
             }
           },
           "remotejdk21_macos_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_21\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"21\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_macos_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_macos_aarch64//:jdk\",\n)\n"
             }
           },
           "remotejdk17_linux_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_aarch64//:jdk\",\n)\n"
@@ -1244,7 +1244,7 @@
             }
           },
           "remotejdk17_linux_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux//:jdk\",\n)\n"
@@ -1288,7 +1288,7 @@
             }
           },
           "remotejdk11_win_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_win//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_win//:jdk\",\n)\n"
@@ -1321,14 +1321,14 @@
             }
           },
           "remotejdk11_linux_s390x_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:s390x\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_s390x//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:s390x\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_s390x//:jdk\",\n)\n"
             }
           },
           "remotejdk11_linux_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux//:jdk\",\n)\n"
@@ -1386,14 +1386,14 @@
             }
           },
           "remotejdk21_macos_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_21\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"21\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_macos//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_macos//:jdk\",\n)\n"
             }
           },
           "remotejdk17_macos_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_macos_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_macos_aarch64//:jdk\",\n)\n"
@@ -1413,14 +1413,14 @@
             }
           },
           "remotejdk11_macos_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_macos_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_macos_aarch64//:jdk\",\n)\n"
             }
           },
           "remotejdk11_linux_ppc64le_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:ppc\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_ppc64le//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:ppc\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_ppc64le//:jdk\",\n)\n"
@@ -1477,7 +1477,7 @@
             }
           },
           "remotejdk11_linux_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_linux_aarch64//:jdk\",\n)\n"
@@ -1510,7 +1510,7 @@
             }
           },
           "remotejdk17_win_arm64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:arm64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_win_arm64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:arm64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_win_arm64//:jdk\",\n)\n"
@@ -1530,14 +1530,14 @@
             }
           },
           "remotejdk11_macos_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_macos//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:macos\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_macos//:jdk\",\n)\n"
             }
           },
           "remotejdk17_linux_ppc64le_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:ppc\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_ppc64le//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:ppc\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_linux_ppc64le//:jdk\",\n)\n"
@@ -1581,21 +1581,21 @@
             }
           },
           "remotejdk21_linux_aarch64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_21\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"21\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_linux_aarch64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:linux\", \"@platforms//cpu:aarch64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_linux_aarch64//:jdk\",\n)\n"
             }
           },
           "remotejdk11_win_arm64_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_11\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"11\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:arm64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_win_arm64//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:arm64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk11_win_arm64//:jdk\",\n)\n"
             }
           },
           "local_jdk": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:local_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:local_java_repository.bzl",
             "ruleClassName": "_local_java_repository_rule",
             "attributes": {
               "java_home": "",
@@ -1639,7 +1639,7 @@
             }
           },
           "remotejdk17_win_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_17\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"17\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_win//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk17_win//:jdk\",\n)\n"
@@ -1672,7 +1672,7 @@
             }
           },
           "remotejdk21_win_toolchain_config_repo": {
-            "bzlFile": "@@rules_java~7.3.2//toolchains:remote_java_repository.bzl",
+            "bzlFile": "@@rules_java~//toolchains:remote_java_repository.bzl",
             "ruleClassName": "_toolchain_config",
             "attributes": {
               "build_file": "\nconfig_setting(\n    name = \"prefix_version_setting\",\n    values = {\"java_runtime_version\": \"remotejdk_21\"},\n    visibility = [\"//visibility:private\"],\n)\nconfig_setting(\n    name = \"version_setting\",\n    values = {\"java_runtime_version\": \"21\"},\n    visibility = [\"//visibility:private\"],\n)\nalias(\n    name = \"version_or_prefix_version_setting\",\n    actual = select({\n        \":version_setting\": \":version_setting\",\n        \"//conditions:default\": \":prefix_version_setting\",\n    }),\n    visibility = [\"//visibility:private\"],\n)\ntoolchain(\n    name = \"toolchain\",\n    target_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_win//:jdk\",\n)\ntoolchain(\n    name = \"bootstrap_runtime_toolchain\",\n    # These constraints are not required for correctness, but prevent fetches of remote JDK for\n    # different architectures. As every Java compilation toolchain depends on a bootstrap runtime in\n    # the same configuration, this constraint will not result in toolchain resolution failures.\n    exec_compatible_with = [\"@platforms//os:windows\", \"@platforms//cpu:x86_64\"],\n    target_settings = [\":version_or_prefix_version_setting\"],\n    toolchain_type = \"@bazel_tools//tools/jdk:bootstrap_runtime_toolchain_type\",\n    toolchain = \"@remotejdk21_win//:jdk\",\n)\n"
@@ -1681,23 +1681,23 @@
         },
         "recordedRepoMappingEntries": [
           [
-            "rules_java~7.3.2",
+            "rules_java~",
             "bazel_tools",
             "bazel_tools"
           ],
           [
-            "rules_java~7.3.2",
+            "rules_java~",
             "remote_java_tools",
-            "rules_java~7.3.2~toolchains~remote_java_tools"
+            "rules_java~~toolchains~remote_java_tools"
           ]
         ]
       }
     },
-    "@@rules_jvm_external~4.4.2//:extensions.bzl%maven": {
+    "@@rules_jvm_external~//:extensions.bzl%maven": {
       "general": {
         "bzlTransitiveDigest": "yXprMX4LqzJwuZlbtT9WNeu7p2iEYw7j4R1NP9pc4Ow=",
         "accumulatedFileDigests": {
-          "@@rules_jvm_external~4.4.2//:rules_jvm_external_deps_install.json": "10442a5ae27d9ff4c2003e5ab71643bf0d8b48dcf968b4173fa274c3232a8c06"
+          "@@rules_jvm_external~//:rules_jvm_external_deps_install.json": "10442a5ae27d9ff4c2003e5ab71643bf0d8b48dcf968b4173fa274c3232a8c06"
         },
         "envVariables": {},
         "generatedRepoSpecs": {
@@ -1954,7 +1954,7 @@
             }
           },
           "rules_jvm_external_deps": {
-            "bzlFile": "@@rules_jvm_external~4.4.2//:coursier.bzl",
+            "bzlFile": "@@rules_jvm_external~//:coursier.bzl",
             "ruleClassName": "pinned_coursier_fetch",
             "attributes": {
               "repositories": [
@@ -1970,7 +1970,7 @@
               "fetch_sources": true,
               "fetch_javadoc": false,
               "generate_compat_repositories": false,
-              "maven_install_json": "@@rules_jvm_external~4.4.2//:rules_jvm_external_deps_install.json",
+              "maven_install_json": "@@rules_jvm_external~//:rules_jvm_external_deps_install.json",
               "override_targets": {},
               "strict_visibility": false,
               "strict_visibility_value": [
@@ -2048,7 +2048,7 @@
             }
           },
           "maven": {
-            "bzlFile": "@@rules_jvm_external~4.4.2//:coursier.bzl",
+            "bzlFile": "@@rules_jvm_external~//:coursier.bzl",
             "ruleClassName": "coursier_fetch",
             "attributes": {
               "repositories": [
@@ -2316,7 +2316,7 @@
             }
           },
           "unpinned_rules_jvm_external_deps": {
-            "bzlFile": "@@rules_jvm_external~4.4.2//:coursier.bzl",
+            "bzlFile": "@@rules_jvm_external~//:coursier.bzl",
             "ruleClassName": "coursier_fetch",
             "attributes": {
               "repositories": [
@@ -2341,7 +2341,7 @@
               "strict_visibility_value": [
                 "@@//visibility:private"
               ],
-              "maven_install_json": "@@rules_jvm_external~4.4.2//:rules_jvm_external_deps_install.json",
+              "maven_install_json": "@@rules_jvm_external~//:rules_jvm_external_deps_install.json",
               "resolve_timeout": 600,
               "jetify": false,
               "jetify_include_list": [
@@ -2703,19 +2703,19 @@
         },
         "recordedRepoMappingEntries": [
           [
-            "rules_jvm_external~4.4.2",
+            "rules_jvm_external~",
             "bazel_tools",
             "bazel_tools"
           ],
           [
-            "rules_jvm_external~4.4.2",
+            "rules_jvm_external~",
             "rules_jvm_external",
-            "rules_jvm_external~4.4.2"
+            "rules_jvm_external~"
           ]
         ]
       }
     },
-    "@@rules_jvm_external~4.4.2//:non-module-deps.bzl%non_module_deps": {
+    "@@rules_jvm_external~//:non-module-deps.bzl%non_module_deps": {
       "general": {
         "bzlTransitiveDigest": "Td87llNSs5GZ/kAxu6pAqfEXBZ3HdkSqRmUzvIfbFWg=",
         "accumulatedFileDigests": {},
@@ -2734,21 +2734,21 @@
         },
         "recordedRepoMappingEntries": [
           [
-            "rules_jvm_external~4.4.2",
+            "rules_jvm_external~",
             "bazel_tools",
             "bazel_tools"
           ]
         ]
       }
     },
-    "@@rules_python~0.22.1//python/extensions:python.bzl%python": {
+    "@@rules_python~//python/extensions:python.bzl%python": {
       "general": {
         "bzlTransitiveDigest": "NGtTMUqs2EEJeXu6mXdpmYRrQGZiJV7S3mxeod3Hm7M=",
         "accumulatedFileDigests": {},
         "envVariables": {},
         "generatedRepoSpecs": {
           "pythons_hub": {
-            "bzlFile": "@@rules_python~0.22.1//python/extensions/private:interpreter_hub.bzl",
+            "bzlFile": "@@rules_python~//python/extensions/private:interpreter_hub.bzl",
             "ruleClassName": "hub_repo",
             "attributes": {
               "toolchains": []
@@ -2757,19 +2757,19 @@
         },
         "recordedRepoMappingEntries": [
           [
-            "rules_python~0.22.1",
+            "rules_python~",
             "bazel_tools",
             "bazel_tools"
           ],
           [
-            "rules_python~0.22.1",
+            "rules_python~",
             "rules_python",
-            "rules_python~0.22.1"
+            "rules_python~"
           ]
         ]
       }
     },
-    "@@rules_python~0.22.1//python/extensions/private:internal_deps.bzl%internal_deps": {
+    "@@rules_python~//python/extensions/private:internal_deps.bzl%internal_deps": {
       "general": {
         "bzlTransitiveDigest": "5c1tkdV6L67SQOZWc9MUoS5ZnsSxeDKsh9urs01jZSM=",
         "accumulatedFileDigests": {},
@@ -2784,7 +2784,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "95203854f974e07af96358c0b261f1048d8e1083f2de9b1c565e1be4a3a48cfc",
               "type": "zip",
@@ -2802,7 +2802,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "6c4459b3de97b75e3bd6b7d4b7f0db13f17f504f3d13e2a7c623786289dd670e",
               "type": "zip",
@@ -2830,7 +2830,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "af4fffaffc4067232253715065e30c5a7ec6faac36f8fc8d6f64263b15f74db0",
               "type": "zip",
@@ -2848,7 +2848,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "4a5375e28c5191ac38cca59b38edd33ef4cc914732c916f2929029b4bfb50795",
               "type": "zip",
@@ -2866,7 +2866,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "b4a5be1748d538a710f87542f22c2cad22f80545a847ad91ce45e77417293eb4",
               "type": "zip",
@@ -2884,7 +2884,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "b9023e237f4c02ff739581ef35969c3739445fb059b060ca51771e69101efffe",
               "type": "zip",
@@ -2902,7 +2902,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "784f53ebc9f3fd0e2a3f6a78b2be1bd1f5575d7863e10c6e12504f240fd06660",
               "type": "zip",
@@ -2930,7 +2930,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "d900bb429fdfd7f511f868cedd03a6bbb142f3f9118c09b99ef8dc9bf9643c3c",
               "type": "zip",
@@ -2948,7 +2948,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "a8fb6cf131ac4070c9c5a3e21de0f7dc5a0fbe8bc77c9456ced896c12fcdad91",
               "type": "zip",
@@ -2976,7 +2976,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "633713d70ad6bfc49b34ead4060531658dc6dfc9b3eb7d8a716d5873377ab745",
               "type": "zip",
@@ -3004,7 +3004,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "c4ed2820d919351f4167e52425e096af41bfabacb1857186c1ea32ff9983ed75",
               "type": "zip",
@@ -3032,7 +3032,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "8f830ed581b45b82451a40faabb89c84e1a998124ee4212d440e9c6cf70083e5",
               "type": "zip",
@@ -3070,7 +3070,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "6b07130585d54fe8dff3d97b93b0e20290de974dc8177c320aeaf23459219c0b",
               "type": "zip",
@@ -3088,7 +3088,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "2198ea6fc548de52adc826f62cb18554caedfb1d26548c1b7c88d8f7faa8f6ba",
               "type": "zip",
@@ -3156,7 +3156,7 @@
                 "-p1"
               ],
               "patches": [
-                "@@rules_python~0.22.1//python/private:coverage.patch"
+                "@@rules_python~//python/private:coverage.patch"
               ],
               "sha256": "ef8674b0ee8cc11e2d574e3e2998aea5df5ab242e012286824ea3c6970580e53",
               "type": "zip",
@@ -3188,19 +3188,19 @@
         },
         "recordedRepoMappingEntries": [
           [
-            "rules_python~0.22.1",
+            "rules_python~",
             "bazel_skylib",
-            "bazel_skylib~1.3.0"
+            "bazel_skylib~"
           ],
           [
-            "rules_python~0.22.1",
+            "rules_python~",
             "bazel_tools",
             "bazel_tools"
           ],
           [
-            "rules_python~0.22.1",
+            "rules_python~",
             "rules_python",
-            "rules_python~0.22.1"
+            "rules_python~"
           ]
         ]
       }
diff --git a/src/tools/bzlmod/utils.bzl b/src/tools/bzlmod/utils.bzl
index 97860967e2..f504a622b6 100644
--- a/src/tools/bzlmod/utils.bzl
+++ b/src/tools/bzlmod/utils.bzl
@@ -75,7 +75,7 @@ def parse_http_artifacts(ctx, lockfile_path, required_repos):
 
     for extension_id, extension_entry in lockfile["moduleExtensions"].items():
         if extension_id.startswith("@@"):
-            # @@rules_foo~1.2.3//:extensions.bzl%foo --> rules_foo~1.2.3
+            # @@rules_foo~//:extensions.bzl%foo --> rules_foo~
             module_repo_name = extension_id.removeprefix("@@").partition("//")[0]
         else:
             # //:extensions.bzl%foo --> _main
