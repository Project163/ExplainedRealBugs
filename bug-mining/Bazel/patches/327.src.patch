diff --git a/site/en/external/lockfile.md b/site/en/external/lockfile.md
index 6a4a600ca7..8e3e3f94da 100644
--- a/site/en/external/lockfile.md
+++ b/site/en/external/lockfile.md
@@ -70,6 +70,16 @@ The lockfile offers several benefits and can be utilized in various ways:
     preventing unexpected updates or breaking changes in external libraries. By
     locking the dependencies to specific versions, the risk of introducing bugs
     due to incompatible or untested updates is reduced.
+-
+
+### Hidden lockfile {:#hidden-lockfile}
+
+Bazel also maintains another lockfile at
+`"$(bazel info output_base)"/MODULE.bazel.lock`. The format and contents of this
+lockfile are explicitly unspecified. It is only used as a performance
+optimization. While it can be deleted together with the output base via
+`bazel clean --expunge`, any need to do so is a bug in either Bazel itself or a
+module extension.
 
 ## Lockfile Contents {:#lockfile-contents}
 
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java b/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
index abfc624447..2a00431bd8 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
@@ -268,7 +268,8 @@ public class BazelRepositoryModule extends BlazeModule {
         .addSkyFunction(SkyFunctions.MODULE_FILE, moduleFileFunction)
         .addSkyFunction(SkyFunctions.BAZEL_DEP_GRAPH, new BazelDepGraphFunction())
         .addSkyFunction(
-            SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(directories.getWorkspace()))
+            SkyFunctions.BAZEL_LOCK_FILE,
+            new BazelLockFileFunction(directories.getWorkspace(), directories.getOutputBase()))
         .addSkyFunction(SkyFunctions.BAZEL_FETCH_ALL, new BazelFetchAllFunction())
         .addSkyFunction(SkyFunctions.BAZEL_MOD_TIDY, new BazelModTidyFunction())
         .addSkyFunction(SkyFunctions.BAZEL_MODULE_INSPECTION, new BazelModuleInspectorFunction())
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileFunction.java
index c89d830af4..aa0db3bb16 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileFunction.java
@@ -41,7 +41,11 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 
-/** Reads the contents of the lock file into its value. */
+/**
+ * Reads the contents of the lockfiles into {@link BazelLockFileValue}s.
+ *
+ * <p>See {@link BazelLockFileValue} for more information.
+ */
 public class BazelLockFileFunction implements SkyFunction {
 
   public static final Precomputed<LockfileMode> LOCKFILE_MODE = new Precomputed<>("lockfile_mode");
@@ -52,32 +56,43 @@ public class BazelLockFileFunction implements SkyFunction {
   private static final Pattern POSSIBLE_MERGE_CONFLICT_PATTERN =
       Pattern.compile("<<<<<<<|=======|" + Pattern.quote("|||||||") + "|>>>>>>>");
 
-  private static final BazelLockFileValue EMPTY_LOCKFILE = BazelLockFileValue.builder().build();
-
   private final Path rootDirectory;
+  private final Path outputBase;
 
-  public BazelLockFileFunction(Path rootDirectory) {
+  public BazelLockFileFunction(Path rootDirectory, Path outputBase) {
     this.rootDirectory = rootDirectory;
+    this.outputBase = outputBase;
   }
 
   @Override
   @Nullable
   public SkyValue compute(SkyKey skyKey, Environment env)
       throws BazelLockfileFunctionException, InterruptedException {
+    boolean forHiddenLockfile = skyKey == BazelLockFileValue.HIDDEN_KEY;
     RootedPath lockfilePath =
-        RootedPath.toRootedPath(Root.fromPath(rootDirectory), LabelConstants.MODULE_LOCKFILE_NAME);
+        RootedPath.toRootedPath(
+            Root.fromPath(forHiddenLockfile ? outputBase : rootDirectory),
+            LabelConstants.MODULE_LOCKFILE_NAME);
 
     // Add dependency on the lockfile to recognize changes to it
     if (env.getValue(FileValue.key(lockfilePath)) == null) {
       return null;
     }
 
-    try (SilentCloseable c = Profiler.instance().profile(ProfilerTask.BZLMOD, "parse lockfile")) {
-      return getLockfileValue(lockfilePath, LOCKFILE_MODE.get(env));
+    try (SilentCloseable c =
+        Profiler.instance()
+            .profile(
+                ProfilerTask.BZLMOD,
+                forHiddenLockfile ? "parse hidden lockfile" : "parse lockfile")) {
+      return getLockfileValue(
+          lockfilePath, forHiddenLockfile ? LockfileMode.UPDATE : LOCKFILE_MODE.get(env));
     } catch (IOException
         | JsonSyntaxException
         | NullPointerException
         | IllegalArgumentException e) {
+      if (forHiddenLockfile) {
+        return BazelLockFileValue.EMPTY_LOCKFILE;
+      }
       String actionSuffix;
       if (POSSIBLE_MERGE_CONFLICT_PATTERN.matcher(e.getMessage()).find()) {
         actionSuffix =
@@ -116,10 +131,10 @@ public class BazelLockFileFunction implements SkyFunction {
                       + " lockfile."),
               Transience.PERSISTENT);
         }
-        return EMPTY_LOCKFILE;
+        return BazelLockFileValue.EMPTY_LOCKFILE;
       }
     } catch (FileNotFoundException e) {
-      return EMPTY_LOCKFILE;
+      return BazelLockFileValue.EMPTY_LOCKFILE;
     }
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
index 43b1cfb9b7..e10a64f4c5 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
@@ -50,6 +50,7 @@ public class BazelLockFileModule extends BlazeModule {
 
   private SkyframeExecutor executor;
   private Path workspaceRoot;
+  private Path outputBase;
   private LockfileMode optionsLockfileMode;
 
   private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
@@ -61,15 +62,18 @@ public class BazelLockFileModule extends BlazeModule {
   public void beforeCommand(CommandEnvironment env) {
     executor = env.getSkyframeExecutor();
     workspaceRoot = env.getWorkspace();
+    outputBase = env.getOutputBase();
     optionsLockfileMode = env.getOptions().getOptions(RepositoryOptions.class).lockfileMode;
   }
 
   @Override
+  @SuppressWarnings("AllowVirtualThreads")
   public void afterCommand() {
     MemoizingEvaluator evaluator = executor.getEvaluator();
     BazelModuleResolutionValue moduleResolutionValue;
     BazelDepGraphValue depGraphValue;
     BazelLockFileValue oldLockfile;
+    BazelLockFileValue oldHiddenLockfile;
     try {
       PrecomputedValue lockfileModeValue =
           (PrecomputedValue) evaluator.getExistingValue(LOCKFILE_MODE.getKey());
@@ -89,15 +93,21 @@ public class BazelLockFileModule extends BlazeModule {
           (BazelModuleResolutionValue) evaluator.getExistingValue(BazelModuleResolutionValue.KEY);
       depGraphValue = (BazelDepGraphValue) evaluator.getExistingValue(BazelDepGraphValue.KEY);
       oldLockfile = (BazelLockFileValue) evaluator.getExistingValue(BazelLockFileValue.KEY);
+      oldHiddenLockfile =
+          (BazelLockFileValue) evaluator.getExistingValue(BazelLockFileValue.HIDDEN_KEY);
     } catch (InterruptedException e) {
       // Not thrown in Bazel.
       throw new IllegalStateException(e);
     }
     if (moduleResolutionValue == null || depGraphValue == null || oldLockfile == null) {
-      // An error during the actual build prevented the evaluation of these values and has already
-      // been reported at this point.
+      // Since these values are required to compute the main repo mapping, which happens in every
+      // build, an error must have occurred that prevented the evaluation of these values and that
+      // has already been reported at this point.
       return;
     }
+    if (oldHiddenLockfile == null) {
+      oldHiddenLockfile = BazelLockFileValue.EMPTY_LOCKFILE;
+    }
 
     // All nodes corresponding to module extensions that have been evaluated in the current build
     // are done at this point. Look up entries by eval keys to record results even if validation
@@ -120,34 +130,74 @@ public class BazelLockFileModule extends BlazeModule {
                 newExtensionInfos.put(key.argument(), value.lockFileInfo().get());
               }
             });
-    var combinedExtensionInfos =
-        combineModuleExtensions(
-            oldLockfile.getModuleExtensions(),
-            newExtensionInfos,
-            /* hasUsages= */ depGraphValue.getExtensionUsagesTable()::containsRow);
-
-    // Create an updated version of the lockfile, keeping only the extension results from the old
-    // lockfile that are still up-to-date and adding the newly resolved extension results.
-    BazelLockFileValue newLockfile =
-        BazelLockFileValue.builder()
-            .setRegistryFileHashes(
-                ImmutableSortedMap.copyOf(moduleResolutionValue.getRegistryFileHashes()))
-            .setSelectedYankedVersions(moduleResolutionValue.getSelectedYankedVersions())
-            .setModuleExtensions(combinedExtensionInfos)
-            .build();
-
-    // Write the new value to the file, but only if needed. This is not just a performance
-    // optimization: whenever the lockfile is updated, most Skyframe nodes will be marked as dirty
-    // on the next build, which breaks commands such as `bazel config` that rely on
-    // com.google.devtools.build.skyframe.MemoizingEvaluator#getDoneValues.
-    if (!newLockfile.equals(oldLockfile)) {
-      updateLockfile(workspaceRoot, newLockfile);
+
+    Thread updateLockfile =
+        Thread.startVirtualThread(
+            () -> {
+              var notReproducibleExtensionInfos =
+                  combineModuleExtensions(
+                      oldLockfile.getModuleExtensions(),
+                      newExtensionInfos,
+                      /* hasUsages= */ depGraphValue.getExtensionUsagesTable()::containsRow,
+                      /* reproducible= */ false);
+
+              // Create an updated version of the lockfile, keeping only the extension results from
+              // the old lockfile that are still up-to-date and adding the newly resolved
+              // extension results, as long as any of them are not known to be reproducible.
+              BazelLockFileValue newLockfile =
+                  BazelLockFileValue.builder()
+                      .setRegistryFileHashes(
+                          ImmutableSortedMap.copyOf(moduleResolutionValue.getRegistryFileHashes()))
+                      .setSelectedYankedVersions(moduleResolutionValue.getSelectedYankedVersions())
+                      .setModuleExtensions(notReproducibleExtensionInfos)
+                      .build();
+
+              // Write the new values to the files, but only if needed. This is not just a
+              // performance optimization: whenever the lockfile is updated, most Skyframe nodes
+              // will be marked as dirty on the next build, which breaks commands such as `bazel
+              // config` that rely on
+              // com.google.devtools.build.skyframe.MemoizingEvaluator#getDoneValues.
+              if (!newLockfile.equals(oldLockfile)) {
+                updateLockfile(workspaceRoot, newLockfile);
+              }
+            });
+
+    final BazelLockFileValue oldHiddenLockfileFinal = oldHiddenLockfile;
+    Thread updateHiddenLockfile =
+        Thread.startVirtualThread(
+            () -> {
+              // Results of reproducible extensions do not need to be stored for reproducibility,
+              // but avoiding reevaluations on server startups helps cold build performance.
+              var reproducibleExtensionInfos =
+                  combineModuleExtensions(
+                      oldHiddenLockfileFinal.getModuleExtensions(),
+                      newExtensionInfos,
+                      /* hasUsages= */ depGraphValue.getExtensionUsagesTable()::containsRow,
+                      /* reproducible= */ true);
+              BazelLockFileValue newHiddenLockfile =
+                  BazelLockFileValue.builder()
+                      .setSelectedYankedVersions(ImmutableMap.of())
+                      .setModuleExtensions(reproducibleExtensionInfos)
+                      .build();
+
+              if (!newHiddenLockfile.equals(oldHiddenLockfileFinal)) {
+                updateLockfile(outputBase, newHiddenLockfile);
+              }
+            });
+
+    try {
+      updateLockfile.join();
+      updateHiddenLockfile.join();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      logger.atSevere().withCause(e).log(
+          "Interrupted while updating MODULE.bazel.lock file: %s", e.getMessage());
     }
   }
 
   /**
-   * Combines the old extensions stored in the lockfile -if they are still valid- with the new
-   * extensions from the events (if any)
+   * Combines the old extensions stored in the lockfile -if they are still used and have the same
+   * dependence on os/arch - with the new extensions from the events (if any)
    */
   @VisibleForTesting
   static ImmutableMap<
@@ -156,12 +206,13 @@ public class BazelLockFileModule extends BlazeModule {
           Map<ModuleExtensionId, ImmutableMap<ModuleExtensionEvalFactors, LockFileModuleExtension>>
               oldExtensionInfos,
           Map<ModuleExtensionId, LockFileModuleExtension.WithFactors> newExtensionInfos,
-          Predicate<ModuleExtensionId> hasUsages) {
+          Predicate<ModuleExtensionId> hasUsages,
+          boolean reproducible) {
     Map<ModuleExtensionId, ImmutableMap<ModuleExtensionEvalFactors, LockFileModuleExtension>>
         updatedExtensionMap = new HashMap<>();
 
     // Keep those per factor extension results that are still used according to the static
-    // information given in the extension declaration (dependence on os and arch, reproducibility).
+    // information given in the extension declaration (dependence on os and arch).
     // Other information such as transitive .bzl hash and usages hash are *not* checked here.
     for (var entry : oldExtensionInfos.entrySet()) {
       var moduleExtensionId = entry.getKey();
@@ -176,26 +227,24 @@ public class BazelLockFileModule extends BlazeModule {
         continue;
       }
       var newFactors = newExtensionInfo.extensionFactors();
-      // Factor results can be individually marked as reproducible and should be dropped if so.
-      ImmutableSortedMap<ModuleExtensionEvalFactors, LockFileModuleExtension>
-          perFactorResultsToKeep =
-              ImmutableSortedMap.copyOf(
-                  Maps.filterKeys(
-                      entry.getValue(),
-                      existingFactors ->
-                          newFactors.hasSameDependenciesAs(existingFactors)
-                              && !(newFactors.equals(existingFactors)
-                                  && newExtensionInfo.moduleExtension().isReproducible())));
-      if (perFactorResultsToKeep.isEmpty()) {
+      // Prefer the new result for its particular set of factors.
+      var perFactorsResultsToKeep =
+          ImmutableSortedMap.copyOf(
+              Maps.filterKeys(
+                  entry.getValue(),
+                  oldFactors ->
+                      oldFactors.hasSameDependenciesAs(newFactors)
+                          && !oldFactors.equals(newFactors)));
+      if (perFactorsResultsToKeep.isEmpty()) {
         continue;
       }
-      updatedExtensionMap.put(moduleExtensionId, perFactorResultsToKeep);
+      updatedExtensionMap.put(moduleExtensionId, perFactorsResultsToKeep);
     }
 
     // Add the new resolved extensions
     for (var extensionIdAndInfo : newExtensionInfos.entrySet()) {
       LockFileModuleExtension extension = extensionIdAndInfo.getValue().moduleExtension();
-      if (extension.isReproducible()) {
+      if (extension.isReproducible() != reproducible) {
         continue;
       }
 
@@ -206,7 +255,7 @@ public class BazelLockFileModule extends BlazeModule {
         // extension exists, add the new entry to the existing map
         extensionEntries =
             ImmutableSortedMap.copyOf(
-                new ImmutableMap.Builder<ModuleExtensionEvalFactors, LockFileModuleExtension>()
+                ImmutableMap.<ModuleExtensionEvalFactors, LockFileModuleExtension>builder()
                     .putAll(oldExtensionEntries)
                     .put(factors, extension)
                     .buildKeepingLast());
@@ -227,12 +276,12 @@ public class BazelLockFileModule extends BlazeModule {
   /**
    * Updates the data stored in the lockfile (MODULE.bazel.lock)
    *
-   * @param workspaceRoot Root of the workspace where the lockfile is located
+   * @param lockfileRoot Root under which the lockfile is located
    * @param updatedLockfile The updated lockfile data to save
    */
-  private static void updateLockfile(Path workspaceRoot, BazelLockFileValue updatedLockfile) {
+  private static void updateLockfile(Path lockfileRoot, BazelLockFileValue updatedLockfile) {
     RootedPath lockfilePath =
-        RootedPath.toRootedPath(Root.fromPath(workspaceRoot), LabelConstants.MODULE_LOCKFILE_NAME);
+        RootedPath.toRootedPath(Root.fromPath(lockfileRoot), LabelConstants.MODULE_LOCKFILE_NAME);
     try {
       FileSystemUtils.writeContent(
           lockfilePath.asPath(),
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
index 6c4cc73938..6cd5aa2116 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
@@ -20,15 +20,24 @@ import com.google.common.collect.ImmutableMap;
 import com.google.devtools.build.lib.bazel.repository.downloader.Checksum;
 import com.google.devtools.build.lib.skyframe.SkyFunctions;
 import com.google.devtools.build.lib.skyframe.serialization.autocodec.SerializationConstant;
+import com.google.devtools.build.skyframe.SkyFunctionName;
 import com.google.devtools.build.skyframe.SkyKey;
 import com.google.devtools.build.skyframe.SkyValue;
 import com.ryanharter.auto.value.gson.GenerateTypeAdapter;
 import java.util.Optional;
 
 /**
- * The result of reading the lockfile. Contains the lockfile version, module hash, definitions of
- * module repositories, post-resolution dependency graph and module extensions data (ID, hash,
- * definition, usages)
+ * The result of reading a lockfile. Contains the lockfile version as well as registry and module
+ * extensions data (ID, usages hash, generated repos, ...).
+ *
+ * <p>Bazel maintains two separate lockfiles:
+ *
+ * <ul>
+ *   <li>the (regular) lockfile stored as MODULE.bazel.lock under the workspace directory;
+ *   <li>the hidden lockfile stored as MODULE.bazel.lock under the output base.
+ * </ul>
+ *
+ * See the javadoc of the two {@link SkyKey}s for more information.
  */
 @AutoValue
 @GenerateTypeAdapter
@@ -40,7 +49,62 @@ public abstract class BazelLockFileValue implements SkyValue {
   // keep this number even).
   public static final int LOCK_FILE_VERSION = 20;
 
-  @SerializationConstant public static final SkyKey KEY = () -> SkyFunctions.BAZEL_LOCK_FILE;
+  /** A valid empty lockfile. */
+  public static final BazelLockFileValue EMPTY_LOCKFILE = builder().build();
+
+  /**
+   * The (regular) lockfile, stored as MODULE.bazel.lock under the workspace directory. This file is
+   * visible to the user and meant to be committed to source control. Thus, it
+   *
+   * <ul>
+   *   <li>should only contain the minimal amount of information necessary to make module resolution
+   *       and module extension evaluation deterministic;
+   *   <li>should be as deterministic as possible to reduce the risk of merge conflicts.
+   * </ul>
+   */
+  @SerializationConstant
+  public static final SkyKey KEY =
+      new SkyKey() {
+        @Override
+        public SkyFunctionName functionName() {
+          return SkyFunctions.BAZEL_LOCK_FILE;
+        }
+
+        @Override
+        public String toString() {
+          return "BazelLockFileValue.KEY";
+        }
+      };
+
+  /**
+   * The hidden lockfile, stored as MODULE.bazel.lock under the output base. This file is not
+   * visible to the user and is only removed on a {@code bazel clean --expunge}, similar to the
+   * persistent action cache. Thus, it
+   *
+   * <ul>
+   *   <li>should only contain information known to be correct indefinitely and never needs to be
+   *       invalidated for a correct build;
+   *   <li>is not subject to the same space and mergeability constraints as the regular lockfile and
+   *       can thus contain more extensive information;
+   *   <li>may differ between users and checkouts of the same project as long as it doesn't affect
+   *       the outcome of the build, with one exception: the build may fail with an error due to
+   *       additional information in the hidden lockfile, e.g. if a module in a registry is changed
+   *       retroactively and thus causes a mismatch with the hash in the persistent lockfile.
+   * </ul>
+   */
+  @SerializationConstant
+  public static final SkyKey HIDDEN_KEY =
+      new SkyKey() {
+        @Override
+        public SkyFunctionName functionName() {
+          return SkyFunctions.BAZEL_LOCK_FILE;
+        }
+
+        @Override
+        public String toString() {
+          return "BazelLockFileValue.HIDDEN_KEY";
+        }
+      };
 
   static Builder builder() {
     return new AutoValue_BazelLockFileValue.Builder()
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
index a64f57b5ac..b45e06dee3 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
@@ -142,13 +142,23 @@ public class SingleExtensionEvalFunction implements SkyFunction {
     LockFileModuleExtension lockedExtension = null;
     LockfileMode lockfileMode = BazelLockFileFunction.LOCKFILE_MODE.get(env);
     if (!lockfileMode.equals(LockfileMode.OFF)) {
-      BazelLockFileValue lockfile = (BazelLockFileValue) env.getValue(BazelLockFileValue.KEY);
-      if (lockfile == null) {
+      var lockfiles =
+          env.getValuesAndExceptions(
+              ImmutableList.of(BazelLockFileValue.KEY, BazelLockFileValue.HIDDEN_KEY));
+      BazelLockFileValue lockfile = (BazelLockFileValue) lockfiles.get(BazelLockFileValue.KEY);
+      BazelLockFileValue hiddenLockfile =
+          (BazelLockFileValue) lockfiles.get(BazelLockFileValue.HIDDEN_KEY);
+      if (lockfile == null || hiddenLockfile == null) {
         return null;
       }
       var lockedExtensionMap = lockfile.getModuleExtensions().get(extensionId);
       lockedExtension =
           lockedExtensionMap == null ? null : lockedExtensionMap.get(extension.getEvalFactors());
+      if (lockedExtension == null) {
+        lockedExtensionMap = hiddenLockfile.getModuleExtensions().get(extensionId);
+        lockedExtension =
+            lockedExtensionMap == null ? null : lockedExtensionMap.get(extension.getEvalFactors());
+      }
       if (lockedExtension != null) {
         try (SilentCloseable c =
             Profiler.instance()
@@ -206,21 +216,18 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                         extensionId, nonVisibleRepoNames)));
       }
     }
-    if (lockfileMode.equals(LockfileMode.ERROR)) {
-      boolean extensionShouldHaveBeenLocked =
-          moduleExtensionMetadata.map(metadata -> !metadata.getReproducible()).orElse(true);
-      // If this extension was not found in the lockfile, and after evaluation we found that it is
-      // not reproducible, then error indicating that it was expected to be in the lockfile.
-      if (lockedExtension == null && extensionShouldHaveBeenLocked) {
-        throw new SingleExtensionEvalFunctionException(
-            ExternalDepsException.withMessage(
-                Code.BAD_LOCKFILE,
-                "The module extension '%s'%s does not exist in the lockfile",
-                extensionId,
-                extension.getEvalFactors().isEmpty()
-                    ? ""
-                    : " for platform " + extension.getEvalFactors()));
-      }
+    if (lockfileMode.equals(LockfileMode.ERROR)
+        && !moduleExtensionMetadata.map(ModuleExtensionMetadata::getReproducible).orElse(false)) {
+      // The extension is not reproducible and can't be in the lockfile, since an existing (but
+      // possibly out-of-date) entry would have been handled by tryGettingValueFromLockFile above.
+      throw new SingleExtensionEvalFunctionException(
+          ExternalDepsException.withMessage(
+              Code.BAD_LOCKFILE,
+              "The module extension '%s'%s does not exist in the lockfile",
+              extensionId,
+              extension.getEvalFactors().isEmpty()
+                  ? ""
+                  : " for platform " + extension.getEvalFactors()));
     }
 
     Optional<LockFileModuleExtension.WithFactors> lockFileInfo;
@@ -339,7 +346,9 @@ public class SingleExtensionEvalFunction implements SkyFunction {
           Optional.of(new LockFileModuleExtension.WithFactors(evalFactors, lockedExtension)),
           env);
     }
-    if (lockfileMode.equals(LockfileMode.ERROR)) {
+    // Reproducible extensions are always locked in the hidden lockfile to provide best-effort
+    // speedups, but should never result in an error if out-of-date.
+    if (lockfileMode.equals(LockfileMode.ERROR) && !lockedExtension.isReproducible()) {
       throw new SingleExtensionEvalFunctionException(
           ExternalDepsException.withMessage(
               Code.BAD_LOCKFILE,
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/SkyfocusExecutor.java b/src/main/java/com/google/devtools/build/lib/skyframe/SkyfocusExecutor.java
index c4ab2904c6..21fd514684 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/SkyfocusExecutor.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/SkyfocusExecutor.java
@@ -26,6 +26,7 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.devtools.build.lib.actions.cache.ActionCache;
 import com.google.devtools.build.lib.cmdline.Label;
+import com.google.devtools.build.lib.cmdline.LabelConstants;
 import com.google.devtools.build.lib.cmdline.PackageIdentifier;
 import com.google.devtools.build.lib.cmdline.RepositoryName;
 import com.google.devtools.build.lib.collect.PathFragmentPrefixTrie;
@@ -181,11 +182,16 @@ public class SkyfocusExecutor {
 
       ImmutableSet<RootedPath> activeDirectoriesRootedPaths =
           Stream.concat(
-                  skyfocusState.options().activeDirectories.stream(),
-                  // The Bzlmod lockfile can be created after a build without having existed
-                  // before and must always be kept in the active directories if it is used.
-                  Stream.of("MODULE.bazel.lock"))
-              .map(k -> toFileStateKey(pkgLocator, k))
+                  Stream.concat(
+                          skyfocusState.options().activeDirectories.stream(),
+                          // The Bzlmod lockfile can be created after a build without having existed
+                          // before and must always be kept in the active directories if it is used.
+                          Stream.of(LabelConstants.MODULE_LOCKFILE_NAME.toString()))
+                      .map(k -> toFileStateKey(pkgLocator, k)),
+                  Stream.of(
+                      RootedPath.toRootedPath(
+                          Root.fromPath(pkgLocator.getOutputBase()),
+                          LabelConstants.MODULE_LOCKFILE_NAME)))
               .collect(toImmutableSet());
       evaluator
           .getInMemoryGraph()
@@ -267,7 +273,6 @@ public class SkyfocusExecutor {
     return focusResult;
   }
 
-
   /** Turns a root relative path string into a RootedPath object. */
   static RootedPath toFileStateKey(PathPackageLocator pkgLocator, String rootRelativePathFragment) {
     // For simplicity's sake, use the first --package_path as the root. This
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/packages/BazelPackageLoader.java b/src/main/java/com/google/devtools/build/lib/skyframe/packages/BazelPackageLoader.java
index 907547910e..6f93bcd3f9 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/packages/BazelPackageLoader.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/packages/BazelPackageLoader.java
@@ -197,7 +197,8 @@ public class BazelPackageLoader extends AbstractPackageLoader {
                       repositoryCache.getRepoContentsCache()))
               .put(
                   SkyFunctions.BAZEL_LOCK_FILE,
-                  new BazelLockFileFunction(directories.getWorkspace()))
+                  new BazelLockFileFunction(
+                      directories.getWorkspace(), directories.getOutputBase()))
               .put(SkyFunctions.BAZEL_DEP_GRAPH, new BazelDepGraphFunction())
               .put(SkyFunctions.BAZEL_MODULE_RESOLUTION, new BazelModuleResolutionFunction())
               .put(SkyFunctions.REPO_SPEC, repoSpecFunction)
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/util/AnalysisMock.java b/src/test/java/com/google/devtools/build/lib/analysis/util/AnalysisMock.java
index ed5627bf94..0b9f557a7b 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/util/AnalysisMock.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/util/AnalysisMock.java
@@ -199,7 +199,9 @@ public abstract class AnalysisMock extends LoadingMock {
                 directories.getWorkspace(),
                 getBuiltinModules(directories)))
         .put(SkyFunctions.BAZEL_DEP_GRAPH, new BazelDepGraphFunction())
-        .put(SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(directories.getWorkspace()))
+        .put(
+            SkyFunctions.BAZEL_LOCK_FILE,
+            new BazelLockFileFunction(directories.getWorkspace(), directories.getOutputBase()))
         .put(SkyFunctions.BAZEL_MODULE_RESOLUTION, new BazelModuleResolutionFunction())
         .put(SkyFunctions.SINGLE_EXTENSION, new SingleExtensionFunction())
         .put(
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
index fd26eaf2de..1d5a31fea8 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelDepGraphFunctionTest.java
@@ -125,7 +125,9 @@ public class BazelDepGraphFunctionTest extends FoundationTestCase {
                         rootDirectory,
                         ImmutableMap.of()))
                 .put(SkyFunctions.PRECOMPUTED, new PrecomputedFunction())
-                .put(SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(rootDirectory))
+                .put(
+                    SkyFunctions.BAZEL_LOCK_FILE,
+                    new BazelLockFileFunction(rootDirectory, directories.getOutputBase()))
                 .put(SkyFunctions.BAZEL_DEP_GRAPH, new BazelDepGraphFunction())
                 .put(SkyFunctions.BAZEL_MODULE_RESOLUTION, resolutionFunctionMock)
                 .put(
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
index 771201e8c7..59d35fab2f 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
@@ -77,7 +77,7 @@ public class BazelLockFileModuleTest {
 
     assertThat(
             BazelLockFileModule.combineModuleExtensions(
-                oldExtensionInfos, newExtensionInfos, id -> true))
+                oldExtensionInfos, newExtensionInfos, id -> true, /* reproducible= */ false))
         .isEqualTo(oldExtensionInfos);
   }
 
@@ -91,7 +91,7 @@ public class BazelLockFileModuleTest {
 
     assertThat(
             BazelLockFileModule.combineModuleExtensions(
-                oldExtensionInfos, newExtensionInfos, id -> true))
+                oldExtensionInfos, newExtensionInfos, id -> true, /* reproducible= */ false))
         .isEmpty();
   }
 
@@ -106,7 +106,7 @@ public class BazelLockFileModuleTest {
 
     assertThat(
             BazelLockFileModule.combineModuleExtensions(
-                oldExtensionInfos, newExtensionInfos, id -> true))
+                oldExtensionInfos, newExtensionInfos, id -> true, /* reproducible= */ false))
         .isEqualTo(
             ImmutableMap.of(extensionId, ImmutableMap.of(evalFactors, nonReproducibleResult)));
   }
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/DiscoveryTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/DiscoveryTest.java
index ffe8126862..57fcba243d 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/DiscoveryTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/DiscoveryTest.java
@@ -171,7 +171,9 @@ public class DiscoveryTest extends FoundationTestCase {
                         SyscallCache.NO_CACHE,
                         externalFilesHelper))
                 .put(DiscoveryValue.FUNCTION_NAME, new DiscoveryFunction())
-                .put(SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(rootDirectory))
+                .put(
+                    SkyFunctions.BAZEL_LOCK_FILE,
+                    new BazelLockFileFunction(rootDirectory, directories.getOutputBase()))
                 .put(
                     SkyFunctions.MODULE_FILE,
                     new ModuleFileFunction(
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
index 9053b65cbf..86c88bbbdb 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
@@ -141,7 +141,9 @@ public class ModuleFileFunctionTest extends FoundationTestCase {
                             new TimestampGranularityMonitor(BlazeClock.instance())),
                         SyscallCache.NO_CACHE,
                         externalFilesHelper))
-                .put(SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(rootDirectory))
+                .put(
+                    SkyFunctions.BAZEL_LOCK_FILE,
+                    new BazelLockFileFunction(rootDirectory, directories.getOutputBase()))
                 .put(
                     SkyFunctions.MODULE_FILE,
                     new ModuleFileFunction(
diff --git a/src/test/java/com/google/devtools/build/lib/rules/repository/RepositoryDelegatorTest.java b/src/test/java/com/google/devtools/build/lib/rules/repository/RepositoryDelegatorTest.java
index a54670c092..50fcb1fc09 100644
--- a/src/test/java/com/google/devtools/build/lib/rules/repository/RepositoryDelegatorTest.java
+++ b/src/test/java/com/google/devtools/build/lib/rules/repository/RepositoryDelegatorTest.java
@@ -212,7 +212,9 @@ public class RepositoryDelegatorTest extends FoundationTestCase {
                         rootPath,
                         ImmutableMap.of()))
                 .put(SkyFunctions.BAZEL_DEP_GRAPH, new BazelDepGraphFunction())
-                .put(SkyFunctions.BAZEL_LOCK_FILE, new BazelLockFileFunction(rootDirectory))
+                .put(
+                    SkyFunctions.BAZEL_LOCK_FILE,
+                    new BazelLockFileFunction(rootDirectory, directories.getOutputBase()))
                 .put(SkyFunctions.BAZEL_MODULE_RESOLUTION, new BazelModuleResolutionFunction())
                 .put(
                     BzlmodRepoRuleValue.BZLMOD_REPO_RULE,
diff --git a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
index ffee6c577d..5f35c7817c 100644
--- a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
@@ -59,6 +59,12 @@ class BazelLockfileTest(test_base.TestBase):
     # TODO(pcloudy): investigate why this is needed, MODULE.bazel.lock is not
     # deterministic?
     os.remove(self.Path('MODULE.bazel.lock'))
+    _, stdout, _ = self.RunBazel(['info', 'output_base'])
+    output_base = pathlib.Path(stdout[0].strip())
+    try:
+      os.remove(output_base.joinpath('MODULE.bazel.lock'))
+    except FileNotFoundError:
+      pass
 
   def tearDown(self):
     self.main_registry.stop()
@@ -116,7 +122,7 @@ class BazelLockfileTest(test_base.TestBase):
 
     # Shutdown bazel to empty any cache of the deps tree
     self.RunBazel(['shutdown'])
-    # Runing again will try to get 'sss' which should produce an error
+    # Running again will try to get 'sss' which should produce an error
     exit_code, _, stderr = self.RunBazel(
         [
             'build',
@@ -400,6 +406,67 @@ class BazelLockfileTest(test_base.TestBase):
     )
     self.assertNotIn('Hello from the other side!', ''.join(stderr))
 
+  def testReproducibleModuleExtension(self):
+    self.ScratchFile(
+        'MODULE.bazel',
+        [
+            'lockfile_ext = use_extension("extension.bzl", "lockfile_ext")',
+            'lockfile_ext.dep(name = "bmbm", versions = ["v1", "v2"])',
+            'use_repo(lockfile_ext, "hello")',
+        ],
+    )
+    self.ScratchFile('BUILD.bazel')
+    self.ScratchFile(
+        'extension.bzl',
+        [
+            'def impl(ctx):',
+            '    ctx.file("BUILD", "filegroup(name=\'lala\')")',
+            '',
+            'repo_rule = repository_rule(implementation=impl)',
+            '',
+            'def _module_ext_impl(ctx):',
+            '    print("Hello from the other side!")',
+            '    repo_rule(name="hello")',
+            '    for mod in ctx.modules:',
+            '        for dep in mod.tags.dep:',
+            '            print("Name:", dep.name, ", Versions:", dep.versions)',
+            '    return ctx.extension_metadata(reproducible = True)',
+            '',
+            '_dep = tag_class(attrs={"name": attr.string(), "versions":',
+            ' attr.string_list()})',
+            'lockfile_ext = module_extension(',
+            '    implementation=_module_ext_impl,',
+            '    tag_classes={"dep": _dep},',
+            '    environ=["GREEN_TREES", "NOT_SET"],',
+            '    os_dependent=True,',
+            '    arch_dependent=True,',
+            ')',
+        ],
+    )
+
+    # Only set one env var, to make sure null variables don't crash
+    _, _, stderr = self.RunBazel(
+        ['build', '@hello//:all'], env_add={'GREEN_TREES': 'In the city'}
+    )
+    self.assertIn('Hello from the other side!', ''.join(stderr))
+    self.assertIn('Name: bmbm , Versions: ["v1", "v2"]', ''.join(stderr))
+
+    self.RunBazel(['clean'])
+    self.RunBazel(['shutdown'])
+    # Verify that the lockfile entry is not stored in the regular lockfile.
+    os.remove(self.Path('MODULE.bazel.lock'))
+    _, _, stderr = self.RunBazel(
+        ['build', '@hello//:all'], env_add={'GREEN_TREES': 'In the city'}
+    )
+    self.assertNotIn('Hello from the other side!', ''.join(stderr))
+
+    self.RunBazel(['clean', '--expunge'])
+
+    _, _, stderr = self.RunBazel(
+        ['build', '@hello//:all'], env_add={'GREEN_TREES': 'In the city'}
+    )
+    self.assertIn('Hello from the other side!', ''.join(stderr))
+
   def testIsolatedAndNonIsolatedModuleExtensions(self):
     self.ScratchFile(
         'MODULE.bazel',
diff --git a/src/test/shell/bazel/remote/build_without_the_bytes_test.sh b/src/test/shell/bazel/remote/build_without_the_bytes_test.sh
index 7bca3295a7..f11f542d9d 100755
--- a/src/test/shell/bazel/remote/build_without_the_bytes_test.sh
+++ b/src/test/shell/bazel/remote/build_without_the_bytes_test.sh
@@ -1580,14 +1580,14 @@ EOF
     --remote_download_minimal \
     //a:test0 >& $TEST_log || fail "Failed to test"
   # 2 remote spawns: 1 for executing the test, 1 for generating the test.xml
-  expect_log "2 processes: 2 remote"
+  expect_log "2 processes:.* 2 remote"
 
   bazel test \
     --remote_executor=grpc://localhost:${worker_port} \
     --remote_download_minimal \
     //a:test1 >& $TEST_log || fail "Failed to test"
   # only 1 remote spawn: test.xml is generated by junit
-  expect_log "2 processes: 1 internal, 1 remote"
+  expect_log "2 processes:.* 1 internal, 1 remote"
 }
 
 function test_output_file_permission() {
diff --git a/src/test/shell/integration/aquery_test.sh b/src/test/shell/integration/aquery_test.sh
index f4f6bd831f..585285e8e0 100755
--- a/src/test/shell/integration/aquery_test.sh
+++ b/src/test/shell/integration/aquery_test.sh
@@ -1479,6 +1479,8 @@ EOF
   cat output >> "$TEST_log"
   assert_not_contains "actions" output
 
+  bazel build --nobuild "//$pkg:foo"
+  # Skyframe state becomes "dirty" after an initial build because that build alters the lockfile
   bazel build --nobuild "//$pkg:foo"
 
   bazel aquery --output=textproto --skyframe_state > output 2> "$TEST_log" \
@@ -1512,6 +1514,8 @@ EOF
 
   bazel clean
   bazel build --nobuild "//$pkg:foo"
+  # Skyframe state becomes "dirty" after an initial build because that build alters the lockfile
+  bazel build --nobuild "//$pkg:foo"
 
   bazel aquery --output=textproto --skyframe_state ${QUERY} > output 2> "$TEST_log" \
     || fail "Expected success"
@@ -1538,6 +1542,8 @@ EOF
   cat output >> "$TEST_log"
   assert_not_contains "actions" output
 
+  bazel build --nobuild "//$pkg:foo"
+  # Skyframe state becomes "dirty" after an initial build because that build alters the lockfile
   bazel build --nobuild "//$pkg:foo"
 
   bazel aquery --output=textproto --skyframe_state > output 2> "$TEST_log" \
@@ -1569,6 +1575,8 @@ EOF
   cat output >> "$TEST_log"
   assert_not_contains "actions" output
 
+  bazel build --nobuild "//$pkg:foo"
+  # Skyframe state becomes "dirty" after an initial build because that build alters the lockfile
   bazel build --nobuild "//$pkg:foo"
 
   bazel aquery --output=jsonproto --skyframe_state > output 2> "$TEST_log" \
