diff --git a/src/main/starlark/builtins_bzl/common/cc/compile/cc_compilation_helper.bzl b/src/main/starlark/builtins_bzl/common/cc/compile/cc_compilation_helper.bzl
index ff988563f4..c0bcd1e049 100644
--- a/src/main/starlark/builtins_bzl/common/cc/compile/cc_compilation_helper.bzl
+++ b/src/main/starlark/builtins_bzl/common/cc/compile/cc_compilation_helper.bzl
@@ -102,7 +102,17 @@ def _compute_public_headers(
     if include_prefix and include_prefix.startswith("/"):
         include_prefix = include_prefix[1:]
 
-    if not strip_prefix and not include_prefix:
+    if strip_prefix == None and not include_prefix:
+        # If CppOptions.experimentalStarlarkCompiling is enabled, then
+        # strip_include_prefix and include_prefix are not None.
+        # If the option is disabled, their default values (from CcCompilationHelper) are None.
+        #
+        # Special case: when "strip_include_prefix = '.'" is set in a target located in
+        # workspace/BUILD.bazel, strip_prefix will be "", not None.
+        # Thus, we check differently for empty values.
+        #
+        # If neither strip_include_prefix nor include_prefix is specified,
+        # we don't need to create virtual headers, so we return the public headers as-is.
         return struct(
             headers = public_headers_artifacts + non_module_map_headers,
             module_map_headers = public_headers_artifacts,
@@ -125,17 +135,16 @@ def _compute_public_headers(
         if include_prefix != None:
             include_path = paths.get_relative(include_prefix, include_path)
 
-        if not original_header.path == include_path:
-            virtual_header = actions.declare_shareable_artifact(paths.join(virtual_include_dir, include_path))
-            actions.symlink(
-                output = virtual_header,
-                target_file = original_header,
-                progress_message = "Symlinking virtual headers for %{label}",
-                use_exec_root_for_source = USE_EXEC_ROOT_FOR_VIRTUAL_INCLUDES_SYMLINKS,
-            )
-            module_map_headers.append(virtual_header)
-            if config.coverage_enabled:
-                virtual_to_original_headers_list.append((virtual_header.path, original_header.path))
+        virtual_header = actions.declare_shareable_artifact(paths.join(virtual_include_dir, include_path))
+        actions.symlink(
+            output = virtual_header,
+            target_file = original_header,
+            progress_message = "Symlinking virtual headers for %{label}",
+            use_exec_root_for_source = USE_EXEC_ROOT_FOR_VIRTUAL_INCLUDES_SYMLINKS,
+        )
+        module_map_headers.append(virtual_header)
+        if config.coverage_enabled:
+            virtual_to_original_headers_list.append((virtual_header.path, original_header.path))
 
         module_map_headers.append(original_header)
 
diff --git a/src/test/java/com/google/devtools/build/lib/rules/cpp/CcCommonTest.java b/src/test/java/com/google/devtools/build/lib/rules/cpp/CcCommonTest.java
index 1c5c66840f..3ad1e934e6 100644
--- a/src/test/java/com/google/devtools/build/lib/rules/cpp/CcCommonTest.java
+++ b/src/test/java/com/google/devtools/build/lib/rules/cpp/CcCommonTest.java
@@ -1310,13 +1310,29 @@ public class CcCommonTest extends BuildViewTestCase {
         "BUILD",
         "licenses(['notice'])",
         "load('@rules_cc//cc:cc_library.bzl', 'cc_library')",
-        "cc_library(name='a', hdrs=['b.h'], strip_include_prefix='.')");
+        "cc_library(name='a', hdrs=['b.h'], strip_include_prefix=None)");
     CcCompilationContext ccContext =
         getConfiguredTarget("//:a").get(CcInfo.PROVIDER).getCcCompilationContext();
     assertThat(ActionsTestUtil.prettyArtifactNames(ccContext.getDeclaredIncludeSrcs()))
         .containsExactly("b.h");
   }
 
+  @Test
+  public void testDotPackageStripPrefix() throws Exception {
+    if (!AnalysisMock.get().isThisBazel()) {
+      return;
+    }
+    scratch.file(
+        "BUILD",
+        "licenses(['notice'])",
+        "load('@rules_cc//cc:cc_library.bzl', 'cc_library')",
+        "cc_library(name='a', hdrs=['b.h'], strip_include_prefix='.')");
+    CcCompilationContext ccContext =
+        getConfiguredTarget("//:a").get(CcInfo.PROVIDER).getCcCompilationContext();
+    assertThat(ActionsTestUtil.prettyArtifactNames(ccContext.getDeclaredIncludeSrcs()))
+        .containsExactly("_virtual_includes/a/b.h", "b.h");
+  }
+
   @Test
   public void testArtifactNotUnderStripPrefix() throws Exception {
     scratch.file(
@@ -1339,7 +1355,7 @@ public class CcCommonTest extends BuildViewTestCase {
   }
 
   @Test
-  public void testSymlinkActionIsNotRegisteredWhenIncludePrefixDoesntChangePath() throws Exception {
+  public void testSymlinkActionIsRegisteredWhenIncludePrefixDoesntChangePath() throws Exception {
     scratch.file(
         "third_party/BUILD",
         """
@@ -1356,7 +1372,7 @@ public class CcCommonTest extends BuildViewTestCase {
     CcCompilationContext ccCompilationContext =
         getConfiguredTarget("//third_party:a").get(CcInfo.PROVIDER).getCcCompilationContext();
     assertThat(ActionsTestUtil.prettyArtifactNames(ccCompilationContext.getDeclaredIncludeSrcs()))
-        .doesNotContain("third_party/_virtual_includes/a/third_party/a.h");
+        .containsExactly("third_party/_virtual_includes/a/third_party/a.h", "third_party/a.h");
   }
 
   @Test
