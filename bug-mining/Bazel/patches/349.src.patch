diff --git a/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryFetchFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryFetchFunction.java
index 534fac6d44..d35f5f99cf 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryFetchFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryFetchFunction.java
@@ -628,7 +628,10 @@ public final class RepositoryFetchFunction implements SkyFunction {
 
       repoMetadata =
           switch (result) {
-            case Dict<?, ?> dict -> new RepoMetadata(RepoMetadata.Reproducibility.NO, dict);
+            case Dict<?, ?> dict ->
+                new RepoMetadata(
+                    RepoMetadata.Reproducibility.NO,
+                    Dict.cast(dict, String.class, Object.class, "return value"));
             case RepoMetadata rm -> rm;
             default -> RepoMetadata.NONREPRODUCIBLE;
           };
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEvent.java b/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEvent.java
index 8bf8c7026f..ae5807428d 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEvent.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEvent.java
@@ -13,13 +13,13 @@
 // limitations under the License.
 package com.google.devtools.build.lib.bazel.repository;
 
-import static com.google.common.collect.Maps.asMap;
+import static com.google.common.collect.ImmutableMap.toImmutableMap;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.devtools.build.lib.util.Pair;
-import java.util.List;
+import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
 import net.starlark.java.eval.Starlark;
 
 /**
@@ -30,45 +30,78 @@ public class RepositoryResolvedEvent {
   private final boolean informationReturned;
   private final String message;
 
-  public RepositoryResolvedEvent(RepoDefinition repoDefinition, Map<?, ?> result) {
+  public RepositoryResolvedEvent(RepoDefinition repoDefinition, Map<String, Object> result) {
     if (result.isEmpty()) {
       // Repo claims to be already reproducible, so wants to be called as is.
       this.informationReturned = false;
       this.message = "Repo '" + repoDefinition.name() + "' finished fetching.";
     } else {
       // Repo claims that the returned (probably changed) arguments are a reproducible
-      // version of itself.
-      // Don't use repoDefinition.attrValues() here as it doesn't include default values.
-      Pair<Map<String, Object>, List<String>> diff =
-          compare(asMap(repoDefinition.getFieldNames(), repoDefinition::getValue), result);
-      if (diff.getFirst().isEmpty() && diff.getSecond().isEmpty()) {
+      // version of itself. Diff them and report the changes, if any.
+      var modifiedAttributes =
+          repoDefinition.getFieldNames().stream()
+              // The "name" attribute is confusing as the value specified by the user is transformed
+              // to the canonical name for repository_ctx.attr.name. Since the name should never
+              // affect reproducibility, ignore it.
+              .filter(name -> !name.equals("name"))
+              // Filter out implicit attributes, which can't be modified by the user.
+              .filter(name -> !name.startsWith("_"))
+              .map(
+                  name -> {
+                    var defaultValue =
+                        repoDefinition
+                            .repoRule()
+                            .attributes()
+                            .get(repoDefinition.repoRule().attributeIndices().get(name))
+                            .getDefaultValueUnchecked();
+                    // Label attributes report a default of null rather than None.
+                    if (defaultValue == null) {
+                      defaultValue = Starlark.NONE;
+                    }
+                    var currentValue = repoDefinition.getValue(name);
+                    var newValue = result.getOrDefault(name, defaultValue);
+                    if (newValue.equals(currentValue)) {
+                      return null;
+                    }
+                    // Distinguish between "dropped" and non-trivially "modified" attributes.
+                    return Map.entry(
+                        name,
+                        newValue.equals(defaultValue) ? Optional.empty() : Optional.of(newValue));
+                  })
+              .filter(Objects::nonNull)
+              .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));
+      if (modifiedAttributes.isEmpty()) {
         this.informationReturned = false;
         this.message = "Repo '" + repoDefinition.name() + "' finished fetching.";
       } else {
         this.informationReturned = true;
-        if (diff.getFirst().isEmpty()) {
+        var modifiedToNonDefault = Maps.filterValues(modifiedAttributes, Optional::isPresent);
+        var dropped = Maps.filterValues(modifiedAttributes, Optional::isEmpty).keySet();
+        if (modifiedToNonDefault.isEmpty()) {
           this.message =
               "Repo '"
                   + repoDefinition.name()
                   + "' indicated that a canonical reproducible form can be obtained by"
                   + " dropping arguments "
-                  + Starlark.repr(diff.getSecond());
-        } else if (diff.getSecond().isEmpty()) {
+                  + Starlark.repr(dropped);
+        } else if (dropped.isEmpty()) {
           this.message =
               "Repo '"
                   + repoDefinition.name()
                   + "' indicated that a canonical reproducible form can be obtained by"
                   + " modifying arguments "
-                  + representModifications(diff.getFirst());
+                  + representModifications(
+                      Maps.transformValues(modifiedToNonDefault, Optional::get));
         } else {
           this.message =
               "Repo '"
                   + repoDefinition.name()
                   + "' indicated that a canonical reproducible form can be obtained by"
                   + " modifying arguments "
-                  + representModifications(diff.getFirst())
+                  + representModifications(
+                      Maps.transformValues(modifiedToNonDefault, Optional::get))
                   + " and dropping "
-                  + Starlark.repr(diff.getSecond());
+                  + Starlark.repr(dropped);
         }
       }
     }
@@ -100,41 +133,9 @@ public class RepositoryResolvedEvent {
             repoDefinition.repoRule().id().bzlFileLabel().getUnambiguousCanonicalForm());
   }
 
-  /**
-   * Compare two maps from Strings to objects, returning a pair of the map with all entries not in
-   * the original map or in the original map, but with a different value, and the keys dropped from
-   * the original map. However, ignore changes where a value is explicitly set to its default.
-   */
-  static Pair<Map<String, Object>, List<String>> compare(
-      Map<String, Object> orig, Map<?, ?> modified) {
-    ImmutableMap.Builder<String, Object> valuesChanged = ImmutableMap.builder();
-    for (Map.Entry<?, ?> entry : modified.entrySet()) {
-      if (entry.getKey() instanceof String key) {
-        Object value = entry.getValue();
-        if (!value.equals(orig.get(key))) {
-          valuesChanged.put(key, value);
-        }
-      }
-    }
-    ImmutableList.Builder<String> keysDropped = ImmutableList.builder();
-    for (String key : orig.keySet()) {
-      if (!modified.containsKey(key)) {
-        keysDropped.add(key);
-      }
-    }
-    return Pair.of(valuesChanged.buildOrThrow(), keysDropped.build());
-  }
-
   static String representModifications(Map<String, Object> changes) {
-    StringBuilder representation = new StringBuilder();
-    boolean isFirst = true;
-    for (Map.Entry<String, Object> entry : changes.entrySet()) {
-      if (!isFirst) {
-        representation.append(", ");
-      }
-      representation.append(entry.getKey()).append(" = ").append(Starlark.repr(entry.getValue()));
-      isFirst = false;
-    }
-    return representation.toString();
+    return changes.entrySet().stream()
+        .map(entry -> "%s = %s".formatted(entry.getKey(), Starlark.repr(entry.getValue())))
+        .collect(Collectors.joining(", "));
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoMetadata.java b/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoMetadata.java
index b7a42fefae..1f00f75b57 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoMetadata.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoMetadata.java
@@ -27,7 +27,8 @@ import net.starlark.java.eval.StarlarkValue;
         """
         See <a href="repository_ctx#repo_metadata"><code>repository_ctx.repo_metadata</code></a>.
         """)
-public record RepoMetadata(Reproducibility reproducible, Dict<?, ?> attrsForReproducibility)
+public record RepoMetadata(
+    Reproducibility reproducible, Dict<String, Object> attrsForReproducibility)
     implements StarlarkValue {
   public static final RepoMetadata NONREPRODUCIBLE =
       new RepoMetadata(Reproducibility.NO, Dict.empty());
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkRepositoryContext.java b/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkRepositoryContext.java
index 4d32d96650..d262b90ce6 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkRepositoryContext.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkRepositoryContext.java
@@ -626,7 +626,8 @@ public class StarlarkRepositoryContext extends StarlarkBaseExternalContext {
           "attrs_for_reproducibility can only be specified if reproducible is False");
     }
     return new RepoMetadata(
-        reproducible ? RepoMetadata.Reproducibility.YES : RepoMetadata.Reproducibility.NO, attrs);
+        reproducible ? RepoMetadata.Reproducibility.YES : RepoMetadata.Reproducibility.NO,
+        Dict.cast(attrs, String.class, Object.class, "attrs_for_reproducibility"));
   }
 
   @Override
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEventTest.java b/src/test/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEventTest.java
deleted file mode 100644
index f587669fe1..0000000000
--- a/src/test/java/com/google/devtools/build/lib/bazel/repository/RepositoryResolvedEventTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2017 The Bazel Authors. All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.devtools.build.lib.bazel.repository;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.devtools.build.lib.util.Pair;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Test for {@link RepositoryOptions}. */
-@RunWith(JUnit4.class)
-public class RepositoryResolvedEventTest {
-
-  @Test
-  public void testCompareReplace() {
-    Pair<Map<String, Object>, List<String>> result =
-        RepositoryResolvedEvent.compare(
-            ImmutableMap.of("foo", "orig"),
-            ImmutableMap.of("foo", "changed"));
-    assertThat(result.getFirst()).containsExactly("foo", "changed");
-    assertThat(result.getSecond()).isEmpty();
-  }
-
-  @Test
-  public void testCompareDrop() {
-    Pair<Map<String, Object>, List<String>> result =
-        RepositoryResolvedEvent.compare(ImmutableMap.of("foo", "orig"), ImmutableMap.of());
-    assertThat(result.getFirst()).isEmpty();
-    assertThat(result.getSecond()).containsExactly("foo");
-  }
-
-  @Test
-  public void testCompareAdd() {
-    Pair<Map<String, Object>, List<String>> result =
-        RepositoryResolvedEvent.compare(
-            ImmutableMap.<String, Object>of(),
-            ImmutableMap.of("foo", "new"));
-    assertThat(result.getFirst()).containsExactly("foo", "new");
-    assertThat(result.getSecond()).isEmpty();
-  }
-
-  @Test
-  public void testRepresentModifications() {
-    assertThat(
-            RepositoryResolvedEvent.representModifications(
-                ImmutableMap.<String, Object>of("a", "b", "c", "d")))
-        .isEqualTo("a = \"b\", c = \"d\"");
-    assertThat(
-            RepositoryResolvedEvent.representModifications(
-                ImmutableMap.<String, Object>of("a", 1, "b", 2)))
-        .isEqualTo("a = 1, b = 2");
-    assertThat(
-            RepositoryResolvedEvent.representModifications(
-                ImmutableMap.<String, Object>of("a", ImmutableList.<Integer>of(1, 2, 3))))
-        .isEqualTo("a = [1, 2, 3]");
-  }
-}
diff --git a/src/test/shell/bazel/starlark_repository_test.sh b/src/test/shell/bazel/starlark_repository_test.sh
index 6adb005864..9f6aba67ee 100755
--- a/src/test/shell/bazel/starlark_repository_test.sh
+++ b/src/test/shell/bazel/starlark_repository_test.sh
@@ -3075,6 +3075,7 @@ repo = use_repo_rule("//:repo.bzl", "repo")
 repo(
   name = "repo",
   attr1 = "value1",
+  attr3 = "//:default",
 )
 EOF
   touch BUILD
@@ -3082,20 +3083,25 @@ EOF
 def _impl(repository_ctx):
   repository_ctx.file("BUILD", "filegroup(name='r')")
   return {
-    "name": repository_ctx.attr.name,
     "attr1": repository_ctx.attr.attr1,
     "attr2": repository_ctx.attr.attr2,
-    "attr3": repository_ctx.attr.attr3,
-    "attr4": repository_ctx.attr.attr4,
+    "attr5": "",
   }
 
 repo = repository_rule(
   implementation = _impl,
   attrs={
+    # Consistently changed from default.
     "attr1": attr.string(default = "default1"),
+    # Unchanged from default.
     "attr2": attr.string(),
+    # Explicitly set to default in rule attributes, not contained in returned dict.
     "attr3": attr.label(default = "//:default"),
+    # Not set or included in the returned dict.
     "attr4": attr.label(),
+    # Not set in rule attributes, but returned as default in the dict.
+    "attr5": attr.string(),
+    "_implicit": attr.string(default = "hi"),
   },
 )
 EOF
@@ -3112,6 +3118,8 @@ repo = use_repo_rule("//:repo.bzl", "repo")
 repo(
   name = "repo",
   attr1 = "value1",
+  attr2 = "value2",
+  attr3 = "value3",
 )
 EOF
   touch BUILD
@@ -3120,8 +3128,8 @@ def _impl(repository_ctx):
   repository_ctx.file("BUILD", "filegroup(name='r')")
   return {
     "name": repository_ctx.attr.name,
-    "attr1": repository_ctx.attr.attr2,
-    "attr2": repository_ctx.attr.attr2,
+    "attr1": "default2",
+    "attr2": "default2",
   }
 
 repo = repository_rule(
@@ -3129,13 +3137,14 @@ repo = repository_rule(
   attrs = {
     "attr1": attr.string(default = "default1"),
     "attr2": attr.string(default = "default2"),
+    "attr3": attr.string(default = "default3"),
   },
 )
 EOF
 
   bazel build @repo//:r >& $TEST_log || fail "expected bazel to succeed"
   expect_log "indicated that a canonical reproducible form can be obtained"
-  expect_log "by modifying arguments attr1 = \"default2\""
+  expect_log "by modifying arguments attr1 = \"default2\" and dropping \[attr2, attr3\]"
 }
 
 run_suite "local repository tests"
