diff --git a/scripts/bazel-lockfile-merge.jq b/scripts/bazel-lockfile-merge.jq
index 116af71dad..af99cb075a 100644
--- a/scripts/bazel-lockfile-merge.jq
+++ b/scripts/bazel-lockfile-merge.jq
@@ -42,9 +42,17 @@ def shallow_merge(f):
         # shallowly merged factors map, then shallowly merge the results.
         moduleExtensions:  (map(.moduleExtensions | to_entries)
                            | flatten
-                           | group_by(.key)
-                           | shallow_merge({(.[0].key): shallow_merge(.value)}))
+                           | if length > 0 then group_by(.key) | shallow_merge({(.[0].key): shallow_merge(.value)}) else {} end),
+        # Group facts by extension ID across all lockfiles with shallowly
+        # merged top-level keys, then shallowly merge the results. Handle the
+        # case where some lockfiles do not have a facts key.
+        facts: (if any(has("facts")) then
+                  map(.facts // {} | to_entries) | flatten |
+                  if length > 0 then group_by(.key) | shallow_merge({(.[0].key): shallow_merge(.value)}) else {} end
+                else null end),
     }
+    # Filter out null values for missing top-level keys such as facts.
+    | with_entries(select(.value != null))
 )? //
     # We get here if the lockfiles with the highest lockFileVersion could not be
     # processed, for example because all lockfiles have lockFileVersion < 10.
diff --git a/scripts/bazel_lockfile_merge_test.sh b/scripts/bazel_lockfile_merge_test.sh
index 50cd65d5d8..9d74fee053 100755
--- a/scripts/bazel_lockfile_merge_test.sh
+++ b/scripts/bazel_lockfile_merge_test.sh
@@ -270,4 +270,114 @@ EOF
   diff -u base left || fail "output differs"
 }
 
+function test_merge_facts() {
+  cat > base <<'EOF'
+{
+  "lockFileVersion": 22,
+  "registryFileHashes": {
+    "https://example.org/modules/foo/1.0/MODULE.bazel": "1234"
+  },
+  "selectedYankedVersions": {},
+  "moduleExtensions": {}
+}
+EOF
+  cat > left <<'EOF'
+{
+  "lockFileVersion": 22,
+  "registryFileHashes": {
+    "https://example.org/modules/foo/1.0/MODULE.bazel": "1234"
+  },
+  "selectedYankedVersions": {},
+  "moduleExtensions": {},
+  "facts": {
+    "@@rules_foo+//:foo_deps.bzl%foo_deps": {
+      "json_foo@1.0": {
+        "sha256": "1111",
+        "url": "https://example.org/json_foo/1.0.zip"
+      },
+      "cbor_foo@2.0": {
+        "sha256": "2222",
+        "url": "https://example.org/cbor_foo/2.0.zip"
+      }
+    },
+    "@@rules_bar+//:bar_deps.bzl%bar_deps": {
+      "json_bar@1.0": {
+        "sha256": "3333",
+        "url": "https://example.org/json_bar/1.0.zip"
+      }
+    }
+  }
+}
+EOF
+  cat > right <<'EOF'
+{
+  "lockFileVersion": 22,
+  "registryFileHashes": {
+    "https://example.org/modules/foo/1.0/MODULE.bazel": "1234"
+  },
+  "selectedYankedVersions": {},
+  "moduleExtensions": {},
+  "facts": {
+    "@@rules_foo+//:foo_deps.bzl%foo_deps": {
+      "json_foo@1.0": {
+        "sha256": "1111",
+        "url": "https://example.org/json_foo/1.0.zip"
+      },
+      "xml_foo@3.0": {
+        "sha256": "4444",
+        "url": "https://example.org/xml_foo/3.0.zip"
+      }
+    },
+    "@@rules_baz+//:baz_deps.bzl%baz_deps": {
+      "json_baz@1.0": {
+        "sha256": "5555",
+        "url": "https://example.org/json_baz/1.0.zip"
+      }
+    }
+  }
+}
+EOF
+  cat > expected <<'EOF'
+{
+  "lockFileVersion": 22,
+  "registryFileHashes": {
+    "https://example.org/modules/foo/1.0/MODULE.bazel": "1234"
+  },
+  "selectedYankedVersions": {},
+  "moduleExtensions": {},
+  "facts": {
+    "@@rules_bar+//:bar_deps.bzl%bar_deps": {
+      "json_bar@1.0": {
+        "sha256": "3333",
+        "url": "https://example.org/json_bar/1.0.zip"
+      }
+    },
+    "@@rules_baz+//:baz_deps.bzl%baz_deps": {
+      "json_baz@1.0": {
+        "sha256": "5555",
+        "url": "https://example.org/json_baz/1.0.zip"
+      }
+    },
+    "@@rules_foo+//:foo_deps.bzl%foo_deps": {
+      "cbor_foo@2.0": {
+        "sha256": "2222",
+        "url": "https://example.org/cbor_foo/2.0.zip"
+      },
+      "json_foo@1.0": {
+        "sha256": "1111",
+        "url": "https://example.org/json_foo/1.0.zip"
+      },
+      "xml_foo@3.0": {
+        "sha256": "4444",
+        "url": "https://example.org/xml_foo/3.0.zip"
+      }
+    }
+  }
+}
+EOF
+
+  do_merge base left right
+  diff -u expected left || fail "output differs"
+}
+
 run_suite "Tests of bash completion of 'blaze' command."
diff --git a/site/en/external/extension.md b/site/en/external/extension.md
index 629eba7846..51a3922e68 100644
--- a/site/en/external/extension.md
+++ b/site/en/external/extension.md
@@ -245,7 +245,7 @@ later. This is because the extension's identify is based on its file, so moving
 the extension into another file later changes your public API and is a backwards
 incompatible change for your users.
 
-### Specify reproducibility
+### Specify reproducibility and use facts
 
 If your extension always defines the same repositories given the same inputs
 (extension tags, files it reads, etc.) and in particular doesn't rely on
@@ -253,9 +253,36 @@ any [downloads](/rules/lib/builtins/module_ctx#download) that aren't guarded by
 a checksum, consider returning
 [`extension_metadata`](/rules/lib/builtins/module_ctx#extension_metadata) with
 `reproducible = True`. This allows Bazel to skip this extension when writing to
-the lockfile.
-
-### Specify the operating system and architecture
+the `MODULE.bazel` lockfile, which helps keep the lockfile small and reduces
+the chance of merge conflicts. Note that Bazel still caches the results of
+reproducible extensions in a way that persists across server restarts, so even
+a long-running extension can be marked as reproducible without a performance
+penalty.
+
+If your extension relies on effectively immutable data obtained from outside
+the build, most commonly from the network, but you don't have a checksum
+available to guard the download, consider using the `facts` parameter of
+[`extension_metadata`](/rules/lib/builtins/module_ctx#extension_metadata) to
+persistently record such data and thus allow your extension to become
+reproducible. `facts` is expected to be a dictionary with string keys and
+arbitrary JSON-like Starlark values that is always persisted in the lockfile and
+available to future evaluations of the extension via the
+[`facts`](/rules/lib/builtins/module_ctx#facts) field of `module_ctx`.
+
+`facts` are not invalidated even when the code of your module extension changes,
+so be prepared to handle the case where the structure of `facts` changes.
+Bazel also assumes that two different `facts` dicts produced by two different
+evaluations of the same extension can be shallowly merged (i.e., as if by using
+the `|` operator on two dicts). This is partially enforced by `module_ctx.facts`
+not supporting enumeration of its entries, just lookups by key.
+
+An example of using `facts` would be to record a mapping from version numbers of
+some SDK to the an object containing the download URL and checksum of that
+version. The first time the extension is evaluated, it can fetch this mapping
+from the network, but on later evaluations it can use the mapping from `facts`
+to avoid the network requests.
+
+### Specify dependence on operating system and architecture
 
 If your extension relies on the operating system or its architecture type,
 ensure to indicate this in the extension definition using the `os_dependent`
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
index 3034ef9447..bf404c2953 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BUILD
@@ -125,6 +125,7 @@ java_library(
     srcs = ["BazelLockFileModule.java"],
     deps = [
         ":module_extension",
+        ":module_extension_metadata",
         ":resolution",
         ":resolution_impl",
         ":serialization",
@@ -213,11 +214,13 @@ java_library(
     srcs = [
         "AttributeValuesAdapter.java",
         "DelegateTypeAdapterFactory.java",
+        "FactsAdapter.java",
         "GsonTypeAdapterUtil.java",
     ],
     deps = [
         ":common",
         ":module_extension",
+        ":module_extension_metadata",
         ":resolution",
         "//src/main/java/com/google/devtools/build/lib/bazel/repository/cache",
         "//src/main/java/com/google/devtools/build/lib/bazel/repository/downloader",
@@ -225,6 +228,7 @@ java_library(
         "//src/main/java/com/google/devtools/build/lib/rules:repository/repo_recorded_input",
         "//src/main/java/com/google/devtools/build/lib/util:string_encoding",
         "//src/main/java/net/starlark/java/eval",
+        "//src/main/java/net/starlark/java/lib/json",
         "//third_party:auto_value",
         "//third_party:gson",
         "//third_party:guava",
@@ -435,6 +439,8 @@ java_library(
 java_library(
     name = "module_extension_metadata",
     srcs = [
+        "Facts.java",
+        "LockfileModuleExtensionMetadata.java",
         "ModuleExtensionMetadata.java",
     ],
     deps = [
@@ -443,9 +449,12 @@ java_library(
         "//src/main/java/com/google/devtools/build/docgen/annot",
         "//src/main/java/com/google/devtools/build/lib/cmdline",
         "//src/main/java/com/google/devtools/build/lib/events",
+        "//src/main/java/com/google/devtools/build/lib/skyframe/serialization:visible-for-serialization",
+        "//src/main/java/com/google/devtools/build/lib/skyframe/serialization/autocodec",
         "//src/main/java/com/google/devtools/build/lib/vfs:pathfragment",
         "//src/main/java/net/starlark/java/annot",
         "//src/main/java/net/starlark/java/eval",
+        "//src/main/java/net/starlark/java/types",
         "//third_party:auto_value",
         "//third_party:gson",
         "//third_party:guava",
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
index 16f4dc1eab..47f28d43bb 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModule.java
@@ -115,9 +115,10 @@ public class BazelLockFileModule extends BlazeModule {
     // transitive closure of the current build. Since extensions are potentially costly to evaluate,
     // this is seen as an advantage. Full reproducibility can be ensured by running 'bazel shutdown'
     // first if needed.
+    var numExtensions = depGraphValue.getExtensionUsagesTable().rowKeySet().size();
     var newExtensionInfos =
-        new HashMap<ModuleExtensionId, LockFileModuleExtension.WithFactors>(
-            depGraphValue.getExtensionUsagesTable().rowKeySet().size());
+        new HashMap<ModuleExtensionId, LockFileModuleExtension.WithFactors>(numExtensions);
+    var combinedFacts = new HashMap<ModuleExtensionId, Facts>(numExtensions);
     var doneValues = evaluator.getDoneValues();
     for (var extensionId : depGraphValue.getExtensionUsagesTable().rowKeySet()) {
       if (extensionId.isInnate()) {
@@ -127,6 +128,7 @@ public class BazelLockFileModule extends BlazeModule {
       var value = (SingleExtensionValue) doneValues.get(SingleExtensionValue.evalKey(extensionId));
       if (value != null) {
         newExtensionInfos.put(extensionId, value.lockFileInfo().get());
+        combinedFacts.put(extensionId, value.facts());
       }
     }
 
@@ -159,6 +161,15 @@ public class BazelLockFileModule extends BlazeModule {
                       .setRegistryFileHashes(remoteRegistryFileHashes)
                       .setSelectedYankedVersions(moduleResolutionValue.getSelectedYankedVersions())
                       .setModuleExtensions(notReproducibleExtensionInfos)
+                      .setFacts(
+                          ImmutableSortedMap.copyOf(
+                              Maps.filterEntries(
+                                  combinedFacts,
+                                  entry ->
+                                      depGraphValue
+                                              .getExtensionUsagesTable()
+                                              .containsRow(entry.getKey())
+                                          && !entry.getValue().equals(Facts.EMPTY))))
                       .build();
 
               // Write the new values to the files, but only if needed. This is not just a
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
index 5e56e5533a..974042c1ac 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileValue.java
@@ -111,7 +111,8 @@ public abstract class BazelLockFileValue implements SkyValue {
         .setLockFileVersion(LOCK_FILE_VERSION)
         .setRegistryFileHashes(ImmutableMap.of())
         .setSelectedYankedVersions(ImmutableMap.of())
-        .setModuleExtensions(ImmutableMap.of());
+        .setModuleExtensions(ImmutableMap.of())
+        .setFacts(ImmutableMap.of());
   }
 
   /** Current version of the lock file */
@@ -131,6 +132,8 @@ public abstract class BazelLockFileValue implements SkyValue {
           ModuleExtensionId, ImmutableMap<ModuleExtensionEvalFactors, LockFileModuleExtension>>
       getModuleExtensions();
 
+  public abstract ImmutableMap<ModuleExtensionId, Facts> getFacts();
+
   public abstract Builder toBuilder();
 
   /** Builder type for {@link BazelLockFileValue}. */
@@ -148,6 +151,8 @@ public abstract class BazelLockFileValue implements SkyValue {
                 ImmutableMap<ModuleExtensionEvalFactors, LockFileModuleExtension>>
             value);
 
+    public abstract Builder setFacts(ImmutableMap<ModuleExtensionId, Facts> value);
+
     public abstract BazelLockFileValue build();
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Facts.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Facts.java
new file mode 100644
index 0000000000..7de15c3dd5
--- /dev/null
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Facts.java
@@ -0,0 +1,185 @@
+// Copyright 2025 The Bazel Authors. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package com.google.devtools.build.lib.bazel.bzlmod;
+
+import com.google.auto.value.AutoValue;
+import com.google.devtools.build.docgen.annot.DocCategory;
+import com.google.devtools.build.lib.skyframe.serialization.VisibleForSerialization;
+import com.google.devtools.build.lib.skyframe.serialization.autocodec.AutoCodec;
+import java.util.TreeMap;
+import net.starlark.java.annot.Param;
+import net.starlark.java.annot.StarlarkBuiltin;
+import net.starlark.java.annot.StarlarkMethod;
+import net.starlark.java.eval.Dict;
+import net.starlark.java.eval.EvalException;
+import net.starlark.java.eval.NoneType;
+import net.starlark.java.eval.Printer;
+import net.starlark.java.eval.Starlark;
+import net.starlark.java.eval.StarlarkFloat;
+import net.starlark.java.eval.StarlarkIndexable;
+import net.starlark.java.eval.StarlarkInt;
+import net.starlark.java.eval.StarlarkList;
+import net.starlark.java.eval.StarlarkSemantics;
+import net.starlark.java.eval.StarlarkThread;
+import net.starlark.java.eval.Tuple;
+import net.starlark.java.types.StarlarkType;
+import net.starlark.java.types.Types;
+
+/**
+ * A container for user-provided JSON-like data attached to a module extension that is persisted
+ * across reevaluations of the extension.
+ */
+@AutoValue
+@AutoCodec
+@StarlarkBuiltin(
+    name = "Facts",
+    doc =
+        """
+        User-provided data attached to a module extension that is persisted across reevaluations of
+        the extension.
+
+        This type supports dict-like access (e.g. `facts["key"]` and `facts.get("key")`) as well as
+        membership tests (e.g. `"key" in facts`). It does not support iteration or methods like
+        `keys()`, `items()`, or `len()`.
+        """,
+    category = DocCategory.BUILTIN)
+public abstract class Facts implements StarlarkIndexable {
+  public static final Facts EMPTY = new AutoValue_Facts(Dict.empty());
+
+  public abstract Dict<String, Object> value();
+
+  public static Facts validateAndCreate(Object value) throws EvalException {
+    return new AutoValue_Facts(
+        validateAndNormalize(Dict.cast(value, String.class, Object.class, "facts")));
+  }
+
+  @AutoCodec.Instantiator
+  @VisibleForSerialization
+  public static Facts createUnchecked(Dict<String, Object> value) {
+    return new AutoValue_Facts(value);
+  }
+
+  // This limit only exists to prevent pathological uses of facts, which are meant to be
+  // human-readable and friendly to VCS merges.
+  private static final int MAX_FACTS_DEPTH = 7;
+
+  @SuppressWarnings("unchecked")
+  private static Dict<String, Object> validateAndNormalize(Dict<String, Object> facts)
+      throws EvalException {
+    return (Dict<String, Object>) validateAndNormalize(facts, MAX_FACTS_DEPTH);
+  }
+
+  private static Object validateAndNormalize(Object facts, int remainingDepth)
+      throws EvalException {
+    if (remainingDepth < 0) {
+      throw Starlark.errorf("Facts cannot be nested more than %s levels deep", MAX_FACTS_DEPTH);
+    }
+    // Only permit types that can be serialized to JSON and ensure that they contain no information
+    // not captured by equality by sorting dicts.
+    return switch (facts) {
+      case String s -> s;
+      case NoneType n -> n;
+      case Boolean b -> b;
+      case StarlarkFloat f -> f;
+      case StarlarkInt i -> i;
+      case StarlarkList<?> list -> {
+        Object[] normalizedList = new Object[list.size()];
+        for (int i = 0; i < list.size(); i++) {
+          normalizedList[i] = validateAndNormalize(list.get(i), remainingDepth - 1);
+        }
+        yield StarlarkList.immutableOf(normalizedList);
+      }
+      case Tuple tuple -> {
+        // Turn a tuple into a list since JSON does not have a tuple type.
+        Object[] normalizedList = new Object[tuple.size()];
+        for (int i = 0; i < tuple.size(); i++) {
+          normalizedList[i] = validateAndNormalize(tuple.get(i), remainingDepth - 1);
+        }
+        yield StarlarkList.immutableOf(normalizedList);
+      }
+      case Dict<?, ?> dict -> {
+        var builder = new TreeMap<String, Object>();
+        for (var entry : dict.entrySet()) {
+          if (!(entry.getKey() instanceof String string)) {
+            throw Starlark.errorf(
+                "Facts keys must be strings, got '%s' (%s)",
+                Starlark.repr(entry), Starlark.type(entry.getKey()));
+          }
+          builder.put(string, validateAndNormalize(entry.getValue(), remainingDepth - 1));
+        }
+        yield Dict.immutableCopyOf(builder);
+      }
+      default ->
+          throw Starlark.errorf(
+              "'%s' (%s) is not supported in facts", Starlark.repr(facts), Starlark.type(facts));
+    };
+  }
+
+  @Override
+  public Object getIndex(StarlarkSemantics semantics, Object key) {
+    return value().get(key);
+  }
+
+  @Override
+  public boolean containsKey(StarlarkSemantics semantics, Object key) {
+    return value().containsKey(key);
+  }
+
+  @StarlarkMethod(
+      name = "get",
+      doc = "Returns the value for <code>key</code> if it exists, or <code>default</code>.",
+      parameters = {
+        @Param(name = "key", doc = "The key to look up.", named = true),
+        @Param(
+            name = "default",
+            doc = "The value to return if <code>key</code> is not present.",
+            named = true,
+            defaultValue = "None"),
+      })
+  public Object get(String key, Object defaultValue) throws EvalException {
+    return value().getOrDefault(key, defaultValue);
+  }
+
+  @Override
+  public void repr(Printer printer, StarlarkSemantics semantics) {
+    // Don't leak the contents to Starlark.
+    printer.append("Facts(<opaque, inspect with print()>)");
+  }
+
+  @Override
+  public void debugPrint(Printer printer, StarlarkThread thread) {
+    // Print the contents for debugging purposes.
+    printer.append("Facts(");
+    value().repr(printer, thread.getSemantics());
+    printer.append(")");
+  }
+
+  @Override
+  public boolean isImmutable() {
+    return true;
+  }
+
+  @Override
+  public void checkHashable() throws EvalException {
+    throw Starlark.errorf("unhashable type: '%s'", Starlark.type(this));
+  }
+
+  @Override
+  public StarlarkType getStarlarkType() {
+    // TODO: Use Mapping instead of dict when available.
+    return Types.dict(Types.STR, Types.ANY);
+  }
+}
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/FactsAdapter.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/FactsAdapter.java
new file mode 100644
index 0000000000..c01e1b885c
--- /dev/null
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/FactsAdapter.java
@@ -0,0 +1,71 @@
+// Copyright 2025 The Bazel Authors. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package com.google.devtools.build.lib.bazel.bzlmod;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import net.starlark.java.eval.EvalException;
+import net.starlark.java.eval.Mutability;
+import net.starlark.java.eval.Starlark;
+import net.starlark.java.eval.StarlarkSemantics;
+import net.starlark.java.eval.StarlarkThread;
+import net.starlark.java.lib.json.Json;
+
+/** Helps serialize/deserialize {@link Facts}, which contains JSON-like Starlark values. */
+public class FactsAdapter extends TypeAdapter<Facts> {
+
+  private final Gson gson = new GsonBuilder().disableHtmlEscaping().create();
+
+  @Override
+  public void write(JsonWriter out, Facts facts) throws IOException {
+    String json;
+    try {
+      json = Json.INSTANCE.encode(facts.value());
+    } catch (EvalException | InterruptedException e) {
+      throw new IllegalStateException(
+          "Unexpected error while serializing facts (%s): %s"
+              .formatted(facts.value(), e.getMessage()),
+          e);
+    }
+    // Round-trip the JSON through Gson to ensure it is properly indented.
+    gson.toJson(gson.fromJson(json, JsonElement.class), out);
+  }
+
+  @Override
+  public Facts read(JsonReader in) throws IOException {
+    var jsonString = gson.toJson(JsonParser.parseReader(in));
+    try (var mu = Mutability.create("FactsAdapter")) {
+      var starlarkThread =
+          StarlarkThread.createTransient(
+              mu,
+              StarlarkSemantics.builder()
+                  // Ensure that UTF-8 strings are encoded correctly, matching the default semantics
+                  // derived from BuildLanguageOptions.
+                  .setBool(StarlarkSemantics.INTERNAL_BAZEL_ONLY_UTF_8_BYTE_STRINGS, true)
+                  .build());
+      return Facts.validateAndCreate(
+          Json.INSTANCE.decode(jsonString, Starlark.UNBOUND, starlarkThread));
+    } catch (EvalException e) {
+      throw new IOException("Failed to decode facts JSON: " + e.getMessage(), e);
+    }
+  }
+}
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/GsonTypeAdapterUtil.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/GsonTypeAdapterUtil.java
index 12bb5c9a24..59240506a0 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/GsonTypeAdapterUtil.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/GsonTypeAdapterUtil.java
@@ -481,6 +481,7 @@ public final class GsonTypeAdapterUtil {
   public static final Gson LOCKFILE_GSON =
       newGsonBuilder()
           .setPrettyPrinting()
+          .registerTypeAdapter(Facts.class, new FactsAdapter())
           .registerTypeAdapterFactory(new OptionalChecksumTypeAdapterFactory())
           .create();
 
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/InnateRunnableExtension.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/InnateRunnableExtension.java
index 5876265e4b..a9a6039be0 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/InnateRunnableExtension.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/InnateRunnableExtension.java
@@ -161,7 +161,8 @@ final class InnateRunnableExtension implements RunnableExtension {
       SingleExtensionUsagesValue usagesValue,
       StarlarkSemantics starlarkSemantics,
       ModuleExtensionId extensionId,
-      RepositoryMapping mainRepositoryMapping)
+      RepositoryMapping mainRepositoryMapping,
+      Facts facts)
       throws InterruptedException, ExternalDepsException {
     Object exported = loadedBzl.getModule().getGlobal(ruleName);
     if (exported == null) {
@@ -214,7 +215,7 @@ final class InnateRunnableExtension implements RunnableExtension {
         ImmutableSortedMap.of(),
         ImmutableSortedMap.of(),
         generatedRepoSpecs.buildOrThrow(),
-        Optional.of(ModuleExtensionMetadata.REPRODUCIBLE),
+        ModuleExtensionMetadata.REPRODUCIBLE,
         ImmutableTable.of());
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockFileModuleExtension.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockFileModuleExtension.java
index f706be6a59..8718920f4b 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockFileModuleExtension.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockFileModuleExtension.java
@@ -53,13 +53,15 @@ public abstract class LockFileModuleExtension {
 
   public abstract ImmutableMap<String, RepoSpec> getGeneratedRepoSpecs();
 
-  public abstract Optional<ModuleExtensionMetadata> getModuleExtensionMetadata();
+  public abstract Optional<LockfileModuleExtensionMetadata> getModuleExtensionMetadata();
 
   public abstract ImmutableTable<RepositoryName, String, RepositoryName>
       getRecordedRepoMappingEntries();
 
   public boolean isReproducible() {
-    return getModuleExtensionMetadata().map(ModuleExtensionMetadata::getReproducible).orElse(false);
+    return getModuleExtensionMetadata()
+        .map(LockfileModuleExtensionMetadata::getReproducible)
+        .orElse(false);
   }
 
   /** Builder type for {@link LockFileModuleExtension}. */
@@ -81,7 +83,8 @@ public abstract class LockFileModuleExtension {
 
     public abstract Builder setGeneratedRepoSpecs(ImmutableMap<String, RepoSpec> value);
 
-    public abstract Builder setModuleExtensionMetadata(Optional<ModuleExtensionMetadata> value);
+    public abstract Builder setModuleExtensionMetadata(
+        Optional<LockfileModuleExtensionMetadata> value);
 
     public abstract Builder setRecordedRepoMappingEntries(
         ImmutableTable<RepositoryName, String, RepositoryName> value);
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockfileModuleExtensionMetadata.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockfileModuleExtensionMetadata.java
new file mode 100644
index 0000000000..e76f610c8f
--- /dev/null
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/LockfileModuleExtensionMetadata.java
@@ -0,0 +1,287 @@
+// Copyright 2021 The Bazel Authors. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.devtools.build.lib.bazel.bzlmod;
+
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Sets;
+import com.google.devtools.build.lib.bazel.bzlmod.ModuleExtensionUsage.Proxy;
+import com.google.devtools.build.lib.events.Event;
+import com.google.devtools.build.lib.vfs.PathFragment;
+import com.ryanharter.auto.value.gson.GenerateTypeAdapter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.Set;
+import javax.annotation.Nullable;
+import net.starlark.java.eval.EvalException;
+import net.starlark.java.eval.Starlark;
+
+/**
+ * A trimmed down version of {@link ModuleExtensionMetadata} that is persisted in the lockfile.
+ *
+ * <p>The difference between this and {@link ModuleExtensionMetadata} is that this class does not
+ * include the {@link Facts} field. Instead, the facts are stored in a dedicated top-level field in
+ * the lockfile, for two reasons:
+ *
+ * <ul>
+ *   <li>Reproducible extensions, which do not store a lockfile entry and thus no instance of this
+ *       class, can have facts and should have them persisted - they may only be reproducible given
+ *       these facts.
+ *   <li>Lockfile entries are stored per OS/CPU if the extension declares a dependency on those, but
+ *       facts are always cross-platform.
+ * </ul>
+ */
+@AutoValue
+@GenerateTypeAdapter
+public abstract class LockfileModuleExtensionMetadata {
+
+  @Nullable
+  abstract ImmutableSet<String> getExplicitRootModuleDirectDeps();
+
+  @Nullable
+  abstract ImmutableSet<String> getExplicitRootModuleDirectDevDeps();
+
+  abstract ModuleExtensionMetadata.UseAllRepos getUseAllRepos();
+
+  abstract boolean getReproducible();
+
+  public static Optional<LockfileModuleExtensionMetadata> of(
+      ModuleExtensionMetadata moduleExtensionMetadata) {
+    if (moduleExtensionMetadata.equals(ModuleExtensionMetadata.DEFAULT)) {
+      return Optional.empty();
+    }
+    return Optional.of(
+        new AutoValue_LockfileModuleExtensionMetadata(
+            moduleExtensionMetadata.getExplicitRootModuleDirectDeps(),
+            moduleExtensionMetadata.getExplicitRootModuleDirectDevDeps(),
+            moduleExtensionMetadata.getUseAllRepos(),
+            moduleExtensionMetadata.getReproducible()));
+  }
+
+  public Optional<RootModuleFileFixup> generateFixup(
+      ModuleExtensionUsage rootUsage, Set<String> allRepos) throws EvalException {
+    var rootModuleDirectDevDeps = getRootModuleDirectDevDeps(allRepos);
+    var rootModuleDirectDeps = getRootModuleDirectDeps(allRepos);
+    if (rootModuleDirectDevDeps.isEmpty() && rootModuleDirectDeps.isEmpty()) {
+      return Optional.empty();
+    }
+    Preconditions.checkState(
+        rootModuleDirectDevDeps.isPresent() && rootModuleDirectDeps.isPresent());
+
+    if (!rootUsage.getHasNonDevUseExtension() && !rootModuleDirectDeps.get().isEmpty()) {
+      throw Starlark.errorf(
+          "root_module_direct_deps must be empty if the root module contains no "
+              + "usages with dev_dependency = False");
+    }
+    if (!rootUsage.getHasDevUseExtension() && !rootModuleDirectDevDeps.get().isEmpty()) {
+      throw Starlark.errorf(
+          "root_module_direct_dev_deps must be empty if the root module contains no "
+              + "usages with dev_dependency = True");
+    }
+
+    return generateFixup(
+        rootUsage, allRepos, rootModuleDirectDeps.get(), rootModuleDirectDevDeps.get());
+  }
+
+  private static Optional<RootModuleFileFixup> generateFixup(
+      ModuleExtensionUsage rootUsage,
+      Set<String> allRepos,
+      Set<String> expectedImports,
+      Set<String> expectedDevImports) {
+    var actualDevImports =
+        rootUsage.getProxies().stream()
+            .filter(p -> p.isDevDependency())
+            .flatMap(p -> p.getImports().values().stream())
+            .collect(toImmutableSet());
+    var actualImports =
+        rootUsage.getProxies().stream()
+            .filter(p -> !p.isDevDependency())
+            .flatMap(p -> p.getImports().values().stream())
+            .collect(toImmutableSet());
+
+    String extensionBzlFile = rootUsage.getExtensionBzlFile();
+    String extensionName = rootUsage.getExtensionName();
+
+    var importsToAdd = ImmutableSortedSet.copyOf(Sets.difference(expectedImports, actualImports));
+    var importsToRemove =
+        ImmutableSortedSet.copyOf(Sets.difference(actualImports, expectedImports));
+    var devImportsToAdd =
+        ImmutableSortedSet.copyOf(Sets.difference(expectedDevImports, actualDevImports));
+    var devImportsToRemove =
+        ImmutableSortedSet.copyOf(Sets.difference(actualDevImports, expectedDevImports));
+
+    if (importsToAdd.isEmpty()
+        && importsToRemove.isEmpty()
+        && devImportsToAdd.isEmpty()
+        && devImportsToRemove.isEmpty()) {
+      return Optional.empty();
+    }
+
+    var message =
+        String.format(
+            "The module extension %s defined in %s reported incorrect imports "
+                + "of repositories via use_repo():\n\n",
+            extensionName, extensionBzlFile);
+
+    var allActualImports = ImmutableSortedSet.copyOf(Sets.union(actualImports, actualDevImports));
+    var allExpectedImports =
+        ImmutableSortedSet.copyOf(Sets.union(expectedImports, expectedDevImports));
+
+    var invalidImports = ImmutableSortedSet.copyOf(Sets.difference(allActualImports, allRepos));
+    if (!invalidImports.isEmpty()) {
+      message +=
+          String.format(
+              "Imported, but not created by the extension (will cause the build to fail):\n"
+                  + "    %s\n\n",
+              String.join(", ", invalidImports));
+    }
+
+    var missingImports =
+        ImmutableSortedSet.copyOf(Sets.difference(allExpectedImports, allActualImports));
+    if (!missingImports.isEmpty()) {
+      message +=
+          String.format(
+              "Not imported, but reported as direct dependencies by the extension (may cause the"
+                  + " build to fail):\n"
+                  + "    %s\n\n",
+              String.join(", ", missingImports));
+    }
+
+    var nonDevImportsOfDevDeps =
+        ImmutableSortedSet.copyOf(Sets.intersection(expectedDevImports, actualImports));
+    if (!nonDevImportsOfDevDeps.isEmpty()) {
+      message +=
+          String.format(
+              "Imported as a regular dependency, but reported as a dev dependency by the "
+                  + "extension (may cause the build to fail when used by other modules):\n"
+                  + "    %s\n\n",
+              String.join(", ", nonDevImportsOfDevDeps));
+    }
+
+    var devImportsOfNonDevDeps =
+        ImmutableSortedSet.copyOf(Sets.intersection(expectedImports, actualDevImports));
+    if (!devImportsOfNonDevDeps.isEmpty()) {
+      message +=
+          String.format(
+              "Imported as a dev dependency, but reported as a regular dependency by the "
+                  + "extension (may cause the build to fail when used by other modules):\n"
+                  + "    %s\n\n",
+              String.join(", ", devImportsOfNonDevDeps));
+    }
+
+    var indirectDepImports =
+        ImmutableSortedSet.copyOf(
+            Sets.difference(Sets.intersection(allActualImports, allRepos), allExpectedImports));
+    if (!indirectDepImports.isEmpty()) {
+      message +=
+          String.format(
+              "Imported, but reported as indirect dependencies by the extension:\n    %s\n\n",
+              String.join(", ", indirectDepImports));
+    }
+
+    message += "Fix the use_repo calls by running 'bazel mod tidy'.";
+
+    var moduleFilePathToCommandsBuilder = ImmutableListMultimap.<PathFragment, String>builder();
+    // Repos to add are easy: always add them to the first proxy of the correct type.
+    if (!importsToAdd.isEmpty()) {
+      Proxy firstNonDevProxy =
+          rootUsage.getProxies().stream().filter(p -> !p.isDevDependency()).findFirst().get();
+      moduleFilePathToCommandsBuilder.put(
+          firstNonDevProxy.getContainingModuleFilePath(),
+          makeUseRepoCommand("use_repo_add", firstNonDevProxy.getProxyName(), importsToAdd));
+    }
+    if (!devImportsToAdd.isEmpty()) {
+      Proxy firstDevProxy =
+          rootUsage.getProxies().stream().filter(p -> p.isDevDependency()).findFirst().get();
+      moduleFilePathToCommandsBuilder.put(
+          firstDevProxy.getContainingModuleFilePath(),
+          makeUseRepoCommand("use_repo_add", firstDevProxy.getProxyName(), devImportsToAdd));
+    }
+    // Repos to remove are a bit trickier: remove them from the proxy that actually imported them.
+    for (Proxy proxy : rootUsage.getProxies()) {
+      var toRemove =
+          ImmutableSortedSet.copyOf(
+              Sets.intersection(
+                  proxy.getImports().values(),
+                  proxy.isDevDependency() ? devImportsToRemove : importsToRemove));
+      if (!toRemove.isEmpty()) {
+        moduleFilePathToCommandsBuilder.put(
+            proxy.getContainingModuleFilePath(),
+            makeUseRepoCommand("use_repo_remove", proxy.getProxyName(), toRemove));
+      }
+    }
+
+    return Optional.of(
+        new RootModuleFileFixup(
+            moduleFilePathToCommandsBuilder.build(),
+            rootUsage,
+            Event.warn(rootUsage.getProxies().getFirst().getLocation(), message)));
+  }
+
+  private static String makeUseRepoCommand(String cmd, String proxyName, Collection<String> repos) {
+    var commandParts = new ArrayList<String>();
+    commandParts.add(cmd);
+    commandParts.add(proxyName.isEmpty() ? "_unnamed_usage" : proxyName);
+    commandParts.addAll(repos);
+    return String.join(" ", commandParts);
+  }
+
+  private Optional<ImmutableSet<String>> getRootModuleDirectDeps(Set<String> allRepos)
+      throws EvalException {
+    return switch (getUseAllRepos()) {
+      case NO -> {
+        if (getExplicitRootModuleDirectDeps() != null) {
+          Set<String> invalidRepos = Sets.difference(getExplicitRootModuleDirectDeps(), allRepos);
+          if (!invalidRepos.isEmpty()) {
+            throw Starlark.errorf(
+                "root_module_direct_deps contained the following repositories "
+                    + "not generated by the extension: %s",
+                String.join(", ", invalidRepos));
+          }
+        }
+        yield Optional.ofNullable(getExplicitRootModuleDirectDeps());
+      }
+      case REGULAR -> Optional.of(ImmutableSet.copyOf(allRepos));
+      case DEV -> Optional.of(ImmutableSet.of());
+    };
+  }
+
+  private Optional<ImmutableSet<String>> getRootModuleDirectDevDeps(Set<String> allRepos)
+      throws EvalException {
+    return switch (getUseAllRepos()) {
+      case NO -> {
+        if (getExplicitRootModuleDirectDevDeps() != null) {
+          Set<String> invalidRepos =
+              Sets.difference(getExplicitRootModuleDirectDevDeps(), allRepos);
+          if (!invalidRepos.isEmpty()) {
+            throw Starlark.errorf(
+                "root_module_direct_dev_deps contained the following "
+                    + "repositories not generated by the extension: %s",
+                String.join(", ", invalidRepos));
+          }
+        }
+        yield Optional.ofNullable(getExplicitRootModuleDirectDevDeps());
+      }
+      case REGULAR -> Optional.of(ImmutableSet.of());
+      case DEV -> Optional.of(ImmutableSet.copyOf(allRepos));
+    };
+  }
+}
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionContext.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionContext.java
index 3e57cd7fe3..9839180f97 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionContext.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionContext.java
@@ -29,6 +29,7 @@ import net.starlark.java.annot.Param;
 import net.starlark.java.annot.ParamType;
 import net.starlark.java.annot.StarlarkBuiltin;
 import net.starlark.java.annot.StarlarkMethod;
+import net.starlark.java.eval.Dict;
 import net.starlark.java.eval.EvalException;
 import net.starlark.java.eval.NoneType;
 import net.starlark.java.eval.Sequence;
@@ -47,6 +48,7 @@ import net.starlark.java.eval.StarlarkSemantics;
 public class ModuleExtensionContext extends StarlarkBaseExternalContext {
   private final ModuleExtensionId extensionId;
   private final StarlarkList<StarlarkBazelModule> modules;
+  private final Facts facts;
   private final boolean rootModuleHasNonDevDependency;
 
   protected ModuleExtensionContext(
@@ -61,6 +63,7 @@ public class ModuleExtensionContext extends StarlarkBaseExternalContext {
       @Nullable RepositoryRemoteExecutor remoteExecutor,
       ModuleExtensionId extensionId,
       StarlarkList<StarlarkBazelModule> modules,
+      Facts facts,
       boolean rootModuleHasNonDevDependency) {
     super(
         workingDirectory,
@@ -76,6 +79,7 @@ public class ModuleExtensionContext extends StarlarkBaseExternalContext {
         /* allowWatchingPathsOutsideWorkspace= */ false);
     this.extensionId = extensionId;
     this.modules = modules;
+    this.facts = facts;
     this.rootModuleHasNonDevDependency = rootModuleHasNonDevDependency;
   }
 
@@ -110,6 +114,23 @@ public class ModuleExtensionContext extends StarlarkBaseExternalContext {
     return modules;
   }
 
+  @StarlarkMethod(
+      name = "facts",
+      structField = true,
+      doc =
+          """
+          The JSON-like dict returned by a previous execution of this extension in the `facts`
+          parameter of [`extension_metadata`](../builtins/module_ctx#extension_metadata) or else
+          `{}`.
+          This is useful for extensions that want to preserve universally true facts such as the
+          hashes of artifacts in an immutable repository.
+          Note that the returned value may have been created by a different version of the
+          extension, which may have used a different schema.
+          """)
+  public Facts getFacts() {
+    return facts;
+  }
+
   @StarlarkMethod(
       name = "is_dev_dependency",
       doc =
@@ -220,13 +241,44 @@ public class ModuleExtensionContext extends StarlarkBaseExternalContext {
             allowedTypes = {
               @ParamType(type = Boolean.class),
             }),
+        @Param(
+            name = "facts",
+            doc =
+                """
+                A JSON-like dict that is made available to future executions of this extension via
+                the `module_ctx.facts` property.
+                This is useful for extensions that want to preserve universally true facts such as
+                the hashes of artifacts in an immutable repository.
+
+                Bazel may shallowly merge multiple facts dicts returned by different versions of the
+                extension in order to resolve merge conflicts on the MODULE.bazel.lock file, as if
+                by applying the `dict.update()` method or the `|` operator in Starlark. Extensions
+                should use facts for key-value storage only and ensure that the key uniquely
+                determines the value, although perhaps only via additional information and network
+                access. An extension can opt out of this merging by providing a dict with a single,
+                fixed top-level key and an arbitrary value.
+
+                Note that the value provided here may be read back by a different version of the
+                extension, so either include a version number or use a schema that is unlikely to
+                result in ambiguities.
+                """,
+            positional = false,
+            named = true,
+            defaultValue = "{}",
+            allowedTypes = {
+              @ParamType(type = Dict.class, generic1 = String.class),
+            }),
       })
   public ModuleExtensionMetadata extensionMetadata(
       Object rootModuleDirectDepsUnchecked,
       Object rootModuleDirectDevDepsUnchecked,
-      boolean reproducible)
+      boolean reproducible,
+      Object facts)
       throws EvalException {
     return ModuleExtensionMetadata.create(
-        rootModuleDirectDepsUnchecked, rootModuleDirectDevDepsUnchecked, reproducible);
+        rootModuleDirectDepsUnchecked,
+        rootModuleDirectDevDepsUnchecked,
+        reproducible,
+        Dict.cast(facts, String.class, Object.class, "facts"));
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionMetadata.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionMetadata.java
index 3c267fff16..536e6940e3 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionMetadata.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionMetadata.java
@@ -14,34 +14,22 @@
 
 package com.google.devtools.build.lib.bazel.bzlmod;
 
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
-
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Sets;
 import com.google.devtools.build.docgen.annot.DocCategory;
-import com.google.devtools.build.lib.bazel.bzlmod.ModuleExtensionUsage.Proxy;
 import com.google.devtools.build.lib.cmdline.RepositoryName;
-import com.google.devtools.build.lib.events.Event;
-import com.google.devtools.build.lib.vfs.PathFragment;
-import com.ryanharter.auto.value.gson.GenerateTypeAdapter;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.LinkedHashSet;
-import java.util.Optional;
 import java.util.Set;
 import javax.annotation.Nullable;
 import net.starlark.java.annot.StarlarkBuiltin;
+import net.starlark.java.eval.Dict;
 import net.starlark.java.eval.EvalException;
 import net.starlark.java.eval.Sequence;
 import net.starlark.java.eval.Starlark;
 import net.starlark.java.eval.StarlarkList;
 import net.starlark.java.eval.StarlarkValue;
 
-/** The Starlark object passed to the implementation function of module extension metadata. */
+/** The Starlark object optionally returned by a module extension's implementation function. */
 @StarlarkBuiltin(
     name = "extension_metadata",
     category = DocCategory.BUILTIN,
@@ -49,15 +37,23 @@ import net.starlark.java.eval.StarlarkValue;
         "Return values of this type from a module extension's implementation function to "
             + "provide metadata about the repositories generated by the extension to Bazel.")
 @AutoValue
-@GenerateTypeAdapter
 public abstract class ModuleExtensionMetadata implements StarlarkValue {
 
+  static final ModuleExtensionMetadata DEFAULT =
+      create(
+          /* explicitRootModuleDirectDeps= */ null,
+          /* explicitRootModuleDirectDevDeps= */ null,
+          UseAllRepos.NO,
+          /* reproducible= */ false,
+          /* facts= */ Facts.EMPTY);
+
   static final ModuleExtensionMetadata REPRODUCIBLE =
       create(
           /* explicitRootModuleDirectDeps= */ null,
           /* explicitRootModuleDirectDevDeps= */ null,
           UseAllRepos.NO,
-          /* reproducible= */ true);
+          /* reproducible= */ true,
+          /* facts= */ Facts.EMPTY);
 
   @Nullable
   abstract ImmutableSet<String> getExplicitRootModuleDirectDeps();
@@ -69,11 +65,14 @@ public abstract class ModuleExtensionMetadata implements StarlarkValue {
 
   abstract boolean getReproducible();
 
+  abstract Facts getFacts();
+
   private static ModuleExtensionMetadata create(
       @Nullable Set<String> explicitRootModuleDirectDeps,
       @Nullable Set<String> explicitRootModuleDirectDevDeps,
       UseAllRepos useAllRepos,
-      boolean reproducible) {
+      boolean reproducible,
+      Facts facts) {
     return new AutoValue_ModuleExtensionMetadata(
         explicitRootModuleDirectDeps != null
             ? ImmutableSet.copyOf(explicitRootModuleDirectDeps)
@@ -82,29 +81,33 @@ public abstract class ModuleExtensionMetadata implements StarlarkValue {
             ? ImmutableSet.copyOf(explicitRootModuleDirectDevDeps)
             : null,
         useAllRepos,
-        reproducible);
+        reproducible,
+        facts);
   }
 
   static ModuleExtensionMetadata create(
       Object rootModuleDirectDepsUnchecked,
       Object rootModuleDirectDevDepsUnchecked,
-      boolean reproducible)
+      boolean reproducible,
+      Dict<String, Object> factsObj)
       throws EvalException {
+    var facts = Facts.validateAndCreate(factsObj);
+
     if (rootModuleDirectDepsUnchecked == Starlark.NONE
         && rootModuleDirectDevDepsUnchecked == Starlark.NONE) {
-      return create(null, null, UseAllRepos.NO, reproducible);
+      return create(null, null, UseAllRepos.NO, reproducible, facts);
     }
 
     // When root_module_direct_deps = "all", accept both root_module_direct_dev_deps = None and
     // root_module_direct_dev_deps = [], but not root_module_direct_dev_deps = ["some_repo"].
     if (rootModuleDirectDepsUnchecked.equals("all")
         && rootModuleDirectDevDepsUnchecked.equals(StarlarkList.immutableOf())) {
-      return create(null, null, UseAllRepos.REGULAR, reproducible);
+      return create(null, null, UseAllRepos.REGULAR, reproducible, facts);
     }
 
     if (rootModuleDirectDevDepsUnchecked.equals("all")
         && rootModuleDirectDepsUnchecked.equals(StarlarkList.immutableOf())) {
-      return create(null, null, UseAllRepos.DEV, reproducible);
+      return create(null, null, UseAllRepos.DEV, reproducible, facts);
     }
 
     if (rootModuleDirectDepsUnchecked.equals("all")
@@ -166,216 +169,8 @@ public abstract class ModuleExtensionMetadata implements StarlarkValue {
         explicitRootModuleDirectDeps,
         explicitRootModuleDirectDevDeps,
         UseAllRepos.NO,
-        reproducible);
-  }
-
-  public Optional<RootModuleFileFixup> generateFixup(
-      ModuleExtensionUsage rootUsage, Set<String> allRepos) throws EvalException {
-    var rootModuleDirectDevDeps = getRootModuleDirectDevDeps(allRepos);
-    var rootModuleDirectDeps = getRootModuleDirectDeps(allRepos);
-    if (rootModuleDirectDevDeps.isEmpty() && rootModuleDirectDeps.isEmpty()) {
-      return Optional.empty();
-    }
-    Preconditions.checkState(
-        rootModuleDirectDevDeps.isPresent() && rootModuleDirectDeps.isPresent());
-
-    if (!rootUsage.getHasNonDevUseExtension() && !rootModuleDirectDeps.get().isEmpty()) {
-      throw Starlark.errorf(
-          "root_module_direct_deps must be empty if the root module contains no "
-              + "usages with dev_dependency = False");
-    }
-    if (!rootUsage.getHasDevUseExtension() && !rootModuleDirectDevDeps.get().isEmpty()) {
-      throw Starlark.errorf(
-          "root_module_direct_dev_deps must be empty if the root module contains no "
-              + "usages with dev_dependency = True");
-    }
-
-    return generateFixup(
-        rootUsage, allRepos, rootModuleDirectDeps.get(), rootModuleDirectDevDeps.get());
-  }
-
-  private static Optional<RootModuleFileFixup> generateFixup(
-      ModuleExtensionUsage rootUsage,
-      Set<String> allRepos,
-      Set<String> expectedImports,
-      Set<String> expectedDevImports) {
-    var actualDevImports =
-        rootUsage.getProxies().stream()
-            .filter(p -> p.isDevDependency())
-            .flatMap(p -> p.getImports().values().stream())
-            .collect(toImmutableSet());
-    var actualImports =
-        rootUsage.getProxies().stream()
-            .filter(p -> !p.isDevDependency())
-            .flatMap(p -> p.getImports().values().stream())
-            .collect(toImmutableSet());
-
-    String extensionBzlFile = rootUsage.getExtensionBzlFile();
-    String extensionName = rootUsage.getExtensionName();
-
-    var importsToAdd = ImmutableSortedSet.copyOf(Sets.difference(expectedImports, actualImports));
-    var importsToRemove =
-        ImmutableSortedSet.copyOf(Sets.difference(actualImports, expectedImports));
-    var devImportsToAdd =
-        ImmutableSortedSet.copyOf(Sets.difference(expectedDevImports, actualDevImports));
-    var devImportsToRemove =
-        ImmutableSortedSet.copyOf(Sets.difference(actualDevImports, expectedDevImports));
-
-    if (importsToAdd.isEmpty()
-        && importsToRemove.isEmpty()
-        && devImportsToAdd.isEmpty()
-        && devImportsToRemove.isEmpty()) {
-      return Optional.empty();
-    }
-
-    var message =
-        String.format(
-            "The module extension %s defined in %s reported incorrect imports "
-                + "of repositories via use_repo():\n\n",
-            extensionName, extensionBzlFile);
-
-    var allActualImports = ImmutableSortedSet.copyOf(Sets.union(actualImports, actualDevImports));
-    var allExpectedImports =
-        ImmutableSortedSet.copyOf(Sets.union(expectedImports, expectedDevImports));
-
-    var invalidImports = ImmutableSortedSet.copyOf(Sets.difference(allActualImports, allRepos));
-    if (!invalidImports.isEmpty()) {
-      message +=
-          String.format(
-              "Imported, but not created by the extension (will cause the build to fail):\n"
-                  + "    %s\n\n",
-              String.join(", ", invalidImports));
-    }
-
-    var missingImports =
-        ImmutableSortedSet.copyOf(Sets.difference(allExpectedImports, allActualImports));
-    if (!missingImports.isEmpty()) {
-      message +=
-          String.format(
-              "Not imported, but reported as direct dependencies by the extension (may cause the"
-                  + " build to fail):\n"
-                  + "    %s\n\n",
-              String.join(", ", missingImports));
-    }
-
-    var nonDevImportsOfDevDeps =
-        ImmutableSortedSet.copyOf(Sets.intersection(expectedDevImports, actualImports));
-    if (!nonDevImportsOfDevDeps.isEmpty()) {
-      message +=
-          String.format(
-              "Imported as a regular dependency, but reported as a dev dependency by the "
-                  + "extension (may cause the build to fail when used by other modules):\n"
-                  + "    %s\n\n",
-              String.join(", ", nonDevImportsOfDevDeps));
-    }
-
-    var devImportsOfNonDevDeps =
-        ImmutableSortedSet.copyOf(Sets.intersection(expectedImports, actualDevImports));
-    if (!devImportsOfNonDevDeps.isEmpty()) {
-      message +=
-          String.format(
-              "Imported as a dev dependency, but reported as a regular dependency by the "
-                  + "extension (may cause the build to fail when used by other modules):\n"
-                  + "    %s\n\n",
-              String.join(", ", devImportsOfNonDevDeps));
-    }
-
-    var indirectDepImports =
-        ImmutableSortedSet.copyOf(
-            Sets.difference(Sets.intersection(allActualImports, allRepos), allExpectedImports));
-    if (!indirectDepImports.isEmpty()) {
-      message +=
-          String.format(
-              "Imported, but reported as indirect dependencies by the extension:\n    %s\n\n",
-              String.join(", ", indirectDepImports));
-    }
-
-    message += "Fix the use_repo calls by running 'bazel mod tidy'.";
-
-    var moduleFilePathToCommandsBuilder = ImmutableListMultimap.<PathFragment, String>builder();
-    // Repos to add are easy: always add them to the first proxy of the correct type.
-    if (!importsToAdd.isEmpty()) {
-      Proxy firstNonDevProxy =
-          rootUsage.getProxies().stream().filter(p -> !p.isDevDependency()).findFirst().get();
-      moduleFilePathToCommandsBuilder.put(
-          firstNonDevProxy.getContainingModuleFilePath(),
-          makeUseRepoCommand("use_repo_add", firstNonDevProxy.getProxyName(), importsToAdd));
-    }
-    if (!devImportsToAdd.isEmpty()) {
-      Proxy firstDevProxy =
-          rootUsage.getProxies().stream().filter(p -> p.isDevDependency()).findFirst().get();
-      moduleFilePathToCommandsBuilder.put(
-          firstDevProxy.getContainingModuleFilePath(),
-          makeUseRepoCommand("use_repo_add", firstDevProxy.getProxyName(), devImportsToAdd));
-    }
-    // Repos to remove are a bit trickier: remove them from the proxy that actually imported them.
-    for (Proxy proxy : rootUsage.getProxies()) {
-      var toRemove =
-          ImmutableSortedSet.copyOf(
-              Sets.intersection(
-                  proxy.getImports().values(),
-                  proxy.isDevDependency() ? devImportsToRemove : importsToRemove));
-      if (!toRemove.isEmpty()) {
-        moduleFilePathToCommandsBuilder.put(
-            proxy.getContainingModuleFilePath(),
-            makeUseRepoCommand("use_repo_remove", proxy.getProxyName(), toRemove));
-      }
-    }
-
-    return Optional.of(
-        new RootModuleFileFixup(
-            moduleFilePathToCommandsBuilder.build(),
-            rootUsage,
-            Event.warn(rootUsage.getProxies().getFirst().getLocation(), message)));
-  }
-
-  private static String makeUseRepoCommand(String cmd, String proxyName, Collection<String> repos) {
-    var commandParts = new ArrayList<String>();
-    commandParts.add(cmd);
-    commandParts.add(proxyName.isEmpty() ? "_unnamed_usage" : proxyName);
-    commandParts.addAll(repos);
-    return String.join(" ", commandParts);
-  }
-
-  private Optional<ImmutableSet<String>> getRootModuleDirectDeps(Set<String> allRepos)
-      throws EvalException {
-    return switch (getUseAllRepos()) {
-      case NO -> {
-        if (getExplicitRootModuleDirectDeps() != null) {
-          Set<String> invalidRepos = Sets.difference(getExplicitRootModuleDirectDeps(), allRepos);
-          if (!invalidRepos.isEmpty()) {
-            throw Starlark.errorf(
-                "root_module_direct_deps contained the following repositories "
-                    + "not generated by the extension: %s",
-                String.join(", ", invalidRepos));
-          }
-        }
-        yield Optional.ofNullable(getExplicitRootModuleDirectDeps());
-      }
-      case REGULAR -> Optional.of(ImmutableSet.copyOf(allRepos));
-      case DEV -> Optional.of(ImmutableSet.of());
-    };
-  }
-
-  private Optional<ImmutableSet<String>> getRootModuleDirectDevDeps(Set<String> allRepos)
-      throws EvalException {
-    return switch (getUseAllRepos()) {
-      case NO -> {
-        if (getExplicitRootModuleDirectDevDeps() != null) {
-          Set<String> invalidRepos =
-              Sets.difference(getExplicitRootModuleDirectDevDeps(), allRepos);
-          if (!invalidRepos.isEmpty()) {
-            throw Starlark.errorf(
-                "root_module_direct_dev_deps contained the following "
-                    + "repositories not generated by the extension: %s",
-                String.join(", ", invalidRepos));
-          }
-        }
-        yield Optional.ofNullable(getExplicitRootModuleDirectDevDeps());
-      }
-      case REGULAR -> Optional.of(ImmutableSet.of());
-      case DEV -> Optional.of(ImmutableSet.copyOf(allRepos));
-    };
+        reproducible,
+        facts);
   }
 
   enum UseAllRepos {
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RegularRunnableExtension.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RegularRunnableExtension.java
index 28c2d51f5d..c0cb03650b 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RegularRunnableExtension.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RegularRunnableExtension.java
@@ -217,7 +217,8 @@ final class RegularRunnableExtension implements RunnableExtension {
       SingleExtensionUsagesValue usagesValue,
       StarlarkSemantics starlarkSemantics,
       ModuleExtensionId extensionId,
-      RepositoryMapping mainRepositoryMapping)
+      RepositoryMapping mainRepositoryMapping,
+      Facts facts)
       throws InterruptedException, ExternalDepsException {
     // See below (the `catch CancellationException` clause) for why there's a `while` loop here.
     while (true) {
@@ -228,7 +229,12 @@ final class RegularRunnableExtension implements RunnableExtension {
             "module-extension-" + extensionId,
             (workerEnv) ->
                 runInternal(
-                    workerEnv, usagesValue, starlarkSemantics, extensionId, mainRepositoryMapping));
+                    workerEnv,
+                    usagesValue,
+                    starlarkSemantics,
+                    extensionId,
+                    mainRepositoryMapping,
+                    facts));
       } catch (ExecutionException e) {
         Throwables.throwIfInstanceOf(e.getCause(), ExternalDepsException.class);
         Throwables.throwIfInstanceOf(e.getCause(), InterruptedException.class);
@@ -248,7 +254,8 @@ final class RegularRunnableExtension implements RunnableExtension {
       SingleExtensionUsagesValue usagesValue,
       StarlarkSemantics starlarkSemantics,
       ModuleExtensionId extensionId,
-      RepositoryMapping mainRepositoryMapping)
+      RepositoryMapping mainRepositoryMapping,
+      Facts facts)
       throws InterruptedException, ExternalDepsException {
     env.getListener().post(ModuleExtensionEvaluationProgress.ongoing(extensionId, "starting"));
     ModuleExtensionEvalStarlarkThreadContext threadContext =
@@ -260,13 +267,14 @@ final class RegularRunnableExtension implements RunnableExtension {
             usagesValue.getRepoOverrides(),
             mainRepositoryMapping,
             env.getListener());
-    Optional<ModuleExtensionMetadata> moduleExtensionMetadata;
+    ModuleExtensionMetadata moduleExtensionMetadata;
     var repoMappingRecorder = new Label.RepoMappingRecorder();
     repoMappingRecorder.mergeEntries(bzlLoadValue.getRecordedRepoMappings());
     try (Mutability mu =
             Mutability.create("module extension", usagesValue.getExtensionUniqueName());
         ModuleExtensionContext moduleContext =
-            createContext(env, usagesValue, starlarkSemantics, extensionId, repoMappingRecorder)) {
+            createContext(
+                env, usagesValue, starlarkSemantics, extensionId, repoMappingRecorder, facts)) {
       StarlarkThread thread =
           StarlarkThread.create(
               mu,
@@ -291,9 +299,9 @@ final class RegularRunnableExtension implements RunnableExtension {
               Starlark.type(returnValue));
         }
         if (returnValue instanceof ModuleExtensionMetadata retMetadata) {
-          moduleExtensionMetadata = Optional.of(retMetadata);
+          moduleExtensionMetadata = retMetadata;
         } else {
-          moduleExtensionMetadata = Optional.empty();
+          moduleExtensionMetadata = ModuleExtensionMetadata.DEFAULT;
         }
       } catch (NeedsSkyframeRestartException e) {
         // Restart by returning null.
@@ -330,7 +338,8 @@ final class RegularRunnableExtension implements RunnableExtension {
       SingleExtensionUsagesValue usagesValue,
       StarlarkSemantics starlarkSemantics,
       ModuleExtensionId extensionId,
-      Label.RepoMappingRecorder repoMappingRecorder)
+      Label.RepoMappingRecorder repoMappingRecorder,
+      Facts facts)
       throws ExternalDepsException {
     Path workingDirectory =
         directories
@@ -363,6 +372,7 @@ final class RegularRunnableExtension implements RunnableExtension {
         repositoryRemoteExecutor,
         extensionId,
         StarlarkList.immutableCopyOf(modules),
+        facts,
         rootModuleHasNonDevDependency);
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RunnableExtension.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RunnableExtension.java
index 68c268d913..9065194928 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RunnableExtension.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/RunnableExtension.java
@@ -51,7 +51,8 @@ interface RunnableExtension {
       SingleExtensionUsagesValue usagesValue,
       StarlarkSemantics starlarkSemantics,
       ModuleExtensionId extensionId,
-      RepositoryMapping mainRepositoryMapping)
+      RepositoryMapping mainRepositoryMapping,
+      Facts facts)
       throws InterruptedException, ExternalDepsException;
 
   /* Holds the result data from running a module extension */
@@ -60,6 +61,6 @@ interface RunnableExtension {
       ImmutableSortedMap<RepoRecordedInput.Dirents, String> recordedDirentsInputs,
       ImmutableSortedMap<RepoRecordedInput.EnvVar, Optional<String>> recordedEnvVarInputs,
       ImmutableMap<String, RepoSpec> generatedRepoSpecs,
-      Optional<ModuleExtensionMetadata> moduleExtensionMetadata,
+      ModuleExtensionMetadata moduleExtensionMetadata,
       ImmutableTable<RepositoryName, String, RepositoryName> recordedRepoMappingEntries) {}
 }
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
index c9d8266083..fd2537dd94 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionEvalFunction.java
@@ -53,6 +53,7 @@ import java.util.function.Function;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.starlark.java.eval.EvalException;
+import net.starlark.java.eval.Starlark;
 import net.starlark.java.eval.StarlarkSemantics;
 
 /**
@@ -137,8 +138,8 @@ public class SingleExtensionEvalFunction implements SkyFunction {
     }
 
     // Check the lockfile first for that module extension
-    LockFileModuleExtension lockedExtension = null;
     LockfileMode lockfileMode = BazelLockFileFunction.LOCKFILE_MODE.get(env);
+    Facts lockfileFacts = Facts.EMPTY;
     if (!lockfileMode.equals(LockfileMode.OFF)) {
       var lockfiles =
           env.getValuesAndExceptions(
@@ -149,8 +150,9 @@ public class SingleExtensionEvalFunction implements SkyFunction {
       if (lockfile == null || hiddenLockfile == null) {
         return null;
       }
+      lockfileFacts = lockfile.getFacts().getOrDefault(extensionId, Facts.EMPTY);
       var lockedExtensionMap = lockfile.getModuleExtensions().get(extensionId);
-      lockedExtension =
+      var lockedExtension =
           lockedExtensionMap == null ? null : lockedExtensionMap.get(extension.getEvalFactors());
       if (lockedExtension == null) {
         lockedExtensionMap = hiddenLockfile.getModuleExtensions().get(extensionId);
@@ -168,7 +170,8 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                   extension,
                   usagesValue,
                   extension.getEvalFactors(),
-                  lockedExtension);
+                  lockedExtension,
+                  lockfileFacts);
           if (singleExtensionValue != null) {
             return singleExtensionValue;
           }
@@ -187,7 +190,8 @@ public class SingleExtensionEvalFunction implements SkyFunction {
               usagesValue,
               starlarkSemantics,
               extensionId,
-              mainRepoMappingValue.repositoryMapping());
+              mainRepoMappingValue.repositoryMapping(),
+              lockfileFacts);
     } catch (ExternalDepsException e) {
       throw new SingleExtensionEvalFunctionException(e);
     }
@@ -195,7 +199,7 @@ public class SingleExtensionEvalFunction implements SkyFunction {
       return null;
     }
     ImmutableMap<String, RepoSpec> generatedRepoSpecs = moduleExtensionResult.generatedRepoSpecs();
-    Optional<ModuleExtensionMetadata> moduleExtensionMetadata =
+    ModuleExtensionMetadata moduleExtensionMetadata =
         moduleExtensionResult.moduleExtensionMetadata();
 
     if (!lockfileMode.equals(LockfileMode.OFF)) {
@@ -214,8 +218,7 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                         extensionId, nonVisibleRepoNames)));
       }
     }
-    if (lockfileMode.equals(LockfileMode.ERROR)
-        && !moduleExtensionMetadata.map(ModuleExtensionMetadata::getReproducible).orElse(false)) {
+    if (lockfileMode.equals(LockfileMode.ERROR) && !moduleExtensionMetadata.getReproducible()) {
       // The extension is not reproducible and can't be in the lockfile, since an existing (but
       // possibly out-of-date) entry would have been handled by tryGettingValueFromLockFile above.
       throw new SingleExtensionEvalFunctionException(
@@ -227,7 +230,19 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                   ? ""
                   : " for platform " + extension.getEvalFactors()));
     }
+    var newFacts = moduleExtensionMetadata.getFacts();
+    if (lockfileMode.equals(LockfileMode.ERROR) && !newFacts.equals(lockfileFacts)) {
+      String reason =
+          "The extension '%s' has changed its facts: %s != %s"
+              .formatted(
+                  extensionId,
+                  Starlark.repr(newFacts.value()),
+                  Starlark.repr(lockfileFacts.value()));
+      throw createOutdatedLockfileException(reason);
+    }
 
+    Optional<LockfileModuleExtensionMetadata> lockfileModuleExtensionMetadata =
+        LockfileModuleExtensionMetadata.of(moduleExtensionMetadata);
     Optional<LockFileModuleExtension.WithFactors> lockFileInfo;
     // At this point the extension has been evaluated successfully, but SingleExtensionEvalFunction
     // may still fail if imported repositories were not generated. However, since imports do not
@@ -257,7 +272,7 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                       .setRecordedDirentsInputs(moduleExtensionResult.recordedDirentsInputs())
                       .setEnvVariables(ImmutableSortedMap.copyOf(envVariables))
                       .setGeneratedRepoSpecs(generatedRepoSpecs)
-                      .setModuleExtensionMetadata(moduleExtensionMetadata)
+                      .setModuleExtensionMetadata(lockfileModuleExtensionMetadata)
                       .setRecordedRepoMappingEntries(
                           moduleExtensionResult.recordedRepoMappingEntries())
                       .build()));
@@ -265,7 +280,13 @@ public class SingleExtensionEvalFunction implements SkyFunction {
       lockFileInfo = Optional.empty();
     }
     return createSingleExtensionValue(
-        generatedRepoSpecs, moduleExtensionMetadata, extensionId, usagesValue, lockFileInfo, env);
+        generatedRepoSpecs,
+        lockfileModuleExtensionMetadata,
+        extensionId,
+        usagesValue,
+        lockFileInfo,
+        newFacts,
+        env);
   }
 
   /**
@@ -282,7 +303,8 @@ public class SingleExtensionEvalFunction implements SkyFunction {
       RunnableExtension extension,
       SingleExtensionUsagesValue usagesValue,
       ModuleExtensionEvalFactors evalFactors,
-      LockFileModuleExtension lockedExtension)
+      LockFileModuleExtension lockedExtension,
+      Facts facts)
       throws SingleExtensionEvalFunctionException,
           InterruptedException,
           NeedsSkyframeRestartException {
@@ -335,6 +357,7 @@ public class SingleExtensionEvalFunction implements SkyFunction {
     } catch (DiffFoundEarlyExitException ignored) {
       // ignored
     }
+    // There is intentionally no diff check for facts - they are never invalidated by Bazel.
     if (!diffRecorder.anyDiffsDetected()) {
       return createSingleExtensionValue(
           lockedExtension.getGeneratedRepoSpecs(),
@@ -342,17 +365,13 @@ public class SingleExtensionEvalFunction implements SkyFunction {
           extensionId,
           usagesValue,
           Optional.of(new LockFileModuleExtension.WithFactors(evalFactors, lockedExtension)),
+          facts,
           env);
     }
     // Reproducible extensions are always locked in the hidden lockfile to provide best-effort
     // speedups, but should never result in an error if out-of-date.
     if (lockfileMode.equals(LockfileMode.ERROR) && !lockedExtension.isReproducible()) {
-      throw new SingleExtensionEvalFunctionException(
-          ExternalDepsException.withMessage(
-              Code.BAD_LOCKFILE,
-              "MODULE.bazel.lock is no longer up-to-date because: %s. "
-                  + "Please run `bazel mod deps --lockfile_mode=update` to update your lockfile.",
-              diffRecorder.getRecordedDiffMessages()));
+      throw createOutdatedLockfileException(diffRecorder.getRecordedDiffMessages());
     }
     return null;
   }
@@ -432,20 +451,13 @@ public class SingleExtensionEvalFunction implements SkyFunction {
     return outdated.isPresent();
   }
 
-  /**
-   * Validates the result of the module extension evaluation against the declared imports, throwing
-   * an exception if validation fails, and returns a SingleExtensionValue otherwise.
-   *
-   * <p>Since extension evaluation does not depend on the declared imports, the result of the
-   * evaluation of the extension implementation function can be reused and persisted in the lockfile
-   * even if validation fails.
-   */
   private SingleExtensionValue createSingleExtensionValue(
       ImmutableMap<String, RepoSpec> generatedRepoSpecs,
-      Optional<ModuleExtensionMetadata> moduleExtensionMetadata,
+      Optional<LockfileModuleExtensionMetadata> moduleExtensionMetadata,
       ModuleExtensionId extensionId,
       SingleExtensionUsagesValue usagesValue,
       Optional<LockFileModuleExtension.WithFactors> lockFileInfo,
+      Facts facts,
       Environment env)
       throws SingleExtensionEvalFunctionException {
     Optional<RootModuleFileFixup> fixup = Optional.empty();
@@ -481,7 +493,18 @@ public class SingleExtensionEvalFunction implements SkyFunction {
                             usagesValue.getExtensionUniqueName() + "+" + e),
                     Function.identity())),
         lockFileInfo,
-        fixup);
+        fixup,
+        facts);
+  }
+
+  private static SingleExtensionEvalFunctionException createOutdatedLockfileException(
+      String reason) {
+    return new SingleExtensionEvalFunctionException(
+        ExternalDepsException.withMessage(
+            Code.BAD_LOCKFILE,
+            "MODULE.bazel.lock is no longer up-to-date because: %s. Please run `bazel mod deps"
+                + " --lockfile_mode=update` to update your lockfile.",
+            reason));
   }
 
   private static final class SingleExtensionEvalFunctionException extends SkyFunctionException {
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionValue.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionValue.java
index 872b3a42c8..0716cf249f 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionValue.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/SingleExtensionValue.java
@@ -42,19 +42,22 @@ import java.util.Optional;
  *     if and only if the lockfile mode is UPDATE.
  * @param fixup Returns the buildozer fixup for incorrect use_repo declarations by the root module
  *     (if any).
+ * @param facts Returns the facts about the extension, which can be used to generate the
  */
 @AutoCodec(explicitlyAllowClass = {Package.class})
 public record SingleExtensionValue(
     ImmutableMap<String, RepoSpec> generatedRepoSpecs,
     ImmutableBiMap<RepositoryName, String> canonicalRepoNameToInternalNames,
     Optional<LockFileModuleExtension.WithFactors> lockFileInfo,
-    Optional<RootModuleFileFixup> fixup)
+    Optional<RootModuleFileFixup> fixup,
+    Facts facts)
     implements SkyValue {
   public SingleExtensionValue {
     requireNonNull(generatedRepoSpecs, "generatedRepoSpecs");
     requireNonNull(canonicalRepoNameToInternalNames, "canonicalRepoNameToInternalNames");
     requireNonNull(lockFileInfo, "lockFileInfo");
     requireNonNull(fixup, "fixup");
+    requireNonNull(facts, "facts");
   }
 
   public static Key key(ModuleExtensionId id) {
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
index f2bfa7ad98..7ecbd82d06 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelLockFileModuleTest.java
@@ -20,6 +20,7 @@ import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.devtools.build.lib.cmdline.Label;
 import java.util.Optional;
+import net.starlark.java.eval.Dict;
 import net.starlark.java.eval.Starlark;
 import org.junit.Before;
 import org.junit.Test;
@@ -59,9 +60,12 @@ public class BazelLockFileModuleTest {
             .setEnvVariables(ImmutableSortedMap.of())
             .setGeneratedRepoSpecs(ImmutableMap.of())
             .setModuleExtensionMetadata(
-                Optional.of(
+                LockfileModuleExtensionMetadata.of(
                     ModuleExtensionMetadata.create(
-                        Starlark.NONE, Starlark.NONE, /* reproducible= */ true)))
+                        Starlark.NONE,
+                        Starlark.NONE,
+                        /* reproducible= */ true,
+                        /* factsObj= */ Dict.empty())))
             .build();
     evalFactors = ModuleExtensionEvalFactors.create("linux", "x86_64");
     otherEvalFactors = ModuleExtensionEvalFactors.create("linux", "aarch64");
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
index f4231b4928..86eb16aa5d 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleExtensionResolutionTest.java
@@ -14,12 +14,15 @@
 
 package com.google.devtools.build.lib.bazel.bzlmod;
 
+import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.devtools.build.lib.bazel.bzlmod.BzlmodTestUtil.createModuleKey;
 import static com.google.devtools.build.lib.testutil.MoreAsserts.assertEventCount;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.devtools.build.lib.analysis.util.BuildViewTestCase;
 import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.cmdline.PackageIdentifier;
@@ -36,8 +39,14 @@ import com.google.devtools.build.skyframe.CyclesReporter;
 import com.google.devtools.build.skyframe.EvaluationResult;
 import com.google.devtools.build.skyframe.SkyKey;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import net.starlark.java.eval.Dict;
+import net.starlark.java.eval.Starlark;
+import net.starlark.java.eval.StarlarkFloat;
+import net.starlark.java.eval.StarlarkInt;
+import net.starlark.java.eval.StarlarkList;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -2528,6 +2537,124 @@ public class ModuleExtensionResolutionTest extends BuildViewTestCase {
         .isEqualTo("Updated use_repo calls for isolated usage 'ext2' of @ext//:defs.bzl%ext");
   }
 
+  @Test
+  public void facts_supportedTypes() throws Exception {
+    var result =
+        evaluateSimpleModuleExtension(
+            """
+            return ctx.extension_metadata(
+                facts = {
+                    "one": "string",
+                    "two": 42,
+                    "three": 3.14,
+                    "four": True,
+                    "five": None,
+                    "six": [1, 2, 3],
+                    "seven": {
+                        "c": "v1",
+                        "b": "v2",
+                        "a": "v3",
+                    },
+                    "eight": (4, 5, "foo"),
+                }
+            )\
+            """);
+
+    if (result.hasError()) {
+      throw result.getError().getException();
+    }
+    var facts = Iterables.getOnlyElement(result.values()).facts().value();
+    assertThat((Map<?, ?>) facts)
+        .isEqualTo(
+            Dict.immutableCopyOf(
+                ImmutableMap.of(
+                    "one",
+                    "string",
+                    "two",
+                    StarlarkInt.of(42),
+                    "three",
+                    StarlarkFloat.of(3.14),
+                    "four",
+                    true,
+                    "five",
+                    Starlark.NONE,
+                    "six",
+                    StarlarkList.immutableOf(
+                        StarlarkInt.of(1), StarlarkInt.of(2), StarlarkInt.of(3)),
+                    "seven",
+                    Dict.immutableCopyOf(ImmutableMap.of("a", "v3", "b", "v2", "c", "v1")),
+                    "eight",
+                    StarlarkList.immutableOf(StarlarkInt.of(4), StarlarkInt.of(5), "foo"))));
+    // Validate that keys in a Dict are sorted.
+    assertThat(
+            ((Map<?, ?>) ((Map<?, ?>) facts).get("seven"))
+                .keySet().stream().collect(toImmutableList()))
+        .containsExactly("a", "b", "c")
+        .inOrder();
+  }
+
+  @Test
+  public void facts_unsupportedType() throws Exception {
+    var result =
+        evaluateSimpleModuleExtension(
+            """
+            return ctx.extension_metadata(
+                facts = {
+                    "unsupported": set([1, 2, 3]),
+                }
+            )\
+            """);
+
+    assertThat(result.hasError()).isTrue();
+    assertContainsEvent("'set([1, 2, 3])' (set) is not supported in facts");
+  }
+
+  @Test
+  public void facts_nonStringKeys() throws Exception {
+    var result =
+        evaluateSimpleModuleExtension(
+            """
+            return ctx.extension_metadata(
+                facts = {
+                    "top_level": {
+                        1: "one",
+                    },
+                }
+            )\
+            """);
+
+    assertThat(result.hasError()).isTrue();
+    assertContainsEvent("Facts keys must be strings, got '1: \"one\"' (int)");
+  }
+
+  @Test
+  public void facts_nestedTooDeeply() throws Exception {
+    var result =
+        evaluateSimpleModuleExtension(
+            """
+            return ctx.extension_metadata(
+                facts = {
+                    "nested": {
+                        "too": {
+                            "deep": {
+                                "to": {
+                                    "be": {
+                                        "considered": {
+                                            "valid": [1, 2, 3]
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            )\
+            """);
+
+    assertThat(result.hasError()).isTrue();
+    assertContainsEvent("Facts cannot be nested more than 7 levels deep");
+  }
+
   private EvaluationResult<SingleExtensionValue> evaluateSimpleModuleExtension(
       String returnStatement) throws Exception {
     return evaluateSimpleModuleExtension(returnStatement, /* devDependency= */ false);
@@ -2546,7 +2673,7 @@ public class ModuleExtensionResolutionTest extends BuildViewTestCase {
         "def _ext_impl(ctx):",
         "  repo(name = 'dep1')",
         "  repo(name = 'dep2')",
-        "  " + returnStatement,
+        returnStatement.indent(2),
         "ext = module_extension(implementation=_ext_impl)");
     scratch.overwriteFile("BUILD");
     invalidatePackages(false);
diff --git a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
index 286a539f75..8b6928f253 100644
--- a/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
+++ b/src/test/py/bazel/bzlmod/bazel_lockfile_test.py
@@ -753,6 +753,9 @@ class BazelLockfileTest(test_base.TestBase):
             'repo_rule = repository_rule(implementation=impl)',
             'def _ext_impl(ctx):',
             '    repo_rule(name="hello")',
+            '    return ctx.extension_metadata(',
+            '        facts = {"Hi": "there!"},',
+            '    )',
             'ext = module_extension(implementation=_ext_impl)',
         ],
     )
@@ -762,6 +765,8 @@ class BazelLockfileTest(test_base.TestBase):
       lockfile = json.loads(f.read().strip())
       ext_keys = list(lockfile['moduleExtensions'].keys())
       self.assertIn('//:extension.bzl%ext', ext_keys)
+      facts_keys = list(lockfile['facts'].keys())
+      self.assertIn('//:extension.bzl%ext', facts_keys)
 
     self.ScratchFile('MODULE.bazel', [])
     self.RunBazel(['build', '//:all'])
@@ -769,6 +774,8 @@ class BazelLockfileTest(test_base.TestBase):
       lockfile = json.loads(f.read().strip())
       ext_keys = list(lockfile['moduleExtensions'].keys())
       self.assertNotIn('//:extension.bzl%ext', ext_keys)
+      facts_keys = list(lockfile['facts'].keys())
+      self.assertNotIn('//:extension.bzl%ext', facts_keys)
 
   def testNoAbsoluteRootModuleFilePath(self):
     self.ScratchFile(
@@ -2814,6 +2821,247 @@ class BazelLockfileTest(test_base.TestBase):
     self.assertNotIn('Hello from the other side!', ''.join(stderr))
     self.assertIn('Unicode test: ', ''.join(stderr))
 
+  def testFactsInReproducibleExtension(self):
+    self.ScratchFile(
+        'MODULE.bazel',
+        [
+            'lockfile_ext = use_extension("extension.bzl", "lockfile_ext")',
+            'use_repo(lockfile_ext, "hello")',
+        ],
+    )
+    self.ScratchFile('BUILD.bazel')
+    self.ScratchFile(
+        'extension.bzl',
+        [
+            'def impl(ctx):',
+            '    ctx.file("BUILD", "filegroup(name=\\"lala\\")")',
+            'repo_rule = repository_rule(',
+            '    implementation = impl,',
+            '    attrs = {"hash": attr.string()},',
+            ')',
+            'def _fetch_metadata(ctx, resource_name):',
+            (
+                '    # Fake function to simulate fetching metadata from the'
+                ' internet.'
+            ),
+            (
+                '    # Also verify that the methods on the facts object behave'
+                ' consistently.'
+            ),
+            (
+                '    if (ctx.facts.get(resource_name) != None) !='
+                ' (resource_name in ctx.facts):'
+            ),
+            (
+                '        fail("ctx.facts.get() and ctx.facts disagree on'
+                ' whether the key exists")'
+            ),
+            (
+                '    if ctx.facts.get(resource_name) != None and'
+                ' ctx.facts.get(resource_name) != ctx.facts[resource_name]:'
+            ),
+            (
+                '        fail("ctx.facts.get() and ctx.facts disagree on the'
+                ' value of the key")'
+            ),
+            '    if resource_name in ctx.facts:',
+            '        return ctx.facts[resource_name]',
+            '    print("Fetching metadata for {}...".format(resource_name))',
+            '    return {"hash": resource_name[::-1]}',
+            'def _mod_ext_impl(ctx):',
+            '    print("Hello from the other side!")',
+            '    metadata = {}',
+            '    for repo in ["hello", "world"]:',
+            '        metadata[repo] = _fetch_metadata(ctx, repo)',
+            '        print("{}: hash={}".format(repo, metadata[repo]["hash"]))',
+            '        repo_rule(',
+            '            name = repo,',
+            '            hash = metadata[repo]["hash"],',
+            '        )',
+            '    return ctx.extension_metadata(',
+            '        reproducible = True,',
+            '        facts = metadata,',
+            '    )',
+            'lockfile_ext = module_extension(implementation = _mod_ext_impl)',
+        ],
+    )
+    _, _, stderr = self.RunBazel(['build', '@hello//:all'])
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from the other side!', stderr)
+    self.assertIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olleh', stderr)
+    self.assertIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=dlrow', stderr)
+
+    # Clean out the hidden lockfile to ensure that the extension is
+    # evaluated again and verify that the reevaluation reuses the facts.
+    _, _, stderr = self.RunBazel(['clean', '--expunge'])
+
+    _, _, stderr = self.RunBazel(
+        ['build', '@hello//:all', '--lockfile_mode=error']
+    )
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from the other side!', stderr)
+    self.assertNotIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olleh', stderr)
+    self.assertNotIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=dlrow', stderr)
+
+    # Update extension in a way that does *not* change the facts.
+    with open(self.Path('extension.bzl'), 'r') as f:
+      lines = [
+          l.replace('Hello from the other side!', 'Hello from this side!')
+          for l in f.readlines()
+      ]
+    self.ScratchFile('extension.bzl', lines)
+
+    _, _, stderr = self.RunBazel(
+        ['build', '@hello//:all', '--lockfile_mode=error']
+    )
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from this side!', stderr)
+    self.assertNotIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olleh', stderr)
+    self.assertNotIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=dlrow', stderr)
+
+    # Update extension in a way that *does* change the facts.
+    with open(self.Path('extension.bzl'), 'r') as f:
+      lines = [
+          (
+              l.replace('resource_name[::-1]', 'resource_name[::-2]').replace(
+                  'if resource_name in ctx.facts:', 'if False:'
+              )
+          )
+          for l in f.readlines()
+      ]
+    self.ScratchFile('extension.bzl', lines)
+
+    exit_code, stdout, stderr = self.RunBazel(
+        ['build', '@hello//:all', '--lockfile_mode=error'], allow_failure=True
+    )
+    self.AssertExitCode(exit_code, 48, stderr, stdout)
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from this side!', stderr)
+    self.assertIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olh', stderr)
+    self.assertIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=drw', stderr)
+    self.assertIn(
+        'ERROR: MODULE.bazel.lock is no longer up-to-date because: The'
+        " extension '@@//:extension.bzl%lockfile_ext' has changed its facts:"
+        ' {"hello": {"hash": "olh"}, "world": {"hash": "drw"}} != {"hello":'
+        ' {"hash": "olleh"}, "world": {"hash": "dlrow"}}',
+        stderr,
+    )
+
+  def testFactsInNonReproducibleExtension(self):
+    self.ScratchFile(
+        'MODULE.bazel',
+        [
+            'lockfile_ext = use_extension("extension.bzl", "lockfile_ext")',
+            'use_repo(lockfile_ext, "hello")',
+        ],
+    )
+    self.ScratchFile('BUILD.bazel')
+    self.ScratchFile(
+        'extension.bzl',
+        [
+            'def impl(ctx):',
+            '    ctx.file("BUILD", "filegroup(name=\\"lala\\")")',
+            'repo_rule = repository_rule(',
+            '    implementation = impl,',
+            '    attrs = {"hash": attr.string()},',
+            ')',
+            'def _fetch_metadata(ctx, resource_name):',
+            (
+                '    # Fake function to simulate fetching metadata from the'
+                ' internet.'
+            ),
+            (
+                '    # Also verify that the methods on the facts object behave'
+                ' consistently.'
+            ),
+            (
+                '    if (ctx.facts.get(resource_name) != None) !='
+                ' (resource_name in ctx.facts):'
+            ),
+            (
+                '        fail("ctx.facts.get() and ctx.facts disagree on'
+                ' whether the key exists")'
+            ),
+            (
+                '    if ctx.facts.get(resource_name) != None and'
+                ' ctx.facts.get(resource_name) != ctx.facts[resource_name]:'
+            ),
+            (
+                '        fail("ctx.facts.get() and ctx.facts disagree on the'
+                ' value of the key")'
+            ),
+            '    if resource_name in ctx.facts:',
+            '        return ctx.facts[resource_name]',
+            '    print("Fetching metadata for {}...".format(resource_name))',
+            '    return {"hash": resource_name[::-1]}',
+            'def _mod_ext_impl(ctx):',
+            '    print("Hello from the other side!")',
+            '    metadata = {}',
+            '    for repo in ["hello", "world"]:',
+            '        metadata[repo] = _fetch_metadata(ctx, repo)',
+            '        print("{}: hash={}".format(repo, metadata[repo]["hash"]))',
+            '        repo_rule(',
+            '            name = repo,',
+            '            hash = metadata[repo]["hash"],',
+            '        )',
+            '    return ctx.extension_metadata(',
+            '        reproducible = False,',
+            '        facts = metadata,',
+            '    )',
+            'lockfile_ext = module_extension(implementation = _mod_ext_impl)',
+        ],
+    )
+    _, _, stderr = self.RunBazel(['build', '@hello//:all'])
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from the other side!', stderr)
+    self.assertIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olleh', stderr)
+    self.assertIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=dlrow', stderr)
+
+    # Update extension in a way that does *not* change the facts and simulate
+    # non-reproducibility by changing the fake remote information.
+    with open(self.Path('extension.bzl'), 'r') as f:
+      lines = [
+          l.replace(
+              'Hello from the other side!', 'Hello from this side!'
+          ).replace('resource_name[::-1]', 'resource_name[::-2]')
+          for l in f.readlines()
+      ]
+    self.ScratchFile('extension.bzl', lines)
+
+    _, _, stderr = self.RunBazel(['build', '@hello//:all'])
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from this side!', stderr)
+    self.assertNotIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olleh', stderr)
+    self.assertNotIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=dlrow', stderr)
+
+    # Update extension in a way that *does* change the facts.
+    with open(self.Path('extension.bzl'), 'r') as f:
+      lines = [
+          (l.replace('if resource_name in ctx.facts:', 'if False:'))
+          for l in f.readlines()
+      ]
+    self.ScratchFile('extension.bzl', lines)
+
+    _, _, stderr = self.RunBazel(['build', '@hello//:all'])
+    stderr = ''.join(stderr)
+    self.assertIn('Hello from this side!', stderr)
+    self.assertIn('Fetching metadata for hello...', stderr)
+    self.assertIn('hello: hash=olh', stderr)
+    self.assertIn('Fetching metadata for world...', stderr)
+    self.assertIn('world: hash=drw', stderr)
+
 
 if __name__ == '__main__':
   absltest.main()
diff --git a/src/test/tools/bzlmod/MODULE.bazel.lock b/src/test/tools/bzlmod/MODULE.bazel.lock
index 897491f757..680f705c8f 100644
--- a/src/test/tools/bzlmod/MODULE.bazel.lock
+++ b/src/test/tools/bzlmod/MODULE.bazel.lock
@@ -309,5 +309,6 @@
         ]
       }
     }
-  }
+  },
+  "facts": {}
 }
