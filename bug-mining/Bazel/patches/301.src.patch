diff --git a/src/java_tools/buildjar/java/com/google/devtools/build/buildjar/instrumentation/JacocoInstrumentationProcessor.java b/src/java_tools/buildjar/java/com/google/devtools/build/buildjar/instrumentation/JacocoInstrumentationProcessor.java
index fd3b9b17d3..766c8dca8c 100644
--- a/src/java_tools/buildjar/java/com/google/devtools/build/buildjar/instrumentation/JacocoInstrumentationProcessor.java
+++ b/src/java_tools/buildjar/java/com/google/devtools/build/buildjar/instrumentation/JacocoInstrumentationProcessor.java
@@ -14,6 +14,8 @@
 
 package com.google.devtools.build.buildjar.instrumentation;
 
+import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
+
 import com.google.common.io.MoreFiles;
 import com.google.common.io.RecursiveDeleteOption;
 import com.google.devtools.build.buildjar.InvalidCommandLineException;
@@ -103,18 +105,22 @@ public final class JacocoInstrumentationProcessor {
             // It's not clear whether there is any advantage in not instrumenting *Test classes,
             // apart from lowering the covered percentage in the aggregate statistics.
 
-            // We first move the original .class file to our metadata directory, then instrument it
-            // and output the instrumented version in the regular classes output directory.
+            // We first copy the original .class file to our metadata directory, then instrument it
+            // and rewrite the instrumented version back into the regular classes output directory.
+
+            // Not moving or unlinking the source .class file is essential to guarantee visiting
+            // it only once during recursive directory traversal while also mutating the directory.
             Path instrumentedCopy = file;
             Path absoluteUninstrumentedCopy = Path.of(file + ".uninstrumented");
             Path uninstrumentedCopy =
                 instrumentedClassesDirectory.resolve(root.relativize(absoluteUninstrumentedCopy));
             Files.createDirectories(uninstrumentedCopy.getParent());
-            Files.move(file, uninstrumentedCopy);
+            Files.copy(file, uninstrumentedCopy);
             try (InputStream input =
                     new BufferedInputStream(Files.newInputStream(uninstrumentedCopy));
                 OutputStream output =
-                    new BufferedOutputStream(Files.newOutputStream(instrumentedCopy))) {
+                    new BufferedOutputStream(
+                        Files.newOutputStream(instrumentedCopy, TRUNCATE_EXISTING))) {
               instr.instrument(input, output, file.toString());
             }
             return FileVisitResult.CONTINUE;
