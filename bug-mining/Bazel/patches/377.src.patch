diff --git a/src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkAction.java b/src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkAction.java
index 4a116cd3e4..3bb3a96507 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkAction.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkAction.java
@@ -14,6 +14,7 @@
 
 package com.google.devtools.build.lib.analysis.actions;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.devtools.build.lib.unix.UnixFileStatus.S_IXUSR;
 
 import com.google.common.base.Preconditions;
@@ -29,6 +30,7 @@ import com.google.devtools.build.lib.actions.ActionResult;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.Artifact.SourceArtifact;
 import com.google.devtools.build.lib.actions.FileArtifactValue;
+import com.google.devtools.build.lib.actions.FileStateType;
 import com.google.devtools.build.lib.actions.FilesetOutputTree;
 import com.google.devtools.build.lib.actions.InputMetadataProvider;
 import com.google.devtools.build.lib.actions.RichArtifactData;
@@ -45,6 +47,7 @@ import com.google.devtools.build.lib.util.Fingerprint;
 import com.google.devtools.build.lib.vfs.FileStatus;
 import com.google.devtools.build.lib.vfs.Path;
 import com.google.devtools.build.lib.vfs.PathFragment;
+import com.google.devtools.build.lib.vfs.SymlinkTargetType;
 import com.google.devtools.build.lib.vfs.Symlinks;
 import com.google.devtools.build.lib.vfs.SyscallCache;
 import java.io.IOException;
@@ -59,6 +62,7 @@ public final class SymlinkAction extends AbstractAction implements RichDataProdu
 
   /** Null when {@link #getPrimaryInput} is the target of the symlink. */
   @Nullable private final PathFragment inputPath;
+
   @Nullable private final String progressMessage;
 
   enum TargetType {
@@ -88,7 +92,7 @@ public final class SymlinkAction extends AbstractAction implements RichDataProdu
 
   public static SymlinkAction toArtifact(
       ActionOwner owner, Artifact input, Artifact output, String progressMessage) {
-    return toArtifact(owner, input, output, progressMessage, /*useExecRootForSource=*/ false);
+    return toArtifact(owner, input, output, progressMessage, /* useExecRootForSource= */ false);
   }
 
   /**
@@ -231,7 +235,7 @@ public final class SymlinkAction extends AbstractAction implements RichDataProdu
       // small amount of overhead.
       outputPath.delete();
 
-      outputPath.createSymbolicLink(targetPath);
+      outputPath.createSymbolicLink(targetPath, getSymlinkTargetType(actionExecutionContext));
     } catch (IOException e) {
       String message =
           String.format(
@@ -272,6 +276,22 @@ public final class SymlinkAction extends AbstractAction implements RichDataProdu
     return ActionResult.EMPTY;
   }
 
+  private SymlinkTargetType getSymlinkTargetType(ActionExecutionContext actionExecutionContext)
+      throws IOException {
+    Artifact primaryInput = getPrimaryInput();
+    if (primaryInput == null) {
+      return SymlinkTargetType.UNSPECIFIED;
+    }
+    FileArtifactValue metadata =
+        checkNotNull(
+            actionExecutionContext.getInputMetadataProvider().getInputMetadata(primaryInput),
+            "missing metadata for %s",
+            primaryInput);
+    return metadata.getType() == FileStateType.DIRECTORY
+        ? SymlinkTargetType.DIRECTORY
+        : SymlinkTargetType.FILE;
+  }
+
   private void maybeVerifyTargetIsExecutable(ActionExecutionContext actionExecutionContext)
       throws ActionExecutionException {
     if (targetType != TargetType.EXECUTABLE) {
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/actions/BUILD b/src/test/java/com/google/devtools/build/lib/analysis/actions/BUILD
index 46d3a84855..8c3a582ce3 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/actions/BUILD
+++ b/src/test/java/com/google/devtools/build/lib/analysis/actions/BUILD
@@ -202,12 +202,16 @@ java_test(
     deps = [
         "//src/main/java/com/google/devtools/build/lib/actions",
         "//src/main/java/com/google/devtools/build/lib/actions:artifacts",
+        "//src/main/java/com/google/devtools/build/lib/actions:file_metadata",
         "//src/main/java/com/google/devtools/build/lib/actions:thread_state_receiver",
         "//src/main/java/com/google/devtools/build/lib/analysis:actions/symlink_action",
         "//src/main/java/com/google/devtools/build/lib/events",
+        "//src/main/java/com/google/devtools/build/lib/skyframe:tree_artifact_value",
         "//src/main/java/com/google/devtools/build/lib/skyframe/serialization/testutils",
         "//src/main/java/com/google/devtools/build/lib/skyframe/serialization/testutils:depsutils",
+        "//src/main/java/com/google/devtools/build/lib/testing/vfs:spied_filesystem",
         "//src/main/java/com/google/devtools/build/lib/vfs",
+        "//src/main/java/com/google/devtools/build/lib/vfs:pathfragment",
         "//src/test/java/com/google/devtools/build/lib/actions/util",
         "//src/test/java/com/google/devtools/build/lib/analysis/util",
         "//src/test/java/com/google/devtools/build/lib/exec/util",
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/actions/SymlinkActionTest.java b/src/test/java/com/google/devtools/build/lib/analysis/actions/SymlinkActionTest.java
index b16519cb5e..89e345f496 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/actions/SymlinkActionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/actions/SymlinkActionTest.java
@@ -15,16 +15,20 @@ package com.google.devtools.build.lib.analysis.actions;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.devtools.build.lib.actions.util.ActionsTestUtil.NULL_ACTION_OWNER;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.devtools.build.lib.actions.ActionExecutionContext;
 import com.google.devtools.build.lib.actions.ActionExecutionContext.LostInputsCheck;
+import com.google.devtools.build.lib.actions.ActionInputMap;
 import com.google.devtools.build.lib.actions.ActionInputPrefetcher;
 import com.google.devtools.build.lib.actions.ActionResult;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.DiscoveredModulesPruner;
 import com.google.devtools.build.lib.actions.Executor;
+import com.google.devtools.build.lib.actions.FileArtifactValue;
 import com.google.devtools.build.lib.actions.InputMetadataProvider;
 import com.google.devtools.build.lib.actions.ThreadStateReceiver;
 import com.google.devtools.build.lib.actions.cache.OutputMetadataStore;
@@ -32,15 +36,21 @@ import com.google.devtools.build.lib.actions.util.ActionsTestUtil;
 import com.google.devtools.build.lib.analysis.util.BuildViewTestCase;
 import com.google.devtools.build.lib.events.StoredEventHandler;
 import com.google.devtools.build.lib.exec.util.TestExecutorBuilder;
+import com.google.devtools.build.lib.skyframe.TreeArtifactValue;
 import com.google.devtools.build.lib.skyframe.serialization.testutils.SerializationDepsUtils;
 import com.google.devtools.build.lib.skyframe.serialization.testutils.SerializationTester;
+import com.google.devtools.build.lib.testing.vfs.SpiedFileSystem;
 import com.google.devtools.build.lib.testutil.TestConstants;
 import com.google.devtools.build.lib.vfs.FileSystem;
+import com.google.devtools.build.lib.vfs.FileSystemUtils;
 import com.google.devtools.build.lib.vfs.Path;
+import com.google.devtools.build.lib.vfs.PathFragment;
 import com.google.devtools.build.lib.vfs.Root;
+import com.google.devtools.build.lib.vfs.SymlinkTargetType;
 import com.google.devtools.build.lib.vfs.SyscallCache;
 import com.google.testing.junit.testparameterinjector.TestParameter;
 import com.google.testing.junit.testparameterinjector.TestParameterInjector;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,55 +59,224 @@ import org.junit.runner.RunWith;
 @RunWith(TestParameterInjector.class)
 public class SymlinkActionTest extends BuildViewTestCase {
 
-  @TestParameter private boolean useExecRootForSources;
-
-  private Path input;
-  private Artifact inputArtifact;
-  private Path output;
-  private Artifact.DerivedArtifact outputArtifact;
-  private SymlinkAction action;
+  private Executor executor;
+  private SpiedFileSystem fs;
 
   @Before
-  public final void setUp() throws Exception {
-    input = scratch.file("input.txt", "Hello, world.");
-    inputArtifact = getSourceArtifact("input.txt");
-    Path linkedInput =
-        directories.getExecRoot(TestConstants.WORKSPACE_NAME).getRelative("input.txt");
-    linkedInput.getParentDirectory().createDirectoryAndParents();
-    linkedInput.createSymbolicLink(input);
-    outputArtifact = getBinArtifactWithNoOwner("destination.txt");
+  public void setUp() throws Exception {
+    executor = new TestExecutorBuilder(fileSystem, directories).build();
+  }
+
+  @Override
+  public FileSystem createFileSystem() {
+    fs = SpiedFileSystem.createInMemorySpy();
+    return fs;
+  }
+
+  @Test
+  public void testSymlinkToSourceFile(@TestParameter boolean useExecRootForSource)
+      throws Exception {
+    Artifact inputArtifact = getSourceArtifact("input");
+    Artifact outputArtifact = getBinArtifactWithNoOwner("output");
+
+    Path inputPath = directories.getExecRoot(TestConstants.WORKSPACE_NAME).getRelative("input");
+    inputPath.getParentDirectory().createDirectoryAndParents();
+    FileSystemUtils.createEmptyFile(inputPath);
+    inputArtifact.getPath().createSymbolicLink(inputPath);
+    outputArtifact.getPath().getParentDirectory().createDirectoryAndParents();
+
+    runSymlinkAction(inputArtifact, outputArtifact, useExecRootForSource);
+
+    PathFragment expectedTarget =
+        useExecRootForSource
+            ? getExecRoot().getRelative(inputArtifact.getExecPath()).asFragment()
+            : inputArtifact.getPath().asFragment();
+
+    assertThat(outputArtifact.getPath().isSymbolicLink()).isTrue();
+    assertThat(outputArtifact.getPath().readSymbolicLink()).isEqualTo(expectedTarget);
+
+    verify(fs)
+        .createSymbolicLink(
+            outputArtifact.getPath().asFragment(), expectedTarget, SymlinkTargetType.FILE);
+  }
+
+  @Test
+  public void testSymlinkToSourceDirectory(@TestParameter boolean useExecRootForSource)
+      throws Exception {
+    Artifact inputArtifact = getSourceArtifact("input");
+    Artifact outputArtifact = getBinArtifactWithNoOwner("output");
+
+    Path inputPath = directories.getExecRoot(TestConstants.WORKSPACE_NAME).getRelative("input");
+    inputPath.createDirectoryAndParents();
+    inputArtifact.getPath().createSymbolicLink(inputPath);
+    outputArtifact.getPath().getParentDirectory().createDirectoryAndParents();
+
+    runSymlinkAction(inputArtifact, outputArtifact, useExecRootForSource);
+
+    PathFragment expectedTarget =
+        useExecRootForSource
+            ? getExecRoot().getRelative(inputArtifact.getExecPath()).asFragment()
+            : inputArtifact.getPath().asFragment();
+
+    assertThat(outputArtifact.getPath().isSymbolicLink()).isTrue();
+    assertThat(outputArtifact.getPath().readSymbolicLink()).isEqualTo(expectedTarget);
+
+    verify(fs)
+        .createSymbolicLink(
+            outputArtifact.getPath().asFragment(), expectedTarget, SymlinkTargetType.DIRECTORY);
+  }
+
+  @Test
+  public void testSymlinkToOutputFile() throws Exception {
+    Artifact inputArtifact = getBinArtifactWithNoOwner("input");
+    Artifact outputArtifact = getBinArtifactWithNoOwner("output");
+
+    inputArtifact.getPath().getParentDirectory().createDirectoryAndParents();
+    FileSystemUtils.writeContent(inputArtifact.getPath(), UTF_8, "hello world");
+    outputArtifact.getPath().getParentDirectory().createDirectoryAndParents();
+
+    runSymlinkAction(inputArtifact, outputArtifact);
+
+    assertThat(outputArtifact.getPath().isSymbolicLink()).isTrue();
+    assertThat(outputArtifact.getPath().readSymbolicLink())
+        .isEqualTo(inputArtifact.getPath().asFragment());
+
+    verify(fs)
+        .createSymbolicLink(
+            outputArtifact.getPath().asFragment(),
+            inputArtifact.getPath().asFragment(),
+            SymlinkTargetType.FILE);
+  }
+
+  @Test
+  public void testSymlinkToOutputTree() throws Exception {
+    Artifact inputArtifact =
+        ActionsTestUtil.createTreeArtifactWithGeneratingAction(
+            getTargetConfiguration().getBinDir(), "input");
+    Artifact outputArtifact =
+        ActionsTestUtil.createTreeArtifactWithGeneratingAction(
+            getTargetConfiguration().getBinDir(), "output");
+
+    inputArtifact.getPath().createDirectoryAndParents();
+    outputArtifact.getPath().createDirectoryAndParents();
+
+    runSymlinkAction(inputArtifact, outputArtifact);
+
+    assertThat(outputArtifact.getPath().isSymbolicLink()).isTrue();
+    assertThat(outputArtifact.getPath().readSymbolicLink())
+        .isEqualTo(inputArtifact.getPath().asFragment());
+
+    verify(fs)
+        .createSymbolicLink(
+            outputArtifact.getPath().asFragment(),
+            inputArtifact.getPath().asFragment(),
+            SymlinkTargetType.DIRECTORY);
+  }
+
+  @Test
+  public void testSymlinkToAbsolutePath() throws Exception {
+    Artifact outputArtifact = getBinArtifactWithNoOwner("output");
+
+    outputArtifact.getPath().getParentDirectory().createDirectoryAndParents();
+
+    runSymlinkAction(PathFragment.create("/some/path"), outputArtifact);
+
+    assertThat(outputArtifact.getPath().isSymbolicLink()).isTrue();
+    assertThat(outputArtifact.getPath().readSymbolicLink())
+        .isEqualTo(PathFragment.create("/some/path"));
+
+    verify(fs)
+        .createSymbolicLink(
+            outputArtifact.getPath().asFragment(),
+            PathFragment.create("/some/path"),
+            SymlinkTargetType.UNSPECIFIED);
+  }
+
+  @Test
+  public void testCodec(@TestParameter boolean useExecRootForSource) throws Exception {
+    Artifact inputArtifact = getSourceArtifact("input");
+    Artifact.DerivedArtifact outputArtifact = getBinArtifactWithNoOwner("output");
     outputArtifact.setGeneratingActionKey(ActionsTestUtil.NULL_ACTION_LOOKUP_DATA);
-    output = outputArtifact.getPath();
-    output.getParentDirectory().createDirectoryAndParents();
-    action =
+
+    SymlinkAction action =
+        SymlinkAction.toArtifact(
+            NULL_ACTION_OWNER,
+            inputArtifact,
+            outputArtifact,
+            "Test symlink action",
+            useExecRootForSource);
+
+    new SerializationTester(action)
+        .addDependency(FileSystem.class, scratch.getFileSystem())
+        .addDependency(Root.RootCodecDependencies.class, new Root.RootCodecDependencies(root))
+        .addDependencies(SerializationDepsUtils.SERIALIZATION_DEPS_FOR_TEST)
+        .setVerificationFunction(
+            (in, out) -> {
+              SymlinkAction inAction = (SymlinkAction) in;
+              SymlinkAction outAction = (SymlinkAction) out;
+              assertThat(inAction.getPrimaryInput().getFilename())
+                  .isEqualTo(outAction.getPrimaryInput().getFilename());
+              assertThat(inAction.getPrimaryOutput().getFilename())
+                  .isEqualTo(outAction.getPrimaryOutput().getFilename());
+              assertThat(inAction.getOwner()).isEqualTo(outAction.getOwner());
+              assertThat(inAction.getProgressMessage()).isEqualTo(outAction.getProgressMessage());
+            })
+        .runTests();
+  }
+
+  private void runSymlinkAction(
+      Artifact inputArtifact, Artifact outputArtifact, boolean useExecRootForSource)
+      throws Exception {
+    var action =
         SymlinkAction.toArtifact(
             NULL_ACTION_OWNER,
             inputArtifact,
             outputArtifact,
-            "Symlinking test: %{label}: %{input} -> %{output}",
-            useExecRootForSources);
+            "Test symlink action",
+            useExecRootForSource);
+
+    assertThat(action.getInputs().toList()).containsExactly(inputArtifact);
+    assertThat(action.getOutputs()).containsExactly(outputArtifact);
+    assertThat(action.getProgressMessage()).isEqualTo("Test symlink action");
+
+    execute(action);
   }
 
-  @Test
-  public void testInputArtifactIsInput() {
-    Iterable<Artifact> inputs = action.getInputs().toList();
-    assertThat(inputs).containsExactly(inputArtifact);
+  private void runSymlinkAction(Artifact inputArtifact, Artifact outputArtifact) throws Exception {
+    var action =
+        SymlinkAction.toArtifact(
+            NULL_ACTION_OWNER,
+            inputArtifact,
+            outputArtifact,
+            "Test symlink action",
+            /* useExecRootForSource= */ false);
+
+    assertThat(action.getInputs().toList()).containsExactly(inputArtifact);
+    assertThat(action.getOutputs()).containsExactly(outputArtifact);
+    assertThat(action.getProgressMessage()).isEqualTo("Test symlink action");
+
+    execute(action);
   }
 
-  @Test
-  public void testDestinationArtifactIsOutput() {
-    Iterable<Artifact> outputs = action.getOutputs();
-    assertThat(outputs).containsExactly(outputArtifact);
+  private void runSymlinkAction(PathFragment absolutePath, Artifact outputArtifact)
+      throws Exception {
+    var action =
+        SymlinkAction.toAbsolutePath(
+            NULL_ACTION_OWNER, absolutePath, outputArtifact, "Test symlink action");
+
+    assertThat(action.getInputs().toList()).isEmpty();
+    assertThat(action.getOutputs()).containsExactly(outputArtifact);
+    assertThat(action.getProgressMessage()).isEqualTo("Test symlink action");
+
+    execute(action);
   }
 
-  @Test
-  public void testSymlink() throws Exception {
-    Executor executor = new TestExecutorBuilder(fileSystem, directories).build();
+  private void execute(SymlinkAction action) throws Exception {
     ActionResult actionResult =
         action.execute(
             new ActionExecutionContext(
                 executor,
-                mock(InputMetadataProvider.class),
+                createInputMetadataProvider(action.getInputs().toList()),
                 ActionInputPrefetcher.NONE,
                 actionKeyContext,
                 mock(OutputMetadataStore.class),
@@ -110,32 +289,20 @@ public class SymlinkActionTest extends BuildViewTestCase {
                 DiscoveredModulesPruner.DEFAULT,
                 SyscallCache.NO_CACHE,
                 ThreadStateReceiver.NULL_INSTANCE));
+
     assertThat(actionResult.spawnResults()).isEmpty();
-    assertThat(output.isSymbolicLink()).isTrue();
-    assertThat(output.resolveSymbolicLinks()).isEqualTo(input);
-    assertThat(action.getPrimaryInput()).isEqualTo(inputArtifact);
-    assertThat(action.getPrimaryOutput()).isEqualTo(outputArtifact);
-    assertThat(action.getProgressMessage())
-        .isEqualTo("Symlinking test: //null/action:owner: input.txt -> destination.txt");
   }
 
-  @Test
-  public void testCodec() throws Exception {
-    new SerializationTester(action)
-        .addDependency(FileSystem.class, scratch.getFileSystem())
-        .addDependency(Root.RootCodecDependencies.class, new Root.RootCodecDependencies(root))
-        .addDependencies(SerializationDepsUtils.SERIALIZATION_DEPS_FOR_TEST)
-        .setVerificationFunction(
-            (in, out) -> {
-              SymlinkAction inAction = (SymlinkAction) in;
-              SymlinkAction outAction = (SymlinkAction) out;
-              assertThat(inAction.getPrimaryInput().getFilename())
-                  .isEqualTo(outAction.getPrimaryInput().getFilename());
-              assertThat(inAction.getPrimaryOutput().getFilename())
-                  .isEqualTo(outAction.getPrimaryOutput().getFilename());
-              assertThat(inAction.getOwner()).isEqualTo(outAction.getOwner());
-              assertThat(inAction.getProgressMessage()).isEqualTo(outAction.getProgressMessage());
-            })
-        .runTests();
+  private static InputMetadataProvider createInputMetadataProvider(Iterable<Artifact> inputs)
+      throws IOException {
+    ActionInputMap inputMap = new ActionInputMap(1);
+    for (Artifact input : inputs) {
+      if (input.isTreeArtifact()) {
+        inputMap.putTreeArtifact(input, TreeArtifactValue.empty());
+      } else {
+        inputMap.put(input, FileArtifactValue.createForTesting(input));
+      }
+    }
+    return inputMap;
   }
 }
