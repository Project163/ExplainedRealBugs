diff --git a/src/main/java/com/google/devtools/build/lib/analysis/ExecGroupCollection.java b/src/main/java/com/google/devtools/build/lib/analysis/ExecGroupCollection.java
index 237b0deecb..0bf9b4bbf3 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/ExecGroupCollection.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/ExecGroupCollection.java
@@ -118,12 +118,13 @@ public abstract class ExecGroupCollection {
 
     public ExecGroupCollection build(
         @Nullable ToolchainCollection<ResolvedToolchainContext> toolchainContexts,
-        ImmutableMap<String, String> rawExecProperties)
+        ImmutableMap<String, String> rawExecProperties,
+        String targetLabel)
         throws InvalidExecGroupException {
 
       // For each exec group, compute the combined execution properties.
       ImmutableTable<String, String, String> combinedExecProperties =
-          computeCombinedExecProperties(toolchainContexts, rawExecProperties);
+          computeCombinedExecProperties(toolchainContexts, rawExecProperties, targetLabel);
 
       return new AutoValue_ExecGroupCollection(execGroups(), combinedExecProperties);
     }
@@ -135,7 +136,8 @@ public abstract class ExecGroupCollection {
    */
   private static ImmutableTable<String, String, String> computeCombinedExecProperties(
       @Nullable ToolchainCollection<ResolvedToolchainContext> toolchainContexts,
-      ImmutableMap<String, String> rawExecProperties)
+      ImmutableMap<String, String> rawExecProperties,
+      String targetLabel)
       throws InvalidExecGroupException {
 
     ImmutableSet<String> execGroupNames;
@@ -158,6 +160,7 @@ public abstract class ExecGroupCollection {
       if (!unknownTargetExecGroupNames.isEmpty()) {
         throw new InvalidExecGroupException(
             "exec_properties",
+            targetLabel,
             unknownTargetExecGroupNames,
             Iterables.concat(execGroupNames, ImmutableSet.of(DEFAULT_EXEC_GROUP_NAME)));
       }
@@ -283,11 +286,15 @@ public abstract class ExecGroupCollection {
   public static final class InvalidExecGroupException extends AbstractSaneAnalysisException {
 
     public InvalidExecGroupException(
-        String what, Collection<String> invalidNames, Iterable<String> validNames) {
+        String what,
+        String targetLabel,
+        Collection<String> invalidNames,
+        Iterable<String> validNames) {
       super(
           String.format(
-              "Tried to set %s for non-existent exec groups: %s%s",
+              "Tried to set %s for non-existent exec groups on %s: %s%s",
               what,
+              targetLabel,
               String.join(",", invalidNames),
               invalidNames.stream()
                   .map(invalidName -> SpellChecker.didYouMean(invalidName, validNames))
diff --git a/src/main/java/com/google/devtools/build/lib/analysis/RuleContext.java b/src/main/java/com/google/devtools/build/lib/analysis/RuleContext.java
index dacedacb28..aa458bc913 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/RuleContext.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/RuleContext.java
@@ -1559,7 +1559,8 @@ public class RuleContext extends TargetContext
         }
       }
 
-      return execGroupCollectionBuilder.build(toolchainContexts, rawExecProperties);
+      return execGroupCollectionBuilder.build(
+          toolchainContexts, rawExecProperties, getRule().getDisplayFormLabel());
     }
 
     private void checkAttributesNonEmpty(AttributeMap attributes) {
diff --git a/src/main/java/com/google/devtools/build/lib/packages/Target.java b/src/main/java/com/google/devtools/build/lib/packages/Target.java
index 9dadb42b0e..5f26655efd 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/Target.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/Target.java
@@ -190,4 +190,11 @@ public interface Target extends TargetData {
    * Creates a compact representation of this target with enough information for dependent parents.
    */
   TargetData reduceForSerialization();
+
+  /** Returns the label identifying as a string formatted for display. */
+  default String getDisplayFormLabel() {
+    return getLabel()
+        .getDisplayForm(
+            getLabel().getRepository().isMain() ? getPackage().getRepositoryMapping() : null);
+  }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainContextUtil.java b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainContextUtil.java
index 13fde74445..d0a493af97 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainContextUtil.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainContextUtil.java
@@ -196,6 +196,7 @@ public final class ToolchainContextUtil {
         if (!rule.getRuleClassObject().getExecGroups().containsKey(canonicalKey)) {
           throw new ExecGroupCollection.InvalidExecGroupException(
               "execution constraints",
+              rule.getDisplayFormLabel(),
               ImmutableSet.of(canonicalKey),
               rule.getRuleClassObject().getExecGroups().keySet());
         }
@@ -205,7 +206,10 @@ public final class ToolchainContextUtil {
           label = Label.parseWithPackageContext(entry.getKey(), packageContext);
         } catch (LabelSyntaxException e) {
           throw new ExecGroupCollection.InvalidExecGroupException(
-              "execution constraints", ImmutableSet.of(entry.getKey()), ImmutableSet.of());
+              "execution constraints",
+              rule.getDisplayFormLabel(),
+              ImmutableSet.of(entry.getKey()),
+              ImmutableSet.of());
         }
         if (toolchainTypes.stream()
             .map(ToolchainTypeRequirement::toolchainType)
@@ -220,12 +224,18 @@ public final class ToolchainContextUtil {
                     .collect(toImmutableSet());
           }
           throw new ExecGroupCollection.InvalidExecGroupException(
-              "execution constraints", ImmutableSet.of(entry.getKey()), suggestedLabels);
+              "execution constraints",
+              rule.getDisplayFormLabel(),
+              ImmutableSet.of(entry.getKey()),
+              suggestedLabels);
         }
         canonicalKey = label.getUnambiguousCanonicalForm();
       } else {
         throw new ExecGroupCollection.InvalidExecGroupException(
-            "execution constraints", ImmutableSet.of(entry.getKey()), ImmutableSet.of());
+            "execution constraints",
+            rule.getDisplayFormLabel(),
+            ImmutableSet.of(entry.getKey()),
+            ImmutableSet.of());
       }
       execGroupConstraints.putAll(canonicalKey, entry.getValue());
     }
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/AutoExecGroupsTest.java b/src/test/java/com/google/devtools/build/lib/analysis/AutoExecGroupsTest.java
index 4738908930..e31976b4e4 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/AutoExecGroupsTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/AutoExecGroupsTest.java
@@ -1266,8 +1266,9 @@ public class AutoExecGroupsTest extends BuildViewTestCase {
     getConfiguredTarget("//test:custom_rule_name");
 
     assertContainsEvent(
-        "Tried to set execution constraints for non-existent exec groups: //rule:toolchain_type_2"
-            + " (did you mean '//rule:toolchain_type_1'?)");
+        "Tried to set execution constraints for non-existent exec groups on"
+            + " //test:custom_rule_name: //rule:toolchain_type_2 (did you mean"
+            + " '//rule:toolchain_type_1'?)");
   }
 
   @Test
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/StarlarkExecGroupTest.java b/src/test/java/com/google/devtools/build/lib/analysis/StarlarkExecGroupTest.java
index b249145742..6fd07212dc 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/StarlarkExecGroupTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/StarlarkExecGroupTest.java
@@ -930,8 +930,8 @@ public class StarlarkExecGroupTest extends BuildViewTestCase {
     reporter.removeHandler(failFastHandler);
     getConfiguredTarget("//test:a");
     assertContainsEvent(
-        "Tried to set execution constraints for non-existent exec groups: my_grou (did you mean"
-            + " 'my_group'?)");
+        "Tried to set execution constraints for non-existent exec groups on"
+            + " //test:a: my_grou (did you mean 'my_group'?)");
   }
 
   @Test
diff --git a/src/test/shell/integration/exec_group_test.sh b/src/test/shell/integration/exec_group_test.sh
index 52f4c142bf..5589cefb23 100755
--- a/src/test/shell/integration/exec_group_test.sh
+++ b/src/test/shell/integration/exec_group_test.sh
@@ -610,7 +610,7 @@ cc_test(
 )
 EOF
   bazel test ${pkg}:a &> $TEST_log && fail "Build passed when we expected an error"
-  grep "Tried to set exec_properties for non-existent exec group" $TEST_log || fail "Did not complain about unknown exec group"
+  grep "Tried to set exec_properties for non-existent exec groups on //${pkg}:a: unknown" $TEST_log || fail "Did not complain about unknown exec group"
 }
 
 function write_toolchains_for_exec_group_tests() {
