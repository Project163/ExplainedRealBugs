diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/CompiledModuleFile.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/CompiledModuleFile.java
index 0d17833268..ca2c809fe7 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/CompiledModuleFile.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/CompiledModuleFile.java
@@ -108,7 +108,8 @@ public record CompiledModuleFile(
   static ImmutableList<IncludeStatement> checkModuleFileSyntax(StarlarkFile starlarkFile)
       throws SyntaxError.Exception {
     var includeStatements = ImmutableList.<IncludeStatement>builder();
-    new DotBazelFileSyntaxChecker("MODULE.bazel files", /* canLoadBzl= */ false) {
+    new DotBazelFileSyntaxChecker(
+        "MODULE.bazel files", /* canLoadBzl= */ false, /* allowLiteralStarStarArgs= */ true) {
       // Once `include` the identifier is assigned to, we no longer care about its appearance
       // anywhere. This allows `include` to be used as a module extension proxy (and technically
       // any other variable binding).
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileGlobals.java b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileGlobals.java
index ae63f51d18..689561d92d 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileGlobals.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileGlobals.java
@@ -644,10 +644,15 @@ public class ModuleFileGlobals {
           @Param(
               name = "kwargs",
               doc =
-                  "Specifies certain repos to import into the scope of the current module with"
-                      + " different names. The keys should be the name to use in the current scope,"
-                      + " whereas the values should be the original names exported by the module"
-                      + " extension."),
+                  """
+                  Specifies certain repos to import into the scope of the current module with
+                  different names. The keys should be the name to use in the current scope,
+                  whereas the values should be the original names exported by the module
+                  extension.
+                  <p>Keys that are not valid identifiers can be specified via a literal dict
+                  passed as extra keyword arguments, e.g.,
+                  <code>use_repo(extension_proxy, **{"foo.2": "foo"})</code>.
+                  """),
       useStarlarkThread = true)
   public void useRepo(
       ModuleExtensionProxy extensionProxy,
@@ -697,7 +702,10 @@ public class ModuleFileGlobals {
                   """
                   The overrides to apply to the repos generated by the extension, where the values
                   are the names of repos in the scope of the current module and the keys are the
-                  names of the repos they will override in the extension.\
+                  names of the repos they will override in the extension.
+                  <p>Keys that are not valid identifiers can be specified via a literal dict
+                  passed as extra keyword arguments, e.g.,
+                  <code>override_repo(extension_proxy, **{"foo.2": "foo"})</code>.
                   """),
       useStarlarkThread = true)
   public void overrideRepo(
@@ -754,7 +762,10 @@ public class ModuleFileGlobals {
                   """
                   The new repos to inject into the extension, where the values are the names of
                   repos in the scope of the current module and the keys are the name they will be
-                  visible under in the extension.\
+                  visible under in the extension.
+                  <p>Keys that are not valid identifiers can be specified via a literal dict
+                  passed as extra keyword arguments, e.g.,
+                  <code>inject_repo(extension_proxy, **{"foo.2": "foo"})</code>.
                   """),
       useStarlarkThread = true)
   public void injectRepo(
diff --git a/src/main/java/com/google/devtools/build/lib/packages/DotBazelFileSyntaxChecker.java b/src/main/java/com/google/devtools/build/lib/packages/DotBazelFileSyntaxChecker.java
index ac34c8e050..783a8a4749 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/DotBazelFileSyntaxChecker.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/DotBazelFileSyntaxChecker.java
@@ -20,6 +20,7 @@ import com.google.devtools.build.lib.concurrent.ThreadSafety.ThreadHostile;
 import net.starlark.java.syntax.Argument;
 import net.starlark.java.syntax.CallExpression;
 import net.starlark.java.syntax.DefStatement;
+import net.starlark.java.syntax.DictExpression;
 import net.starlark.java.syntax.ForStatement;
 import net.starlark.java.syntax.IfStatement;
 import net.starlark.java.syntax.LambdaExpression;
@@ -46,16 +47,26 @@ import net.starlark.java.syntax.SyntaxError;
 public class DotBazelFileSyntaxChecker extends NodeVisitor {
   private final String where;
   private final boolean canLoadBzl;
+  private final boolean allowLiteralStarStarArgs;
   private ImmutableList.Builder<SyntaxError> errors = ImmutableList.builder();
 
   /**
    * @param where describes the type of file being checked.
    * @param canLoadBzl whether the file type being check supports load statements. This is used to
    *     generate more informative error messages.
+   * @param allowLiteralStarStarArgs whether to allow **kwargs in function calls if the dict is a
+   *     literal. This is needed for some functions that take arbitrary keyword arguments whose keys
+   *     may have to contain non-identifier characters.
    */
-  public DotBazelFileSyntaxChecker(String where, boolean canLoadBzl) {
+  public DotBazelFileSyntaxChecker(
+      String where, boolean canLoadBzl, boolean allowLiteralStarStarArgs) {
     this.where = where;
     this.canLoadBzl = canLoadBzl;
+    this.allowLiteralStarStarArgs = allowLiteralStarStarArgs;
+  }
+
+  public DotBazelFileSyntaxChecker(String where, boolean canLoadBzl) {
+    this(where, canLoadBzl, /* allowLiteralStarStarArgs= */ false);
   }
 
   public final void check(StarlarkFile file) throws SyntaxError.Exception {
@@ -74,12 +85,19 @@ public class DotBazelFileSyntaxChecker extends NodeVisitor {
   // Reject f(*args) and f(**kwargs) calls.
   private void rejectStarArgs(CallExpression call) {
     for (Argument arg : call.getArguments()) {
-      if (arg instanceof Argument.StarStar) {
-        error(
-            arg.getStartLocation(),
-            "**kwargs arguments are not allowed in "
-                + where
-                + ". Pass the arguments in explicitly.");
+      if (arg instanceof Argument.StarStar starStar) {
+        if (!allowLiteralStarStarArgs) {
+          error(
+              arg.getStartLocation(),
+              "**kwargs arguments are not allowed in "
+                  + where
+                  + ". Pass the arguments in explicitly.");
+        }
+        if (!(starStar.getValue() instanceof DictExpression)) {
+          error(
+              arg.getStartLocation(),
+              "**kwargs arguments must be a literal dict in " + where + ".");
+        }
       } else if (arg instanceof Argument.Star) {
         error(
             arg.getStartLocation(),
diff --git a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
index 5c9c92fb2e..b75e129c06 100644
--- a/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
+++ b/src/test/java/com/google/devtools/build/lib/bazel/bzlmod/ModuleFileFunctionTest.java
@@ -2044,6 +2044,56 @@ public class ModuleFileFunctionTest extends FoundationTestCase {
         """);
   }
 
+  @Test
+  public void testOverrideRepo_extraKeywordArguments_literal() throws Exception {
+    scratch.overwriteFile(
+        rootDirectory.getRelative("MODULE.bazel").getPathString(),
+        """
+        module(name='aaa')
+        ext1 = use_extension('//:defs.bzl', 'ext1')
+        use_repo(ext1, "foo")
+        ext2 = use_extension('//:defs.bzl', 'ext2')
+        use_repo(ext2, "bar.2")
+        override_repo(ext2, **{"foo.2": "foo"})
+        """);
+
+    EvaluationResult<RootModuleFileValue> result =
+        evaluator.evaluate(
+            ImmutableList.of(ModuleFileValue.KEY_FOR_ROOT_MODULE), evaluationContext);
+    assertThat(result.hasError()).isFalse();
+
+    var ext2Usage =
+        result.get(ModuleFileValue.KEY_FOR_ROOT_MODULE).module().getExtensionUsages().get(1);
+    assertThat(ext2Usage.getRepoOverrides().keySet()).containsExactly("foo.2");
+  }
+
+  @Test
+  public void testOverrideRepo_extraKeywordArguments_nonLiteral() throws Exception {
+    scratch.overwriteFile(
+        rootDirectory.getRelative("MODULE.bazel").getPathString(),
+        """
+        module(name='aaa')
+        ext1 = use_extension('//:defs.bzl', 'ext1')
+        use_repo(ext1, "foo")
+        ext2 = use_extension('//:defs.bzl', 'ext2')
+        use_repo(ext2, "bar.2")
+        KWARGS = {"foo.2": "foo"}
+        override_repo(ext2, **KWARGS)
+        """);
+
+    reporter.removeHandler(failFastHandler);
+    EvaluationResult<RootModuleFileValue> result =
+        evaluator.evaluate(
+            ImmutableList.of(ModuleFileValue.KEY_FOR_ROOT_MODULE), evaluationContext);
+    assertThat(result.hasError()).isTrue();
+
+    assertContainsEvent(
+        """
+        ERROR /workspace/MODULE.bazel:7:21: **kwargs arguments must be a literal dict in \
+        MODULE.bazel files.\
+        """);
+  }
+
   @Test
   public void testInjectRepo_imported() throws Exception {
     scratch.overwriteFile(
