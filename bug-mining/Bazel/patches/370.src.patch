diff --git a/src/main/java/com/google/devtools/build/lib/remote/merkletree/MerkleTreeComputer.java b/src/main/java/com/google/devtools/build/lib/remote/merkletree/MerkleTreeComputer.java
index 52ebecdf9d..1b8fe55081 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/merkletree/MerkleTreeComputer.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/merkletree/MerkleTreeComputer.java
@@ -417,12 +417,31 @@ public final class MerkleTreeComputer {
 
     PathFragment currentParent = PathFragment.EMPTY_FRAGMENT;
     PathFragment lastSourceDirPath = null;
+    Map.Entry<PathFragment, ? extends ActionInput> lastEntry = null;
     for (var entry : Iterables.concat(sortedInputs, END_OF_INPUTS_SENTINEL)) {
       if (Thread.interrupted()) {
         throw new InterruptedException();
       }
 
       PathFragment path = entry.getKey();
+      // The same path may appear multiple times if the inputs are outputs of shared actions. Only
+      // stage the first one.
+      if (lastEntry != null && path.equals(lastEntry.getKey())) {
+        var previousInput = lastEntry.getValue();
+        var currentInput = entry.getValue();
+        checkState(
+            previousInput instanceof Artifact previousArtifact
+                && currentInput instanceof Artifact currentArtifact
+                && !previousInput.equals(currentInput)
+                && new Artifact.OwnerlessArtifactWrapper(previousArtifact)
+                    .equals(new Artifact.OwnerlessArtifactWrapper(currentArtifact)),
+            "Duplicate paths are only allowed for distinct shared artifacts, got: %s and %s at %s",
+            previousInput,
+            currentInput,
+            path);
+        continue;
+      }
+      lastEntry = entry;
       if (spawnScrubber != null && spawnScrubber.shouldOmitInput(path)) {
         continue;
       }
diff --git a/src/test/java/com/google/devtools/build/lib/actions/util/ActionsTestUtil.java b/src/test/java/com/google/devtools/build/lib/actions/util/ActionsTestUtil.java
index 87802f0df5..371b51a27b 100644
--- a/src/test/java/com/google/devtools/build/lib/actions/util/ActionsTestUtil.java
+++ b/src/test/java/com/google/devtools/build/lib/actions/util/ActionsTestUtil.java
@@ -126,6 +126,9 @@ public final class ActionsTestUtil {
 
   public static final Label NULL_LABEL = Label.parseCanonicalUnchecked("//null/action:owner");
 
+  public static final Label YET_ANOTHER_NULL_LABEL =
+      Label.parseCanonicalUnchecked("//yet/another/null/action:owner");
+
   public static ActionExecutionContext createContext(
       Executor executor,
       ExtendedEventHandler eventHandler,
@@ -376,6 +379,32 @@ public final class ActionsTestUtil {
         }
       };
 
+  @SerializationConstant
+  public static final ActionLookupKey YET_ANOTHER_NULL_ARTIFACT_OWNER =
+      new ActionLookupKey() {
+
+        @Override
+        public SkyFunctionName functionName() {
+          return null;
+        }
+
+        @Override
+        public Label getLabel() {
+          return YET_ANOTHER_NULL_LABEL;
+        }
+
+        @Nullable
+        @Override
+        public BuildConfigurationKey getConfigurationKey() {
+          return null;
+        }
+
+        @Override
+        public String toString() {
+          return "YET_ANOTHER_NULL_ARTIFACT_OWNER";
+        }
+      };
+
   public static final ActionTemplateExpansionKey NULL_TEMPLATE_EXPANSION_ARTIFACT_OWNER =
       ActionTemplateExpansionValue.key(NULL_ARTIFACT_OWNER, /* actionIndex= */ 0);
 
@@ -408,6 +437,10 @@ public final class ActionsTestUtil {
   public static final ActionLookupData NULL_ACTION_LOOKUP_DATA =
       ActionLookupData.create(NULL_ARTIFACT_OWNER, 0);
 
+  @SerializationConstant
+  public static final ActionLookupData YET_ANOTHER_NULL_ACTION_LOOKUP_DATA =
+      ActionLookupData.create(YET_ANOTHER_NULL_ARTIFACT_OWNER, 0);
+
   /** An unchecked exception class for action conflicts. */
   public static class UncheckedActionConflictException extends RuntimeException {
     public UncheckedActionConflictException(ActionConflictException e) {
diff --git a/src/test/java/com/google/devtools/build/lib/remote/BuildWithoutTheBytesIntegrationTestBase.java b/src/test/java/com/google/devtools/build/lib/remote/BuildWithoutTheBytesIntegrationTestBase.java
index df36ee14a3..037fe76478 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/BuildWithoutTheBytesIntegrationTestBase.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/BuildWithoutTheBytesIntegrationTestBase.java
@@ -1797,6 +1797,42 @@ public abstract class BuildWithoutTheBytesIntegrationTestBase extends BuildInteg
     assertValidOutputFile("actual/file-3", "3");
   }
 
+  @Test
+  public void testShareableActionOutputsAsInputs() throws Exception {
+    write(
+        "defs.bzl",
+        """
+        def _generate_shared_file(ctx):
+            output = ctx.actions.declare_file("shared.txt")
+            ctx.actions.run_shell(
+                outputs = [output],
+                command = "echo -n 'shared content' > %s" % output.path,
+            )
+            return [DefaultInfo(files=depset([output]))]
+        generate_shared_file = rule(_generate_shared_file)
+        """);
+    write(
+        "BUILD",
+        """
+        load(":defs.bzl", "generate_shared_file")
+        generate_shared_file(name = "gen1")
+        generate_shared_file(name = "gen2")
+        genrule(
+            name = "consume_outputs",
+            srcs = [":gen1", ":gen2"],
+            outs = ["combined_output.txt"],
+            cmd = "cat $(SRCS) > $@",
+        )
+        """);
+
+    buildTarget("//:consume_outputs");
+
+    assertOnlyOutputRemoteContent(
+        "//:consume_outputs", "combined_output.txt", "shared contentshared content");
+    assertOnlyOutputRemoteContent("//:gen1", "shared.txt", "shared content");
+    assertOnlyOutputRemoteContent("//:gen2", "shared.txt", "shared content");
+  }
+
   protected void assertOutputsDoNotExist(String target) throws Exception {
     for (Artifact output : getArtifacts(target)) {
       assertWithMessage(
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
index f3584298e6..b7a6423e8f 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
@@ -498,6 +498,21 @@ public class RemoteExecutionServiceTest {
         ActionsTestUtil.createTreeArtifactWithGeneratingAction(artifactRoot, "empty_dir");
     fakeFileCache.addTreeArtifact(emptyDir, TreeArtifactValue.newBuilder(emptyDir).build());
     inputs.add(emptyDir);
+    // Add an artifact with the same path but different owner to verify that the directory isn't
+    // duplicated in the Merkle tree.
+    PathFragment execPath = artifactRoot.getExecPath().getRelative("empty_dir");
+    var emptyDirWithDifferentOwner =
+        Artifact.SpecialArtifact.create(
+            artifactRoot,
+            execPath,
+            ActionsTestUtil.YET_ANOTHER_NULL_ARTIFACT_OWNER,
+            Artifact.SpecialArtifactType.TREE);
+    emptyDirWithDifferentOwner.setGeneratingActionKey(
+        ActionsTestUtil.YET_ANOTHER_NULL_ACTION_LOOKUP_DATA);
+    fakeFileCache.addTreeArtifact(
+        emptyDirWithDifferentOwner,
+        TreeArtifactValue.newBuilder(emptyDirWithDifferentOwner).build());
+    inputs.add(emptyDirWithDifferentOwner);
 
     var runfilesTreeRoot = artifactRoot.getExecPath().getRelative("dir/my_tool.runfiles");
     var runfilesTree =
@@ -3024,7 +3039,8 @@ public class RemoteExecutionServiceTest {
                     artifact ->
                         PathFragment.create(TestConstants.WORKSPACE_NAME)
                             .getRelative(artifact.getRunfilesPath()),
-                    identity()));
+                    identity(),
+                    (a, b) -> b));
       }
 
       @Override
diff --git a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
index 7da6c0944a..70a437aaa1 100644
--- a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
+++ b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
@@ -37,6 +37,7 @@ import com.google.devtools.build.lib.vfs.Path;
 import com.google.devtools.build.lib.vfs.PathFragment;
 import com.google.protobuf.ByteString;
 import java.io.IOException;
+import java.util.HashSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -83,13 +84,20 @@ class OnDiskBlobStoreCache extends CombinedCache {
       throws IOException, InterruptedException {
     rootLocation.createDirectoryAndParents();
     Directory directory = Directory.parseFrom(getFromFuture(downloadBlob(context, rootDigest)));
+    HashSet<Path> childrenSeen = new HashSet<>();
     for (FileNode file : directory.getFilesList()) {
       Path dst = rootLocation.getRelative(unicodeToInternal(file.getName()));
+      if (!childrenSeen.add(dst)) {
+        throw new IOException("Duplicate child '%s' in directory %s".formatted(dst, directory));
+      }
       getFromFuture(downloadFile(context, dst, file.getDigest()));
       dst.setExecutable(file.getIsExecutable());
     }
     for (SymlinkNode symlink : directory.getSymlinksList()) {
       Path dst = rootLocation.getRelative(unicodeToInternal(symlink.getName()));
+      if (!childrenSeen.add(dst)) {
+        throw new IOException("Duplicate child '%s' in directory %s".formatted(dst, directory));
+      }
       // TODO(fmeum): The following line is not generally correct: The remote execution API allows
       //  for non-normalized symlink targets, but the normalization applied by PathFragment.create
       //  does not take directory symlinks into account. However, Bazel's file system API does not
@@ -98,8 +106,11 @@ class OnDiskBlobStoreCache extends CombinedCache {
       dst.createSymbolicLink(PathFragment.create(unicodeToInternal(symlink.getTarget())));
     }
     for (DirectoryNode child : directory.getDirectoriesList()) {
-      downloadTree(
-          context, child.getDigest(), rootLocation.getRelative(unicodeToInternal(child.getName())));
+      Path dst = rootLocation.getRelative(unicodeToInternal(child.getName()));
+      if (!childrenSeen.add(dst)) {
+        throw new IOException("Duplicate child '%s' in directory %s".formatted(dst, directory));
+      }
+      downloadTree(context, child.getDigest(), dst);
     }
   }
 
