diff --git a/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java b/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
index b6027c798f..4bdc7a730f 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java
@@ -396,7 +396,7 @@ public class BazelRepositoryModule extends BlazeModule {
             Profiler.instance()
                 .profile(ProfilerTask.REPO_CACHE_GC_WAIT, "waiting to acquire repo cache lock")) {
           repositoryCache.getRepoContentsCache().acquireSharedLock();
-        } catch (IOException e) {
+        } catch (IOException | InterruptedException e) {
           throw new AbruptExitException(
               detailedExitCode(
                   "could not acquire lock on repo contents cache", Code.BAD_REPO_CONTENTS_CACHE),
diff --git a/src/main/java/com/google/devtools/build/lib/bazel/repository/cache/RepoContentsCache.java b/src/main/java/com/google/devtools/build/lib/bazel/repository/cache/RepoContentsCache.java
index 9410b899ac..0876c9f3b1 100644
--- a/src/main/java/com/google/devtools/build/lib/bazel/repository/cache/RepoContentsCache.java
+++ b/src/main/java/com/google/devtools/build/lib/bazel/repository/cache/RepoContentsCache.java
@@ -157,13 +157,10 @@ public final class RepoContentsCache {
    */
   public Path moveToCache(
       Path fetchedRepoDir, Path fetchedRepoMarkerFile, String predeclaredInputHash)
-      throws IOException {
+      throws IOException, InterruptedException {
     Preconditions.checkState(path != null);
 
     Path entryDir = path.getRelative(predeclaredInputHash);
-    if (!entryDir.isDirectory()) {
-      entryDir.delete();
-    }
     String counter = getNextCounterInDir(entryDir);
     Path cacheRecordedInputsFile = entryDir.getChild(counter + RECORDED_INPUTS_SUFFIX);
     Path cacheRepoDir = entryDir.getChild(counter);
@@ -188,8 +185,12 @@ public final class RepoContentsCache {
     return cacheRepoDir;
   }
 
-  private static String getNextCounterInDir(Path entryDir) throws IOException {
+  private static String getNextCounterInDir(Path entryDir)
+      throws IOException, InterruptedException {
     Path counterFile = entryDir.getRelative("counter");
+    // This use of FileSystemLock.get is safe since the predeclared input hash is part of entryDir's
+    // path and in particular includes the canonical repository name. This ensures that the same
+    // lock file will not be acquired concurrently by multiple threads, which isn't supported.
     try (var lock = FileSystemLock.get(entryDir.getRelative("lock"), LockMode.EXCLUSIVE)) {
       int c = 0;
       if (counterFile.exists()) {
@@ -205,7 +206,7 @@ public final class RepoContentsCache {
     }
   }
 
-  public void acquireSharedLock() throws IOException {
+  public void acquireSharedLock() throws IOException, InterruptedException {
     Preconditions.checkState(path != null);
     Preconditions.checkState(sharedLock == null, "this process already has the shared lock");
     sharedLock = FileSystemLock.get(path.getRelative(LOCK_PATH), LockMode.SHARED);
diff --git a/src/main/java/com/google/devtools/build/lib/util/BUILD b/src/main/java/com/google/devtools/build/lib/util/BUILD
index a8b91f9b60..cad1f2d4e9 100644
--- a/src/main/java/com/google/devtools/build/lib/util/BUILD
+++ b/src/main/java/com/google/devtools/build/lib/util/BUILD
@@ -46,6 +46,7 @@ java_library(
     srcs = ["FileSystemLock.java"],
     deps = [
         ":string_encoding",
+        "//src/main/java/com/google/devtools/build/lib/concurrent:thread_safety",
         "//src/main/java/com/google/devtools/build/lib/vfs",
         "//third_party:guava",
     ],
diff --git a/src/main/java/com/google/devtools/build/lib/util/FileSystemLock.java b/src/main/java/com/google/devtools/build/lib/util/FileSystemLock.java
index 779889c75a..4e87e07631 100644
--- a/src/main/java/com/google/devtools/build/lib/util/FileSystemLock.java
+++ b/src/main/java/com/google/devtools/build/lib/util/FileSystemLock.java
@@ -13,12 +13,13 @@
 // limitations under the License.
 package com.google.devtools.build.lib.util;
 
-
 import com.google.common.annotations.VisibleForTesting;
+import com.google.devtools.build.lib.concurrent.ThreadSafety;
 import com.google.devtools.build.lib.vfs.Path;
 import java.io.IOException;
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileLock;
+import java.nio.channels.FileLockInterruptionException;
 import java.nio.file.StandardOpenOption;
 
 /**
@@ -71,9 +72,12 @@ public final class FileSystemLock implements AutoCloseable {
    * Tries to acquires a lock on the given path with the given mode. Throws an exception if the lock
    * is already held by another process.
    *
+   * <p>This method must not be called concurrently from multiple threads with the same path.
+   *
    * @throws LockAlreadyHeldException if the lock is already exclusively held by another process
    * @throws IOException if another error occurred
    */
+  @ThreadSafety.ThreadHostile
   public static FileSystemLock tryGet(Path path, LockMode mode) throws IOException {
     FileChannel channel = prepareChannel(path);
     FileLock lock = channel.tryLock(0, Long.MAX_VALUE, mode == LockMode.SHARED);
@@ -83,10 +87,23 @@ public final class FileSystemLock implements AutoCloseable {
     return new FileSystemLock(channel, lock);
   }
 
-  /** Acquires a lock on the given path with the given mode. Blocks until the lock is acquired. */
-  public static FileSystemLock get(Path path, LockMode mode) throws IOException {
+  /**
+   * Acquires a lock on the given path with the given mode. Blocks until the lock is acquired.
+   *
+   * <p>This method must not be called concurrently from multiple threads with the same path.
+   */
+  @ThreadSafety.ThreadHostile
+  public static FileSystemLock get(Path path, LockMode mode)
+      throws IOException, InterruptedException {
     FileChannel channel = prepareChannel(path);
-    FileLock lock = channel.lock(0, Long.MAX_VALUE, mode == LockMode.SHARED);
+    FileLock lock;
+    try {
+      lock = channel.lock(0, Long.MAX_VALUE, mode == LockMode.SHARED);
+    } catch (FileLockInterruptionException e) {
+      Thread.interrupted(); // clear interrupt bit
+      channel.close();
+      throw new InterruptedException();
+    }
     return new FileSystemLock(channel, lock);
   }
 
