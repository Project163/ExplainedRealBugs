diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteActionContextProvider.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteActionContextProvider.java
index f329fe627f..0e66c09e28 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteActionContextProvider.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteActionContextProvider.java
@@ -14,7 +14,6 @@
 package com.google.devtools.build.lib.remote;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import build.bazel.remote.execution.v2.Digest;
 import com.google.common.base.Preconditions;
@@ -35,13 +34,11 @@ import com.google.devtools.build.lib.util.TempPathGenerator;
 import com.google.devtools.build.lib.vfs.OutputService;
 import com.google.devtools.build.lib.vfs.Path;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 
 /** Provides a remote execution context. */
 final class RemoteActionContextProvider {
 
-  private final Executor executor;
   private final CommandEnvironment env;
   @Nullable private final CombinedCache combinedCache;
   @Nullable private final RemoteExecutionClient remoteExecutor;
@@ -56,7 +53,6 @@ final class RemoteActionContextProvider {
   private final Set<Digest> knownMissingCasDigests;
 
   private RemoteActionContextProvider(
-      Executor executor,
       CommandEnvironment env,
       @Nullable CombinedCache combinedCache,
       @Nullable RemoteExecutionClient remoteExecutor,
@@ -66,7 +62,6 @@ final class RemoteActionContextProvider {
       @Nullable RemoteOutputChecker remoteOutputChecker,
       @Nullable OutputService outputService,
       Set<Digest> knownMissingCasDigests) {
-    this.executor = executor;
     this.env = Preconditions.checkNotNull(env, "env");
     this.combinedCache = combinedCache;
     this.remoteExecutor = remoteExecutor;
@@ -84,7 +79,6 @@ final class RemoteActionContextProvider {
       DigestUtil digestUtil,
       Set<Digest> knownMissingCasDigests) {
     return new RemoteActionContextProvider(
-        directExecutor(),
         env,
         /* combinedCache= */ null,
         /* remoteExecutor= */ null,
@@ -97,7 +91,6 @@ final class RemoteActionContextProvider {
   }
 
   public static RemoteActionContextProvider createForRemoteCaching(
-      Executor executor,
       CommandEnvironment env,
       CombinedCache combinedCache,
       ListeningScheduledExecutorService retryScheduler,
@@ -106,7 +99,6 @@ final class RemoteActionContextProvider {
       OutputService outputService,
       Set<Digest> knownMissingCasDigests) {
     return new RemoteActionContextProvider(
-        executor,
         env,
         combinedCache,
         /* remoteExecutor= */ null,
@@ -119,7 +111,6 @@ final class RemoteActionContextProvider {
   }
 
   public static RemoteActionContextProvider createForRemoteExecution(
-      Executor executor,
       CommandEnvironment env,
       RemoteExecutionCache remoteCache,
       RemoteExecutionClient remoteExecutor,
@@ -130,7 +121,6 @@ final class RemoteActionContextProvider {
       OutputService outputService,
       Set<Digest> knownMissingCasDigests) {
     return new RemoteActionContextProvider(
-        executor,
         env,
         remoteCache,
         remoteExecutor,
@@ -174,7 +164,6 @@ final class RemoteActionContextProvider {
           checkNotNull(env.getOptions().getOptions(ExecutionOptions.class)).verboseFailures;
       remoteExecutionService =
           new RemoteExecutionService(
-              executor,
               env.getReporter(),
               verboseFailures,
               env.getExecRoot(),
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
index 7b78036ce4..5f0efa5700 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
@@ -135,9 +135,6 @@ import com.google.protobuf.ByteString;
 import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.Message;
 import io.grpc.Status.Code;
-import io.reactivex.rxjava3.core.Scheduler;
-import io.reactivex.rxjava3.core.Single;
-import io.reactivex.rxjava3.schedulers.Schedulers;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.time.Instant;
@@ -155,11 +152,11 @@ import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.Phaser;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -193,9 +190,11 @@ public class RemoteExecutionService {
   private final TempPathGenerator tempPathGenerator;
   @Nullable private final Path captureCorruptedOutputsDir;
   private final Set<String> reportedErrors = new HashSet<>();
-  private final Phaser backgroundTaskPhaser = new Phaser(1);
 
-  private final Scheduler scheduler;
+  @SuppressWarnings("AllowVirtualThreads")
+  private final ExecutorService backgroundTaskExecutor =
+      Executors.newThreadPerTaskExecutor(
+          Thread.ofVirtual().name("remote-execution-bg-", 0).factory());
 
   private final AtomicBoolean shutdown = new AtomicBoolean(false);
   private final AtomicBoolean buildInterrupted = new AtomicBoolean(false);
@@ -209,7 +208,6 @@ public class RemoteExecutionService {
   private Boolean useOutputPaths;
 
   public RemoteExecutionService(
-      Executor executor,
       Reporter reporter,
       boolean verboseFailures,
       Path execRoot,
@@ -254,7 +252,6 @@ public class RemoteExecutionService {
     this.tempPathGenerator = tempPathGenerator;
     this.captureCorruptedOutputsDir = captureCorruptedOutputsDir;
 
-    this.scheduler = Schedulers.from(executor, /* interruptibleWorker= */ true);
     this.remoteOutputChecker = remoteOutputChecker;
     this.outputService = outputService;
     this.knownMissingCasDigests = knownMissingCasDigests;
@@ -1132,7 +1129,7 @@ public class RemoteExecutionService {
       }
     }
 
-    waitForBulkTransfer(dirMetadataDownloads.values(), /* cancelRemainingOnInterrupt= */ true);
+    waitForBulkTransfer(dirMetadataDownloads.values());
 
     ImmutableMap.Builder<Path, DirectoryMetadata> directories = ImmutableMap.builder();
     for (Map.Entry<Path, ListenableFuture<Tree>> metadataDownload :
@@ -1346,7 +1343,7 @@ public class RemoteExecutionService {
 
     ImmutableList<ListenableFuture<FileMetadata>> downloads = downloadsBuilder.build();
     try (SilentCloseable c = Profiler.instance().profile("Remote.download")) {
-      waitForBulkTransfer(downloads, /* cancelRemainingOnInterrupt= */ true);
+      waitForBulkTransfer(downloads);
     } catch (Exception e) {
       // TODO(bazel-team): Consider adding better case-by-case exception handling instead of just
       // rethrowing
@@ -1697,54 +1694,34 @@ public class RemoteExecutionService {
     }
   }
 
-  private Single<UploadManifest> buildUploadManifestAsync(
-      RemoteAction action, SpawnResult spawnResult) {
-    return Single.fromCallable(
-        () -> {
-          try (SilentCloseable c = Profiler.instance().profile("build upload manifest")) {
-            ImmutableList.Builder<Path> outputFiles = ImmutableList.builder();
-            // Check that all mandatory outputs are created.
-            for (ActionInput outputFile : action.getSpawn().getOutputFiles()) {
-              Symlinks followSymlinks =
-                  outputFile.isSymlink() ? Symlinks.NOFOLLOW : Symlinks.FOLLOW;
-              Path localPath = execRoot.getRelative(outputFile.getExecPath());
-              if (action.getSpawn().isMandatoryOutput(outputFile)
-                  && !localPath.exists(followSymlinks)) {
-                throw new IOException(
-                    "Expected output " + prettyPrint(outputFile) + " was not created locally.");
-              }
-              outputFiles.add(localPath);
-            }
-
-            return UploadManifest.create(
-                combinedCache.getRemoteCacheCapabilities(),
-                digestUtil,
-                action.getRemotePathResolver(),
-                action.getActionKey(),
-                action.getAction(),
-                action.getCommand(),
-                outputFiles.build(),
-                action.getSpawnExecutionContext().getFileOutErr(),
-                spawnResult.exitCode(),
-                spawnResult.getStartTime(),
-                spawnResult.getWallTimeInMs());
-          }
-        });
-  }
-
   @VisibleForTesting
   UploadManifest buildUploadManifest(RemoteAction action, SpawnResult spawnResult)
       throws IOException, ExecException, InterruptedException {
-    try {
-      return buildUploadManifestAsync(action, spawnResult).blockingGet();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      if (cause != null) {
-        Throwables.throwIfInstanceOf(cause, IOException.class);
-        Throwables.throwIfInstanceOf(cause, ExecException.class);
-        Throwables.throwIfInstanceOf(cause, InterruptedException.class);
+    try (SilentCloseable c = Profiler.instance().profile("build upload manifest")) {
+      ImmutableList.Builder<Path> outputFiles = ImmutableList.builder();
+      // Check that all mandatory outputs are created.
+      for (ActionInput outputFile : action.getSpawn().getOutputFiles()) {
+        Symlinks followSymlinks = outputFile.isSymlink() ? Symlinks.NOFOLLOW : Symlinks.FOLLOW;
+        Path localPath = execRoot.getRelative(outputFile.getExecPath());
+        if (action.getSpawn().isMandatoryOutput(outputFile) && !localPath.exists(followSymlinks)) {
+          throw new IOException(
+              "Expected output " + prettyPrint(outputFile) + " was not created locally.");
+        }
+        outputFiles.add(localPath);
       }
-      throw e;
+
+      return UploadManifest.create(
+          combinedCache.getRemoteCacheCapabilities(),
+          digestUtil,
+          action.getRemotePathResolver(),
+          action.getActionKey(),
+          action.getAction(),
+          action.getCommand(),
+          outputFiles.build(),
+          action.getSpawnExecutionContext().getFileOutErr(),
+          spawnResult.exitCode(),
+          spawnResult.getStartTime(),
+          spawnResult.getWallTimeInMs());
     }
   }
 
@@ -1778,48 +1755,33 @@ public class RemoteExecutionService {
 
     if (remoteOptions.remoteCacheAsync
         && !action.getSpawn().getResourceOwner().mayModifySpawnOutputsAfterExecution()) {
-      AtomicLong startTime = new AtomicLong();
-      var unused =
-          Single.using(
-                  () -> {
-                    backgroundTaskPhaser.register();
-                    CombinedCache cache = combinedCache.retain();
-                    startTime.set(Profiler.nanoTimeMaybe());
-                    return cache;
-                  },
-                  combinedCache ->
-                      buildUploadManifestAsync(action, spawnResult)
-                          .flatMap(
-                              manifest ->
-                                  manifest.uploadAsync(
-                                      action.getRemoteActionExecutionContext(),
-                                      combinedCache,
-                                      reporter)),
-                  cacheResource -> {
-                    Profiler.instance()
-                        .completeTask(startTime.get(), ProfilerTask.UPLOAD_TIME, "upload outputs");
-                    onUploadComplete.run();
-                    // Release the cache first before arriving the backgroundTaskPhaser. Otherwise,
-                    // the release here could make the reference count reach zero and close the
-                    // cache, resulting in a deadlock when using HTTP cache.
-                    // See https://github.com/bazelbuild/bazel/issues/25232.
-                    cacheResource.release();
-                    backgroundTaskPhaser.arriveAndDeregister();
-                  },
-                  /* eager= */ false)
-              .subscribeOn(scheduler)
-              .subscribe(result -> {}, this::reportUploadError);
+      backgroundTaskExecutor.execute(
+          () -> {
+            try {
+              doUploadOutputs(action, spawnResult, onUploadComplete);
+            } catch (ExecException e) {
+              reportUploadError(e);
+            } catch (InterruptedException ignored) {
+              // ThreadPerTaskExecutor does not care about interrupt status.
+            }
+          });
     } else {
-      try (SilentCloseable c =
-          Profiler.instance().profile(ProfilerTask.UPLOAD_TIME, "upload outputs")) {
-        UploadManifest manifest = buildUploadManifest(action, spawnResult);
-        var unused =
-            manifest.upload(action.getRemoteActionExecutionContext(), combinedCache, reporter);
-      } catch (IOException e) {
-        reportUploadError(e);
-      } finally {
-        onUploadComplete.run();
-      }
+      doUploadOutputs(action, spawnResult, onUploadComplete);
+    }
+  }
+
+  private void doUploadOutputs(
+      RemoteAction action, SpawnResult spawnResult, Runnable onUploadComplete)
+      throws ExecException, InterruptedException {
+    try (SilentCloseable c =
+        Profiler.instance().profile(ProfilerTask.UPLOAD_TIME, "upload outputs")) {
+      UploadManifest manifest = buildUploadManifest(action, spawnResult);
+      var unused =
+          manifest.upload(action.getRemoteActionExecutionContext(), combinedCache, reporter);
+    } catch (IOException e) {
+      reportUploadError(e);
+    } finally {
+      onUploadComplete.run();
     }
   }
 
@@ -2022,31 +1984,25 @@ public class RemoteExecutionService {
     }
   }
 
-  /**
-   * Shuts the service down. Wait for active network I/O to finish but new requests are rejected.
-   */
+  /** Shuts the service down. */
   public void shutdown() {
     if (!shutdown.compareAndSet(false, true)) {
       return;
     }
 
     if (buildInterrupted.get()) {
+      backgroundTaskExecutor.shutdownNow();
+      if (combinedCache != null) {
+        combinedCache.shutdownNow();
+      }
       Thread.currentThread().interrupt();
     }
 
-    if (combinedCache != null) {
-      try {
-        backgroundTaskPhaser.awaitAdvanceInterruptibly(backgroundTaskPhaser.arrive());
-      } catch (InterruptedException e) {
-        buildInterrupted.set(true);
-        combinedCache.shutdownNow();
-        Thread.currentThread().interrupt();
-      }
+    // Waits for all background tasks to finish and interrupts them if there is another interrupt.
+    backgroundTaskExecutor.close();
 
-      // Only release the combinedCache once all background tasks have been finished. Otherwise, the
-      // last task might try to close the combinedCache inside the callback of network response
-      // which might cause deadlocks.
-      // See https://github.com/bazelbuild/bazel/issues/21568.
+    // Release the cache only after background tasks are done as they might be using it.
+    if (combinedCache != null) {
       combinedCache.release();
     }
 
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
index a7445c0c35..824f7e9dc2 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
@@ -266,7 +266,6 @@ public final class RemoteModule extends BlazeModule {
             digestUtil);
     actionContextProvider =
         RemoteActionContextProvider.createForRemoteCaching(
-            executorService,
             env,
             combinedCache,
             /* retryScheduler= */ null,
@@ -711,7 +710,6 @@ public final class RemoteModule extends BlazeModule {
               digestUtil);
       actionContextProvider =
           RemoteActionContextProvider.createForRemoteExecution(
-              executorService,
               env,
               remoteCache,
               remoteExecutor,
@@ -745,7 +743,6 @@ public final class RemoteModule extends BlazeModule {
               digestUtil);
       actionContextProvider =
           RemoteActionContextProvider.createForRemoteCaching(
-              executorService,
               env,
               combinedCache,
               retryScheduler,
diff --git a/src/main/java/com/google/devtools/build/lib/remote/UploadManifest.java b/src/main/java/com/google/devtools/build/lib/remote/UploadManifest.java
index fa3ea118dd..851a11f783 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/UploadManifest.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/UploadManifest.java
@@ -15,12 +15,9 @@ package com.google.devtools.build.lib.remote;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Throwables.throwIfInstanceOf;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-import static com.google.devtools.build.lib.remote.util.RxFutures.toCompletable;
-import static com.google.devtools.build.lib.remote.util.RxFutures.toSingle;
-import static com.google.devtools.build.lib.remote.util.RxUtils.mergeBulkTransfer;
-import static com.google.devtools.build.lib.remote.util.RxUtils.toTransferResult;
+import static com.google.devtools.build.lib.remote.util.Utils.getFromFuture;
+import static com.google.devtools.build.lib.remote.util.Utils.waitForBulkTransfer;
 import static com.google.devtools.build.lib.util.StringEncoding.internalToUnicode;
 import static java.util.Comparator.comparing;
 import static java.util.Comparator.naturalOrder;
@@ -40,11 +37,12 @@ import build.bazel.remote.execution.v2.Tree;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
+import com.google.common.collect.Sets;
 import com.google.common.collect.SortedSetMultimap;
 import com.google.common.collect.TreeMultimap;
+import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.devtools.build.lib.actions.ActionExecutionMetadata;
 import com.google.devtools.build.lib.actions.ActionUploadFinishedEvent;
@@ -62,7 +60,6 @@ import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient.ActionKey;
 import com.google.devtools.build.lib.remote.common.RemotePathResolver;
 import com.google.devtools.build.lib.remote.util.DigestUtil;
-import com.google.devtools.build.lib.remote.util.RxUtils;
 import com.google.devtools.build.lib.server.FailureDetails.FailureDetail;
 import com.google.devtools.build.lib.server.FailureDetails.RemoteExecution;
 import com.google.devtools.build.lib.server.FailureDetails.RemoteExecution.Code;
@@ -73,12 +70,10 @@ import com.google.devtools.build.lib.vfs.FileSymlinkLoopException;
 import com.google.devtools.build.lib.vfs.Path;
 import com.google.devtools.build.lib.vfs.PathFragment;
 import com.google.devtools.build.lib.vfs.Symlinks;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.CodedOutputStream;
 import com.google.protobuf.Timestamp;
-import io.reactivex.rxjava3.core.Completable;
-import io.reactivex.rxjava3.core.Flowable;
-import io.reactivex.rxjava3.core.Single;
 import java.io.IOException;
 import java.time.Instant;
 import java.util.ArrayList;
@@ -86,13 +81,11 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ForkJoinPool;
-import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 
 /** UploadManifest adds output metadata to a {@link ActionResult}. */
@@ -589,136 +582,85 @@ public class UploadManifest {
     return result.build();
   }
 
-  /** Uploads outputs and action result (if exit code is 0) to remote cache. */
+  /** Uploads outputs and action result (if exit code is 0) to the remote and/or disk cache. */
   public ActionResult upload(
       RemoteActionExecutionContext context,
       CombinedCache combinedCache,
       ExtendedEventHandler reporter)
       throws IOException, InterruptedException, ExecException {
-    try {
-      return uploadAsync(context, combinedCache, reporter).blockingGet();
-    } catch (RuntimeException e) {
-      Throwable cause = e.getCause();
-      if (cause != null) {
-        throwIfInstanceOf(cause, InterruptedException.class);
-        throwIfInstanceOf(cause, IOException.class);
-        throwIfInstanceOf(cause, ExecException.class);
+    ActionExecutionMetadata action = context.getSpawnOwner();
+    var allDigests = Sets.union(digestToBlobs.keySet(), digestToFile.keySet()).immutableCopy();
+    ImmutableSet<Digest> missingDigests;
+    try (var s = profiler.profile(ProfilerTask.INFO, "findMissingDigests")) {
+      missingDigests = getFromFuture(combinedCache.findMissingDigests(context, allDigests));
+    }
+
+    try (var s =
+        profiler.profile(
+            ProfilerTask.UPLOAD_TIME,
+            () -> "upload %d missing blobs".formatted(missingDigests.size()))) {
+      var uploadFutures = new ArrayList<ListenableFuture<Void>>(missingDigests.size());
+      for (var digest : missingDigests) {
+        uploadFutures.add(
+            decorateUploadFuture(
+                uploadSingleDigest(context, combinedCache, digest),
+                reporter,
+                action,
+                Store.CAS,
+                digest));
       }
-      throw e;
+      waitForBulkTransfer(uploadFutures);
     }
+
+    // The action result must be uploaded after the Action and Command protos per the REAPI
+    // protocol. We choose to upload it after all other blobs since this has historically been the
+    // case and action results may fail to validate server-side if they are accessed before all
+    // blobs they refer to are present.
+    var actionResult = result.build();
+    if (actionResult.getExitCode() == 0 && actionKey != null) {
+      try (var s = profiler.profile(ProfilerTask.UPLOAD_TIME, "upload action result")) {
+        getFromFuture(
+            decorateUploadFuture(
+                combinedCache.uploadActionResult(context, actionKey, actionResult),
+                reporter,
+                action,
+                Store.AC,
+                actionKey.digest()));
+      }
+    }
+    return actionResult;
   }
 
-  private Completable upload(
+  private ListenableFuture<Void> uploadSingleDigest(
       RemoteActionExecutionContext context, CombinedCache combinedCache, Digest digest) {
     Path file = digestToFile.get(digest);
     if (file != null) {
-      return toCompletable(() -> combinedCache.uploadFile(context, digest, file), directExecutor());
+      return combinedCache.uploadFile(context, digest, file);
     }
 
     ByteString blob = digestToBlobs.get(digest);
     if (blob == null) {
-      String message = "FindMissingBlobs call returned an unknown digest: " + digest;
-      return Completable.error(new IOException(message));
+      return Futures.immediateFailedFuture(
+          new IOException("FindMissingBlobs call returned an unknown digest: " + digest));
     }
 
-    return toCompletable(() -> combinedCache.uploadBlob(context, digest, blob), directExecutor());
-  }
-
-  private static void reportUploadStarted(
-      ExtendedEventHandler reporter,
-      @Nullable ActionExecutionMetadata action,
-      Store store,
-      Iterable<Digest> digests) {
-    if (action != null) {
-      for (Digest digest : digests) {
-        reporter.post(ActionUploadStartedEvent.create(action, store, digest));
-      }
-    }
+    return combinedCache.uploadBlob(context, digest, blob);
   }
 
-  private static void reportUploadFinished(
+  @CanIgnoreReturnValue
+  private static <T> ListenableFuture<T> decorateUploadFuture(
+      ListenableFuture<T> future,
       ExtendedEventHandler reporter,
       @Nullable ActionExecutionMetadata action,
       Store store,
-      Iterable<Digest> digests) {
-    if (action != null) {
-      for (Digest digest : digests) {
-        reporter.post(ActionUploadFinishedEvent.create(action, store, digest));
-      }
+      Digest digest) {
+    if (action == null) {
+      return future;
     }
-  }
-
-  /**
-   * Returns a {@link Single} which upon subscription will upload outputs and action result (if exit
-   * code is 0) to remote cache.
-   */
-  public Single<ActionResult> uploadAsync(
-      RemoteActionExecutionContext context,
-      CombinedCache combinedCache,
-      ExtendedEventHandler reporter) {
-    Collection<Digest> digests = new ArrayList<>();
-    digests.addAll(digestToFile.keySet());
-    digests.addAll(digestToBlobs.keySet());
-
-    ActionExecutionMetadata action = context.getSpawnOwner();
-
-    Flowable<RxUtils.TransferResult> bulkTransfers =
-        toSingle(() -> findMissingDigests(context, combinedCache, digests), directExecutor())
-            .doOnSubscribe(d -> reportUploadStarted(reporter, action, Store.CAS, digests))
-            .doOnError(error -> reportUploadFinished(reporter, action, Store.CAS, digests))
-            .doOnDispose(() -> reportUploadFinished(reporter, action, Store.CAS, digests))
-            .doOnSuccess(
-                missingDigests -> {
-                  List<Digest> existedDigests =
-                      digests.stream()
-                          .filter(digest -> !missingDigests.contains(digest))
-                          .collect(Collectors.toList());
-                  reportUploadFinished(reporter, action, Store.CAS, existedDigests);
-                })
-            .flatMapPublisher(Flowable::fromIterable)
-            .flatMapSingle(
-                digest ->
-                    toTransferResult(upload(context, combinedCache, digest))
-                        .doFinally(
-                            () ->
-                                reportUploadFinished(
-                                    reporter, action, Store.CAS, ImmutableList.of(digest))));
-    Completable uploadOutputs = mergeBulkTransfer(bulkTransfers);
-
-    ActionResult actionResult = result.build();
-    Completable uploadActionResult = Completable.complete();
-    if (actionResult.getExitCode() == 0 && actionKey != null) {
-      uploadActionResult =
-          toCompletable(
-                  () -> combinedCache.uploadActionResult(context, actionKey, actionResult),
-                  directExecutor())
-              .doOnSubscribe(
-                  d ->
-                      reportUploadStarted(
-                          reporter, action, Store.AC, ImmutableList.of(actionKey.digest())))
-              .doFinally(
-                  () ->
-                      reportUploadFinished(
-                          reporter, action, Store.AC, ImmutableList.of(actionKey.digest())));
-    }
-
-    return Completable.concatArray(uploadOutputs, uploadActionResult).toSingleDefault(actionResult);
-  }
-
-  private ListenableFuture<ImmutableSet<Digest>> findMissingDigests(
-      RemoteActionExecutionContext context,
-      CombinedCache combinedCache,
-      Collection<Digest> digests) {
-    long startTime = Profiler.nanoTimeMaybe();
-
-    var future = combinedCache.findMissingDigests(context, digests);
-
-    if (profiler.isActive()) {
-      future.addListener(
-          () -> profiler.logSimpleTask(startTime, ProfilerTask.INFO, "findMissingDigests"),
-          directExecutor());
-    }
-
+    reporter.post(ActionUploadStartedEvent.create(action, store, digest));
+    future.addListener(
+        () -> reporter.post(ActionUploadFinishedEvent.create(action, store, digest)),
+        directExecutor());
     return future;
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/remote/util/Utils.java b/src/main/java/com/google/devtools/build/lib/remote/util/Utils.java
index c44171a739..f7aa30a332 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/util/Utils.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/util/Utils.java
@@ -579,8 +579,12 @@ public final class Utils {
         && !executionInfo.containsKey(ExecutionRequirements.NO_REMOTE_CACHE_UPLOAD);
   }
 
-  public static void waitForBulkTransfer(
-      Iterable<? extends ListenableFuture<?>> transfers, boolean cancelRemainingOnInterrupt)
+  /**
+   * Waits for all transfers to finish.
+   *
+   * <p>If interrupted, all remaining transfers are canceled.
+   */
+  public static void waitForBulkTransfer(Iterable<? extends ListenableFuture<?>> transfers)
       throws BulkTransferException, InterruptedException {
     BulkTransferException bulkTransferException = null;
     InterruptedException interruptedException = null;
@@ -589,7 +593,7 @@ public final class Utils {
       try {
         if (interruptedException == null) {
           // Wait for all transfers to finish.
-          getFromFuture(transfer, cancelRemainingOnInterrupt);
+          getFromFuture(transfer, /* cancelOnInterrupt= */ true);
         } else {
           transfer.cancel(true);
         }
@@ -601,10 +605,6 @@ public final class Utils {
       } catch (InterruptedException e) {
         interrupted = Thread.interrupted() || interrupted;
         interruptedException = e;
-        if (!cancelRemainingOnInterrupt) {
-          // leave the rest of the transfers alone
-          break;
-        }
       }
     }
     if (interrupted) {
diff --git a/src/test/java/com/google/devtools/build/lib/remote/BUILD b/src/test/java/com/google/devtools/build/lib/remote/BUILD
index 5e7257b0f3..0a9b4d8316 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/BUILD
+++ b/src/test/java/com/google/devtools/build/lib/remote/BUILD
@@ -263,6 +263,7 @@ java_test(
 java_test(
     name = "DiskCacheIntegrationTest",
     srcs = ["DiskCacheIntegrationTest.java"],
+    jvm_flags = ["-Djava.lang.Thread.allowVirtualThreads=true"],
     tags = ["requires-network"],
     runtime_deps = [
         "//third_party/grpc-java:grpc-jar",
diff --git a/src/test/java/com/google/devtools/build/lib/remote/ByteStreamUploaderTest.java b/src/test/java/com/google/devtools/build/lib/remote/ByteStreamUploaderTest.java
index 1b62fb64f7..1a921b05c8 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/ByteStreamUploaderTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/ByteStreamUploaderTest.java
@@ -1713,7 +1713,7 @@ public class ByteStreamUploaderTest {
               context, chunkerEntry.getKey(), chunkerEntry.getValue()));
     }
 
-    waitForBulkTransfer(uploads, /* cancelRemainingOnInterrupt= */ true);
+    waitForBulkTransfer(uploads);
   }
 
   private static class NoopStreamObserver implements StreamObserver<WriteRequest> {
diff --git a/src/test/java/com/google/devtools/build/lib/remote/CombinedCacheTest.java b/src/test/java/com/google/devtools/build/lib/remote/CombinedCacheTest.java
index c9712c3d47..c98aa4d723 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/CombinedCacheTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/CombinedCacheTest.java
@@ -217,8 +217,7 @@ public class CombinedCacheTest {
         combinedCache.downloadOutErr(
             remoteActionExecutionContext,
             result.build(),
-            new FileOutErr(execRoot.getRelative("stdout"), execRoot.getRelative("stderr"))),
-        true);
+            new FileOutErr(execRoot.getRelative("stdout"), execRoot.getRelative("stderr"))));
 
     assertThat(combinedCache.getNumSuccessfulDownloads()).isEqualTo(0);
     assertThat(combinedCache.getNumFailedDownloads()).isEqualTo(0);
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
index 1e1530bbe5..74970ae268 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
@@ -3003,7 +3003,6 @@ public class RemoteExecutionServiceTest {
 
   private RemoteExecutionService newRemoteExecutionService(RemoteOptions remoteOptions) {
     return new RemoteExecutionService(
-        directExecutor(),
         reporter,
         /* verboseFailures= */ true,
         execRoot,
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
index 85bb9f08ad..837c9f8df8 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
@@ -17,7 +17,6 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
@@ -302,7 +301,6 @@ public class RemoteSpawnCacheTest {
     RemoteExecutionService service =
         spy(
             new RemoteExecutionService(
-                directExecutor(),
                 reporter,
                 /* verboseFailures= */ true,
                 execRoot,
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
index e399f100f7..2770fb4507 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
@@ -15,7 +15,6 @@ package com.google.devtools.build.lib.remote;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
@@ -1266,7 +1265,6 @@ public class RemoteSpawnRunnerTest {
     ExecutionOptions executionOptions = Options.parse(ExecutionOptions.class, flag).getOptions();
     RemoteExecutionService remoteExecutionService =
         new RemoteExecutionService(
-            directExecutor(),
             reporter,
             /* verboseFailures= */ true,
             execRoot,
@@ -1803,7 +1801,6 @@ public class RemoteSpawnRunnerTest {
     RemoteExecutionService service =
         spy(
             new RemoteExecutionService(
-                directExecutor(),
                 reporter,
                 /* verboseFailures= */ true,
                 execRoot,
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
index 6174c8d1e6..1c08c48a74 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
@@ -14,7 +14,6 @@
 package com.google.devtools.build.lib.remote;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static com.google.devtools.build.lib.remote.GrpcCacheClient.getResourceName;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -339,7 +338,6 @@ public class RemoteSpawnRunnerWithGrpcRemoteExecutorTest {
             cacheProtocol, /* diskCacheClient= */ null, /* symlinkTemplate= */ null, DIGEST_UTIL);
     RemoteExecutionService remoteExecutionService =
         new RemoteExecutionService(
-            directExecutor(),
             reporter,
             /* verboseFailures= */ true,
             execRoot,
