diff --git a/src/main/java/com/google/devtools/build/lib/analysis/CommonPrerequisiteValidator.java b/src/main/java/com/google/devtools/build/lib/analysis/CommonPrerequisiteValidator.java
index d1c6e836f4..16cff96578 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/CommonPrerequisiteValidator.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/CommonPrerequisiteValidator.java
@@ -228,8 +228,7 @@ public abstract class CommonPrerequisiteValidator implements PrerequisiteValidat
     // same-logical-package as this location, a property that doesn't apply to targets created in
     // symbolic macros. Calling isSameLogicalPackage() takes care of both of these checks. Note that
     // we don't need to worry about the package's default_visibility at this stage because
-    // it is already accounted for at loading time by the target's getVisibility() accessor (or
-    // earlier).
+    // it is already accounted for at loading time by the target's getVisibility() accessor.
     //
     // TODO: #19922 - The same-logical-package logic should also be applied in the loading phase, to
     // the propagated visibility attribute inside symbolic macros, so that it applies to targets
diff --git a/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java b/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
index 96431febb4..62cd0e2525 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/ConfiguredTargetFactory.java
@@ -106,24 +106,22 @@ public final class ConfiguredTargetFactory {
   }
 
   /**
-   * Returns the visibility of the given target. Errors during package group resolution are reported
-   * to the {@code AnalysisEnvironment}.
+   * Returns the visibility of the given target, as represented by {@link
+   * VisibilityProvider#getVisibility}.
+   *
+   * <p>This is constructed by starting with the value obtained from either {@link
+   * Target#getVisibility} or {@link Target#getActualVisibility}, and recursively expanding package
+   * groups. Errors during package group resolution are reported to the {@code AnalysisEnvironment}.
    */
   private static NestedSet<PackageGroupContents> convertVisibility(
       OrderedSetMultimap<DependencyKind, ConfiguredTargetAndData> prerequisiteMap,
       EventHandler reporter,
       Target target) {
-    // Targets declared inside symbolic macros already have a RuleVisibility that includes the
-    // target's declaration location. Targets that are *not* declared inside symbolic macros do not
-    // necessarily have their declaration location (i.e. the package they live in) in their
-    // RuleVisibility, but CommonPrerequisiteValidator takes that into account. See also javadoc of
-    // Rule#getRuleVisibility.
-    //
-    // TODO: #19922 - Ideally we'd just put the location into the visibility attribute even for
-    // targets not declared in symbolic macros. But this has a wide user-facing blast radius since
-    // it changes all existing targets' visibilities (when inspected via existing_rules(),
-    // `bazel query`, etc.).
-    RuleVisibility ruleVisibility = target.getVisibility();
+    // Optimization: don't use actual visibility if not in a symbolic macro. See javadoc on
+    // VisibilityProvider#getVisibility. Since the actual visibility only ever adds a ...:__pkg__
+    // item, not a package group, it doesn't need to be handled here.
+    RuleVisibility ruleVisibility =
+        target.isCreatedInSymbolicMacro() ? target.getActualVisibility() : target.getVisibility();
     if (ruleVisibility.equals(RuleVisibility.PUBLIC)) {
       return VisibilityProvider.PUBLIC_VISIBILITY;
     }
diff --git a/src/main/java/com/google/devtools/build/lib/analysis/VisibilityProvider.java b/src/main/java/com/google/devtools/build/lib/analysis/VisibilityProvider.java
index f182a15c33..648b20e7e3 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/VisibilityProvider.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/VisibilityProvider.java
@@ -24,28 +24,14 @@ import com.google.devtools.build.lib.packages.PackageSpecification.PackageGroupC
 /**
  * Provider class for configured targets that have a visibility.
  *
- * <p>The visibility provider is computed in {@link ConfiguredTargetFactory#convertVisibility}.
- * Essentially, it starts with the target's {@link RuleVisibility} from the loading phase, resolves
- * the references to {@code package_group}s (which may be aggregated through multiple {@code
- * includes}), and merges all the visibility grants into a {@code NestedSet} of {@link
- * PackageGroupContents}. Thus, the visibility provider contains transitive information, which gets
- * flattened at the time of visibility checking.
+ * <p>This is the analysis-time equivalent of the visibility attribute, with package groups
+ * recursively expanded. This provider also tracks a bit indicating whether the target was created
+ * in a symbolic macro, which is not necessarily otherwise available in the prerequisite object at
+ * analysis time.
  *
- * <p>This provider also needs to track a bit indicating whether the target was declared within one
- * or more symbolic macros. This is used by {@link CommonPrerequisiteValidator} to help implement
- * the visibility check in two ways:
- *
- * <ul>
- *   <li>First, for targets not in symbolic macros, the declaration location (i.e. package) of the
- *       target is not concatenated into its visibility attribute (see {@link
- *       Rule#getRuleVisibility}), and {@code CommonPrerequisiteValidator} needs to know to account
- *       for this when doing the visibility check.
- *   <li>Second, there's the {@link CommonPrerequisiteValidator#isSameLogicalPackage} hook, which
- *       powers the hack that targets in {@code //javatests/foo} are allowed to see targets in
- *       {@code //java/foo}. (This feature is only active within Google and disabled for OSS Bazel.)
- *       The semantics are that targets created in symbolic macros are never automatically visible
- *       to {@code //javatests/foo} packages, regardless of the package or declaration location.
- * </ul>
+ * <p>The contents of this provider are determined in {@link
+ * ConfiguredTargetFactory#convertVisibility}. It is consumed by the visibility check in {@link
+ * CommonPrerequisiteValidator#isVisibleToLocation}.
  */
 public interface VisibilityProvider extends TransitiveInfoProvider {
 
@@ -58,20 +44,33 @@ public interface VisibilityProvider extends TransitiveInfoProvider {
       NestedSetBuilder.emptySet(Order.STABLE_ORDER);
 
   /**
-   * Returns the visibility specification, as determined by resolving the entries in the {@code
-   * visibility} attribute.
+   * Returns the target's visibility, as determined from recursively resolving and expanding the
+   * package groups it references.
    *
-   * <p>For targets in symbolic macros, this will include the target's declaration location. For
-   * targets created directly by the package (including in legacy macros that are not in symbolic
-   * macros), it may not include the target's package, even though it is technically visible to it.
+   * <p>Morally, this should represent the expansion of the target's {@link
+   * Target#getActualVisibility "actual" visibility}. However, as an optimization, for targets that
+   * are *not* declared within a symbolic macro, we substitute the {@link Target#getVisibility "raw"
+   * or "default" visibility} for the actual visibility. The optimized version omits the package
+   * where the target was instantiated, avoiding extra allocations in the common case of a target
+   * that has public or private visibility. The caller must compensate for this optimization by
+   * allowing visibility to the target's own package if the target was not created in a macro.
    */
   NestedSet<PackageGroupContents> getVisibility();
 
   /**
    * Returns whether this target was instantiated in one or more symbolic macros.
    *
-   * <p>(This information can be determined from the {@link Rule} object, but that's not necessarily
-   * available from a prerequisite object during analysis.)
+   * <p>This information can be determined from the {@link Rule} object, but that's not necessarily
+   * available from a prerequisite object at analysis time.
+   *
+   * <p>This bit is used by the {@link CommonPrerequisiteValidator#isSameLogicalPackage} hook, which
+   * powers the hack that targets in {@code //javatests/foo} are allowed to see targets in {@code
+   * //java/foo}. (This feature is only active within Google and disabled for OSS Bazel.) The
+   * semantics are that targets created in symbolic macros are never automatically visible to {@code
+   * //javatests/foo} packages, regardless of the package or declaration location.
+   *
+   * <p>This bit is also used to work around the optimization mentioned above for {@link
+   * #getVisibility}.
    */
   boolean isCreatedInSymbolicMacro();
 }
diff --git a/src/main/java/com/google/devtools/build/lib/packages/EnvironmentGroup.java b/src/main/java/com/google/devtools/build/lib/packages/EnvironmentGroup.java
index bfe03ba124..39a1b32730 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/EnvironmentGroup.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/EnvironmentGroup.java
@@ -33,6 +33,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nullable;
 import net.starlark.java.syntax.Location;
 
 /**
@@ -295,9 +296,18 @@ public class EnvironmentGroup implements Target {
     return Collections.emptySet();
   }
 
+  @Override
+  @Nullable
+  public RuleVisibility getRawVisibility() {
+    return null;
+  }
+
   @Override
   public RuleVisibility getVisibility() {
-    return RuleVisibility.PRIVATE; // No rule should be referencing an environment_group.
+    // No rule should be referencing an environment_group.
+    // (We override getRawVisibility() separately so as to not display this value during
+    // introspection.)
+    return RuleVisibility.PRIVATE;
   }
 
   @Override
diff --git a/src/main/java/com/google/devtools/build/lib/packages/InputFile.java b/src/main/java/com/google/devtools/build/lib/packages/InputFile.java
index 1d2228d266..57ae59b336 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/InputFile.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/InputFile.java
@@ -64,8 +64,9 @@ public class InputFile extends FileTarget {
   }
 
   @Override
-  public RuleVisibility getVisibility() {
-    return pkg.getPackageArgs().defaultVisibility();
+  @Nullable
+  public RuleVisibility getRawVisibility() {
+    return null;
   }
 
   @Override
diff --git a/src/main/java/com/google/devtools/build/lib/packages/MacroClass.java b/src/main/java/com/google/devtools/build/lib/packages/MacroClass.java
index ce12116291..3b965df66d 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/MacroClass.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/MacroClass.java
@@ -230,6 +230,9 @@ public final class MacroClass {
     }
 
     // Special processing of the "visibility" attribute.
+    // TODO(brandjon): When we add introspection of attributes of symbolic macros, we'll want to
+    // distinguish between the different types of visibility a la Target#getRawVisibility /
+    // #getVisibility / #getActualVisibility.
     @Nullable MacroFrame parentMacroFrame = pkgBuilder.getCurrentMacroFrame();
     @Nullable Object rawVisibility = attrValues.get("visibility");
     RuleVisibility parsedVisibility;
@@ -254,8 +257,8 @@ public final class MacroClass {
         parentMacroFrame == null
             ? pkgBuilder.getPackageIdentifier()
             : parentMacroFrame.macroInstance.getDefinitionPackage();
-    parsedVisibility = parsedVisibility.concatWithPackage(instantiatingLoc);
-    attrValues.put("visibility", parsedVisibility.getDeclaredLabels());
+    RuleVisibility actualVisibility = parsedVisibility.concatWithPackage(instantiatingLoc);
+    attrValues.put("visibility", actualVisibility.getDeclaredLabels());
 
     // Populate defaults for the rest, and validate that no mandatory attr was missed.
     for (Attribute attr : attributes.values()) {
diff --git a/src/main/java/com/google/devtools/build/lib/packages/MacroInstance.java b/src/main/java/com/google/devtools/build/lib/packages/MacroInstance.java
index 48e0081f1e..bab90236f9 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/MacroInstance.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/MacroInstance.java
@@ -156,7 +156,7 @@ public final class MacroInstance {
   }
 
   /**
-   * Returns the visibility of this macro instance.
+   * Returns the visibility of this macro instance, analogous to {@link Target#getActualVisibility}.
    *
    * <p>This value will be observed as the {@code visibility} parameter of the implementation
    * function. It is not necessarily the same as the {@code visibility} value passed in when
@@ -165,7 +165,7 @@ public final class MacroInstance {
    *
    * <p>It can be assumed that the returned list satisfies {@link RuleVisibility#validate}.
    */
-  public ImmutableList<Label> getVisibility() {
+  public ImmutableList<Label> getActualVisibility() {
     @SuppressWarnings("unchecked")
     List<Label> visibility = (List<Label>) Preconditions.checkNotNull(attrValues.get("visibility"));
     return ImmutableList.copyOf(visibility);
diff --git a/src/main/java/com/google/devtools/build/lib/packages/OutputFile.java b/src/main/java/com/google/devtools/build/lib/packages/OutputFile.java
index 1bf9e1363f..511ea67890 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/OutputFile.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/OutputFile.java
@@ -16,6 +16,7 @@ package com.google.devtools.build.lib.packages;
 
 import com.google.devtools.build.lib.cmdline.Label;
 import java.util.List;
+import javax.annotation.Nullable;
 import net.starlark.java.syntax.Location;
 
 /** A generated file that is the output of a rule. */
@@ -52,6 +53,17 @@ public abstract class OutputFile extends FileTarget {
     this.outputKey = outputKey;
   }
 
+  @Override
+  @Nullable
+  public final RuleVisibility getRawVisibility() {
+    return generatingRule.getRawVisibility();
+  }
+
+  @Override
+  public final RuleVisibility getDefaultVisibility() {
+    return generatingRule.getDefaultVisibility();
+  }
+
   @Override
   public final RuleVisibility getVisibility() {
     return generatingRule.getVisibility();
diff --git a/src/main/java/com/google/devtools/build/lib/packages/PackageGroup.java b/src/main/java/com/google/devtools/build/lib/packages/PackageGroup.java
index 9f6d8357a8..f41cc56d4f 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/PackageGroup.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/PackageGroup.java
@@ -26,6 +26,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
 import net.starlark.java.syntax.Location;
 
 /**
@@ -142,11 +143,19 @@ public class PackageGroup implements Target {
     return targetKind() + " " + getLabel();
   }
 
+  @Override
+  @Nullable
+  public RuleVisibility getRawVisibility() {
+    return null;
+  }
+
   @Override
   public RuleVisibility getVisibility() {
     // Package groups are always public to avoid a PackageGroupConfiguredTarget
     // needing itself for the visibility check. It may work, but I did not
     // think it over completely.
+    // (We override getRawVisibility() separately so as to not display this value during
+    // introspection.)
     return RuleVisibility.PUBLIC;
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/packages/Rule.java b/src/main/java/com/google/devtools/build/lib/packages/Rule.java
index c247b3eba5..12f424bfe8 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/Rule.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/Rule.java
@@ -1067,62 +1067,8 @@ public class Rule implements Target, DependencyFilter.AttributeInfoProvider {
   }
 
   /**
-   * Returns the effective visibility of this rule target, as best as can be determined at loading
-   * time.
-   *
-   * <p>Conceptually, this is taken from the target's {@code visibility} attribute, with a few
-   * caveats described below. The actual visibility check is based on analysis-time information that
-   * traverses possibly multiple levels of {@code package_group} definitions; see {@link
-   * VisibilityProvider}.
-   *
-   * <p>Under the Macro-Aware Visibility model, targets are always visible to the location of the
-   * code of the symbolic macro in which they are declared, or the target's package if they are not
-   * in a symbolic macro. For targets in symbolic macros, we realize this by automatically appending
-   * this location to {@code visibility} when the target is created (see {@link
-   * RuleFactory#createRule}).
-   *
-   * <p>However, for targets created by the BUILD file and legacy macros (i.e. outside any symbolic
-   * macro), we do not append anything, because that would be a backwards incompatible change (as
-   * well as a minor memory regression). So instead, when checking visibility at analysis time, we
-   * simply implicitly allow the target's own package anytime the target was not created in a
-   * symbolic macro.
-   *
-   * <p>The package's {@code default_visibility} is used as the starting point for targets that are
-   * not created in any symbolic macro and that do not specify an explicit {@code visibility}.
+   * Implementation of {@link #getRawVisibility} that avoids constructing a {@code RuleVisibility}.
    */
-  // TODO: #19922 - Technically, I think the fact that we munge visibility for targets in symbolic
-  // macros means that they appear as though they were explicitly specified
-  // (AttributeMap#isAttributeValueExplicitlySpecified). I doubt this matters in practice, as most
-  // logic should not be relying on that bit.
-  @Override
-  public RuleVisibility getVisibility() {
-    List<Label> rawLabels = getRawVisibilityLabels();
-    return rawLabels == null
-        ? getDefaultVisibility()
-        // The attribute value was already validated when it was set, so call the unchecked method.
-        : RuleVisibility.parseUnchecked(rawLabels);
-  }
-
-  @Override
-  public Iterable<Label> getVisibilityDependencyLabels() {
-    List<Label> rawLabels = getRawVisibilityLabels();
-    if (rawLabels == null) {
-      return getDefaultVisibility().getDependencyLabels();
-    }
-    RuleVisibility constantVisibility = RuleVisibility.parseIfConstant(rawLabels);
-    if (constantVisibility != null) {
-      return constantVisibility.getDependencyLabels();
-    }
-    // Filter out labels like :__pkg__ and :__subpackages__.
-    return Iterables.filter(rawLabels, label -> PackageSpecification.fromLabel(label) == null);
-  }
-
-  @Override
-  public List<Label> getVisibilityDeclaredLabels() {
-    List<Label> rawLabels = getRawVisibilityLabels();
-    return rawLabels == null ? getDefaultVisibility().getDeclaredLabels() : rawLabels;
-  }
-
   @Nullable
   @SuppressWarnings("unchecked")
   private List<Label> getRawVisibilityLabels() {
@@ -1133,14 +1079,20 @@ public class Rule implements Target, DependencyFilter.AttributeInfoProvider {
     return (List<Label>) getAttrIfStored(visibilityIndex);
   }
 
-  private RuleVisibility getDefaultVisibility() {
-    // TODO: #19922 - This logic is only reached from getVisibility() when the visibility attribute
-    // is not set on this target. But since we munge the visibility attribute to be non-empty for
-    // all targets created in symbolic macros, this logic is bypassed anytime the target is in a
-    // symbolic macro. The likely fix is to factor this out into something that can be consulted by
-    // RuleFactory#getModifiedVisibility in place of accessing the package's default_visibility
-    // (which isn't supposed to be consulted inside symbolic macros anyway).
+  @Override
+  @Nullable
+  public RuleVisibility getRawVisibility() {
+    List<Label> rawLabels = getRawVisibilityLabels();
+    // The attribute value was already validated when it was set, so call the unchecked method.
+    return rawLabels != null ? RuleVisibility.parseUnchecked(rawLabels) : null;
+  }
 
+  /**
+   * Retrieves the package's default visibility, or for certain rule classes, injects a different
+   * default visibility.
+   */
+  @Override
+  public RuleVisibility getDefaultVisibility() {
     if (ruleClass.getName().equals("bind")) {
       return RuleVisibility.PUBLIC; // bind rules are always public.
     }
@@ -1152,7 +1104,28 @@ public class Rule implements Target, DependencyFilter.AttributeInfoProvider {
         && pkg.getConfigSettingVisibilityPolicy() == ConfigSettingVisibilityPolicy.DEFAULT_PUBLIC) {
       return RuleVisibility.PUBLIC; // Default: //visibility:public.
     }
-    return pkg.getPackageArgs().defaultVisibility();
+
+    return Target.super.getDefaultVisibility();
+  }
+
+  @Override
+  public Iterable<Label> getVisibilityDependencyLabels() {
+    List<Label> rawLabels = getRawVisibilityLabels();
+    if (rawLabels == null) {
+      return getDefaultVisibility().getDependencyLabels();
+    }
+    RuleVisibility constantVisibility = RuleVisibility.parseIfConstant(rawLabels);
+    if (constantVisibility != null) {
+      return constantVisibility.getDependencyLabels();
+    }
+    // Filter out labels like :__pkg__ and :__subpackages__.
+    return Iterables.filter(rawLabels, label -> PackageSpecification.fromLabel(label) == null);
+  }
+
+  @Override
+  public List<Label> getVisibilityDeclaredLabels() {
+    List<Label> rawLabels = getRawVisibilityLabels();
+    return rawLabels != null ? rawLabels : getDefaultVisibility().getDeclaredLabels();
   }
 
   @Override
diff --git a/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java b/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
index a989416ecd..02018f0dd1 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/RuleFactory.java
@@ -24,7 +24,6 @@ import com.google.devtools.build.lib.packages.RuleClass.Builder.RuleClassType;
 import com.google.devtools.build.lib.packages.TargetRecorder.NameConflictException;
 import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
@@ -85,22 +84,15 @@ public class RuleFactory {
           ruleClass + " cannot be in the WORKSPACE file " + "(used by " + label + ")");
     }
 
-    // Add the generator_name attribute, and possibly append the declaration location to the
-    // visibility attribute.
+    // Add the generator_name attribute.
     BuildLangTypedAttributeValuesMap processedAttributes;
     @Nullable String generatorName = getGeneratorName(pkgBuilder, attributeValues, callstack);
-    @Nullable List<Label> modifiedVisibility = getModifiedVisibility(pkgBuilder, attributeValues);
     // Don't bother copying anything if nothing changed.
-    if (generatorName != null || modifiedVisibility != null) {
+    if (generatorName != null) {
       ImmutableMap.Builder<String, Object> builder =
-          ImmutableMap.builderWithExpectedSize(attributeValues.attributeValues.size() + 2);
+          ImmutableMap.builderWithExpectedSize(attributeValues.attributeValues.size() + 1);
       builder.putAll(attributeValues.attributeValues);
-      if (generatorName != null) {
-        builder.put("generator_name", generatorName);
-      }
-      if (modifiedVisibility != null) {
-        builder.put("visibility", modifiedVisibility);
-      }
+      builder.put("generator_name", generatorName);
       processedAttributes = new BuildLangTypedAttributeValuesMap(builder.buildKeepingLast());
     } else {
       processedAttributes = attributeValues;
@@ -274,46 +266,6 @@ public class RuleFactory {
     return generatorName;
   }
 
-  /**
-   * Given the attribute values of the rule being instantiated, computes and returns the new value
-   * for its visibility attribute, or null if no change is needed.
-   *
-   * <p>For targets created inside one or more symbolic macros, the new visibility value is whatever
-   * the original visibility attribute was (possibly the package's default visibility), unioned with
-   * the package where the innermost currently executing symbolic macro was exported.
-   *
-   * <p>For targets not created inside one or more symbolic macros, no change is made to the
-   * visibility attribute. The visibility check will account for this by permitting access to the
-   * target from locations in the same package as the target.
-   */
-  @Nullable
-  private static List<Label> getModifiedVisibility(
-      Package.Builder pkgBuilder, BuildLangTypedAttributeValuesMap args) {
-    MacroInstance currentMacro = pkgBuilder.currentMacro();
-    if (currentMacro == null) {
-      return null;
-    }
-
-    RuleVisibility visibility = null;
-    Object uncheckedVisibilityAttr = args.getAttributeValue("visibility");
-    if (uncheckedVisibilityAttr == null) {
-      visibility = RuleVisibility.PRIVATE;
-    } else {
-      try {
-        List<Label> visibilityAttr =
-            BuildType.LABEL_LIST.convert(
-                uncheckedVisibilityAttr, "visibility attribute", pkgBuilder.getLabelConverter());
-        visibility = RuleVisibility.parse(visibilityAttr);
-      } catch (EvalException ex) {
-        // Can't modify the visibility attribute because it's invalid. Let it be caught in
-        // RuleClass#populateDefinedRuleAttributeValues.
-        return null;
-      }
-    }
-
-    return visibility.concatWithPackage(currentMacro.getDefinitionPackage()).getDeclaredLabels();
-  }
-
   /**
    * Builds a map from rule names to (newly constructed)) Starlark callables that instantiate them.
    */
diff --git a/src/main/java/com/google/devtools/build/lib/packages/Target.java b/src/main/java/com/google/devtools/build/lib/packages/Target.java
index abe0f63fe0..9dadb42b0e 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/Target.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/Target.java
@@ -84,9 +84,61 @@ public interface Target extends TargetData {
   /** Returns the set of distribution types associated with this target. */
   Set<DistributionType> getDistributions();
 
-  /** Returns the visibility of this target. */
+  /**
+   * Returns the visibility that was supplied at the point of this target's declaration -- e.g. the
+   * {@code visibility} attribute/argument for a rule target or {@code exports_files()} declaration)
+   * -- or null if none was given.
+   *
+   * <p>Although this value is "raw", it is still normalized through {@link
+   * RuleVisibility#validateAndSimplify RuleVisibility parsing}, e.g. eliminating redundant {@code
+   * //visibility:private} items and replacing the list with a single {@code //visibility:public}
+   * item if at least one such item appears.
+   *
+   * <p>This value may be useful to tooling that wants to introspect a target's visibility via
+   * {@code bazel query} and feed the result back into a modified target declaration, without
+   * picking up the package's default visibility, or the added location of the package or symbolic
+   * macro the target was declared in. It is not useful as a direct input to the visibility
+   * semantics; for that see {@link #getActualVisibility}.
+   *
+   * <p>This is also the value that is introspected through {@code native.existing_rules()}, except
+   * that null is replaced by an empty visibility.
+   */
+  @Nullable
+  RuleVisibility getRawVisibility();
+
+  /**
+   * Returns the default visibility value to fall back on if this target does not have a raw
+   * visibility.
+   *
+   * <p>Usually this is just the package's default visibility value for targets not declared in
+   * symbolic macros, and private for targets within symbolic macros. (In other words, a package's
+   * default visibility does not propagate to within a symbolic macro.) However, some targets may
+   * inject additional default visibility behavior here.
+   */
+  default RuleVisibility getDefaultVisibility() {
+    return isCreatedInSymbolicMacro()
+        ? RuleVisibility.PRIVATE
+        : getPackage().getPackageArgs().defaultVisibility();
+  }
+
+  /**
+   * Returns the {@link #getRawVisibility raw visibility} of this target, falling back on a {@link
+   * #getDefaultVisibility default value} if no raw visibility was supplied.
+   *
+   * <p>Due to the fallback, the result cannot be null.
+   *
+   * <p>This value may be useful for introspecting a target's visibility and reporting it in a
+   * context where the package's default visibility is not known. It is not useful as a direct input
+   * to the visibility semantics; for that see {@link #getActualVisibility}.
+   */
+  // TODO(brandjon): Perhaps the default value within a symbolic macro should be the value of the
+  // `--default_visibility` flag / PrecomputedValue. This would ensure targets within macros are
+  // always visible within unit tests or escape-hatched builds.
   // TODO(jhorvitz): Usually one of the following two methods suffice. Try to remove this.
-  RuleVisibility getVisibility();
+  default RuleVisibility getVisibility() {
+    RuleVisibility result = getRawVisibility();
+    return result != null ? result : getDefaultVisibility();
+  }
 
   /**
    * Equivalent to calling {@link RuleVisibility#getDependencyLabels} on the value returned by
@@ -110,6 +162,27 @@ public interface Target extends TargetData {
     return getVisibility().getDeclaredLabels();
   }
 
+  /**
+   * Returns the visibility of this target, as understood by the visibility semantics.
+   *
+   * <p>This is the result of {@link #getVisibility} unioned with the package where this target was
+   * instantiated (which can differ from the package where this target lives if the target was
+   * created inside a symbolic macro).
+   *
+   * <p>This is the value that feeds into visibility checking in the analysis phase. See {@link
+   * ConfiguredTargetFactory#convertVisibility} and {@link
+   * CommonPrerequisiteValidator#isVisibleToLocation}.
+   */
+  default RuleVisibility getActualVisibility() {
+    RuleVisibility visibility = getVisibility();
+    MacroInstance declaringMacro = getDeclaringMacro();
+    PackageIdentifier instantiatingLoc =
+        declaringMacro == null
+            ? getPackage().getPackageIdentifier()
+            : declaringMacro.getDefinitionPackage();
+    return visibility.concatWithPackage(instantiatingLoc);
+  }
+
   /** Returns whether this target type can be configured (e.g. accepts non-null configurations). */
   boolean isConfigurable();
 
diff --git a/src/main/java/com/google/devtools/build/lib/packages/VisibilityLicenseSpecifiedInputFile.java b/src/main/java/com/google/devtools/build/lib/packages/VisibilityLicenseSpecifiedInputFile.java
index 013cd2808f..935b235d62 100644
--- a/src/main/java/com/google/devtools/build/lib/packages/VisibilityLicenseSpecifiedInputFile.java
+++ b/src/main/java/com/google/devtools/build/lib/packages/VisibilityLicenseSpecifiedInputFile.java
@@ -43,12 +43,9 @@ public final class VisibilityLicenseSpecifiedInputFile extends InputFile {
   }
 
   @Override
-  public RuleVisibility getVisibility() {
-    if (visibility != null) {
-      return visibility;
-    } else {
-      return getPackage().getPackageArgs().defaultVisibility();
-    }
+  @Nullable
+  public RuleVisibility getRawVisibility() {
+    return visibility;
   }
 
   @Override
diff --git a/src/main/java/com/google/devtools/build/lib/query2/compat/FakeLoadTarget.java b/src/main/java/com/google/devtools/build/lib/query2/compat/FakeLoadTarget.java
index 89d10e97a7..598477cc8f 100644
--- a/src/main/java/com/google/devtools/build/lib/query2/compat/FakeLoadTarget.java
+++ b/src/main/java/com/google/devtools/build/lib/query2/compat/FakeLoadTarget.java
@@ -75,7 +75,7 @@ public class FakeLoadTarget implements Target {
   }
 
   @Override
-  public RuleVisibility getVisibility() {
+  public RuleVisibility getRawVisibility() {
     return RuleVisibility.PUBLIC;
   }
 
diff --git a/src/main/java/com/google/devtools/build/lib/query2/query/output/ProtoOutputFormatter.java b/src/main/java/com/google/devtools/build/lib/query2/query/output/ProtoOutputFormatter.java
index 19417157b7..6d7eb75bc9 100644
--- a/src/main/java/com/google/devtools/build/lib/query2/query/output/ProtoOutputFormatter.java
+++ b/src/main/java/com/google/devtools/build/lib/query2/query/output/ProtoOutputFormatter.java
@@ -335,6 +335,9 @@ public class ProtoOutputFormatter extends AbstractUnorderedFormatter {
         input.setPackageContainsErrors(inputFile.getPackage().containsErrors());
       }
 
+      // TODO(bazel-team): We're being inconsistent about whether we include the package's
+      // default_visibility in the target. For files we do, but for rules we don't.
+
       for (Label visibilityDependency : target.getVisibilityDependencyLabels()) {
         input.addPackageGroup(labelPrinter.toString(visibilityDependency));
       }
diff --git a/src/main/java/com/google/devtools/build/lib/query2/query/output/XmlOutputFormatter.java b/src/main/java/com/google/devtools/build/lib/query2/query/output/XmlOutputFormatter.java
index a31cce559a..fde21c8ea7 100644
--- a/src/main/java/com/google/devtools/build/lib/query2/query/output/XmlOutputFormatter.java
+++ b/src/main/java/com/google/devtools/build/lib/query2/query/output/XmlOutputFormatter.java
@@ -228,6 +228,8 @@ class XmlOutputFormatter extends AbstractUnorderedFormatter {
             String.valueOf(inputFile.getPackage().containsErrors()));
       }
 
+      // TODO(bazel-team): We're being inconsistent about whether we include the package's
+      // default_visibility in the target. For files we do, but for rules we don't.
       addPackageGroupsToElement(doc, elem, inputFile, labelPrinter);
     } else if (target instanceof EnvironmentGroup envGroup) {
       elem = doc.createElement("environment-group");
diff --git a/src/main/java/com/google/devtools/build/lib/rules/AliasConfiguredTarget.java b/src/main/java/com/google/devtools/build/lib/rules/AliasConfiguredTarget.java
index f0a0b76520..ce28f11604 100644
--- a/src/main/java/com/google/devtools/build/lib/rules/AliasConfiguredTarget.java
+++ b/src/main/java/com/google/devtools/build/lib/rules/AliasConfiguredTarget.java
@@ -61,6 +61,9 @@ import net.starlark.java.eval.Structure;
  *   <li>{@code actual} has a self transition. Self transitions don't get applied to the alias rule,
  *       and so the configuration keys actually differ.
  * </ul>
+ *
+ * <p>An {@code alias} target may not be used to redirect a {@code package_group} target in a {@code
+ * visibility} declaration or a {@code package_group}'s {@code includes} attribute.
  */
 @Immutable
 public final class AliasConfiguredTarget implements ConfiguredTarget, Structure {
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/SymbolicMacroTest.java b/src/test/java/com/google/devtools/build/lib/analysis/SymbolicMacroTest.java
index 45bab995c9..43eaf1d4dd 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/SymbolicMacroTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/SymbolicMacroTest.java
@@ -87,7 +87,7 @@ public final class SymbolicMacroTest extends BuildViewTestCase {
       throws Exception {
     Target target = pkg.getTarget(name);
     assertThat(target).isNotNull();
-    return asStringList(target.getVisibility().getDeclaredLabels());
+    return asStringList(target.getActualVisibility().getDeclaredLabels());
   }
 
   /**
@@ -95,7 +95,7 @@ public final class SymbolicMacroTest extends BuildViewTestCase {
    * package.
    */
   private static ImmutableList<String> getMacroVisibility(Package pkg, String id) throws Exception {
-    return asStringList(getMacroById(pkg, id).getVisibility());
+    return asStringList(getMacroById(pkg, id).getActualVisibility());
   }
 
   /**
diff --git a/src/test/java/com/google/devtools/build/lib/analysis/VisibilityProviderTest.java b/src/test/java/com/google/devtools/build/lib/analysis/VisibilityProviderTest.java
index 59f889e0a2..f273ceaa27 100644
--- a/src/test/java/com/google/devtools/build/lib/analysis/VisibilityProviderTest.java
+++ b/src/test/java/com/google/devtools/build/lib/analysis/VisibilityProviderTest.java
@@ -200,7 +200,6 @@ public final class VisibilityProviderTest extends BuildViewTestCase {
     // Check the provider of an alias target declared in a BUILD file referencing an actual target
     // in a macro, and vice versa.
     defineSimpleRule();
-    scratch.file("lib/BUILD");
     scratch.file(
         // Put the .bzl in //pkg so we don't have to declare //pkg:__pkg__ in visibility.
         "pkg/macro.bzl",
diff --git a/src/test/java/com/google/devtools/build/lib/graph/DigraphTest.java b/src/test/java/com/google/devtools/build/lib/graph/DigraphTest.java
index 132f3dffe8..cb36ef38cc 100644
--- a/src/test/java/com/google/devtools/build/lib/graph/DigraphTest.java
+++ b/src/test/java/com/google/devtools/build/lib/graph/DigraphTest.java
@@ -85,7 +85,7 @@ public class DigraphTest {
     }
 
     @Override
-    public RuleVisibility getVisibility() {
+    public RuleVisibility getRawVisibility() {
       return null;
     }
 
diff --git a/src/test/java/com/google/devtools/build/lib/packages/PackageFactoryTest.java b/src/test/java/com/google/devtools/build/lib/packages/PackageFactoryTest.java
index 7a70564704..ca6bda268d 100644
--- a/src/test/java/com/google/devtools/build/lib/packages/PackageFactoryTest.java
+++ b/src/test/java/com/google/devtools/build/lib/packages/PackageFactoryTest.java
@@ -1644,17 +1644,15 @@ public final class PackageFactoryTest extends PackageLoadingTestCase {
   // many macros overall, for both eager and deferred evaluation.
 
   /**
-   * Asserts that the target's RuleVisibility contains exactly the given labels.
-   *
-   * <p>For rule targets, this is effectively its visibility attribute, as possibly modified by the
-   * munging to include the declaration location.
+   * Asserts that the target's {@link Target#getActualVisibility actual visibility} contains exactly
+   * the given labels.
    */
   private void assertVisibilityIs(Target target, String... visibilityLabels) {
     ImmutableList.Builder<Label> labels = ImmutableList.builder();
     for (String item : visibilityLabels) {
       labels.add(Label.parseCanonicalUnchecked(item));
     }
-    assertThat(target.getVisibility().getDeclaredLabels())
+    assertThat(target.getActualVisibility().getDeclaredLabels())
         // Values are sorted by virtue of visibility being a label_list.
         .containsExactlyElementsIn(labels.build());
   }
@@ -1665,7 +1663,8 @@ public final class PackageFactoryTest extends PackageLoadingTestCase {
   }
 
   @Test
-  public void testDeclarationVisibilityUnioning_onlyOccursWithinMacros() throws Exception {
+  public void testDeclarationVisibilityUnioning_occursBothInsideAndOutsideMacros()
+      throws Exception {
     enableMacrosAndUsePrivateVisibility();
     scratch.file("lib/BUILD");
     scratch.file(
@@ -1691,7 +1690,7 @@ public final class PackageFactoryTest extends PackageLoadingTestCase {
         """);
 
     Package pkg = loadPackageAndAssertSuccess("pkg");
-    assertVisibilityIs(pkg.getTarget("foo"), "//other_pkg:__pkg__");
+    assertVisibilityIs(pkg.getTarget("foo"), "//other_pkg:__pkg__", "//pkg:__pkg__");
     assertVisibilityIs(pkg.getTarget("bar"), "//other_pkg:__pkg__", "//lib:__pkg__");
   }
 
@@ -1753,7 +1752,8 @@ public final class PackageFactoryTest extends PackageLoadingTestCase {
         """);
 
     Package pkg = loadPackageAndAssertSuccess("pkg");
-    assertVisibilityIs(pkg.getTarget("foo"), "//other_pkg:__pkg__");
+    assertVisibilityIs(pkg.getTarget("foo"), "//other_pkg:__pkg__", "//pkg:__pkg__");
+    // other_pkg doesn't propagate to bar, it only has its own instantiation location.
     assertVisibilityIs(pkg.getTarget("bar"), "//lib:__pkg__");
   }
 
