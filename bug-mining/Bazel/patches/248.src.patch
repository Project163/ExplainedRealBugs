diff --git a/src/main/java/com/google/devtools/build/lib/rules/cpp/HeaderDiscovery.java b/src/main/java/com/google/devtools/build/lib/rules/cpp/HeaderDiscovery.java
index bb3d068956..45e4eba67c 100644
--- a/src/main/java/com/google/devtools/build/lib/rules/cpp/HeaderDiscovery.java
+++ b/src/main/java/com/google/devtools/build/lib/rules/cpp/HeaderDiscovery.java
@@ -107,7 +107,8 @@ final class HeaderDiscovery {
         treeArtifacts,
         execRoot,
         artifactResolver,
-        siblingRepositoryLayout);
+        siblingRepositoryLayout,
+        pathMapper);
   }
 
   private static NestedSet<Artifact> runDiscovery(
@@ -120,7 +121,8 @@ final class HeaderDiscovery {
       Map<PathFragment, SpecialArtifact> treeArtifacts,
       Path execRoot,
       ArtifactResolver artifactResolver,
-      boolean siblingRepositoryLayout)
+      boolean siblingRepositoryLayout,
+      PathMapper pathMapper)
       throws ActionExecutionException {
     NestedSetBuilder<Artifact> inputs = NestedSetBuilder.stableOrder();
 
@@ -192,7 +194,7 @@ final class HeaderDiscovery {
           inputs.add(artifact);
         }
         continue;
-      } else if (artifact == null && execPathFragment.getFileExtension().equals("cppmap")) {
+      } else if (execPathFragment.getFileExtension().equals("cppmap")) {
         // Transitive cppmap files are added to the dotd files of compiles even
         // though they are not required for compilation. Since they're not
         // explicit inputs to the action this only happens when sandboxing is
@@ -200,7 +202,8 @@ final class HeaderDiscovery {
         continue;
       }
 
-      SpecialArtifact treeArtifact = findOwningTreeArtifact(execPathFragment, treeArtifacts);
+      SpecialArtifact treeArtifact =
+          findOwningTreeArtifact(execPathFragment, treeArtifacts, pathMapper);
       if (treeArtifact != null) {
         inputs.add(treeArtifact);
       } else {
@@ -234,7 +237,9 @@ final class HeaderDiscovery {
 
   @Nullable
   private static SpecialArtifact findOwningTreeArtifact(
-      PathFragment execPath, Map<PathFragment, SpecialArtifact> treeArtifacts) {
+      PathFragment execPath,
+      Map<PathFragment, SpecialArtifact> treeArtifacts,
+      PathMapper pathMapper) {
     // Check the map for the exec path's parent directory first. If the exec path matches a direct
     // child of a tree artifact (a common case), we can skip the full iteration below.
     PathFragment dir = execPath.getParentDirectory();
@@ -245,7 +250,7 @@ final class HeaderDiscovery {
 
     // Search for any tree artifact that encloses the exec path.
     return treeArtifacts.values().stream()
-        .filter(a -> dir.startsWith(a.getExecPath()))
+        .filter(a -> dir.startsWith(pathMapper.map(a.getExecPath())))
         .findAny()
         .orElse(null);
   }
diff --git a/src/test/shell/bazel/path_mapping_test.sh b/src/test/shell/bazel/path_mapping_test.sh
index 239d6e9db4..60892c69fb 100755
--- a/src/test/shell/bazel/path_mapping_test.sh
+++ b/src/test/shell/bazel/path_mapping_test.sh
@@ -421,6 +421,8 @@ EOF
   cat > "$pkg/main.cc" <<EOF
 #include <iostream>
 #include <string>
+#include "$pkg/lib1/gen/top_level.h"
+#include "$pkg/lib1/gen/other_dir/not_top_level.h"
 #include "$pkg/lib1/lib1.h"
 #include "lib2.h"
 
@@ -430,19 +432,29 @@ int main() {
   std::cout << GetLib1Greeting() << std::endl;
   std::cout << GetLib2Greeting() << std::endl;
   std::cout << TreeArtifactGreeting() << std::endl;
+  std::cout << TOP_LEVEL_CONSTANT << " " << NOT_TOP_LEVEL_CONSTANT << std::endl;
   return 0;
 }
 EOF
 
   mkdir -p "$pkg"/lib1
   cat > "$pkg/lib1/BUILD" <<EOF
+load("//$pkg/common/utils:defs.bzl", "gen_h", "transition_wrapper")
+
 cc_library(
     name = "lib1",
     srcs = ["lib1.cc"],
-    hdrs = ["lib1.h"],
+    hdrs = [
+        "lib1.h",
+        ":gen",
+    ],
     deps = ["//$pkg/common/utils:utils"],
     visibility = ["//visibility:public"],
 )
+
+gen_h(
+    name = "gen",
+)
 EOF
   cat > "$pkg/lib1/lib1.h" <<'EOF'
 #ifndef LIB1_H_
@@ -611,6 +623,38 @@ gen_cc = rule(
         "subject": attr.string(),
     },
 )
+
+def _gen_h_impl(ctx):
+    out = ctx.actions.declare_directory(ctx.label.name)
+    ctx.actions.run_shell(
+        outputs = [out],
+        command = """\
+cat >{out_path}/top_level.h <<EOF2
+#ifndef TOP_LEVEL_H_
+#define TOP_LEVEL_H_
+
+#define TOP_LEVEL_CONSTANT 42
+
+#endif
+EOF2
+mkdir -p {out_path}/other_dir
+cat >{out_path}/other_dir/not_top_level.h <<EOF2
+#ifndef NOT_TOP_LEVEL_H_
+#define NOT_TOP_LEVEL_H_
+
+#define NOT_TOP_LEVEL_CONSTANT 43
+
+#endif
+EOF2
+        """.format(
+            out_path = out.path,
+        ),
+    )
+    return [
+        DefaultInfo(files = depset([out])),
+    ]
+
+gen_h = rule(implementation = _gen_h_impl)
 EOF
   cat > "$pkg/common/utils/utils.cc.tpl" <<'EOF'
 #include "utils.h"
@@ -631,6 +675,7 @@ EOF
   expect_log 'Hello, lib1!'
   expect_log 'Hello, lib2!'
   expect_log 'Hello, TreeArtifact!'
+  expect_log '42 43'
   expect_not_log 'remote cache hit'
 
   bazel run \
@@ -644,6 +689,7 @@ EOF
   expect_log 'Hi there, lib1!'
   expect_log 'Hi there, lib2!'
   expect_log 'Hello, TreeArtifact!'
+  expect_log '42 43'
   # Compilation actions for lib1, lib2 and main should result in cache hits due
   # to path stripping, utils is legitimately different and should not.
   expect_log ' 4 remote cache hit'
