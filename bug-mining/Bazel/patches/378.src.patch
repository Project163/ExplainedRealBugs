diff --git a/src/main/java/com/google/devtools/build/lib/dynamic/Branch.java b/src/main/java/com/google/devtools/build/lib/dynamic/Branch.java
index 53fed74bd6..25ccb3f0bf 100644
--- a/src/main/java/com/google/devtools/build/lib/dynamic/Branch.java
+++ b/src/main/java/com/google/devtools/build/lib/dynamic/Branch.java
@@ -15,6 +15,7 @@
 package com.google.devtools.build.lib.dynamic;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.flogger.GoogleLogger;
@@ -48,8 +49,10 @@ abstract class Branch implements Callable<ImmutableList<SpawnResult>> {
    * #callImpl(ActionExecutionContext)} yet.
    */
   protected final AtomicBoolean starting = new AtomicBoolean(true);
+
   /** The {@link Spawn} this branch is running. */
   protected final Spawn spawn;
+
   /**
    * The {@link SettableFuture} with the results from running the spawn. Must not be null if
    * execution succeeded.
@@ -61,6 +64,7 @@ abstract class Branch implements Callable<ImmutableList<SpawnResult>> {
    * This object is shared between the local and remote branch of an action.
    */
   protected final AtomicReference<DynamicMode> strategyThatCancelled;
+
   /**
    * Semaphore that indicates whether this branch is done, i.e. either completed or cancelled. This
    * is needed to wait for the branch to finish its own cleanup (e.g. terminating subprocesses) once
@@ -71,6 +75,8 @@ abstract class Branch implements Callable<ImmutableList<SpawnResult>> {
   protected final DynamicExecutionOptions options;
   protected final ActionExecutionContext context;
 
+  protected Branch otherBranch;
+
   /**
    * Creates a new branch of dynamic execution.
    *
@@ -130,6 +136,41 @@ abstract class Branch implements Callable<ImmutableList<SpawnResult>> {
     future.setFuture(executor.submit(this));
   }
 
+  /** Sets up the {@link Future} used in the current branch to know what other branch to cancel. */
+  protected void prepareFuture(Branch otherBranch) {
+    this.otherBranch = otherBranch;
+    future.addListener(
+        () -> {
+          if (starting.compareAndSet(true, false)) {
+            // If the current branch got cancelled before even starting, we release its semaphore
+            // for it.
+            done.release();
+          }
+          // If the current branch succeeds, there is no need to keep the other branch running.
+          // If the current branch fails, cancel the other branch as well. However, that one may
+          // in turn cancel us, thus causing an interruption. Don't consider that a failure as
+          // we otherwise risk canceling both branches.
+          var state = future.state();
+          if (state == Future.State.SUCCESS
+              || (state == Future.State.FAILED
+                  && !(future.exceptionNow() instanceof InterruptedException))) {
+            otherBranch.cancel();
+          }
+          if (options.debugSpawnScheduler) {
+            logger.atInfo().log(
+                "In listener callback, the future of the remote branch is %s",
+                future.state().name());
+            try {
+              future.get();
+            } catch (InterruptedException | ExecutionException e) {
+              logger.atInfo().withCause(e).log(
+                  "The future of the remote branch failed with an exception.");
+            }
+          }
+        },
+        directExecutor());
+  }
+
   /**
    * Moves a set of stdout/stderr files over another one. Errors during the move are logged and
    * swallowed.
diff --git a/src/main/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategy.java b/src/main/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategy.java
index 64faf1106f..3ccef7fc90 100644
--- a/src/main/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategy.java
+++ b/src/main/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategy.java
@@ -54,6 +54,7 @@ import java.util.Optional;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future.State;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
@@ -708,7 +709,7 @@ public class DynamicSpawnStrategy implements SpawnStrategy {
             // This can happen if the other branch is local under local_lockfree and has returned
             // its result but not yet cancelled this branch, or if the other branch was already
             // cancelled for other reasons. In the latter case, we are good to continue.
-            if (!otherBranch.isCancelled()) {
+            if (otherBranch.future.state() == State.SUCCESS) {
               throw new DynamicInterruptedException(
                   String.format(
                       "Execution of %s strategy stopped because %s strategy could not be cancelled",
diff --git a/src/main/java/com/google/devtools/build/lib/dynamic/LocalBranch.java b/src/main/java/com/google/devtools/build/lib/dynamic/LocalBranch.java
index baebee93a3..8ede46c73b 100644
--- a/src/main/java/com/google/devtools/build/lib/dynamic/LocalBranch.java
+++ b/src/main/java/com/google/devtools/build/lib/dynamic/LocalBranch.java
@@ -20,7 +20,6 @@ import static com.google.devtools.build.lib.actions.DynamicStrategyRegistry.Dyna
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.flogger.GoogleLogger;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.devtools.build.lib.actions.ActionExecutionContext;
 import com.google.devtools.build.lib.actions.DynamicStrategyRegistry;
 import com.google.devtools.build.lib.actions.DynamicStrategyRegistry.DynamicMode;
@@ -29,6 +28,7 @@ import com.google.devtools.build.lib.actions.SandboxedSpawnStrategy;
 import com.google.devtools.build.lib.actions.Spawn;
 import com.google.devtools.build.lib.actions.SpawnResult;
 import com.google.devtools.build.lib.actions.SpawnResult.Status;
+import com.google.devtools.build.lib.actions.SpawnStrategy;
 import com.google.devtools.build.lib.dynamic.DynamicExecutionModule.IgnoreFailureCheck;
 import com.google.devtools.build.lib.profiler.Profiler;
 import com.google.devtools.build.lib.profiler.SilentCloseable;
@@ -36,7 +36,6 @@ import com.google.devtools.build.lib.util.io.FileOutErr;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.Optional;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
@@ -50,7 +49,6 @@ import javax.annotation.Nullable;
 class LocalBranch extends Branch {
   private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
 
-  private RemoteBranch remoteBranch;
   private final IgnoreFailureCheck ignoreFailureCheck;
   private final Function<Spawn, Optional<Spawn>> getExtraSpawnForLocalExecution;
   private final AtomicBoolean delayLocalExecution;
@@ -138,38 +136,12 @@ class LocalBranch extends Branch {
     throw new AssertionError("canExec passed but no usable local strategy for action " + spawn);
   }
 
-  /** Sets up the {@link Future} used in the local branch to know what remote branch to cancel. */
-  protected void prepareFuture(RemoteBranch remoteBranch) {
-    // TODO(b/203094728): Maybe generify this method and move it up.
-    this.remoteBranch = remoteBranch;
-    future.addListener(
-        () -> {
-          if (starting.compareAndSet(true, false)) {
-            // If the local branch got cancelled before even starting, we release its semaphore
-            // for it.
-            done.release();
-          }
-          if (!future.isCancelled()) {
-            remoteBranch.cancel();
-          }
-          if (options.debugSpawnScheduler) {
-            logger.atInfo().log(
-                "In listener callback, the future of the local branch is %s",
-                future.state().name());
-            try {
-              future.get();
-            } catch (InterruptedException | ExecutionException e) {
-              logger.atInfo().withCause(e).log(
-                  "The future of the local branch failed with an exception.");
-            }
-          }
-        },
-        MoreExecutors.directExecutor());
-  }
-
   @Override
   ImmutableList<SpawnResult> callImpl(ActionExecutionContext context)
       throws InterruptedException, ExecException {
+    if (otherBranch == null) {
+      throw new IllegalStateException("prepareFuture not called");
+    }
     try {
       if (!starting.compareAndSet(true, false)) {
         // If we ever get here, it's because we were cancelled early and the listener
@@ -190,7 +162,7 @@ class LocalBranch extends Branch {
               maybeIgnoreFailure(exitCode, errorMessage, outErr);
             }
             DynamicSpawnStrategy.stopBranch(
-                remoteBranch, this, strategyThatCancelled, options, this.context);
+                otherBranch, this, strategyThatCancelled, options, this.context);
           },
           getExtraSpawnForLocalExecution);
     } catch (DynamicInterruptedException e) {
diff --git a/src/main/java/com/google/devtools/build/lib/dynamic/RemoteBranch.java b/src/main/java/com/google/devtools/build/lib/dynamic/RemoteBranch.java
index 9bd26ea1ca..09797c5abd 100644
--- a/src/main/java/com/google/devtools/build/lib/dynamic/RemoteBranch.java
+++ b/src/main/java/com/google/devtools/build/lib/dynamic/RemoteBranch.java
@@ -20,7 +20,6 @@ import static com.google.devtools.build.lib.actions.DynamicStrategyRegistry.Dyna
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.flogger.GoogleLogger;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.devtools.build.lib.actions.ActionExecutionContext;
 import com.google.devtools.build.lib.actions.DynamicStrategyRegistry;
 import com.google.devtools.build.lib.actions.DynamicStrategyRegistry.DynamicMode;
@@ -29,10 +28,10 @@ import com.google.devtools.build.lib.actions.SandboxedSpawnStrategy;
 import com.google.devtools.build.lib.actions.SandboxedSpawnStrategy.StopConcurrentSpawns;
 import com.google.devtools.build.lib.actions.Spawn;
 import com.google.devtools.build.lib.actions.SpawnResult;
+import com.google.devtools.build.lib.actions.SpawnStrategy;
 import com.google.devtools.build.lib.dynamic.DynamicExecutionModule.IgnoreFailureCheck;
 import com.google.devtools.build.lib.events.Event;
 import com.google.devtools.build.lib.util.io.FileOutErr;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.Nullable;
@@ -45,7 +44,6 @@ import javax.annotation.Nullable;
 class RemoteBranch extends Branch {
   private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
 
-  private LocalBranch localBranch;
   private final IgnoreFailureCheck ignoreFailureCheck;
   private final AtomicBoolean delayLocalExecution;
 
@@ -109,39 +107,11 @@ class RemoteBranch extends Branch {
     throw new AssertionError("canExec passed but no usable remote strategy for action " + spawn);
   }
 
-  /** Sets up the future for this branch, once the other branch is available. */
-  public void prepareFuture(LocalBranch localBranch) {
-    this.localBranch = localBranch;
-    future.addListener(
-        () -> {
-          if (starting.compareAndSet(true, false)) {
-            // If the remote branch got cancelled before even starting, we release its semaphore
-            // for it.
-            done.release();
-          }
-          if (!future.isCancelled()) {
-            localBranch.cancel();
-          }
-          if (options.debugSpawnScheduler) {
-            logger.atInfo().log(
-                "In listener callback, the future of the remote branch is %s",
-                future.state().name());
-            try {
-              future.get();
-            } catch (InterruptedException | ExecutionException e) {
-              logger.atInfo().withCause(e).log(
-                  "The future of the remote branch failed with an exception.");
-            }
-          }
-        },
-        MoreExecutors.directExecutor());
-  }
-
   @Override
   public ImmutableList<SpawnResult> callImpl(ActionExecutionContext context)
       throws InterruptedException, ExecException {
-    if (localBranch == null) {
-      throw new IllegalStateException("Initialize not called");
+    if (otherBranch == null) {
+      throw new IllegalStateException("prepareFuture not called");
     }
     try {
       if (!starting.compareAndSet(true, false)) {
@@ -158,7 +128,7 @@ class RemoteBranch extends Branch {
               maybeIgnoreFailure(exitCode, errorMessage, outErr);
             }
             DynamicSpawnStrategy.stopBranch(
-                localBranch, this, strategyThatCancelled, options, this.context);
+                otherBranch, this, strategyThatCancelled, options, this.context);
           },
           delayLocalExecution);
     } catch (DynamicInterruptedException e) {
diff --git a/src/test/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategyTest.java b/src/test/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategyTest.java
index 729c5929d9..a89711ce65 100644
--- a/src/test/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategyTest.java
+++ b/src/test/java/com/google/devtools/build/lib/dynamic/DynamicSpawnStrategyTest.java
@@ -1095,6 +1095,177 @@ public class DynamicSpawnStrategyTest {
     assertThatStrategyPropagatesException(localExec, remoteExec, e);
   }
 
+  @Test
+  public void remoteBranchThrowsInterruptedExceptionAfterCancellation() throws Exception {
+    CountDownLatch localCanFinish = new CountDownLatch(1);
+    CountDownLatch remoteStarted = new CountDownLatch(1);
+
+    MockSpawnStrategy localStrategy =
+        new MockSpawnStrategy(
+            "MockLocalSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              remoteStarted.await();
+              localCanFinish.await();
+            },
+            DoExec.NOTHING);
+
+    MockSpawnStrategy remoteStrategy =
+        new MockSpawnStrategy(
+            "MockRemoteSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              remoteStarted.countDown();
+              Thread.sleep(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
+            },
+            DoExec.NOTHING);
+
+    StrategyAndContext strategyAndContext = createSpawnStrategy(localStrategy, remoteStrategy);
+
+    TestThread testThread =
+        new TestThread(
+            () -> {
+              try {
+                Spawn spawn = newDynamicSpawn();
+                strategyAndContext.exec(spawn);
+              } catch (InterruptedException | ExecException e) {
+                throw new RuntimeException(e);
+              }
+            });
+    testThread.start();
+
+    remoteStarted.await();
+    localCanFinish.countDown();
+    testThread.joinAndAssertState(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
+
+    assertThat(localStrategy.succeeded()).isTrue();
+    assertThat(remoteStrategy.succeeded()).isFalse();
+  }
+
+  @Test
+  public void localBranchCancelsRemoteWhichThrowsInterruptedException() throws Exception {
+    CountDownLatch bothStarted = new CountDownLatch(2);
+
+    MockSpawnStrategy localStrategy =
+        new MockSpawnStrategy(
+            "MockLocalSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              countDownAndWait(bothStarted);
+            },
+            DoExec.NOTHING);
+
+    MockSpawnStrategy remoteStrategy =
+        new MockSpawnStrategy(
+            "MockRemoteSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              countDownAndWait(bothStarted);
+              Thread.sleep(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
+            },
+            DoExec.NOTHING);
+
+    StrategyAndContext strategyAndContext = createSpawnStrategy(localStrategy, remoteStrategy);
+
+    Spawn spawn = newDynamicSpawn();
+    strategyAndContext.exec(spawn);
+
+    assertThat(localStrategy.succeeded()).isTrue();
+    assertThat(remoteStrategy.succeeded()).isFalse();
+    assertThat(outErr.outAsLatin1()).contains("output files written with MockLocalSpawnStrategy");
+  }
+
+  @Test
+  public void remoteFinishesFirstAndThrowsInterruptedExceptionDuringLocalCancellation()
+      throws Exception {
+    CountDownLatch bothStarted = new CountDownLatch(2);
+
+    MockSpawnStrategy localStrategy =
+        new MockSpawnStrategy(
+            "MockLocalSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              countDownAndWait(bothStarted);
+              Thread.sleep(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
+            },
+            DoExec.NOTHING);
+
+    MockSpawnStrategy remoteStrategy =
+        new MockSpawnStrategy(
+            "MockRemoteSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              countDownAndWait(bothStarted);
+            },
+            DoExec.NOTHING);
+
+    StrategyAndContext strategyAndContext = createSpawnStrategy(localStrategy, remoteStrategy);
+
+    Spawn spawn = newDynamicSpawn();
+    // This should complete successfully with remote results, not throw AssertionError
+    strategyAndContext.exec(spawn);
+
+    assertThat(localStrategy.succeeded()).isFalse();
+    assertThat(remoteStrategy.succeeded()).isTrue();
+    assertThat(outErr.outAsLatin1()).contains("output files written with MockRemoteSpawnStrategy");
+  }
+
+  @Test
+  public void remoteBranchThrowsInterruptedExceptionBeforeStopConcurrentSpawns() throws Exception {
+    CountDownLatch remoteStarted = new CountDownLatch(1);
+
+    MockSpawnStrategy localStrategy =
+        new MockSpawnStrategy(
+            "MockLocalSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              remoteStarted.await();
+              Thread.sleep(100); // Give remote time to fail
+            },
+            DoExec.NOTHING);
+
+    MockSpawnStrategy remoteStrategy =
+        new MockSpawnStrategy(
+            "MockRemoteSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              remoteStarted.countDown();
+              throw new InterruptedException("Remote operation interrupted");
+            },
+            DoExec.NOTHING);
+
+    StrategyAndContext strategyAndContext = createSpawnStrategy(localStrategy, remoteStrategy);
+
+    Spawn spawn = newDynamicSpawn();
+    strategyAndContext.exec(spawn);
+
+    assertThat(localStrategy.succeeded()).isTrue();
+    assertThat(remoteStrategy.succeeded()).isFalse();
+    assertThat(outErr.outAsLatin1()).contains("output files written with MockLocalSpawnStrategy");
+  }
+
+  @Test
+  public void remoteBranchInterruptedAfterLocalStartsStopConcurrentSpawns() throws Exception {
+    CountDownLatch bothStarted = new CountDownLatch(2);
+    CountDownLatch localReadyToStop = new CountDownLatch(1);
+
+    MockSpawnStrategy localStrategy =
+        new MockSpawnStrategy(
+            "MockLocalSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> countDownAndWait(bothStarted),
+            (self, spawn, actionExecutionContext) -> localReadyToStop.countDown());
+
+    MockSpawnStrategy remoteStrategy =
+        new MockSpawnStrategy(
+            "MockRemoteSpawnStrategy",
+            (self, spawn, actionExecutionContext) -> {
+              countDownAndWait(bothStarted);
+              Thread.sleep(TestUtils.WAIT_TIMEOUT_MILLISECONDS);
+            },
+            DoExec.NOTHING);
+
+    StrategyAndContext strategyAndContext = createSpawnStrategy(localStrategy, remoteStrategy);
+
+    Spawn spawn = newDynamicSpawn();
+    strategyAndContext.exec(spawn);
+
+    assertThat(localStrategy.succeeded()).isTrue();
+    assertThat(remoteStrategy.succeeded()).isFalse();
+    assertThat(outErr.outAsLatin1()).contains("output files written with MockLocalSpawnStrategy");
+  }
+
   private static FailureDetail createFailureDetail(String message) {
     return FailureDetail.newBuilder()
         .setMessage(message)
