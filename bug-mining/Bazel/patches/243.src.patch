diff --git a/src/test/shell/bazel/bazel_java_test.sh b/src/test/shell/bazel/bazel_java_test.sh
index 8ac652aab6..d078df4315 100755
--- a/src/test/shell/bazel/bazel_java_test.sh
+++ b/src/test/shell/bazel/bazel_java_test.sh
@@ -2117,39 +2117,67 @@ EOF
 }
 
 function test_one_version() {
-  if [[ "${JAVA_TOOLS_ZIP}" == released ]]; then
-    # TODO: Enable test after the next java_tools release.
-    return 0
-  fi
-
-  # TODO: Remove patch on rules_java and add test for prebuilt tool after the next release.
-  cat << 'EOF' > MODULE.bazel
-bazel_dep(
-    name = "rules_java",
-    version = "7.5.0",
+  mkdir -p pkg
+  cat << 'EOF' > pkg/BUILD
+java_binary(
+    name = "a",
+    srcs = ["A.java"],
+    main_class = "A",
+    deps = [
+        "//pkg/b1",
+        "//pkg/b2",
+    ]
+)
+EOF
+  cat << 'EOF' > pkg/A.java
+public class A extends B {
+  public static void main(String[] args) {
+    System.err.println("Hello, two worlds!");
+  }
+}
+EOF
+  mkdir -p pkg/b1
+  cat << 'EOF' > pkg/b1/BUILD
+java_library(
+    name = "b1",
+    srcs = ["B.java"],
+    visibility = ["//visibility:public"],
 )
-archive_override(
-    module_name = "rules_java",
-    urls = ["https://github.com/bazelbuild/rules_java/releases/download/7.5.0/rules_java-7.5.0.tar.gz"],
-    patches = ["//pkg:rules_java.patch"],
+EOF
+  cat << 'EOF' > pkg/b1/B.java
+public class B {
+  public void foo() {}
+}
+EOF
+  mkdir -p pkg/b2
+  cat << 'EOF' > pkg/b2/BUILD
+java_library(
+    name = "b2",
+    srcs = ["B.java"],
+    visibility = ["//visibility:public"],
 )
-toolchains = use_extension("@rules_java//java:extensions.bzl", "toolchains")
-use_repo(toolchains, "remote_java_tools_linux")
+EOF
+  cat << 'EOF' > pkg/b2/B.java
+public class B {
+  public void bar() {}
+}
 EOF
 
-  mkdir -p pkg
-  cat << 'EOF' > pkg/rules_java.patch
---- MODULE.bazel
-+++ MODULE.bazel
-@@ -13,6 +13,7 @@ bazel_dep(name = "bazel_skylib", version = "1.2.0")
- # Required by @remote_java_tools, which is loaded via module extension.
- bazel_dep(name = "rules_proto", version = "4.0.0")
- bazel_dep(name = "rules_license", version = "0.0.3")
-+bazel_dep(name = "abseil-cpp", version = "20230802.1", repo_name = "com_google_absl")
+  bazel build //pkg:a --experimental_one_version_enforcement=error \
+    >& $TEST_log && fail "build should have failed"
+  expect_log "Found one definition violations on the runtime classpath:"
+  expect_log "B has incompatible definitions in:"
+  expect_log " //pkg/b1:b1"
+  expect_log " //pkg/b2:b2"
+}
 
- register_toolchains("//toolchains:all")
+function test_one_version_allowlist() {
+  if [[ "${JAVA_TOOLS_ZIP}" == released ]]; then
+      # TODO: Enable test after the next java_tools release.
+      return 0
+  fi
 
-EOF
+  mkdir -p pkg
   cat << 'EOF' > pkg/BUILD
 load("@bazel_tools//tools/jdk:default_java_toolchain.bzl", "default_java_toolchain")
 
@@ -2157,8 +2185,7 @@ default_java_toolchain(
     name = "java_toolchain",
     source_version = "17",
     target_version = "17",
-    # TODO: Replace this with a target under @rules_java after the next release.
-    oneversion = "@remote_java_tools_linux//:prebuilt_one_version",
+    oneversion_whitelist = "//pkg:allowlist",
 )
 
 java_binary(
@@ -2171,7 +2198,10 @@ java_binary(
     ]
 )
 EOF
+  touch pkg/allowlist
   cat << 'EOF' > pkg/A.java
+package com.example;
+
 public class A extends B {
   public static void main(String[] args) {
     System.err.println("Hello, two worlds!");
@@ -2187,6 +2217,8 @@ java_library(
 )
 EOF
   cat << 'EOF' > pkg/b1/B.java
+package com.example;
+
 public class B {
   public void foo() {}
 }
@@ -2200,20 +2232,30 @@ java_library(
 )
 EOF
   cat << 'EOF' > pkg/b2/B.java
+package com.example;
+
 public class B {
   public void bar() {}
 }
 EOF
 
-  bazel build //pkg:a \
+  bazel build //pkg:a --experimental_one_version_enforcement=error \
     --java_language_version=17 \
     --extra_toolchains=//pkg:java_toolchain_definition \
-    --experimental_one_version_enforcement=error \
     >& $TEST_log && fail "build should have failed"
   expect_log "Found one definition violations on the runtime classpath:"
-  expect_log "B has incompatible definitions in:"
+  expect_log "com.example.B has incompatible definitions in:"
   expect_log " //pkg/b1:b1"
   expect_log " //pkg/b2:b2"
+
+  cat > pkg/allowlist <<EOF
+foo/bar @repo//baz
+com/example //pkg/b1:b1
+EOF
+  bazel build //pkg:a --experimental_one_version_enforcement=error \
+    --java_language_version=17 \
+    --extra_toolchains=//pkg:java_toolchain_definition \
+    >& $TEST_log || fail "build should have succeeded"
 }
 
 run_suite "Java integration tests"
diff --git a/src/tools/one_version/one_version_main.cc b/src/tools/one_version/one_version_main.cc
index 0b7bc078a5..26c8734432 100644
--- a/src/tools/one_version/one_version_main.cc
+++ b/src/tools/one_version/one_version_main.cc
@@ -38,12 +38,14 @@
 int main(int argc, char *argv[]) {
   std::string output_file;
   bool succeed_on_found_violations = false;
+  std::string allowlist_file;
   std::vector<std::string> inputs;
   ArgTokenStream tokens(argc - 1, argv + 1);
   while (!tokens.AtEnd()) {
     if (tokens.MatchAndSet("--output", &output_file) ||
         tokens.MatchAndSet("--succeed_on_found_violations",
                            &succeed_on_found_violations) ||
+        tokens.MatchAndSet("--whitelist", &allowlist_file) ||
         tokens.MatchAndSet("--inputs", &inputs)) {
     } else {
       std::cerr << "error: bad command line argument " << tokens.token()
@@ -52,11 +54,32 @@ int main(int argc, char *argv[]) {
     }
   }
 
-  // TODO(cushon): support customizing the allowlist
-  one_version::OneVersion one_version(
-      std::make_unique<one_version::MapAllowlist>(
-          absl::flat_hash_map<std::string,
-                              absl::flat_hash_set<std::string>>()));
+  std::unique_ptr<one_version::Allowlist> allowlist;
+  if (allowlist_file.empty()) {
+    allowlist = std::make_unique<one_version::MapAllowlist>(
+        absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>>());
+  } else {
+    std::ifstream in(allowlist_file);
+    if (!in) {
+      std::cerr << "error: unable to open allowlist file: " << allowlist_file
+                << std::endl;
+      return 1;
+    }
+    absl::flat_hash_map<std::string, absl::flat_hash_set<std::string>> map;
+    std::string line;
+    while (std::getline(in, line)) {
+      std::vector<std::string> parts =
+          absl::StrSplit(line, absl::MaxSplits(' ', 1));
+      if (parts.size() != 2) {
+        std::cerr << "error: expected <package> <label>, got: " << line
+                  << std::endl;
+        return 1;
+      }
+      map[parts[0]].insert(parts[1]);
+    }
+    allowlist = std::make_unique<one_version::MapAllowlist>(std::move(map));
+  }
+  one_version::OneVersion one_version(std::move(allowlist));
 
   for (const std::string &input : inputs) {
     std::vector<std::string> pieces = absl::StrSplit(input, ',');
