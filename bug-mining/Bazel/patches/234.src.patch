diff --git a/src/main/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploader.java b/src/main/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploader.java
index 349bf3c431..e384b6f6cc 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploader.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploader.java
@@ -338,7 +338,7 @@ class ByteStreamBuildEventArtifactUploader extends AbstractReferenceCounted
       return Single.just(remoteBytestreamUriPrefix);
     }
 
-    return toSingle(remoteCache.cacheProtocol::getAuthority, directExecutor())
+    return toSingle(remoteCache::getRemoteAuthority, directExecutor())
         .map(
             a -> {
               if (!Strings.isNullOrEmpty(remoteInstanceName)) {
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteCache.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteCache.java
index afc9dee757..84e05f82e0 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteCache.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteCache.java
@@ -13,6 +13,9 @@
 // limitations under the License.
 package com.google.devtools.build.lib.remote;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
@@ -23,7 +26,6 @@ import static com.google.devtools.build.lib.remote.util.Utils.getFromFuture;
 import build.bazel.remote.execution.v2.ActionResult;
 import build.bazel.remote.execution.v2.CacheCapabilities;
 import build.bazel.remote.execution.v2.Digest;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.flogger.GoogleLogger;
@@ -39,6 +41,7 @@ import com.google.devtools.build.lib.remote.common.RemoteActionExecutionContext;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient.ActionKey;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient.CachedActionResult;
+import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.options.RemoteOptions;
 import com.google.devtools.build.lib.remote.util.AsyncTaskCache;
 import com.google.devtools.build.lib.remote.util.DigestUtil;
@@ -62,6 +65,7 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 
 /**
  * A cache for storing artifacts (input and output) as well as the output of running an action.
@@ -83,25 +87,93 @@ public class RemoteCache extends AbstractReferenceCounted {
   private final CountDownLatch closeCountDownLatch = new CountDownLatch(1);
   protected final AsyncTaskCache.NoResult<Digest> casUploadCache = AsyncTaskCache.NoResult.create();
 
-  protected final RemoteCacheClient cacheProtocol;
+  @Nullable protected final RemoteCacheClient remoteCacheClient;
+  @Nullable protected final DiskCacheClient diskCacheClient;
   protected final RemoteOptions options;
   protected final DigestUtil digestUtil;
 
   public RemoteCache(
-      RemoteCacheClient cacheProtocol, RemoteOptions options, DigestUtil digestUtil) {
-    this.cacheProtocol = cacheProtocol;
+      @Nullable RemoteCacheClient remoteCacheClient,
+      @Nullable DiskCacheClient diskCacheClient,
+      RemoteOptions options,
+      DigestUtil digestUtil) {
+    checkArgument(
+        remoteCacheClient != null || diskCacheClient != null,
+        "remoteCacheClient and diskCacheClient cannot be null at the same time");
+    this.remoteCacheClient = remoteCacheClient;
+    this.diskCacheClient = diskCacheClient;
     this.options = options;
     this.digestUtil = digestUtil;
   }
 
-  public CacheCapabilities getCacheCapabilities() throws IOException {
-    return cacheProtocol.getCacheCapabilities();
+  public CacheCapabilities getRemoteCacheCapabilities() throws IOException {
+    if (remoteCacheClient == null) {
+      return CacheCapabilities.getDefaultInstance();
+    }
+    return remoteCacheClient.getCacheCapabilities();
+  }
+
+  public ListenableFuture<String> getRemoteAuthority() {
+    if (remoteCacheClient == null) {
+      return immediateFuture("");
+    }
+    return remoteCacheClient.getAuthority();
   }
 
   public CachedActionResult downloadActionResult(
       RemoteActionExecutionContext context, ActionKey actionKey, boolean inlineOutErr)
       throws IOException, InterruptedException {
-    return getFromFuture(cacheProtocol.downloadActionResult(context, actionKey, inlineOutErr));
+    ListenableFuture<CachedActionResult> future = immediateFuture(null);
+
+    if (diskCacheClient != null && context.getReadCachePolicy().allowDiskCache()) {
+      // If Build without the Bytes is enabled, the future will likely return null
+      // and fallback to remote cache because AC integrity check is enabled and referenced blobs are
+      // probably missing from disk cache due to BwoB.
+      //
+      // TODO(chiwang): With lease service, instead of doing the integrity check against local
+      // filesystem, we can check whether referenced blobs are alive in the lease service to
+      // increase the cache-hit rate for disk cache.
+      future = diskCacheClient.downloadActionResult(context, actionKey, inlineOutErr);
+    }
+
+    if (remoteCacheClient != null && context.getReadCachePolicy().allowRemoteCache()) {
+      future =
+          Futures.transformAsync(
+              future,
+              (result) -> {
+                if (result == null) {
+                  return downloadActionResultFromRemote(context, actionKey, inlineOutErr);
+                } else {
+                  return immediateFuture(result);
+                }
+              },
+              directExecutor());
+    }
+
+    return getFromFuture(future);
+  }
+
+  private ListenableFuture<CachedActionResult> downloadActionResultFromRemote(
+      RemoteActionExecutionContext context, ActionKey actionKey, boolean inlineOutErr) {
+    checkState(remoteCacheClient != null && context.getReadCachePolicy().allowRemoteCache());
+    return Futures.transformAsync(
+        remoteCacheClient.downloadActionResult(context, actionKey, inlineOutErr),
+        (cachedActionResult) -> {
+          if (cachedActionResult == null) {
+            return immediateFuture(null);
+          }
+
+          if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+            return Futures.transform(
+                diskCacheClient.uploadActionResult(
+                    context, actionKey, cachedActionResult.actionResult()),
+                v -> cachedActionResult,
+                directExecutor());
+          }
+
+          return immediateFuture(cachedActionResult);
+        },
+        directExecutor());
   }
 
   /**
@@ -113,13 +185,34 @@ public class RemoteCache extends AbstractReferenceCounted {
     if (Iterables.isEmpty(digests)) {
       return immediateFuture(ImmutableSet.of());
     }
-    return cacheProtocol.findMissingDigests(context, digests);
+
+    ListenableFuture<ImmutableSet<Digest>> diskQuery = immediateFuture(ImmutableSet.of());
+    if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+      diskQuery = diskCacheClient.findMissingDigests(context, digests);
+    }
+
+    ListenableFuture<ImmutableSet<Digest>> remoteQuery = immediateFuture(ImmutableSet.of());
+    if (remoteCacheClient != null && context.getWriteCachePolicy().allowRemoteCache()) {
+      remoteQuery = remoteCacheClient.findMissingDigests(context, digests);
+    }
+
+    ListenableFuture<ImmutableSet<Digest>> diskQueryFinal = diskQuery;
+    ListenableFuture<ImmutableSet<Digest>> remoteQueryFinal = remoteQuery;
+
+    return Futures.whenAllSucceed(remoteQueryFinal, diskQueryFinal)
+        .call(
+            () ->
+                ImmutableSet.<Digest>builder()
+                    .addAll(remoteQueryFinal.get())
+                    .addAll(diskQueryFinal.get())
+                    .build(),
+            directExecutor());
   }
 
-  /** Returns whether the action cache supports updating action results. */
-  public boolean actionCacheSupportsUpdate() {
+  /** Returns whether the remote action cache supports updating action results. */
+  public boolean remoteActionCacheSupportsUpdate() {
     try {
-      return getCacheCapabilities().getActionCacheUpdateCapabilities().getUpdateEnabled();
+      return getRemoteCacheCapabilities().getActionCacheUpdateCapabilities().getUpdateEnabled();
     } catch (IOException ignored) {
       return false;
     }
@@ -128,13 +221,22 @@ public class RemoteCache extends AbstractReferenceCounted {
   /** Upload the action result to the remote cache. */
   public ListenableFuture<Void> uploadActionResult(
       RemoteActionExecutionContext context, ActionKey actionKey, ActionResult actionResult) {
+    ListenableFuture<Void> future = Futures.immediateVoidFuture();
 
-    Completable upload =
-        RxFutures.toCompletable(
-            () -> cacheProtocol.uploadActionResult(context, actionKey, actionResult),
-            directExecutor());
+    if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+      future = diskCacheClient.uploadActionResult(context, actionKey, actionResult);
+    }
+
+    if (remoteCacheClient != null && context.getWriteCachePolicy().allowRemoteCache()) {
+      // TODO(chiwang): Make two uploads in parallel?
+      future =
+          Futures.transformAsync(
+              future,
+              v -> remoteCacheClient.uploadActionResult(context, actionKey, actionResult),
+              directExecutor());
+    }
 
-    return RxFutures.toListenableFuture(upload);
+    return future;
   }
 
   /**
@@ -158,14 +260,30 @@ public class RemoteCache extends AbstractReferenceCounted {
       return COMPLETED_SUCCESS;
     }
 
-    Completable upload =
-        casUploadCache.execute(
-            digest,
-            RxFutures.toCompletable(
-                () -> cacheProtocol.uploadFile(context, digest, file), directExecutor()),
-            force);
+    ListenableFuture<Void> future = Futures.immediateVoidFuture();
+    if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+      future = diskCacheClient.uploadFile(context, digest, file);
+    }
+
+    if (remoteCacheClient != null && context.getWriteCachePolicy().allowRemoteCache()) {
+      // TODO(chiwang): Make two uploads in parallel?
+      future =
+          Futures.transformAsync(
+              future,
+              v -> {
+                Completable upload =
+                    casUploadCache.execute(
+                        digest,
+                        RxFutures.toCompletable(
+                            () -> remoteCacheClient.uploadFile(context, digest, file),
+                            directExecutor()),
+                        force);
+                return RxFutures.toListenableFuture(upload);
+              },
+              directExecutor());
+    }
 
-    return RxFutures.toListenableFuture(upload);
+    return future;
   }
 
   /**
@@ -189,14 +307,32 @@ public class RemoteCache extends AbstractReferenceCounted {
       return COMPLETED_SUCCESS;
     }
 
-    Completable upload =
-        casUploadCache.execute(
-            digest,
-            RxFutures.toCompletable(
-                () -> cacheProtocol.uploadBlob(context, digest, data), directExecutor()),
-            force);
+    ListenableFuture<Void> future = Futures.immediateVoidFuture();
+
+    if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+      future = diskCacheClient.uploadBlob(context, digest, data);
+    }
+
+    if (remoteCacheClient != null && context.getWriteCachePolicy().allowRemoteCache()) {
+      // TODO(chiwang): Make two uploads in parallel?
+      future =
+          Futures.transformAsync(
+              future,
+              v -> {
+                Completable upload =
+                    casUploadCache.execute(
+                        digest,
+                        RxFutures.toCompletable(
+                            () -> remoteCacheClient.uploadBlob(context, digest, data),
+                            directExecutor()),
+                        force);
+
+                return RxFutures.toListenableFuture(upload);
+              },
+              directExecutor());
+    }
 
-    return RxFutures.toListenableFuture(upload);
+    return future;
   }
 
   public ListenableFuture<byte[]> downloadBlob(
@@ -225,7 +361,7 @@ public class RemoteCache extends AbstractReferenceCounted {
     if (digest.getSizeBytes() == 0) {
       return COMPLETED_SUCCESS;
     }
-    var future = cacheProtocol.downloadBlob(context, digest, out);
+    var future = downloadBlob(context, digest, out);
     return Futures.catchingAsync(
         future,
         CacheNotFoundException.class,
@@ -236,6 +372,77 @@ public class RemoteCache extends AbstractReferenceCounted {
         directExecutor());
   }
 
+  private ListenableFuture<Void> downloadBlob(
+      RemoteActionExecutionContext context, Digest digest, OutputStream out) {
+    ListenableFuture<Void> future = immediateFailedFuture(new CacheNotFoundException(digest));
+
+    if (diskCacheClient != null && context.getReadCachePolicy().allowDiskCache()) {
+      future = diskCacheClient.downloadBlob(context, digest, out);
+    }
+
+    if (remoteCacheClient != null && context.getReadCachePolicy().allowRemoteCache()) {
+      future =
+          Futures.catchingAsync(
+              future,
+              CacheNotFoundException.class,
+              (unused) -> downloadBlobFromRemote(context, digest, out),
+              directExecutor());
+    }
+
+    return future;
+  }
+
+  private ListenableFuture<Void> downloadBlobFromRemote(
+      RemoteActionExecutionContext context, Digest digest, OutputStream out) {
+    checkState(remoteCacheClient != null && context.getReadCachePolicy().allowRemoteCache());
+
+    if (diskCacheClient != null && context.getWriteCachePolicy().allowDiskCache()) {
+      Path tempPath = diskCacheClient.getTempPath();
+      LazyFileOutputStream tempOut = new LazyFileOutputStream(tempPath);
+      ListenableFuture<Void> download =
+          cleanupTempFileOnError(
+              remoteCacheClient.downloadBlob(context, digest, tempOut), tempPath, tempOut);
+      return Futures.transformAsync(
+          download,
+          (unused) -> {
+            try {
+              // Fsync temp before we rename it to avoid data loss in the case of machine
+              // crashes (the OS may reorder the writes and the rename).
+              tempOut.syncIfPossible();
+              tempOut.close();
+              diskCacheClient.captureFile(tempPath, digest, Store.CAS);
+            } catch (IOException e) {
+              return immediateFailedFuture(e);
+            }
+            return diskCacheClient.downloadBlob(context, digest, out);
+          },
+          directExecutor());
+    }
+
+    return remoteCacheClient.downloadBlob(context, digest, out);
+  }
+
+  private static ListenableFuture<Void> cleanupTempFileOnError(
+      ListenableFuture<Void> f, Path tempPath, OutputStream tempOut) {
+    return Futures.catchingAsync(
+        f,
+        Exception.class,
+        (rootCause) -> {
+          try {
+            tempOut.close();
+          } catch (IOException e) {
+            rootCause.addSuppressed(e);
+          }
+          try {
+            tempPath.delete();
+          } catch (IOException e) {
+            rootCause.addSuppressed(e);
+          }
+          return immediateFailedFuture(rootCause);
+        },
+        directExecutor());
+  }
+
   /** A reporter that reports download progresses. */
   public static class DownloadProgressReporter {
     private static final Pattern PATTERN = Pattern.compile("^bazel-out/[^/]+/[^/]+/");
@@ -338,7 +545,7 @@ public class RemoteCache extends AbstractReferenceCounted {
       Digest digest,
       DownloadProgressReporter reporter)
       throws IOException {
-    Preconditions.checkNotNull(path.getParentDirectory()).createDirectoryAndParents();
+    checkNotNull(path.getParentDirectory()).createDirectoryAndParents();
     if (digest.getSizeBytes() == 0) {
       // Handle empty file locally.
       FileSystemUtils.writeContent(path, new byte[0]);
@@ -361,7 +568,7 @@ public class RemoteCache extends AbstractReferenceCounted {
     reporter.started();
     OutputStream out = new ReportingOutputStream(new LazyFileOutputStream(path), reporter);
 
-    ListenableFuture<Void> f = cacheProtocol.downloadBlob(context, digest, out);
+    ListenableFuture<Void> f = downloadBlob(context, digest, out);
     f.addListener(
         () -> {
           try {
@@ -421,10 +628,23 @@ public class RemoteCache extends AbstractReferenceCounted {
     return downloads;
   }
 
+  public boolean hasRemoteCache() {
+    return remoteCacheClient != null;
+  }
+
+  public boolean hasDiskCache() {
+    return diskCacheClient != null;
+  }
+
   @Override
   protected void deallocate() {
+    if (diskCacheClient != null) {
+      diskCacheClient.close();
+    }
     casUploadCache.shutdown();
-    cacheProtocol.close();
+    if (remoteCacheClient != null) {
+      remoteCacheClient.close();
+    }
 
     closeCountDownLatch.countDown();
   }
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
index 5de2b5ef52..96bed1120d 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
@@ -20,7 +20,6 @@ import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
-import com.google.devtools.build.lib.remote.disk.DiskAndRemoteCacheClient;
 import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.http.HttpCacheClient;
 import com.google.devtools.build.lib.remote.options.RemoteOptions;
@@ -40,21 +39,11 @@ public final class RemoteCacheClientFactory {
 
   private RemoteCacheClientFactory() {}
 
-  public static RemoteCacheClient createDiskAndRemoteClient(
-      Path workingDirectory,
-      RemoteOptions options,
-      DigestUtil digestUtil,
-      ExecutorService executorService,
-      boolean remoteVerifyDownloads,
-      RemoteCacheClient remoteCacheClient)
-      throws IOException {
-    DiskCacheClient diskCacheClient =
-        createDiskCache(
-            workingDirectory, options, digestUtil, executorService, remoteVerifyDownloads);
-    return new DiskAndRemoteCacheClient(diskCacheClient, remoteCacheClient);
-  }
+  /** A record that hold both a {@link RemoteCacheClient} and {@link DiskCacheClient}. */
+  public record CombinedCacheClient(
+      @Nullable RemoteCacheClient remoteCacheClient, @Nullable DiskCacheClient diskCacheClient) {}
 
-  public static RemoteCacheClient create(
+  public static CombinedCacheClient create(
       RemoteOptions options,
       @Nullable Credentials creds,
       AuthAndTLSOptions authAndTlsOptions,
@@ -64,26 +53,26 @@ public final class RemoteCacheClientFactory {
       RemoteRetrier retrier)
       throws IOException {
     Preconditions.checkNotNull(workingDirectory, "workingDirectory");
-    if (isHttpCache(options) && isDiskCache(options)) {
-      return createDiskAndHttpCache(
-          workingDirectory,
-          options,
-          creds,
-          authAndTlsOptions,
-          digestUtil,
-          executorService,
-          retrier);
-    }
+    RemoteCacheClient httpCacheClient = null;
+    DiskCacheClient diskCacheClient = null;
     if (isHttpCache(options)) {
-      return createHttp(options, creds, authAndTlsOptions, digestUtil, retrier);
+      httpCacheClient = createHttp(options, creds, authAndTlsOptions, digestUtil, retrier);
     }
     if (isDiskCache(options)) {
-      return createDiskCache(
-          workingDirectory, options, digestUtil, executorService, options.remoteVerifyDownloads);
+      diskCacheClient =
+          createDiskCache(
+              workingDirectory,
+              options,
+              digestUtil,
+              executorService,
+              options.remoteVerifyDownloads);
+    }
+    if (httpCacheClient == null && diskCacheClient == null) {
+      throw new IllegalArgumentException(
+          "Unrecognized RemoteOptions configuration: remote Http cache URL and/or local disk cache"
+              + " options expected.");
     }
-    throw new IllegalArgumentException(
-        "Unrecognized RemoteOptions configuration: remote Http cache URL and/or local disk cache"
-            + " options expected.");
+    return new CombinedCacheClient(httpCacheClient, diskCacheClient);
   }
 
   public static boolean isRemoteCacheOptions(RemoteOptions options) {
@@ -137,7 +126,7 @@ public final class RemoteCacheClientFactory {
     }
   }
 
-  private static DiskCacheClient createDiskCache(
+  public static DiskCacheClient createDiskCache(
       Path workingDirectory,
       RemoteOptions options,
       DigestUtil digestUtil,
@@ -149,25 +138,6 @@ public final class RemoteCacheClientFactory {
         cacheDir, options.diskCacheMaxSizeBytes, digestUtil, executorService, verifyDownloads);
   }
 
-  private static RemoteCacheClient createDiskAndHttpCache(
-      Path workingDirectory,
-      RemoteOptions options,
-      Credentials cred,
-      AuthAndTLSOptions authAndTlsOptions,
-      DigestUtil digestUtil,
-      ExecutorService executorService,
-      RemoteRetrier retrier)
-      throws IOException {
-    RemoteCacheClient httpCache = createHttp(options, cred, authAndTlsOptions, digestUtil, retrier);
-    return createDiskAndRemoteClient(
-        workingDirectory,
-        options,
-        digestUtil,
-        executorService,
-        options.remoteVerifyDownloads,
-        httpCache);
-  }
-
   public static boolean isDiskCache(RemoteOptions options) {
     return options.diskCache != null && !options.diskCache.isEmpty();
   }
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionCache.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionCache.java
index cbc029eeca..c6fd785800 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionCache.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionCache.java
@@ -40,6 +40,7 @@ import com.google.devtools.build.lib.remote.common.CacheNotFoundException;
 import com.google.devtools.build.lib.remote.common.LostInputsEvent;
 import com.google.devtools.build.lib.remote.common.RemoteActionExecutionContext;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
+import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.merkletree.MerkleTree;
 import com.google.devtools.build.lib.remote.merkletree.MerkleTree.PathOrBytes;
 import com.google.devtools.build.lib.remote.options.RemoteOptions;
@@ -61,6 +62,7 @@ import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
 
 /** A {@link RemoteCache} with additional functionality needed for remote execution. */
 public class RemoteExecutionCache extends RemoteCache {
@@ -99,8 +101,11 @@ public class RemoteExecutionCache extends RemoteCache {
       };
 
   public RemoteExecutionCache(
-      RemoteCacheClient protocolImpl, RemoteOptions options, DigestUtil digestUtil) {
-    super(protocolImpl, options, digestUtil);
+      RemoteCacheClient remoteCacheClient,
+      @Nullable DiskCacheClient diskCacheClient,
+      RemoteOptions options,
+      DigestUtil digestUtil) {
+    super(checkNotNull(remoteCacheClient), diskCacheClient, options, digestUtil);
   }
 
   @VisibleForTesting
@@ -175,13 +180,13 @@ public class RemoteExecutionCache extends RemoteCache {
       Reporter reporter) {
     Directory node = merkleTree.getDirectoryByDigest(digest);
     if (node != null) {
-      return cacheProtocol.uploadBlob(context, digest, node.toByteString());
+      return remoteCacheClient.uploadBlob(context, digest, node.toByteString());
     }
 
     PathOrBytes file = merkleTree.getFileByDigest(digest);
     if (file != null) {
       if (file.getBytes() != null) {
-        return cacheProtocol.uploadBlob(context, digest, file.getBytes());
+        return remoteCacheClient.uploadBlob(context, digest, file.getBytes());
       }
 
       var path = checkNotNull(file.getPath());
@@ -196,12 +201,12 @@ public class RemoteExecutionCache extends RemoteCache {
       } catch (IOException e) {
         return immediateFailedFuture(e);
       }
-      return cacheProtocol.uploadFile(context, digest, path);
+      return remoteCacheClient.uploadFile(context, digest, path);
     }
 
     Message message = additionalInputs.get(digest);
     if (message != null) {
-      return cacheProtocol.uploadBlob(context, digest, message.toByteString());
+      return remoteCacheClient.uploadBlob(context, digest, message.toByteString());
     }
 
     return immediateFailedFuture(
@@ -315,7 +320,8 @@ public class RemoteExecutionCache extends RemoteCache {
                                   if (digestsToQuery.isEmpty()) {
                                     return immediateFuture(ImmutableSet.of());
                                   }
-                                  return findMissingDigests(context, digestsToQuery);
+                                  return remoteCacheClient.findMissingDigests(
+                                      context, digestsToQuery);
                                 },
                                 directExecutor())
                             .map(
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
index 647dd63243..1a2f9688be 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java
@@ -16,7 +16,6 @@ package com.google.devtools.build.lib.remote;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Strings.isNullOrEmpty;
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
@@ -286,12 +285,12 @@ public class RemoteExecutionService {
     return command.setWorkingDirectory(remotePathResolver.getWorkingDirectory()).build();
   }
 
-  private static boolean useRemoteCache(RemoteOptions options) {
-    return !isNullOrEmpty(options.remoteCache) || !isNullOrEmpty(options.remoteExecutor);
+  private boolean useRemoteCache() {
+    return remoteCache != null && remoteCache.hasRemoteCache();
   }
 
-  private static boolean useDiskCache(RemoteOptions options) {
-    return options.diskCache != null && !options.diskCache.isEmpty();
+  private boolean useDiskCache() {
+    return remoteCache != null && remoteCache.hasDiskCache();
   }
 
   public CachePolicy getReadCachePolicy(Spawn spawn) {
@@ -299,20 +298,9 @@ public class RemoteExecutionService {
       return CachePolicy.NO_CACHE;
     }
 
-    boolean allowDiskCache = false;
-    boolean allowRemoteCache = false;
-
-    if (useRemoteCache(remoteOptions)) {
-      allowRemoteCache = remoteOptions.remoteAcceptCached && Spawns.mayBeCachedRemotely(spawn);
-      if (useDiskCache(remoteOptions)) {
-        // Combined cache. Disk cache is treated as local cache. Actions which are tagged with
-        // `no-remote-cache` can still hit the disk cache.
-        allowDiskCache = Spawns.mayBeCached(spawn);
-      }
-    } else {
-      // Disk cache only
-      allowDiskCache = Spawns.mayBeCached(spawn);
-    }
+    boolean allowRemoteCache =
+        useRemoteCache() && remoteOptions.remoteAcceptCached && Spawns.mayBeCachedRemotely(spawn);
+    boolean allowDiskCache = useDiskCache() && Spawns.mayBeCached(spawn);
 
     return CachePolicy.create(allowRemoteCache, allowDiskCache);
   }
@@ -322,22 +310,11 @@ public class RemoteExecutionService {
       return CachePolicy.NO_CACHE;
     }
 
-    boolean allowDiskCache = false;
-    boolean allowRemoteCache = false;
-
-    if (useRemoteCache(remoteOptions)) {
-      allowRemoteCache =
-          shouldUploadLocalResultsToRemoteCache(remoteOptions, spawn.getExecutionInfo())
-              && remoteCache.actionCacheSupportsUpdate();
-      if (useDiskCache(remoteOptions)) {
-        // Combined cache. Treat the disk cache part as local cache. Actions which are tagged with
-        // `no-remote-cache` can still hit the disk cache.
-        allowDiskCache = Spawns.mayBeCached(spawn);
-      }
-    } else {
-      // Disk cache only
-      allowDiskCache = Spawns.mayBeCached(spawn);
-    }
+    boolean allowRemoteCache =
+        useRemoteCache()
+            && shouldUploadLocalResultsToRemoteCache(remoteOptions, spawn.getExecutionInfo())
+            && remoteCache.remoteActionCacheSupportsUpdate();
+    boolean allowDiskCache = useDiskCache() && Spawns.mayBeCached(spawn);
 
     return CachePolicy.create(allowRemoteCache, allowDiskCache);
   }
@@ -1310,7 +1287,7 @@ public class RemoteExecutionService {
       // When downloading outputs from just remotely executed action, the action result comes from
       // Execution response which means, if disk cache is enabled, action result hasn't been
       // uploaded to it. Upload action result to disk cache here so next build could hit it.
-      if (useDiskCache(remoteOptions) && result.executeResponse != null) {
+      if (useDiskCache() && result.executeResponse != null) {
         getFromFuture(
             remoteCache.uploadActionResult(
                 context.withWriteCachePolicy(CachePolicy.DISK_CACHE_ONLY),
@@ -1583,7 +1560,7 @@ public class RemoteExecutionService {
 
             return UploadManifest.create(
                 remoteOptions,
-                remoteCache.getCacheCapabilities(),
+                remoteCache.getRemoteCacheCapabilities(),
                 digestUtil,
                 action.getRemotePathResolver(),
                 action.getActionKey(),
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
index f2bc253ab1..6b0883aa06 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
@@ -56,10 +56,12 @@ import com.google.devtools.build.lib.exec.ModuleActionContextRegistry;
 import com.google.devtools.build.lib.exec.SpawnStrategyRegistry;
 import com.google.devtools.build.lib.profiler.Profiler;
 import com.google.devtools.build.lib.remote.LeaseService.LeaseExtension;
+import com.google.devtools.build.lib.remote.RemoteCacheClientFactory.CombinedCacheClient;
 import com.google.devtools.build.lib.remote.RemoteServerCapabilities.ServerCapabilitiesRequirement;
 import com.google.devtools.build.lib.remote.circuitbreaker.CircuitBreakerFactory;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
 import com.google.devtools.build.lib.remote.common.RemoteExecutionClient;
+import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.downloader.GrpcRemoteDownloader;
 import com.google.devtools.build.lib.remote.http.DownloadTimeoutException;
 import com.google.devtools.build.lib.remote.http.HttpException;
@@ -221,11 +223,11 @@ public final class RemoteModule extends BlazeModule {
       RemoteOptions remoteOptions,
       DigestUtil digestUtil,
       ExecutorService executorService) {
-    RemoteCacheClient cacheClient;
+    CombinedCacheClient combinedCacheClient;
     Retrier.CircuitBreaker circuitBreaker =
         CircuitBreakerFactory.createCircuitBreaker(remoteOptions);
     try {
-      cacheClient =
+      combinedCacheClient =
           RemoteCacheClientFactory.create(
               remoteOptions,
               credentials,
@@ -239,7 +241,12 @@ public final class RemoteModule extends BlazeModule {
       handleInitFailure(env, e, Code.CACHE_INIT_FAILURE);
       return;
     }
-    RemoteCache remoteCache = new RemoteCache(cacheClient, remoteOptions, digestUtil);
+    RemoteCache remoteCache =
+        new RemoteCache(
+            combinedCacheClient.remoteCacheClient(),
+            combinedCacheClient.diskCacheClient(),
+            remoteOptions,
+            digestUtil);
     actionContextProvider =
         RemoteActionContextProvider.createForRemoteCaching(
             executorService,
@@ -586,22 +593,22 @@ public final class RemoteModule extends BlazeModule {
       }
     }
 
-    RemoteCacheClient cacheClient =
+    RemoteCacheClient remoteCacheClient =
         new GrpcCacheClient(
             cacheChannel.retain(), callCredentialsProvider, remoteOptions, retrier, digestUtil);
     cacheChannel.release();
+    DiskCacheClient diskCacheClient = null;
 
     if (enableRemoteExecution) {
       if (enableDiskCache) {
         try {
-          cacheClient =
-              RemoteCacheClientFactory.createDiskAndRemoteClient(
+          diskCacheClient =
+              RemoteCacheClientFactory.createDiskCache(
                   env.getWorkingDirectory(),
                   remoteOptions,
                   digestUtil,
                   executorService,
-                  remoteOptions.remoteVerifyDownloads,
-                  cacheClient);
+                  remoteOptions.remoteVerifyDownloads);
         } catch (Exception e) {
           handleInitFailure(env, e, Code.CACHE_INIT_FAILURE);
           return;
@@ -631,7 +638,7 @@ public final class RemoteModule extends BlazeModule {
       }
       execChannel.release();
       RemoteExecutionCache remoteCache =
-          new RemoteExecutionCache(cacheClient, remoteOptions, digestUtil);
+          new RemoteExecutionCache(remoteCacheClient, diskCacheClient, remoteOptions, digestUtil);
       actionContextProvider =
           RemoteActionContextProvider.createForRemoteExecution(
               executorService,
@@ -656,21 +663,21 @@ public final class RemoteModule extends BlazeModule {
     } else {
       if (enableDiskCache) {
         try {
-          cacheClient =
-              RemoteCacheClientFactory.createDiskAndRemoteClient(
+          diskCacheClient =
+              RemoteCacheClientFactory.createDiskCache(
                   env.getWorkingDirectory(),
                   remoteOptions,
                   digestUtil,
                   executorService,
-                  remoteOptions.remoteVerifyDownloads,
-                  cacheClient);
+                  remoteOptions.remoteVerifyDownloads);
         } catch (Exception e) {
           handleInitFailure(env, e, Code.CACHE_INIT_FAILURE);
           return;
         }
       }
 
-      RemoteCache remoteCache = new RemoteCache(cacheClient, remoteOptions, digestUtil);
+      RemoteCache remoteCache =
+          new RemoteCache(remoteCacheClient, diskCacheClient, remoteOptions, digestUtil);
       actionContextProvider =
           RemoteActionContextProvider.createForRemoteCaching(
               executorService,
@@ -731,7 +738,7 @@ public final class RemoteModule extends BlazeModule {
               downloaderChannel.retain(),
               Optional.ofNullable(callCredentials),
               retrier,
-              cacheClient,
+              remoteCacheClient,
               digestUtil.getDigestFunction(),
               remoteOptions,
               verboseFailures,
diff --git a/src/main/java/com/google/devtools/build/lib/remote/disk/DiskAndRemoteCacheClient.java b/src/main/java/com/google/devtools/build/lib/remote/disk/DiskAndRemoteCacheClient.java
deleted file mode 100644
index 67e71faf82..0000000000
--- a/src/main/java/com/google/devtools/build/lib/remote/disk/DiskAndRemoteCacheClient.java
+++ /dev/null
@@ -1,264 +0,0 @@
-// Copyright 2019 The Bazel Authors. All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package com.google.devtools.build.lib.remote.disk;
-
-import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
-import static com.google.common.util.concurrent.Futures.immediateFuture;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-
-import build.bazel.remote.execution.v2.ActionResult;
-import build.bazel.remote.execution.v2.CacheCapabilities;
-import build.bazel.remote.execution.v2.Digest;
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.devtools.build.lib.remote.Store;
-import com.google.devtools.build.lib.remote.common.CacheNotFoundException;
-import com.google.devtools.build.lib.remote.common.LazyFileOutputStream;
-import com.google.devtools.build.lib.remote.common.RemoteActionExecutionContext;
-import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
-import com.google.devtools.build.lib.vfs.Path;
-import com.google.protobuf.ByteString;
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * A {@link RemoteCacheClient} implementation combining two blob stores. A local disk blob store and
- * a remote blob store. If a blob isn't found in the first store, the second store is used, and the
- * blob added to the first. Put puts the blob on both stores.
- */
-public final class DiskAndRemoteCacheClient implements RemoteCacheClient {
-
-  private final RemoteCacheClient remoteCache;
-  private final DiskCacheClient diskCache;
-
-  public DiskAndRemoteCacheClient(DiskCacheClient diskCache, RemoteCacheClient remoteCache) {
-    this.diskCache = Preconditions.checkNotNull(diskCache);
-    this.remoteCache = Preconditions.checkNotNull(remoteCache);
-  }
-
-  @Override
-  public ListenableFuture<Void> uploadActionResult(
-      RemoteActionExecutionContext context, ActionKey actionKey, ActionResult actionResult) {
-    ListenableFuture<Void> future = Futures.immediateVoidFuture();
-
-    if (context.getWriteCachePolicy().allowDiskCache()) {
-      future = diskCache.uploadActionResult(context, actionKey, actionResult);
-    }
-
-    if (context.getWriteCachePolicy().allowRemoteCache()) {
-      future =
-          Futures.transformAsync(
-              future,
-              v -> remoteCache.uploadActionResult(context, actionKey, actionResult),
-              directExecutor());
-    }
-    return future;
-  }
-
-  @Override
-  public void close() {
-    diskCache.close();
-    remoteCache.close();
-  }
-
-  @Override
-  public ListenableFuture<Void> uploadFile(
-      RemoteActionExecutionContext context, Digest digest, Path file) {
-    ListenableFuture<Void> future = Futures.immediateVoidFuture();
-
-    if (context.getWriteCachePolicy().allowDiskCache()) {
-      future = diskCache.uploadFile(context, digest, file);
-    }
-
-    if (context.getWriteCachePolicy().allowRemoteCache()) {
-      future =
-          Futures.transformAsync(
-              future, v -> remoteCache.uploadFile(context, digest, file), directExecutor());
-    }
-    return future;
-  }
-
-  @Override
-  public ListenableFuture<Void> uploadBlob(
-      RemoteActionExecutionContext context, Digest digest, ByteString data) {
-    ListenableFuture<Void> future = Futures.immediateVoidFuture();
-
-    if (context.getWriteCachePolicy().allowDiskCache()) {
-      future = diskCache.uploadBlob(context, digest, data);
-    }
-
-    if (context.getWriteCachePolicy().allowRemoteCache()) {
-      future =
-          Futures.transformAsync(
-              future, v -> remoteCache.uploadBlob(context, digest, data), directExecutor());
-    }
-    return future;
-  }
-
-  @Override
-  public ListenableFuture<ImmutableSet<Digest>> findMissingDigests(
-      RemoteActionExecutionContext context, Iterable<Digest> digests) {
-    ListenableFuture<ImmutableSet<Digest>> diskQuery = immediateFuture(ImmutableSet.of());
-    if (context.getWriteCachePolicy().allowDiskCache()) {
-      diskQuery = diskCache.findMissingDigests(context, digests);
-    }
-
-    ListenableFuture<ImmutableSet<Digest>> remoteQuery = immediateFuture(ImmutableSet.of());
-    if (context.getWriteCachePolicy().allowRemoteCache()) {
-      remoteQuery = remoteCache.findMissingDigests(context, digests);
-    }
-
-    ListenableFuture<ImmutableSet<Digest>> diskQueryFinal = diskQuery;
-    ListenableFuture<ImmutableSet<Digest>> remoteQueryFinal = remoteQuery;
-
-    return Futures.whenAllSucceed(remoteQueryFinal, diskQueryFinal)
-        .call(
-            () ->
-                ImmutableSet.<Digest>builder()
-                    .addAll(remoteQueryFinal.get())
-                    .addAll(diskQueryFinal.get())
-                    .build(),
-            directExecutor());
-  }
-
-  private Path getTempPath() {
-    return diskCache.getTempPath();
-  }
-
-  private static ListenableFuture<Void> cleanupTempFileOnError(
-      ListenableFuture<Void> f, Path tempPath, OutputStream tempOut) {
-    return Futures.catchingAsync(
-        f,
-        Exception.class,
-        (rootCause) -> {
-          try {
-            tempOut.close();
-          } catch (IOException e) {
-            rootCause.addSuppressed(e);
-          }
-          try {
-            tempPath.delete();
-          } catch (IOException e) {
-            rootCause.addSuppressed(e);
-          }
-          return immediateFailedFuture(rootCause);
-        },
-        directExecutor());
-  }
-
-  @Override
-  public ListenableFuture<Void> downloadBlob(
-      RemoteActionExecutionContext context, Digest digest, OutputStream out) {
-    if (context.getReadCachePolicy().allowDiskCache()) {
-      return Futures.catchingAsync(
-          diskCache.downloadBlob(context, digest, out),
-          CacheNotFoundException.class,
-          (unused) -> downloadBlobFromRemote(context, digest, out),
-          directExecutor());
-    } else {
-      return downloadBlobFromRemote(context, digest, out);
-    }
-  }
-
-  private ListenableFuture<Void> downloadBlobFromRemote(
-      RemoteActionExecutionContext context, Digest digest, OutputStream out) {
-    if (context.getReadCachePolicy().allowRemoteCache()) {
-      Path tempPath = getTempPath();
-      LazyFileOutputStream tempOut = new LazyFileOutputStream(tempPath);
-
-      ListenableFuture<Void> download =
-          cleanupTempFileOnError(
-              remoteCache.downloadBlob(context, digest, tempOut), tempPath, tempOut);
-      return Futures.transformAsync(
-          download,
-          (unused) -> {
-            try {
-              // Fsync temp before we rename it to avoid data loss in the case of machine
-              // crashes (the OS may reorder the writes and the rename).
-              tempOut.syncIfPossible();
-              tempOut.close();
-              diskCache.captureFile(tempPath, digest, Store.CAS);
-            } catch (IOException e) {
-              return immediateFailedFuture(e);
-            }
-            return diskCache.downloadBlob(context, digest, out);
-          },
-          directExecutor());
-    } else {
-      return immediateFuture(null);
-    }
-  }
-
-  private ListenableFuture<CachedActionResult> downloadActionResultFromRemote(
-      RemoteActionExecutionContext context, ActionKey actionKey, boolean inlineOutErr) {
-    return Futures.transformAsync(
-        remoteCache.downloadActionResult(context, actionKey, inlineOutErr),
-        (cachedActionResult) -> {
-          if (cachedActionResult == null) {
-            return immediateFuture(null);
-          } else {
-            return Futures.transform(
-                diskCache.uploadActionResult(context, actionKey, cachedActionResult.actionResult()),
-                v -> cachedActionResult,
-                directExecutor());
-          }
-        },
-        directExecutor());
-  }
-
-  @Override
-  public CacheCapabilities getCacheCapabilities() throws IOException {
-    return remoteCache.getCacheCapabilities();
-  }
-
-  @Override
-  public ListenableFuture<String> getAuthority() {
-    return remoteCache.getAuthority();
-  }
-
-  @Override
-  public ListenableFuture<CachedActionResult> downloadActionResult(
-      RemoteActionExecutionContext context, ActionKey actionKey, boolean inlineOutErr) {
-    ListenableFuture<CachedActionResult> future = immediateFuture(null);
-
-    if (context.getReadCachePolicy().allowDiskCache()) {
-      // If Build without the Bytes is enabled, the future will likely return null
-      // and fallback to remote cache because AC integrity check is enabled and referenced blobs are
-      // probably missing from disk cache due to BwoB.
-      //
-      // TODO(chiwang): With lease service, instead of doing the integrity check against local
-      // filesystem, we can check whether referenced blobs are alive in the lease service to
-      // increase the cache-hit rate for disk cache.
-      future = diskCache.downloadActionResult(context, actionKey, inlineOutErr);
-    }
-
-    if (context.getReadCachePolicy().allowRemoteCache()) {
-      future =
-          Futures.transformAsync(
-              future,
-              (result) -> {
-                if (result == null) {
-                  return downloadActionResultFromRemote(context, actionKey, inlineOutErr);
-                } else {
-                  return immediateFuture(result);
-                }
-              },
-              directExecutor());
-    }
-
-    return future;
-  }
-}
diff --git a/src/main/java/com/google/devtools/build/lib/remote/disk/DiskCacheClient.java b/src/main/java/com/google/devtools/build/lib/remote/disk/DiskCacheClient.java
index bf460ad6ef..6d2c6e7ccd 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/disk/DiskCacheClient.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/disk/DiskCacheClient.java
@@ -151,7 +151,7 @@ public class DiskCacheClient implements RemoteCacheClient {
    * <p>The caller must ensure that the digest is correct and the file has been recently modified.
    * This method should only be called by the combined cache implementation.
    */
-  void captureFile(Path src, Digest digest, Store store) throws IOException {
+  public void captureFile(Path src, Digest digest, Store store) throws IOException {
     Path target = toPath(digest, store);
     target.getParentDirectory().createDirectoryAndParents();
     src.renameTo(target);
@@ -345,7 +345,7 @@ public class DiskCacheClient implements RemoteCacheClient {
     return immediateFuture(ImmutableSet.copyOf(digests));
   }
 
-  Path getTempPath() {
+  public Path getTempPath() {
     return tmpRoot.getChild(UUID.randomUUID().toString());
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploaderTest.java b/src/test/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploaderTest.java
index 9f0c55ef5d..6262093784 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploaderTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/ByteStreamBuildEventArtifactUploaderTest.java
@@ -595,7 +595,7 @@ public class ByteStreamBuildEventArtifactUploaderTest {
         .when(cacheClient)
         .findMissingDigests(any(), any());
 
-    return new RemoteCache(cacheClient, remoteOptions, DIGEST_UTIL);
+    return new RemoteCache(cacheClient, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
   }
 
   private ByteStreamBuildEventArtifactUploader newArtifactUploader(RemoteCache remoteCache) {
diff --git a/src/test/java/com/google/devtools/build/lib/remote/GrpcCacheClientTest.java b/src/test/java/com/google/devtools/build/lib/remote/GrpcCacheClientTest.java
index 52f26def02..250983d59d 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/GrpcCacheClientTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/GrpcCacheClientTest.java
@@ -310,7 +310,8 @@ public class GrpcCacheClientTest {
   public void testVirtualActionInputSupport() throws Exception {
     RemoteOptions options = Options.getDefaults(RemoteOptions.class);
     RemoteExecutionCache client =
-        new RemoteExecutionCache(newClient(options), options, DIGEST_UTIL);
+        new RemoteExecutionCache(
+            newClient(options), /* diskCacheClient= */ null, options, DIGEST_UTIL);
     PathFragment execPath = PathFragment.create("my/exec/path");
     VirtualActionInput virtualActionInput =
         ActionsTestUtil.createVirtualActionInput(execPath, "hello");
@@ -501,7 +502,8 @@ public class GrpcCacheClientTest {
     // arrange
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     Digest fooDigest = DIGEST_UTIL.computeAsUtf8("foo-contents");
     Digest barDigest = DIGEST_UTIL.computeAsUtf8("bar-contents");
@@ -524,7 +526,8 @@ public class GrpcCacheClientTest {
   public void testUploadDirectory() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest fooDigest =
         fakeFileCache.createScratchInput(ActionInputHelper.fromPath("a/foo"), "xyz");
@@ -592,7 +595,8 @@ public class GrpcCacheClientTest {
   public void testUploadDirectoryEmpty() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest barDigest =
         fakeFileCache.createScratchInputDirectory(
@@ -635,7 +639,8 @@ public class GrpcCacheClientTest {
   public void testUploadDirectoryNested() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest wobbleDigest =
         fakeFileCache.createScratchInput(ActionInputHelper.fromPath("bar/test/wobble"), "xyz");
@@ -712,7 +717,7 @@ public class GrpcCacheClientTest {
     UploadManifest uploadManifest =
         UploadManifest.create(
             remoteCache.options,
-            remoteCache.getCacheCapabilities(),
+            remoteCache.getRemoteCacheCapabilities(),
             remoteCache.digestUtil,
             remotePathResolver,
             actionKey,
@@ -798,7 +803,8 @@ public class GrpcCacheClientTest {
     serviceRegistry.addService(ServerInterceptors.intercept(actionCache, interceptor));
 
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
     remoteCache.downloadActionResult(
         context,
         DIGEST_UTIL.asActionKey(DIGEST_UTIL.computeAsUtf8("key")),
@@ -809,7 +815,8 @@ public class GrpcCacheClientTest {
   public void testUpload() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest fooDigest =
         fakeFileCache.createScratchInput(ActionInputHelper.fromPath("a/foo"), "xyz");
@@ -885,7 +892,8 @@ public class GrpcCacheClientTest {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     remoteOptions.maxOutboundMessageSize = 80; // Enough for one digest, but not two.
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest fooDigest =
         fakeFileCache.createScratchInput(ActionInputHelper.fromPath("a/foo"), "xyz");
@@ -950,7 +958,8 @@ public class GrpcCacheClientTest {
   public void testUploadCacheMissesWithRetries() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     GrpcCacheClient client = newClient(remoteOptions);
-    RemoteCache remoteCache = new RemoteCache(client, remoteOptions, DIGEST_UTIL);
+    RemoteCache remoteCache =
+        new RemoteCache(client, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
 
     final Digest fooDigest =
         fakeFileCache.createScratchInput(ActionInputHelper.fromPath("a/foo"), "xyz");
diff --git a/src/test/java/com/google/devtools/build/lib/remote/InMemoryRemoteCache.java b/src/test/java/com/google/devtools/build/lib/remote/InMemoryRemoteCache.java
index e77372af3e..20f57bea9f 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/InMemoryRemoteCache.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/InMemoryRemoteCache.java
@@ -31,19 +31,16 @@ class InMemoryRemoteCache extends RemoteExecutionCache {
 
   InMemoryRemoteCache(
       Map<Digest, byte[]> casEntries, RemoteOptions options, DigestUtil digestUtil) {
-    super(
-        new InMemoryCacheClient(casEntries),
-        options,
-        digestUtil);
+    super(new InMemoryCacheClient(casEntries), /* diskCacheClient= */ null, options, digestUtil);
   }
 
   InMemoryRemoteCache(RemoteOptions options, DigestUtil digestUtil) {
-    super(new InMemoryCacheClient(), options, digestUtil);
+    super(new InMemoryCacheClient(), /* diskCacheClient= */ null, options, digestUtil);
   }
 
   InMemoryRemoteCache(
       RemoteCacheClient cacheProtocol, RemoteOptions options, DigestUtil digestUtil) {
-    super(cacheProtocol, options, digestUtil);
+    super(cacheProtocol, /* diskCacheClient= */ null, options, digestUtil);
   }
 
   Digest addContents(RemoteActionExecutionContext context, String txt)
@@ -54,7 +51,7 @@ class InMemoryRemoteCache extends RemoteExecutionCache {
   Digest addContents(RemoteActionExecutionContext context, byte[] bytes)
       throws IOException, InterruptedException {
     Digest digest = digestUtil.compute(bytes);
-    Utils.getFromFuture(cacheProtocol.uploadBlob(context, digest, ByteString.copyFrom(bytes)));
+    Utils.getFromFuture(remoteCacheClient.uploadBlob(context, digest, ByteString.copyFrom(bytes)));
     return digest;
   }
 
@@ -65,25 +62,25 @@ class InMemoryRemoteCache extends RemoteExecutionCache {
 
   Digest addException(String txt, Exception e) {
     Digest digest = digestUtil.compute(txt.getBytes(UTF_8));
-    ((InMemoryCacheClient) cacheProtocol).addDownloadFailure(digest, e);
+    ((InMemoryCacheClient) remoteCacheClient).addDownloadFailure(digest, e);
     return digest;
   }
 
   Digest addException(Message m, Exception e) {
     Digest digest = digestUtil.compute(m);
-    ((InMemoryCacheClient) cacheProtocol).addDownloadFailure(digest, e);
+    ((InMemoryCacheClient) remoteCacheClient).addDownloadFailure(digest, e);
     return digest;
   }
 
   int getNumSuccessfulDownloads() {
-    return ((InMemoryCacheClient) cacheProtocol).getNumSuccessfulDownloads();
+    return ((InMemoryCacheClient) remoteCacheClient).getNumSuccessfulDownloads();
   }
 
   int getNumFailedDownloads() {
-    return ((InMemoryCacheClient) cacheProtocol).getNumFailedDownloads();
+    return ((InMemoryCacheClient) remoteCacheClient).getNumFailedDownloads();
   }
 
   Map<Digest, Integer> getNumFindMissingDigests() {
-    return ((InMemoryCacheClient) cacheProtocol).getNumFindMissingDigests();
+    return ((InMemoryCacheClient) remoteCacheClient).getNumFindMissingDigests();
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteActionInputFetcherTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteActionInputFetcherTest.java
index 8fee1fc6dc..3793c6228c 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteActionInputFetcherTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteActionInputFetcherTest.java
@@ -173,6 +173,7 @@ public class RemoteActionInputFetcherTest extends ActionInputPrefetcherTestBase
           DigestUtil.buildDigest(entry.getKey().asBytes(), entry.getValue().length),
           entry.getValue());
     }
-    return new RemoteCache(new InMemoryCacheClient(cacheEntries), options, digestUtil);
+    return new RemoteCache(
+        new InMemoryCacheClient(cacheEntries), /* diskCacheClient= */ null, options, digestUtil);
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactoryTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactoryTest.java
index de368904d8..4662313a90 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactoryTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactoryTest.java
@@ -21,9 +21,6 @@ import com.google.common.util.concurrent.ListeningScheduledExecutorService;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
 import com.google.devtools.build.lib.clock.JavaClock;
-import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
-import com.google.devtools.build.lib.remote.disk.DiskAndRemoteCacheClient;
-import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.http.HttpCacheClient;
 import com.google.devtools.build.lib.remote.options.RemoteOptions;
 import com.google.devtools.build.lib.remote.util.DigestUtil;
@@ -75,7 +72,7 @@ public class RemoteCacheClientFactoryTest {
     remoteOptions.diskCache = PathFragment.create("/etc/something/cache/here");
     fs.getPath("/etc/something/cache/here").createDirectoryAndParents();
 
-    RemoteCacheClient blobStore =
+    var blobStore =
         RemoteCacheClientFactory.create(
             remoteOptions,
             /* creds= */ null,
@@ -85,7 +82,8 @@ public class RemoteCacheClientFactoryTest {
             executorService,
             retrier);
 
-    assertThat(blobStore).isInstanceOf(DiskAndRemoteCacheClient.class);
+    assertThat(blobStore.remoteCacheClient()).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.diskCacheClient()).isNotNull();
   }
 
   @Test
@@ -94,7 +92,7 @@ public class RemoteCacheClientFactoryTest {
     remoteOptions.diskCache = PathFragment.create("/etc/something/cache/here");
     assertThat(workingDirectory.exists()).isFalse();
 
-    RemoteCacheClient blobStore =
+    var blobStore =
         RemoteCacheClientFactory.create(
             remoteOptions,
             /* creds= */ null,
@@ -104,7 +102,8 @@ public class RemoteCacheClientFactoryTest {
             executorService,
             retrier);
 
-    assertThat(blobStore).isInstanceOf(DiskAndRemoteCacheClient.class);
+    assertThat(blobStore.remoteCacheClient()).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.diskCacheClient()).isNotNull();
     assertThat(workingDirectory.exists()).isTrue();
   }
 
@@ -132,7 +131,7 @@ public class RemoteCacheClientFactoryTest {
     remoteOptions.remoteCache = "http://doesnotexist.com";
     remoteOptions.remoteProxy = "unix://some-proxy";
 
-    RemoteCacheClient blobStore =
+    var blobStore =
         RemoteCacheClientFactory.create(
             remoteOptions,
             /* creds= */ null,
@@ -142,7 +141,8 @@ public class RemoteCacheClientFactoryTest {
             executorService,
             retrier);
 
-    assertThat(blobStore).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.remoteCacheClient()).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.diskCacheClient()).isNull();
   }
 
   @Test
@@ -170,7 +170,7 @@ public class RemoteCacheClientFactoryTest {
   public void createHttpCacheWithoutProxy() throws IOException {
     remoteOptions.remoteCache = "http://doesnotexist.com";
 
-    RemoteCacheClient blobStore =
+    var blobStore =
         RemoteCacheClientFactory.create(
             remoteOptions,
             /* creds= */ null,
@@ -180,14 +180,15 @@ public class RemoteCacheClientFactoryTest {
             executorService,
             retrier);
 
-    assertThat(blobStore).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.remoteCacheClient()).isInstanceOf(HttpCacheClient.class);
+    assertThat(blobStore.diskCacheClient()).isNull();
   }
 
   @Test
   public void createDiskCache() throws IOException {
     remoteOptions.diskCache = PathFragment.create("/etc/something/cache/here");
 
-    RemoteCacheClient blobStore =
+    var blobStore =
         RemoteCacheClientFactory.create(
             remoteOptions,
             /* creds= */ null,
@@ -197,7 +198,8 @@ public class RemoteCacheClientFactoryTest {
             executorService,
             retrier);
 
-    assertThat(blobStore).isInstanceOf(DiskCacheClient.class);
+    assertThat(blobStore.remoteCacheClient()).isNull();
+    assertThat(blobStore.diskCacheClient()).isNotNull();
   }
 
   @Test
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheTest.java
index 6fd7d0acde..763d3e5e28 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteCacheTest.java
@@ -435,7 +435,7 @@ public class RemoteCacheTest {
           throws Exception {
     // arrange
     RemoteCacheClient cacheProtocol = spy(new InMemoryCacheClient());
-    RemoteExecutionCache remoteCache = spy(newRemoteExecutionCache(cacheProtocol));
+    RemoteExecutionCache remoteCache = newRemoteExecutionCache(cacheProtocol);
 
     SettableFuture<ImmutableSet<Digest>> findMissingDigestsFuture = SettableFuture.create();
     CountDownLatch findMissingDigestsCalled = new CountDownLatch(1);
@@ -444,7 +444,7 @@ public class RemoteCacheTest {
               findMissingDigestsCalled.countDown();
               return findMissingDigestsFuture;
             })
-        .when(remoteCache)
+        .when(cacheProtocol)
         .findMissingDigests(any(), any());
     Deque<SettableFuture<Void>> futures = new ConcurrentLinkedDeque<>();
     CountDownLatch uploadBlobCalls = new CountDownLatch(2);
@@ -681,11 +681,18 @@ public class RemoteCacheTest {
   }
 
   private RemoteCache newRemoteCache(RemoteCacheClient remoteCacheClient) {
-    return new RemoteCache(remoteCacheClient, Options.getDefaults(RemoteOptions.class), digestUtil);
+    return new RemoteCache(
+        remoteCacheClient,
+        /* diskCacheClient= */ null,
+        Options.getDefaults(RemoteOptions.class),
+        digestUtil);
   }
 
   private RemoteExecutionCache newRemoteExecutionCache(RemoteCacheClient remoteCacheClient) {
     return new RemoteExecutionCache(
-        remoteCacheClient, Options.getDefaults(RemoteOptions.class), digestUtil);
+        remoteCacheClient,
+        /* diskCacheClient= */ null,
+        Options.getDefaults(RemoteOptions.class),
+        digestUtil);
   }
 }
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
index 00ce86a9bc..ac3109ce2f 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteExecutionServiceTest.java
@@ -35,7 +35,6 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import build.bazel.remote.execution.v2.ActionResult;
-import build.bazel.remote.execution.v2.CacheCapabilities;
 import build.bazel.remote.execution.v2.Digest;
 import build.bazel.remote.execution.v2.Directory;
 import build.bazel.remote.execution.v2.DirectoryNode;
@@ -47,7 +46,6 @@ import build.bazel.remote.execution.v2.OutputFile;
 import build.bazel.remote.execution.v2.OutputSymlink;
 import build.bazel.remote.execution.v2.Platform;
 import build.bazel.remote.execution.v2.RequestMetadata;
-import build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy;
 import build.bazel.remote.execution.v2.SymlinkNode;
 import build.bazel.remote.execution.v2.Tree;
 import com.google.common.base.Throwables;
@@ -1829,12 +1827,6 @@ public class RemoteExecutionServiceTest {
 
   @Test
   public void uploadOutputs_uploadAbsoluteDanglingSymlink() throws Exception {
-    when(cache.getCacheCapabilities())
-        .thenReturn(
-            CacheCapabilities.newBuilder()
-                .setSymlinkAbsolutePathStrategy(SymlinkAbsolutePathStrategy.Value.ALLOWED)
-                .build());
-
     doUploadDanglingSymlink(PathFragment.create("/some/path"));
   }
 
@@ -2037,7 +2029,7 @@ public class RemoteExecutionServiceTest {
               uploadBlobCalled.countDown();
               return future;
             })
-        .when(cache.cacheProtocol)
+        .when(cache.remoteCacheClient)
         .uploadBlob(any(), any(), any());
     ActionInput input = ActionInputHelper.fromPath("inputs/foo");
     fakeFileCache.createScratchInput(input, "input-foo");
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteModuleTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteModuleTest.java
index 13a057f85f..2f9a1b7c92 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteModuleTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteModuleTest.java
@@ -32,6 +32,7 @@ import com.google.auth.Credentials;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.eventbus.EventBus;
+import com.google.common.truth.extensions.proto.ProtoTruth;
 import com.google.devtools.build.lib.analysis.BlazeDirectories;
 import com.google.devtools.build.lib.analysis.ServerDirectories;
 import com.google.devtools.build.lib.analysis.config.CoreOptions;
@@ -258,7 +259,8 @@ public final class RemoteModuleTest {
 
       // Retrieve the execution capabilities so that the asynchronous task that eagerly requests
       // them doesn't leak and accidentally interfere with other test cases.
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      ProtoTruth.assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(EXEC_AND_CACHE_CAPS.getCacheCapabilities());
 
       assertCircuitBreakerInstance();
@@ -283,7 +285,8 @@ public final class RemoteModuleTest {
 
       beforeCommand();
 
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(EXEC_AND_CACHE_CAPS.getCacheCapabilities());
       assertThat(
               remoteModule
@@ -311,7 +314,8 @@ public final class RemoteModuleTest {
 
       beforeCommand();
 
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(CACHE_ONLY_CAPS.getCacheCapabilities());
       assertThat(Thread.interrupted()).isFalse();
       assertThat(cacheServerCapabilitiesImpl.getRequestCount()).isEqualTo(1);
@@ -339,7 +343,8 @@ public final class RemoteModuleTest {
 
       beforeCommand();
 
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(EXEC_AND_CACHE_CAPS.getCacheCapabilities());
       assertThat(
               remoteModule
@@ -377,7 +382,8 @@ public final class RemoteModuleTest {
 
       beforeCommand();
 
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(CACHE_ONLY_CAPS.getCacheCapabilities());
       assertThat(
               remoteModule
@@ -441,7 +447,7 @@ public final class RemoteModuleTest {
       RemoteActionContextProvider actionContextProvider = remoteModule.getActionContextProvider();
       assertThat(actionContextProvider).isNotNull();
       assertThat(actionContextProvider.getRemoteCache()).isNotNull();
-      assertThat(actionContextProvider.getRemoteCache().getCacheCapabilities())
+      assertThat(actionContextProvider.getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(CACHE_ONLY_CAPS.getCacheCapabilities());
     } finally {
       cacheServer.shutdownNow();
@@ -465,7 +471,7 @@ public final class RemoteModuleTest {
       RemoteActionContextProvider actionContextProvider = remoteModule.getActionContextProvider();
       assertThat(actionContextProvider).isNotNull();
       assertThat(actionContextProvider.getRemoteCache()).isNotNull();
-      assertThat(actionContextProvider.getRemoteCache().getCacheCapabilities())
+      assertThat(actionContextProvider.getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(EXEC_AND_CACHE_CAPS.getCacheCapabilities());
     } finally {
       executionServer.shutdownNow();
@@ -514,7 +520,8 @@ public final class RemoteModuleTest {
 
       beforeCommand();
 
-      assertThat(remoteModule.getActionContextProvider().getRemoteCache().getCacheCapabilities())
+      assertThat(
+              remoteModule.getActionContextProvider().getRemoteCache().getRemoteCacheCapabilities())
           .isEqualTo(CACHE_ONLY_CAPS.getCacheCapabilities());
       assertThat(Thread.interrupted()).isFalse();
       assertThat(cacheServerCapabilitiesImpl.getRequestCount()).isEqualTo(1);
@@ -553,7 +560,7 @@ public final class RemoteModuleTest {
     Retrier.CircuitBreaker circuitBreaker;
     if (actionContextProvider.getRemoteCache() != null) {
       circuitBreaker =
-          ((GrpcCacheClient) actionContextProvider.getRemoteCache().cacheProtocol)
+          ((GrpcCacheClient) actionContextProvider.getRemoteCache().remoteCacheClient)
               .getRetrier()
               .getCircuitBreaker();
     } else if (actionContextProvider.getRemoteExecutionClient() != null) {
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
index b6c64e001e..e25cfdf0d2 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnCacheTest.java
@@ -73,9 +73,11 @@ import com.google.devtools.build.lib.exec.util.FakeOwner;
 import com.google.devtools.build.lib.remote.RemoteExecutionService.RemoteActionResult;
 import com.google.devtools.build.lib.remote.common.CacheNotFoundException;
 import com.google.devtools.build.lib.remote.common.RemoteActionExecutionContext;
+import com.google.devtools.build.lib.remote.common.RemoteCacheClient;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient.ActionKey;
 import com.google.devtools.build.lib.remote.common.RemoteCacheClient.CachedActionResult;
 import com.google.devtools.build.lib.remote.common.RemotePathResolver;
+import com.google.devtools.build.lib.remote.disk.DiskCacheClient;
 import com.google.devtools.build.lib.remote.options.RemoteOptions;
 import com.google.devtools.build.lib.remote.options.RemoteOutputsMode;
 import com.google.devtools.build.lib.remote.util.DigestUtil;
@@ -326,6 +328,9 @@ public class RemoteSpawnCacheTest {
     simplePolicy = createSpawnExecutionContext(simpleSpawn, execRoot, fakeFileCache, outErr);
 
     fakeFileCache.createScratchInput(simpleSpawn.getInputFiles().getSingleton(), "xyz");
+
+    when(remoteCache.hasRemoteCache()).thenReturn(true);
+    when(remoteCache.remoteActionCacheSupportsUpdate()).thenReturn(true);
   }
 
   @Test
@@ -419,8 +424,20 @@ public class RemoteSpawnCacheTest {
 
     RemoteOptions withLocalCache = Options.getDefaults(RemoteOptions.class);
     withLocalCache.diskCache = PathFragment.create("/etc/something/cache/here");
-    for (RemoteSpawnCache remoteSpawnCache :
-        ImmutableList.of(createRemoteSpawnCache(), remoteSpawnCacheWithOptions(withLocalCache))) {
+    for (var remoteOptions :
+        ImmutableList.of(Options.getDefaults(RemoteOptions.class), withLocalCache)) {
+
+      DiskCacheClient diskCacheClient = null;
+      RemoteCacheClient remoteCacheClient = null;
+      if (remoteOptions == withLocalCache) {
+        diskCacheClient = mock(DiskCacheClient.class);
+      } else {
+        remoteCacheClient = mock(RemoteCacheClient.class);
+      }
+      remoteCache =
+          spy(new RemoteCache(remoteCacheClient, diskCacheClient, remoteOptions, digestUtil));
+
+      var remoteSpawnCache = remoteSpawnCacheWithOptions(remoteOptions);
       for (String requirement :
           ImmutableList.of(ExecutionRequirements.NO_CACHE, ExecutionRequirements.LOCAL)) {
         SimpleSpawn uncacheableSpawn =
@@ -436,7 +453,11 @@ public class RemoteSpawnCacheTest {
                 .setRunnerName("test")
                 .build();
         entry.store(result);
-        verifyNoMoreInteractions(remoteCache);
+        if (remoteOptions == withLocalCache) {
+          verifyNoMoreInteractions(diskCacheClient);
+        } else {
+          verifyNoMoreInteractions(remoteCacheClient);
+        }
       }
     }
   }
@@ -448,6 +469,11 @@ public class RemoteSpawnCacheTest {
 
     RemoteOptions remoteCacheOptions = Options.getDefaults(RemoteOptions.class);
     remoteCacheOptions.remoteCache = "https://somecache.com";
+    RemoteCacheClient remoteCacheClient = mock(RemoteCacheClient.class);
+    remoteCache =
+        spy(
+            new RemoteCache(
+                remoteCacheClient, /* diskCacheClient= */ null, remoteCacheOptions, digestUtil));
     RemoteSpawnCache remoteSpawnCache = remoteSpawnCacheWithOptions(remoteCacheOptions);
     for (String requirement :
         ImmutableList.of(
@@ -469,7 +495,7 @@ public class RemoteSpawnCacheTest {
               .setRunnerName("test")
               .build();
       entry.store(result);
-      verifyNoMoreInteractions(remoteCache);
+      verifyNoMoreInteractions(remoteCacheClient);
     }
   }
 
@@ -483,6 +509,10 @@ public class RemoteSpawnCacheTest {
     combinedCacheOptions.remoteCache = "https://somecache.com";
     combinedCacheOptions.diskCache = PathFragment.create("/etc/something/cache/here");
     RemoteSpawnCache remoteSpawnCache = remoteSpawnCacheWithOptions(combinedCacheOptions);
+    RemoteCacheClient remoteCacheClient = mock(RemoteCacheClient.class);
+    DiskCacheClient diskCacheClient = mock(DiskCacheClient.class);
+    remoteCache =
+        spy(new RemoteCache(remoteCacheClient, diskCacheClient, combinedCacheOptions, digestUtil));
 
     for (String requirement :
         ImmutableList.of(ExecutionRequirements.NO_CACHE, ExecutionRequirements.LOCAL)) {
@@ -502,7 +532,7 @@ public class RemoteSpawnCacheTest {
               .setRunnerName("test")
               .build();
       entry.store(result);
-      verifyNoMoreInteractions(remoteCache);
+      verifyNoMoreInteractions(remoteCacheClient);
     }
   }
 
@@ -510,6 +540,8 @@ public class RemoteSpawnCacheTest {
   public void noRemoteCacheStillUsesLocalCache() throws Exception {
     RemoteOptions remoteOptions = Options.getDefaults(RemoteOptions.class);
     remoteOptions.diskCache = PathFragment.create("/etc/something/cache/here");
+    when(remoteCache.hasRemoteCache()).thenReturn(false);
+    when(remoteCache.hasDiskCache()).thenReturn(true);
     RemoteSpawnCache cache = remoteSpawnCacheWithOptions(remoteOptions);
     ArgumentCaptor<ActionKey> actionKeyCaptor = ArgumentCaptor.forClass(ActionKey.class);
     when(remoteCache.downloadActionResult(
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
index 4bf36e726f..b7c39202c6 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerTest.java
@@ -21,6 +21,7 @@ import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doThrow;
@@ -192,6 +193,9 @@ public class RemoteSpawnRunnerTest {
     remoteOptions = Options.getDefaults(RemoteOptions.class);
 
     retryService = MoreExecutors.listeningDecorator(Executors.newScheduledThreadPool(1));
+
+    when(cache.hasRemoteCache()).thenReturn(true);
+    when(cache.remoteActionCacheSupportsUpdate()).thenReturn(true);
   }
 
   @After
@@ -303,6 +307,8 @@ public class RemoteSpawnRunnerTest {
 
     verify(localRunner).exec(spawn, policy);
     verify(cache).ensureInputsPresent(any(), any(), any(), anyBoolean(), any());
+    verify(cache, atLeastOnce()).hasRemoteCache();
+    verify(cache, atLeastOnce()).hasDiskCache();
     verifyNoMoreInteractions(cache);
   }
 
diff --git a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
index 226ef8bdc7..9fb8d0c5d3 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/RemoteSpawnRunnerWithGrpcRemoteExecutorTest.java
@@ -331,7 +331,9 @@ public class RemoteSpawnRunnerWithGrpcRemoteExecutorTest {
     GrpcCacheClient cacheProtocol =
         new GrpcCacheClient(
             channel.retain(), callCredentialsProvider, remoteOptions, retrier, DIGEST_UTIL);
-    remoteCache = new RemoteExecutionCache(cacheProtocol, remoteOptions, DIGEST_UTIL);
+    remoteCache =
+        new RemoteExecutionCache(
+            cacheProtocol, /* diskCacheClient= */ null, remoteOptions, DIGEST_UTIL);
     RemoteExecutionService remoteExecutionService =
         new RemoteExecutionService(
             directExecutor(),
diff --git a/src/test/java/com/google/devtools/build/lib/remote/util/InMemoryCacheClient.java b/src/test/java/com/google/devtools/build/lib/remote/util/InMemoryCacheClient.java
index dee425d789..d6198a429e 100644
--- a/src/test/java/com/google/devtools/build/lib/remote/util/InMemoryCacheClient.java
+++ b/src/test/java/com/google/devtools/build/lib/remote/util/InMemoryCacheClient.java
@@ -13,9 +13,11 @@
 // limitations under the License.
 package com.google.devtools.build.lib.remote.util;
 
+import build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities;
 import build.bazel.remote.execution.v2.ActionResult;
 import build.bazel.remote.execution.v2.CacheCapabilities;
 import build.bazel.remote.execution.v2.Digest;
+import build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.io.ByteStreams;
 import com.google.common.util.concurrent.Futures;
@@ -108,7 +110,11 @@ public class InMemoryCacheClient implements RemoteCacheClient {
 
   @Override
   public CacheCapabilities getCacheCapabilities() {
-    return CacheCapabilities.getDefaultInstance();
+    return CacheCapabilities.newBuilder()
+        .setActionCacheUpdateCapabilities(
+            ActionCacheUpdateCapabilities.newBuilder().setUpdateEnabled(true).build())
+        .setSymlinkAbsolutePathStrategy(SymlinkAbsolutePathStrategy.Value.ALLOWED)
+        .build();
   }
 
   @Override
diff --git a/src/test/shell/bazel/remote/remote_build_event_uploader_test.sh b/src/test/shell/bazel/remote/remote_build_event_uploader_test.sh
index f0e4ac8b4a..c647f3a417 100755
--- a/src/test/shell/bazel/remote/remote_build_event_uploader_test.sh
+++ b/src/test/shell/bazel/remote/remote_build_event_uploader_test.sh
@@ -270,10 +270,10 @@ EOF
       --build_event_json_file=$BEP_JSON \
       //a:foo >& $TEST_log || fail "Failed to build"
 
-  expect_bes_file_not_uploaded foo.txt
+  expect_bes_file_uploaded foo.txt
   expect_bes_file_uploaded command.profile.gz
   remote_cas_files="$(count_remote_cas_files)"
-  [[ "$remote_cas_files" == 1 ]] || fail "Expected 1 remote cas entries, not $remote_cas_files"
+  [[ "$remote_cas_files" == 2 ]] || fail "Expected 2 remote cas entries, not $remote_cas_files"
   disk_cas_files="$(count_disk_cas_files $cache_dir)"
   # foo.txt, stdout and stderr for action 'foo'
   [[ "$disk_cas_files" == 3 ]] || fail "Expected 3 disk cas entries, not $disk_cas_files"
diff --git a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/ExecutionServer.java b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/ExecutionServer.java
index e47a28aa27..7e677f135d 100644
--- a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/ExecutionServer.java
+++ b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/ExecutionServer.java
@@ -389,7 +389,7 @@ final class ExecutionServer extends ExecutionImplBase {
         UploadManifest manifest =
             UploadManifest.create(
                 cache.getRemoteOptions(),
-                cache.getCacheCapabilities(),
+                cache.getRemoteCacheCapabilities(),
                 digestUtil,
                 RemotePathResolver.createDefault(workingDirectory),
                 actionKey,
diff --git a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
index 12ecd5903a..f14eb3eb78 100644
--- a/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
+++ b/src/tools/remote/src/main/java/com/google/devtools/build/remote/worker/OnDiskBlobStoreCache.java
@@ -15,10 +15,13 @@ package com.google.devtools.build.remote.worker;
 
 import static com.google.devtools.build.lib.remote.util.Utils.getFromFuture;
 
+import build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities;
+import build.bazel.remote.execution.v2.CacheCapabilities;
 import build.bazel.remote.execution.v2.Digest;
 import build.bazel.remote.execution.v2.Directory;
 import build.bazel.remote.execution.v2.DirectoryNode;
 import build.bazel.remote.execution.v2.FileNode;
+import build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy;
 import build.bazel.remote.execution.v2.SymlinkNode;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
@@ -43,6 +46,7 @@ class OnDiskBlobStoreCache extends RemoteCache {
   public OnDiskBlobStoreCache(RemoteOptions options, Path cacheDir, DigestUtil digestUtil)
       throws IOException {
     super(
+        /* remoteCacheClient= */ null,
         new DiskCacheClient(
             cacheDir,
             /* maxSizeBytes= */ 0,
@@ -53,10 +57,18 @@ class OnDiskBlobStoreCache extends RemoteCache {
         digestUtil);
   }
 
+  @Override
+  public CacheCapabilities getRemoteCacheCapabilities() {
+    return CacheCapabilities.newBuilder()
+        .setActionCacheUpdateCapabilities(
+            ActionCacheUpdateCapabilities.newBuilder().setUpdateEnabled(true).build())
+        .setSymlinkAbsolutePathStrategy(SymlinkAbsolutePathStrategy.Value.ALLOWED)
+        .build();
+  }
+
   /** If the given blob exists, updates its mtime and returns true. Otherwise, returns false. */
   boolean refresh(Digest digest) throws IOException {
-    DiskCacheClient diskCache = (DiskCacheClient) cacheProtocol;
-    return diskCache.refresh(diskCache.toPath(digest, Store.CAS));
+    return diskCacheClient.refresh(diskCacheClient.toPath(digest, Store.CAS));
   }
 
   @SuppressWarnings("ProtoParseWithRegistry")
