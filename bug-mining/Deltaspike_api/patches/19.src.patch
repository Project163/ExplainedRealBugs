diff --git a/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/annotation/ConfigProperty.java b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/annotation/ConfigProperty.java
index 126b37f3c..50ca44296 100644
--- a/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/annotation/ConfigProperty.java
+++ b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/annotation/ConfigProperty.java
@@ -42,52 +42,8 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * </pre>
  * </p>
  *
- * <h2>Providing own Converters and Type injection</h2>
- * <p>DeltaSpikes own configuration system only natively only supports Strings.
- * If you like to apply own Converters or extract other types from those Strings,
- * you can simply do this by providing an own Qualifier and a simple
- * CDI producer method for it.</p>
- *
- * <p>First we write a simple Qualifier:
- * <pre>
- * &#064;Target({ PARAMETER, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
- * &#064;Retention(RUNTIME)
- * &#064;Qualifier
- * public @interface NumberConfig
- * {
- *     &#064;Nonbinding
- *     boolean name(); // the name of the configuration-key to lookup the value
- *
- *     &#064;Nonbinding
- *     boolean pattern(); // the pattern for NumberFormatter
- * }
- * </pre>
- * </p>
- *
- * <p>The producer method implementation is pretty easy as well:
- * <pre>
- * &#064;ApplicationScoped
- * public class NumberConfigProducer extends BaseConfigPropertyProducer
- * {
- *     &#064;Produces
- *     &#064;Dependent
- *     &#064;NumberConfig
- *     public Float produceNumberConfig(InjectionPoint injectionPoint)
- *     {
- *         String configuredValue = getStringPropertyValue(injectionPoint);
- *
- *         if (configuredValue == null || configuredValue.length() == 0)
- *         {
- *             return null; // or 0.f depending on what you need
- *         }
- *
- *         NumberConfig metaData = getAnnotation(injectionPoint, NumberConfig.class);
- *         DecimalFormat df = new DecimalFormat(metaData.pattern());
- *         return df.parse(configuredValue).floatValue();
- *     }
- * }
- * </pre>
- * </p>
+ * <p>See the sample in {@link org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer}
+ * for how to implement own configuration injection.</p>
  *
  * @see org.apache.deltaspike.core.api.config.ConfigResolver
  * @see org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer
diff --git a/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/config/BaseConfigPropertyProducer.java b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/config/BaseConfigPropertyProducer.java
index c13b6bfb6..40e0b1b2a 100644
--- a/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/config/BaseConfigPropertyProducer.java
+++ b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/config/BaseConfigPropertyProducer.java
@@ -27,14 +27,72 @@ import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
 import org.apache.deltaspike.core.util.BeanUtils;
 
 /**
- * This contains the fundamental parts for implementing own
- * ConfigProperty producers.
+ * <p>This contains the fundamental parts for implementing own
+ * ConfigProperty producers.</p>
  *
- * TODO: add documentation
+ * <h2>Providing own Converters and Type injection</h2>
+ * <p>DeltaSpikes own configuration system only natively only supports Strings.
+ * If you like to apply own Converters or extract other types from those Strings,
+ * you can simply do this by providing an own Qualifier and a simple
+ * CDI producer method for it.</p>
+ *
+ * <p>First we write a simple Qualifier:
+ * <pre>
+ * &#064;Target({ PARAMETER, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
+ * &#064;Retention(RUNTIME)
+ * &#064;ConfigProperty(named="unused") // the name
+ * &#064;Qualifier
+ * public @interface NumberConfig
+ * {
+ *     &#064;Nonbinding
+ *     boolean name(); // the name of the configuration-key to lookup the value
+ *
+ *     @Nonbinding
+ *     String defaultValue() default ConfigProperty.NULL;
+ *
+ *     &#064;Nonbinding
+ *     boolean pattern(); // the pattern for NumberFormatter
+ * }
+ * </pre>
+ * </p>
+ *
+ * <p>The producer method implementation is pretty easy as well:
+ * <pre>
+ * &#064;ApplicationScoped
+ * public class NumberConfigProducer extends BaseConfigPropertyProducer
+ * {
+ *     &#064;Produces
+ *     &#064;Dependent
+ *     &#064;NumberConfig
+ *     public Float produceNumberConfig(InjectionPoint injectionPoint)
+ *     {
+ *         // resolve the annotation
+ *         NumberConfig metaData = getAnnotation(injectionPoint, NumberConfig.class);
+
+ *         // get the configured value from the underlying configuration system
+ *         String configuredValue = getPropertyValue(metaData.name(), metaData.defaultValue());
+ *         if (configuredValue == null)
+ *         {
+ *             return null;
+ *         }
+ *
+ *         // format according to the given pattern
+ *         DecimalFormat df = new DecimalFormat(metaData.pattern(), new DecimalFormatSymbols(Locale.US));
+ *         return df.parse(configuredValue).floatValue(); *
+ *     }
+ * }
+ * </pre>
+ * </p>
+
  */
 public abstract class BaseConfigPropertyProducer
 {
     /**
+     * <p>Inspects the given InjectionPoint and search for a {@link ConfigProperty}
+     * annotation or an Annotation with a {@link ConfigProperty} meta-Annotation.
+     * The name and defaultValue information will be used to resolve the
+     * configured value.</p>
+     *
      * @param injectionPoint current injection point
      * @return the configured value for the given InjectionPoint
      */
@@ -50,16 +108,29 @@ public abstract class BaseConfigPropertyProducer
         String configuredValue;
         String defaultValue = configProperty.defaultValue();
 
+        configuredValue = getPropertyValue(configProperty.name(), defaultValue);
+
+        return configuredValue;
+    }
+
+    /**
+     * @param propertyName the name of the property key
+     * @param defaultValue the default value to return if no configured property is found or
+     *                     {@link ConfigProperty#NULL} if no default value should be returned.
+     * @return the configured value or the defaultValue according to the NULL logic.
+     */
+    protected String getPropertyValue(String propertyName, String defaultValue)
+    {
+        String configuredValue;
         if (ConfigProperty.NULL.equals(defaultValue))
         {
             // no special defaultValue has been configured
-            configuredValue = ConfigResolver.getPropertyValue(configProperty.name());
+            configuredValue = ConfigResolver.getPropertyValue(propertyName);
         }
         else
         {
-            configuredValue = ConfigResolver.getPropertyValue(configProperty.name(), defaultValue);
+            configuredValue = ConfigResolver.getPropertyValue(propertyName, defaultValue);
         }
-
         return configuredValue;
     }
 
