diff --git a/src/main/java/com/pablissimo/sonar/TsLintExecutorConfig.java b/src/main/java/com/pablissimo/sonar/TsLintExecutorConfig.java
index f1889de..0126b63 100644
--- a/src/main/java/com/pablissimo/sonar/TsLintExecutorConfig.java
+++ b/src/main/java/com/pablissimo/sonar/TsLintExecutorConfig.java
@@ -6,29 +6,35 @@ import org.sonar.api.config.Settings;
 public class TsLintExecutorConfig {
     public static final String CONFIG_FILENAME = "tslint.json";
     public static final String TSLINT_FALLBACK_PATH = "node_modules/tslint/bin/tslint";
-    
+
     private String pathToTsLint;
     private String configFile;
     private String rulesDir;
     private String pathToTsConfig;
     private boolean shouldPerformTypeCheck;
-    
+    private String pathToTsLintOutput;
+
     private Integer timeoutMs;
-    
+
     public static TsLintExecutorConfig fromSettings(Settings settings, SensorContext ctx, PathResolver resolver) {
         TsLintExecutorConfig toReturn = new TsLintExecutorConfig();
-        
+
         toReturn.setPathToTsLint(resolver.getPath(ctx, TypeScriptPlugin.SETTING_TS_LINT_PATH, TSLINT_FALLBACK_PATH));
         toReturn.setConfigFile(resolver.getPath(ctx, TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH, CONFIG_FILENAME));
         toReturn.setRulesDir(resolver.getPath(ctx, TypeScriptPlugin.SETTING_TS_LINT_RULES_DIR, null));
         toReturn.setPathToTsConfig(resolver.getPath(ctx, TypeScriptPlugin.SETTING_TS_LINT_PROJECT_PATH, null));
-        
+        toReturn.setPathToTsLintOutput(resolver.getPath(ctx, TypeScriptPlugin.SETTING_TS_LINT_OUTPUT_PATH, null));
+
         toReturn.setTimeoutMs(Math.max(5000, settings.getInt(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT)));
         toReturn.setShouldPerformTypeCheck(settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_TYPECHECK));
-        
+
         return toReturn;
     }
-    
+
+    public Boolean useAlreadyExistsTsLintOutput() {
+        return this.pathToTsLintOutput != null && !this.pathToTsLintOutput.isEmpty();
+    }
+
     public Boolean useTsConfigInsteadOfFileList() {
         return this.pathToTsConfig != null && !this.pathToTsConfig.isEmpty();
     }
@@ -73,6 +79,15 @@ public class TsLintExecutorConfig {
         this.pathToTsConfig = pathToTsConfig;
     }
 
+    public String getPathToTsLintOutput() {
+        return this.pathToTsLintOutput;
+    }
+
+    public void setPathToTsLintOutput(String pathToTsLintOutput) {
+        this.pathToTsLintOutput = pathToTsLintOutput;
+    }
+
+
     public boolean shouldPerformTypeCheck() {
         return this.shouldPerformTypeCheck;
     }
diff --git a/src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java b/src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java
index ce2bacf..bba6196 100644
--- a/src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java
+++ b/src/main/java/com/pablissimo/sonar/TsLintExecutorImpl.java
@@ -23,12 +23,12 @@ public class TsLintExecutorImpl implements TsLintExecutor {
 
     private boolean mustQuoteSpaceContainingPaths = false;
     private TempFolder tempFolder;
-    
+
     public TsLintExecutorImpl(System2 system, TempFolder tempFolder) {
         this.mustQuoteSpaceContainingPaths = system.isOsWindows();
         this.tempFolder = tempFolder;
     }
-    
+
     private String preparePath(String path) {
         if (path == null) {
             return null;
@@ -40,7 +40,7 @@ public class TsLintExecutorImpl implements TsLintExecutor {
             return path;
         }
     }
-    
+
     private Command getBaseCommand(TsLintExecutorConfig config, String tempPath) {
         Command command =
                 Command
@@ -55,7 +55,7 @@ public class TsLintExecutorImpl implements TsLintExecutor {
                 .addArgument("--rules-dir")
                 .addArgument(this.preparePath(rulesDir));
         }
-        
+
         if (tempPath != null && tempPath.length() > 0) {
             command
                 .addArgument("--out")
@@ -65,13 +65,13 @@ public class TsLintExecutorImpl implements TsLintExecutor {
         command
             .addArgument("--config")
             .addArgument(this.preparePath(config.getConfigFile()));
-        
+
         if (config.useTsConfigInsteadOfFileList()) {
             command
                 .addArgument("--project")
                 .addArgument(this.preparePath(config.getPathToTsConfig()));
         }
-        
+
         if (config.shouldPerformTypeCheck()) {
             command
                 .addArgument("--type-check");
@@ -89,39 +89,46 @@ public class TsLintExecutorImpl implements TsLintExecutor {
         else if (files == null) {
             throw new IllegalArgumentException("files");
         }
-        
+
+        if (config.useAlreadyExistsTsLintOutput()) {
+            LOG.debug("Running with exists JSON file");
+            List<String> toReturn = new ArrayList<String>();
+            toReturn.add(this.getFileContent(new File(config.getPathToTsLintOutput())));
+            return toReturn;
+        }
+
         // New up a command that's everything we need except the files to process
         // We'll use this as our reference for chunking up files, if we need to
         File tslintOutputFile = this.tempFolder.newFile();
         String tslintOutputFilePath = tslintOutputFile.getAbsolutePath();
         Command baseCommand = getBaseCommand(config, tslintOutputFilePath);
-        
+
         LOG.debug("Using a temporary path for TsLint output: " + tslintOutputFilePath);
 
         StringStreamConsumer stdOutConsumer = new StringStreamConsumer();
         StringStreamConsumer stdErrConsumer = new StringStreamConsumer();
-        
+
         List<String> toReturn = new ArrayList<String>();
-        
+
         if (config.useTsConfigInsteadOfFileList()) {
             LOG.debug("Running against a single project JSON file");
-            
+
             // If we're being asked to use a tsconfig.json file, it'll contain
             // the file list to lint - so don't batch, and just run with it
             toReturn.add(this.getCommandOutput(baseCommand, stdOutConsumer, stdErrConsumer, tslintOutputFile, config.getTimeoutMs()));
         }
-        else {        
+        else {
             int baseCommandLength = baseCommand.toCommandLine().length();
             int availableForBatching = MAX_COMMAND_LENGTH - baseCommandLength;
-    
+
             List<List<String>> batches = new ArrayList<List<String>>();
             List<String> currentBatch = new ArrayList<String>();
             batches.add(currentBatch);
-    
+
             int currentBatchLength = 0;
             for (int i = 0; i < files.size(); i++) {
                 String nextPath = this.preparePath(files.get(i).trim());
-    
+
                 // +1 for the space we'll be adding between filenames
                 if (currentBatchLength + nextPath.length() + 1 > availableForBatching) {
                     // Too long to add to this batch, create new
@@ -129,26 +136,26 @@ public class TsLintExecutorImpl implements TsLintExecutor {
                     currentBatchLength = 0;
                     batches.add(currentBatch);
                 }
-    
+
                 currentBatch.add(nextPath);
                 currentBatchLength += nextPath.length() + 1;
             }
-    
+
             LOG.debug("Split " + files.size() + " files into " + batches.size() + " batches for processing");
-                        
+
             for (int i = 0; i < batches.size(); i++) {
                 StringBuilder outputBuilder = new StringBuilder();
-    
+
                 List<String> thisBatch = batches.get(i);
-    
+
                 Command thisCommand = getBaseCommand(config, tslintOutputFilePath);
-    
+
                 for (int fileIndex = 0; fileIndex < thisBatch.size(); fileIndex++) {
                     thisCommand.addArgument(thisBatch.get(fileIndex));
                 }
-    
+
                 LOG.debug("Executing TsLint with command: " + thisCommand.toCommandLine());
-    
+
                 // Timeout is specified per file, not per batch (which can vary a lot)
                 // so multiply it up
                 toReturn.add(this.getCommandOutput(thisCommand, stdOutConsumer, stdErrConsumer, tslintOutputFile, config.getTimeoutMs() * thisBatch.size()));
@@ -157,7 +164,7 @@ public class TsLintExecutorImpl implements TsLintExecutor {
 
         return toReturn;
     }
-    
+
     private String getCommandOutput(Command thisCommand, StreamConsumer stdOutConsumer, StreamConsumer stdErrConsumer, File tslintOutputFile, Integer timeoutMs) {
         LOG.debug("Executing TsLint with command: " + thisCommand.toCommandLine());
 
@@ -165,27 +172,31 @@ public class TsLintExecutorImpl implements TsLintExecutor {
         // so multiply it up
         this.createExecutor().execute(thisCommand, stdOutConsumer, stdErrConsumer, timeoutMs);
 
+        return getFileContent(tslintOutputFile);
+    }
+
+    private String getFileContent(File tslintOutputFile) {
         StringBuilder outputBuilder = new StringBuilder();
 
         try {
             BufferedReader reader = this.getBufferedReaderForFile(tslintOutputFile);
-            
+
             String str;
             while ((str = reader.readLine()) != null) {
                 outputBuilder.append(str);
             }
-            
+
             reader.close();
-            
+
             return outputBuilder.toString();
         }
         catch (IOException ex) {
             LOG.error("Failed to re-read TsLint output", ex);
         }
-        
+
         return "";
     }
-    
+
     protected BufferedReader getBufferedReaderForFile(File file) throws IOException {
         return new BufferedReader(
                 new InputStreamReader(
diff --git a/src/main/java/com/pablissimo/sonar/TypeScriptPlugin.java b/src/main/java/com/pablissimo/sonar/TypeScriptPlugin.java
index 63cfd10..33d48a6 100644
--- a/src/main/java/com/pablissimo/sonar/TypeScriptPlugin.java
+++ b/src/main/java/com/pablissimo/sonar/TypeScriptPlugin.java
@@ -109,6 +109,15 @@ import org.sonar.api.*;
         description = "Required if tslinttypecheck parameter specified, the path to the tsconfig.json file that describes the files to lint and build",
         project = true,
         global = false
+    ),
+    @Property(
+        key = TypeScriptPlugin.SETTING_TS_LINT_OUTPUT_PATH,
+        defaultValue = "",
+        type = PropertyType.STRING,
+        name = "Path to TSLint Json output file, if required",
+        description = "Required if TSLint running before SonarQube checks",
+        project = true,
+        global = false
     )
 })
 public class TypeScriptPlugin implements Plugin {
@@ -124,6 +133,7 @@ public class TypeScriptPlugin implements Plugin {
     public static final String SETTING_TS_RULE_CONFIGS = "sonar.ts.ruleconfigs";
     public static final String SETTING_TS_LINT_TYPECHECK = "sonar.ts.tslinttypecheck";
     public static final String SETTING_TS_LINT_PROJECT_PATH = "sonar.ts.tslintprojectpath";
+    public static final String SETTING_TS_LINT_OUTPUT_PATH = "sonar.ts.tslintoutputpath";
 
     @Override
     public void define(Context ctx) {
diff --git a/src/test/java/com/pablissimo/sonar/TsLintExecutorConfigTest.java b/src/test/java/com/pablissimo/sonar/TsLintExecutorConfigTest.java
index d22f36f..c03155d 100644
--- a/src/test/java/com/pablissimo/sonar/TsLintExecutorConfigTest.java
+++ b/src/test/java/com/pablissimo/sonar/TsLintExecutorConfigTest.java
@@ -11,119 +11,125 @@ import org.sonar.api.batch.sensor.internal.SensorContextTester;
 import org.sonar.api.config.Settings;
 
 public class TsLintExecutorConfigTest {
-    
+
     private TsLintExecutorConfig getNewConfig() {
         return new TsLintExecutorConfig();
     }
-    
+
     @Test
     public void canGetSetPathToTsLint() {
         TsLintExecutorConfig config = getNewConfig();
         config.setPathToTsLint("My path");
-        
+
         assertEquals("My path",  config.getPathToTsLint());
     }
-    
+
     @Test
     public void canGetSetPathToTsLintConfig() {
         TsLintExecutorConfig config = getNewConfig();
         config.setConfigFile("My path");
-        
+
         assertEquals("My path",  config.getConfigFile());
     }
-    
+
     @Test
     public void canGetSetRulesDir() {
         TsLintExecutorConfig config = getNewConfig();
         config.setRulesDir("My path");
-        
+
         assertEquals("My path",  config.getRulesDir());
     }
-    
+
     @Test
     public void canGetSetTimeout() {
         TsLintExecutorConfig config = getNewConfig();
         config.setTimeoutMs(12);
-        
+
         assertEquals((Integer) 12, config.getTimeoutMs());
     }
-    
+
     @Test
     public void canGetSetTsConfigPath() {
         TsLintExecutorConfig config = getNewConfig();
         config.setPathToTsConfig("My path");
-        
+
         assertEquals("My path",  config.getPathToTsConfig());
     }
-    
+
     @Test
     public void canGetSetTypeCheck() {
         TsLintExecutorConfig config = getNewConfig();
         config.setShouldPerformTypeCheck(true);
-        
+
         assertTrue(config.shouldPerformTypeCheck());
     }
-    
+
     @Test
     public void useTsConfigInsteadOfFileList_returnsTrue_ifPathToTsConfigSet() {
         TsLintExecutorConfig config = getNewConfig();
         config.setPathToTsConfig("My path");
-        
+
         assertTrue(config.useTsConfigInsteadOfFileList());
     }
-    
+
     @Test
     public void useTsConfigInsteadOfFileList_returnsFalse_ifPathToTsConfigNotSet() {
         TsLintExecutorConfig config = getNewConfig();
         config.setPathToTsConfig("");
-        
+
         assertFalse(config.useTsConfigInsteadOfFileList());
     }
-    
+
     @Test
     public void fromSettings_initialisesFromSettingsAndResolver() {
         Settings settings = new Settings();
         settings.setProperty(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT, 12000);
         settings.setProperty(TypeScriptPlugin.SETTING_TS_LINT_TYPECHECK, true);
-        
+
         PathResolver resolver = mock(PathResolver.class);
-        
-        when(resolver.getPath(any(SensorContext.class), 
-                               eq(TypeScriptPlugin.SETTING_TS_LINT_PATH), 
+
+        when(resolver.getPath(any(SensorContext.class),
+                               eq(TypeScriptPlugin.SETTING_TS_LINT_PATH),
                                eq(TsLintExecutorConfig.TSLINT_FALLBACK_PATH))
         ).thenReturn("tslint");
-        
-        when(resolver.getPath(any(SensorContext.class), 
-                               eq(TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH), 
+
+        when(resolver.getPath(any(SensorContext.class),
+                               eq(TypeScriptPlugin.SETTING_TS_LINT_CONFIG_PATH),
                                eq(TsLintExecutorConfig.CONFIG_FILENAME))
         ).thenReturn("tslint.json");
 
-        when(resolver.getPath(any(SensorContext.class), 
-                               eq(TypeScriptPlugin.SETTING_TS_LINT_RULES_DIR), 
+        when(resolver.getPath(any(SensorContext.class),
+                               eq(TypeScriptPlugin.SETTING_TS_LINT_RULES_DIR),
                                eq((String) null))
         ).thenReturn("rulesdir");
-        
-        when(resolver.getPath(any(SensorContext.class), 
-                               eq(TypeScriptPlugin.SETTING_TS_LINT_PROJECT_PATH), 
+
+        when(resolver.getPath(any(SensorContext.class),
+                               eq(TypeScriptPlugin.SETTING_TS_LINT_PROJECT_PATH),
                                eq((String) null))
         ).thenReturn("tsconfig.json");
-        
+
+        when(resolver.getPath(any(SensorContext.class),
+                                eq(TypeScriptPlugin.SETTING_TS_LINT_OUTPUT_PATH),
+                                eq((String) null))
+        ).thenReturn("out.json");
+
         TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(settings, SensorContextTester.create(new File("")), resolver);
-        
+
         assertEquals("tslint", config.getPathToTsLint());
         assertEquals("tslint.json", config.getConfigFile());
         assertEquals("rulesdir", config.getRulesDir());
         assertEquals("tsconfig.json", config.getPathToTsConfig());
-        
+
+        assertEquals("out.json", config.getPathToTsLintOutput());
         assertTrue(config.shouldPerformTypeCheck());
         assertEquals((Integer) 12000, config.getTimeoutMs());
     }
-    
+
     @Test
     public void fromSettings_setsTimeoutTo5000msMinimum_ifSetToLess() {
         Settings settings = new Settings();
         settings.setProperty(TypeScriptPlugin.SETTING_TS_LINT_TIMEOUT, 1000);
-        
+
         PathResolver resolver = mock(PathResolver.class);
 
         TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(settings, SensorContextTester.create(new File("")), resolver);
diff --git a/src/test/java/com/pablissimo/sonar/TypeScriptPluginTest.java b/src/test/java/com/pablissimo/sonar/TypeScriptPluginTest.java
index 6bfe0fa..ab976a1 100644
--- a/src/test/java/com/pablissimo/sonar/TypeScriptPluginTest.java
+++ b/src/test/java/com/pablissimo/sonar/TypeScriptPluginTest.java
@@ -57,7 +57,7 @@ public class TypeScriptPluginTest {
         Annotation annotation = plugin.getClass().getAnnotations()[0];
         Properties propertiesAnnotation = (Properties) annotation;
 
-        assertEquals(11, propertiesAnnotation.value().length);
+        assertEquals(12, propertiesAnnotation.value().length);
 
         Property[] properties = propertiesAnnotation.value();
         assertNotNull(findPropertyByName(properties,
@@ -82,6 +82,8 @@ public class TypeScriptPluginTest {
             TypeScriptPlugin.SETTING_TS_LINT_TYPECHECK));
         assertNotNull(findPropertyByName(properties,
             TypeScriptPlugin.SETTING_TS_LINT_PROJECT_PATH));
+        assertNotNull(findPropertyByName(properties,
+            TypeScriptPlugin.SETTING_TS_LINT_OUTPUT_PATH));
     }
 
     @Test
