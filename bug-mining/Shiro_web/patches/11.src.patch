diff --git a/web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java b/web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java
index fa8b79a03..71a52e3ea 100644
--- a/web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java
+++ b/web/src/main/java/org/apache/shiro/web/config/IniFilterChainResolverFactory.java
@@ -1,190 +1,190 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.config;
-
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.config.IniFactorySupport;
-import org.apache.shiro.config.IniSecurityManagerFactory;
-import org.apache.shiro.config.ReflectionBuilder;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.Factory;
-import org.apache.shiro.web.filter.mgt.FilterChainManager;
-import org.apache.shiro.web.filter.mgt.FilterChainResolver;
-import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterConfig;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * A {@link Factory} that creates {@link FilterChainResolver} instances based on {@link Ini} configuration.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class IniFilterChainResolverFactory extends IniFactorySupport<FilterChainResolver> {
-
-    public static final String FILTERS = "filters";
-    public static final String URLS = "urls";
-
-    private static transient final Logger log = LoggerFactory.getLogger(IniFilterChainResolverFactory.class);
-
-    private FilterConfig filterConfig;
-
-    private Map<String, ?> defaultBeans;
-
-    public IniFilterChainResolverFactory() {
-        super();
-    }
-
-    public IniFilterChainResolverFactory(Ini ini) {
-        super(ini);
-    }
-
-    public IniFilterChainResolverFactory(Ini ini, Map<String, ?> defaultBeans) {
-        this(ini);
-        this.defaultBeans = defaultBeans;
-    }
-
-    public FilterConfig getFilterConfig() {
-        return filterConfig;
-    }
-
-    public void setFilterConfig(FilterConfig filterConfig) {
-        this.filterConfig = filterConfig;
-    }
-
-    protected FilterChainResolver createInstance(Ini ini) {
-        FilterChainResolver filterChainResolver = createDefaultInstance();
-        if (filterChainResolver instanceof PathMatchingFilterChainResolver) {
-            PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) filterChainResolver;
-            FilterChainManager manager = resolver.getFilterChainManager();
-            buildChains(manager, ini);
-        }
-        return filterChainResolver;
-    }
-
-    protected FilterChainResolver createDefaultInstance() {
-        FilterConfig filterConfig = getFilterConfig();
-        if (filterConfig != null) {
-            return new PathMatchingFilterChainResolver(filterConfig);
-        } else {
-            return new PathMatchingFilterChainResolver();
-        }
-    }
-
-    protected void buildChains(FilterChainManager manager, Ini ini) {
-        //filters section:
-        Ini.Section section = ini.getSection(FILTERS);
-
-        if (!CollectionUtils.isEmpty(section)) {
-            String msg = "The [{}] section has been deprecated and will be removed in a future release!  Please " +
-                    "move all object configuration (filters and all other objects) to the [{}] section.";
-            log.warn(msg, FILTERS, IniSecurityManagerFactory.MAIN_SECTION_NAME);
-        }
-
-        Map<String, Object> defaults = new LinkedHashMap<String, Object>();
-
-        Map<String, Filter> defaultFilters = manager.getFilters();
-
-        //now let's see if there are any object defaults in addition to the filters
-        //these can be used to configure the filters:
-        //create a Map of objects to use as the defaults:
-        if (!CollectionUtils.isEmpty(defaultFilters)) {
-            defaults.putAll(defaultFilters);
-        }
-        //User-provided objects must come _after_ the default filters - to allow the user-provided
-        //ones to override the default filters if necessary.
-        if (!CollectionUtils.isEmpty(this.defaultBeans)) {
-            defaults.putAll(this.defaultBeans);
-        }
-
-        Map<String, Filter> filters = getFilters(section, defaults);
-
-        //add the filters to the manager:
-        registerFilters(filters, manager);
-
-        //urls section:
-        section = ini.getSection(URLS);
-        createChains(section, manager);
-    }
-
-    protected void registerFilters(Map<String, Filter> filters, FilterChainManager manager) {
-        if (!CollectionUtils.isEmpty(filters)) {
-            boolean init = getFilterConfig() != null; //only call filter.init if there is a FilterConfig available
-            for (Map.Entry<String, Filter> entry : filters.entrySet()) {
-                String name = entry.getKey();
-                Filter filter = entry.getValue();
-                manager.addFilter(name, filter, init);
-            }
-        }
-    }
-
-    protected Map<String, Filter> getFilters(Map<String, String> section, Map<String, ?> defaults) {
-
-        Map<String, Filter> filters;
-
-        if (!CollectionUtils.isEmpty(section)) {
-            ReflectionBuilder builder = new ReflectionBuilder(defaults);
-            Map<String, ?> built = builder.buildObjects(section);
-            filters = extractFilters(built);
-        } else {
-            filters = extractFilters(defaults);
-        }
-
-        return filters;
-    }
-
-    private Map<String, Filter> extractFilters(Map<String, ?> objects) {
-        if (CollectionUtils.isEmpty(objects)) {
-            return null;
-        }
-        Map<String, Filter> filterMap = new LinkedHashMap<String, Filter>();
-        for (Map.Entry<String, ?> entry : objects.entrySet()) {
-            String key = entry.getKey();
-            Object value = entry.getValue();
-            if (value instanceof Filter) {
-                filterMap.put(key, (Filter) value);
-            }
-        }
-        return filterMap;
-    }
-
-    protected void createChains(Map<String, String> urls, FilterChainManager manager) {
-        if (CollectionUtils.isEmpty(urls)) {
-            if (log.isDebugEnabled()) {
-                log.debug("No urls to process.");
-            }
-            return;
-        }
-
-        if (log.isTraceEnabled()) {
-            log.trace("Before url processing.");
-        }
-
-        for (Map.Entry<String, String> entry : urls.entrySet()) {
-            String path = entry.getKey();
-            String value = entry.getValue();
-            manager.createChain(path, value);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.config;
+
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.config.IniFactorySupport;
+import org.apache.shiro.config.IniSecurityManagerFactory;
+import org.apache.shiro.config.ReflectionBuilder;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.Factory;
+import org.apache.shiro.web.filter.mgt.FilterChainManager;
+import org.apache.shiro.web.filter.mgt.FilterChainResolver;
+import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterConfig;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * A {@link Factory} that creates {@link FilterChainResolver} instances based on {@link Ini} configuration.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class IniFilterChainResolverFactory extends IniFactorySupport<FilterChainResolver> {
+
+    public static final String FILTERS = "filters";
+    public static final String URLS = "urls";
+
+    private static transient final Logger log = LoggerFactory.getLogger(IniFilterChainResolverFactory.class);
+
+    private FilterConfig filterConfig;
+
+    private Map<String, ?> defaultBeans;
+
+    public IniFilterChainResolverFactory() {
+        super();
+    }
+
+    public IniFilterChainResolverFactory(Ini ini) {
+        super(ini);
+    }
+
+    public IniFilterChainResolverFactory(Ini ini, Map<String, ?> defaultBeans) {
+        this(ini);
+        this.defaultBeans = defaultBeans;
+    }
+
+    public FilterConfig getFilterConfig() {
+        return filterConfig;
+    }
+
+    public void setFilterConfig(FilterConfig filterConfig) {
+        this.filterConfig = filterConfig;
+    }
+
+    protected FilterChainResolver createInstance(Ini ini) {
+        FilterChainResolver filterChainResolver = createDefaultInstance();
+        if (filterChainResolver instanceof PathMatchingFilterChainResolver) {
+            PathMatchingFilterChainResolver resolver = (PathMatchingFilterChainResolver) filterChainResolver;
+            FilterChainManager manager = resolver.getFilterChainManager();
+            buildChains(manager, ini);
+        }
+        return filterChainResolver;
+    }
+
+    protected FilterChainResolver createDefaultInstance() {
+        FilterConfig filterConfig = getFilterConfig();
+        if (filterConfig != null) {
+            return new PathMatchingFilterChainResolver(filterConfig);
+        } else {
+            return new PathMatchingFilterChainResolver();
+        }
+    }
+
+    protected void buildChains(FilterChainManager manager, Ini ini) {
+        //filters section:
+        Ini.Section section = ini.getSection(FILTERS);
+
+        if (!CollectionUtils.isEmpty(section)) {
+            String msg = "The [{}] section has been deprecated and will be removed in a future release!  Please " +
+                    "move all object configuration (filters and all other objects) to the [{}] section.";
+            log.warn(msg, FILTERS, IniSecurityManagerFactory.MAIN_SECTION_NAME);
+        }
+
+        Map<String, Object> defaults = new LinkedHashMap<String, Object>();
+
+        Map<String, Filter> defaultFilters = manager.getFilters();
+
+        //now let's see if there are any object defaults in addition to the filters
+        //these can be used to configure the filters:
+        //create a Map of objects to use as the defaults:
+        if (!CollectionUtils.isEmpty(defaultFilters)) {
+            defaults.putAll(defaultFilters);
+        }
+        //User-provided objects must come _after_ the default filters - to allow the user-provided
+        //ones to override the default filters if necessary.
+        if (!CollectionUtils.isEmpty(this.defaultBeans)) {
+            defaults.putAll(this.defaultBeans);
+        }
+
+        Map<String, Filter> filters = getFilters(section, defaults);
+
+        //add the filters to the manager:
+        registerFilters(filters, manager);
+
+        //urls section:
+        section = ini.getSection(URLS);
+        createChains(section, manager);
+    }
+
+    protected void registerFilters(Map<String, Filter> filters, FilterChainManager manager) {
+        if (!CollectionUtils.isEmpty(filters)) {
+            boolean init = getFilterConfig() != null; //only call filter.init if there is a FilterConfig available
+            for (Map.Entry<String, Filter> entry : filters.entrySet()) {
+                String name = entry.getKey();
+                Filter filter = entry.getValue();
+                manager.addFilter(name, filter, init);
+            }
+        }
+    }
+
+    protected Map<String, Filter> getFilters(Map<String, String> section, Map<String, ?> defaults) {
+
+        Map<String, Filter> filters;
+
+        if (!CollectionUtils.isEmpty(section)) {
+            ReflectionBuilder builder = new ReflectionBuilder(defaults);
+            Map<String, ?> built = builder.buildObjects(section);
+            filters = extractFilters(built);
+        } else {
+            filters = extractFilters(defaults);
+        }
+
+        return filters;
+    }
+
+    private Map<String, Filter> extractFilters(Map<String, ?> objects) {
+        if (CollectionUtils.isEmpty(objects)) {
+            return null;
+        }
+        Map<String, Filter> filterMap = new LinkedHashMap<String, Filter>();
+        for (Map.Entry<String, ?> entry : objects.entrySet()) {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            if (value instanceof Filter) {
+                filterMap.put(key, (Filter) value);
+            }
+        }
+        return filterMap;
+    }
+
+    protected void createChains(Map<String, String> urls, FilterChainManager manager) {
+        if (CollectionUtils.isEmpty(urls)) {
+            if (log.isDebugEnabled()) {
+                log.debug("No urls to process.");
+            }
+            return;
+        }
+
+        if (log.isTraceEnabled()) {
+            log.trace("Before url processing.");
+        }
+
+        for (Map.Entry<String, String> entry : urls.entrySet()) {
+            String path = entry.getKey();
+            String value = entry.getValue();
+            manager.createChain(path, value);
+        }
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/config/WebIniSecurityManagerFactory.java b/web/src/main/java/org/apache/shiro/web/config/WebIniSecurityManagerFactory.java
index 6122fbae2..e69230e23 100644
--- a/web/src/main/java/org/apache/shiro/web/config/WebIniSecurityManagerFactory.java
+++ b/web/src/main/java/org/apache/shiro/web/config/WebIniSecurityManagerFactory.java
@@ -1,78 +1,78 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.config;
-
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.config.IniSecurityManagerFactory;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.web.filter.mgt.DefaultFilter;
-import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
-
-import javax.servlet.Filter;
-import java.util.Map;
-
-/**
- * Differs from the parent class only in the {@link #createDefaultInstance()} method, to
- * ensure a web-capable {@code SecurityManager} instance is created by default.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class WebIniSecurityManagerFactory extends IniSecurityManagerFactory {
-
-    /**
-     * Creates a new {@code WebIniSecurityManagerFactory} instance which will construct web-capable
-     * {@code SecurityManager} instances.
-     */
-    public WebIniSecurityManagerFactory() {
-        super();
-    }
-
-    /**
-     * Creates a new {@code WebIniSecurityManagerFactory} instance which will construct web-capable
-     * {@code SecurityManager} instances.  Uses the given {@link Ini} instance to construct the instance.
-     *
-     * @param config the Ini configuration that will be used to construct new web-capable {@code SecurityManager}
-     *               instances.
-     */
-    public WebIniSecurityManagerFactory(Ini config) {
-        super(config);
-    }
-
-    /**
-     * Simply returns <code>new {@link DefaultWebSecurityManager}();</code> to ensure a web-capable
-     * {@code SecurityManager} is available by default.
-     *
-     * @return a new web-capable {@code SecurityManager} instance.
-     */
-    @Override
-    protected SecurityManager createDefaultInstance() {
-        return new DefaultWebSecurityManager();
-    }
-
-    @SuppressWarnings({"unchecked"})
-    @Override
-    protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {
-        Map defaults = super.createDefaults(ini, mainSection);
-        //add the default filters:
-        Map<String, Filter> defaultFilters = DefaultFilter.createInstanceMap(null);
-        defaults.putAll(defaultFilters);
-        return defaults;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.config;
+
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.config.IniSecurityManagerFactory;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.web.filter.mgt.DefaultFilter;
+import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
+
+import javax.servlet.Filter;
+import java.util.Map;
+
+/**
+ * Differs from the parent class only in the {@link #createDefaultInstance()} method, to
+ * ensure a web-capable {@code SecurityManager} instance is created by default.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class WebIniSecurityManagerFactory extends IniSecurityManagerFactory {
+
+    /**
+     * Creates a new {@code WebIniSecurityManagerFactory} instance which will construct web-capable
+     * {@code SecurityManager} instances.
+     */
+    public WebIniSecurityManagerFactory() {
+        super();
+    }
+
+    /**
+     * Creates a new {@code WebIniSecurityManagerFactory} instance which will construct web-capable
+     * {@code SecurityManager} instances.  Uses the given {@link Ini} instance to construct the instance.
+     *
+     * @param config the Ini configuration that will be used to construct new web-capable {@code SecurityManager}
+     *               instances.
+     */
+    public WebIniSecurityManagerFactory(Ini config) {
+        super(config);
+    }
+
+    /**
+     * Simply returns <code>new {@link DefaultWebSecurityManager}();</code> to ensure a web-capable
+     * {@code SecurityManager} is available by default.
+     *
+     * @return a new web-capable {@code SecurityManager} instance.
+     */
+    @Override
+    protected SecurityManager createDefaultInstance() {
+        return new DefaultWebSecurityManager();
+    }
+
+    @SuppressWarnings({"unchecked"})
+    @Override
+    protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {
+        Map defaults = super.createDefaults(ini, mainSection);
+        //add the default filters:
+        Map<String, Filter> defaultFilters = DefaultFilter.createInstanceMap(null);
+        defaults.putAll(defaultFilters);
+        return defaults;
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticatingFilter.java b/web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticatingFilter.java
index 619363364..147793aaa 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticatingFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/authc/AuthenticatingFilter.java
@@ -1,108 +1,108 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authc;
-
-import org.apache.shiro.authc.AuthenticationException;
-import org.apache.shiro.authc.AuthenticationToken;
-import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.subject.Subject;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * An <code>AuthenticationFilter</code> that is capable of automatically performing an authentication attempt
- * based on the incoming request.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public abstract class AuthenticatingFilter extends AuthenticationFilter {
-
-    //TODO - complete JavaDoc
-
-    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {
-        AuthenticationToken token = createToken(request, response);
-        if (token == null) {
-            String msg = "createToken method implementation returned null. A valid non-null AuthenticationToken " +
-                    "must be created in order to execute a login attempt.";
-            throw new IllegalStateException(msg);
-        }
-        try {
-            Subject subject = getSubject(request, response);
-            subject.login(token);
-            return onLoginSuccess(token, subject, request, response);
-        } catch (AuthenticationException e) {
-            return onLoginFailure(token, e, request, response);
-        }
-    }
-
-    protected abstract AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception;
-
-    protected AuthenticationToken createToken(String username, String password,
-                                              ServletRequest request, ServletResponse response) {
-        boolean rememberMe = isRememberMe(request);
-        String host = getHost(request);
-        return createToken(username, password, rememberMe, host);
-    }
-
-    protected AuthenticationToken createToken(String username, String password,
-                                              boolean rememberMe, String host) {
-        return new UsernamePasswordToken(username, password, rememberMe, host);
-    }
-
-    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject,
-                                     ServletRequest request, ServletResponse response) throws Exception {
-        return true;
-    }
-
-    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e,
-                                     ServletRequest request, ServletResponse response) {
-        return false;
-    }
-
-    /**
-     * Returns the host name or IP associated with the current subject.  This method is primarily provided for use
-     * during construction of an <code>AuthenticationToken</code>.
-     * <p/>
-     * The default implementation merely returns {@link ServletRequest#getRemoteHost()}.
-     *
-     * @param request the incoming ServletRequest
-     * @return the <code>InetAddress</code> to associate with the login attempt.
-     */
-    protected String getHost(ServletRequest request) {
-        return request.getRemoteHost();
-    }
-
-    /**
-     * Returns <code>true</code> if &quot;rememberMe&quot; should be enabled for the login attempt associated with the
-     * current <code>request</code>, <code>false</code> otherwise.
-     * <p/>
-     * This implementation always returns <code>false</code> and is provided as a template hook to subclasses that
-     * support <code>rememberMe</code> logins and wish to determine <code>rememberMe</code> in a custom mannner
-     * based on the current <code>request</code>.
-     *
-     * @param request the incoming ServletRequest
-     * @return <code>true</code> if &quot;rememberMe&quot; should be enabled for the login attempt associated with the
-     *         current <code>request</code>, <code>false</code> otherwise.
-     */
-    protected boolean isRememberMe(ServletRequest request) {
-        return false;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authc;
+
+import org.apache.shiro.authc.AuthenticationException;
+import org.apache.shiro.authc.AuthenticationToken;
+import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.subject.Subject;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * An <code>AuthenticationFilter</code> that is capable of automatically performing an authentication attempt
+ * based on the incoming request.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public abstract class AuthenticatingFilter extends AuthenticationFilter {
+
+    //TODO - complete JavaDoc
+
+    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {
+        AuthenticationToken token = createToken(request, response);
+        if (token == null) {
+            String msg = "createToken method implementation returned null. A valid non-null AuthenticationToken " +
+                    "must be created in order to execute a login attempt.";
+            throw new IllegalStateException(msg);
+        }
+        try {
+            Subject subject = getSubject(request, response);
+            subject.login(token);
+            return onLoginSuccess(token, subject, request, response);
+        } catch (AuthenticationException e) {
+            return onLoginFailure(token, e, request, response);
+        }
+    }
+
+    protected abstract AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception;
+
+    protected AuthenticationToken createToken(String username, String password,
+                                              ServletRequest request, ServletResponse response) {
+        boolean rememberMe = isRememberMe(request);
+        String host = getHost(request);
+        return createToken(username, password, rememberMe, host);
+    }
+
+    protected AuthenticationToken createToken(String username, String password,
+                                              boolean rememberMe, String host) {
+        return new UsernamePasswordToken(username, password, rememberMe, host);
+    }
+
+    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject,
+                                     ServletRequest request, ServletResponse response) throws Exception {
+        return true;
+    }
+
+    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e,
+                                     ServletRequest request, ServletResponse response) {
+        return false;
+    }
+
+    /**
+     * Returns the host name or IP associated with the current subject.  This method is primarily provided for use
+     * during construction of an <code>AuthenticationToken</code>.
+     * <p/>
+     * The default implementation merely returns {@link ServletRequest#getRemoteHost()}.
+     *
+     * @param request the incoming ServletRequest
+     * @return the <code>InetAddress</code> to associate with the login attempt.
+     */
+    protected String getHost(ServletRequest request) {
+        return request.getRemoteHost();
+    }
+
+    /**
+     * Returns <code>true</code> if &quot;rememberMe&quot; should be enabled for the login attempt associated with the
+     * current <code>request</code>, <code>false</code> otherwise.
+     * <p/>
+     * This implementation always returns <code>false</code> and is provided as a template hook to subclasses that
+     * support <code>rememberMe</code> logins and wish to determine <code>rememberMe</code> in a custom mannner
+     * based on the current <code>request</code>.
+     *
+     * @param request the incoming ServletRequest
+     * @return <code>true</code> if &quot;rememberMe&quot; should be enabled for the login attempt associated with the
+     *         current <code>request</code>, <code>false</code> otherwise.
+     */
+    protected boolean isRememberMe(ServletRequest request) {
+        return false;
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/authz/HostFilter.java b/web/src/main/java/org/apache/shiro/web/filter/authz/HostFilter.java
index b36428f2d..c21574157 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/authz/HostFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/authz/HostFilter.java
@@ -1,106 +1,106 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authz;
-
-import org.apache.shiro.util.StringUtils;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import java.util.regex.Pattern;
-import java.util.Map;
-
-/**
- * A Filter that can allow or deny access based on the host that sent the request.
- *
- * <b>WARNING:</b> NOT YET FULLY IMPLEMENTED!!!  Work in progress.
- *
- * @since 1.0
- */
-public class HostFilter extends AuthorizationFilter {
-
-    public static final String IPV4_QUAD_REGEX = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2(?:[0-4][0-9]|5[0-5]))";
-
-    public static final String IPV4_REGEX = "(?:" + IPV4_QUAD_REGEX + "\\.){3}" + IPV4_QUAD_REGEX + "$";
-    public static final Pattern IPV4_PATTERN = Pattern.compile(IPV4_REGEX);
-
-    public static final String PRIVATE_CLASS_B_SUBSET = "(?:1[6-9]|2[0-9]|3[0-1])";
-
-    public static final String PRIVATE_CLASS_A_REGEX = "10\\.(?:" + IPV4_QUAD_REGEX + "\\.){2}" + IPV4_QUAD_REGEX + "$";
-
-    public static final String PRIVATE_CLASS_B_REGEX =
-            "172\\." + PRIVATE_CLASS_B_SUBSET + "\\." + IPV4_QUAD_REGEX + "\\." + IPV4_QUAD_REGEX + "$";
-
-    public static final String PRIVATE_CLASS_C_REGEX = "192\\.168\\." + IPV4_QUAD_REGEX + "\\." + IPV4_QUAD_REGEX + "$";
-
-    Map<String, String> authorizedIps; //user-configured IP (which can be wildcarded) to constructed regex mapping
-    Map<String, String> deniedIps;
-    Map<String, String> authorizedHostnames;
-    Map<String, String> deniedHostnames;
-
-
-    public void setAuthorizedHosts(String authorizedHosts) {
-        if (!StringUtils.hasText(authorizedHosts)) {
-            throw new IllegalArgumentException("authorizedHosts argument cannot be null or empty.");
-        }
-        String[] hosts = StringUtils.tokenizeToStringArray(authorizedHosts, ", \t");
-
-        for (String host : hosts) {
-            //replace any periods with \\. to ensure the regex works:
-            String periodsReplaced = host.replace(".", "\\.");
-            //check for IPv4:
-            String wildcardsReplaced = periodsReplaced.replace("*", IPV4_QUAD_REGEX);
-
-            if (IPV4_PATTERN.matcher(wildcardsReplaced).matches()) {
-                authorizedIps.put(host, wildcardsReplaced);
-            } else {
-
-            }
-
-
-        }
-
-    }
-
-    public void setDeniedHosts(String deniedHosts) {
-        if (!StringUtils.hasText(deniedHosts)) {
-            throw new IllegalArgumentException("deniedHosts argument cannot be null or empty.");
-        }
-    }
-
-    protected boolean isIpv4Candidate(String host) {
-        String[] quads = StringUtils.tokenizeToStringArray(host, ".");
-        if (quads == null || quads.length != 4) {
-            return false;
-        }
-        for (String quad : quads) {
-            if (!quad.equals("*")) {
-                try {
-                    Integer.parseInt(quad);
-                } catch (NumberFormatException nfe) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
-        throw new UnsupportedOperationException("Not yet fully implemented!!!" );
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authz;
+
+import org.apache.shiro.util.StringUtils;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import java.util.regex.Pattern;
+import java.util.Map;
+
+/**
+ * A Filter that can allow or deny access based on the host that sent the request.
+ *
+ * <b>WARNING:</b> NOT YET FULLY IMPLEMENTED!!!  Work in progress.
+ *
+ * @since 1.0
+ */
+public class HostFilter extends AuthorizationFilter {
+
+    public static final String IPV4_QUAD_REGEX = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2(?:[0-4][0-9]|5[0-5]))";
+
+    public static final String IPV4_REGEX = "(?:" + IPV4_QUAD_REGEX + "\\.){3}" + IPV4_QUAD_REGEX + "$";
+    public static final Pattern IPV4_PATTERN = Pattern.compile(IPV4_REGEX);
+
+    public static final String PRIVATE_CLASS_B_SUBSET = "(?:1[6-9]|2[0-9]|3[0-1])";
+
+    public static final String PRIVATE_CLASS_A_REGEX = "10\\.(?:" + IPV4_QUAD_REGEX + "\\.){2}" + IPV4_QUAD_REGEX + "$";
+
+    public static final String PRIVATE_CLASS_B_REGEX =
+            "172\\." + PRIVATE_CLASS_B_SUBSET + "\\." + IPV4_QUAD_REGEX + "\\." + IPV4_QUAD_REGEX + "$";
+
+    public static final String PRIVATE_CLASS_C_REGEX = "192\\.168\\." + IPV4_QUAD_REGEX + "\\." + IPV4_QUAD_REGEX + "$";
+
+    Map<String, String> authorizedIps; //user-configured IP (which can be wildcarded) to constructed regex mapping
+    Map<String, String> deniedIps;
+    Map<String, String> authorizedHostnames;
+    Map<String, String> deniedHostnames;
+
+
+    public void setAuthorizedHosts(String authorizedHosts) {
+        if (!StringUtils.hasText(authorizedHosts)) {
+            throw new IllegalArgumentException("authorizedHosts argument cannot be null or empty.");
+        }
+        String[] hosts = StringUtils.tokenizeToStringArray(authorizedHosts, ", \t");
+
+        for (String host : hosts) {
+            //replace any periods with \\. to ensure the regex works:
+            String periodsReplaced = host.replace(".", "\\.");
+            //check for IPv4:
+            String wildcardsReplaced = periodsReplaced.replace("*", IPV4_QUAD_REGEX);
+
+            if (IPV4_PATTERN.matcher(wildcardsReplaced).matches()) {
+                authorizedIps.put(host, wildcardsReplaced);
+            } else {
+
+            }
+
+
+        }
+
+    }
+
+    public void setDeniedHosts(String deniedHosts) {
+        if (!StringUtils.hasText(deniedHosts)) {
+            throw new IllegalArgumentException("deniedHosts argument cannot be null or empty.");
+        }
+    }
+
+    protected boolean isIpv4Candidate(String host) {
+        String[] quads = StringUtils.tokenizeToStringArray(host, ".");
+        if (quads == null || quads.length != 4) {
+            return false;
+        }
+        for (String quad : quads) {
+            if (!quad.equals("*")) {
+                try {
+                    Integer.parseInt(quad);
+                } catch (NumberFormatException nfe) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
+        throw new UnsupportedOperationException("Not yet fully implemented!!!" );
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.java b/web/src/main/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.java
index c2574dd68..4cc3959a3 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.java
@@ -1,269 +1,269 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authz;
-
-import org.apache.shiro.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A filter that translates an HTTP Request's Method (eg GET, POST, etc)
- * into an corresponding action (verb) and uses that verb to construct a permission that will be checked to determine
- * access.
- * <p/>
- * This Filter is primarily provided to support REST environments where the type (Method)
- * of request translates to an action being performed on one or more resources.  This paradigm works well with Shiro's
- * concepts of using permissions for access control and can be leveraged to easily perform permission checks.
- * <p/>
- * This filter functions as follows:
- * <ol>
- * <li>The incoming HTTP request's Method (GET, POST, PUT, DELETE, etc) is discovered.</li>
- * <li>The Method is translated into a more 'application friendly' verb, such as 'create', edit', 'delete', etc.</li>
- * <li>The verb is appended to any configured permissions for the
- * {@link org.apache.shiro.web.filter.PathMatchingFilter currently matching path}.</li>
- * <li>If the current {@code Subject} {@link org.apache.shiro.subject.Subject#isPermitted(String) isPermitted} to
- * perform the resolved action, the request is allowed to continue.</li>
- * </ol>
- * <p/>
- * For example, if the following filter chain was defined, where 'rest' was the name given to a filter instance of
- * this class:
- * <pre>
- * /user/** = rest[user]</pre>
- * Then an HTTP {@code GET} request to {@code /user/1234} would translate to the constructed permission
- * {@code user:read} (GET is mapped to the 'read' action) and execute the permission check
- * <code>Subject.isPermitted(&quot;user:read&quot;)</code> in order to allow the request to continue.
- * <p/>
- * Similarly, an HTTP {@code POST} to {@code /user} would translate to the constructed permission
- * {@code user:create} (POST is mapped to the 'create' action) and execute the permission check
- * <code>Subject.isPermitted(&quot;user:create&quot;)</code> in order to allow the request to continue.
- * <p/>
- * <h3>Method To Verb Mapping</h3>
- * The following table represents the default HTTP Method-to-action verb mapping:
- * <table>
- * <tr><th>HTTP Method</th><th>Mapped Action</th><th>Example Permission</th><th>Runtime Check</th></tr>
- * <tr><td>head</td><td>read</td><td>perm1</td><td>perm1:read</td></tr>
- * <tr><td>get</td><td>read</td><td>perm2</td><td>perm2:read</td></tr>
- * <tr><td>put</td><td>update</td><td>perm3</td><td>perm3:update</td></tr>
- * <tr><td>post</td><td>create</td><td>perm4</td><td>perm4:create</td></tr>
- * <tr><td>mkcol</td><td>create</td><td>perm5</td><td>perm5:create</td></tr>
- * <tr><td>options</td><td>read</td><td>perm6</td><td>perm6:read</td></tr>
- * <tr><td>trace</td><td>read</td><td>perm7</td><td>perm7:read</td></tr>
- * </table>
- *
- * @author Brian Demers
- * @author Tamas Cservenak
- * @author Les Hazlewood
- * @since 1.0
- */
-public class HttpMethodPermissionFilter extends PermissionsAuthorizationFilter {
-
-    /**
-     * This class's private logger.
-     */
-    private static final Logger log = LoggerFactory.getLogger(HttpMethodPermissionFilter.class);
-
-    /**
-     * Map that contains a mapping between http methods to permission actions (verbs)
-     */
-    private final Map<String, String> httpMethodActions = new HashMap<String, String>();
-
-    //Actions representing HTTP Method values (GET -> read, POST -> create, etc)
-    private static final String CREATE_ACTION = "create";
-    private static final String READ_ACTION = "read";
-    private static final String UPDATE_ACTION = "update";
-    private static final String DELETE_ACTION = "delete";
-
-    /**
-     * Enum of constants for well-defined mapping values.  Used in the Filter's constructor to perform the map instance
-     * used at runtime.
-     */
-    private static enum HttpMethodAction {
-
-        DELETE(DELETE_ACTION),
-        GET(READ_ACTION),
-        HEAD(READ_ACTION),
-        MKCOL(CREATE_ACTION), //webdav, but useful here
-        OPTIONS(READ_ACTION),
-        POST(CREATE_ACTION),
-        PUT(UPDATE_ACTION),
-        TRACE(READ_ACTION);
-
-        private final String action;
-
-        private HttpMethodAction(String action) {
-            this.action = action;
-        }
-
-        public String getAction() {
-            return this.action;
-        }
-    }
-
-    /**
-     * Creates the filter instance with default method-to-action values in the instance's
-     * {@link #getHttpMethodActions() http method actions map}.
-     */
-    public HttpMethodPermissionFilter() {
-        for (HttpMethodAction methodAction : HttpMethodAction.values()) {
-            httpMethodActions.put(methodAction.name().toLowerCase(), methodAction.getAction());
-        }
-    }
-
-    /**
-     * Returns the HTTP Method name (key) to action verb (value) mapping used to resolve actions based on an
-     * incoming {@code HttpServletRequest}.  All keys and values are lower-case.  The
-     * default key/value pairs are defined in the top class-level JavaDoc.
-     *
-     * @return the HTTP Method lower-case name (key) to lower-case action verb (value) mapping
-     */
-    protected Map<String, String> getHttpMethodActions() {
-        return this.httpMethodActions;
-    }
-
-    /**
-     * Determines the action (verb) attempting to be performed on the filtered resource by the current request.
-     * <p/>
-     * This implementation expects the incoming request to be an {@link HttpServletRequest} and returns a mapped
-     * action based on the HTTP request {@link javax.servlet.http.HttpServletRequest#getMethod() method}.
-     *
-     * @param request to pull the method from.
-     * @return The string equivalent verb of the http method.
-     */
-    protected String getHttpMethodAction(ServletRequest request) {
-        String method = ((HttpServletRequest) request).getMethod();
-        return getHttpMethodAction(method);
-    }
-
-    /**
-     * Determines the corresponding application action that will be performed on the filtered resource based on the
-     * specified HTTP method (GET, POST, etc).
-     *
-     * @param method to be translated into the verb.
-     * @return The string equivalent verb of the method.
-     */
-    protected String getHttpMethodAction(String method) {
-        String lc = method.toLowerCase();
-        String resolved = getHttpMethodActions().get(lc);
-        return resolved != null ? resolved : method;
-    }
-
-    /**
-     * Returns a collection of String permissions with which to perform a permission check to determine if the filter
-     * will allow the request to continue.
-     * <p/>
-     * This implementation merely delegates to {@link #buildPermissions(String[], String)} and ignores the inbound
-     * HTTP servlet request, but it can be overridden by subclasses for more complex request-specific building logic
-     * if necessary.
-     *
-     * @param request         the inbound HTTP request - ignored in this implementation, but available to
-     *                        subclasses for more complex construction building logic if necessary
-     * @param configuredPerms any url-specific permissions mapped to this filter in the URL rules mappings.
-     * @param action          the application-friendly action (verb) resolved based on the HTTP Method name.
-     * @return a collection of String permissions with which to perform a permission check to determine if the filter
-     *         will allow the request to continue.
-     */
-    protected String[] buildPermissions(HttpServletRequest request, String[] configuredPerms, String action) {
-        return buildPermissions(configuredPerms, action);
-    }
-
-    /**
-     * Builds a new array of permission strings based on the original argument, appending the specified action verb
-     * to each one per {@link org.apache.shiro.authz.permission.WildcardPermission WildcardPermission} conventions.  The
-     * built permission strings will be the ones used at runtime during the permission check that determines if filter
-     * access should be allowed to continue or not.
-     * <p/>
-     * For example, if the {@code configuredPerms} argument contains the following 3 permission strings:
-     * <p/>
-     * <ol>
-     * <li>permission:one</li>
-     * <li>permission:two</li>
-     * <li>permission:three</li>
-     * </ol>
-     * And the action is {@code read}, then the return value will be:
-     * <ol>
-     * <li>permission:one:read</li>
-     * <li>permission:two:read</li>
-     * <li>permission:three:read</li>
-     * </ol>
-     * per {@link org.apache.shiro.authz.permission.WildcardPermission WildcardPermission} conventions.  Subclasses
-     * are of course free to override this method or the
-     * {@link #buildPermissions(javax.servlet.http.HttpServletRequest, String[], String) buildPermissions} request
-     * variant for custom building logic or with different permission formats.
-     *
-     * @param configuredPerms list of configuredPerms to be converted.
-     * @param action          the resolved action based on the request method to be appended to permission strings.
-     * @return an array of permission strings with each element appended with the action.
-     */
-    protected String[] buildPermissions(String[] configuredPerms, String action) {
-        if (configuredPerms == null || configuredPerms.length <= 0 || !StringUtils.hasText(action)) {
-            return configuredPerms;
-        }
-
-        String[] mappedPerms = new String[configuredPerms.length];
-
-        // loop and append :action
-        for (int i = 0; i < configuredPerms.length; i++) {
-            mappedPerms[i] = configuredPerms[i] + ":" + action;
-        }
-
-        if (log.isTraceEnabled()) {
-            StringBuffer sb = new StringBuffer();
-            for (int i = 0; i < mappedPerms.length; i++) {
-                if (i > 0) {
-                    sb.append(", ");
-                }
-                sb.append(mappedPerms[i]);
-            }
-            log.trace("MAPPED '{}' action to permission(s) '{}'", action, sb);
-        }
-
-        return mappedPerms;
-    }
-
-    /**
-     * Resolves an 'application friendly' action verb based on the {@code HttpServletRequest}'s method, appends that
-     * action to each configured permission (the {@code mappedValue} argument is a {@code String[]} array), and
-     * delegates the permission check for the newly constructed permission(s) to the superclass
-     * {@link PermissionsAuthorizationFilter#isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed}
-     * implementation to perform the actual permission check.
-     *
-     * @param request     the inbound {@code ServletRequest}
-     * @param response    the outbound {@code ServletResponse}
-     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.
-     * @return {@code true} if the request should proceed through the filter normally, {@code false} if the
-     *         request should be processed by this filter's
-     *         {@link #onAccessDenied(ServletRequest,ServletResponse,Object)} method instead.
-     * @throws IOException
-     */
-    @Override
-    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {
-        String[] perms = (String[]) mappedValue;
-        // append the http action to the end of the permissions and then back to super
-        String action = getHttpMethodAction(request);
-        String[] resolvedPerms = buildPermissions(perms, action);
-        return super.isAccessAllowed(request, response, resolvedPerms);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authz;
+
+import org.apache.shiro.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A filter that translates an HTTP Request's Method (eg GET, POST, etc)
+ * into an corresponding action (verb) and uses that verb to construct a permission that will be checked to determine
+ * access.
+ * <p/>
+ * This Filter is primarily provided to support REST environments where the type (Method)
+ * of request translates to an action being performed on one or more resources.  This paradigm works well with Shiro's
+ * concepts of using permissions for access control and can be leveraged to easily perform permission checks.
+ * <p/>
+ * This filter functions as follows:
+ * <ol>
+ * <li>The incoming HTTP request's Method (GET, POST, PUT, DELETE, etc) is discovered.</li>
+ * <li>The Method is translated into a more 'application friendly' verb, such as 'create', edit', 'delete', etc.</li>
+ * <li>The verb is appended to any configured permissions for the
+ * {@link org.apache.shiro.web.filter.PathMatchingFilter currently matching path}.</li>
+ * <li>If the current {@code Subject} {@link org.apache.shiro.subject.Subject#isPermitted(String) isPermitted} to
+ * perform the resolved action, the request is allowed to continue.</li>
+ * </ol>
+ * <p/>
+ * For example, if the following filter chain was defined, where 'rest' was the name given to a filter instance of
+ * this class:
+ * <pre>
+ * /user/** = rest[user]</pre>
+ * Then an HTTP {@code GET} request to {@code /user/1234} would translate to the constructed permission
+ * {@code user:read} (GET is mapped to the 'read' action) and execute the permission check
+ * <code>Subject.isPermitted(&quot;user:read&quot;)</code> in order to allow the request to continue.
+ * <p/>
+ * Similarly, an HTTP {@code POST} to {@code /user} would translate to the constructed permission
+ * {@code user:create} (POST is mapped to the 'create' action) and execute the permission check
+ * <code>Subject.isPermitted(&quot;user:create&quot;)</code> in order to allow the request to continue.
+ * <p/>
+ * <h3>Method To Verb Mapping</h3>
+ * The following table represents the default HTTP Method-to-action verb mapping:
+ * <table>
+ * <tr><th>HTTP Method</th><th>Mapped Action</th><th>Example Permission</th><th>Runtime Check</th></tr>
+ * <tr><td>head</td><td>read</td><td>perm1</td><td>perm1:read</td></tr>
+ * <tr><td>get</td><td>read</td><td>perm2</td><td>perm2:read</td></tr>
+ * <tr><td>put</td><td>update</td><td>perm3</td><td>perm3:update</td></tr>
+ * <tr><td>post</td><td>create</td><td>perm4</td><td>perm4:create</td></tr>
+ * <tr><td>mkcol</td><td>create</td><td>perm5</td><td>perm5:create</td></tr>
+ * <tr><td>options</td><td>read</td><td>perm6</td><td>perm6:read</td></tr>
+ * <tr><td>trace</td><td>read</td><td>perm7</td><td>perm7:read</td></tr>
+ * </table>
+ *
+ * @author Brian Demers
+ * @author Tamas Cservenak
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public class HttpMethodPermissionFilter extends PermissionsAuthorizationFilter {
+
+    /**
+     * This class's private logger.
+     */
+    private static final Logger log = LoggerFactory.getLogger(HttpMethodPermissionFilter.class);
+
+    /**
+     * Map that contains a mapping between http methods to permission actions (verbs)
+     */
+    private final Map<String, String> httpMethodActions = new HashMap<String, String>();
+
+    //Actions representing HTTP Method values (GET -> read, POST -> create, etc)
+    private static final String CREATE_ACTION = "create";
+    private static final String READ_ACTION = "read";
+    private static final String UPDATE_ACTION = "update";
+    private static final String DELETE_ACTION = "delete";
+
+    /**
+     * Enum of constants for well-defined mapping values.  Used in the Filter's constructor to perform the map instance
+     * used at runtime.
+     */
+    private static enum HttpMethodAction {
+
+        DELETE(DELETE_ACTION),
+        GET(READ_ACTION),
+        HEAD(READ_ACTION),
+        MKCOL(CREATE_ACTION), //webdav, but useful here
+        OPTIONS(READ_ACTION),
+        POST(CREATE_ACTION),
+        PUT(UPDATE_ACTION),
+        TRACE(READ_ACTION);
+
+        private final String action;
+
+        private HttpMethodAction(String action) {
+            this.action = action;
+        }
+
+        public String getAction() {
+            return this.action;
+        }
+    }
+
+    /**
+     * Creates the filter instance with default method-to-action values in the instance's
+     * {@link #getHttpMethodActions() http method actions map}.
+     */
+    public HttpMethodPermissionFilter() {
+        for (HttpMethodAction methodAction : HttpMethodAction.values()) {
+            httpMethodActions.put(methodAction.name().toLowerCase(), methodAction.getAction());
+        }
+    }
+
+    /**
+     * Returns the HTTP Method name (key) to action verb (value) mapping used to resolve actions based on an
+     * incoming {@code HttpServletRequest}.  All keys and values are lower-case.  The
+     * default key/value pairs are defined in the top class-level JavaDoc.
+     *
+     * @return the HTTP Method lower-case name (key) to lower-case action verb (value) mapping
+     */
+    protected Map<String, String> getHttpMethodActions() {
+        return this.httpMethodActions;
+    }
+
+    /**
+     * Determines the action (verb) attempting to be performed on the filtered resource by the current request.
+     * <p/>
+     * This implementation expects the incoming request to be an {@link HttpServletRequest} and returns a mapped
+     * action based on the HTTP request {@link javax.servlet.http.HttpServletRequest#getMethod() method}.
+     *
+     * @param request to pull the method from.
+     * @return The string equivalent verb of the http method.
+     */
+    protected String getHttpMethodAction(ServletRequest request) {
+        String method = ((HttpServletRequest) request).getMethod();
+        return getHttpMethodAction(method);
+    }
+
+    /**
+     * Determines the corresponding application action that will be performed on the filtered resource based on the
+     * specified HTTP method (GET, POST, etc).
+     *
+     * @param method to be translated into the verb.
+     * @return The string equivalent verb of the method.
+     */
+    protected String getHttpMethodAction(String method) {
+        String lc = method.toLowerCase();
+        String resolved = getHttpMethodActions().get(lc);
+        return resolved != null ? resolved : method;
+    }
+
+    /**
+     * Returns a collection of String permissions with which to perform a permission check to determine if the filter
+     * will allow the request to continue.
+     * <p/>
+     * This implementation merely delegates to {@link #buildPermissions(String[], String)} and ignores the inbound
+     * HTTP servlet request, but it can be overridden by subclasses for more complex request-specific building logic
+     * if necessary.
+     *
+     * @param request         the inbound HTTP request - ignored in this implementation, but available to
+     *                        subclasses for more complex construction building logic if necessary
+     * @param configuredPerms any url-specific permissions mapped to this filter in the URL rules mappings.
+     * @param action          the application-friendly action (verb) resolved based on the HTTP Method name.
+     * @return a collection of String permissions with which to perform a permission check to determine if the filter
+     *         will allow the request to continue.
+     */
+    protected String[] buildPermissions(HttpServletRequest request, String[] configuredPerms, String action) {
+        return buildPermissions(configuredPerms, action);
+    }
+
+    /**
+     * Builds a new array of permission strings based on the original argument, appending the specified action verb
+     * to each one per {@link org.apache.shiro.authz.permission.WildcardPermission WildcardPermission} conventions.  The
+     * built permission strings will be the ones used at runtime during the permission check that determines if filter
+     * access should be allowed to continue or not.
+     * <p/>
+     * For example, if the {@code configuredPerms} argument contains the following 3 permission strings:
+     * <p/>
+     * <ol>
+     * <li>permission:one</li>
+     * <li>permission:two</li>
+     * <li>permission:three</li>
+     * </ol>
+     * And the action is {@code read}, then the return value will be:
+     * <ol>
+     * <li>permission:one:read</li>
+     * <li>permission:two:read</li>
+     * <li>permission:three:read</li>
+     * </ol>
+     * per {@link org.apache.shiro.authz.permission.WildcardPermission WildcardPermission} conventions.  Subclasses
+     * are of course free to override this method or the
+     * {@link #buildPermissions(javax.servlet.http.HttpServletRequest, String[], String) buildPermissions} request
+     * variant for custom building logic or with different permission formats.
+     *
+     * @param configuredPerms list of configuredPerms to be converted.
+     * @param action          the resolved action based on the request method to be appended to permission strings.
+     * @return an array of permission strings with each element appended with the action.
+     */
+    protected String[] buildPermissions(String[] configuredPerms, String action) {
+        if (configuredPerms == null || configuredPerms.length <= 0 || !StringUtils.hasText(action)) {
+            return configuredPerms;
+        }
+
+        String[] mappedPerms = new String[configuredPerms.length];
+
+        // loop and append :action
+        for (int i = 0; i < configuredPerms.length; i++) {
+            mappedPerms[i] = configuredPerms[i] + ":" + action;
+        }
+
+        if (log.isTraceEnabled()) {
+            StringBuffer sb = new StringBuffer();
+            for (int i = 0; i < mappedPerms.length; i++) {
+                if (i > 0) {
+                    sb.append(", ");
+                }
+                sb.append(mappedPerms[i]);
+            }
+            log.trace("MAPPED '{}' action to permission(s) '{}'", action, sb);
+        }
+
+        return mappedPerms;
+    }
+
+    /**
+     * Resolves an 'application friendly' action verb based on the {@code HttpServletRequest}'s method, appends that
+     * action to each configured permission (the {@code mappedValue} argument is a {@code String[]} array), and
+     * delegates the permission check for the newly constructed permission(s) to the superclass
+     * {@link PermissionsAuthorizationFilter#isAccessAllowed(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Object) isAccessAllowed}
+     * implementation to perform the actual permission check.
+     *
+     * @param request     the inbound {@code ServletRequest}
+     * @param response    the outbound {@code ServletResponse}
+     * @param mappedValue the filter-specific config value mapped to this filter in the URL rules mappings.
+     * @return {@code true} if the request should proceed through the filter normally, {@code false} if the
+     *         request should be processed by this filter's
+     *         {@link #onAccessDenied(ServletRequest,ServletResponse,Object)} method instead.
+     * @throws IOException
+     */
+    @Override
+    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {
+        String[] perms = (String[]) mappedValue;
+        // append the http action to the end of the permissions and then back to super
+        String action = getHttpMethodAction(request);
+        String[] resolvedPerms = buildPermissions(perms, action);
+        return super.isAccessAllowed(request, response, resolvedPerms);
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java
index 7e21424e8..1685e023b 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManager.java
@@ -1,271 +1,271 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.config.ConfigurationException;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.Nameable;
-import org.apache.shiro.util.StringUtils;
-import org.apache.shiro.web.filter.PathConfigProcessor;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletException;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-
-import static org.apache.shiro.util.StringUtils.split;
-
-/**
- * Default {@link FilterChainManager} implementation maintaining a map of {@link Filter Filter} instances
- * (key: filter name, value: Filter) as well as a map of {@link NamedFilterList NamedFilterList}s created from these
- * {@code Filter}s (key: filter chain name, value: NamedFilterList).  The {@code NamedFilterList} is essentially a
- * {@link FilterChain} that also has a name property by which it can be looked up.
- *
- * @author Les Hazlewood
- * @see NamedFilterList
- * @since 1.0
- */
-public class DefaultFilterChainManager implements FilterChainManager {
-
-    private static transient final Logger log = LoggerFactory.getLogger(DefaultFilterChainManager.class);
-
-    private FilterConfig filterConfig;
-
-    private Map<String, Filter> filters; //pool of filters available for creating chains
-
-    private Map<String, NamedFilterList> filterChains; //key: chain name, value: chain
-
-    public DefaultFilterChainManager() {
-        this.filters = new LinkedHashMap<String, Filter>();
-        this.filterChains = new LinkedHashMap<String, NamedFilterList>();
-        addDefaultFilters(false);
-    }
-
-    public DefaultFilterChainManager(FilterConfig filterConfig) {
-        this.filters = new LinkedHashMap<String, Filter>();
-        this.filterChains = new LinkedHashMap<String, NamedFilterList>();
-        setFilterConfig(filterConfig);
-        addDefaultFilters(true);
-    }
-
-    /**
-     * Returns the {@code FilterConfig} provided by the Servlet container at webapp startup.
-     *
-     * @return the {@code FilterConfig} provided by the Servlet container at webapp startup.
-     */
-    public FilterConfig getFilterConfig() {
-        return filterConfig;
-    }
-
-    /**
-     * Sets the {@code FilterConfig} provided by the Servlet container at webapp startup.
-     *
-     * @param filterConfig the {@code FilterConfig} provided by the Servlet container at webapp startup.
-     */
-    public void setFilterConfig(FilterConfig filterConfig) {
-        this.filterConfig = filterConfig;
-    }
-
-    public Map<String, Filter> getFilters() {
-        return filters;
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public void setFilters(Map<String, Filter> filters) {
-        this.filters = filters;
-    }
-
-    public Map<String, NamedFilterList> getFilterChains() {
-        return filterChains;
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public void setFilterChains(Map<String, NamedFilterList> filterChains) {
-        this.filterChains = filterChains;
-    }
-
-    public Filter getFilter(String name) {
-        return this.filters.get(name);
-    }
-
-    public void addFilter(String name, Filter filter) {
-        addFilter(name, filter, true);
-    }
-
-    public void addFilter(String name, Filter filter, boolean init) {
-        addFilter(name, filter, init, true);
-    }
-
-    public void createChain(String chainName, String chainDefinition) {
-        if (!StringUtils.hasText(chainName)) {
-            throw new NullPointerException("chainName cannot be null or empty.");
-        }
-        if (!StringUtils.hasText(chainDefinition)) {
-            throw new NullPointerException("chainDefinition cannot be null or empty.");
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("Creating chain [" + chainName + "] from String definition [" + chainDefinition + "]");
-        }
-
-        //parse the value by tokenizing it to get the resulting filter-specific config entries
-        //
-        //e.g. for a value of
-        //
-        //     "authc, roles[admin,user], perms[file:edit]"
-        //
-        // the resulting token array would equal
-        //
-        //     { "authc", "roles[admin,user]", "perms[file:edit]" }
-        //
-        String[] filterTokens = split(chainDefinition);
-
-        //each token is specific to each filter.
-        //strip the name and extract any filter-specific config between brackets [ ]
-        for (String token : filterTokens) {
-            String[] nameAndConfig = token.split("\\[", 2);
-            String name = nameAndConfig[0];
-            String config = null;
-
-            if (nameAndConfig.length == 2) {
-                config = nameAndConfig[1];
-                //if there was an open bracket, there was a close bracket, so strip it too:
-                config = config.substring(0, config.length() - 1);
-            }
-
-            //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:
-            addToChain(chainName, name, config);
-        }
-    }
-
-    protected void addFilter(String name, Filter filter, boolean init, boolean overwrite) {
-        Filter existing = getFilter(name);
-        if (existing == null || overwrite) {
-            if (filter instanceof Nameable) {
-                ((Nameable) filter).setName(name);
-            }
-            if (init) {
-                initFilter(filter);
-            }
-            this.filters.put(name, filter);
-        }
-    }
-
-    public void addToChain(String chainName, String filterName) {
-        addToChain(chainName, filterName, null);
-    }
-
-    public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) {
-        if (!StringUtils.hasText(chainName)) {
-            throw new IllegalArgumentException("chainName cannot be null or empty.");
-        }
-        Filter filter = getFilter(filterName);
-        if (filter == null) {
-            throw new IllegalArgumentException("There is no filter with name '" + filterName +
-                    "' to apply to chain [" + chainName + "] in the pool of available Filters.  Ensure a " +
-                    "filter with that name/path has first been registered with the addFilter method(s).");
-        }
-
-        applyChainConfig(chainName, filter, chainSpecificFilterConfig);
-
-        NamedFilterList chain = ensureChain(chainName);
-        chain.add(filter);
-    }
-
-    protected void applyChainConfig(String chainName, Filter filter, String chainSpecificFilterConfig) {
-        if (log.isDebugEnabled()) {
-            log.debug("Attempting to apply path [" + chainName + "] to filter [" + filter + "] " +
-                    "with config [" + chainSpecificFilterConfig + "]");
-        }
-        if (filter instanceof PathConfigProcessor) {
-            ((PathConfigProcessor) filter).processPathConfig(chainName, chainSpecificFilterConfig);
-        } else {
-            if (StringUtils.hasText(chainSpecificFilterConfig)) {
-                //they specified a filter configuration, but the Filter doesn't implement PathConfigProcessor
-                //this is an erroneous config:
-                String msg = "chainSpecificFilterConfig was specified, but the underlying " +
-                        "Filter instance is not an 'instanceof' " +
-                        PathConfigProcessor.class.getName() + ".  This is required if the filter is to accept " +
-                        "chain-specific configuration.";
-                throw new ConfigurationException(msg);
-            }
-        }
-    }
-
-    protected NamedFilterList ensureChain(String chainName) {
-        NamedFilterList chain = getChain(chainName);
-        if (chain == null) {
-            chain = new SimpleNamedFilterList(chainName);
-            this.filterChains.put(chainName, chain);
-        }
-        return chain;
-    }
-
-    public NamedFilterList getChain(String chainName) {
-        return this.filterChains.get(chainName);
-    }
-
-    public boolean hasChains() {
-        return !CollectionUtils.isEmpty(this.filterChains);
-    }
-
-    public Set<String> getChainNames() {
-        //noinspection unchecked
-        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;
-    }
-
-    public FilterChain proxy(FilterChain original, String chainName) {
-        NamedFilterList configured = getChain(chainName);
-        if (configured == null) {
-            String msg = "There is no configured chain under the name/key [" + chainName + "].";
-            throw new IllegalArgumentException(msg);
-        }
-        return configured.proxy(original);
-    }
-
-    /**
-     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );</code>.
-     *
-     * @param filter the filter to initialize with the {@code FilterConfig}.
-     */
-    protected void initFilter(Filter filter) {
-        FilterConfig filterConfig = getFilterConfig();
-        if (filterConfig == null) {
-            throw new IllegalStateException("FilterConfig attribute has not been set.  This must occur before filter " +
-                    "initialization can occur.");
-        }
-        try {
-            filter.init(filterConfig);
-        } catch (ServletException e) {
-            throw new ConfigurationException(e);
-        }
-    }
-
-    protected void addDefaultFilters(boolean init) {
-        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
-            addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.config.ConfigurationException;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.Nameable;
+import org.apache.shiro.util.StringUtils;
+import org.apache.shiro.web.filter.PathConfigProcessor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+import static org.apache.shiro.util.StringUtils.split;
+
+/**
+ * Default {@link FilterChainManager} implementation maintaining a map of {@link Filter Filter} instances
+ * (key: filter name, value: Filter) as well as a map of {@link NamedFilterList NamedFilterList}s created from these
+ * {@code Filter}s (key: filter chain name, value: NamedFilterList).  The {@code NamedFilterList} is essentially a
+ * {@link FilterChain} that also has a name property by which it can be looked up.
+ *
+ * @author Les Hazlewood
+ * @see NamedFilterList
+ * @since 1.0
+ */
+public class DefaultFilterChainManager implements FilterChainManager {
+
+    private static transient final Logger log = LoggerFactory.getLogger(DefaultFilterChainManager.class);
+
+    private FilterConfig filterConfig;
+
+    private Map<String, Filter> filters; //pool of filters available for creating chains
+
+    private Map<String, NamedFilterList> filterChains; //key: chain name, value: chain
+
+    public DefaultFilterChainManager() {
+        this.filters = new LinkedHashMap<String, Filter>();
+        this.filterChains = new LinkedHashMap<String, NamedFilterList>();
+        addDefaultFilters(false);
+    }
+
+    public DefaultFilterChainManager(FilterConfig filterConfig) {
+        this.filters = new LinkedHashMap<String, Filter>();
+        this.filterChains = new LinkedHashMap<String, NamedFilterList>();
+        setFilterConfig(filterConfig);
+        addDefaultFilters(true);
+    }
+
+    /**
+     * Returns the {@code FilterConfig} provided by the Servlet container at webapp startup.
+     *
+     * @return the {@code FilterConfig} provided by the Servlet container at webapp startup.
+     */
+    public FilterConfig getFilterConfig() {
+        return filterConfig;
+    }
+
+    /**
+     * Sets the {@code FilterConfig} provided by the Servlet container at webapp startup.
+     *
+     * @param filterConfig the {@code FilterConfig} provided by the Servlet container at webapp startup.
+     */
+    public void setFilterConfig(FilterConfig filterConfig) {
+        this.filterConfig = filterConfig;
+    }
+
+    public Map<String, Filter> getFilters() {
+        return filters;
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public void setFilters(Map<String, Filter> filters) {
+        this.filters = filters;
+    }
+
+    public Map<String, NamedFilterList> getFilterChains() {
+        return filterChains;
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public void setFilterChains(Map<String, NamedFilterList> filterChains) {
+        this.filterChains = filterChains;
+    }
+
+    public Filter getFilter(String name) {
+        return this.filters.get(name);
+    }
+
+    public void addFilter(String name, Filter filter) {
+        addFilter(name, filter, true);
+    }
+
+    public void addFilter(String name, Filter filter, boolean init) {
+        addFilter(name, filter, init, true);
+    }
+
+    public void createChain(String chainName, String chainDefinition) {
+        if (!StringUtils.hasText(chainName)) {
+            throw new NullPointerException("chainName cannot be null or empty.");
+        }
+        if (!StringUtils.hasText(chainDefinition)) {
+            throw new NullPointerException("chainDefinition cannot be null or empty.");
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Creating chain [" + chainName + "] from String definition [" + chainDefinition + "]");
+        }
+
+        //parse the value by tokenizing it to get the resulting filter-specific config entries
+        //
+        //e.g. for a value of
+        //
+        //     "authc, roles[admin,user], perms[file:edit]"
+        //
+        // the resulting token array would equal
+        //
+        //     { "authc", "roles[admin,user]", "perms[file:edit]" }
+        //
+        String[] filterTokens = split(chainDefinition);
+
+        //each token is specific to each filter.
+        //strip the name and extract any filter-specific config between brackets [ ]
+        for (String token : filterTokens) {
+            String[] nameAndConfig = token.split("\\[", 2);
+            String name = nameAndConfig[0];
+            String config = null;
+
+            if (nameAndConfig.length == 2) {
+                config = nameAndConfig[1];
+                //if there was an open bracket, there was a close bracket, so strip it too:
+                config = config.substring(0, config.length() - 1);
+            }
+
+            //now we have the filter name, path and (possibly null) path-specific config.  Let's apply them:
+            addToChain(chainName, name, config);
+        }
+    }
+
+    protected void addFilter(String name, Filter filter, boolean init, boolean overwrite) {
+        Filter existing = getFilter(name);
+        if (existing == null || overwrite) {
+            if (filter instanceof Nameable) {
+                ((Nameable) filter).setName(name);
+            }
+            if (init) {
+                initFilter(filter);
+            }
+            this.filters.put(name, filter);
+        }
+    }
+
+    public void addToChain(String chainName, String filterName) {
+        addToChain(chainName, filterName, null);
+    }
+
+    public void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) {
+        if (!StringUtils.hasText(chainName)) {
+            throw new IllegalArgumentException("chainName cannot be null or empty.");
+        }
+        Filter filter = getFilter(filterName);
+        if (filter == null) {
+            throw new IllegalArgumentException("There is no filter with name '" + filterName +
+                    "' to apply to chain [" + chainName + "] in the pool of available Filters.  Ensure a " +
+                    "filter with that name/path has first been registered with the addFilter method(s).");
+        }
+
+        applyChainConfig(chainName, filter, chainSpecificFilterConfig);
+
+        NamedFilterList chain = ensureChain(chainName);
+        chain.add(filter);
+    }
+
+    protected void applyChainConfig(String chainName, Filter filter, String chainSpecificFilterConfig) {
+        if (log.isDebugEnabled()) {
+            log.debug("Attempting to apply path [" + chainName + "] to filter [" + filter + "] " +
+                    "with config [" + chainSpecificFilterConfig + "]");
+        }
+        if (filter instanceof PathConfigProcessor) {
+            ((PathConfigProcessor) filter).processPathConfig(chainName, chainSpecificFilterConfig);
+        } else {
+            if (StringUtils.hasText(chainSpecificFilterConfig)) {
+                //they specified a filter configuration, but the Filter doesn't implement PathConfigProcessor
+                //this is an erroneous config:
+                String msg = "chainSpecificFilterConfig was specified, but the underlying " +
+                        "Filter instance is not an 'instanceof' " +
+                        PathConfigProcessor.class.getName() + ".  This is required if the filter is to accept " +
+                        "chain-specific configuration.";
+                throw new ConfigurationException(msg);
+            }
+        }
+    }
+
+    protected NamedFilterList ensureChain(String chainName) {
+        NamedFilterList chain = getChain(chainName);
+        if (chain == null) {
+            chain = new SimpleNamedFilterList(chainName);
+            this.filterChains.put(chainName, chain);
+        }
+        return chain;
+    }
+
+    public NamedFilterList getChain(String chainName) {
+        return this.filterChains.get(chainName);
+    }
+
+    public boolean hasChains() {
+        return !CollectionUtils.isEmpty(this.filterChains);
+    }
+
+    public Set<String> getChainNames() {
+        //noinspection unchecked
+        return this.filterChains != null ? this.filterChains.keySet() : Collections.EMPTY_SET;
+    }
+
+    public FilterChain proxy(FilterChain original, String chainName) {
+        NamedFilterList configured = getChain(chainName);
+        if (configured == null) {
+            String msg = "There is no configured chain under the name/key [" + chainName + "].";
+            throw new IllegalArgumentException(msg);
+        }
+        return configured.proxy(original);
+    }
+
+    /**
+     * Initializes the filter by calling <code>filter.init( {@link #getFilterConfig() getFilterConfig()} );</code>.
+     *
+     * @param filter the filter to initialize with the {@code FilterConfig}.
+     */
+    protected void initFilter(Filter filter) {
+        FilterConfig filterConfig = getFilterConfig();
+        if (filterConfig == null) {
+            throw new IllegalStateException("FilterConfig attribute has not been set.  This must occur before filter " +
+                    "initialization can occur.");
+        }
+        try {
+            filter.init(filterConfig);
+        } catch (ServletException e) {
+            throw new ConfigurationException(e);
+        }
+    }
+
+    protected void addDefaultFilters(boolean init) {
+        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
+            addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false);
+        }
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainManager.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainManager.java
index f3d2a715f..212023a76 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainManager.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainManager.java
@@ -1,198 +1,198 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.config.ConfigurationException;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * A {@code FilterChainManager} manages the creation and modification of {@link Filter} chains from an available pool
- * of {@link Filter} instances.
- *
- * @since 1.0
- */
-public interface FilterChainManager {
-
-    /**
-     * Returns the pool of available {@code Filter}s managed by this manager, keyed by {@code name}.
-     *
-     * @return the pool of available {@code Filter}s managed by this manager, keyed by {@code name}.
-     */
-    Map<String, Filter> getFilters();
-
-    /**
-     * Returns the filter chain identified by the specified {@code chainName} or {@code null} if there is no chain with
-     * that name.
-     *
-     * @param chainName the name identifying the filter chain.
-     * @return the filter chain identified by the specified {@code chainName} or {@code null} if there is no chain with
-     *         that name.
-     */
-    NamedFilterList getChain(String chainName);
-
-    /**
-     * Returns {@code true} if one or more configured chains are available, {@code false} if none are configured.
-     *
-     * @return {@code true} if one or more configured chains are available, {@code false} if none are configured.
-     */
-    boolean hasChains();
-
-    /**
-     * Returns the names of all configured chains or an empty {@code Set} if no chains have been configured.
-     *
-     * @return the names of all configured chains or an empty {@code Set} if no chains have been configured.
-     */
-    Set<String> getChainNames();
-
-    /**
-     * Proxies the specified {@code original} FilterChain with the named chain.  The returned
-     * {@code FilterChain} instance will first execute the configured named chain and then lastly invoke the given
-     * {@code original} chain.
-     *
-     * @param original  the original FilterChain to proxy
-     * @param chainName the name of the internal configured filter chain that should 'sit in front' of the specified
-     *                  original chain.
-     * @return a {@code FilterChain} instance that will execute the named chain and then finally the
-     *         specified {@code original} FilterChain instance.
-     * @throws IllegalArgumentException if there is no configured chain with the given {@code chainName}.
-     */
-    FilterChain proxy(FilterChain original, String chainName);
-
-    /**
-     * Adds a filter to the 'pool' of available filters that can be used when
-     * {@link #addToChain(String, String, String) creating filter chains}.
-     * <p/>
-     * Calling this method is effectively the same as calling
-     * <code>{@link #addFilter(String, javax.servlet.Filter, boolean) addFilter}(name, filter, <b>true</b>);</code>
-     *
-     * @param name   the name to assign to the filter, used to reference the filter in chain definitions
-     * @param filter the filter to initialize and then add to the pool of available filters that can be used
-     */
-    void addFilter(String name, Filter filter);
-
-    /**
-     * Adds a filter to the 'pool' of available filters that can be used when
-     * {@link #addToChain(String, String, String) creating filter chains}.
-     *
-     * @param name   the name to assign to the filter, used to reference the filter in chain definitions
-     * @param filter the filter to assign to the filter pool
-     * @param init   whether or not the {@code Filter} should be
-     *               {@link Filter#init(javax.servlet.FilterConfig) initialized} first before being added to the pool.
-     */
-    void addFilter(String name, Filter filter, boolean init);
-
-    /**
-     * Creates a filter chain for the given {@code chainName} with the specified {@code chainDefinition}
-     * String.
-     * <h3>Conventional Use</h3>
-     * Because the {@code FilterChainManager} interface does not impose any restrictions on filter chain names,
-     * (it expects only Strings), a convenient convention is to make the chain name an actual URL path expression
-     * (such as an {@link org.apache.shiro.util.AntPathMatcher Ant path expression}).  For example:
-     * <p/>
-     * <code>createChain(<b><em>path_expression</em></b>, <em>path_specific_filter_chain_definition</em>);</code>
-     * This convention can be used by a {@link FilterChainResolver} to inspect request URL paths
-     * against the chain name (path) and, if a match is found, return the corresponding chain for runtime filtering.
-     * <h3>Chain Definition Format</h3>
-     * The {@code chainDefinition} method argument is expected to conform to the following format:
-     * <pre>
-     * filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]</pre>
-     * where
-     * <ol>
-     * <li>{@code filterN} is the name of a filter previously
-     * {@link #addFilter(String, javax.servlet.Filter) registered} with the manager, and</li>
-     * <li>{@code [optional_configN]} is an optional bracketed string that has meaning for that particular filter for
-     * <em>this particular chain</em></li>
-     * </ol>
-     * If the filter does not need specific config for that chain name/URL path,
-     * you may discard the brackets - that is, {@code filterN[]} just becomes {@code filterN}.
-     * <p/>
-     * And because this method does create a chain, remember that order matters!  The comma-delimited filter tokens in
-     * the {@code chainDefinition} specify the chain's execution order.
-     * <h3>Examples</h3>
-     * <pre>/account/** = authcBasic</pre>
-     * This example says &quot;Create a filter named '{@code /account/**}' consisting of only the '{@code authcBasic}'
-     * filter&quot;.  Also because the {@code authcBasic} filter does not need any path-specific
-     * config, it doesn't have any config brackets {@code []}.
-     * <p/>
-     * <pre>/remoting/** = authcBasic, roles[b2bClient], perms[&quot;remote:invoke:wan,lan&quot;]</pre>
-     * This example by contrast uses the 'roles' and 'perms' filters which <em>do</em> use bracket notation.  This
-     * definition says:
-     * <p/>
-     * Construct a filter chain named '{@code /remoting/**}' which
-     * <ol>
-     * <li>ensures the user is first authenticated ({@code authcBasic}) then</li>
-     * <li>ensures that user has the {@code b2bClient} role, and then finally</li>
-     * <li>ensures that they have the {@code remote:invoke:lan,wan} permission.</li>
-     * </ol>
-     * <p/>
-     * <b>Note</b>: because elements within brackets [ ] can be comma-delimited themselves, you must quote the
-     * internal bracket definition if commas are needed (the above example has 'lan,wan').  If we didn't do that, the
-     * parser would interpret the chain definition as four tokens:
-     * <ol>
-     * <li>authcBasic</li>
-     * <li>roles[b2bclient]</li>
-     * <li>perms[remote:invoke:lan</li>
-     * <li>wan]</li>
-     * </ol>
-     * which is obviously incorrect.  So remember to use quotes if your internal bracket definitions need to use commas.
-     *
-     * @param chainName       the name to associate with the chain, conventionally a URL path pattern.
-     * @param chainDefinition the string-formatted chain definition used to construct an actual
-     *                        {@link NamedFilterList} chain instance.
-     * @see FilterChainResolver
-     * @see org.apache.shiro.util.AntPathMatcher AntPathMatcher
-     */
-    void createChain(String chainName, String chainDefinition);
-
-    /**
-     * Adds (appends) a filter to the filter chain identified by the given {@code chainName}.  If there is no chain
-     * with the given name, a new one is created and the filter will be the first in the chain.
-     *
-     * @param chainName  the name of the chain where the filter will be appended.
-     * @param filterName the name of the {@link #addFilter registered} filter to add to the chain.
-     * @throws IllegalArgumentException if there is not a {@link #addFilter(String, javax.servlet.Filter) registered}
-     *                                  filter under the given {@code filterName}
-     */
-    void addToChain(String chainName, String filterName);
-
-    /**
-     * Adds (appends) a filter to the filter chain identified by the given {@code chainName}.  If there is no chain
-     * with the given name, a new one is created and the filter will be the first in the chain.
-     * <p/>
-     * Note that the final argument expects the associated filter to be an instance of
-     * a {@link org.apache.shiro.web.filter.PathConfigProcessor PathConfigProcessor} to accept per-chain configuration.
-     * If it is not, a {@link IllegalArgumentException} will be thrown.
-     *
-     * @param chainName                 the name of the chain where the filter will be appended.
-     * @param filterName                the name of the {@link #addFilter registered} filter to add to the chain.
-     * @param chainSpecificFilterConfig the filter-specific configuration that should be applied for only the specified
-     *                                  filter chain.
-     * @throws IllegalArgumentException if there is not a {@link #addFilter(String, javax.servlet.Filter) registered}
-     *                                  filter under the given {@code filterName}
-     * @throws ConfigurationException   if the filter is not capable of accepting {@code chainSpecificFilterConfig}
-     *                                  (usually such filters implement the
-     *                                  {@link org.apache.shiro.web.filter.PathConfigProcessor PathConfigProcessor}
-     *                                  interface).
-     */
-    void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) throws ConfigurationException;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.config.ConfigurationException;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A {@code FilterChainManager} manages the creation and modification of {@link Filter} chains from an available pool
+ * of {@link Filter} instances.
+ *
+ * @since 1.0
+ */
+public interface FilterChainManager {
+
+    /**
+     * Returns the pool of available {@code Filter}s managed by this manager, keyed by {@code name}.
+     *
+     * @return the pool of available {@code Filter}s managed by this manager, keyed by {@code name}.
+     */
+    Map<String, Filter> getFilters();
+
+    /**
+     * Returns the filter chain identified by the specified {@code chainName} or {@code null} if there is no chain with
+     * that name.
+     *
+     * @param chainName the name identifying the filter chain.
+     * @return the filter chain identified by the specified {@code chainName} or {@code null} if there is no chain with
+     *         that name.
+     */
+    NamedFilterList getChain(String chainName);
+
+    /**
+     * Returns {@code true} if one or more configured chains are available, {@code false} if none are configured.
+     *
+     * @return {@code true} if one or more configured chains are available, {@code false} if none are configured.
+     */
+    boolean hasChains();
+
+    /**
+     * Returns the names of all configured chains or an empty {@code Set} if no chains have been configured.
+     *
+     * @return the names of all configured chains or an empty {@code Set} if no chains have been configured.
+     */
+    Set<String> getChainNames();
+
+    /**
+     * Proxies the specified {@code original} FilterChain with the named chain.  The returned
+     * {@code FilterChain} instance will first execute the configured named chain and then lastly invoke the given
+     * {@code original} chain.
+     *
+     * @param original  the original FilterChain to proxy
+     * @param chainName the name of the internal configured filter chain that should 'sit in front' of the specified
+     *                  original chain.
+     * @return a {@code FilterChain} instance that will execute the named chain and then finally the
+     *         specified {@code original} FilterChain instance.
+     * @throws IllegalArgumentException if there is no configured chain with the given {@code chainName}.
+     */
+    FilterChain proxy(FilterChain original, String chainName);
+
+    /**
+     * Adds a filter to the 'pool' of available filters that can be used when
+     * {@link #addToChain(String, String, String) creating filter chains}.
+     * <p/>
+     * Calling this method is effectively the same as calling
+     * <code>{@link #addFilter(String, javax.servlet.Filter, boolean) addFilter}(name, filter, <b>true</b>);</code>
+     *
+     * @param name   the name to assign to the filter, used to reference the filter in chain definitions
+     * @param filter the filter to initialize and then add to the pool of available filters that can be used
+     */
+    void addFilter(String name, Filter filter);
+
+    /**
+     * Adds a filter to the 'pool' of available filters that can be used when
+     * {@link #addToChain(String, String, String) creating filter chains}.
+     *
+     * @param name   the name to assign to the filter, used to reference the filter in chain definitions
+     * @param filter the filter to assign to the filter pool
+     * @param init   whether or not the {@code Filter} should be
+     *               {@link Filter#init(javax.servlet.FilterConfig) initialized} first before being added to the pool.
+     */
+    void addFilter(String name, Filter filter, boolean init);
+
+    /**
+     * Creates a filter chain for the given {@code chainName} with the specified {@code chainDefinition}
+     * String.
+     * <h3>Conventional Use</h3>
+     * Because the {@code FilterChainManager} interface does not impose any restrictions on filter chain names,
+     * (it expects only Strings), a convenient convention is to make the chain name an actual URL path expression
+     * (such as an {@link org.apache.shiro.util.AntPathMatcher Ant path expression}).  For example:
+     * <p/>
+     * <code>createChain(<b><em>path_expression</em></b>, <em>path_specific_filter_chain_definition</em>);</code>
+     * This convention can be used by a {@link FilterChainResolver} to inspect request URL paths
+     * against the chain name (path) and, if a match is found, return the corresponding chain for runtime filtering.
+     * <h3>Chain Definition Format</h3>
+     * The {@code chainDefinition} method argument is expected to conform to the following format:
+     * <pre>
+     * filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]</pre>
+     * where
+     * <ol>
+     * <li>{@code filterN} is the name of a filter previously
+     * {@link #addFilter(String, javax.servlet.Filter) registered} with the manager, and</li>
+     * <li>{@code [optional_configN]} is an optional bracketed string that has meaning for that particular filter for
+     * <em>this particular chain</em></li>
+     * </ol>
+     * If the filter does not need specific config for that chain name/URL path,
+     * you may discard the brackets - that is, {@code filterN[]} just becomes {@code filterN}.
+     * <p/>
+     * And because this method does create a chain, remember that order matters!  The comma-delimited filter tokens in
+     * the {@code chainDefinition} specify the chain's execution order.
+     * <h3>Examples</h3>
+     * <pre>/account/** = authcBasic</pre>
+     * This example says &quot;Create a filter named '{@code /account/**}' consisting of only the '{@code authcBasic}'
+     * filter&quot;.  Also because the {@code authcBasic} filter does not need any path-specific
+     * config, it doesn't have any config brackets {@code []}.
+     * <p/>
+     * <pre>/remoting/** = authcBasic, roles[b2bClient], perms[&quot;remote:invoke:wan,lan&quot;]</pre>
+     * This example by contrast uses the 'roles' and 'perms' filters which <em>do</em> use bracket notation.  This
+     * definition says:
+     * <p/>
+     * Construct a filter chain named '{@code /remoting/**}' which
+     * <ol>
+     * <li>ensures the user is first authenticated ({@code authcBasic}) then</li>
+     * <li>ensures that user has the {@code b2bClient} role, and then finally</li>
+     * <li>ensures that they have the {@code remote:invoke:lan,wan} permission.</li>
+     * </ol>
+     * <p/>
+     * <b>Note</b>: because elements within brackets [ ] can be comma-delimited themselves, you must quote the
+     * internal bracket definition if commas are needed (the above example has 'lan,wan').  If we didn't do that, the
+     * parser would interpret the chain definition as four tokens:
+     * <ol>
+     * <li>authcBasic</li>
+     * <li>roles[b2bclient]</li>
+     * <li>perms[remote:invoke:lan</li>
+     * <li>wan]</li>
+     * </ol>
+     * which is obviously incorrect.  So remember to use quotes if your internal bracket definitions need to use commas.
+     *
+     * @param chainName       the name to associate with the chain, conventionally a URL path pattern.
+     * @param chainDefinition the string-formatted chain definition used to construct an actual
+     *                        {@link NamedFilterList} chain instance.
+     * @see FilterChainResolver
+     * @see org.apache.shiro.util.AntPathMatcher AntPathMatcher
+     */
+    void createChain(String chainName, String chainDefinition);
+
+    /**
+     * Adds (appends) a filter to the filter chain identified by the given {@code chainName}.  If there is no chain
+     * with the given name, a new one is created and the filter will be the first in the chain.
+     *
+     * @param chainName  the name of the chain where the filter will be appended.
+     * @param filterName the name of the {@link #addFilter registered} filter to add to the chain.
+     * @throws IllegalArgumentException if there is not a {@link #addFilter(String, javax.servlet.Filter) registered}
+     *                                  filter under the given {@code filterName}
+     */
+    void addToChain(String chainName, String filterName);
+
+    /**
+     * Adds (appends) a filter to the filter chain identified by the given {@code chainName}.  If there is no chain
+     * with the given name, a new one is created and the filter will be the first in the chain.
+     * <p/>
+     * Note that the final argument expects the associated filter to be an instance of
+     * a {@link org.apache.shiro.web.filter.PathConfigProcessor PathConfigProcessor} to accept per-chain configuration.
+     * If it is not, a {@link IllegalArgumentException} will be thrown.
+     *
+     * @param chainName                 the name of the chain where the filter will be appended.
+     * @param filterName                the name of the {@link #addFilter registered} filter to add to the chain.
+     * @param chainSpecificFilterConfig the filter-specific configuration that should be applied for only the specified
+     *                                  filter chain.
+     * @throws IllegalArgumentException if there is not a {@link #addFilter(String, javax.servlet.Filter) registered}
+     *                                  filter under the given {@code filterName}
+     * @throws ConfigurationException   if the filter is not capable of accepting {@code chainSpecificFilterConfig}
+     *                                  (usually such filters implement the
+     *                                  {@link org.apache.shiro.web.filter.PathConfigProcessor PathConfigProcessor}
+     *                                  interface).
+     */
+    void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) throws ConfigurationException;
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainResolver.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainResolver.java
index bed3f588a..fc0daabb9 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainResolver.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/FilterChainResolver.java
@@ -1,54 +1,54 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import javax.servlet.FilterChain;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * A {@code FilterChainResolver} can resolve an appropriate {@link FilterChain} to execute during a
- * {@code ServletRequest}.  It allows resolution of arbitrary filter chains which can be executed for any given
- * request or URI/URL.
- * <p/>
- * This mechanism allows for a much more flexible FilterChain resolution than normal {@code web.xml} servlet filter
- * definitions:  it allows arbitrary filter chains to be defined per URL in a much more concise and easy to read manner,
- * and even allows filter chains to be dynamically resolved or constructed at runtime if the underlying implementation
- * supports it.
- *
- * @since 1.0
- */
-public interface FilterChainResolver {
-
-    /**
-     * Returns the filter chain that should be executed for the given request, or {@code null} if the
-     * original chain should be used.
-     * <p/>
-     * This method allows a implementation to define arbitrary security {@link javax.servlet.Filter Filter}
-     * chains for any given request or URL pattern.
-     *
-     * @param request       the incoming ServletRequest
-     * @param response      the outgoing ServletResponse
-     * @param originalChain the original {@code FilterChain} intercepted by the ShiroFilter implementation.
-     * @return the filter chain that should be executed for the given request, or {@code null} if the
-     *         original chain should be used.
-     */
-    FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A {@code FilterChainResolver} can resolve an appropriate {@link FilterChain} to execute during a
+ * {@code ServletRequest}.  It allows resolution of arbitrary filter chains which can be executed for any given
+ * request or URI/URL.
+ * <p/>
+ * This mechanism allows for a much more flexible FilterChain resolution than normal {@code web.xml} servlet filter
+ * definitions:  it allows arbitrary filter chains to be defined per URL in a much more concise and easy to read manner,
+ * and even allows filter chains to be dynamically resolved or constructed at runtime if the underlying implementation
+ * supports it.
+ *
+ * @since 1.0
+ */
+public interface FilterChainResolver {
+
+    /**
+     * Returns the filter chain that should be executed for the given request, or {@code null} if the
+     * original chain should be used.
+     * <p/>
+     * This method allows a implementation to define arbitrary security {@link javax.servlet.Filter Filter}
+     * chains for any given request or URL pattern.
+     *
+     * @param request       the incoming ServletRequest
+     * @param response      the outgoing ServletResponse
+     * @param originalChain the original {@code FilterChain} intercepted by the ShiroFilter implementation.
+     * @return the filter chain that should be executed for the given request, or {@code null} if the
+     *         original chain should be used.
+     */
+    FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);
+
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/NamedFilterList.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/NamedFilterList.java
index 92b05d7fe..fc0b5d6d1 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/NamedFilterList.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/NamedFilterList.java
@@ -1,51 +1,51 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import java.util.List;
-
-/**
- * A {@code NamedFilterList} is a {@code List} of {@code Filter} instances that is uniquely identified by a
- * {@link #getName() name}.  It has the ability to generate new {@link FilterChain} instances reflecting this list's
- * filter order via the {@link #proxy proxy} method.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public interface NamedFilterList extends List<Filter> {
-
-    /**
-     * Returns the configuration-unique name assigned to this {@code Filter} list.
-     *
-     * @return the configuration-unique name assigned to this {@code Filter} list.
-     */
-    String getName();
-
-    /**
-     * Returns a new {@code FilterChain} instance that will first execute this list's {@code Filter}s (in list order)
-     * and end with the execution of the given {@code filterChain} instance.
-     *
-     * @param filterChain the {@code FilterChain} instance to execute after this list's {@code Filter}s have executed.
-     * @return a new {@code FilterChain} instance that will first execute this list's {@code Filter}s (in list order)
-     *         and end with the execution of the given {@code filterChain} instance.
-     */
-    FilterChain proxy(FilterChain filterChain);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import java.util.List;
+
+/**
+ * A {@code NamedFilterList} is a {@code List} of {@code Filter} instances that is uniquely identified by a
+ * {@link #getName() name}.  It has the ability to generate new {@link FilterChain} instances reflecting this list's
+ * filter order via the {@link #proxy proxy} method.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public interface NamedFilterList extends List<Filter> {
+
+    /**
+     * Returns the configuration-unique name assigned to this {@code Filter} list.
+     *
+     * @return the configuration-unique name assigned to this {@code Filter} list.
+     */
+    String getName();
+
+    /**
+     * Returns a new {@code FilterChain} instance that will first execute this list's {@code Filter}s (in list order)
+     * and end with the execution of the given {@code filterChain} instance.
+     *
+     * @param filterChain the {@code FilterChain} instance to execute after this list's {@code Filter}s have executed.
+     * @return a new {@code FilterChain} instance that will first execute this list's {@code Filter}s (in list order)
+     *         and end with the execution of the given {@code filterChain} instance.
+     */
+    FilterChain proxy(FilterChain filterChain);
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
index 9f21dd249..bb70885f5 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolver.java
@@ -1,149 +1,149 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.util.AntPathMatcher;
-import org.apache.shiro.util.PatternMatcher;
-import org.apache.shiro.web.util.WebUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * A {@code FilterChainResolver} that resolves {@link FilterChain}s based on url path
- * matching, as determined by a configurable {@link #setPathMatcher(org.apache.shiro.util.PatternMatcher) PathMatcher}.
- * <p/>
- * This implementation functions by consulting a {@link org.apache.shiro.web.filter.mgt.FilterChainManager} for all configured filter chains (keyed
- * by configured path pattern).  If an incoming Request path matches one of the configured path patterns (via
- * the {@code PathMatcher}, the corresponding configured {@code FilterChain} is returned.
- *
- * @since 1.0
- */
-public class PathMatchingFilterChainResolver implements FilterChainResolver {
-
-    private static transient final Logger log = LoggerFactory.getLogger(PathMatchingFilterChainResolver.class);
-
-    private FilterChainManager filterChainManager;
-
-    private PatternMatcher pathMatcher;
-
-    public PathMatchingFilterChainResolver() {
-        this.pathMatcher = new AntPathMatcher();
-        this.filterChainManager = new DefaultFilterChainManager();
-    }
-
-    public PathMatchingFilterChainResolver(FilterConfig filterConfig) {
-        this.pathMatcher = new AntPathMatcher();
-        this.filterChainManager = new DefaultFilterChainManager(filterConfig);
-    }
-
-    /**
-     * Returns the {@code PatternMatcher} used when determining if an incoming request's path
-     * matches a configured filter chain.  Unless overridden, the
-     * default implementation is an {@link org.apache.shiro.util.AntPathMatcher AntPathMatcher}.
-     *
-     * @return the {@code PatternMatcher} used when determining if an incoming request's path
-     *         matches a configured filter chain.
-     */
-    public PatternMatcher getPathMatcher() {
-        return pathMatcher;
-    }
-
-    /**
-     * Sets the {@code PatternMatcher} used when determining if an incoming request's path
-     * matches a configured filter chain.  Unless overridden, the
-     * default implementation is an {@link org.apache.shiro.util.AntPathMatcher AntPathMatcher}.
-     *
-     * @param pathMatcher the {@code PatternMatcher} used when determining if an incoming request's path
-     *                    matches a configured filter chain.
-     */
-    public void setPathMatcher(PatternMatcher pathMatcher) {
-        this.pathMatcher = pathMatcher;
-    }
-
-    public FilterChainManager getFilterChainManager() {
-        return filterChainManager;
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public void setFilterChainManager(FilterChainManager filterChainManager) {
-        this.filterChainManager = filterChainManager;
-    }
-
-    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
-        FilterChainManager filterChainManager = getFilterChainManager();
-        if (!filterChainManager.hasChains()) {
-            return null;
-        }
-
-        String requestURI = getPathWithinApplication(request);
-
-        //the 'chain names' in this implementation are actually path patterns defined by the user.  We just use them
-        //as the chain name for the FilterChainManager's requirements
-        for (String pathPattern : filterChainManager.getChainNames()) {
-
-            // If the path does match, then pass on to the subclass implementation for specific checks:
-            if (pathMatches(pathPattern, requestURI)) {
-                if (log.isTraceEnabled()) {
-                    log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "].  " +
-                            "Utilizing corresponding filter chain...");
-                }
-                return filterChainManager.proxy(originalChain, pathPattern);
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Returns {@code true} if an incoming request path (the {@code path} argument)
-     * matches a configured filter chain path (the {@code pattern} argument), {@code false} otherwise.
-     * <p/>
-     * Simply delegates to
-     * <b><code>{@link #getPathMatcher() getPathMatcher()}.{@link org.apache.shiro.util.PatternMatcher#matches(String, String) matches(pattern,path)}</code></b>.
-     * Subclass implementors should think carefully before overriding this method, as typically a custom
-     * {@code PathMatcher} should be configured for custom path matching behavior instead.  Favor OO composition
-     * rather than inheritance to limit your exposure to Shiro implementation details which may change over time.
-     *
-     * @param pattern the pattern to match against
-     * @param path    the value to match with the specified {@code pattern}
-     * @return {@code true} if the request {@code path} matches the specified filter chain url {@code pattern},
-     *         {@code false} otherwise.
-     */
-    protected boolean pathMatches(String pattern, String path) {
-        PatternMatcher pathMatcher = getPathMatcher();
-        return pathMatcher.matches(pattern, path);
-    }
-
-    /**
-     * Merely returns
-     * <code>WebUtils.{@link org.apache.shiro.web.util.WebUtils#getPathWithinApplication(javax.servlet.http.HttpServletRequest) getPathWithinApplication(request)}</code>
-     * and can be overridden by subclasses for custom request-to-application-path resolution behavior.
-     *
-     * @param request the incoming {@code ServletRequest}
-     * @return the request's path within the appliation.
-     */
-    protected String getPathWithinApplication(ServletRequest request) {
-        return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.util.AntPathMatcher;
+import org.apache.shiro.util.PatternMatcher;
+import org.apache.shiro.web.util.WebUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A {@code FilterChainResolver} that resolves {@link FilterChain}s based on url path
+ * matching, as determined by a configurable {@link #setPathMatcher(org.apache.shiro.util.PatternMatcher) PathMatcher}.
+ * <p/>
+ * This implementation functions by consulting a {@link org.apache.shiro.web.filter.mgt.FilterChainManager} for all configured filter chains (keyed
+ * by configured path pattern).  If an incoming Request path matches one of the configured path patterns (via
+ * the {@code PathMatcher}, the corresponding configured {@code FilterChain} is returned.
+ *
+ * @since 1.0
+ */
+public class PathMatchingFilterChainResolver implements FilterChainResolver {
+
+    private static transient final Logger log = LoggerFactory.getLogger(PathMatchingFilterChainResolver.class);
+
+    private FilterChainManager filterChainManager;
+
+    private PatternMatcher pathMatcher;
+
+    public PathMatchingFilterChainResolver() {
+        this.pathMatcher = new AntPathMatcher();
+        this.filterChainManager = new DefaultFilterChainManager();
+    }
+
+    public PathMatchingFilterChainResolver(FilterConfig filterConfig) {
+        this.pathMatcher = new AntPathMatcher();
+        this.filterChainManager = new DefaultFilterChainManager(filterConfig);
+    }
+
+    /**
+     * Returns the {@code PatternMatcher} used when determining if an incoming request's path
+     * matches a configured filter chain.  Unless overridden, the
+     * default implementation is an {@link org.apache.shiro.util.AntPathMatcher AntPathMatcher}.
+     *
+     * @return the {@code PatternMatcher} used when determining if an incoming request's path
+     *         matches a configured filter chain.
+     */
+    public PatternMatcher getPathMatcher() {
+        return pathMatcher;
+    }
+
+    /**
+     * Sets the {@code PatternMatcher} used when determining if an incoming request's path
+     * matches a configured filter chain.  Unless overridden, the
+     * default implementation is an {@link org.apache.shiro.util.AntPathMatcher AntPathMatcher}.
+     *
+     * @param pathMatcher the {@code PatternMatcher} used when determining if an incoming request's path
+     *                    matches a configured filter chain.
+     */
+    public void setPathMatcher(PatternMatcher pathMatcher) {
+        this.pathMatcher = pathMatcher;
+    }
+
+    public FilterChainManager getFilterChainManager() {
+        return filterChainManager;
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public void setFilterChainManager(FilterChainManager filterChainManager) {
+        this.filterChainManager = filterChainManager;
+    }
+
+    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
+        FilterChainManager filterChainManager = getFilterChainManager();
+        if (!filterChainManager.hasChains()) {
+            return null;
+        }
+
+        String requestURI = getPathWithinApplication(request);
+
+        //the 'chain names' in this implementation are actually path patterns defined by the user.  We just use them
+        //as the chain name for the FilterChainManager's requirements
+        for (String pathPattern : filterChainManager.getChainNames()) {
+
+            // If the path does match, then pass on to the subclass implementation for specific checks:
+            if (pathMatches(pathPattern, requestURI)) {
+                if (log.isTraceEnabled()) {
+                    log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "].  " +
+                            "Utilizing corresponding filter chain...");
+                }
+                return filterChainManager.proxy(originalChain, pathPattern);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns {@code true} if an incoming request path (the {@code path} argument)
+     * matches a configured filter chain path (the {@code pattern} argument), {@code false} otherwise.
+     * <p/>
+     * Simply delegates to
+     * <b><code>{@link #getPathMatcher() getPathMatcher()}.{@link org.apache.shiro.util.PatternMatcher#matches(String, String) matches(pattern,path)}</code></b>.
+     * Subclass implementors should think carefully before overriding this method, as typically a custom
+     * {@code PathMatcher} should be configured for custom path matching behavior instead.  Favor OO composition
+     * rather than inheritance to limit your exposure to Shiro implementation details which may change over time.
+     *
+     * @param pattern the pattern to match against
+     * @param path    the value to match with the specified {@code pattern}
+     * @return {@code true} if the request {@code path} matches the specified filter chain url {@code pattern},
+     *         {@code false} otherwise.
+     */
+    protected boolean pathMatches(String pattern, String path) {
+        PatternMatcher pathMatcher = getPathMatcher();
+        return pathMatcher.matches(pattern, path);
+    }
+
+    /**
+     * Merely returns
+     * <code>WebUtils.{@link org.apache.shiro.web.util.WebUtils#getPathWithinApplication(javax.servlet.http.HttpServletRequest) getPathWithinApplication(request)}</code>
+     * and can be overridden by subclasses for custom request-to-application-path resolution behavior.
+     *
+     * @param request the incoming {@code ServletRequest}
+     * @return the request's path within the appliation.
+     */
+    protected String getPathWithinApplication(ServletRequest request) {
+        return WebUtils.getPathWithinApplication(WebUtils.toHttp(request));
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java b/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java
index 6ecc4174c..a0bf79d85 100644
--- a/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java
+++ b/web/src/main/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterList.java
@@ -1,174 +1,174 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.util.StringUtils;
-import org.apache.shiro.web.servlet.ProxiedFilterChain;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import java.util.*;
-
-/**
- * Simple {@code NamedFilterList} implementation that is supported by a backing {@link List} instance and a simple
- * {@link #getName() name} property. All {@link List} method implementations are immediately delegated to the
- * wrapped backing list.
- *
- * @since 1.0
- */
-public class SimpleNamedFilterList implements NamedFilterList {
-
-    private String name;
-    private List<Filter> backingList;
-
-    /**
-     * Creates a new {@code SimpleNamedFilterList} instance with the specified {@code name}, defaulting to a new
-     * {@link ArrayList ArrayList} instance as the backing list.
-     *
-     * @param name the name to assign to this instance.
-     * @throws IllegalArgumentException if {@code name} is null or empty.
-     */
-    public SimpleNamedFilterList(String name) {
-        this(name, new ArrayList<Filter>());
-    }
-
-    /**
-     * Creates a new {@code SimpleNamedFilterList} instance with the specified {@code name} and {@code backingList}.
-     *
-     * @param name        the name to assign to this instance.
-     * @param backingList the list instance used to back all of this class's {@link List} method implementations.
-     * @throws IllegalArgumentException if {@code name} is null or empty.
-     * @throws NullPointerException     if the backing list is {@code null}.
-     */
-    public SimpleNamedFilterList(String name, List<Filter> backingList) {
-        if (backingList == null) {
-            throw new NullPointerException("backingList constructor argument cannot be null.");
-        }
-        this.backingList = backingList;
-        setName(name);
-    }
-
-    protected void setName(String name) {
-        if (!StringUtils.hasText(name)) {
-            throw new IllegalArgumentException("Cannot specify a null or empty name.");
-        }
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public FilterChain proxy(FilterChain orig) {
-        return new ProxiedFilterChain(orig, this);
-    }
-
-    public boolean add(Filter filter) {
-        return this.backingList.add(filter);
-    }
-
-    public void add(int index, Filter filter) {
-        this.backingList.add(index, filter);
-    }
-
-    public boolean addAll(Collection<? extends Filter> c) {
-        return this.backingList.addAll(c);
-    }
-
-    public boolean addAll(int index, Collection<? extends Filter> c) {
-        return this.backingList.addAll(index, c);
-    }
-
-    public void clear() {
-        this.backingList.clear();
-    }
-
-    public boolean contains(Object o) {
-        return this.backingList.contains(o);
-    }
-
-    public boolean containsAll(Collection<?> c) {
-        return this.backingList.containsAll(c);
-    }
-
-    public Filter get(int index) {
-        return this.backingList.get(index);
-    }
-
-    public int indexOf(Object o) {
-        return this.backingList.indexOf(o);
-    }
-
-    public boolean isEmpty() {
-        return this.backingList.isEmpty();
-    }
-
-    public Iterator<Filter> iterator() {
-        return this.backingList.iterator();
-    }
-
-    public int lastIndexOf(Object o) {
-        return this.backingList.lastIndexOf(o);
-    }
-
-    public ListIterator<Filter> listIterator() {
-        return this.backingList.listIterator();
-    }
-
-    public ListIterator<Filter> listIterator(int index) {
-        return this.backingList.listIterator(index);
-    }
-
-    public Filter remove(int index) {
-        return this.backingList.remove(index);
-    }
-
-    public boolean remove(Object o) {
-        return this.backingList.remove(o);
-    }
-
-    public boolean removeAll(Collection<?> c) {
-        return this.backingList.removeAll(c);
-    }
-
-    public boolean retainAll(Collection<?> c) {
-        return this.backingList.retainAll(c);
-    }
-
-    public Filter set(int index, Filter filter) {
-        return this.backingList.set(index, filter);
-    }
-
-    public int size() {
-        return this.backingList.size();
-    }
-
-    public List<Filter> subList(int fromIndex, int toIndex) {
-        return this.backingList.subList(fromIndex, toIndex);
-    }
-
-    public Object[] toArray() {
-        return this.backingList.toArray();
-    }
-
-    public <T> T[] toArray(T[] a) {
-        //noinspection SuspiciousToArrayCall
-        return this.backingList.toArray(a);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.util.StringUtils;
+import org.apache.shiro.web.servlet.ProxiedFilterChain;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import java.util.*;
+
+/**
+ * Simple {@code NamedFilterList} implementation that is supported by a backing {@link List} instance and a simple
+ * {@link #getName() name} property. All {@link List} method implementations are immediately delegated to the
+ * wrapped backing list.
+ *
+ * @since 1.0
+ */
+public class SimpleNamedFilterList implements NamedFilterList {
+
+    private String name;
+    private List<Filter> backingList;
+
+    /**
+     * Creates a new {@code SimpleNamedFilterList} instance with the specified {@code name}, defaulting to a new
+     * {@link ArrayList ArrayList} instance as the backing list.
+     *
+     * @param name the name to assign to this instance.
+     * @throws IllegalArgumentException if {@code name} is null or empty.
+     */
+    public SimpleNamedFilterList(String name) {
+        this(name, new ArrayList<Filter>());
+    }
+
+    /**
+     * Creates a new {@code SimpleNamedFilterList} instance with the specified {@code name} and {@code backingList}.
+     *
+     * @param name        the name to assign to this instance.
+     * @param backingList the list instance used to back all of this class's {@link List} method implementations.
+     * @throws IllegalArgumentException if {@code name} is null or empty.
+     * @throws NullPointerException     if the backing list is {@code null}.
+     */
+    public SimpleNamedFilterList(String name, List<Filter> backingList) {
+        if (backingList == null) {
+            throw new NullPointerException("backingList constructor argument cannot be null.");
+        }
+        this.backingList = backingList;
+        setName(name);
+    }
+
+    protected void setName(String name) {
+        if (!StringUtils.hasText(name)) {
+            throw new IllegalArgumentException("Cannot specify a null or empty name.");
+        }
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public FilterChain proxy(FilterChain orig) {
+        return new ProxiedFilterChain(orig, this);
+    }
+
+    public boolean add(Filter filter) {
+        return this.backingList.add(filter);
+    }
+
+    public void add(int index, Filter filter) {
+        this.backingList.add(index, filter);
+    }
+
+    public boolean addAll(Collection<? extends Filter> c) {
+        return this.backingList.addAll(c);
+    }
+
+    public boolean addAll(int index, Collection<? extends Filter> c) {
+        return this.backingList.addAll(index, c);
+    }
+
+    public void clear() {
+        this.backingList.clear();
+    }
+
+    public boolean contains(Object o) {
+        return this.backingList.contains(o);
+    }
+
+    public boolean containsAll(Collection<?> c) {
+        return this.backingList.containsAll(c);
+    }
+
+    public Filter get(int index) {
+        return this.backingList.get(index);
+    }
+
+    public int indexOf(Object o) {
+        return this.backingList.indexOf(o);
+    }
+
+    public boolean isEmpty() {
+        return this.backingList.isEmpty();
+    }
+
+    public Iterator<Filter> iterator() {
+        return this.backingList.iterator();
+    }
+
+    public int lastIndexOf(Object o) {
+        return this.backingList.lastIndexOf(o);
+    }
+
+    public ListIterator<Filter> listIterator() {
+        return this.backingList.listIterator();
+    }
+
+    public ListIterator<Filter> listIterator(int index) {
+        return this.backingList.listIterator(index);
+    }
+
+    public Filter remove(int index) {
+        return this.backingList.remove(index);
+    }
+
+    public boolean remove(Object o) {
+        return this.backingList.remove(o);
+    }
+
+    public boolean removeAll(Collection<?> c) {
+        return this.backingList.removeAll(c);
+    }
+
+    public boolean retainAll(Collection<?> c) {
+        return this.backingList.retainAll(c);
+    }
+
+    public Filter set(int index, Filter filter) {
+        return this.backingList.set(index, filter);
+    }
+
+    public int size() {
+        return this.backingList.size();
+    }
+
+    public List<Filter> subList(int fromIndex, int toIndex) {
+        return this.backingList.subList(fromIndex, toIndex);
+    }
+
+    public Object[] toArray() {
+        return this.backingList.toArray();
+    }
+
+    public <T> T[] toArray(T[] a) {
+        //noinspection SuspiciousToArrayCall
+        return this.backingList.toArray(a);
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSecurityManager.java b/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSecurityManager.java
index 93ef41ed0..87d178517 100644
--- a/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSecurityManager.java
+++ b/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSecurityManager.java
@@ -1,194 +1,194 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.mgt;
-
-import org.apache.shiro.mgt.DefaultSecurityManager;
-import org.apache.shiro.realm.Realm;
-import org.apache.shiro.session.mgt.SessionContext;
-import org.apache.shiro.session.mgt.SessionKey;
-import org.apache.shiro.session.mgt.SessionManager;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.SubjectContext;
-import org.apache.shiro.util.LifecycleUtils;
-import org.apache.shiro.web.servlet.ShiroHttpServletRequest;
-import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;
-import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
-import org.apache.shiro.web.session.mgt.ServletContainerSessionManager;
-import org.apache.shiro.web.session.mgt.WebSessionKey;
-import org.apache.shiro.web.subject.WebSubject;
-import org.apache.shiro.web.subject.WebSubjectContext;
-import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
-import org.apache.shiro.web.util.WebUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import java.io.Serializable;
-import java.util.Collection;
-
-
-/**
- * Default {@link WebSecurityManager WebSecurityManager} implementation used in web-based applications or any
- * application that requires HTTP connectivity (SOAP, http remoting, etc).
- *
- * @author Les Hazlewood
- * @since 0.2
- */
-public class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {
-
-    //TODO - complete JavaDoc
-
-    private static final Logger log = LoggerFactory.getLogger(DefaultWebSecurityManager.class);
-
-    public static final String HTTP_SESSION_MODE = "http";
-    public static final String NATIVE_SESSION_MODE = "native";
-
-    private String sessionMode;
-
-    public DefaultWebSecurityManager() {
-        super();
-        this.sessionMode = HTTP_SESSION_MODE;
-        setSubjectFactory(new DefaultWebSubjectFactory());
-        setRememberMeManager(new CookieRememberMeManager());
-        setSessionManager(new ServletContainerSessionManager());
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public DefaultWebSecurityManager(Realm singleRealm) {
-        this();
-        setRealm(singleRealm);
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public DefaultWebSecurityManager(Collection<Realm> realms) {
-        this();
-        setRealms(realms);
-    }
-
-    @Override
-    protected SubjectContext createSubjectContext() {
-        return new DefaultWebSubjectContext();
-    }
-
-    @Override
-    protected SubjectContext copy(SubjectContext subjectContext) {
-        if (subjectContext instanceof WebSubjectContext) {
-            return new DefaultWebSubjectContext((WebSubjectContext) subjectContext);
-        }
-        return super.copy(subjectContext);
-    }
-
-    @SuppressWarnings({"UnusedDeclaration"})
-    public String getSessionMode() {
-        return sessionMode;
-    }
-
-    public void setSessionMode(String sessionMode) {
-        String mode = sessionMode;
-        if (mode == null) {
-            throw new IllegalArgumentException("sessionMode argument cannot be null.");
-        }
-        mode = sessionMode.toLowerCase();
-        if (!HTTP_SESSION_MODE.equals(mode) && !NATIVE_SESSION_MODE.equals(mode)) {
-            String msg = "Invalid sessionMode [" + sessionMode + "].  Allowed values are " +
-                    "public static final String constants in the " + getClass().getName() + " class: '"
-                    + HTTP_SESSION_MODE + "' or '" + NATIVE_SESSION_MODE + "', with '" +
-                    HTTP_SESSION_MODE + "' being the default.";
-            throw new IllegalArgumentException(msg);
-        }
-        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(mode);
-        this.sessionMode = mode;
-        if (recreate) {
-            LifecycleUtils.destroy(getSessionManager());
-            SessionManager sessionManager = createSessionManager(mode);
-            setSessionManager(sessionManager);
-        }
-    }
-
-    /**
-     * @since 1.0
-     */
-    public boolean isHttpSessionMode() {
-        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);
-    }
-
-    protected SessionManager createSessionManager(String sessionMode) {
-        if (sessionMode == null || sessionMode.equalsIgnoreCase(HTTP_SESSION_MODE)) {
-            if (log.isInfoEnabled()) {
-                log.info(HTTP_SESSION_MODE + " mode - enabling ServletContainerSessionManager (HTTP-only Sessions)");
-            }
-            return new ServletContainerSessionManager();
-        } else {
-            if (log.isInfoEnabled()) {
-                log.info(NATIVE_SESSION_MODE + " mode - enabling DefaultWebSessionManager (HTTP + heterogeneous-client sessions)");
-            }
-            return new DefaultWebSessionManager();
-        }
-    }
-
-    @Override
-    protected SessionContext createSessionContext(SubjectContext subjectContext) {
-        SessionContext sessionContext = super.createSessionContext(subjectContext);
-        if (subjectContext instanceof WebSubjectContext) {
-            WebSubjectContext wsc = (WebSubjectContext) subjectContext;
-            ServletRequest request = wsc.resolveServletRequest();
-            ServletResponse response = wsc.resolveServletResponse();
-            DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);
-            if (request != null) {
-                webSessionContext.setServletRequest(request);
-            }
-            if (response != null) {
-                webSessionContext.setServletResponse(response);
-            }
-
-            sessionContext = webSessionContext;
-        }
-        return sessionContext;
-    }
-
-    @Override
-    protected SessionKey getSessionKey(SubjectContext context) {
-        if (WebUtils.isWeb(context)) {
-            Serializable sessionId = context.getSessionId();
-            ServletRequest request = WebUtils.getRequest(context);
-            ServletResponse response = WebUtils.getResponse(context);
-            return new WebSessionKey(sessionId, request, response);
-        } else {
-            return super.getSessionKey(context);
-
-        }
-    }
-
-    @Override
-    protected void beforeLogout(Subject subject) {
-        super.beforeLogout(subject);
-        removeRequestIdentity(subject);
-    }
-
-    protected void removeRequestIdentity(Subject subject) {
-        if (subject instanceof WebSubject) {
-            WebSubject webSubject = (WebSubject) subject;
-            ServletRequest request = webSubject.getServletRequest();
-            if (request != null) {
-                request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);
-            }
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.mgt;
+
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.realm.Realm;
+import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.session.mgt.SessionKey;
+import org.apache.shiro.session.mgt.SessionManager;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.subject.SubjectContext;
+import org.apache.shiro.util.LifecycleUtils;
+import org.apache.shiro.web.servlet.ShiroHttpServletRequest;
+import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;
+import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
+import org.apache.shiro.web.session.mgt.ServletContainerSessionManager;
+import org.apache.shiro.web.session.mgt.WebSessionKey;
+import org.apache.shiro.web.subject.WebSubject;
+import org.apache.shiro.web.subject.WebSubjectContext;
+import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
+import org.apache.shiro.web.util.WebUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import java.io.Serializable;
+import java.util.Collection;
+
+
+/**
+ * Default {@link WebSecurityManager WebSecurityManager} implementation used in web-based applications or any
+ * application that requires HTTP connectivity (SOAP, http remoting, etc).
+ *
+ * @author Les Hazlewood
+ * @since 0.2
+ */
+public class DefaultWebSecurityManager extends DefaultSecurityManager implements WebSecurityManager {
+
+    //TODO - complete JavaDoc
+
+    private static final Logger log = LoggerFactory.getLogger(DefaultWebSecurityManager.class);
+
+    public static final String HTTP_SESSION_MODE = "http";
+    public static final String NATIVE_SESSION_MODE = "native";
+
+    private String sessionMode;
+
+    public DefaultWebSecurityManager() {
+        super();
+        this.sessionMode = HTTP_SESSION_MODE;
+        setSubjectFactory(new DefaultWebSubjectFactory());
+        setRememberMeManager(new CookieRememberMeManager());
+        setSessionManager(new ServletContainerSessionManager());
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public DefaultWebSecurityManager(Realm singleRealm) {
+        this();
+        setRealm(singleRealm);
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public DefaultWebSecurityManager(Collection<Realm> realms) {
+        this();
+        setRealms(realms);
+    }
+
+    @Override
+    protected SubjectContext createSubjectContext() {
+        return new DefaultWebSubjectContext();
+    }
+
+    @Override
+    protected SubjectContext copy(SubjectContext subjectContext) {
+        if (subjectContext instanceof WebSubjectContext) {
+            return new DefaultWebSubjectContext((WebSubjectContext) subjectContext);
+        }
+        return super.copy(subjectContext);
+    }
+
+    @SuppressWarnings({"UnusedDeclaration"})
+    public String getSessionMode() {
+        return sessionMode;
+    }
+
+    public void setSessionMode(String sessionMode) {
+        String mode = sessionMode;
+        if (mode == null) {
+            throw new IllegalArgumentException("sessionMode argument cannot be null.");
+        }
+        mode = sessionMode.toLowerCase();
+        if (!HTTP_SESSION_MODE.equals(mode) && !NATIVE_SESSION_MODE.equals(mode)) {
+            String msg = "Invalid sessionMode [" + sessionMode + "].  Allowed values are " +
+                    "public static final String constants in the " + getClass().getName() + " class: '"
+                    + HTTP_SESSION_MODE + "' or '" + NATIVE_SESSION_MODE + "', with '" +
+                    HTTP_SESSION_MODE + "' being the default.";
+            throw new IllegalArgumentException(msg);
+        }
+        boolean recreate = this.sessionMode == null || !this.sessionMode.equals(mode);
+        this.sessionMode = mode;
+        if (recreate) {
+            LifecycleUtils.destroy(getSessionManager());
+            SessionManager sessionManager = createSessionManager(mode);
+            setSessionManager(sessionManager);
+        }
+    }
+
+    /**
+     * @since 1.0
+     */
+    public boolean isHttpSessionMode() {
+        return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);
+    }
+
+    protected SessionManager createSessionManager(String sessionMode) {
+        if (sessionMode == null || sessionMode.equalsIgnoreCase(HTTP_SESSION_MODE)) {
+            if (log.isInfoEnabled()) {
+                log.info(HTTP_SESSION_MODE + " mode - enabling ServletContainerSessionManager (HTTP-only Sessions)");
+            }
+            return new ServletContainerSessionManager();
+        } else {
+            if (log.isInfoEnabled()) {
+                log.info(NATIVE_SESSION_MODE + " mode - enabling DefaultWebSessionManager (HTTP + heterogeneous-client sessions)");
+            }
+            return new DefaultWebSessionManager();
+        }
+    }
+
+    @Override
+    protected SessionContext createSessionContext(SubjectContext subjectContext) {
+        SessionContext sessionContext = super.createSessionContext(subjectContext);
+        if (subjectContext instanceof WebSubjectContext) {
+            WebSubjectContext wsc = (WebSubjectContext) subjectContext;
+            ServletRequest request = wsc.resolveServletRequest();
+            ServletResponse response = wsc.resolveServletResponse();
+            DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);
+            if (request != null) {
+                webSessionContext.setServletRequest(request);
+            }
+            if (response != null) {
+                webSessionContext.setServletResponse(response);
+            }
+
+            sessionContext = webSessionContext;
+        }
+        return sessionContext;
+    }
+
+    @Override
+    protected SessionKey getSessionKey(SubjectContext context) {
+        if (WebUtils.isWeb(context)) {
+            Serializable sessionId = context.getSessionId();
+            ServletRequest request = WebUtils.getRequest(context);
+            ServletResponse response = WebUtils.getResponse(context);
+            return new WebSessionKey(sessionId, request, response);
+        } else {
+            return super.getSessionKey(context);
+
+        }
+    }
+
+    @Override
+    protected void beforeLogout(Subject subject) {
+        super.beforeLogout(subject);
+        removeRequestIdentity(subject);
+    }
+
+    protected void removeRequestIdentity(Subject subject) {
+        if (subject instanceof WebSubject) {
+            WebSubject webSubject = (WebSubject) subject;
+            ServletRequest request = webSubject.getServletRequest();
+            if (request != null) {
+                request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);
+            }
+        }
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSubjectFactory.java b/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSubjectFactory.java
index bd4f880be..87cdb4342 100644
--- a/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSubjectFactory.java
+++ b/web/src/main/java/org/apache/shiro/web/mgt/DefaultWebSubjectFactory.java
@@ -1,70 +1,70 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.mgt;
-
-import org.apache.shiro.mgt.DefaultSubjectFactory;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.subject.PrincipalCollection;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.SubjectContext;
-import org.apache.shiro.web.subject.WebSubjectContext;
-import org.apache.shiro.web.subject.support.WebDelegatingSubject;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * A {@code SubjectFactory} implementation that creates {@link WebDelegatingSubject} instances.
- * <p/>
- * {@code WebDelegatingSubject} instances are required if Request/Response objects are to be maintained across
- * threads when using the {@code Subject} {@link Subject#associateWith(java.util.concurrent.Callable) createCallable}
- * and {@link Subject#associateWith(Runnable) createRunnable} methods.
- *
- * @see #newSubjectInstance(org.apache.shiro.subject.PrincipalCollection, boolean, String, org.apache.shiro.session.Session, org.apache.shiro.mgt.SecurityManager)
- * @since 1.0
- */
-public class DefaultWebSubjectFactory extends DefaultSubjectFactory {
-
-    public DefaultWebSubjectFactory() {
-        super();
-    }
-
-    public Subject createSubject(SubjectContext context) {
-        if (!(context instanceof WebSubjectContext)) {
-            return super.createSubject(context);
-        }
-        WebSubjectContext wsc = (WebSubjectContext) context;
-        SecurityManager securityManager = wsc.resolveSecurityManager();
-        Session session = wsc.resolveSession();
-        PrincipalCollection principals = wsc.resolvePrincipals();
-        boolean authenticated = wsc.resolveAuthenticated();
-        String host = wsc.resolveHost();
-        ServletRequest request = wsc.resolveServletRequest();
-        ServletResponse response = wsc.resolveServletResponse();
-        return newSubjectInstance(principals, authenticated, host, session, request, response, securityManager);
-    }
-
-    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated,
-                                         String host, Session session,
-                                         ServletRequest request, ServletResponse response,
-                                         SecurityManager securityManager) {
-        return new WebDelegatingSubject(principals, authenticated, host, session, request, response, securityManager);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.mgt;
+
+import org.apache.shiro.mgt.DefaultSubjectFactory;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.subject.PrincipalCollection;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.subject.SubjectContext;
+import org.apache.shiro.web.subject.WebSubjectContext;
+import org.apache.shiro.web.subject.support.WebDelegatingSubject;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A {@code SubjectFactory} implementation that creates {@link WebDelegatingSubject} instances.
+ * <p/>
+ * {@code WebDelegatingSubject} instances are required if Request/Response objects are to be maintained across
+ * threads when using the {@code Subject} {@link Subject#associateWith(java.util.concurrent.Callable) createCallable}
+ * and {@link Subject#associateWith(Runnable) createRunnable} methods.
+ *
+ * @see #newSubjectInstance(org.apache.shiro.subject.PrincipalCollection, boolean, String, org.apache.shiro.session.Session, org.apache.shiro.mgt.SecurityManager)
+ * @since 1.0
+ */
+public class DefaultWebSubjectFactory extends DefaultSubjectFactory {
+
+    public DefaultWebSubjectFactory() {
+        super();
+    }
+
+    public Subject createSubject(SubjectContext context) {
+        if (!(context instanceof WebSubjectContext)) {
+            return super.createSubject(context);
+        }
+        WebSubjectContext wsc = (WebSubjectContext) context;
+        SecurityManager securityManager = wsc.resolveSecurityManager();
+        Session session = wsc.resolveSession();
+        PrincipalCollection principals = wsc.resolvePrincipals();
+        boolean authenticated = wsc.resolveAuthenticated();
+        String host = wsc.resolveHost();
+        ServletRequest request = wsc.resolveServletRequest();
+        ServletResponse response = wsc.resolveServletResponse();
+        return newSubjectInstance(principals, authenticated, host, session, request, response, securityManager);
+    }
+
+    protected Subject newSubjectInstance(PrincipalCollection principals, boolean authenticated,
+                                         String host, Session session,
+                                         ServletRequest request, ServletResponse response,
+                                         SecurityManager securityManager) {
+        return new WebDelegatingSubject(principals, authenticated, host, session, request, response, securityManager);
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java b/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java
index a6414f3b4..411e89aeb 100644
--- a/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/servlet/AbstractFilter.java
@@ -1,128 +1,128 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.servlet;
-
-import org.apache.shiro.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletException;
-
-/**
- * Base abstract Filter simplifying Filter initialization and {@link #getInitParam(String) access} to init parameters.
- * Subclass initialization logic should be performed by overriding the {@link #onFilterConfigSet()} template method.
- * FilterChain execution logic (the
- * {@link #doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)} method
- * is left to subclasses.
- *
- * @since 1.0
- */
-public abstract class AbstractFilter extends ServletContextSupport implements Filter {
-
-    private static transient final Logger log = LoggerFactory.getLogger(AbstractFilter.class);
-
-    /**
-     * FilterConfig provided by the Servlet container at start-up.
-     */
-    protected FilterConfig filterConfig;
-
-    /**
-     * Returns the servlet container specified {@code FilterConfig} instance provided at
-     * {@link #init(javax.servlet.FilterConfig) startup}.
-     *
-     * @return the servlet container specified {@code FilterConfig} instance provided at start-up.
-     */
-    public FilterConfig getFilterConfig() {
-        return filterConfig;
-    }
-
-    /**
-     * Sets the FilterConfig <em>and</em> the {@code ServletContext} as attributes of this class for use by
-     * subclasses.  That is:
-     * <pre>
-     * this.filterConfig = filterConfig;
-     * setServletContext(filterConfig.getServletContext());</pre>
-     *
-     * @param filterConfig the FilterConfig instance provided by the Servlet container at start-up.
-     */
-    public void setFilterConfig(FilterConfig filterConfig) {
-        this.filterConfig = filterConfig;
-        setServletContext(filterConfig.getServletContext());
-    }
-
-    /**
-     * Returns the value for the named {@code init-param}, or {@code null} if there was no {@code init-param}
-     * specified by that name.
-     *
-     * @param paramName the name of the {@code init-param}
-     * @return the value for the named {@code init-param}, or {@code null} if there was no {@code init-param}
-     *         specified by that name.
-     */
-    protected String getInitParam(String paramName) {
-        FilterConfig config = getFilterConfig();
-        return StringUtils.clean(config.getInitParameter(paramName));
-    }
-
-    /**
-     * Sets the filter's {@link #setFilterConfig filterConfig} and then immediately calls
-     * {@link #onFilterConfigSet() onFilterConfigSet()} to trigger any processing a subclass might wish to perform.
-     *
-     * @param filterConfig the servlet container supplied FilterConfig instance.
-     * @throws javax.servlet.ServletException if {@link #onFilterConfigSet() onFilterConfigSet()} throws an Exception.
-     */
-    public final void init(FilterConfig filterConfig) throws ServletException {
-        setFilterConfig(filterConfig);
-        try {
-            onFilterConfigSet();
-        } catch (Exception e) {
-            if (e instanceof ServletException) {
-                throw (ServletException) e;
-            } else {
-                if (log.isErrorEnabled()) {
-                    log.error("Unable to start Filter: [" + e.getMessage() + "].", e);
-                }
-                throw new ServletException(e);
-            }
-        }
-    }
-
-    /**
-     * Template method to be overridden by subclasses to perform initialization logic at start-up.  The
-     * {@code ServletContext} and {@code FilterConfig} will be accessible
-     * (and non-{@code null}) at the time this method is invoked via the
-     * {@link #getServletContext() getServletContext()} and {@link #getFilterConfig() getFilterConfig()}
-     * methods respectively.
-     * <p/>
-     * {@code init-param} values may be conveniently obtained via the {@link #getInitParam(String)} method.
-     *
-     * @throws Exception if the subclass has an error upon initialization.
-     */
-    protected void onFilterConfigSet() throws Exception {
-    }
-
-    /**
-     * Default no-op implementation that can be overridden by subclasses for custom cleanup behavior.
-     */
-    public void destroy() {
-    }
-
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.servlet;
+
+import org.apache.shiro.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+
+/**
+ * Base abstract Filter simplifying Filter initialization and {@link #getInitParam(String) access} to init parameters.
+ * Subclass initialization logic should be performed by overriding the {@link #onFilterConfigSet()} template method.
+ * FilterChain execution logic (the
+ * {@link #doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)} method
+ * is left to subclasses.
+ *
+ * @since 1.0
+ */
+public abstract class AbstractFilter extends ServletContextSupport implements Filter {
+
+    private static transient final Logger log = LoggerFactory.getLogger(AbstractFilter.class);
+
+    /**
+     * FilterConfig provided by the Servlet container at start-up.
+     */
+    protected FilterConfig filterConfig;
+
+    /**
+     * Returns the servlet container specified {@code FilterConfig} instance provided at
+     * {@link #init(javax.servlet.FilterConfig) startup}.
+     *
+     * @return the servlet container specified {@code FilterConfig} instance provided at start-up.
+     */
+    public FilterConfig getFilterConfig() {
+        return filterConfig;
+    }
+
+    /**
+     * Sets the FilterConfig <em>and</em> the {@code ServletContext} as attributes of this class for use by
+     * subclasses.  That is:
+     * <pre>
+     * this.filterConfig = filterConfig;
+     * setServletContext(filterConfig.getServletContext());</pre>
+     *
+     * @param filterConfig the FilterConfig instance provided by the Servlet container at start-up.
+     */
+    public void setFilterConfig(FilterConfig filterConfig) {
+        this.filterConfig = filterConfig;
+        setServletContext(filterConfig.getServletContext());
+    }
+
+    /**
+     * Returns the value for the named {@code init-param}, or {@code null} if there was no {@code init-param}
+     * specified by that name.
+     *
+     * @param paramName the name of the {@code init-param}
+     * @return the value for the named {@code init-param}, or {@code null} if there was no {@code init-param}
+     *         specified by that name.
+     */
+    protected String getInitParam(String paramName) {
+        FilterConfig config = getFilterConfig();
+        return StringUtils.clean(config.getInitParameter(paramName));
+    }
+
+    /**
+     * Sets the filter's {@link #setFilterConfig filterConfig} and then immediately calls
+     * {@link #onFilterConfigSet() onFilterConfigSet()} to trigger any processing a subclass might wish to perform.
+     *
+     * @param filterConfig the servlet container supplied FilterConfig instance.
+     * @throws javax.servlet.ServletException if {@link #onFilterConfigSet() onFilterConfigSet()} throws an Exception.
+     */
+    public final void init(FilterConfig filterConfig) throws ServletException {
+        setFilterConfig(filterConfig);
+        try {
+            onFilterConfigSet();
+        } catch (Exception e) {
+            if (e instanceof ServletException) {
+                throw (ServletException) e;
+            } else {
+                if (log.isErrorEnabled()) {
+                    log.error("Unable to start Filter: [" + e.getMessage() + "].", e);
+                }
+                throw new ServletException(e);
+            }
+        }
+    }
+
+    /**
+     * Template method to be overridden by subclasses to perform initialization logic at start-up.  The
+     * {@code ServletContext} and {@code FilterConfig} will be accessible
+     * (and non-{@code null}) at the time this method is invoked via the
+     * {@link #getServletContext() getServletContext()} and {@link #getFilterConfig() getFilterConfig()}
+     * methods respectively.
+     * <p/>
+     * {@code init-param} values may be conveniently obtained via the {@link #getInitParam(String)} method.
+     *
+     * @throws Exception if the subclass has an error upon initialization.
+     */
+    protected void onFilterConfigSet() throws Exception {
+    }
+
+    /**
+     * Default no-op implementation that can be overridden by subclasses for custom cleanup behavior.
+     */
+    public void destroy() {
+    }
+
+
 }
\ No newline at end of file
diff --git a/web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java b/web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
index 0e37796c4..4574b357a 100644
--- a/web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/servlet/AbstractShiroFilter.java
@@ -1,361 +1,361 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.servlet;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.subject.ExecutionException;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.web.filter.mgt.FilterChainResolver;
-import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
-import org.apache.shiro.web.mgt.WebSecurityManager;
-import org.apache.shiro.web.subject.WebSubject;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.FilterChain;
-import javax.servlet.ServletException;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-
-/**
- * Abstract base class that provides all standard Shiro request filtering behavior and expects
- * subclasses to implement configuration-specific logic (INI, XML, .properties, etc).
- * <p/>
- * Subclasses should perform configuration and construction logic in an overridden
- * {@link #init()} method implementation.  That implementation should make available any constructed
- * {@code SecurityManager} and {@code FilterChainResolver} by calling
- * {@link #setSecurityManager(org.apache.shiro.web.mgt.WebSecurityManager)} and
- * {@link #setFilterChainResolver(org.apache.shiro.web.filter.mgt.FilterChainResolver)} methods respectively.
- *
- * @since 1.0
- */
-public abstract class AbstractShiroFilter extends OncePerRequestFilter {
-
-    private static final Logger log = LoggerFactory.getLogger(AbstractShiroFilter.class);
-
-    // Reference to the security manager used by this filter
-    private WebSecurityManager securityManager;
-
-    // Used to determine which chain should handle an incoming request/response
-    private FilterChainResolver filterChainResolver;
-
-    protected AbstractShiroFilter() {
-    }
-
-    public WebSecurityManager getSecurityManager() {
-        return securityManager;
-    }
-
-    public void setSecurityManager(WebSecurityManager sm) {
-        this.securityManager = sm;
-    }
-
-    public FilterChainResolver getFilterChainResolver() {
-        return filterChainResolver;
-    }
-
-    public void setFilterChainResolver(FilterChainResolver filterChainResolver) {
-        this.filterChainResolver = filterChainResolver;
-    }
-
-    protected final void onFilterConfigSet() throws Exception {
-        init();
-        ensureSecurityManager();
-    }
-
-    public void init() throws Exception {
-    }
-
-    /**
-     * A fallback mechanism called in {@link #onFilterConfigSet()} to ensure that the
-     * {@link #getSecurityManager() securityManager} property has been set by configuration, and if not,
-     * creates one automatically.
-     */
-    private void ensureSecurityManager() {
-        WebSecurityManager securityManager = getSecurityManager();
-        if (securityManager == null) {
-            log.info("No SecurityManager configured.  Creating default.");
-            securityManager = createDefaultSecurityManager();
-            setSecurityManager(securityManager);
-        }
-    }
-
-    protected WebSecurityManager createDefaultSecurityManager() {
-        return new DefaultWebSecurityManager();
-    }
-
-    protected boolean isHttpSessions() {
-        return getSecurityManager().isHttpSessionMode();
-    }
-
-    /**
-     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting
-     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.
-     *
-     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.
-     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.
-     * @since 1.0
-     */
-    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {
-        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());
-    }
-
-    /**
-     * Prepares the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request
-     * processing.
-     * <p/>
-     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method
-     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific
-     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.
-     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.
-     * @since 1.0
-     */
-    @SuppressWarnings({"UnusedDeclaration"})
-    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {
-        ServletRequest toUse = request;
-        if (request instanceof HttpServletRequest) {
-            HttpServletRequest http = (HttpServletRequest) request;
-            toUse = wrapServletRequest(http);
-        }
-        return toUse;
-    }
-
-    /**
-     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide
-     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not
-     * Servlet Container HTTP-based sessions).
-     *
-     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.
-     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.
-     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.
-     * @since 1.0
-     */
-    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {
-        return new ShiroHttpServletResponse(orig, getServletContext(), request);
-    }
-
-    /**
-     * Prepares the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request
-     * processing.
-     * <p/>
-     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}
-     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a
-     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the
-     * Shiro-managed Session's sessionId and not a servlet container session ID.
-     * <p/>
-     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the
-     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.
-     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.
-     * @since 1.0
-     */
-    @SuppressWarnings({"UnusedDeclaration"})
-    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {
-        ServletResponse toUse = response;
-        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&
-                (response instanceof HttpServletResponse)) {
-            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if
-            //using Shiro sessions (i.e. not simple HttpSession based sessions):
-            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);
-        }
-        return toUse;
-    }
-
-    /**
-     * Creates a {@link WebSubject} instance to associate with the incoming request/response pair which will be used
-     * throughout the request/response execution.
-     *
-     * @param request  the incoming {@code ServletRequest}
-     * @param response the outgoing {@code ServletResponse}
-     * @return the {@code WebSubject} instance to associate with the request/response execution
-     * @since 1.0
-     */
-    protected WebSubject createSubject(ServletRequest request, ServletResponse response) {
-        return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();
-    }
-
-    /**
-     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.
-     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no
-     * session ({@code subject.getSession(false) == null}), this method does nothing.
-     * <p/>This method implementation merely calls
-     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()</code> on the session.
-     *
-     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method
-     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method
-     * @since 1.0
-     */
-    @SuppressWarnings({"UnusedDeclaration"})
-    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {
-        if (!isHttpSessions()) { //'native' sessions
-            Subject subject = SecurityUtils.getSubject();
-            //Subject should never _ever_ be null, but just in case:
-            if (subject != null) {
-                Session session = subject.getSession(false);
-                if (session != null) {
-                    try {
-                        session.touch();
-                    } catch (Throwable t) {
-                        log.error("session.touch() method invocation has failed.  Unable to update" +
-                                "the corresponding session's last access time based on the incoming request.", t);
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It
-     * performs the following ordered operations:
-     * <ol>
-     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}
-     * the incoming {@code ServletRequest} for use during Shiro's processing</li>
-     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}
-     * the outgoing {@code ServletResponse} for use during Shiro's processing</li>
-     * <li> {@link #createSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Creates} a
-     * {@link Subject} instance based on the specified request/response pair.</li>
-     * <li>Finally {@link Subject#execute(Runnable) executes} the
-     * {@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and
-     * {@link #executeChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}
-     * methods</li>
-     * </ol>
-     * <p/>
-     * The {@code Subject.}{@link Subject#execute(Runnable) execute(Runnable)} call in step #4 is used as an
-     * implementation technique to guarantee proper thread binding and restoration is completed successfully.
-     *
-     * @param servletRequest  the incoming {@code ServletRequest}
-     * @param servletResponse the outgoing {@code ServletResponse}
-     * @param chain           the container-provided {@code FilterChain} to execute
-     * @throws IOException                    if an IO error occurs
-     * @throws javax.servlet.ServletException if an Throwable other than an IOException
-     */
-    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)
-            throws ServletException, IOException {
-
-        Throwable t = null;
-
-        try {
-            final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);
-            final ServletResponse response = prepareServletResponse(request, servletResponse, chain);
-
-            final Subject subject = createSubject(request, response);
-
-            //noinspection unchecked
-            subject.execute(new Callable() {
-                public Object call() throws Exception {
-                    updateSessionLastAccessTime(request, response);
-                    executeChain(request, response, chain);
-                    return null;
-                }
-            });
-        } catch (ExecutionException ex) {
-            t = ex.getCause();
-        } catch (Throwable throwable) {
-            t = throwable;
-        }
-
-        if (t != null) {
-            if (t instanceof ServletException) {
-                throw (ServletException) t;
-            }
-            if (t instanceof IOException) {
-                throw (IOException) t;
-            }
-            //otherwise it's not one of the two exceptions expected by the filter method signature - wrap it in one:
-            String msg = "Filtered request failed.";
-            throw new ServletException(msg, t);
-        }
-    }
-
-    /**
-     * Returns the {@code FilterChain} to execute for the given request.
-     * <p/>
-     * The {@code origChain} argument is the
-     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide
-     * more behavior by pre-pending further chains according to the Shiro configuration.
-     * <p/>
-     * This implementation returns the chain that will actually be executed by acquiring the chain from a
-     * {@link #getFilterChainResolver() filterChainResolver}.  The resolver determines exactly which chain to
-     * execute, typically based on URL configuration.  If no chain is returned from the resolver call
-     * (returns {@code null}), then the {@code origChain} will be returned by default.
-     *
-     * @param request   the incoming ServletRequest
-     * @param response  the outgoing ServletResponse
-     * @param origChain the original {@code FilterChain} provided by the Servlet Container
-     * @return the {@link FilterChain} to execute for the given request
-     * @since 1.0
-     */
-    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {
-        FilterChain chain = origChain;
-
-        FilterChainResolver resolver = getFilterChainResolver();
-        if (resolver == null) {
-            log.debug("No FilterChainResolver configured.  Returning original FilterChain.");
-            return origChain;
-        }
-
-        FilterChain resolved = resolver.getChain(request, response, origChain);
-        if (resolved != null) {
-            log.trace("Resolved a configured FilterChain for the current request.");
-            chain = resolved;
-        } else {
-            log.trace("No FilterChain configured for the current request.  Using the default.");
-        }
-
-        return chain;
-    }
-
-    /**
-     * Executes a {@link FilterChain} for the given request.
-     * <p/>
-     * This implementation first delegates to
-     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}</code>
-     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting
-     * value from that call is then executed directly by calling the returned {@code FilterChain}'s
-     * {@link FilterChain#doFilter doFilter} method.  That is:
-     * <pre>
-     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);
-     * chain.{@link FilterChain#doFilter doFilter}(request,response);</pre>
-     *
-     * @param request   the incoming ServletRequest
-     * @param response  the outgoing ServletResponse
-     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured
-     *                  chain of Filters.
-     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException
-     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException
-     * @since 1.0
-     */
-    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)
-            throws IOException, ServletException {
-        FilterChain chain = getExecutionChain(request, response, origChain);
-        chain.doFilter(request, response);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.servlet;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.subject.ExecutionException;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.web.filter.mgt.FilterChainResolver;
+import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
+import org.apache.shiro.web.mgt.WebSecurityManager;
+import org.apache.shiro.web.subject.WebSubject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.Callable;
+
+/**
+ * Abstract base class that provides all standard Shiro request filtering behavior and expects
+ * subclasses to implement configuration-specific logic (INI, XML, .properties, etc).
+ * <p/>
+ * Subclasses should perform configuration and construction logic in an overridden
+ * {@link #init()} method implementation.  That implementation should make available any constructed
+ * {@code SecurityManager} and {@code FilterChainResolver} by calling
+ * {@link #setSecurityManager(org.apache.shiro.web.mgt.WebSecurityManager)} and
+ * {@link #setFilterChainResolver(org.apache.shiro.web.filter.mgt.FilterChainResolver)} methods respectively.
+ *
+ * @since 1.0
+ */
+public abstract class AbstractShiroFilter extends OncePerRequestFilter {
+
+    private static final Logger log = LoggerFactory.getLogger(AbstractShiroFilter.class);
+
+    // Reference to the security manager used by this filter
+    private WebSecurityManager securityManager;
+
+    // Used to determine which chain should handle an incoming request/response
+    private FilterChainResolver filterChainResolver;
+
+    protected AbstractShiroFilter() {
+    }
+
+    public WebSecurityManager getSecurityManager() {
+        return securityManager;
+    }
+
+    public void setSecurityManager(WebSecurityManager sm) {
+        this.securityManager = sm;
+    }
+
+    public FilterChainResolver getFilterChainResolver() {
+        return filterChainResolver;
+    }
+
+    public void setFilterChainResolver(FilterChainResolver filterChainResolver) {
+        this.filterChainResolver = filterChainResolver;
+    }
+
+    protected final void onFilterConfigSet() throws Exception {
+        init();
+        ensureSecurityManager();
+    }
+
+    public void init() throws Exception {
+    }
+
+    /**
+     * A fallback mechanism called in {@link #onFilterConfigSet()} to ensure that the
+     * {@link #getSecurityManager() securityManager} property has been set by configuration, and if not,
+     * creates one automatically.
+     */
+    private void ensureSecurityManager() {
+        WebSecurityManager securityManager = getSecurityManager();
+        if (securityManager == null) {
+            log.info("No SecurityManager configured.  Creating default.");
+            securityManager = createDefaultSecurityManager();
+            setSecurityManager(securityManager);
+        }
+    }
+
+    protected WebSecurityManager createDefaultSecurityManager() {
+        return new DefaultWebSecurityManager();
+    }
+
+    protected boolean isHttpSessions() {
+        return getSecurityManager().isHttpSessionMode();
+    }
+
+    /**
+     * Wraps the original HttpServletRequest in a {@link ShiroHttpServletRequest}, which is required for supporting
+     * Servlet Specification behavior backed by a {@link org.apache.shiro.subject.Subject Subject} instance.
+     *
+     * @param orig the original Servlet Container-provided incoming {@code HttpServletRequest} instance.
+     * @return {@link ShiroHttpServletRequest ShiroHttpServletRequest} instance wrapping the original.
+     * @since 1.0
+     */
+    protected ServletRequest wrapServletRequest(HttpServletRequest orig) {
+        return new ShiroHttpServletRequest(orig, getServletContext(), isHttpSessions());
+    }
+
+    /**
+     * Prepares the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request
+     * processing.
+     * <p/>
+     * If the {@code ServletRequest} is an instance of {@link HttpServletRequest}, the value returned from this method
+     * is obtained by calling {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)} to allow Shiro-specific
+     * HTTP behavior, otherwise the original {@code ServletRequest} argument is returned.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.
+     * @return the {@code ServletRequest} instance that will be passed to the {@code FilterChain} for request processing.
+     * @since 1.0
+     */
+    @SuppressWarnings({"UnusedDeclaration"})
+    protected ServletRequest prepareServletRequest(ServletRequest request, ServletResponse response, FilterChain chain) {
+        ServletRequest toUse = request;
+        if (request instanceof HttpServletRequest) {
+            HttpServletRequest http = (HttpServletRequest) request;
+            toUse = wrapServletRequest(http);
+        }
+        return toUse;
+    }
+
+    /**
+     * Returns a new {@link ShiroHttpServletResponse} instance, wrapping the {@code orig} argument, in order to provide
+     * correct URL rewriting behavior required by the Servlet Specification when using Shiro-based sessions (and not
+     * Servlet Container HTTP-based sessions).
+     *
+     * @param orig    the original {@code HttpServletResponse} instance provided by the Servlet Container.
+     * @param request the {@code ShiroHttpServletRequest} instance wrapping the original request.
+     * @return the wrapped ServletResponse instance to use during {@link FilterChain} execution.
+     * @since 1.0
+     */
+    protected ServletResponse wrapServletResponse(HttpServletResponse orig, ShiroHttpServletRequest request) {
+        return new ShiroHttpServletResponse(orig, getServletContext(), request);
+    }
+
+    /**
+     * Prepares the {@code ServletResponse} instance that will be passed to the {@code FilterChain} for request
+     * processing.
+     * <p/>
+     * This implementation delegates to {@link #wrapServletRequest(javax.servlet.http.HttpServletRequest)}
+     * only if Shiro-based sessions are enabled (that is, !{@link #isHttpSessions()}) and the request instance is a
+     * {@link ShiroHttpServletRequest}.  This ensures that any URL rewriting that occurs is handled correctly using the
+     * Shiro-managed Session's sessionId and not a servlet container session ID.
+     * <p/>
+     * If HTTP-based sessions are enabled (the default), then this method does nothing and just returns the
+     * {@code ServletResponse} argument as-is, relying on the default Servlet Container URL rewriting logic.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @param chain    the Servlet Container provided {@code FilterChain} that will receive the returned request.
+     * @return the {@code ServletResponse} instance that will be passed to the {@code FilterChain} during request processing.
+     * @since 1.0
+     */
+    @SuppressWarnings({"UnusedDeclaration"})
+    protected ServletResponse prepareServletResponse(ServletRequest request, ServletResponse response, FilterChain chain) {
+        ServletResponse toUse = response;
+        if (!isHttpSessions() && (request instanceof ShiroHttpServletRequest) &&
+                (response instanceof HttpServletResponse)) {
+            //the ShiroHttpServletResponse exists to support URL rewriting for session ids.  This is only needed if
+            //using Shiro sessions (i.e. not simple HttpSession based sessions):
+            toUse = wrapServletResponse((HttpServletResponse) response, (ShiroHttpServletRequest) request);
+        }
+        return toUse;
+    }
+
+    /**
+     * Creates a {@link WebSubject} instance to associate with the incoming request/response pair which will be used
+     * throughout the request/response execution.
+     *
+     * @param request  the incoming {@code ServletRequest}
+     * @param response the outgoing {@code ServletResponse}
+     * @return the {@code WebSubject} instance to associate with the request/response execution
+     * @since 1.0
+     */
+    protected WebSubject createSubject(ServletRequest request, ServletResponse response) {
+        return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();
+    }
+
+    /**
+     * Updates any 'native'  Session's last access time that might exist to the timestamp when this method is called.
+     * If native sessions are not enabled (that is, standard Servlet container sessions are being used) or there is no
+     * session ({@code subject.getSession(false) == null}), this method does nothing.
+     * <p/>This method implementation merely calls
+     * <code>Session.{@link org.apache.shiro.session.Session#touch() touch}()</code> on the session.
+     *
+     * @param request  incoming request - ignored, but available to subclasses that might wish to override this method
+     * @param response outgoing response - ignored, but available to subclasses that might wish to override this method
+     * @since 1.0
+     */
+    @SuppressWarnings({"UnusedDeclaration"})
+    protected void updateSessionLastAccessTime(ServletRequest request, ServletResponse response) {
+        if (!isHttpSessions()) { //'native' sessions
+            Subject subject = SecurityUtils.getSubject();
+            //Subject should never _ever_ be null, but just in case:
+            if (subject != null) {
+                Session session = subject.getSession(false);
+                if (session != null) {
+                    try {
+                        session.touch();
+                    } catch (Throwable t) {
+                        log.error("session.touch() method invocation has failed.  Unable to update" +
+                                "the corresponding session's last access time based on the incoming request.", t);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * {@code doFilterInternal} implementation that sets-up, executes, and cleans-up a Shiro-filtered request.  It
+     * performs the following ordered operations:
+     * <ol>
+     * <li>{@link #prepareServletRequest(ServletRequest, ServletResponse, FilterChain) Prepares}
+     * the incoming {@code ServletRequest} for use during Shiro's processing</li>
+     * <li>{@link #prepareServletResponse(ServletRequest, ServletResponse, FilterChain) Prepares}
+     * the outgoing {@code ServletResponse} for use during Shiro's processing</li>
+     * <li> {@link #createSubject(javax.servlet.ServletRequest, javax.servlet.ServletResponse) Creates} a
+     * {@link Subject} instance based on the specified request/response pair.</li>
+     * <li>Finally {@link Subject#execute(Runnable) executes} the
+     * {@link #updateSessionLastAccessTime(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} and
+     * {@link #executeChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)}
+     * methods</li>
+     * </ol>
+     * <p/>
+     * The {@code Subject.}{@link Subject#execute(Runnable) execute(Runnable)} call in step #4 is used as an
+     * implementation technique to guarantee proper thread binding and restoration is completed successfully.
+     *
+     * @param servletRequest  the incoming {@code ServletRequest}
+     * @param servletResponse the outgoing {@code ServletResponse}
+     * @param chain           the container-provided {@code FilterChain} to execute
+     * @throws IOException                    if an IO error occurs
+     * @throws javax.servlet.ServletException if an Throwable other than an IOException
+     */
+    protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)
+            throws ServletException, IOException {
+
+        Throwable t = null;
+
+        try {
+            final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);
+            final ServletResponse response = prepareServletResponse(request, servletResponse, chain);
+
+            final Subject subject = createSubject(request, response);
+
+            //noinspection unchecked
+            subject.execute(new Callable() {
+                public Object call() throws Exception {
+                    updateSessionLastAccessTime(request, response);
+                    executeChain(request, response, chain);
+                    return null;
+                }
+            });
+        } catch (ExecutionException ex) {
+            t = ex.getCause();
+        } catch (Throwable throwable) {
+            t = throwable;
+        }
+
+        if (t != null) {
+            if (t instanceof ServletException) {
+                throw (ServletException) t;
+            }
+            if (t instanceof IOException) {
+                throw (IOException) t;
+            }
+            //otherwise it's not one of the two exceptions expected by the filter method signature - wrap it in one:
+            String msg = "Filtered request failed.";
+            throw new ServletException(msg, t);
+        }
+    }
+
+    /**
+     * Returns the {@code FilterChain} to execute for the given request.
+     * <p/>
+     * The {@code origChain} argument is the
+     * original {@code FilterChain} supplied by the Servlet Container, but it may be modified to provide
+     * more behavior by pre-pending further chains according to the Shiro configuration.
+     * <p/>
+     * This implementation returns the chain that will actually be executed by acquiring the chain from a
+     * {@link #getFilterChainResolver() filterChainResolver}.  The resolver determines exactly which chain to
+     * execute, typically based on URL configuration.  If no chain is returned from the resolver call
+     * (returns {@code null}), then the {@code origChain} will be returned by default.
+     *
+     * @param request   the incoming ServletRequest
+     * @param response  the outgoing ServletResponse
+     * @param origChain the original {@code FilterChain} provided by the Servlet Container
+     * @return the {@link FilterChain} to execute for the given request
+     * @since 1.0
+     */
+    protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {
+        FilterChain chain = origChain;
+
+        FilterChainResolver resolver = getFilterChainResolver();
+        if (resolver == null) {
+            log.debug("No FilterChainResolver configured.  Returning original FilterChain.");
+            return origChain;
+        }
+
+        FilterChain resolved = resolver.getChain(request, response, origChain);
+        if (resolved != null) {
+            log.trace("Resolved a configured FilterChain for the current request.");
+            chain = resolved;
+        } else {
+            log.trace("No FilterChain configured for the current request.  Using the default.");
+        }
+
+        return chain;
+    }
+
+    /**
+     * Executes a {@link FilterChain} for the given request.
+     * <p/>
+     * This implementation first delegates to
+     * <code>{@link #getExecutionChain(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) getExecutionChain}</code>
+     * to allow the application's Shiro configuration to determine exactly how the chain should execute.  The resulting
+     * value from that call is then executed directly by calling the returned {@code FilterChain}'s
+     * {@link FilterChain#doFilter doFilter} method.  That is:
+     * <pre>
+     * FilterChain chain = {@link #getExecutionChain}(request, response, origChain);
+     * chain.{@link FilterChain#doFilter doFilter}(request,response);</pre>
+     *
+     * @param request   the incoming ServletRequest
+     * @param response  the outgoing ServletResponse
+     * @param origChain the Servlet Container-provided chain that may be wrapped further by an application-configured
+     *                  chain of Filters.
+     * @throws IOException      if the underlying {@code chain.doFilter} call results in an IOException
+     * @throws ServletException if the underlying {@code chain.doFilter} call results in a ServletException
+     * @since 1.0
+     */
+    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)
+            throws IOException, ServletException {
+        FilterChain chain = getExecutionChain(request, response, origChain);
+        chain.doFilter(request, response);
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/servlet/AdviceFilter.java b/web/src/main/java/org/apache/shiro/web/servlet/AdviceFilter.java
index b57d5797e..d8d624acb 100644
--- a/web/src/main/java/org/apache/shiro/web/servlet/AdviceFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/servlet/AdviceFilter.java
@@ -1,201 +1,201 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.servlet;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.servlet.FilterChain;
-import javax.servlet.ServletException;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import java.io.IOException;
-
-/**
- * A Servlet Filter that enables AOP-style &quot;around&quot; advice for a ServletRequest via
- * {@link #preHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) preHandle},
- * {@link #postHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) postHandle},
- * and {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion}
- * hooks.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public abstract class AdviceFilter extends OncePerRequestFilter {
-
-    /**
-     * The static logger available to this class only
-     */
-    private static final Logger log = LoggerFactory.getLogger(AdviceFilter.class);
-
-    /**
-     * Returns {@code true} if the filter chain should be allowed to continue, {@code false} otherwise.
-     * It is called before the chain is actually consulted/executed.
-     * <p/>
-     * The default implementation returns {@code true} always and exists as a template method for subclasses.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @return {@code true} if the filter chain should be allowed to continue, {@code false} otherwise.
-     * @throws Exception if there is any error.
-     */
-    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
-        return true;
-    }
-
-    /**
-     * Allows 'post' advice logic to be called, but only if no exception occurs during filter chain execution.  That
-     * is, if {@link #executeChain executeChain} throws an exception, this method will never be called.  Be aware of
-     * this when implementing logic.  Most resource 'cleanup' behavior is often done in the
-     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion(request,response,exception)}
-     * implementation, which is guaranteed to be called for every request, even when the chain processing throws
-     * an Exception.
-     * <p/>
-     * The default implementation does nothing (no-op) and exists as a template method for subclasses.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @throws Exception if an error occurs.
-     */
-    @SuppressWarnings({"UnusedDeclaration"})
-    protected void postHandle(ServletRequest request, ServletResponse response) throws Exception {
-    }
-
-    /**
-     * Called in all cases in a {@code finally} block even if {@link #preHandle preHandle} returns
-     * {@code false} or if an exception is thrown during filter chain processing.  Can be used for resource
-     * cleanup if so desired.
-     * <p/>
-     * The default implementation does nothing (no-op) and exists as a template method for subclasses.
-     *
-     * @param request   the incoming ServletRequest
-     * @param response  the outgoing ServletResponse
-     * @param exception any exception thrown during {@link #preHandle preHandle}, {@link #executeChain executeChain},
-     *                  or {@link #postHandle postHandle} execution, or {@code null} if no exception was thrown
-     *                  (i.e. the chain processed successfully).
-     * @throws Exception if an error occurs.
-     */
-    @SuppressWarnings({"UnusedDeclaration"})
-    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception {
-    }
-
-    /**
-     * Actually executes the specified filter chain by calling <code>chain.doFilter(request,response);</code>.
-     * <p/>
-     * Can be overridden by subclasses for custom logic.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @param chain    the filter chain to execute
-     * @throws Exception if there is any error executing the chain.
-     */
-    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception {
-        chain.doFilter(request, response);
-    }
-
-    /**
-     * Actually implements the chain execution logic, utilizing
-     * {@link #preHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) pre},
-     * {@link #postHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) post}, and
-     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) after}
-     * advice hooks.
-     *
-     * @param request  the incoming ServletRequest
-     * @param response the outgoing ServletResponse
-     * @param chain    the filter chain to execute
-     * @throws ServletException if a servlet-related error occurs
-     * @throws IOException      if an IO error occurs
-     */
-    public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)
-            throws ServletException, IOException {
-
-        Exception exception = null;
-
-        try {
-
-            boolean continueChain = preHandle(request, response);
-            if (log.isTraceEnabled()) {
-                log.trace("Invoked preHandle method.  Continuing chain?: [" + continueChain + "]");
-            }
-
-            if (continueChain) {
-                executeChain(request, response, chain);
-            }
-
-            postHandle(request, response);
-            if (log.isTraceEnabled()) {
-                log.trace("Successfully invoked postHandle method");
-            }
-
-        } catch (Exception e) {
-            exception = e;
-        } finally {
-            cleanup(request, response, exception);
-        }
-    }
-
-    /**
-     * Executes cleanup logic in the {@code finally} code block in the
-     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) doFilterInternal}
-     * implementation.
-     * <p/>
-     * This implementation specifically calls
-     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion}
-     * as well as handles any exceptions properly.
-     *
-     * @param request  the incoming {@code ServletRequest}
-     * @param response the outgoing {@code ServletResponse}
-     * @param existing any exception that might have occurred while executing the {@code FilterChain} or
-     *                 pre or post advice, or {@code null} if the pre/chain/post execution did not throw an {@code Exception}.
-     * @throws ServletException if any exception other than an {@code IOException} is thrown.
-     * @throws IOException      if the pre/chain/post execution throw an {@code IOException}
-     */
-    protected void cleanup(ServletRequest request, ServletResponse response, Exception existing)
-            throws ServletException, IOException {
-        Exception exception = existing;
-        try {
-            afterCompletion(request, response, exception);
-            if (log.isTraceEnabled()) {
-                log.trace("Successfully invoked afterCompletion method.");
-            }
-        } catch (Exception e) {
-            if (exception == null) {
-                exception = e;
-            } else {
-                log.debug("afterCompletion implementation threw an exception.  This will be ignored to " +
-                        "allow the original source exception to be propagated.", e);
-            }
-        }
-        if (exception != null) {
-            if (exception instanceof ServletException) {
-                throw (ServletException) exception;
-            } else if (exception instanceof IOException) {
-                throw (IOException) exception;
-            } else {
-                if (log.isDebugEnabled()) {
-                    String msg = "Filter execution resulted in an unexpected Exception " +
-                            "(not IOException or ServletException as the Filter API recommends).  " +
-                            "Wrapping in ServletException and propagating.";
-                    log.debug(msg);
-                }
-                throw new ServletException(exception);
-            }
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.servlet;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import java.io.IOException;
+
+/**
+ * A Servlet Filter that enables AOP-style &quot;around&quot; advice for a ServletRequest via
+ * {@link #preHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) preHandle},
+ * {@link #postHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) postHandle},
+ * and {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion}
+ * hooks.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public abstract class AdviceFilter extends OncePerRequestFilter {
+
+    /**
+     * The static logger available to this class only
+     */
+    private static final Logger log = LoggerFactory.getLogger(AdviceFilter.class);
+
+    /**
+     * Returns {@code true} if the filter chain should be allowed to continue, {@code false} otherwise.
+     * It is called before the chain is actually consulted/executed.
+     * <p/>
+     * The default implementation returns {@code true} always and exists as a template method for subclasses.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @return {@code true} if the filter chain should be allowed to continue, {@code false} otherwise.
+     * @throws Exception if there is any error.
+     */
+    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
+        return true;
+    }
+
+    /**
+     * Allows 'post' advice logic to be called, but only if no exception occurs during filter chain execution.  That
+     * is, if {@link #executeChain executeChain} throws an exception, this method will never be called.  Be aware of
+     * this when implementing logic.  Most resource 'cleanup' behavior is often done in the
+     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion(request,response,exception)}
+     * implementation, which is guaranteed to be called for every request, even when the chain processing throws
+     * an Exception.
+     * <p/>
+     * The default implementation does nothing (no-op) and exists as a template method for subclasses.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @throws Exception if an error occurs.
+     */
+    @SuppressWarnings({"UnusedDeclaration"})
+    protected void postHandle(ServletRequest request, ServletResponse response) throws Exception {
+    }
+
+    /**
+     * Called in all cases in a {@code finally} block even if {@link #preHandle preHandle} returns
+     * {@code false} or if an exception is thrown during filter chain processing.  Can be used for resource
+     * cleanup if so desired.
+     * <p/>
+     * The default implementation does nothing (no-op) and exists as a template method for subclasses.
+     *
+     * @param request   the incoming ServletRequest
+     * @param response  the outgoing ServletResponse
+     * @param exception any exception thrown during {@link #preHandle preHandle}, {@link #executeChain executeChain},
+     *                  or {@link #postHandle postHandle} execution, or {@code null} if no exception was thrown
+     *                  (i.e. the chain processed successfully).
+     * @throws Exception if an error occurs.
+     */
+    @SuppressWarnings({"UnusedDeclaration"})
+    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception {
+    }
+
+    /**
+     * Actually executes the specified filter chain by calling <code>chain.doFilter(request,response);</code>.
+     * <p/>
+     * Can be overridden by subclasses for custom logic.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @param chain    the filter chain to execute
+     * @throws Exception if there is any error executing the chain.
+     */
+    protected void executeChain(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception {
+        chain.doFilter(request, response);
+    }
+
+    /**
+     * Actually implements the chain execution logic, utilizing
+     * {@link #preHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) pre},
+     * {@link #postHandle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) post}, and
+     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) after}
+     * advice hooks.
+     *
+     * @param request  the incoming ServletRequest
+     * @param response the outgoing ServletResponse
+     * @param chain    the filter chain to execute
+     * @throws ServletException if a servlet-related error occurs
+     * @throws IOException      if an IO error occurs
+     */
+    public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)
+            throws ServletException, IOException {
+
+        Exception exception = null;
+
+        try {
+
+            boolean continueChain = preHandle(request, response);
+            if (log.isTraceEnabled()) {
+                log.trace("Invoked preHandle method.  Continuing chain?: [" + continueChain + "]");
+            }
+
+            if (continueChain) {
+                executeChain(request, response, chain);
+            }
+
+            postHandle(request, response);
+            if (log.isTraceEnabled()) {
+                log.trace("Successfully invoked postHandle method");
+            }
+
+        } catch (Exception e) {
+            exception = e;
+        } finally {
+            cleanup(request, response, exception);
+        }
+    }
+
+    /**
+     * Executes cleanup logic in the {@code finally} code block in the
+     * {@link #doFilterInternal(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) doFilterInternal}
+     * implementation.
+     * <p/>
+     * This implementation specifically calls
+     * {@link #afterCompletion(javax.servlet.ServletRequest, javax.servlet.ServletResponse, Exception) afterCompletion}
+     * as well as handles any exceptions properly.
+     *
+     * @param request  the incoming {@code ServletRequest}
+     * @param response the outgoing {@code ServletResponse}
+     * @param existing any exception that might have occurred while executing the {@code FilterChain} or
+     *                 pre or post advice, or {@code null} if the pre/chain/post execution did not throw an {@code Exception}.
+     * @throws ServletException if any exception other than an {@code IOException} is thrown.
+     * @throws IOException      if the pre/chain/post execution throw an {@code IOException}
+     */
+    protected void cleanup(ServletRequest request, ServletResponse response, Exception existing)
+            throws ServletException, IOException {
+        Exception exception = existing;
+        try {
+            afterCompletion(request, response, exception);
+            if (log.isTraceEnabled()) {
+                log.trace("Successfully invoked afterCompletion method.");
+            }
+        } catch (Exception e) {
+            if (exception == null) {
+                exception = e;
+            } else {
+                log.debug("afterCompletion implementation threw an exception.  This will be ignored to " +
+                        "allow the original source exception to be propagated.", e);
+            }
+        }
+        if (exception != null) {
+            if (exception instanceof ServletException) {
+                throw (ServletException) exception;
+            } else if (exception instanceof IOException) {
+                throw (IOException) exception;
+            } else {
+                if (log.isDebugEnabled()) {
+                    String msg = "Filter execution resulted in an unexpected Exception " +
+                            "(not IOException or ServletException as the Filter API recommends).  " +
+                            "Wrapping in ServletException and propagating.";
+                    log.debug(msg);
+                }
+                throw new ServletException(exception);
+            }
+        }
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java b/web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java
index 17bac1c77..f90656481 100644
--- a/web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/servlet/IniShiroFilter.java
@@ -1,397 +1,397 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.servlet;
-
-import org.apache.shiro.config.ConfigurationException;
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.config.IniFactorySupport;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.web.config.IniFilterChainResolverFactory;
-import org.apache.shiro.web.config.WebIniSecurityManagerFactory;
-import org.apache.shiro.web.filter.mgt.FilterChainResolver;
-import org.apache.shiro.web.mgt.WebSecurityManager;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Map;
-
-/**
- * Main Servlet Filter that configures and enables all Shiro functions within a web application by using the
- * <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> configuration format.
- * <p/>
- * The following is a fully commented example that documents how to configure it:
- * <pre>&lt;filter&gt;
- * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
- * &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;
- * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;
- * #
- * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.
- * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any
- * #       comments that you don't want to read from your own configuration ;)
- * #
- * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any
- * # values on those lines, you only need to uncomment the lines you want to change.
- * #
- * [main]
- * # The 'main' section defines Shiro-wide configuration.
- * #
- * # Each section's configuration is essentially an object graph definition in a .properties style (name/value pair)
- * # format.  The beans defined would be those that are used to construct the application's SecurityManager.  It is
- * # essentially 'poor man's' dependency injection via a .properties format.
- * #
- * # --- Defining Realms ---
- * #
- * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.
- * # For example:
- * #
- * # myRealm = example.pkg.security.MyRealm
- * #
- * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into
- * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference
- * # other beans ('$' bean reference notation) while defining Realms and other objects:
- * #
- * # <b>connectionFactory</b> = example.pkg.ConnectionFactory
- * # connectionFactory.driverClassName = a.jdbc.Driver
- * # connectionFactory.username = aUsername
- * # connectionFactory.password = aPassword
- * # connectionFactory.minConnections = 3
- * # connectionFactory.maxConnections = 10
- * # ... etc...
- * #
- * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm
- * # myJdbcRealm.connectionFactory = <b>$connectionFactory</b>
- * # ... etc ...
- * #
- * # --- Realm Factories ---
- * #
- * # If the INI style isn't robust enough for your needs, you also have the option of implementing the
- * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction
- * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the
- * # SecurityManager just as the individual Realms are.  For example:
- * #
- * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory
- * #
- * # --- SessionManager properties ---
- * #
- * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.
- * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager}, so you
- * # can set any of its corresponding properties as necessary:
- * #
- * # someObject = some.fully.qualified.ClassName
- * # someObject.propertyN = foo
- * # ...
- * # securityManager.someObject = $someObject
- * #
- * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.
- * # By default, Shiro's Session infrastructure in a web environment will use the
- * # Servlet container's HttpSession.  However, if you need to share session state across client types
- * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for
- * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful
- * # (and client-agnostic) session management.  You can enable this by uncommenting the following line
- * # and changing 'http' to 'native'
- * #
- * #securityManager.{@link org.apache.shiro.web.mgt.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http
- * #
- * [filters]
- * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.
- * #
- * # The following commented values are already provided by Shiro by default and are immediately usable
- * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines
- * # you need to change.
- * #
- * # Each Filter is configured based on its functionality and/or protocol.  You should read each
- * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would
- * # affect the user experience.
- * #
- * # Form-based Authentication filter:
- * #<a name="authc"></a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp
- * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}
- * #
- * # Http BASIC Authentication filter:
- * #<a name="authcBasic"></a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}
- * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application
- * #
- * # Roles filter: requires the requesting user to have one or more roles for the request to continue.
- * # If they do not have the specified roles, they are redirected to the specified URL.
- * #<a name="roles"></a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}
- * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =
- * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead
- * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.
- * #
- * # Permissions filter: requires the requesting user to have one or more permissions for the request to
- * # continue, and if they do not, redirects them to the specified URL.
- * #<a name="perms"></a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}
- * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =
- * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead
- * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many
- * # applications like to use the same url specified in roles.unauthorizedUrl above.
- * #
- * #
- * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,
- * # $references, etc).  To properly handle url path matching (see the [urls] section below), your
- * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.
- * #
- * [urls]
- * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the
- * # following representation:
- * #
- * # ant_path_expression = path_specific_filter_chain_definition
- * #
- * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of
- * # filters to execute for that request.
- * #
- * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern
- * # to greatly customize the security experience.
- * #
- * # The path_specific_filter_chain_definition must match the following format:
- * #
- * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]
- * #
- * # where 'filterN' is the name of an filter defined above in the [filters] section and
- * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for
- * # _that particular path_.  If the filter does not need specific config for that url path, you may
- * # discard the brackets so filterN[] just becomes filterN.
- * #
- * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern
- * # in the order you want them to filter (comma-delimited).
- * #
- * # Finally, each filter is free to handle the response however it wants if its necessary
- * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow
- * # the request to continue through the chain on to the final destination view.
- * #
- * # Examples:
- * #
- * # To illustrate chain configuration, look at the /account/** mapping below.  This says
- * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the
- * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].
- * #
- * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use
- * # bracket notation.  That definition says:
- * #
- * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user
- * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;
- * #
- * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to quote any config
- * # value which may require a comma. If we didn't do that, the permission filter below would interpret
- * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the
- * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal
- * # commas.)
- * #
- * /account/** = <a href="#authcBasic">authcBasic</a>
- * /remoting/** = <a href="#authcBasic">authcBasic</a>, <a href="#roles">roles</a>[b2bClient], <a href="#perms">perms</a>["remote:invoke:lan,wan"]
- * &lt;/param-value&gt;&lt;/init-param&gt;
- * &lt;/filter&gt;
- * <p/>
- * &lt;filter-mapping&gt;
- *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
- *     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
- * &lt;/filter-mapping&gt;</pre>
- *
- * @since 1.0
- */
-public class IniShiroFilter extends AbstractShiroFilter {
-
-    public static final String CONFIG_INIT_PARAM_NAME = "config";
-    public static final String CONFIG_PATH_INIT_PARAM_NAME = "configPath";
-
-    private static final Logger log = LoggerFactory.getLogger(IniShiroFilter.class);
-
-    private String config;
-    private String configPath;
-
-    public IniShiroFilter() {
-    }
-
-    /**
-     * Returns the actual INI configuration text to use to build the {@link SecurityManager} and
-     * {@link FilterChainResolver} used by the web application or {@code null} if the
-     * {@link #getConfigPath() configPath} should be used to load a fallback INI source.
-     * <p/>
-     * This value is {@code null} by default, but it will be automatically set to the value of the
-     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
-     * container at startup.
-     *
-     * @return the actual INI configuration text to use to build the {@link SecurityManager} and
-     *         {@link FilterChainResolver} used by the web application or {@code null} if the
-     *         {@link #getConfigPath() configPath} should be used to load a fallback INI source.
-     */
-    public String getConfig() {
-        return this.config;
-    }
-
-    /**
-     * Sets the actual INI configuration text to use to build the {@link SecurityManager} and
-     * {@link FilterChainResolver} used by the web application.  If this value is {@code null}, the
-     * {@link #getConfigPath() configPath} will be checked to see if a .ini file should be loaded instead.
-     * <p/>
-     * This value is {@code null} by default, but it will be automatically set to the value of the
-     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
-     * container at startup.
-     *
-     * @param config the actual INI configuration text to use to build the {@link SecurityManager} and
-     *               {@link FilterChainResolver} used by the web application.
-     */
-    public void setConfig(String config) {
-        this.config = config;
-    }
-
-    /**
-     * Returns the config path to be used to load a .ini file for configuration if a configuration is
-     * not specified via the {@link #getConfig() config} attribute.
-     * <p/>
-     * This value is {@code null} by default, but it will be automatically set to the value of the
-     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
-     * container at startup.
-     *
-     * @return the config path to be used to load a .ini file for configuration if a configuration is
-     *         not specified via the {@link #getConfig() config} attribute.
-     */
-    public String getConfigPath() {
-        return configPath;
-    }
-
-    /**
-     * Sets the config path to be used to load a .ini file for configuration if a configuration is
-     * not specified via the {@link #getConfig() config} attribute.
-     * <p/>
-     * This value is {@code null} by default, but it will be automatically set to the value of the
-     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
-     * container at startup.
-     *
-     * @param configPath the config path to be used to load a .ini file for configuration if a configuration is
-     *                   not specified via the {@link #getConfig() config} attribute.
-     */
-    public void setConfigPath(String configPath) {
-        this.configPath = configPath;
-    }
-
-    public void init() throws Exception {
-        applyInitParams();
-        configure();
-    }
-
-    protected void applyInitParams() throws Exception {
-        String config = getInitParam(CONFIG_INIT_PARAM_NAME);
-        if (config != null) {
-            setConfig(config);
-        }
-        String configPath = getInitParam(CONFIG_PATH_INIT_PARAM_NAME);
-        if (configPath != null) {
-            setConfigPath(configPath);
-        }
-    }
-
-    protected void configure() throws Exception {
-        Ini ini = loadIniFromConfig();
-
-        if (CollectionUtils.isEmpty(ini)) {
-            log.info("Null or empty configuration specified via 'config' init-param.  " +
-                    "Checking path-based configuration.");
-            ini = loadIniFromPath();
-        }
-        if (CollectionUtils.isEmpty(ini)) {
-            log.info("Null or empty configuration specified via '" + CONFIG_INIT_PARAM_NAME + "' or '" +
-                    CONFIG_PATH_INIT_PARAM_NAME + "' filter parameters.  Trying the default " +
-                    IniFactorySupport.DEFAULT_INI_RESOURCE_PATH + " file.");
-            ini = IniFactorySupport.loadDefaultClassPathIni();
-        }
-
-        Map<String, ?> objects = applySecurityManager(ini);
-        applyFilterChainResolver(ini, objects);
-    }
-
-    protected Ini loadIniFromConfig() {
-        Ini ini = null;
-        String config = getConfig();
-        if (config != null) {
-            ini = convertConfigToIni(config);
-        }
-        return ini;
-    }
-
-    protected Ini loadIniFromPath() {
-        Ini ini = null;
-        String path = getConfigPath();
-        if (path != null) {
-            ini = convertPathToIni(path);
-        }
-        return ini;
-    }
-
-    protected Map<String, ?> applySecurityManager(Ini ini) {
-        WebIniSecurityManagerFactory factory;
-        if (CollectionUtils.isEmpty(ini)) {
-            factory = new WebIniSecurityManagerFactory();
-        } else {
-            factory = new WebIniSecurityManagerFactory(ini);
-        }
-
-        // Create the security manager and check that it implements WebSecurityManager.
-        // Otherwise, it can't be used with the filter.
-        SecurityManager securityManager = factory.getInstance();
-        if (!(securityManager instanceof WebSecurityManager)) {
-            String msg = "The configured security manager is not an instance of WebSecurityManager, so " +
-                    "it can not be used with the Shiro servlet filter.";
-            throw new ConfigurationException(msg);
-        }
-
-        setSecurityManager((WebSecurityManager) securityManager);
-
-        return factory.getBeans();
-    }
-
-    protected void applyFilterChainResolver(Ini ini, Map<String, ?> defaults) {
-        if (ini == null || ini.isEmpty()) {
-            //nothing to use to create the resolver, just return
-            //(the AbstractShiroFilter allows a null resolver, in which case the original FilterChain is
-            // always used).
-            return;
-        }
-
-        //only create a resolver if the 'filters' or 'urls' sections are defined:
-        Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);
-        Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);
-        if ((urls != null && !urls.isEmpty()) || (filters != null && !filters.isEmpty())) {
-            //either the urls section or the filters section was defined.  Go ahead and create the resolver
-            //and set it:
-            IniFilterChainResolverFactory filterChainResolverFactory = new IniFilterChainResolverFactory(ini, defaults);
-            filterChainResolverFactory.setFilterConfig(getFilterConfig());
-            FilterChainResolver resolver = filterChainResolverFactory.getInstance();
-            setFilterChainResolver(resolver);
-        }
-    }
-
-    protected Ini convertConfigToIni(String config) {
-        Ini ini = new Ini();
-        ini.load(config);
-        return ini;
-    }
-
-    protected Ini convertPathToIni(String path) {
-        Ini ini = new Ini();
-        ini.loadFromPath(path);
-        return ini;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.servlet;
+
+import org.apache.shiro.config.ConfigurationException;
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.config.IniFactorySupport;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.web.config.IniFilterChainResolverFactory;
+import org.apache.shiro.web.config.WebIniSecurityManagerFactory;
+import org.apache.shiro.web.filter.mgt.FilterChainResolver;
+import org.apache.shiro.web.mgt.WebSecurityManager;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Map;
+
+/**
+ * Main Servlet Filter that configures and enables all Shiro functions within a web application by using the
+ * <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> configuration format.
+ * <p/>
+ * The following is a fully commented example that documents how to configure it:
+ * <pre>&lt;filter&gt;
+ * &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
+ * &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;
+ * &lt;init-param&gt;&lt;param-name&gt;config&lt;/param-name&gt;&lt;param-value&gt;
+ * #
+ * #NOTE:  This config looks pretty long - but its not - its only a few lines of actual config.
+ * #       Everything else is just heavily commented to explain things in-depth. Feel free to delete any
+ * #       comments that you don't want to read from your own configuration ;)
+ * #
+ * # Any commented values below that _don't_ start with 'example.pkg' are Shiro's defaults.  If you want to change any
+ * # values on those lines, you only need to uncomment the lines you want to change.
+ * #
+ * [main]
+ * # The 'main' section defines Shiro-wide configuration.
+ * #
+ * # Each section's configuration is essentially an object graph definition in a .properties style (name/value pair)
+ * # format.  The beans defined would be those that are used to construct the application's SecurityManager.  It is
+ * # essentially 'poor man's' dependency injection via a .properties format.
+ * #
+ * # --- Defining Realms ---
+ * #
+ * # Any Realm defined here will automatically be injected into Shiro's default SecurityManager created at start up.
+ * # For example:
+ * #
+ * # myRealm = example.pkg.security.MyRealm
+ * #
+ * # This would instantiate the some.pkg.security.MyRealm class with a default no-arg constructor and inject it into
+ * # the SecurityManager.  More than one realm can be defined if needed.  You can create graphs and reference
+ * # other beans ('$' bean reference notation) while defining Realms and other objects:
+ * #
+ * # <b>connectionFactory</b> = example.pkg.ConnectionFactory
+ * # connectionFactory.driverClassName = a.jdbc.Driver
+ * # connectionFactory.username = aUsername
+ * # connectionFactory.password = aPassword
+ * # connectionFactory.minConnections = 3
+ * # connectionFactory.maxConnections = 10
+ * # ... etc...
+ * #
+ * # myJdbcRealm = example.pkg.jdbc.MyJdbcRealm
+ * # myJdbcRealm.connectionFactory = <b>$connectionFactory</b>
+ * # ... etc ...
+ * #
+ * # --- Realm Factories ---
+ * #
+ * # If the INI style isn't robust enough for your needs, you also have the option of implementing the
+ * # {@link org.apache.shiro.realm.RealmFactory org.apache.shiro.realm.RealmFactory} interface with more complex construction
+ * # logic.  Then you can declare the implementation here instead.  The realms it returns will be injected in to the
+ * # SecurityManager just as the individual Realms are.  For example:
+ * #
+ * # aRealmFactory = some.pkg.ClassThatImplementsRealmFactory
+ * #
+ * # --- SessionManager properties ---
+ * #
+ * # Except for Realms and RealmFactories, all other objects should be defined and set on the SecurityManager directly.
+ * # The default 'securityManager' bean is an instance of {@link org.apache.shiro.web.mgt.DefaultWebSecurityManager}, so you
+ * # can set any of its corresponding properties as necessary:
+ * #
+ * # someObject = some.fully.qualified.ClassName
+ * # someObject.propertyN = foo
+ * # ...
+ * # securityManager.someObject = $someObject
+ * #
+ * # For example, if you wanted to change Shiro's default session mechanism, you can change the 'sessionMode' property.
+ * # By default, Shiro's Session infrastructure in a web environment will use the
+ * # Servlet container's HttpSession.  However, if you need to share session state across client types
+ * # (e.g. Web MVC plus Java Web Start or Flash), or are doing distributed/shared Sessions for
+ * # Single Sign On, HttpSessions aren't good enough.  You'll need to use Shiro's more powerful
+ * # (and client-agnostic) session management.  You can enable this by uncommenting the following line
+ * # and changing 'http' to 'native'
+ * #
+ * #securityManager.{@link org.apache.shiro.web.mgt.DefaultWebSecurityManager#setSessionMode(String) sessionMode} = http
+ * #
+ * [filters]
+ * # This section defines the 'pool' of all Filters available to the url path definitions in the [urls] section below.
+ * #
+ * # The following commented values are already provided by Shiro by default and are immediately usable
+ * # in the [urls] definitions below.  If you like, you may override any values by uncommenting only the lines
+ * # you need to change.
+ * #
+ * # Each Filter is configured based on its functionality and/or protocol.  You should read each
+ * # Filter's JavaDoc to fully understand what each does and how it works as well as how it would
+ * # affect the user experience.
+ * #
+ * # Form-based Authentication filter:
+ * #<a name="authc"></a>authc = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter}
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setLoginUrl(String) loginUrl} = /login.jsp
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setUsernameParam(String) usernameParam} = username
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setPasswordParam(String) passwordParam} = password
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setRememberMeParam(String) rememberMeParam} = rememberMe
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setSuccessUrl(String) successUrl}  = /login.jsp
+ * #authc.{@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#setFailureKeyAttribute(String) failureKeyAttribute} = {@link org.apache.shiro.web.filter.authc.FormAuthenticationFilter#DEFAULT_ERROR_KEY_ATTRIBUTE_NAME}
+ * #
+ * # Http BASIC Authentication filter:
+ * #<a name="authcBasic"></a>authcBasic = {@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter}
+ * #authcBasic.{@link org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter#setApplicationName(String) applicationName} = application
+ * #
+ * # Roles filter: requires the requesting user to have one or more roles for the request to continue.
+ * # If they do not have the specified roles, they are redirected to the specified URL.
+ * #<a name="roles"></a>roles = {@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter}
+ * #roles.{@link org.apache.shiro.web.filter.authz.RolesAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =
+ * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead
+ * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.
+ * #
+ * # Permissions filter: requires the requesting user to have one or more permissions for the request to
+ * # continue, and if they do not, redirects them to the specified URL.
+ * #<a name="perms"></a>perms = {@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter}
+ * #perms.{@link org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter#setUnauthorizedUrl(String) unauthorizedUrl} =
+ * # (note the above url is null by default, which will cause an HTTP 403 (Access Denied) response instead
+ * # of redirecting to a page.  If you want to show a 'nice page' instead, you should specify that url.  Many
+ * # applications like to use the same url specified in roles.unauthorizedUrl above.
+ * #
+ * #
+ * # Define your own filters here as you would any other object as described in the '[main]' section above (properties,
+ * # $references, etc).  To properly handle url path matching (see the [urls] section below), your
+ * # filter should extend the {@link org.apache.shiro.web.filter.PathMatchingFilter PathMatchingFilter} abstract class.
+ * #
+ * [urls]
+ * # This section defines url path mappings.  Each mapping entry must be on a single line and conform to the
+ * # following representation:
+ * #
+ * # ant_path_expression = path_specific_filter_chain_definition
+ * #
+ * # For any request that matches a specified path, the corresponding value defines a comma-delimited chain of
+ * # filters to execute for that request.
+ * #
+ * # This is incredibly powerful in that you can define arbitrary filter chains for any given request pattern
+ * # to greatly customize the security experience.
+ * #
+ * # The path_specific_filter_chain_definition must match the following format:
+ * #
+ * # filter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]
+ * #
+ * # where 'filterN' is the name of an filter defined above in the [filters] section and
+ * # '[optional_configN]' is an optional bracketed string that has meaning for that particular filter for
+ * # _that particular path_.  If the filter does not need specific config for that url path, you may
+ * # discard the brackets so filterN[] just becomes filterN.
+ * #
+ * # And because filter tokens define chains, order matters!  Define the tokens for each path pattern
+ * # in the order you want them to filter (comma-delimited).
+ * #
+ * # Finally, each filter is free to handle the response however it wants if its necessary
+ * # conditions are not met (redirect, HTTP error code, direct rendering, etc).  Otherwise, it is expected to allow
+ * # the request to continue through the chain on to the final destination view.
+ * #
+ * # Examples:
+ * #
+ * # To illustrate chain configuration, look at the /account/** mapping below.  This says
+ * # &quot;apply the above 'authcBasic' filter to any request matching the '/account/**' pattern&quot;.  Since the
+ * # 'authcBasic' filter does not need any path-specific config, it doesn't have any config brackets [].
+ * #
+ * # The /remoting/** definition on the other hand uses the 'roles' and 'perms' filters which do use
+ * # bracket notation.  That definition says:
+ * #
+ * # &quot;To access /remoting/** urls, ensure that the user is first authenticated ('authcBasic'), then ensure that user
+ * # has the 'b2bClient' role, and then finally ensure that they have the 'remote:invoke:lan,wan' permission.&quot;
+ * #
+ * # (Note that because elements within brackets [ ] are comma-delimited themselves, we needed to quote any config
+ * # value which may require a comma. If we didn't do that, the permission filter below would interpret
+ * # the text between the brackets as two permissions: 'remote:invoke:lan' and 'wan' instead of the
+ * # single desired 'remote:invoke:lan,wan' token.  So, you can use quotes wherever you need to escape internal
+ * # commas.)
+ * #
+ * /account/** = <a href="#authcBasic">authcBasic</a>
+ * /remoting/** = <a href="#authcBasic">authcBasic</a>, <a href="#roles">roles</a>[b2bClient], <a href="#perms">perms</a>["remote:invoke:lan,wan"]
+ * &lt;/param-value&gt;&lt;/init-param&gt;
+ * &lt;/filter&gt;
+ * <p/>
+ * &lt;filter-mapping&gt;
+ *     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
+ *     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
+ * &lt;/filter-mapping&gt;</pre>
+ *
+ * @since 1.0
+ */
+public class IniShiroFilter extends AbstractShiroFilter {
+
+    public static final String CONFIG_INIT_PARAM_NAME = "config";
+    public static final String CONFIG_PATH_INIT_PARAM_NAME = "configPath";
+
+    private static final Logger log = LoggerFactory.getLogger(IniShiroFilter.class);
+
+    private String config;
+    private String configPath;
+
+    public IniShiroFilter() {
+    }
+
+    /**
+     * Returns the actual INI configuration text to use to build the {@link SecurityManager} and
+     * {@link FilterChainResolver} used by the web application or {@code null} if the
+     * {@link #getConfigPath() configPath} should be used to load a fallback INI source.
+     * <p/>
+     * This value is {@code null} by default, but it will be automatically set to the value of the
+     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
+     * container at startup.
+     *
+     * @return the actual INI configuration text to use to build the {@link SecurityManager} and
+     *         {@link FilterChainResolver} used by the web application or {@code null} if the
+     *         {@link #getConfigPath() configPath} should be used to load a fallback INI source.
+     */
+    public String getConfig() {
+        return this.config;
+    }
+
+    /**
+     * Sets the actual INI configuration text to use to build the {@link SecurityManager} and
+     * {@link FilterChainResolver} used by the web application.  If this value is {@code null}, the
+     * {@link #getConfigPath() configPath} will be checked to see if a .ini file should be loaded instead.
+     * <p/>
+     * This value is {@code null} by default, but it will be automatically set to the value of the
+     * '{@code config}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
+     * container at startup.
+     *
+     * @param config the actual INI configuration text to use to build the {@link SecurityManager} and
+     *               {@link FilterChainResolver} used by the web application.
+     */
+    public void setConfig(String config) {
+        this.config = config;
+    }
+
+    /**
+     * Returns the config path to be used to load a .ini file for configuration if a configuration is
+     * not specified via the {@link #getConfig() config} attribute.
+     * <p/>
+     * This value is {@code null} by default, but it will be automatically set to the value of the
+     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
+     * container at startup.
+     *
+     * @return the config path to be used to load a .ini file for configuration if a configuration is
+     *         not specified via the {@link #getConfig() config} attribute.
+     */
+    public String getConfigPath() {
+        return configPath;
+    }
+
+    /**
+     * Sets the config path to be used to load a .ini file for configuration if a configuration is
+     * not specified via the {@link #getConfig() config} attribute.
+     * <p/>
+     * This value is {@code null} by default, but it will be automatically set to the value of the
+     * '{@code configPath}' {@code init-param} if it exists in the {@code FilterConfig} provided by the servlet
+     * container at startup.
+     *
+     * @param configPath the config path to be used to load a .ini file for configuration if a configuration is
+     *                   not specified via the {@link #getConfig() config} attribute.
+     */
+    public void setConfigPath(String configPath) {
+        this.configPath = configPath;
+    }
+
+    public void init() throws Exception {
+        applyInitParams();
+        configure();
+    }
+
+    protected void applyInitParams() throws Exception {
+        String config = getInitParam(CONFIG_INIT_PARAM_NAME);
+        if (config != null) {
+            setConfig(config);
+        }
+        String configPath = getInitParam(CONFIG_PATH_INIT_PARAM_NAME);
+        if (configPath != null) {
+            setConfigPath(configPath);
+        }
+    }
+
+    protected void configure() throws Exception {
+        Ini ini = loadIniFromConfig();
+
+        if (CollectionUtils.isEmpty(ini)) {
+            log.info("Null or empty configuration specified via 'config' init-param.  " +
+                    "Checking path-based configuration.");
+            ini = loadIniFromPath();
+        }
+        if (CollectionUtils.isEmpty(ini)) {
+            log.info("Null or empty configuration specified via '" + CONFIG_INIT_PARAM_NAME + "' or '" +
+                    CONFIG_PATH_INIT_PARAM_NAME + "' filter parameters.  Trying the default " +
+                    IniFactorySupport.DEFAULT_INI_RESOURCE_PATH + " file.");
+            ini = IniFactorySupport.loadDefaultClassPathIni();
+        }
+
+        Map<String, ?> objects = applySecurityManager(ini);
+        applyFilterChainResolver(ini, objects);
+    }
+
+    protected Ini loadIniFromConfig() {
+        Ini ini = null;
+        String config = getConfig();
+        if (config != null) {
+            ini = convertConfigToIni(config);
+        }
+        return ini;
+    }
+
+    protected Ini loadIniFromPath() {
+        Ini ini = null;
+        String path = getConfigPath();
+        if (path != null) {
+            ini = convertPathToIni(path);
+        }
+        return ini;
+    }
+
+    protected Map<String, ?> applySecurityManager(Ini ini) {
+        WebIniSecurityManagerFactory factory;
+        if (CollectionUtils.isEmpty(ini)) {
+            factory = new WebIniSecurityManagerFactory();
+        } else {
+            factory = new WebIniSecurityManagerFactory(ini);
+        }
+
+        // Create the security manager and check that it implements WebSecurityManager.
+        // Otherwise, it can't be used with the filter.
+        SecurityManager securityManager = factory.getInstance();
+        if (!(securityManager instanceof WebSecurityManager)) {
+            String msg = "The configured security manager is not an instance of WebSecurityManager, so " +
+                    "it can not be used with the Shiro servlet filter.";
+            throw new ConfigurationException(msg);
+        }
+
+        setSecurityManager((WebSecurityManager) securityManager);
+
+        return factory.getBeans();
+    }
+
+    protected void applyFilterChainResolver(Ini ini, Map<String, ?> defaults) {
+        if (ini == null || ini.isEmpty()) {
+            //nothing to use to create the resolver, just return
+            //(the AbstractShiroFilter allows a null resolver, in which case the original FilterChain is
+            // always used).
+            return;
+        }
+
+        //only create a resolver if the 'filters' or 'urls' sections are defined:
+        Ini.Section urls = ini.getSection(IniFilterChainResolverFactory.URLS);
+        Ini.Section filters = ini.getSection(IniFilterChainResolverFactory.FILTERS);
+        if ((urls != null && !urls.isEmpty()) || (filters != null && !filters.isEmpty())) {
+            //either the urls section or the filters section was defined.  Go ahead and create the resolver
+            //and set it:
+            IniFilterChainResolverFactory filterChainResolverFactory = new IniFilterChainResolverFactory(ini, defaults);
+            filterChainResolverFactory.setFilterConfig(getFilterConfig());
+            FilterChainResolver resolver = filterChainResolverFactory.getInstance();
+            setFilterChainResolver(resolver);
+        }
+    }
+
+    protected Ini convertConfigToIni(String config) {
+        Ini ini = new Ini();
+        ini.load(config);
+        return ini;
+    }
+
+    protected Ini convertPathToIni(String path) {
+        Ini ini = new Ini();
+        ini.loadFromPath(path);
+        return ini;
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/servlet/NameableFilter.java b/web/src/main/java/org/apache/shiro/web/servlet/NameableFilter.java
index 7235bf5e0..de74a3203 100644
--- a/web/src/main/java/org/apache/shiro/web/servlet/NameableFilter.java
+++ b/web/src/main/java/org/apache/shiro/web/servlet/NameableFilter.java
@@ -1,95 +1,95 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.servlet;
-
-import org.apache.shiro.util.Nameable;
-
-import javax.servlet.FilterConfig;
-
-/**
- * Allows a filter to be named via JavaBeans-compatible
- * {@link #getName()}/{@link #setName(String)} methods.  If no name is specified, the name of the filter will
- * default to the name given to it in {@code web.xml} (the {@code FilterConfig}'s
- * {@link javax.servlet.FilterConfig#getFilterName() filterName}).
- *
- * @since 1.0
- */
-public abstract class NameableFilter extends AbstractFilter implements Nameable {
-
-    /**
-     * The name of this filter, unique within an application.
-     */
-    private String name;
-
-    /**
-     * Returns the filter's name.
-     * <p/>
-     * Unless overridden by calling the {@link #setName(String) setName(String)} method, this value defaults to the
-     * filter name as specified by the servlet container at start-up:
-     * <pre>
-     * this.name = {@link #getFilterConfig() getFilterConfig()}.{@link javax.servlet.FilterConfig#getFilterName() getName()};</pre>
-     *
-     * @return the filter name, or {@code null} if none available
-     * @see javax.servlet.GenericServlet#getServletName()
-     * @see javax.servlet.FilterConfig#getFilterName()
-     */
-    protected String getName() {
-        if (this.name == null) {
-            FilterConfig config = getFilterConfig();
-            if (config != null) {
-                this.name = config.getFilterName();
-            }
-        }
-
-        return this.name;
-    }
-
-    /**
-     * Sets the filter's name.
-     * <p/>
-     * Unless overridden by calling this method, this value defaults to the filter name as specified by the
-     * servlet container at start-up:
-     * <pre>
-     * this.name = {@link #getFilterConfig() getFilterConfig()}.{@link javax.servlet.FilterConfig#getFilterName() getName()};</pre>
-     *
-     * @param name the name of the filter.
-     */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /**
-     * Returns a StringBuilder instance with the {@link #getName() name}, or if the name is {@code null}, just the
-     * {@code super.toStringBuilder()} instance.
-     *
-     * @return a StringBuilder instance to use for appending String data that will eventually be returned from a
-     *         {@code toString()} invocation.
-     */
-    protected StringBuilder toStringBuilder() {
-        String name = getName();
-        if (name == null) {
-            return super.toStringBuilder();
-        } else {
-            StringBuilder sb = new StringBuilder();
-            sb.append(name);
-            return sb;
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.servlet;
+
+import org.apache.shiro.util.Nameable;
+
+import javax.servlet.FilterConfig;
+
+/**
+ * Allows a filter to be named via JavaBeans-compatible
+ * {@link #getName()}/{@link #setName(String)} methods.  If no name is specified, the name of the filter will
+ * default to the name given to it in {@code web.xml} (the {@code FilterConfig}'s
+ * {@link javax.servlet.FilterConfig#getFilterName() filterName}).
+ *
+ * @since 1.0
+ */
+public abstract class NameableFilter extends AbstractFilter implements Nameable {
+
+    /**
+     * The name of this filter, unique within an application.
+     */
+    private String name;
+
+    /**
+     * Returns the filter's name.
+     * <p/>
+     * Unless overridden by calling the {@link #setName(String) setName(String)} method, this value defaults to the
+     * filter name as specified by the servlet container at start-up:
+     * <pre>
+     * this.name = {@link #getFilterConfig() getFilterConfig()}.{@link javax.servlet.FilterConfig#getFilterName() getName()};</pre>
+     *
+     * @return the filter name, or {@code null} if none available
+     * @see javax.servlet.GenericServlet#getServletName()
+     * @see javax.servlet.FilterConfig#getFilterName()
+     */
+    protected String getName() {
+        if (this.name == null) {
+            FilterConfig config = getFilterConfig();
+            if (config != null) {
+                this.name = config.getFilterName();
+            }
+        }
+
+        return this.name;
+    }
+
+    /**
+     * Sets the filter's name.
+     * <p/>
+     * Unless overridden by calling this method, this value defaults to the filter name as specified by the
+     * servlet container at start-up:
+     * <pre>
+     * this.name = {@link #getFilterConfig() getFilterConfig()}.{@link javax.servlet.FilterConfig#getFilterName() getName()};</pre>
+     *
+     * @param name the name of the filter.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Returns a StringBuilder instance with the {@link #getName() name}, or if the name is {@code null}, just the
+     * {@code super.toStringBuilder()} instance.
+     *
+     * @return a StringBuilder instance to use for appending String data that will eventually be returned from a
+     *         {@code toString()} invocation.
+     */
+    protected StringBuilder toStringBuilder() {
+        String name = getName();
+        if (name == null) {
+            return super.toStringBuilder();
+        } else {
+            StringBuilder sb = new StringBuilder();
+            sb.append(name);
+            return sb;
+        }
+    }
+
+}
diff --git a/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java b/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
index cc1a71d32..14e924147 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
@@ -1,160 +1,160 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.subject;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.SubjectContext;
-import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
-import org.apache.shiro.web.util.RequestPairSource;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * A {@code WebSubject} represents a Subject instance that was acquired as a result of an incoming
- * {@link ServletRequest}.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public interface WebSubject extends Subject, RequestPairSource {
-
-    /**
-     * Returns the {@code ServletRequest} accessible when the Subject instance was created.
-     *
-     * @return the {@code ServletRequest} accessible when the Subject instance was created.
-     */
-    ServletRequest getServletRequest();
-
-    /**
-     * Returns the {@code ServletResponse} accessible when the Subject instance was created.
-     *
-     * @return the {@code ServletResponse} accessible when the Subject instance was created.
-     */
-    ServletResponse getServletResponse();
-
-    /**
-     * A {@code WebSubject.Builder} performs the same function as a {@link Subject.Builder Subject.Builder}, but
-     * additionally ensures that the Servlet request/response pair that is triggering the Subject instance's creation
-     * is retained for use by internal Shiro components as necessary.
-     */
-    public static class Builder extends Subject.Builder {
-
-        /**
-         * Constructs a new {@code Web.Builder} instance using the {@link SecurityManager SecurityManager} obtained by
-         * calling {@code SecurityUtils.}{@link SecurityUtils#getSecurityManager() getSecurityManager()}.  If you want
-         * to specify your own SecurityManager instance, use the
-         * {@link #Builder(SecurityManager, ServletRequest, ServletResponse)} constructor instead.
-         *
-         * @param request  the incoming ServletRequest that will be associated with the built {@code WebSubject} instance.
-         * @param response the outgoing ServletRequest paired with the ServletRequest that will be associated with the
-         *                 built {@code WebSubject} instance.
-         */
-        public Builder(ServletRequest request, ServletResponse response) {
-            this(SecurityUtils.getSecurityManager(), request, response);
-        }
-
-        /**
-         * Constructs a new {@code Web.Builder} instance using the specified {@code SecurityManager} instance to
-         * create the {@link WebSubject WebSubject} instance.
-         *
-         * @param securityManager the {@code SecurityManager SecurityManager} instance to use to build the
-         *                        {@code WebSubject} instance.
-         * @param request         the incoming ServletRequest that will be associated with the built {@code WebSubject}
-         *                        instance.
-         * @param response        the outgoing ServletRequest paired with the ServletRequest that will be associated
-         *                        with the built {@code WebSubject} instance.
-         */
-        public Builder(SecurityManager securityManager, ServletRequest request, ServletResponse response) {
-            super(securityManager);
-            if (request == null) {
-                throw new IllegalArgumentException("ServletRequest argument cannot be null.");
-            }
-            if (response == null) {
-                throw new IllegalArgumentException("ServletResponse argument cannot be null.");
-            }
-            setRequest(request);
-            setResponse(response);
-        }
-
-        /**
-         * Overrides the parent implementation to return a new instance of a
-         * {@link DefaultWebSubjectContext DefaultWebSubjectContext} to account for the additional request/response
-         * pair.
-         *
-         * @return a new instance of a {@link DefaultWebSubjectContext DefaultWebSubjectContext} to account for the
-         *         additional request/response pair.
-         */
-        @Override
-        protected SubjectContext newSubjectContextInstance() {
-            return new DefaultWebSubjectContext();
-        }
-
-        /**
-         * Called by the {@code WebSubject.Builder} constructor, this method places the request object in the
-         * context map for later retrieval.
-         *
-         * @param request the incoming ServletRequest that triggered the creation of the {@code WebSubject} instance.
-         * @return 'this' for method chaining.
-         */
-        protected Builder setRequest(ServletRequest request) {
-            if (request != null) {
-                ((WebSubjectContext) getSubjectContext()).setServletRequest(request);
-            }
-            return this;
-        }
-
-        /**
-         * Called by the {@code WebSubject.Builder} constructor, this method places the response object in the
-         * context map for later retrieval.
-         *
-         * @param response the outgoing ServletRequest paired with the ServletRequest that triggered the creation of
-         *                 the {@code WebSubject} instance.
-         * @return 'this' for method chaining.
-         */
-        protected Builder setResponse(ServletResponse response) {
-            if (response != null) {
-                ((WebSubjectContext) getSubjectContext()).setServletResponse(response);
-            }
-            return this;
-        }
-
-        /**
-         * Returns {@link #buildSubject() super.buildSubject()}, but additionally ensures that the returned instance
-         * is an {@code instanceof} {@link WebSubject WebSubject} and to support a type-safe method so a caller
-         * does not have to cast.   Per the parent class's method JavaDoc, this method will return a new instance
-         * each time it is called.
-         *
-         * @return a new {@link WebSubject WebSubject} instance built by this {@code Builder}.
-         */
-        public WebSubject buildWebSubject() {
-            Subject subject = super.buildSubject();
-            if (!(subject instanceof WebSubject)) {
-                String msg = "Subject implementation returned from the SecurityManager was not a " +
-                        WebSubject.class.getName() + " implementation.  Please ensure a Web-enabled SecurityManager " +
-                        "has been configured and made available to this builder.";
-                throw new IllegalStateException(msg);
-            }
-            return (WebSubject) subject;
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.subject;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.subject.SubjectContext;
+import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
+import org.apache.shiro.web.util.RequestPairSource;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A {@code WebSubject} represents a Subject instance that was acquired as a result of an incoming
+ * {@link ServletRequest}.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public interface WebSubject extends Subject, RequestPairSource {
+
+    /**
+     * Returns the {@code ServletRequest} accessible when the Subject instance was created.
+     *
+     * @return the {@code ServletRequest} accessible when the Subject instance was created.
+     */
+    ServletRequest getServletRequest();
+
+    /**
+     * Returns the {@code ServletResponse} accessible when the Subject instance was created.
+     *
+     * @return the {@code ServletResponse} accessible when the Subject instance was created.
+     */
+    ServletResponse getServletResponse();
+
+    /**
+     * A {@code WebSubject.Builder} performs the same function as a {@link Subject.Builder Subject.Builder}, but
+     * additionally ensures that the Servlet request/response pair that is triggering the Subject instance's creation
+     * is retained for use by internal Shiro components as necessary.
+     */
+    public static class Builder extends Subject.Builder {
+
+        /**
+         * Constructs a new {@code Web.Builder} instance using the {@link SecurityManager SecurityManager} obtained by
+         * calling {@code SecurityUtils.}{@link SecurityUtils#getSecurityManager() getSecurityManager()}.  If you want
+         * to specify your own SecurityManager instance, use the
+         * {@link #Builder(SecurityManager, ServletRequest, ServletResponse)} constructor instead.
+         *
+         * @param request  the incoming ServletRequest that will be associated with the built {@code WebSubject} instance.
+         * @param response the outgoing ServletRequest paired with the ServletRequest that will be associated with the
+         *                 built {@code WebSubject} instance.
+         */
+        public Builder(ServletRequest request, ServletResponse response) {
+            this(SecurityUtils.getSecurityManager(), request, response);
+        }
+
+        /**
+         * Constructs a new {@code Web.Builder} instance using the specified {@code SecurityManager} instance to
+         * create the {@link WebSubject WebSubject} instance.
+         *
+         * @param securityManager the {@code SecurityManager SecurityManager} instance to use to build the
+         *                        {@code WebSubject} instance.
+         * @param request         the incoming ServletRequest that will be associated with the built {@code WebSubject}
+         *                        instance.
+         * @param response        the outgoing ServletRequest paired with the ServletRequest that will be associated
+         *                        with the built {@code WebSubject} instance.
+         */
+        public Builder(SecurityManager securityManager, ServletRequest request, ServletResponse response) {
+            super(securityManager);
+            if (request == null) {
+                throw new IllegalArgumentException("ServletRequest argument cannot be null.");
+            }
+            if (response == null) {
+                throw new IllegalArgumentException("ServletResponse argument cannot be null.");
+            }
+            setRequest(request);
+            setResponse(response);
+        }
+
+        /**
+         * Overrides the parent implementation to return a new instance of a
+         * {@link DefaultWebSubjectContext DefaultWebSubjectContext} to account for the additional request/response
+         * pair.
+         *
+         * @return a new instance of a {@link DefaultWebSubjectContext DefaultWebSubjectContext} to account for the
+         *         additional request/response pair.
+         */
+        @Override
+        protected SubjectContext newSubjectContextInstance() {
+            return new DefaultWebSubjectContext();
+        }
+
+        /**
+         * Called by the {@code WebSubject.Builder} constructor, this method places the request object in the
+         * context map for later retrieval.
+         *
+         * @param request the incoming ServletRequest that triggered the creation of the {@code WebSubject} instance.
+         * @return 'this' for method chaining.
+         */
+        protected Builder setRequest(ServletRequest request) {
+            if (request != null) {
+                ((WebSubjectContext) getSubjectContext()).setServletRequest(request);
+            }
+            return this;
+        }
+
+        /**
+         * Called by the {@code WebSubject.Builder} constructor, this method places the response object in the
+         * context map for later retrieval.
+         *
+         * @param response the outgoing ServletRequest paired with the ServletRequest that triggered the creation of
+         *                 the {@code WebSubject} instance.
+         * @return 'this' for method chaining.
+         */
+        protected Builder setResponse(ServletResponse response) {
+            if (response != null) {
+                ((WebSubjectContext) getSubjectContext()).setServletResponse(response);
+            }
+            return this;
+        }
+
+        /**
+         * Returns {@link #buildSubject() super.buildSubject()}, but additionally ensures that the returned instance
+         * is an {@code instanceof} {@link WebSubject WebSubject} and to support a type-safe method so a caller
+         * does not have to cast.   Per the parent class's method JavaDoc, this method will return a new instance
+         * each time it is called.
+         *
+         * @return a new {@link WebSubject WebSubject} instance built by this {@code Builder}.
+         */
+        public WebSubject buildWebSubject() {
+            Subject subject = super.buildSubject();
+            if (!(subject instanceof WebSubject)) {
+                String msg = "Subject implementation returned from the SecurityManager was not a " +
+                        WebSubject.class.getName() + " implementation.  Please ensure a Web-enabled SecurityManager " +
+                        "has been configured and made available to this builder.";
+                throw new IllegalStateException(msg);
+            }
+            return (WebSubject) subject;
+        }
+    }
+
+}
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java b/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
index 02a0306a4..fde8318e1 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
@@ -1,75 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.subject.support;
-
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.mgt.SessionContext;
-import org.apache.shiro.subject.PrincipalCollection;
-import org.apache.shiro.subject.support.DelegatingSubject;
-import org.apache.shiro.util.StringUtils;
-import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;
-import org.apache.shiro.web.session.mgt.WebSessionContext;
-import org.apache.shiro.web.subject.WebSubject;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * Default {@link WebSubject WebSubject} implementation that additional ensures the ability to retain a
- * servlet request/response pair to be used by internal shiro components as necessary during the request execution.
- *
- * @since 1.0
- */
-public class WebDelegatingSubject extends DelegatingSubject implements WebSubject {
-
-    private static final long serialVersionUID = -1655724323350159250L;
-
-    private final ServletRequest servletRequest;
-    private final ServletResponse servletResponse;
-
-    public WebDelegatingSubject(PrincipalCollection principals, boolean authenticated,
-                                String host, Session session,
-                                ServletRequest request, ServletResponse response,
-                                SecurityManager securityManager) {
-        super(principals, authenticated, host, session, securityManager);
-        this.servletRequest = request;
-        this.servletResponse = response;
-    }
-
-    public ServletRequest getServletRequest() {
-        return servletRequest;
-    }
-
-    public ServletResponse getServletResponse() {
-        return servletResponse;
-    }
-
-    @Override
-    protected SessionContext createSessionContext() {
-        WebSessionContext wsc = new DefaultWebSessionContext();
-        String host = getHost();
-        if (StringUtils.hasText(host)) {
-            wsc.setHost(host);
-        }
-        wsc.setServletRequest(this.servletRequest);
-        wsc.setServletResponse(this.servletResponse);
-        return wsc;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.subject.support;
+
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.subject.PrincipalCollection;
+import org.apache.shiro.subject.support.DelegatingSubject;
+import org.apache.shiro.util.StringUtils;
+import org.apache.shiro.web.session.mgt.DefaultWebSessionContext;
+import org.apache.shiro.web.session.mgt.WebSessionContext;
+import org.apache.shiro.web.subject.WebSubject;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * Default {@link WebSubject WebSubject} implementation that additional ensures the ability to retain a
+ * servlet request/response pair to be used by internal shiro components as necessary during the request execution.
+ *
+ * @since 1.0
+ */
+public class WebDelegatingSubject extends DelegatingSubject implements WebSubject {
+
+    private static final long serialVersionUID = -1655724323350159250L;
+
+    private final ServletRequest servletRequest;
+    private final ServletResponse servletResponse;
+
+    public WebDelegatingSubject(PrincipalCollection principals, boolean authenticated,
+                                String host, Session session,
+                                ServletRequest request, ServletResponse response,
+                                SecurityManager securityManager) {
+        super(principals, authenticated, host, session, securityManager);
+        this.servletRequest = request;
+        this.servletResponse = response;
+    }
+
+    public ServletRequest getServletRequest() {
+        return servletRequest;
+    }
+
+    public ServletResponse getServletResponse() {
+        return servletResponse;
+    }
+
+    @Override
+    protected SessionContext createSessionContext() {
+        WebSessionContext wsc = new DefaultWebSessionContext();
+        String host = getHost();
+        if (StringUtils.hasText(host)) {
+            wsc.setHost(host);
+        }
+        wsc.setServletRequest(this.servletRequest);
+        wsc.setServletResponse(this.servletResponse);
+        return wsc;
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/tags/AuthenticatedTag.java b/web/src/main/java/org/apache/shiro/web/tags/AuthenticatedTag.java
index 7ab31f51f..c778c5a66 100644
--- a/web/src/main/java/org/apache/shiro/web/tags/AuthenticatedTag.java
+++ b/web/src/main/java/org/apache/shiro/web/tags/AuthenticatedTag.java
@@ -1,62 +1,62 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.tags;
-
-import javax.servlet.jsp.JspException;
-import javax.servlet.jsp.tagext.TagSupport;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-
-/**
- * JSP tag that renders the tag body only if the current user has executed a <b>successful</b> authentication attempt
- * <em>during their current session</em>.
- *
- * <p>This is more restrictive than the {@link UserTag}, which only
- * ensures the current user is known to the system, either via a current login or from Remember Me services,
- * which only makes the assumption that the current user is who they say they are, and does not guarantee it like
- * this tag does.
- *
- * <p>The logically opposite tag of this one is the {@link NotAuthenticatedTag}
- *
- * @author Jeremy Haile
- * @author Les Hazlewood
- * @since 0.2
- */
-public class AuthenticatedTag extends SecureTag {
-
-    //TODO - complete JavaDoc
-
-    private static final Logger log = LoggerFactory.getLogger(AuthenticatedTag.class);
-
-    public int onDoStartTag() throws JspException {
-        if (getSubject() != null && getSubject().isAuthenticated()) {
-            if (log.isTraceEnabled()) {
-                log.trace("Subject exists and is authenticated.  Tag body will be evaluated.");
-            }
-            return TagSupport.EVAL_BODY_INCLUDE;
-        } else {
-            if (log.isTraceEnabled()) {
-                log.trace("Subject does not exist or is not authenticated.  Tag body will not be evaluated.");
-            }
-            return TagSupport.SKIP_BODY;
-        }
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.tags;
+
+import javax.servlet.jsp.JspException;
+import javax.servlet.jsp.tagext.TagSupport;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * JSP tag that renders the tag body only if the current user has executed a <b>successful</b> authentication attempt
+ * <em>during their current session</em>.
+ *
+ * <p>This is more restrictive than the {@link UserTag}, which only
+ * ensures the current user is known to the system, either via a current login or from Remember Me services,
+ * which only makes the assumption that the current user is who they say they are, and does not guarantee it like
+ * this tag does.
+ *
+ * <p>The logically opposite tag of this one is the {@link NotAuthenticatedTag}
+ *
+ * @author Jeremy Haile
+ * @author Les Hazlewood
+ * @since 0.2
+ */
+public class AuthenticatedTag extends SecureTag {
+
+    //TODO - complete JavaDoc
+
+    private static final Logger log = LoggerFactory.getLogger(AuthenticatedTag.class);
+
+    public int onDoStartTag() throws JspException {
+        if (getSubject() != null && getSubject().isAuthenticated()) {
+            if (log.isTraceEnabled()) {
+                log.trace("Subject exists and is authenticated.  Tag body will be evaluated.");
+            }
+            return TagSupport.EVAL_BODY_INCLUDE;
+        } else {
+            if (log.isTraceEnabled()) {
+                log.trace("Subject does not exist or is not authenticated.  Tag body will not be evaluated.");
+            }
+            return TagSupport.SKIP_BODY;
+        }
+    }
 }
\ No newline at end of file
diff --git a/web/src/main/java/org/apache/shiro/web/tags/NotAuthenticatedTag.java b/web/src/main/java/org/apache/shiro/web/tags/NotAuthenticatedTag.java
index 5e5408ab4..19b9b69d4 100644
--- a/web/src/main/java/org/apache/shiro/web/tags/NotAuthenticatedTag.java
+++ b/web/src/main/java/org/apache/shiro/web/tags/NotAuthenticatedTag.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.tags;
-
-import javax.servlet.jsp.JspException;
-import javax.servlet.jsp.tagext.TagSupport;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-
-/**
- * JSP tag that renders the tag body only if the current user has <em>not</em> executed a successful authentication
- * attempt <em>during their current session</em>.
- *
- * <p>The logically opposite tag of this one is the {@link org.apache.shiro.web.tags.AuthenticatedTag}.
- *
- * @author Jeremy Haile
- * @since 0.2
- */
-public class NotAuthenticatedTag extends SecureTag {
-
-    //TODO - complete JavaDoc
-
-    private static final Logger log = LoggerFactory.getLogger(NotAuthenticatedTag.class);
-
-    public int onDoStartTag() throws JspException {
-        if (getSubject() == null || !getSubject().isAuthenticated()) {
-            if (log.isTraceEnabled()) {
-                log.trace("Subject does not exist or is not authenticated.  Tag body will be evaluated.");
-            }
-            return TagSupport.EVAL_BODY_INCLUDE;
-        } else {
-            if (log.isTraceEnabled()) {
-                log.trace("Subject exists and is authenticated.  Tag body will not be evaluated.");
-            }
-            return TagSupport.SKIP_BODY;
-        }
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.tags;
+
+import javax.servlet.jsp.JspException;
+import javax.servlet.jsp.tagext.TagSupport;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * JSP tag that renders the tag body only if the current user has <em>not</em> executed a successful authentication
+ * attempt <em>during their current session</em>.
+ *
+ * <p>The logically opposite tag of this one is the {@link org.apache.shiro.web.tags.AuthenticatedTag}.
+ *
+ * @author Jeremy Haile
+ * @since 0.2
+ */
+public class NotAuthenticatedTag extends SecureTag {
+
+    //TODO - complete JavaDoc
+
+    private static final Logger log = LoggerFactory.getLogger(NotAuthenticatedTag.class);
+
+    public int onDoStartTag() throws JspException {
+        if (getSubject() == null || !getSubject().isAuthenticated()) {
+            if (log.isTraceEnabled()) {
+                log.trace("Subject does not exist or is not authenticated.  Tag body will be evaluated.");
+            }
+            return TagSupport.EVAL_BODY_INCLUDE;
+        } else {
+            if (log.isTraceEnabled()) {
+                log.trace("Subject exists and is authenticated.  Tag body will not be evaluated.");
+            }
+            return TagSupport.SKIP_BODY;
+        }
+    }
 }
\ No newline at end of file
diff --git a/web/src/main/java/org/apache/shiro/web/tags/PrincipalTag.java b/web/src/main/java/org/apache/shiro/web/tags/PrincipalTag.java
index 124433fd8..07ee37fff 100644
--- a/web/src/main/java/org/apache/shiro/web/tags/PrincipalTag.java
+++ b/web/src/main/java/org/apache/shiro/web/tags/PrincipalTag.java
@@ -1,206 +1,206 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.tags;
-
-import java.beans.BeanInfo;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
-import java.io.IOException;
-import javax.servlet.jsp.JspException;
-import javax.servlet.jsp.JspTagException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * <p>Tag used to print out the String value of a user's default principal,
- * or a specific principal as specified by the tag's attributes.</p>
- *
- * <p> If no attributes are specified, the tag prints out the <tt>toString()</tt>
- * value of the user's default principal.  If the <tt>type</tt> attribute
- * is specified, the tag looks for a principal with the given type.  If the
- * <tt>property</tt> attribute is specified, the tag prints the string value of
- * the specified property of the principal.  If no principal is found or the user
- * is not authenticated, the tag displays nothing unless a <tt>defaultValue</tt>
- * is specified.</p>
- *
- * @author Jeremy Haile
- * @since 0.2
- */
-public class PrincipalTag extends SecureTag {
-
-    //TODO - complete JavaDoc
-
-    /*--------------------------------------------
-    |             C O N S T A N T S             |
-    ============================================*/
-
-    /*--------------------------------------------
-    |    I N S T A N C E   V A R I A B L E S    |
-    ============================================*/
-    private static final Logger log = LoggerFactory.getLogger(PrincipalTag.class);
-
-    /**
-     * The type of principal to be retrieved, or null if the default principal should be used.
-     */
-    private String type;
-
-    /**
-     * The property name to retrieve of the principal, or null if the <tt>toString()</tt> value should be used.
-     */
-    private String property;
-
-    /**
-     * The default value that should be displayed if the user is not authenticated, or no principal is found.
-     */
-    private String defaultValue;
-
-    /*--------------------------------------------
-    |         C O N S T R U C T O R S           |
-    ============================================*/
-
-    /*--------------------------------------------
-    |  A C C E S S O R S / M O D I F I E R S    |
-    ============================================*/
-
-
-    public String getType() {
-        return type;
-    }
-
-
-    public void setType(String type) {
-        this.type = type;
-    }
-
-
-    public String getProperty() {
-        return property;
-    }
-
-
-    public void setProperty(String property) {
-        this.property = property;
-    }
-
-
-    public String getDefaultValue() {
-        return defaultValue;
-    }
-
-
-    public void setDefaultValue(String defaultValue) {
-        this.defaultValue = defaultValue;
-    }
-
-    /*--------------------------------------------
-    |               M E T H O D S               |
-    ============================================*/
-
-
-    @SuppressWarnings({"unchecked"})
-    public int onDoStartTag() throws JspException {
-        String strValue = null;
-
-        if (getSubject() != null) {
-
-            // Get the principal to print out
-            Object principal;
-
-            if (type == null) {
-                principal = getSubject().getPrincipal();
-            } else {
-                principal = getPrincipalFromClassName();
-            }
-
-            // Get the string value of the principal
-            if (principal != null) {
-                if (property == null) {
-                    strValue = principal.toString();
-                } else {
-                    strValue = getPrincipalProperty(principal, property);
-                }
-            }
-
-        }
-
-        // Print out the principal value if not null
-        if (strValue != null) {
-            try {
-                pageContext.getOut().write(strValue);
-            } catch (IOException e) {
-                throw new JspTagException("Error writing [" + strValue + "] to JSP.", e);
-            }
-        }
-
-        return SKIP_BODY;
-    }
-
-    @SuppressWarnings({"unchecked"})
-    private Object getPrincipalFromClassName() {
-        Object principal = null;
-
-        try {
-            Class cls = Class.forName(type);
-            principal = getSubject().getPrincipals().oneByType(cls);
-        } catch (ClassNotFoundException e) {
-            if (log.isErrorEnabled()) {
-                log.error("Unable to find class for name [" + type + "]");
-            }
-        }
-        return principal;
-    }
-
-
-    private String getPrincipalProperty(Object principal, String property) throws JspTagException {
-        String strValue = null;
-
-        try {
-            BeanInfo bi = Introspector.getBeanInfo(principal.getClass());
-
-            // Loop through the properties to get the string value of the specified property
-            boolean foundProperty = false;
-            for (PropertyDescriptor pd : bi.getPropertyDescriptors()) {
-                if (pd.getName().equals(property)) {
-                    Object value = pd.getReadMethod().invoke(principal, (Object[]) null);
-                    strValue = String.valueOf(value);
-                    foundProperty = true;
-                    break;
-                }
-            }
-
-            if (!foundProperty) {
-                final String message = "Property [" + property + "] not found in principal of type [" + principal.getClass().getName() + "]";
-                if (log.isErrorEnabled()) {
-                    log.error(message);
-                }
-                throw new JspTagException(message);
-            }
-
-        } catch (Exception e) {
-            final String message = "Error reading property [" + property + "] from principal of type [" + principal.getClass().getName() + "]";
-            if (log.isErrorEnabled()) {
-                log.error(message, e);
-            }
-            throw new JspTagException(message, e);
-        }
-
-        return strValue;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.tags;
+
+import java.beans.BeanInfo;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.io.IOException;
+import javax.servlet.jsp.JspException;
+import javax.servlet.jsp.JspTagException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * <p>Tag used to print out the String value of a user's default principal,
+ * or a specific principal as specified by the tag's attributes.</p>
+ *
+ * <p> If no attributes are specified, the tag prints out the <tt>toString()</tt>
+ * value of the user's default principal.  If the <tt>type</tt> attribute
+ * is specified, the tag looks for a principal with the given type.  If the
+ * <tt>property</tt> attribute is specified, the tag prints the string value of
+ * the specified property of the principal.  If no principal is found or the user
+ * is not authenticated, the tag displays nothing unless a <tt>defaultValue</tt>
+ * is specified.</p>
+ *
+ * @author Jeremy Haile
+ * @since 0.2
+ */
+public class PrincipalTag extends SecureTag {
+
+    //TODO - complete JavaDoc
+
+    /*--------------------------------------------
+    |             C O N S T A N T S             |
+    ============================================*/
+
+    /*--------------------------------------------
+    |    I N S T A N C E   V A R I A B L E S    |
+    ============================================*/
+    private static final Logger log = LoggerFactory.getLogger(PrincipalTag.class);
+
+    /**
+     * The type of principal to be retrieved, or null if the default principal should be used.
+     */
+    private String type;
+
+    /**
+     * The property name to retrieve of the principal, or null if the <tt>toString()</tt> value should be used.
+     */
+    private String property;
+
+    /**
+     * The default value that should be displayed if the user is not authenticated, or no principal is found.
+     */
+    private String defaultValue;
+
+    /*--------------------------------------------
+    |         C O N S T R U C T O R S           |
+    ============================================*/
+
+    /*--------------------------------------------
+    |  A C C E S S O R S / M O D I F I E R S    |
+    ============================================*/
+
+
+    public String getType() {
+        return type;
+    }
+
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+
+    public String getProperty() {
+        return property;
+    }
+
+
+    public void setProperty(String property) {
+        this.property = property;
+    }
+
+
+    public String getDefaultValue() {
+        return defaultValue;
+    }
+
+
+    public void setDefaultValue(String defaultValue) {
+        this.defaultValue = defaultValue;
+    }
+
+    /*--------------------------------------------
+    |               M E T H O D S               |
+    ============================================*/
+
+
+    @SuppressWarnings({"unchecked"})
+    public int onDoStartTag() throws JspException {
+        String strValue = null;
+
+        if (getSubject() != null) {
+
+            // Get the principal to print out
+            Object principal;
+
+            if (type == null) {
+                principal = getSubject().getPrincipal();
+            } else {
+                principal = getPrincipalFromClassName();
+            }
+
+            // Get the string value of the principal
+            if (principal != null) {
+                if (property == null) {
+                    strValue = principal.toString();
+                } else {
+                    strValue = getPrincipalProperty(principal, property);
+                }
+            }
+
+        }
+
+        // Print out the principal value if not null
+        if (strValue != null) {
+            try {
+                pageContext.getOut().write(strValue);
+            } catch (IOException e) {
+                throw new JspTagException("Error writing [" + strValue + "] to JSP.", e);
+            }
+        }
+
+        return SKIP_BODY;
+    }
+
+    @SuppressWarnings({"unchecked"})
+    private Object getPrincipalFromClassName() {
+        Object principal = null;
+
+        try {
+            Class cls = Class.forName(type);
+            principal = getSubject().getPrincipals().oneByType(cls);
+        } catch (ClassNotFoundException e) {
+            if (log.isErrorEnabled()) {
+                log.error("Unable to find class for name [" + type + "]");
+            }
+        }
+        return principal;
+    }
+
+
+    private String getPrincipalProperty(Object principal, String property) throws JspTagException {
+        String strValue = null;
+
+        try {
+            BeanInfo bi = Introspector.getBeanInfo(principal.getClass());
+
+            // Loop through the properties to get the string value of the specified property
+            boolean foundProperty = false;
+            for (PropertyDescriptor pd : bi.getPropertyDescriptors()) {
+                if (pd.getName().equals(property)) {
+                    Object value = pd.getReadMethod().invoke(principal, (Object[]) null);
+                    strValue = String.valueOf(value);
+                    foundProperty = true;
+                    break;
+                }
+            }
+
+            if (!foundProperty) {
+                final String message = "Property [" + property + "] not found in principal of type [" + principal.getClass().getName() + "]";
+                if (log.isErrorEnabled()) {
+                    log.error(message);
+                }
+                throw new JspTagException(message);
+            }
+
+        } catch (Exception e) {
+            final String message = "Error reading property [" + property + "] from principal of type [" + principal.getClass().getName() + "]";
+            if (log.isErrorEnabled()) {
+                log.error(message, e);
+            }
+            throw new JspTagException(message, e);
+        }
+
+        return strValue;
+    }
 }
\ No newline at end of file
diff --git a/web/src/test/java/org/apache/shiro/web/WebTest.java b/web/src/test/java/org/apache/shiro/web/WebTest.java
index c98513d67..22eeacce8 100644
--- a/web/src/test/java/org/apache/shiro/web/WebTest.java
+++ b/web/src/test/java/org/apache/shiro/web/WebTest.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web;
-
-import static org.easymock.EasyMock.createNiceMock;
-import static org.easymock.EasyMock.expect;
-
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletContext;
-
-/**
- * @since 1.0
- */
-public abstract class WebTest {
-
-    protected FilterConfig createNiceMockFilterConfig() {
-        FilterConfig mock = createNiceMock(FilterConfig.class);
-        ServletContext mockServletContext = createNiceMock(ServletContext.class);
-        expect(mock.getServletContext()).andReturn(mockServletContext);
-        return mock;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web;
+
+import static org.easymock.EasyMock.createNiceMock;
+import static org.easymock.EasyMock.expect;
+
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletContext;
+
+/**
+ * @since 1.0
+ */
+public abstract class WebTest {
+
+    protected FilterConfig createNiceMockFilterConfig() {
+        FilterConfig mock = createNiceMock(FilterConfig.class);
+        ServletContext mockServletContext = createNiceMock(ServletContext.class);
+        expect(mock.getServletContext()).andReturn(mockServletContext);
+        return mock;
+    }
+
+
+}
diff --git a/web/src/test/java/org/apache/shiro/web/config/IniFilterChainResolverFactoryTest.java b/web/src/test/java/org/apache/shiro/web/config/IniFilterChainResolverFactoryTest.java
index 38c226d3f..92a476c3e 100644
--- a/web/src/test/java/org/apache/shiro/web/config/IniFilterChainResolverFactoryTest.java
+++ b/web/src/test/java/org/apache/shiro/web/config/IniFilterChainResolverFactoryTest.java
@@ -1,116 +1,116 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.config;
-
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.web.WebTest;
-import org.apache.shiro.web.filter.mgt.FilterChainResolver;
-import org.junit.Before;
-import org.junit.Test;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterConfig;
-import java.util.Map;
-
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-/**
- * Tests for the {@link IniFilterChainResolverFactory}.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class IniFilterChainResolverFactoryTest extends WebTest {
-
-    private IniFilterChainResolverFactory factory;
-
-    @Before
-    public void setUp() {
-        this.factory = new IniFilterChainResolverFactory();
-    }
-
-    @Test
-    public void testNewInstance() {
-        assertNull(factory.getFilterConfig());
-        factory.setFilterConfig(null);
-        assertNull(factory.getFilterConfig());
-    }
-
-    @Test
-    public void testGetInstanceNoIni() {
-        FilterChainResolver resolver = factory.getInstance();
-        assertNotNull(resolver);
-    }
-
-    @Test
-    public void testNewInstanceWithIni() {
-        Ini ini = new Ini();
-        String config =
-                "[urls]\n" +
-                        "/index.html = anon";
-        ini.load(config);
-        factory = new IniFilterChainResolverFactory(ini);
-        FilterChainResolver resolver = factory.getInstance();
-        assertNotNull(resolver);
-    }
-
-    @Test
-    public void testGetFiltersWithNullOrEmptySection() {
-        Map<String, Filter> filters = factory.getFilters(null, null);
-        assertNull(filters);
-    }
-
-    @Test
-    public void testCreateChainsWithNullUrlsSection() {
-        //should do nothing (return immediately, no exceptions):
-        factory.createChains(null, null);
-    }
-
-    @Test
-    public void testNewInstanceWithNonFilter() {
-        Ini ini = new Ini();
-        String config =
-                "[filters]\n" +
-                        "test = org.apache.shiro.web.servlet.SimpleCookie\n" + //any non-Filter will do
-                        "[urls]\n" +
-                        "/index.html = anon";
-        ini.load(config);
-        factory = new IniFilterChainResolverFactory(ini);
-        factory.getInstance();
-    }
-
-    @Test
-    public void testNewInstanceWithFilterConfig() {
-        Ini ini = new Ini();
-        String text =
-                "[urls]\n" +
-                        "/index.html = anon";
-        ini.load(text);
-        factory = new IniFilterChainResolverFactory(ini);
-        FilterConfig config = createNiceMockFilterConfig();
-        factory.setFilterConfig(config);
-        replay(config);
-        FilterChainResolver resolver = factory.getInstance();
-        assertNotNull(resolver);
-        verify(config);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.config;
+
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.web.WebTest;
+import org.apache.shiro.web.filter.mgt.FilterChainResolver;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterConfig;
+import java.util.Map;
+
+import static org.easymock.EasyMock.replay;
+import static org.easymock.EasyMock.verify;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+/**
+ * Tests for the {@link IniFilterChainResolverFactory}.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class IniFilterChainResolverFactoryTest extends WebTest {
+
+    private IniFilterChainResolverFactory factory;
+
+    @Before
+    public void setUp() {
+        this.factory = new IniFilterChainResolverFactory();
+    }
+
+    @Test
+    public void testNewInstance() {
+        assertNull(factory.getFilterConfig());
+        factory.setFilterConfig(null);
+        assertNull(factory.getFilterConfig());
+    }
+
+    @Test
+    public void testGetInstanceNoIni() {
+        FilterChainResolver resolver = factory.getInstance();
+        assertNotNull(resolver);
+    }
+
+    @Test
+    public void testNewInstanceWithIni() {
+        Ini ini = new Ini();
+        String config =
+                "[urls]\n" +
+                        "/index.html = anon";
+        ini.load(config);
+        factory = new IniFilterChainResolverFactory(ini);
+        FilterChainResolver resolver = factory.getInstance();
+        assertNotNull(resolver);
+    }
+
+    @Test
+    public void testGetFiltersWithNullOrEmptySection() {
+        Map<String, Filter> filters = factory.getFilters(null, null);
+        assertNull(filters);
+    }
+
+    @Test
+    public void testCreateChainsWithNullUrlsSection() {
+        //should do nothing (return immediately, no exceptions):
+        factory.createChains(null, null);
+    }
+
+    @Test
+    public void testNewInstanceWithNonFilter() {
+        Ini ini = new Ini();
+        String config =
+                "[filters]\n" +
+                        "test = org.apache.shiro.web.servlet.SimpleCookie\n" + //any non-Filter will do
+                        "[urls]\n" +
+                        "/index.html = anon";
+        ini.load(config);
+        factory = new IniFilterChainResolverFactory(ini);
+        factory.getInstance();
+    }
+
+    @Test
+    public void testNewInstanceWithFilterConfig() {
+        Ini ini = new Ini();
+        String text =
+                "[urls]\n" +
+                        "/index.html = anon";
+        ini.load(text);
+        factory = new IniFilterChainResolverFactory(ini);
+        FilterConfig config = createNiceMockFilterConfig();
+        factory.setFilterConfig(config);
+        replay(config);
+        FilterChainResolver resolver = factory.getInstance();
+        assertNotNull(resolver);
+        verify(config);
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/authc/AnonymousFilterTest.java b/web/src/test/java/org/apache/shiro/web/filter/authc/AnonymousFilterTest.java
index 277116441..7507ea697 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/authc/AnonymousFilterTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/authc/AnonymousFilterTest.java
@@ -1,38 +1,38 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authc;
-
-import static org.junit.Assert.assertTrue;
-import org.junit.Test;
-
-/**
- * Test for {@link org.apache.shiro.web.filter.authc.AnonymousFilter}.
- *
- * @since 1.0
- */
-public class AnonymousFilterTest {
-
-    @Test
-    public void test() {
-        AnonymousFilter filter = new AnonymousFilter();
-        boolean allow = filter.onPreHandle(null, null, null);
-        assertTrue(allow);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authc;
+
+import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+
+/**
+ * Test for {@link org.apache.shiro.web.filter.authc.AnonymousFilter}.
+ *
+ * @since 1.0
+ */
+public class AnonymousFilterTest {
+
+    @Test
+    public void test() {
+        AnonymousFilter filter = new AnonymousFilter();
+        boolean allow = filter.onPreHandle(null, null, null);
+        assertTrue(allow);
+    }
+
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/authz/AuthorizationFilterTest.java b/web/src/test/java/org/apache/shiro/web/filter/authz/AuthorizationFilterTest.java
index af512a859..dba7cb530 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/authz/AuthorizationFilterTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/authz/AuthorizationFilterTest.java
@@ -1,99 +1,99 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authz;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.test.SecurityManagerTestSupport;
-import org.junit.Test;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-
-import static org.easymock.EasyMock.*;
-
-/**
- * Test cases for the {@link AuthorizationFilter} class.
- */
-public class AuthorizationFilterTest extends SecurityManagerTestSupport {
-
-    @Test
-    public void testUserOnAccessDeniedWithResponseError() throws IOException {
-        // Tests when a user (known identity) is denied access and no unauthorizedUrl has been configured.
-        // This should trigger an HTTP response error code.
-
-        //log in the user using the account provided by the superclass for tests:
-        SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));
-        
-        AuthorizationFilter filter = new AuthorizationFilter() {
-            @Override
-            protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
-                    throws Exception {
-                return false; //for this test case
-            }
-        };
-
-        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
-        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
-
-        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-        replay(response);
-        filter.onAccessDenied(request, response);
-        verify(response);
-    }
-
-    @Test
-    public void testUserOnAccessDeniedWithRedirect() throws IOException {
-        // Tests when a user (known identity) is denied access and an unauthorizedUrl *has* been configured.
-        // This should trigger an HTTP redirect
-
-        //log in the user using the account provided by the superclass for tests:
-        SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));
-
-        String unauthorizedUrl = "unauthorized.jsp";
-
-        AuthorizationFilter filter = new AuthorizationFilter() {
-            @Override
-            protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
-                    throws Exception {
-                return false; //for this test case
-            }
-        };
-        filter.setUnauthorizedUrl(unauthorizedUrl);
-
-        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
-        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
-
-        expect(request.getContextPath()).andReturn("/").anyTimes();
-
-        String encoded = "/" + unauthorizedUrl;
-        expect(response.encodeRedirectURL(unauthorizedUrl)).andReturn(encoded);
-        response.sendRedirect(encoded);
-        replay(request);
-        replay(response);
-
-        filter.onAccessDenied(request, response);
-
-        verify(request);
-        verify(response);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authz;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.test.SecurityManagerTestSupport;
+import org.junit.Test;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+import static org.easymock.EasyMock.*;
+
+/**
+ * Test cases for the {@link AuthorizationFilter} class.
+ */
+public class AuthorizationFilterTest extends SecurityManagerTestSupport {
+
+    @Test
+    public void testUserOnAccessDeniedWithResponseError() throws IOException {
+        // Tests when a user (known identity) is denied access and no unauthorizedUrl has been configured.
+        // This should trigger an HTTP response error code.
+
+        //log in the user using the account provided by the superclass for tests:
+        SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));
+        
+        AuthorizationFilter filter = new AuthorizationFilter() {
+            @Override
+            protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
+                    throws Exception {
+                return false; //for this test case
+            }
+        };
+
+        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
+        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
+
+        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
+        replay(response);
+        filter.onAccessDenied(request, response);
+        verify(response);
+    }
+
+    @Test
+    public void testUserOnAccessDeniedWithRedirect() throws IOException {
+        // Tests when a user (known identity) is denied access and an unauthorizedUrl *has* been configured.
+        // This should trigger an HTTP redirect
+
+        //log in the user using the account provided by the superclass for tests:
+        SecurityUtils.getSubject().login(new UsernamePasswordToken("test", "test"));
+
+        String unauthorizedUrl = "unauthorized.jsp";
+
+        AuthorizationFilter filter = new AuthorizationFilter() {
+            @Override
+            protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue)
+                    throws Exception {
+                return false; //for this test case
+            }
+        };
+        filter.setUnauthorizedUrl(unauthorizedUrl);
+
+        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
+        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
+
+        expect(request.getContextPath()).andReturn("/").anyTimes();
+
+        String encoded = "/" + unauthorizedUrl;
+        expect(response.encodeRedirectURL(unauthorizedUrl)).andReturn(encoded);
+        response.sendRedirect(encoded);
+        replay(request);
+        replay(response);
+
+        filter.onAccessDenied(request, response);
+
+        verify(request);
+        verify(response);
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/authz/HostFilterTest.java b/web/src/test/java/org/apache/shiro/web/filter/authz/HostFilterTest.java
index 859eea9af..8781590b7 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/authz/HostFilterTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/authz/HostFilterTest.java
@@ -1,81 +1,81 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authz;
-
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-import java.util.regex.Pattern;
-
-/** @since 1.0 */
-public class HostFilterTest {
-
-    @Test
-    public void testPrivateClassC() {
-        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_C_REGEX);
-
-        String base = "192.168.";
-
-        for (int i = 0; i < 256; i++) {
-            String ibase = base + i;
-            for (int j = 0; j < 256; j++) {
-                String ip = ibase + "." + j;
-                assertTrue(p.matcher(ip).matches());
-            }
-        }
-    }
-
-    @Test
-    public void testPrivateClassB() {
-        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_B_REGEX);
-
-        String base = "172.";
-
-        for (int i = 16; i < 32; i++) {
-            String ibase = base + i;
-            for (int j = 0; j < 256; j++) {
-                String jBase = ibase + "." + j;
-                for (int k = 0; k < 256; k++) {
-                    String ip = jBase + "." + k;
-                    assertTrue(p.matcher(ip).matches());
-                }
-            }
-        }
-    }
-
-    /* Takes a long time (20+ seconds?) - only enable when testing explicitly:
-    @Test
-    public void testPrivateClassA() {
-        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_A_REGEX);
-
-        String base = "10.";
-
-        for (int i = 0; i < 256; i++) {
-            String ibase = base + i;
-            for (int j = 0; j < 256; j++) {
-                String jBase = ibase + "." + j;
-                for (int k = 0; k < 256; k++) {
-                    String ip = jBase + "." + k;
-                    assertTrue(p.matcher(ip).matches());
-                }
-            }
-        }
-    } */
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authz;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import java.util.regex.Pattern;
+
+/** @since 1.0 */
+public class HostFilterTest {
+
+    @Test
+    public void testPrivateClassC() {
+        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_C_REGEX);
+
+        String base = "192.168.";
+
+        for (int i = 0; i < 256; i++) {
+            String ibase = base + i;
+            for (int j = 0; j < 256; j++) {
+                String ip = ibase + "." + j;
+                assertTrue(p.matcher(ip).matches());
+            }
+        }
+    }
+
+    @Test
+    public void testPrivateClassB() {
+        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_B_REGEX);
+
+        String base = "172.";
+
+        for (int i = 16; i < 32; i++) {
+            String ibase = base + i;
+            for (int j = 0; j < 256; j++) {
+                String jBase = ibase + "." + j;
+                for (int k = 0; k < 256; k++) {
+                    String ip = jBase + "." + k;
+                    assertTrue(p.matcher(ip).matches());
+                }
+            }
+        }
+    }
+
+    /* Takes a long time (20+ seconds?) - only enable when testing explicitly:
+    @Test
+    public void testPrivateClassA() {
+        Pattern p = Pattern.compile(HostFilter.PRIVATE_CLASS_A_REGEX);
+
+        String base = "10.";
+
+        for (int i = 0; i < 256; i++) {
+            String ibase = base + i;
+            for (int j = 0; j < 256; j++) {
+                String jBase = ibase + "." + j;
+                for (int k = 0; k < 256; k++) {
+                    String ip = jBase + "." + k;
+                    assertTrue(p.matcher(ip).matches());
+                }
+            }
+        }
+    } */
+
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilterTest.java b/web/src/test/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilterTest.java
index 2de2540eb..1737b1921 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilterTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilterTest.java
@@ -1,48 +1,48 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.authz;
-
-import junit.framework.Assert;
-import org.junit.Test;
-
-
-public class HttpMethodPermissionFilterTest {
-
-    @Test
-    public void testPermisisonMapping() {
-        // Testing the isAccessAllowed would be easier, but would need to mock out the servlet request
-
-        HttpMethodPermissionFilter filter = new HttpMethodPermissionFilter();
-
-        String[] permsBefore = {"foo", "bar"};
-
-        String[] permsAfter = filter.buildPermissions(permsBefore, filter.getHttpMethodAction("get"));
-        Assert.assertEquals(2, permsAfter.length);
-        Assert.assertEquals("foo:read", permsAfter[0]);
-        Assert.assertEquals("bar:read", permsAfter[1]);
-
-        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("head"))[0]);
-        Assert.assertEquals("foo:update", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("put"))[0]);
-        Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("post"))[0]);
-        Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("mkcol"))[0]);
-        Assert.assertEquals("foo:delete", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("delete"))[0]);
-        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("options"))[0]);
-        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("trace"))[0]);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.authz;
+
+import junit.framework.Assert;
+import org.junit.Test;
+
+
+public class HttpMethodPermissionFilterTest {
+
+    @Test
+    public void testPermisisonMapping() {
+        // Testing the isAccessAllowed would be easier, but would need to mock out the servlet request
+
+        HttpMethodPermissionFilter filter = new HttpMethodPermissionFilter();
+
+        String[] permsBefore = {"foo", "bar"};
+
+        String[] permsAfter = filter.buildPermissions(permsBefore, filter.getHttpMethodAction("get"));
+        Assert.assertEquals(2, permsAfter.length);
+        Assert.assertEquals("foo:read", permsAfter[0]);
+        Assert.assertEquals("bar:read", permsAfter[1]);
+
+        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("head"))[0]);
+        Assert.assertEquals("foo:update", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("put"))[0]);
+        Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("post"))[0]);
+        Assert.assertEquals("foo:create", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("mkcol"))[0]);
+        Assert.assertEquals("foo:delete", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("delete"))[0]);
+        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("options"))[0]);
+        Assert.assertEquals("foo:read", filter.buildPermissions(permsBefore, filter.getHttpMethodAction("trace"))[0]);
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManagerTest.java b/web/src/test/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManagerTest.java
index a4df58b9f..cdf8e2b54 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManagerTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/mgt/DefaultFilterChainManagerTest.java
@@ -1,214 +1,214 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.config.ConfigurationException;
-import org.apache.shiro.web.filter.authz.SslFilter;
-import org.apache.shiro.web.servlet.IniShiroFilter;
-import org.junit.Before;
-import org.junit.Test;
-
-import javax.servlet.*;
-import java.util.Map;
-import java.util.Set;
-
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
-/**
- * Test case for the {@link DefaultFilterChainManager} implementation.
- *
- * @since 1.0
- */
-public class DefaultFilterChainManagerTest {
-
-    DefaultFilterChainManager manager;
-
-    @Before
-    public void setUp() {
-        this.manager = new DefaultFilterChainManager();
-    }
-
-    @Test
-    public void testNewInstanceDefaultFilters() {
-        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
-            assertNotNull(manager.getFilter(defaultFilter.name()));
-        }
-        assertFalse(manager.hasChains());
-    }
-
-    protected FilterConfig createNiceMockFilterConfig() {
-        FilterConfig mock = createNiceMock(FilterConfig.class);
-        ServletContext mockServletContext = createNiceMock(ServletContext.class);
-        expect(mock.getServletContext()).andReturn(mockServletContext);
-        return mock;
-    }
-
-    @Test
-    public void testNewInstanceWithFilterConfig() {
-        FilterConfig mock = createNiceMockFilterConfig();
-        replay(mock);
-        this.manager = new DefaultFilterChainManager(mock);
-        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
-            assertNotNull(manager.getFilter(defaultFilter.name()));
-        }
-        assertFalse(manager.hasChains());
-        verify(mock);
-    }
-
-    @Test
-    public void testCreateChain() {
-        try {
-            manager.createChain(null, null);
-        } catch (NullPointerException expected) {
-        }
-        try {
-            manager.createChain("test", null);
-        } catch (NullPointerException expected) {
-        }
-
-        manager.createChain("test", "authc, roles[manager], perms[\"user:read,write:12345\"");
-
-        assertTrue(manager.hasChains());
-
-        Set<String> chainNames = manager.getChainNames();
-        assertNotNull(chainNames);
-        assertEquals(1, chainNames.size());
-        assertTrue(chainNames.contains("test"));
-
-        Map<String, NamedFilterList> chains = manager.getFilterChains();
-        assertEquals(1, chains.size());
-        assertTrue(chains.containsKey("test"));
-        manager.setFilterChains(chains);
-
-        NamedFilterList chain = manager.getChain("test");
-        assertNotNull(chain);
-
-        Filter filter = chain.get(0);
-        assertNotNull(filter);
-        assertEquals(DefaultFilter.authc.getFilterClass(), filter.getClass());
-
-        filter = chain.get(1);
-        assertNotNull(filter);
-        assertEquals(DefaultFilter.roles.getFilterClass(), filter.getClass());
-
-        filter = chain.get(2);
-        assertNotNull(filter);
-        assertEquals(DefaultFilter.perms.getFilterClass(), filter.getClass());
-    }
-
-    @Test
-    public void testBeanMethods() {
-        Map<String, Filter> filters = manager.getFilters();
-        assertEquals(filters.size(), DefaultFilter.values().length);
-        manager.setFilters(filters);
-    }
-
-    @Test
-    public void testAddFilter() {
-        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
-        replay(mockFilterConfig);
-        this.manager = new DefaultFilterChainManager(mockFilterConfig);
-        manager.addFilter("test", new SslFilter());
-        Filter filter = manager.getFilter("test");
-        assertNotNull(filter);
-        assertEquals(SslFilter.class, filter.getClass());
-        verify(mockFilterConfig);
-    }
-
-    @Test(expected = ConfigurationException.class)
-    public void testAddFilterInitThrowsException() {
-        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
-        Filter mockFilter = createNiceMock(Filter.class);
-
-        try {
-            mockFilter.init(isA(FilterConfig.class));
-        } catch (ServletException e) {
-            fail("test setup failure.");
-        }
-        //noinspection ThrowableInstanceNeverThrown
-        expectLastCall().andThrow(new ServletException());
-
-        replay(mockFilterConfig);
-        replay(mockFilter);
-
-        this.manager = new DefaultFilterChainManager(mockFilterConfig);
-
-        this.manager.addFilter("blah", mockFilter);
-
-        verify(mockFilterConfig);
-        verify(mockFilter);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testAddFilterNoFilterConfig() {
-        manager.addFilter("test", new SslFilter());
-    }
-
-    @Test
-    public void testAddToChain() {
-        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
-        replay(mockFilterConfig);
-        this.manager = new DefaultFilterChainManager(mockFilterConfig);
-
-        manager.addFilter("testSsl", new SslFilter());
-        manager.createChain("test", "anon");
-
-        try {
-            manager.addToChain("test", null);
-        } catch (IllegalArgumentException expected) {
-        }
-        try {
-            manager.addToChain(null, "testSsl");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    @Test
-    public void testAddToChainNotPathProcessor() {
-        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
-        replay(mockFilterConfig);
-        this.manager = new DefaultFilterChainManager(mockFilterConfig);
-
-        manager.addFilter("nonPathProcessor", new IniShiroFilter());
-        manager.createChain("test", "nonPathProcessor");
-
-        try {
-            manager.addToChain("test", "nonPathProcessor", "dummyConfig");
-        } catch (ConfigurationException expected) {
-        }
-    }
-
-    @Test
-    public void testProxy() {
-        FilterChain mock = createNiceMock(FilterChain.class);
-        replay(mock);
-        manager.createChain("test", "anon");
-        this.manager.proxy(mock, "test");
-        verify(mock);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testProxyNoChain() {
-        FilterChain mock = createNiceMock(FilterChain.class);
-        replay(mock);
-        this.manager.proxy(mock, "blah");
-        verify(mock);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.config.ConfigurationException;
+import org.apache.shiro.web.filter.authz.SslFilter;
+import org.apache.shiro.web.servlet.IniShiroFilter;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.servlet.*;
+import java.util.Map;
+import java.util.Set;
+
+import static org.easymock.EasyMock.*;
+import static org.junit.Assert.*;
+
+/**
+ * Test case for the {@link DefaultFilterChainManager} implementation.
+ *
+ * @since 1.0
+ */
+public class DefaultFilterChainManagerTest {
+
+    DefaultFilterChainManager manager;
+
+    @Before
+    public void setUp() {
+        this.manager = new DefaultFilterChainManager();
+    }
+
+    @Test
+    public void testNewInstanceDefaultFilters() {
+        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
+            assertNotNull(manager.getFilter(defaultFilter.name()));
+        }
+        assertFalse(manager.hasChains());
+    }
+
+    protected FilterConfig createNiceMockFilterConfig() {
+        FilterConfig mock = createNiceMock(FilterConfig.class);
+        ServletContext mockServletContext = createNiceMock(ServletContext.class);
+        expect(mock.getServletContext()).andReturn(mockServletContext);
+        return mock;
+    }
+
+    @Test
+    public void testNewInstanceWithFilterConfig() {
+        FilterConfig mock = createNiceMockFilterConfig();
+        replay(mock);
+        this.manager = new DefaultFilterChainManager(mock);
+        for (DefaultFilter defaultFilter : DefaultFilter.values()) {
+            assertNotNull(manager.getFilter(defaultFilter.name()));
+        }
+        assertFalse(manager.hasChains());
+        verify(mock);
+    }
+
+    @Test
+    public void testCreateChain() {
+        try {
+            manager.createChain(null, null);
+        } catch (NullPointerException expected) {
+        }
+        try {
+            manager.createChain("test", null);
+        } catch (NullPointerException expected) {
+        }
+
+        manager.createChain("test", "authc, roles[manager], perms[\"user:read,write:12345\"");
+
+        assertTrue(manager.hasChains());
+
+        Set<String> chainNames = manager.getChainNames();
+        assertNotNull(chainNames);
+        assertEquals(1, chainNames.size());
+        assertTrue(chainNames.contains("test"));
+
+        Map<String, NamedFilterList> chains = manager.getFilterChains();
+        assertEquals(1, chains.size());
+        assertTrue(chains.containsKey("test"));
+        manager.setFilterChains(chains);
+
+        NamedFilterList chain = manager.getChain("test");
+        assertNotNull(chain);
+
+        Filter filter = chain.get(0);
+        assertNotNull(filter);
+        assertEquals(DefaultFilter.authc.getFilterClass(), filter.getClass());
+
+        filter = chain.get(1);
+        assertNotNull(filter);
+        assertEquals(DefaultFilter.roles.getFilterClass(), filter.getClass());
+
+        filter = chain.get(2);
+        assertNotNull(filter);
+        assertEquals(DefaultFilter.perms.getFilterClass(), filter.getClass());
+    }
+
+    @Test
+    public void testBeanMethods() {
+        Map<String, Filter> filters = manager.getFilters();
+        assertEquals(filters.size(), DefaultFilter.values().length);
+        manager.setFilters(filters);
+    }
+
+    @Test
+    public void testAddFilter() {
+        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
+        replay(mockFilterConfig);
+        this.manager = new DefaultFilterChainManager(mockFilterConfig);
+        manager.addFilter("test", new SslFilter());
+        Filter filter = manager.getFilter("test");
+        assertNotNull(filter);
+        assertEquals(SslFilter.class, filter.getClass());
+        verify(mockFilterConfig);
+    }
+
+    @Test(expected = ConfigurationException.class)
+    public void testAddFilterInitThrowsException() {
+        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
+        Filter mockFilter = createNiceMock(Filter.class);
+
+        try {
+            mockFilter.init(isA(FilterConfig.class));
+        } catch (ServletException e) {
+            fail("test setup failure.");
+        }
+        //noinspection ThrowableInstanceNeverThrown
+        expectLastCall().andThrow(new ServletException());
+
+        replay(mockFilterConfig);
+        replay(mockFilter);
+
+        this.manager = new DefaultFilterChainManager(mockFilterConfig);
+
+        this.manager.addFilter("blah", mockFilter);
+
+        verify(mockFilterConfig);
+        verify(mockFilter);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testAddFilterNoFilterConfig() {
+        manager.addFilter("test", new SslFilter());
+    }
+
+    @Test
+    public void testAddToChain() {
+        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
+        replay(mockFilterConfig);
+        this.manager = new DefaultFilterChainManager(mockFilterConfig);
+
+        manager.addFilter("testSsl", new SslFilter());
+        manager.createChain("test", "anon");
+
+        try {
+            manager.addToChain("test", null);
+        } catch (IllegalArgumentException expected) {
+        }
+        try {
+            manager.addToChain(null, "testSsl");
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void testAddToChainNotPathProcessor() {
+        FilterConfig mockFilterConfig = createNiceMockFilterConfig();
+        replay(mockFilterConfig);
+        this.manager = new DefaultFilterChainManager(mockFilterConfig);
+
+        manager.addFilter("nonPathProcessor", new IniShiroFilter());
+        manager.createChain("test", "nonPathProcessor");
+
+        try {
+            manager.addToChain("test", "nonPathProcessor", "dummyConfig");
+        } catch (ConfigurationException expected) {
+        }
+    }
+
+    @Test
+    public void testProxy() {
+        FilterChain mock = createNiceMock(FilterChain.class);
+        replay(mock);
+        manager.createChain("test", "anon");
+        this.manager.proxy(mock, "test");
+        verify(mock);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testProxyNoChain() {
+        FilterChain mock = createNiceMock(FilterChain.class);
+        replay(mock);
+        this.manager.proxy(mock, "blah");
+        verify(mock);
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolverTest.java b/web/src/test/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolverTest.java
index 9ac451615..70f874e95 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolverTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/mgt/PathMatchingFilterChainResolverTest.java
@@ -1,128 +1,128 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.util.AntPathMatcher;
-import org.apache.shiro.web.WebTest;
-import org.apache.shiro.web.util.WebUtils;
-import org.junit.Before;
-import org.junit.Test;
-
-import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
-/**
- * Tests for {@link org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver}.
- *
- * @since 1.0
- */
-public class PathMatchingFilterChainResolverTest extends WebTest {
-
-    private PathMatchingFilterChainResolver resolver;
-
-    @Before
-    public void setUp() {
-        resolver = new PathMatchingFilterChainResolver();
-    }
-
-    @Test
-    public void testNewInstance() {
-        assertNotNull(resolver.getPathMatcher());
-        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
-        assertNotNull(resolver.getFilterChainManager());
-        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
-    }
-
-    @Test
-    public void testNewInstanceWithFilterConfig() {
-        FilterConfig mock = createNiceMockFilterConfig();
-        replay(mock);
-        resolver = new PathMatchingFilterChainResolver(mock);
-        assertNotNull(resolver.getPathMatcher());
-        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
-        assertNotNull(resolver.getFilterChainManager());
-        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
-        assertEquals(((DefaultFilterChainManager) resolver.getFilterChainManager()).getFilterConfig(), mock);
-        verify(mock);
-    }
-
-    @Test
-    public void testSetters() {
-        resolver.setPathMatcher(new AntPathMatcher());
-        assertNotNull(resolver.getPathMatcher());
-        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
-        resolver.setFilterChainManager(new DefaultFilterChainManager());
-        assertNotNull(resolver.getFilterChainManager());
-        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
-    }
-
-    @Test
-    public void testGetChainsWithoutChains() {
-        ServletRequest request = createNiceMock(HttpServletRequest.class);
-        ServletResponse response = createNiceMock(HttpServletResponse.class);
-        FilterChain chain = createNiceMock(FilterChain.class);
-        FilterChain resolved = resolver.getChain(request, response, chain);
-        assertNull(resolved);
-    }
-
-    @Test
-    public void testGetChainsWithMatch() {
-        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
-        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
-        FilterChain chain = createNiceMock(FilterChain.class);
-
-        //ensure at least one chain is defined:
-        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");
-
-        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();
-        expect(request.getContextPath()).andReturn("");
-        expect(request.getRequestURI()).andReturn("/index.html");
-        replay(request);
-
-        FilterChain resolved = resolver.getChain(request, response, chain);
-        assertNotNull(resolved);
-        verify(request);
-    }
-
-    @Test
-    public void testGetChainsWithoutMatch() {
-        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
-        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
-        FilterChain chain = createNiceMock(FilterChain.class);
-
-        //ensure at least one chain is defined:
-        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");
-
-        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();
-        expect(request.getContextPath()).andReturn("");
-        expect(request.getRequestURI()).andReturn("/");
-        replay(request);
-
-        FilterChain resolved = resolver.getChain(request, response, chain);
-        assertNull(resolved);
-        verify(request);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.util.AntPathMatcher;
+import org.apache.shiro.web.WebTest;
+import org.apache.shiro.web.util.WebUtils;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import static org.easymock.EasyMock.*;
+import static org.junit.Assert.*;
+
+/**
+ * Tests for {@link org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver}.
+ *
+ * @since 1.0
+ */
+public class PathMatchingFilterChainResolverTest extends WebTest {
+
+    private PathMatchingFilterChainResolver resolver;
+
+    @Before
+    public void setUp() {
+        resolver = new PathMatchingFilterChainResolver();
+    }
+
+    @Test
+    public void testNewInstance() {
+        assertNotNull(resolver.getPathMatcher());
+        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
+        assertNotNull(resolver.getFilterChainManager());
+        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
+    }
+
+    @Test
+    public void testNewInstanceWithFilterConfig() {
+        FilterConfig mock = createNiceMockFilterConfig();
+        replay(mock);
+        resolver = new PathMatchingFilterChainResolver(mock);
+        assertNotNull(resolver.getPathMatcher());
+        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
+        assertNotNull(resolver.getFilterChainManager());
+        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
+        assertEquals(((DefaultFilterChainManager) resolver.getFilterChainManager()).getFilterConfig(), mock);
+        verify(mock);
+    }
+
+    @Test
+    public void testSetters() {
+        resolver.setPathMatcher(new AntPathMatcher());
+        assertNotNull(resolver.getPathMatcher());
+        assertTrue(resolver.getPathMatcher() instanceof AntPathMatcher);
+        resolver.setFilterChainManager(new DefaultFilterChainManager());
+        assertNotNull(resolver.getFilterChainManager());
+        assertTrue(resolver.getFilterChainManager() instanceof DefaultFilterChainManager);
+    }
+
+    @Test
+    public void testGetChainsWithoutChains() {
+        ServletRequest request = createNiceMock(HttpServletRequest.class);
+        ServletResponse response = createNiceMock(HttpServletResponse.class);
+        FilterChain chain = createNiceMock(FilterChain.class);
+        FilterChain resolved = resolver.getChain(request, response, chain);
+        assertNull(resolved);
+    }
+
+    @Test
+    public void testGetChainsWithMatch() {
+        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
+        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
+        FilterChain chain = createNiceMock(FilterChain.class);
+
+        //ensure at least one chain is defined:
+        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");
+
+        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();
+        expect(request.getContextPath()).andReturn("");
+        expect(request.getRequestURI()).andReturn("/index.html");
+        replay(request);
+
+        FilterChain resolved = resolver.getChain(request, response, chain);
+        assertNotNull(resolved);
+        verify(request);
+    }
+
+    @Test
+    public void testGetChainsWithoutMatch() {
+        HttpServletRequest request = createNiceMock(HttpServletRequest.class);
+        HttpServletResponse response = createNiceMock(HttpServletResponse.class);
+        FilterChain chain = createNiceMock(FilterChain.class);
+
+        //ensure at least one chain is defined:
+        resolver.getFilterChainManager().addToChain("/index.html", "authcBasic");
+
+        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();
+        expect(request.getContextPath()).andReturn("");
+        expect(request.getRequestURI()).andReturn("/");
+        replay(request);
+
+        FilterChain resolved = resolver.getChain(request, response, chain);
+        assertNull(resolved);
+        verify(request);
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterListTest.java b/web/src/test/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterListTest.java
index 450e15e7e..a62e13204 100644
--- a/web/src/test/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterListTest.java
+++ b/web/src/test/java/org/apache/shiro/web/filter/mgt/SimpleNamedFilterListTest.java
@@ -1,154 +1,154 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.filter.mgt;
-
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.web.filter.authc.UserFilter;
-import org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;
-import org.apache.shiro.web.filter.authz.PortFilter;
-import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;
-import org.apache.shiro.web.filter.authz.SslFilter;
-import org.junit.Test;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import java.util.*;
-
-import static org.easymock.EasyMock.createNiceMock;
-import static org.junit.Assert.*;
-
-/**
- * Test case for the {@link SimpleNamedFilterList} implementation.
- *
- * @since 1.0
- */
-public class SimpleNamedFilterListTest {
-
-    @Test
-    public void testNewInstance() {
-        @SuppressWarnings({"MismatchedQueryAndUpdateOfCollection"})
-        SimpleNamedFilterList list = new SimpleNamedFilterList("test");
-        assertNotNull(list.getName());
-        assertEquals("test", list.getName());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testNewInstanceNameless() {
-        new SimpleNamedFilterList(null);
-    }
-
-    @Test
-    public void testNewInstanceBackingList() {
-        new SimpleNamedFilterList("test", new ArrayList<Filter>());
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testNewInstanceNullBackingList() {
-        new SimpleNamedFilterList("test", null);
-    }
-
-    /**
-     * Exists mainly to increase code coverage as the SimpleNamedFilterList
-     * implementation is a direct pass through.
-     */
-    @Test
-    public void testListMethods() {
-        FilterChain mock = createNiceMock(FilterChain.class);
-        Filter filter = createNiceMock(Filter.class);
-
-        NamedFilterList list = new SimpleNamedFilterList("test");
-        list.add(filter);
-        FilterChain chain = list.proxy(mock);
-        assertNotNull(chain);
-        assertNotSame(mock, chain);
-
-        Filter singleFilter = new SslFilter();
-        List<? extends Filter> multipleFilters = CollectionUtils.asList(new PortFilter(), new UserFilter());
-
-        list.add(0, singleFilter);
-        assertEquals(2, list.size());
-        assertTrue(list.get(0) instanceof SslFilter);
-        assertTrue(Arrays.equals(list.toArray(), new Object[]{singleFilter, filter}));
-
-        list.addAll(multipleFilters);
-        assertEquals(4, list.size());
-        assertTrue(list.get(2) instanceof PortFilter);
-        assertTrue(list.get(3) instanceof UserFilter);
-
-        list.addAll(0, CollectionUtils.asList(new PermissionsAuthorizationFilter(), new RolesAuthorizationFilter()));
-        assertEquals(6, list.size());
-        assertTrue(list.get(0) instanceof PermissionsAuthorizationFilter);
-        assertTrue(list.get(1) instanceof RolesAuthorizationFilter);
-        assertEquals(2, list.indexOf(singleFilter));
-        assertEquals(multipleFilters, list.subList(4, list.size()));
-
-        assertTrue(list.contains(singleFilter));
-        assertTrue(list.containsAll(multipleFilters));
-
-        assertFalse(list.isEmpty());
-        list.clear();
-        assertTrue(list.isEmpty());
-
-        list.add(singleFilter);
-        Iterator i = list.iterator();
-        assertTrue(i.hasNext());
-        assertEquals(i.next(), singleFilter);
-
-        ListIterator li = list.listIterator();
-        assertTrue(li.hasNext());
-        assertEquals(li.next(), singleFilter);
-
-        li = list.listIterator(0);
-        assertTrue(li.hasNext());
-        assertEquals(li.next(), singleFilter);
-
-        list.set(0, singleFilter);
-        assertEquals(list.get(0), singleFilter);
-
-        Filter[] filters = new Filter[list.size()];
-        filters = list.toArray(filters);
-        assertEquals(1, filters.length);
-        assertEquals(filters[0], singleFilter);
-
-        assertEquals(0, list.lastIndexOf(singleFilter));
-
-        list.remove(singleFilter);
-        assertTrue(list.isEmpty());
-
-        list.add(singleFilter);
-        list.remove(0);
-        assertTrue(list.isEmpty());
-
-        list.add(singleFilter);
-        list.addAll(multipleFilters);
-        assertEquals(3, list.size());
-        list.removeAll(multipleFilters);
-        assertEquals(1, list.size());
-        assertEquals(list.get(0), singleFilter);
-
-        list.addAll(multipleFilters);
-        assertEquals(3, list.size());
-        list.retainAll(multipleFilters);
-        assertEquals(2, list.size());
-        //noinspection unchecked
-        assertEquals(new ArrayList(list), multipleFilters);
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.mgt;
+
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.web.filter.authc.UserFilter;
+import org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;
+import org.apache.shiro.web.filter.authz.PortFilter;
+import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;
+import org.apache.shiro.web.filter.authz.SslFilter;
+import org.junit.Test;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import java.util.*;
+
+import static org.easymock.EasyMock.createNiceMock;
+import static org.junit.Assert.*;
+
+/**
+ * Test case for the {@link SimpleNamedFilterList} implementation.
+ *
+ * @since 1.0
+ */
+public class SimpleNamedFilterListTest {
+
+    @Test
+    public void testNewInstance() {
+        @SuppressWarnings({"MismatchedQueryAndUpdateOfCollection"})
+        SimpleNamedFilterList list = new SimpleNamedFilterList("test");
+        assertNotNull(list.getName());
+        assertEquals("test", list.getName());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testNewInstanceNameless() {
+        new SimpleNamedFilterList(null);
+    }
+
+    @Test
+    public void testNewInstanceBackingList() {
+        new SimpleNamedFilterList("test", new ArrayList<Filter>());
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testNewInstanceNullBackingList() {
+        new SimpleNamedFilterList("test", null);
+    }
+
+    /**
+     * Exists mainly to increase code coverage as the SimpleNamedFilterList
+     * implementation is a direct pass through.
+     */
+    @Test
+    public void testListMethods() {
+        FilterChain mock = createNiceMock(FilterChain.class);
+        Filter filter = createNiceMock(Filter.class);
+
+        NamedFilterList list = new SimpleNamedFilterList("test");
+        list.add(filter);
+        FilterChain chain = list.proxy(mock);
+        assertNotNull(chain);
+        assertNotSame(mock, chain);
+
+        Filter singleFilter = new SslFilter();
+        List<? extends Filter> multipleFilters = CollectionUtils.asList(new PortFilter(), new UserFilter());
+
+        list.add(0, singleFilter);
+        assertEquals(2, list.size());
+        assertTrue(list.get(0) instanceof SslFilter);
+        assertTrue(Arrays.equals(list.toArray(), new Object[]{singleFilter, filter}));
+
+        list.addAll(multipleFilters);
+        assertEquals(4, list.size());
+        assertTrue(list.get(2) instanceof PortFilter);
+        assertTrue(list.get(3) instanceof UserFilter);
+
+        list.addAll(0, CollectionUtils.asList(new PermissionsAuthorizationFilter(), new RolesAuthorizationFilter()));
+        assertEquals(6, list.size());
+        assertTrue(list.get(0) instanceof PermissionsAuthorizationFilter);
+        assertTrue(list.get(1) instanceof RolesAuthorizationFilter);
+        assertEquals(2, list.indexOf(singleFilter));
+        assertEquals(multipleFilters, list.subList(4, list.size()));
+
+        assertTrue(list.contains(singleFilter));
+        assertTrue(list.containsAll(multipleFilters));
+
+        assertFalse(list.isEmpty());
+        list.clear();
+        assertTrue(list.isEmpty());
+
+        list.add(singleFilter);
+        Iterator i = list.iterator();
+        assertTrue(i.hasNext());
+        assertEquals(i.next(), singleFilter);
+
+        ListIterator li = list.listIterator();
+        assertTrue(li.hasNext());
+        assertEquals(li.next(), singleFilter);
+
+        li = list.listIterator(0);
+        assertTrue(li.hasNext());
+        assertEquals(li.next(), singleFilter);
+
+        list.set(0, singleFilter);
+        assertEquals(list.get(0), singleFilter);
+
+        Filter[] filters = new Filter[list.size()];
+        filters = list.toArray(filters);
+        assertEquals(1, filters.length);
+        assertEquals(filters[0], singleFilter);
+
+        assertEquals(0, list.lastIndexOf(singleFilter));
+
+        list.remove(singleFilter);
+        assertTrue(list.isEmpty());
+
+        list.add(singleFilter);
+        list.remove(0);
+        assertTrue(list.isEmpty());
+
+        list.add(singleFilter);
+        list.addAll(multipleFilters);
+        assertEquals(3, list.size());
+        list.removeAll(multipleFilters);
+        assertEquals(1, list.size());
+        assertEquals(list.get(0), singleFilter);
+
+        list.addAll(multipleFilters);
+        assertEquals(3, list.size());
+        list.retainAll(multipleFilters);
+        assertEquals(2, list.size());
+        //noinspection unchecked
+        assertEquals(new ArrayList(list), multipleFilters);
+    }
+
+
+}
diff --git a/web/src/test/java/org/apache/shiro/web/mgt/AbstractWebSecurityManagerTest.java b/web/src/test/java/org/apache/shiro/web/mgt/AbstractWebSecurityManagerTest.java
index 7d5f56abb..8d08041d4 100644
--- a/web/src/test/java/org/apache/shiro/web/mgt/AbstractWebSecurityManagerTest.java
+++ b/web/src/test/java/org/apache/shiro/web/mgt/AbstractWebSecurityManagerTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.mgt;
-
-import org.apache.shiro.util.ThreadContext;
-import org.junit.After;
-
-/**
- * @since 1.0
- */
-public abstract class AbstractWebSecurityManagerTest {
-
-    @After
-    public void tearDown() {
-        ThreadContext.remove();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.mgt;
+
+import org.apache.shiro.util.ThreadContext;
+import org.junit.After;
+
+/**
+ * @since 1.0
+ */
+public abstract class AbstractWebSecurityManagerTest {
+
+    @After
+    public void tearDown() {
+        ThreadContext.remove();
+    }
+}
diff --git a/web/src/test/resources/IniShiroFilterTest.ini b/web/src/test/resources/IniShiroFilterTest.ini
index 4f6813404..b95945dd7 100644
--- a/web/src/test/resources/IniShiroFilterTest.ini
+++ b/web/src/test/resources/IniShiroFilterTest.ini
@@ -1,21 +1,21 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-[filters]
-authc.successUrl = /index.jsp
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+[filters]
+authc.successUrl = /index.jsp
+
diff --git a/web/src/test/resources/log4j.properties b/web/src/test/resources/log4j.properties
index 82c10bb4d..0462fd896 100644
--- a/web/src/test/resources/log4j.properties
+++ b/web/src/test/resources/log4j.properties
@@ -1,38 +1,38 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-log4j.rootLogger=TRACE, stdout
-
-log4j.appender.stdout=org.apache.log4j.ConsoleAppender
-log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
-log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n
-
-# Pattern to output: date priority [category] - message
-log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
-log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n
-
-# Spring logging level is WARN
-log4j.logger.org.springframework=WARN
-
-# General Apache libraries is WARN
-log4j.logger.org.apache=WARN
-
-log4j.logger.net.sf.ehcache=WARN
-
-log4j.logger.org.apache.shiro=TRACE
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+log4j.rootLogger=TRACE, stdout
+
+log4j.appender.stdout=org.apache.log4j.ConsoleAppender
+log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
+log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n
+
+# Pattern to output: date priority [category] - message
+log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
+log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n
+
+# Spring logging level is WARN
+log4j.logger.org.springframework=WARN
+
+# General Apache libraries is WARN
+log4j.logger.org.apache=WARN
+
+log4j.logger.net.sf.ehcache=WARN
+
+log4j.logger.org.apache.shiro=TRACE
 log4j.logger.org.apache.shiro.util.ThreadContext=WARN
\ No newline at end of file
