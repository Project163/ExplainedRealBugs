diff --git a/web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java b/web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java
index 05e1c5d51..0b02ad381 100644
--- a/web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java
+++ b/web/src/main/java/org/apache/shiro/web/DefaultWebSecurityManager.java
@@ -20,17 +20,19 @@ package org.apache.shiro.web;
 
 import org.apache.shiro.mgt.DefaultSecurityManager;
 import org.apache.shiro.realm.Realm;
-import org.apache.shiro.session.InvalidSessionException;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.mgt.DelegatingSession;
 import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.session.mgt.SessionKey;
+import org.apache.shiro.session.mgt.SessionManager;
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.subject.SubjectContext;
 import org.apache.shiro.util.LifecycleUtils;
 import org.apache.shiro.web.mgt.CookieRememberMeManager;
 import org.apache.shiro.web.mgt.DefaultWebSubjectFactory;
 import org.apache.shiro.web.servlet.ShiroHttpServletRequest;
-import org.apache.shiro.web.session.*;
+import org.apache.shiro.web.session.DefaultWebSessionContext;
+import org.apache.shiro.web.session.DefaultWebSessionManager;
+import org.apache.shiro.web.session.ServletContainerSessionManager;
+import org.apache.shiro.web.session.WebSessionKey;
 import org.apache.shiro.web.subject.WebSubject;
 import org.apache.shiro.web.subject.WebSubjectContext;
 import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
@@ -116,7 +118,7 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
         this.sessionMode = mode;
         if (recreate) {
             LifecycleUtils.destroy(getSessionManager());
-            WebSessionManager sessionManager = createSessionManager(mode);
+            SessionManager sessionManager = createSessionManager(mode);
             setSessionManager(sessionManager);
         }
     }
@@ -128,7 +130,7 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
         return this.sessionMode == null || this.sessionMode.equals(HTTP_SESSION_MODE);
     }
 
-    protected WebSessionManager createSessionManager(String sessionMode) {
+    protected SessionManager createSessionManager(String sessionMode) {
         if (sessionMode == null || sessionMode.equalsIgnoreCase(HTTP_SESSION_MODE)) {
             if (log.isInfoEnabled()) {
                 log.info(HTTP_SESSION_MODE + " mode - enabling ServletContainerSessionManager (HTTP-only Sessions)");
@@ -142,43 +144,6 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
         }
     }
 
-    @Override
-    protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException {
-        Session session = null;
-        if (context instanceof WebSubjectContext) {
-            WebSubjectContext wsc = (WebSubjectContext) context;
-            ServletRequest request = wsc.resolveServletRequest();
-            ServletResponse response = wsc.resolveServletResponse();
-            if (request != null && response != null) {
-                session = ((WebSessionManager) getSessionManager()).getSession(request, response);
-            }
-        } else {
-            session = super.resolveContextSession(context);
-        }
-
-        if (session != null && !isHttpSessionMode()) {
-            //don't expose the EIS-tier session instance to the SubjectFactory
-            session = new DelegatingSession(this, session.getId());
-        }
-
-        return session;
-    }
-
-    @Override
-    protected Serializable getSessionId(SubjectContext subjectContext) {
-        Serializable sessionId = super.getSessionId(subjectContext);
-        if (sessionId == null && subjectContext instanceof WebSubjectContext) {
-            WebSubjectContext wsc = (WebSubjectContext) subjectContext;
-            ServletRequest request = wsc.resolveServletRequest();
-            ServletResponse response = wsc.resolveServletResponse();
-            if (request != null && response != null) {
-                sessionId = ((WebSessionManager) getSessionManager()).getSessionId(request, response);
-            }
-        }
-
-        return sessionId;
-    }
-
     @Override
     protected SessionContext createSessionContext(SubjectContext subjectContext) {
         SessionContext sessionContext = super.createSessionContext(subjectContext);
@@ -186,18 +151,32 @@ public class DefaultWebSecurityManager extends DefaultSecurityManager implements
             WebSubjectContext wsc = (WebSubjectContext) subjectContext;
             ServletRequest request = wsc.resolveServletRequest();
             ServletResponse response = wsc.resolveServletResponse();
-            WebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);
+            DefaultWebSessionContext webSessionContext = new DefaultWebSessionContext(sessionContext);
             if (request != null) {
                 webSessionContext.setServletRequest(request);
             }
             if (response != null) {
                 webSessionContext.setServletResponse(response);
             }
+
             sessionContext = webSessionContext;
         }
         return sessionContext;
     }
 
+    @Override
+    protected SessionKey getSessionKey(SubjectContext context) {
+        if (WebUtils.isWeb(context)) {
+            Serializable sessionId = context.getSessionId();
+            ServletRequest request = WebUtils.getRequest(context);
+            ServletResponse response = WebUtils.getResponse(context);
+            return new WebSessionKey(sessionId, request, response);
+        } else {
+            return super.getSessionKey(context);
+
+        }
+    }
+
     @Override
     protected void beforeLogout(Subject subject) {
         super.beforeLogout(subject);
diff --git a/web/src/main/java/org/apache/shiro/web/DelegatingWebSecurityManager.java b/web/src/main/java/org/apache/shiro/web/DelegatingWebSecurityManager.java
deleted file mode 100644
index 42d9cb55d..000000000
--- a/web/src/main/java/org/apache/shiro/web/DelegatingWebSecurityManager.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web;
-
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.web.session.DelegatingWebSessionManager;
-import org.apache.shiro.web.session.WebSessionManager;
-
-/**
- * A {@code DelegatingWebSecurityManager} performs all normal web-related operations of the superclass
- * {@link DefaultWebSecurityManager} (handling cookies, HTTP requests, and other similar tasks), but delegates all of
- * its authentication, authorization and session operations to a delegate {@link SecurityManager SecurityManager}
- * instance.
- * <p/>
- * The {@code DelegatingWebSecurityManager} plays a part in some enterprise environments where the web tier and
- * business-logic tier do not reside in the same virtual machine.  In these environments, this component performs all
- * standard Web/Http security operations, but delegates the 'real' authentication, authorization and session management
- * operations to a wrapped {@code SecurityManager} instance responsible for those operations.  Usually the wrapped
- * {@code SecurityManager} instance is a remoting proxy that communicates with a remote/back-end {@code SecurityManager}
- * that is responsible for the 'real' security duties.
- * <p/>
- * In such distributed environments, all components in the web-tier VM use the {@link DelegatingWebSecurityManager}
- * instance as if it were the normal primary {@code SecurityManager} and are unaware of the distributed nature of the
- * application's configuration.
- *
- * @since 1.0
- */
-public class DelegatingWebSecurityManager extends DefaultWebSecurityManager {
-
-    public DelegatingWebSecurityManager() {
-        super();
-        //disable caching for now (delegate SecurityManager should cache if necessary):
-        setCacheManager(null);
-        //default to native sessions, since http sessions hosted in a web server would not
-        //be accessible to a back-end SecurityManager and native Sessions are:
-        setSessionMode(DefaultWebSecurityManager.NATIVE_SESSION_MODE);
-    }
-
-    public DelegatingWebSecurityManager(SecurityManager delegate) {
-        this();
-        setDelegateSecurityManager(delegate);
-    }
-
-    /**
-     * Receives the target/delegate {@link SecurityManager SecurityManager} instance, often a
-     * {@code SecurityManager} remoting proxy in distributed/federated environments.
-     * <p/>
-     * This implementation immediately sets this instance as the
-     * {@link #setAuthenticator(org.apache.shiro.authc.Authenticator) delegate authenticator} and
-     * {@link #setAuthorizer(org.apache.shiro.authz.Authorizer) delegate authorizer}.  It then constructs a
-     * wrapping {@link WebSessionManager WebSubjectFactory} based on the delegate {@code SecurityManager} instance
-     * and uses them as this component's
-     * {@link #setSessionManager(org.apache.shiro.session.mgt.SessionManager) sessionManager} instance.
-     *
-     * @param delegate the {@link SecurityManager} to which all authentication, authorization, and
-     *                 session management operations will be delegated.
-     * @see #createWebSessionManager(org.apache.shiro.mgt.SecurityManager)
-     */
-    public void setDelegateSecurityManager(SecurityManager delegate) {
-        if (delegate == null) {
-            throw new IllegalArgumentException("sessionManager cannot be null");
-        }
-
-        setAuthenticator(delegate);
-        setAuthorizer(delegate);
-
-        WebSessionManager sessionManager = createWebSessionManager(delegate);
-        setSessionManager(sessionManager);
-    }
-
-    /**
-     * Creates a WebSessionManager that will be used for all Session operations based on the specified
-     * {@code SecurityManager} delegate.  This implementation returns a new {@link DelegatingWebSessionManager} instance.
-     *
-     * @param delegate the delegate {@code SecurityManager} instance to use for all session operations.
-     * @return a WebSessionManager to use for all session operations for this {@link SecurityManager} instance.
-     * @see #setSessionManager(org.apache.shiro.session.mgt.SessionManager)
-     */
-    protected WebSessionManager createWebSessionManager(SecurityManager delegate) {
-        return new DelegatingWebSessionManager(delegate);
-    }
-}
diff --git a/web/src/main/java/org/apache/shiro/web/WebUtils.java b/web/src/main/java/org/apache/shiro/web/WebUtils.java
index 98ee91382..6bbd04f71 100644
--- a/web/src/main/java/org/apache/shiro/web/WebUtils.java
+++ b/web/src/main/java/org/apache/shiro/web/WebUtils.java
@@ -21,12 +21,9 @@ package org.apache.shiro.web;
 import org.apache.shiro.SecurityUtils;
 import org.apache.shiro.session.Session;
 import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.SubjectContext;
 import org.apache.shiro.util.StringUtils;
-import org.apache.shiro.util.ThreadContext;
 import org.apache.shiro.web.filter.AccessControlFilter;
-import org.apache.shiro.web.subject.WebSubject;
-import org.apache.shiro.web.subject.WebSubjectContext;
+import org.apache.shiro.web.util.RequestPairSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -57,14 +54,6 @@ public class WebUtils {
 
     private static final Logger log = LoggerFactory.getLogger(WebUtils.class);
 
-
-    /**
-     * Message displayed when a servlet request or response is not bound to the current thread context when expected.
-     */
-    private static final String NOT_BOUND_ERROR_MESSAGE =
-            "Make sure WebUtils.bind() is being called. (typically called by AbstractShiroFilter)  " +
-                    "This could also happen when running integration tests that don't properly call WebUtils.bind().";
-
     public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + "_SHIRO_THREAD_CONTEXT_KEY";
     public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + "_SHIRO_THREAD_CONTEXT_KEY";
 
@@ -74,7 +63,6 @@ public class WebUtils {
      */
     public static final String SAVED_REQUEST_KEY = "shiroSavedRequest";
 
-
     /**
      * Standard Servlet 2.3+ spec request attributes for include URI and paths.
      * <p>If included via a RequestDispatcher, the current resource will see the
@@ -234,7 +222,7 @@ public class WebUtils {
         return enc;
     }
 
-    /**
+    /*
      * Returns {@code true} IFF the specified {@code SubjectContext}:
      * <ol>
      * <li>A {@link WebSubjectContext} instance</li>
@@ -247,151 +235,55 @@ public class WebUtils {
      * @return {@code true} IFF the specified context has HTTP request/response objects, {@code false} otherwise.
      * @since 1.0
      */
-    public static boolean isHttp(SubjectContext context) {
-        if (context instanceof WebSubjectContext) {
-            WebSubjectContext wsc = (WebSubjectContext) context;
-            ServletRequest request = wsc.resolveServletRequest();
-            ServletResponse response = wsc.resolveServletResponse();
-            return request != null && request instanceof HttpServletRequest &&
-                    response != null && response instanceof HttpServletResponse;
-        }
-        return false;
+
+    public static boolean isWeb(Object requestPairSource) {
+        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);
     }
 
-    /**
-     * Returns {@code true} IFF the specified {@code Subject}:
-     * <ol>
-     * <li>A {@link WebSubject} instance</li>
-     * <li>The {@code WebSubject}'s request/response pair are not null</li>
-     * <li>The request is an {@link HttpServletRequest} instance</li>
-     * <li>The response is an {@link HttpServletResponse} instance</li>
-     * </ol>
-     *
-     * @param subject the {@code Subject} instance to check to see if it is HTTP compatible
-     * @return {@code true} IFF the specified subject has HTTP request/response objects, {@code false} otherwise.
-     * @since 1.0
-     */
-    public static boolean isHttp(Subject subject) {
-        if (subject instanceof WebSubject) {
-            WebSubject ws = (WebSubject) subject;
-            ServletRequest request = ws.getServletRequest();
-            ServletResponse response = ws.getServletResponse();
-            return request != null && request instanceof HttpServletRequest &&
-                    response != null && response instanceof HttpServletResponse;
-        }
-        return false;
+    public static boolean isHttp(Object requestPairSource) {
+        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);
     }
 
-    /**
-     * Returns the {@code Subject}'s associated {@link HttpServletRequest} instance.  This method will
-     * throw an {@link IllegalArgumentException} if the Subject is not a {@link WebSubject} instance or that
-     * {@code WebSubject} does not have an HTTP-compatible request object.  Callers will usually want to call
-     * the {@link #isHttp(Subject) isHttp(subject)} method first to ensure this method can be called successfully.
-     *
-     * @param subject the subject instance from which to retrieve the {@code Subject}'s associated
-     *                {@link HttpServletRequest} instance
-     * @return the subject's associated {@link HttpServletRequest} object.
-     * @throws IllegalArgumentException if the {@code Subject} is not a {@link WebSubject} or that {@code WebSubject}'s
-     *                                  request is not an {@link HttpServletRequest}.
-     * @since 1.0
-     */
-    public static HttpServletRequest getHttpRequest(Subject subject) throws IllegalArgumentException {
-        if (!(subject instanceof WebSubject)) {
-            String msg = "Subject instance is not a " + WebSubject.class.getName() + " instance.  This is required " +
-                    "to obtain a ServletRequest and ServletResponse";
-            throw new IllegalArgumentException(msg);
+    public static ServletRequest getRequest(Object requestPairSource) {
+        if (requestPairSource instanceof RequestPairSource) {
+            return ((RequestPairSource) requestPairSource).getServletRequest();
         }
-        WebSubject ws = (WebSubject) subject;
-        ServletRequest request = ws.getServletRequest();
-        if (request == null || !(request instanceof HttpServletRequest)) {
-            String msg = "WebSubject's ServletRequest is null or not an instance of HttpServletRequest.";
-            throw new IllegalArgumentException(msg);
-        }
-        return (HttpServletRequest) request;
+        return null;
     }
 
-    /**
-     * Returns the {@code Subject}'s associated {@link HttpServletResponse} instance.  This method will
-     * throw an {@link IllegalArgumentException} if the Subject is not a {@link WebSubject} instance or that
-     * {@code WebSubject} does not have an HTTP-compatible response object.  Callers will usually want to call
-     * the {@link #isHttp(Subject) isHttp(subject)} method first to ensure this method can be called successfully.
-     *
-     * @param subject the subject instance from which to retrieve the {@code Subject}'s associated
-     *                {@link HttpServletResponse} instance
-     * @return the subject's associated {@link HttpServletResponse} object.
-     * @throws IllegalArgumentException if the {@code Subject} is not a {@link WebSubject} or that {@code WebSubject}'s
-     *                                  response is not an {@link HttpServletResponse}.
-     * @since 1.0
-     */
-    public static HttpServletResponse getHttpResponse(Subject subject) {
-        if (!(subject instanceof WebSubject)) {
-            String msg = "Subject instance is not a " + WebSubject.class.getName() + " instance.  This is required " +
-                    "to obtain a ServletRequest and ServletResponse";
-            throw new IllegalArgumentException(msg);
-        }
-        WebSubject ws = (WebSubject) subject;
-        ServletResponse response = ws.getServletResponse();
-        if (response == null || !(response instanceof HttpServletResponse)) {
-            String msg = "WebSubject's ServletResponse is null or not an instance of HttpServletResponse.";
-            throw new IllegalArgumentException(msg);
+    public static ServletResponse getResponse(Object requestPairSource) {
+        if (requestPairSource instanceof RequestPairSource) {
+            return ((RequestPairSource) requestPairSource).getServletResponse();
         }
-        return (HttpServletResponse) response;
+        return null;
     }
 
-    /**
-     * Returns the {@code SubjectContext}'s {@link HttpServletRequest} instance.  This method will
-     * throw an {@link IllegalArgumentException} if the context is not a {@link WebSubjectContext} instance or that
-     * {@code WebSubjectContext} does not have an HTTP-compatible request object.  Callers will usually want to call
-     * the {@link #isHttp(SubjectContext) isHttp(subjectContext)} method first to ensure this method can be called
-     * successfully.
-     *
-     * @param context the subjectContext instance from which to retrieve the associated {@link HttpServletRequest}
-     * @return the context's {@link HttpServletRequest} object.
-     * @throws IllegalArgumentException if the {@code SubjectContext} is not a {@link WebSubjectContext} or that
-     *                                  {@code WebSubjectContext}'s request is not an {@link HttpServletRequest}.
-     * @since 1.0
-     */
-    public static HttpServletRequest getHttpRequest(SubjectContext context) {
-        if (!(context instanceof WebSubjectContext)) {
-            String msg = "SubjectContext instance is not a " + WebSubjectContext.class.getName() + " instance.  " +
-                    "This is required to obtain a ServletRequest and ServletResponse";
-            throw new IllegalArgumentException(msg);
-        }
-        WebSubjectContext wsc = (WebSubjectContext) context;
-        ServletRequest request = wsc.resolveServletRequest();
-        if (request == null || !(request instanceof HttpServletRequest)) {
-            String msg = "WebSubjectContext's ServletRequest is null or not an instance of HttpServletRequest.";
-            throw new IllegalArgumentException(msg);
+    public static HttpServletRequest getHttpRequest(Object requestPairSource) {
+        ServletRequest request = getRequest(requestPairSource);
+        if (request instanceof HttpServletRequest) {
+            return (HttpServletRequest) request;
         }
-        return (HttpServletRequest) request;
+        return null;
     }
 
-    /**
-     * Returns the {@code SubjectContext}'s {@link HttpServletResponse} instance.  This method will
-     * throw an {@link IllegalArgumentException} if the context is not a {@link WebSubjectContext} instance or that
-     * {@code WebSubjectContext} does not have an HTTP-compatible response object.  Callers will usually want to call
-     * the {@link #isHttp(SubjectContext) isHttp(subjectContext)} method first to ensure this method can be called
-     * successfully.
-     *
-     * @param context the subjectContext instance from which to retrieve the associated {@link HttpServletResponse}
-     * @return the context's {@link HttpServletResponse} object.
-     * @throws IllegalArgumentException if the {@code SubjectContext} is not a {@link WebSubjectContext} or that
-     *                                  {@code WebSubjectContext}'s response is not an {@link HttpServletResponse}.
-     * @since 1.0
-     */
-    public static HttpServletResponse getHttpResponse(SubjectContext context) {
-        if (!(context instanceof WebSubjectContext)) {
-            String msg = "SubjectContext instance is not a " + WebSubjectContext.class.getName() + " instance.  " +
-                    "This is required to obtain a ServletRequest and ServletResponse";
-            throw new IllegalArgumentException(msg);
+    public static HttpServletResponse getHttpResponse(Object requestPairSource) {
+        ServletResponse response = getResponse(requestPairSource);
+        if (response instanceof HttpServletResponse) {
+            return (HttpServletResponse) response;
         }
-        WebSubjectContext wsc = (WebSubjectContext) context;
-        ServletResponse response = wsc.resolveServletResponse();
-        if (response == null || !(response instanceof HttpServletResponse)) {
-            String msg = "WebSubjectContext's ServletResponse is null or not an instance of HttpServletResponse.";
-            throw new IllegalArgumentException(msg);
-        }
-        return (HttpServletResponse) response;
+        return null;
+    }
+
+    private static boolean isWeb(RequestPairSource source) {
+        ServletRequest request = source.getServletRequest();
+        ServletResponse response = source.getServletResponse();
+        return request != null && response != null;
+    }
+
+    private static boolean isHttp(RequestPairSource source) {
+        ServletRequest request = source.getServletRequest();
+        ServletResponse response = source.getServletResponse();
+        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;
     }
 
     /**
@@ -426,96 +318,6 @@ public class WebUtils {
         return (HttpServletResponse) response;
     }
 
-    /**
-     * Returns the current thread-bound {@code ServletRequest} or {@code null} if there is not one bound.
-     * <p/>
-     * It is the case in certain enterprise environments where a web-enabled SecurityManager (and its internal mechanisms)
-     * is the primary SecurityManager but also serves as a 'central' coordinator for security operations in a cluster.
-     * In these environments, it is possible for a web-enabled SecurityManager to receive remote method invocations that
-     * are not HTTP based.  In such an environment this method would return {@code null}.
-     * <p/>
-     * <b>THIS IS NOT PART OF APACHE SHIRO'S PUBLIC API.</b>  It exists for Shiro implementation requirements only.
-     *
-     * @return the current thread-bound {@code ServletRequest} or {@code null} if there is not one bound.
-     * @since 1.0
-     */
-    public static ServletRequest getServletRequest() {
-        ServletRequest request = (ServletRequest) ThreadContext.get(SERVLET_REQUEST_KEY);
-        if (request == null) {
-            Subject subject = ThreadContext.getSubject();
-            if (subject instanceof WebSubject) {
-                WebSubject webSubject = (WebSubject) subject;
-                request = webSubject.getServletRequest();
-            }
-        }
-        return request;
-    }
-
-    /**
-     * Convenience method that simplifies binding a ServletRequest to the current thread (via the ThreadContext).
-     * <p/>
-     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of
-     * ThreadContext key names.  The implementation is simple in that, if the servletRequest is not <tt>null</tt>,
-     * it binds it to the thread, i.e.:
-     * <p/>
-     * <pre>
-     * if (servletRequest != null) {
-     *     ThreadContext.put( SERVLET_REQUEST_KEY, servletRequest );
-     * }</pre>
-     *
-     * @param servletRequest the ServletRequest object to bind to the thread.  If the argument is null, nothing will be done.
-     */
-    public static void bind(ServletRequest servletRequest) {
-        if (servletRequest != null) {
-            ThreadContext.put(SERVLET_REQUEST_KEY, servletRequest);
-        }
-    }
-
-    /**
-     * Returns the current thread-bound {@code ServletResponse} or {@code null} if there is not one bound.
-     * <p/>
-     * It is the case in certain enterprise environments where a web-enabled SecurityManager (and its internal mechanisms)
-     * is the primary SecurityManager but also serves as a 'central' coordinator for security operations in a cluster.
-     * In these environments, it is possible for a web-enabled SecurityManager to receive remote method invocations that
-     * are not HTTP based.  In such an environment this method would return {@code null}.
-     * <p/>
-     * <b>THIS IS NOT PART OF APACHE SHIRO'S PUBLIC API.</b>  It exists for Shiro implementation requirements only.
-     *
-     * @return the current thread-bound {@code ServletResponse} or {@code null} if there is not one bound.
-     * @since 1.0
-     */
-    public static ServletResponse getServletResponse() {
-        ServletResponse response = (ServletResponse) ThreadContext.get(SERVLET_RESPONSE_KEY);
-        if (response == null) {
-            Subject subject = ThreadContext.getSubject();
-            if (subject instanceof WebSubject) {
-                WebSubject webSubject = (WebSubject) subject;
-                response = webSubject.getServletResponse();
-            }
-        }
-        return response;
-    }
-
-    /**
-     * Convenience method that simplifies binding a ServletResponse to the thread via the ThreadContext.
-     * <p/>
-     * <p>The method's existence is to help reduce casting in your own code and to simplify remembering of
-     * ThreadContext key names.  The implementation is simple in that, if the servletResponse is not <tt>null</tt>,
-     * it binds it to the thread, i.e.:
-     * <p/>
-     * <pre>
-     * if (servletResponse != null) {
-     *     ThreadContext.put( SERVLET_RESPONSE_KEY, servletResponse );
-     * }</pre>
-     *
-     * @param servletResponse the ServletResponse object to bind to the thread.  If the argument is null, nothing will be done.
-     */
-    public static void bind(ServletResponse servletResponse) {
-        if (servletResponse != null) {
-            ThreadContext.put(SERVLET_RESPONSE_KEY, servletResponse);
-        }
-    }
-
     /**
      * Redirects the current request to a new URL based on the given parameters.
      *
diff --git a/web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java b/web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java
index 77d7eeb23..a3f419594 100644
--- a/web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java
+++ b/web/src/main/java/org/apache/shiro/web/session/DefaultWebSessionManager.java
@@ -18,9 +18,13 @@
  */
 package org.apache.shiro.web.session;
 
+import org.apache.shiro.session.ExpiredSessionException;
+import org.apache.shiro.session.InvalidSessionException;
 import org.apache.shiro.session.Session;
-import org.apache.shiro.session.SessionException;
 import org.apache.shiro.session.mgt.DefaultSessionManager;
+import org.apache.shiro.session.mgt.DelegatingSession;
+import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.session.mgt.SessionKey;
 import org.apache.shiro.web.WebUtils;
 import org.apache.shiro.web.servlet.Cookie;
 import org.apache.shiro.web.servlet.ShiroHttpServletRequest;
@@ -32,6 +36,7 @@ import org.slf4j.LoggerFactory;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.Serializable;
 
 
@@ -41,9 +46,7 @@ import java.io.Serializable;
  * @author Les Hazlewood
  * @since 0.9
  */
-public class DefaultWebSessionManager extends DefaultSessionManager implements WebSessionManager {
-
-    //TODO - complete JavaDoc
+public class DefaultWebSessionManager extends DefaultSessionManager {
 
     private static final Logger log = LoggerFactory.getLogger(DefaultWebSessionManager.class);
 
@@ -75,33 +78,21 @@ public class DefaultWebSessionManager extends DefaultSessionManager implements W
         this.sessionIdCookieEnabled = sessionIdCookieEnabled;
     }
 
-    private void storeSessionId(Serializable currentId, ServletRequest request, ServletResponse response) {
+    private void storeSessionId(Serializable currentId, HttpServletRequest request, HttpServletResponse response) {
         if (currentId == null) {
             String msg = "sessionId cannot be null when persisting for subsequent requests.";
             throw new IllegalArgumentException(msg);
         }
-        if (!(request instanceof HttpServletRequest)) {
-            log.debug("Current request is not an HttpServletRequest - cannot save session id cookie. Returning.");
-            return;
-        }
         Cookie template = getSessionIdCookie();
         Cookie cookie = new SimpleCookie(template);
         String idString = currentId.toString();
         cookie.setValue(idString);
-        cookie.saveTo(WebUtils.toHttp(request), WebUtils.toHttp(response));
+        cookie.saveTo(request, response);
         log.trace("Set session ID cookie for session with id {}", idString);
     }
 
-    private void markSessionIdValid(ServletRequest request) {
-        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);
-    }
-
-    private void markSessionIdInvalid(ServletRequest request) {
-        request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);
-    }
-
-    private void removeSessionIdCookie(ServletRequest request, ServletResponse response) {
-        getSessionIdCookie().removeFrom(WebUtils.toHttp(request), WebUtils.toHttp(response));
+    private void removeSessionIdCookie(HttpServletRequest request, HttpServletResponse response) {
+        getSessionIdCookie().removeFrom(request, response);
     }
 
     private String getSessionIdCookieValue(ServletRequest request, ServletResponse response) {
@@ -139,78 +130,113 @@ public class DefaultWebSessionManager extends DefaultSessionManager implements W
             request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);
             //automatically mark it valid here.  If it is invalid, the
             //onUnknownSession method below will be invoked and we'll remove the attribute at that time.
-            markSessionIdValid(request);
+            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);
         }
         return id;
     }
 
+    protected Session createExposedSession(Session session, SessionContext context) {
+        if (!WebUtils.isWeb(context)) {
+            return super.createExposedSession(session, context);
+        }
+        ServletRequest request = WebUtils.getRequest(context);
+        ServletResponse response = WebUtils.getResponse(context);
+        SessionKey key = new WebSessionKey(session.getId(), request, response);
+        return new DelegatingSession(this, key);
+    }
+
+    protected Session createExposedSession(Session session, SessionKey key) {
+        if (!WebUtils.isWeb(key)) {
+            return super.createExposedSession(session, key);
+        }
+
+        ServletRequest request = WebUtils.getRequest(key);
+        ServletResponse response = WebUtils.getResponse(key);
+        SessionKey sessionKey = new WebSessionKey(session.getId(), request, response);
+        return new DelegatingSession(this, sessionKey);
+    }
+
     /**
      * Stores the Session's ID, usually as a Cookie, to associate with future requests.
      *
      * @param session the session that was just {@link #createSession created}.
      */
     @Override
-    protected void onStart(Session session) {
-        ServletRequest request = WebUtils.getServletRequest();
-        ServletResponse response = WebUtils.getServletResponse();
-        if (request == null || response == null) {
-            log.debug("Request or response object is not bound to the thread.  Assuming this session start " +
-                    "activity is due to a non web request (possible in a web application that also services " +
-                    "non web clients.");
+    protected void onStart(Session session, SessionContext context) {
+        super.onStart(session, context);
+
+        if (!WebUtils.isHttp(context)) {
+            log.debug("SessionContext argument is not HTTP compatible or does not have an HTTP request/response " +
+                    "pair. No session ID cookie will be set.");
             return;
+
         }
+        HttpServletRequest request = WebUtils.getHttpRequest(context);
+        HttpServletResponse response = WebUtils.getHttpResponse(context);
+
         if (isSessionIdCookieEnabled()) {
             Serializable sessionId = session.getId();
             storeSessionId(sessionId, request, response);
         } else {
-            log.debug("Session ID cookie is disabled.  No cookie has been set for new session with id {}",
-                    session.getId());
+            log.debug("Session ID cookie is disabled.  No cookie has been set for new session with id {}", session.getId());
         }
 
         request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE);
         request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_IS_NEW, Boolean.TRUE);
     }
 
-    public Session getSession(ServletRequest request, ServletResponse response) throws SessionException {
-        Serializable id = getReferencedSessionId(request, response);
-        Session session = null;
-        if ( id != null ) {
-            session = getSession(id);
+    @Override
+    public Serializable getSessionId(SessionKey key) {
+        Serializable id = super.getSessionId(key);
+        if (id == null && WebUtils.isWeb(key)) {
+            ServletRequest request = WebUtils.getRequest(key);
+            ServletResponse response = WebUtils.getResponse(key);
+            id = getSessionId(request, response);
         }
-        return session;
+        return id;
     }
 
-    public Serializable getSessionId(ServletRequest request, ServletResponse response) {
+    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
         return getReferencedSessionId(request, response);
     }
 
     @Override
-    public void onUnknownSession(Serializable sessionId) {
-        ServletRequest request = WebUtils.getServletRequest();
-        if (request != null) {
-            markSessionIdInvalid(request);
-        }
-        removeSessionIdCookie();
+    protected void onExpiration(Session s, ExpiredSessionException ese, SessionKey key) {
+        super.onExpiration(s, ese, key);
+        onInvalidation(key);
     }
 
-    protected void onStop(Session session) {
-        super.onStop(session);
-        removeSessionIdCookie();
+    @Override
+    protected void onInvalidation(Session session, InvalidSessionException ise, SessionKey key) {
+        super.onInvalidation(session, ise, key);
+        onInvalidation(key);
     }
 
-    protected void onExpiration(Session session) {
-        super.onExpiration(session);
-        removeSessionIdCookie();
+    private void onInvalidation(SessionKey key) {
+        ServletRequest request = WebUtils.getRequest(key);
+        if (request != null) {
+            request.removeAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID);
+        }
+        if (WebUtils.isHttp(key)) {
+            log.debug("Referenced session was invalid.  Removing session ID cookie.");
+            removeSessionIdCookie(WebUtils.getHttpRequest(key), WebUtils.getHttpResponse(key));
+        } else {
+            log.debug("SessionKey argument is not HTTP compatible or does not have an HTTP request/response " +
+                    "pair. Session ID cookie will not be removed due to invalidated session.");
+        }
     }
 
-    private void removeSessionIdCookie() {
-        ServletRequest request = WebUtils.getServletRequest();
-        ServletResponse response = WebUtils.getServletResponse();
-        if (request == null || response == null) {
-            log.debug("No request or response bound to the thread.  Session ID cookie cannot be removed.  This could " +
-                    "occur in a web application that also services non web clients (e.g. RMI remoting).");
-            return;
+    @Override
+    protected void onStop(Session session, SessionKey key) {
+        super.onStop(session, key);
+        if (WebUtils.isHttp(key)) {
+            HttpServletRequest request = WebUtils.getHttpRequest(key);
+            HttpServletResponse response = WebUtils.getHttpResponse(key);
+            log.debug("Session has been stopped (subject logout or explicit stop).  Removing session ID cookie.");
+            removeSessionIdCookie(request, response);
+        } else {
+            log.debug("SessionKey argument is not HTTP compatible or does not have an HTTP request/response " +
+                    "pair. Session ID cookie will not be removed due to stopped session.");
         }
-        removeSessionIdCookie(request, response);
     }
 }
diff --git a/web/src/main/java/org/apache/shiro/web/session/DelegatingWebSessionManager.java b/web/src/main/java/org/apache/shiro/web/session/DelegatingWebSessionManager.java
deleted file mode 100644
index d5cf7116e..000000000
--- a/web/src/main/java/org/apache/shiro/web/session/DelegatingWebSessionManager.java
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.session;
-
-import org.apache.shiro.authz.AuthorizationException;
-import org.apache.shiro.session.InvalidSessionException;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.SessionException;
-import org.apache.shiro.session.mgt.DelegatingSession;
-import org.apache.shiro.session.mgt.SessionContext;
-import org.apache.shiro.session.mgt.SessionManager;
-import org.apache.shiro.util.ThreadContext;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Date;
-
-/**
- * WARNING: THIS IS A WORK IN PROGRESS AND IS NOT RECOMMENDED FOR USE!
- *
- * A {@code DelegatingWebSessionManager} performs all normal operations of the superclass {@link DefaultWebSessionManager}
- * except it does not perform {@code Session} creation or lookup duties itself and instead delegates those duties
- * to a target/wrapped {@link SessionManager SessionManager} instance.  It is primarily used to support
- * the functionality of the {@link org.apache.shiro.web.DelegatingWebSecurityManager DelegatingWebSecurityManager} and
- * for the most part is considered an infrastructural component that would rarely need to be referenced by Shiro users.
- * <p/>
- * The {@code DelegatingWebSessionManager} plays a part in some enterprise environments where the web tier and
- * business-logic tier do not reside in the same virtual machine.  In these environments, this component performs all
- * standard Web/Http session operations, but delegates {@code Session} creation and lookup to a wrapped
- * {@code SessionManager} instance responsible for those operations.  Usually the wrapped {@code SessionManager}
- * instance is a remoting proxy that communicates with a remote/back-end SessionManager that is responsible for the
- * 'real' creation/lookup duties.
- *
- * @since 1.0
- */
-public class DelegatingWebSessionManager extends DefaultWebSessionManager {
-
-    private static transient final Logger log = LoggerFactory.getLogger(DelegatingWebSessionManager.class);
-
-    private static final String THREAD_CONTEXT_SESSION_KEY =
-            DelegatingWebSessionManager.class.getName() + ".THREAD_CONTEXT_SESSION_KEY";
-
-    private SessionManager delegateSessionManager = null;
-
-    public DelegatingWebSessionManager() {
-        setSessionValidationSchedulerEnabled(false);
-    }
-
-    public DelegatingWebSessionManager(SessionManager delegateSessionManager) {
-        this();
-        this.delegateSessionManager = new ThreadClearingSessionManager(delegateSessionManager);
-    }
-
-    public void setDelegateSessionManager(SessionManager delegateSessionManager) {
-        this.delegateSessionManager = new ThreadClearingSessionManager(delegateSessionManager);
-    }
-
-    private void assertDelegateExists() {
-        //can only be null in a Dependency Injection environment, so check to ensure it is not null:
-        if (this.delegateSessionManager == null) {
-            throw new IllegalStateException("delegateSessionManager property has not been set.  Please check your " +
-                    "configuration to ensure the " + getClass().getName() + " instance has been injected with a " +
-                    SessionManager.class.getName() + " delegate instance.");
-        }
-    }
-
-    /**
-     * Can be used in DI environments to ensure the
-     * {@link #setDelegateSessionManager(org.apache.shiro.session.mgt.SessionManager) delegateSessionManager} exists and
-     * has been set correctly.
-     *
-     * @throws IllegalStateException if the {@code delegateSessionManager} property has not been set.
-     */
-    public void init() throws IllegalStateException {
-        assertDelegateExists();
-    }
-
-    @Override
-    protected Session doCreateSession(SessionContext initData) {
-        assertDelegateExists();
-        Session session = this.delegateSessionManager.start(initData);
-        return new DelegatingSession(this, session.getId());
-    }
-
-    @Override
-    protected void applyGlobalSessionTimeout(Session session) {
-        //do nothing so we don't override the back-end's session settings.
-        //TODO - ensure front end session manager settings cannot be altered
-    }
-
-    @Override
-    protected Session retrieveSessionFromDataSource(Serializable id) throws InvalidSessionException {
-        //use thread-local caching to eliminate repeated 'hits' on the back-end data store during
-        //the thread execution.  We do this here and not in the parent class since we can ensure the
-        //ThreadContext is being cleared at the end of each request due to the ShiroFilter being required in web
-        //environments (which automatically clears the thread).
-        Session session = (Session) ThreadContext.get(THREAD_CONTEXT_SESSION_KEY);
-        if (session != null) {
-            log.trace("Returning thread-cached session.");
-            return session;
-        }
-        assertDelegateExists();
-        //get the host address and bind it to the thread.  This call will both validate the session as well as
-        //make it accessible for futher host checks:
-        String host = this.delegateSessionManager.getHost(id);
-        session = new DelegatingSession(this.delegateSessionManager, id, host);
-        log.trace("Cached the session retrieved from the datasource in a thread-local for continued thread access.");
-        ThreadContext.put(THREAD_CONTEXT_SESSION_KEY, session);
-
-        return session;
-    }
-
-    protected void removeThreadBoundSession() {
-        log.debug("Session is invalid or an invalid id was encountered.  Unbinding the thread-cached session.");
-        ThreadContext.remove(THREAD_CONTEXT_SESSION_KEY);
-    }
-
-    @Override
-    protected void onChange(Session session) {
-        //do nothing - back-end will react to change as appropriate
-    }
-
-    @Override
-    protected void doValidate(Session session) throws InvalidSessionException {
-        //do nothing - we rely on lazy session exceptions and recreation via the SessionManagerProxy to avoid
-        //costly validation checks on each session access.
-    }
-
-
-    private interface SessionManagerCallback {
-        Object doWithSessionManager(SessionManager sm) throws SessionException;
-    }
-
-    private class ThreadClearingSessionManager implements SessionManager {
-
-        private final SessionManager target;
-
-        private ThreadClearingSessionManager(SessionManager target) {
-            this.target = target;
-        }
-
-        private Object execute(SessionManagerCallback smc) throws SessionException {
-            try {
-                return smc.doWithSessionManager(target);
-            } catch (SessionException se) {
-                removeThreadBoundSession();
-                //propagate after cleanup:
-                throw se;
-            }
-        }
-
-        public Session start(final SessionContext initData) throws AuthorizationException {
-            return (Session) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.start(initData);
-                }
-            });
-        }
-
-        public Date getStartTimestamp(final Serializable sessionId) {
-            return (Date) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getStartTimestamp(sessionId);
-                }
-            });
-        }
-
-        public Date getLastAccessTime(final Serializable sessionId) {
-            return (Date) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getLastAccessTime(sessionId);
-                }
-            });
-        }
-
-        public boolean isValid(final Serializable sessionId) {
-            return (Boolean) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.isValid(sessionId);
-                }
-            });
-        }
-
-        public void checkValid(final Serializable sessionId) throws InvalidSessionException {
-            execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    sm.checkValid(sessionId);
-                    return null;
-                }
-            });
-        }
-
-        public long getTimeout(final Serializable sessionId) throws InvalidSessionException {
-            return (Long) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getTimeout(sessionId);
-                }
-            });
-        }
-
-        public void setTimeout(final Serializable sessionId, final long maxIdleTimeInMillis) throws InvalidSessionException {
-            execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    sm.setTimeout(sessionId, maxIdleTimeInMillis);
-                    return null;
-                }
-            });
-        }
-
-        public void touch(final Serializable sessionId) throws InvalidSessionException {
-            execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    sm.touch(sessionId);
-                    return null;
-                }
-            });
-        }
-
-        public String getHost(final Serializable sessionId) {
-            return (String) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getHost(sessionId);
-                }
-            });
-        }
-
-        public void stop(final Serializable sessionId) throws InvalidSessionException {
-            execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    sm.stop(sessionId);
-                    return null;
-                }
-            });
-        }
-
-        @SuppressWarnings({"unchecked"})
-        public Collection<Object> getAttributeKeys(final Serializable sessionId) {
-            return (Collection<Object>) execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getAttributeKeys(sessionId);
-                }
-            });
-        }
-
-        public Object getAttribute(final Serializable sessionId, final Object key) throws InvalidSessionException {
-            return execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.getAttribute(sessionId, key);
-                }
-            });
-        }
-
-        public void setAttribute(final Serializable sessionId, final Object key, final Object value) throws InvalidSessionException {
-            execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    sm.setAttribute(sessionId, key, value);
-                    return null;
-                }
-            });
-        }
-
-        public Object removeAttribute(final Serializable sessionId, final Object key) throws InvalidSessionException {
-            return execute(new SessionManagerCallback() {
-                public Object doWithSessionManager(SessionManager sm) throws SessionException {
-                    return sm.removeAttribute(sessionId, key);
-                }
-            });
-        }
-    }
-}
diff --git a/web/src/main/java/org/apache/shiro/web/session/ServletContainerSessionManager.java b/web/src/main/java/org/apache/shiro/web/session/ServletContainerSessionManager.java
index 76332c424..3fb7a2f76 100644
--- a/web/src/main/java/org/apache/shiro/web/session/ServletContainerSessionManager.java
+++ b/web/src/main/java/org/apache/shiro/web/session/ServletContainerSessionManager.java
@@ -19,16 +19,16 @@
 package org.apache.shiro.web.session;
 
 import org.apache.shiro.authz.AuthorizationException;
-import org.apache.shiro.session.InvalidSessionException;
 import org.apache.shiro.session.Session;
+import org.apache.shiro.session.SessionException;
 import org.apache.shiro.session.mgt.AbstractSessionManager;
 import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.session.mgt.SessionKey;
+import org.apache.shiro.web.WebUtils;
 
 import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
-import java.io.Serializable;
 
 
 /**
@@ -51,7 +51,7 @@ import java.io.Serializable;
  * @author Les Hazlewood
  * @since 0.9
  */
-public class ServletContainerSessionManager extends AbstractSessionManager implements WebSessionManager {
+public class ServletContainerSessionManager extends AbstractSessionManager {
 
     //TODO - complete JavaDoc
 
@@ -60,92 +60,60 @@ public class ServletContainerSessionManager extends AbstractSessionManager imple
     public ServletContainerSessionManager() {
     }
 
-    @Override
-    public Session start(SessionContext initData) throws AuthorizationException {
-        return createSession(initData);
+    public Session start(SessionContext context) throws AuthorizationException {
+        return createSession(context);
     }
 
-    /**
-     * This method exists only to satisfy the parent's abstract method signature.  It should never be called since
-     * there is no way to obtain a Session instance from a Servlet Container by id (in a system independent
-     * manner).
-     * <p/>
-     * This method will always throw an exception if called since the
-     * {@link #getSession(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} method should be used in all
-     * cases instead.
-     *
-     * @param sessionId
-     * @return
-     * @throws InvalidSessionException
-     */
-    protected Session doGetSession(Serializable sessionId) throws InvalidSessionException {
-        //Ignore session id since there is no way to acquire a session based on an id in a servlet container
-        //(that is implementation agnostic)
-        String msg = "Cannot retrieve sessions by ID when Sessions are managed by the Servlet Container.  This " +
-                "feature is available for Shiro 'native' session SessionManager implementations only.";
-        throw new IllegalStateException(msg);
-        /*ServletRequest request = WebUtils.getServletRequest();
-        ServletResponse response = WebUtils.getServletResponse();
-        if (request == null) {
-            String msg = "Thread-bound ServletRequest cannot be null in ServletContainer-managed Session environments.";
-            throw new IllegalStateException(msg);
+    public Session getSession(SessionKey key) throws SessionException {
+        if (!WebUtils.isHttp(key)) {
+            String msg = "SessionKey must be an HTTP compatible implementation.";
+            throw new IllegalArgumentException(msg);
         }
-        return getSession(request, response);*/
-    }
 
-    /**
-     * @since 1.0
-     */
-    public Session getSession(ServletRequest request, ServletResponse response) {
+        HttpServletRequest request = WebUtils.getHttpRequest(key);
+
         Session session = null;
-        HttpSession httpSession = ((HttpServletRequest) request).getSession(false);
+
+        HttpSession httpSession = request.getSession(false);
         if (httpSession != null) {
             session = createSession(httpSession, request.getRemoteHost());
         }
+
         return session;
     }
 
-    /**
-     * @since 1.0
-     */
-    public Serializable getSessionId(ServletRequest request, ServletResponse response) {
-        HttpSession httpSession = ((HttpServletRequest) request).getSession(false);
-        return httpSession != null ? httpSession.getId() : null;
+    private String getHost(SessionContext context) {
+        String host = context.getHost();
+        if (host == null) {
+            ServletRequest request = WebUtils.getRequest(context);
+            if (request != null) {
+                host = request.getRemoteHost();
+            }
+        }
+        return host;
+
     }
 
     /**
      * @since 1.0
      */
     protected Session createSession(SessionContext sessionContext) throws AuthorizationException {
-        if (!(sessionContext instanceof WebSessionContext)) {
-            String msg = "SessionContext must be a " + WebSessionContext.class.getName() + " instance.";
+        if (!WebUtils.isHttp(sessionContext)) {
+            String msg = "SessionContext must be an HTTP compatible implementation.";
             throw new IllegalArgumentException(msg);
         }
 
-        WebSessionContext wsc = (WebSessionContext) sessionContext;
+        HttpServletRequest request = WebUtils.getHttpRequest(sessionContext);
 
-        ServletRequest request = wsc.getServletRequest();
-        if (request == null) {
-            String msg = "WebSessionContext must contain a ServletRequest.";
-            throw new IllegalStateException(msg);
-        }
-        ServletResponse response = wsc.getServletResponse();
-        if (response == null) {
-            String msg = "WebSessionContext must contain a ServletResponse.";
-            throw new IllegalStateException(msg);
-        }
-
-        HttpSession httpSession = ((HttpServletRequest) request).getSession();
+        HttpSession httpSession = request.getSession();
 
         //ensure that the httpSession timeout reflects what is configured:
         long timeoutMillis = getGlobalSessionTimeout();
         httpSession.setMaxInactiveInterval((int) (timeoutMillis / MILLIS_PER_SECOND));
 
-        String originatingHost = wsc.getHost();
-        if (originatingHost == null) {
-            originatingHost = request.getRemoteHost();
-        }
-        return createSession(httpSession, originatingHost);
+        String host = getHost(sessionContext);
+
+        return createSession(httpSession, host);
     }
 
     protected Session createSession(HttpSession httpSession, String host) {
diff --git a/web/src/main/java/org/apache/shiro/web/session/WebSessionContext.java b/web/src/main/java/org/apache/shiro/web/session/WebSessionContext.java
index 22a6f4728..7732677be 100644
--- a/web/src/main/java/org/apache/shiro/web/session/WebSessionContext.java
+++ b/web/src/main/java/org/apache/shiro/web/session/WebSessionContext.java
@@ -19,6 +19,7 @@
 package org.apache.shiro.web.session;
 
 import org.apache.shiro.session.mgt.SessionContext;
+import org.apache.shiro.web.util.RequestPairSource;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -31,7 +32,7 @@ import javax.servlet.ServletResponse;
  * @author Les Hazlewood
  * @since 1.0
  */
-public interface WebSessionContext extends SessionContext {
+public interface WebSessionContext extends SessionContext, RequestPairSource {
 
     /**
      * Returns the {@code ServletRequest} received by the servlet container triggering the creation of the
diff --git a/web/src/main/java/org/apache/shiro/web/session/WebSessionKey.java b/web/src/main/java/org/apache/shiro/web/session/WebSessionKey.java
new file mode 100644
index 000000000..97a933f26
--- /dev/null
+++ b/web/src/main/java/org/apache/shiro/web/session/WebSessionKey.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2008 Les Hazlewood
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.shiro.web.session;
+
+import org.apache.shiro.session.mgt.DefaultSessionKey;
+import org.apache.shiro.web.util.RequestPairSource;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import java.io.Serializable;
+
+/**
+ * A {@link org.apache.shiro.session.mgt.SessionKey SessionKey} implementation that also retains the
+ * {@code ServletRequest} and {@code ServletResponse} associated with the web request that is performing the
+ * session lookup.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public class WebSessionKey extends DefaultSessionKey implements RequestPairSource {
+
+    private final ServletRequest servletRequest;
+    private final ServletResponse servletResponse;
+
+    public WebSessionKey(ServletRequest request, ServletResponse response) {
+        if (request == null) {
+            throw new NullPointerException("request argument cannot be null.");
+        }
+        if (response == null) {
+            throw new NullPointerException("response argument cannot be null.");
+        }
+        this.servletRequest = request;
+        this.servletResponse = response;
+    }
+
+    public WebSessionKey(Serializable sessionId, ServletRequest request, ServletResponse response) {
+        this(request, response);
+        setSessionId(sessionId);
+    }
+
+    public ServletRequest getServletRequest() {
+        return servletRequest;
+    }
+
+    public ServletResponse getServletResponse() {
+        return servletResponse;
+    }
+}
diff --git a/web/src/main/java/org/apache/shiro/web/session/WebSessionManager.java b/web/src/main/java/org/apache/shiro/web/session/WebSessionManager.java
deleted file mode 100644
index 3877c1882..000000000
--- a/web/src/main/java/org/apache/shiro/web/session/WebSessionManager.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.session;
-
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.SessionException;
-import org.apache.shiro.session.mgt.SessionManager;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import java.io.Serializable;
-
-
-/**
- * A {@code WebSessionManager} is a {@code SessionManager} that has the ability to obtain session ids based on a
- * {@link ServletRequest ServletRequest}/{@link ServletResponse ServletResponse} pair.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public interface WebSessionManager extends SessionManager {
-
-    /**
-     * Returns the session id associated with the specified request pair or {@code null} if there is no session
-     * associated with the request.
-     *
-     * @param request  the incoming {@code ServletRequest}
-     * @param response the outgoing {@code ServletResponse}
-     * @return the current session id associated with the specified request pair, or {@code null} if there is no
-     *         session associated with the request.
-     * @since 1.0
-     */
-    Serializable getSessionId(ServletRequest request, ServletResponse response);
-
-    /**
-     * Returns the session associated with the specified request pair or {@code null} if there is no session
-     * associated with the request.
-     *
-     * @param request  the incoming {@code ServletRequest}
-     * @param response the outgoing {@code ServletResponse}
-     * @return the current session associated with the specified request pair, or {@code null} if there is no
-     *         session associated with the request.
-     * @throws SessionException if there is a problem acquiring the Session associated with the request/response pair
-     * @since 1.0
-     */
-    Session getSession(ServletRequest request, ServletResponse response) throws SessionException;
-}
diff --git a/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java b/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
index e918a4b99..8cea5fa85 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/WebSubject.java
@@ -23,6 +23,7 @@ import org.apache.shiro.mgt.SecurityManager;
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.subject.SubjectContext;
 import org.apache.shiro.web.subject.support.DefaultWebSubjectContext;
+import org.apache.shiro.web.util.RequestPairSource;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -33,7 +34,7 @@ import javax.servlet.ServletResponse;
  *
  * @since 1.0
  */
-public interface WebSubject extends Subject {
+public interface WebSubject extends Subject, RequestPairSource {
 
     /**
      * Returns the {@code ServletRequest} accessible when the Subject instance was created.
diff --git a/web/src/main/java/org/apache/shiro/web/subject/WebSubjectContext.java b/web/src/main/java/org/apache/shiro/web/subject/WebSubjectContext.java
index a872e1a1e..d1707d2ad 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/WebSubjectContext.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/WebSubjectContext.java
@@ -19,6 +19,7 @@
 package org.apache.shiro.web.subject;
 
 import org.apache.shiro.subject.SubjectContext;
+import org.apache.shiro.web.util.RequestPairSource;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -30,7 +31,7 @@ import javax.servlet.ServletResponse;
  * @author Les Hazlewood
  * @since 1.0
  */
-public interface WebSubjectContext extends SubjectContext {
+public interface WebSubjectContext extends SubjectContext, RequestPairSource {
 
     /**
      * Returns the {@code ServletRequest} received by the servlet container triggering the creation of the
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/DefaultWebSubjectContext.java b/web/src/main/java/org/apache/shiro/web/subject/support/DefaultWebSubjectContext.java
index 113556173..3f87a7653 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/support/DefaultWebSubjectContext.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/support/DefaultWebSubjectContext.java
@@ -20,7 +20,6 @@ package org.apache.shiro.web.subject.support;
 
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.subject.support.DefaultSubjectContext;
-import org.apache.shiro.web.WebUtils;
 import org.apache.shiro.web.subject.WebSubject;
 import org.apache.shiro.web.subject.WebSubjectContext;
 
@@ -81,10 +80,6 @@ public class DefaultWebSubjectContext extends DefaultSubjectContext implements W
                 request = ((WebSubject) existing).getServletRequest();
             }
         }
-        //last resort - try the thread-local (TODO - remove this if possible):
-        if (request == null) {
-            request = WebUtils.getServletRequest();
-        }
 
         return request;
     }
@@ -111,11 +106,6 @@ public class DefaultWebSubjectContext extends DefaultSubjectContext implements W
             }
         }
 
-        //last resort - try the thread-local (TODO - remove this if possible):
-        if (response == null) {
-            response = WebUtils.getServletResponse();
-        }
-
         return response;
     }
 }
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java b/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
index e321b3a57..56be2b577 100644
--- a/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
+++ b/web/src/main/java/org/apache/shiro/web/subject/support/WebDelegatingSubject.java
@@ -30,7 +30,6 @@ import org.apache.shiro.web.subject.WebSubject;
 
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
-import java.util.concurrent.Callable;
 
 /**
  * @since 1.0
@@ -70,14 +69,4 @@ public class WebDelegatingSubject extends DelegatingSubject implements WebSubjec
         wsc.setServletResponse(this.servletResponse);
         return wsc;
     }
-
-    @Override
-    public <V> Callable<V> associateWith(Callable<V> callable) {
-        return new WebSubjectCallable<V>(this, callable);
-    }
-
-    @Override
-    public Runnable associateWith(Runnable runnable) {
-        return new WebSubjectRunnable(this, runnable);
-    }
 }
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectCallable.java b/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectCallable.java
deleted file mode 100644
index 87ed02790..000000000
--- a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectCallable.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.subject.support;
-
-import org.apache.shiro.subject.support.SubjectCallable;
-import org.apache.shiro.web.subject.WebSubject;
-
-import java.util.concurrent.Callable;
-
-/**
- * @since 1.0
- */
-public class WebSubjectCallable<V> extends SubjectCallable<V> {
-
-    public WebSubjectCallable(WebSubject subject, Callable<V> delegate) {
-        super(new WebSubjectThreadState(subject), delegate);
-    }
-}
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectRunnable.java b/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectRunnable.java
deleted file mode 100644
index 6e9ce2707..000000000
--- a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectRunnable.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.subject.support;
-
-import org.apache.shiro.subject.support.SubjectRunnable;
-import org.apache.shiro.web.subject.WebSubject;
-
-/**
- * @since 1.0
- */
-public class WebSubjectRunnable extends SubjectRunnable {
-
-    public WebSubjectRunnable(WebSubject subject, Runnable delegate) {
-        super(new WebSubjectThreadState(subject), delegate);
-    }
-}
diff --git a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectThreadState.java b/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectThreadState.java
deleted file mode 100644
index fadb6cceb..000000000
--- a/web/src/main/java/org/apache/shiro/web/subject/support/WebSubjectThreadState.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web.subject.support;
-
-import org.apache.shiro.subject.support.SubjectThreadState;
-import org.apache.shiro.web.WebUtils;
-import org.apache.shiro.web.subject.WebSubject;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
-/**
- * Web-specific {@code SubjectThreadState} implementation that, in addition to the parent class's bind/unbind
- * behavior, also ensures that a {@link ServletRequest ServletRequest} and {@link ServletResponse ServletResponse}
- * pair are also bound/unbound as necessary.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public class WebSubjectThreadState extends SubjectThreadState {
-
-    private final ServletRequest request;
-    private final ServletResponse response;
-
-    /**
-     * Creates a new {@code WebSubjectThreadState} instance, retaining the {@link WebSubject} argument's
-     * {@link org.apache.shiro.web.subject.WebSubject#getServletRequest() servletRequest} and
-     * {@link org.apache.shiro.web.subject.WebSubject#getServletResponse() servletResponse} in addition to any
-     * state retained by the parent class's constructor.
-     *
-     * @param subject the {@link WebSubject} to bind as well as from which to acquire the
-     *                {@code ServletRequest} and {@code ServletResponse} pair.
-     */
-    public WebSubjectThreadState(WebSubject subject) {
-        super(subject);
-
-        ServletRequest request = subject.getServletRequest();
-        if (request == null) {
-            request = WebUtils.getServletRequest();
-        }
-        this.request = request;
-
-        ServletResponse response = subject.getServletResponse();
-        if (response == null) {
-            response = WebUtils.getServletResponse();
-        }
-        this.response = response;
-    }
-
-    /**
-     * Calls {@code super.bind()} and then additionally binds the internal {@code ServletRequest} and
-     * {@code ServletResponse} pair via
-     * {@code WebUtils.}{@link WebUtils#bind(javax.servlet.ServletRequest) bind(ServletRequest)} and
-     * {@code WebUtils.}{@link WebUtils#bind(javax.servlet.ServletResponse) bind(ServletResponse)}, respectively.
-     */
-    @Override
-    public void bind() {
-        super.bind();
-        if (request != null) {
-            WebUtils.bind(request);
-        }
-        if (response != null) {
-            WebUtils.bind(response);
-        }
-    }
-}
diff --git a/web/src/main/java/org/apache/shiro/web/util/RequestPairSource.java b/web/src/main/java/org/apache/shiro/web/util/RequestPairSource.java
new file mode 100644
index 000000000..177991240
--- /dev/null
+++ b/web/src/main/java/org/apache/shiro/web/util/RequestPairSource.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2008 Les Hazlewood
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.shiro.web.util;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public interface RequestPairSource {
+
+    ServletRequest getServletRequest();
+
+    ServletResponse getServletResponse();
+}
diff --git a/web/src/test/java/org/apache/shiro/web/AbstractWebSecurityManagerTest.java b/web/src/test/java/org/apache/shiro/web/AbstractWebSecurityManagerTest.java
index 2bcac4325..20b681be0 100644
--- a/web/src/test/java/org/apache/shiro/web/AbstractWebSecurityManagerTest.java
+++ b/web/src/test/java/org/apache/shiro/web/AbstractWebSecurityManagerTest.java
@@ -18,16 +18,9 @@
  */
 package org.apache.shiro.web;
 
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.subject.Subject;
 import org.apache.shiro.util.ThreadContext;
-import org.apache.shiro.web.subject.WebSubject;
-import org.apache.shiro.web.subject.support.WebSubjectThreadState;
 import org.junit.After;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-
 /**
  * @since 1.0
  */
@@ -37,13 +30,4 @@ public abstract class AbstractWebSecurityManagerTest {
     public void tearDown() {
         ThreadContext.remove();
     }
-
-    protected Subject newSubject(SecurityManager sm, ServletRequest request, ServletResponse response) {
-        ThreadContext.bind(sm);
-        WebSubject subject = new WebSubject.Builder(sm, request, response).buildWebSubject();
-        WebSubjectThreadState threadState = new WebSubjectThreadState(subject);
-        threadState.bind();
-        return subject;
-    }
-
 }
diff --git a/web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java b/web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java
index bb1259c43..67d6fb932 100644
--- a/web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java
+++ b/web/src/test/java/org/apache/shiro/web/DefaultWebSecurityManagerTest.java
@@ -26,6 +26,7 @@ import org.apache.shiro.session.Session;
 import org.apache.shiro.session.mgt.AbstractSessionManager;
 import org.apache.shiro.subject.Subject;
 import org.apache.shiro.web.servlet.ShiroHttpSession;
+import org.apache.shiro.web.subject.WebSubject;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -65,7 +66,7 @@ public class DefaultWebSecurityManagerTest extends AbstractWebSecurityManagerTes
     }
 
     protected Subject newSubject(ServletRequest request, ServletResponse response) {
-        return newSubject(sm, request, response);
+        return new WebSubject.Builder(sm, request, response).buildSubject();
     }
 
     @Test
diff --git a/web/src/test/java/org/apache/shiro/web/DelegatingWebSecurityManagerTest.java b/web/src/test/java/org/apache/shiro/web/DelegatingWebSecurityManagerTest.java
deleted file mode 100644
index b79608f38..000000000
--- a/web/src/test/java/org/apache/shiro/web/DelegatingWebSecurityManagerTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.web;
-
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.session.ExpiredSessionException;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.mgt.AbstractSessionManager;
-import org.apache.shiro.session.mgt.DelegatingSession;
-import org.apache.shiro.session.mgt.SessionContext;
-import org.apache.shiro.subject.Subject;
-import org.easymock.EasyMock;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.Serializable;
-import java.util.UUID;
-
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * Unit test for the {@link org.apache.shiro.web.DelegatingWebSecurityManager} implementation.
- *
- * @since 1.0
- */
-public class DelegatingWebSecurityManagerTest extends AbstractWebSecurityManagerTest {
-
-    private DelegatingWebSecurityManager sm;
-
-    @Before
-    public void setup() {
-        sm = new DelegatingWebSecurityManager();
-    }
-
-    @After
-    public void tearDown() {
-        sm.destroy();
-        super.tearDown();
-    }
-
-    protected Subject newSubject(ServletRequest request, ServletResponse response) {
-        return newSubject(sm, request, response);
-    }
-
-    @Test
-    public void testSessionTimeout() {
-
-        SecurityManager delegate = createMock(SecurityManager.class);
-        sm.setDelegateSecurityManager(delegate);
-
-        HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);
-        HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);
-
-        expect(mockRequest.getCookies()).andReturn(null);
-
-        String host = "192.168.1.1";
-
-        Serializable sessionId = UUID.randomUUID().toString();
-        expect(delegate.start(EasyMock.<SessionContext>anyObject())).andReturn(new DelegatingSession(sm, sessionId));
-        expect(delegate.getHost(sessionId)).andReturn(host);
-        expect(delegate.getTimeout(sessionId)).andReturn(AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
-        delegate.setTimeout(sessionId, 125L);
-        expectLastCall().times(1);
-        expect(delegate.getTimeout(sessionId)).andReturn(125L);
-        //pretend that 125ms have gone by
-        Serializable replacedSessionId = UUID.randomUUID().toString();
-        @SuppressWarnings({"ThrowableInstanceNeverThrown"})
-        ExpiredSessionException expired = new ExpiredSessionException("test", sessionId);
-        expect(delegate.getTimeout(sessionId)).andThrow(expired);
-
-        replay(delegate);
-        replay(mockRequest);
-
-        Subject subject = newSubject(mockRequest, mockResponse);
-        Session session = subject.getSession();
-        String id = session.getId().toString();
-        assertEquals(AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT, session.getTimeout());
-        session.setTimeout(125);
-        assertEquals(125, session.getTimeout());
-        //now the underlying session should have been expired and a new one replaced by default.
-        //so ensure the replaced session has the default session timeout:
-        try {
-            session.getTimeout();
-            fail("Should have thrown an ExpiredSessionException");
-        } catch (ExpiredSessionException expected) {
-        }
-        verify(delegate);
-        verify(mockRequest);
-    }
-}
\ No newline at end of file
diff --git a/web/src/test/java/org/apache/shiro/web/session/DefaultWebSessionManagerTest.java b/web/src/test/java/org/apache/shiro/web/session/DefaultWebSessionManagerTest.java
index a95a3ac1b..060bc49a4 100644
--- a/web/src/test/java/org/apache/shiro/web/session/DefaultWebSessionManagerTest.java
+++ b/web/src/test/java/org/apache/shiro/web/session/DefaultWebSessionManagerTest.java
@@ -20,7 +20,6 @@ package org.apache.shiro.web.session;
 
 import org.apache.shiro.session.mgt.SimpleSession;
 import org.apache.shiro.util.ThreadContext;
-import org.apache.shiro.web.WebUtils;
 import org.apache.shiro.web.servlet.Cookie;
 import org.apache.shiro.web.servlet.ShiroHttpServletRequest;
 import org.apache.shiro.web.servlet.ShiroHttpSession;
@@ -57,8 +56,9 @@ public class DefaultWebSessionManagerTest {
         SimpleSession session = new SimpleSession();
         session.setId("12345");
 
-        WebUtils.bind(createMock(HttpServletRequest.class));
-        WebUtils.bind(createMock(HttpServletResponse.class));
+        WebSessionContext wsc = new DefaultWebSessionContext();
+        wsc.setServletRequest(createMock(HttpServletRequest.class));
+        wsc.setServletResponse(createMock(HttpServletResponse.class));
 
         //test that the cookie template is being used:
         expect(cookie.getValue()).andReturn("blah");
@@ -73,7 +73,7 @@ public class DefaultWebSessionManagerTest {
 
         replay(cookie);
 
-        mgr.onStart(session);
+        mgr.onStart(session, wsc);
 
         verify(cookie);
     }
@@ -91,12 +91,13 @@ public class DefaultWebSessionManagerTest {
         SimpleSession session = new SimpleSession();
         session.setId("12345");
 
-        WebUtils.bind(createMock(HttpServletRequest.class));
-        WebUtils.bind(createMock(HttpServletResponse.class));
+        WebSessionContext wsc = new DefaultWebSessionContext();
+        wsc.setServletRequest(createMock(HttpServletRequest.class));
+        wsc.setServletResponse(createMock(HttpServletResponse.class));
 
         replay(cookie);
 
-        mgr.onStart(session);
+        mgr.onStart(session, wsc);
 
         verify(cookie);
     }
