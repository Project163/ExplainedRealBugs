diff --git a/lib/capybara/driver/culerity_driver.rb b/lib/capybara/driver/culerity_driver.rb
index d979994c..9157a9f2 100644
--- a/lib/capybara/driver/culerity_driver.rb
+++ b/lib/capybara/driver/culerity_driver.rb
@@ -55,7 +55,6 @@ class Capybara::Driver::Culerity < Capybara::Driver::Base
   def initialize(app)
     @app = app
     @rack_server = Capybara::Server.new(@app)
-    @rack_server.boot
   end
 
   def visit(path)
diff --git a/lib/capybara/driver/selenium_driver.rb b/lib/capybara/driver/selenium_driver.rb
index 672b321e..5c65f8fe 100644
--- a/lib/capybara/driver/selenium_driver.rb
+++ b/lib/capybara/driver/selenium_driver.rb
@@ -66,7 +66,6 @@ class Capybara::Driver::Selenium < Capybara::Driver::Base
   def initialize(app)
     @app = app
     @rack_server = Capybara::Server.new(@app)
-    @rack_server.boot
   end
 
   def visit(path)
diff --git a/lib/capybara/server.rb b/lib/capybara/server.rb
index 65b869b0..8952dc0b 100644
--- a/lib/capybara/server.rb
+++ b/lib/capybara/server.rb
@@ -4,14 +4,27 @@ require 'rack'
 require 'rack/handler/mongrel'
 
 class Capybara::Server
-  attr_reader :app
-  
+  class Identify
+    def initialize(app)
+      @app = app
+    end
+
+    def call(env)
+      if env["REQUEST_PATH"] == "/__identify__"
+        [200, {}, @app.object_id.to_s]
+      else
+        @app.call(env)
+      end
+    end
+  end
+
+
+  attr_reader :app, :port
+
   def initialize(app)
     @app = app
-  end
-  
-  def port
-    8080
+    find_available_port
+    boot
   end
 
   def host
@@ -22,34 +35,59 @@ class Capybara::Server
     path = URI.parse(path).request_uri if path =~ /^http/
     "http://#{host}:#{port}#{path}"
   end
-  
+
+  def responsive?
+    is_running_on_port?(port)
+  end
+
+private
+
   def boot
     Capybara.log "application has already booted" and return if responsive?
     Capybara.log "booting Rack applicartion on port #{port}"
-    start_time = Time.now
-    Thread.new do
-      Rack::Handler::Mongrel.run @app, :Port => port
-    end
-    Capybara.log "checking if application has booted"
-    loop do
-      Capybara.log("application has booted") and break if responsive?
-      if Time.now - start_time > 10 
-        Capybara.log "Rack application timed out during boot"
-        exit
+
+    Timeout.timeout(10) do
+      Thread.new do
+        Rack::Handler::Mongrel.run Identify.new(@app), :Port => port
+      end
+      Capybara.log "checking if application has booted"
+
+      loop do
+        Capybara.log("application has booted") and break if responsive?
+        sleep 0.5
       end
-      
-      Capybara.log '.'
-      sleep 1
     end
+  rescue Timeout::Error
+    Capybara.log "Rack application timed out during boot"
+    exit
   end
 
-  def responsive?
-    res = Net::HTTP.start(host, port) { |http| http.get('/') }
+  def find_available_port
+    @port = 9887
+    @port += 1 while is_port_open?(@port) and not is_running_on_port?(@port)
+  end
+
+  def is_running_on_port?(tested_port)
+    res = Net::HTTP.start(host, tested_port) { |http| http.get('/__identify__') }
 
     if res.is_a?(Net::HTTPSuccess) or res.is_a?(Net::HTTPRedirection)
-      return true
+      return res.body == @app.object_id.to_s
+    end
+  rescue Errno::ECONNREFUSED
+    return false
+  end
+
+  def is_port_open?(tested_port)
+    Timeout::timeout(1) do
+      begin
+        s = TCPSocket.new(host, tested_port)
+        s.close
+        return true
+      rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH
+        return false
+      end
     end
-  rescue Errno::ECONNREFUSED 
+  rescue Timeout::Error
     return false
   end
 
diff --git a/spec/server_spec.rb b/spec/server_spec.rb
new file mode 100644
index 00000000..65f4357d
--- /dev/null
+++ b/spec/server_spec.rb
@@ -0,0 +1,47 @@
+require File.expand_path('spec_helper', File.dirname(__FILE__))
+
+describe Capybara::Server do
+
+  it "should spool up a rack server" do
+    @app = proc { |env| [200, {}, "Hello Server!"]}
+    @server = Capybara::Server.new(@app)
+    
+    @res = Net::HTTP.start(@server.host, @server.port) { |http| http.get('/') }
+    
+    @res.body.should include('Hello Server')
+  end
+  
+  it "should find an available port" do
+    @app1 = proc { |env| [200, {}, "Hello Server!"]}
+    @app2 = proc { |env| [200, {}, "Hello Second Server!"]}
+
+    @server1 = Capybara::Server.new(@app1)
+    @server2 = Capybara::Server.new(@app2)
+    
+    @res1 = Net::HTTP.start(@server1.host, @server1.port) { |http| http.get('/') }
+    @res1.body.should include('Hello Server')
+    
+    @res2 = Net::HTTP.start(@server2.host, @server2.port) { |http| http.get('/') }
+    @res2.body.should include('Hello Second Server')
+  end
+  
+  it "should use the server if it already running" do
+    @app1 = proc { |env| [200, {}, "Hello Server!"]}
+    @app2 = proc { |env| [200, {}, "Hello Second Server!"]}
+
+    @server1a = Capybara::Server.new(@app1)
+    @server1b = Capybara::Server.new(@app1)
+    @server2a = Capybara::Server.new(@app2)
+    @server2b = Capybara::Server.new(@app2)
+    
+    @res1 = Net::HTTP.start(@server1b.host, @server1b.port) { |http| http.get('/') }
+    @res1.body.should include('Hello Server')
+    
+    @res2 = Net::HTTP.start(@server2b.host, @server2b.port) { |http| http.get('/') }
+    @res2.body.should include('Hello Second Server')
+    
+    @server1a.port.should == @server1b.port
+    @server2a.port.should == @server2b.port
+  end
+
+end
