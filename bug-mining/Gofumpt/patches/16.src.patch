diff --git a/internal/gofumpt.go b/internal/gofumpt.go
index 353040e..60d6ba5 100644
--- a/internal/gofumpt.go
+++ b/internal/gofumpt.go
@@ -372,6 +372,25 @@ func (f *fumpter) applyPre(c *astutil.Cursor) {
 			f.addNewline(node.Lbrace + 1)
 			closeLine = f.Line(node.Rbrace)
 		}
+		for i1, elem1 := range node.Elts {
+			i2 := i1 + 1
+			if i2 >= len(node.Elts) {
+				break
+			}
+			elem2 := node.Elts[i2]
+			// TODO: do we care about &{}?
+			_, ok1 := elem1.(*ast.CompositeLit)
+			_, ok2 := elem2.(*ast.CompositeLit)
+			if !ok1 && !ok2 {
+				continue
+			}
+			// If there's a newline between any consecutive
+			// elements, there must be a newline between all
+			// composite literal elements.
+			if f.Line(elem1.End()) == f.Line(elem2.Pos()) {
+				f.addNewline(elem1.End())
+			}
+		}
 		last := node.Elts[len(node.Elts)-1]
 		if closeLine == f.Line(last.End()) {
 			f.addNewline(last.End())
diff --git a/testdata/scripts/composite-multiline.txt b/testdata/scripts/composite-multiline.txt
index 157fcf5..3c2087d 100644
--- a/testdata/scripts/composite-multiline.txt
+++ b/testdata/scripts/composite-multiline.txt
@@ -23,6 +23,17 @@ var _ = []string{`
 	if no elements are surrounded by newlines
 `}
 
+var _ = []struct{ a int }{
+	{ // consistent
+		a: 1,
+	},
+	{
+		a: 2,
+	}, { // inconsistent
+		a: 3,
+	},
+}
+
 -- foo.go.golden --
 package p
 
@@ -45,3 +56,15 @@ var _ = []string{`
 	`, `
 	if no elements are surrounded by newlines
 `}
+
+var _ = []struct{ a int }{
+	{ // consistent
+		a: 1,
+	},
+	{
+		a: 2,
+	},
+	{ // inconsistent
+		a: 3,
+	},
+}
