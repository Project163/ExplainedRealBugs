diff --git a/flag.go b/flag.go
deleted file mode 100644
index 27d614d..0000000
--- a/flag.go
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright (c) 2019, Daniel Mart√≠ <mvdan@mvdan.cc>
-// See LICENSE for licensing information
-
-package main
-
-import "flag"
-
-var (
-	langVersion = flag.String("lang", "", "target Go version in the form 1.X (default from go.mod)")
-	extraRules  = flag.Bool("extra", false, "enable extra rules which should be vetted by a human")
-	showVersion = flag.Bool("version", false, "show version and exit")
-)
-
-func init() {
-	// make -s default to true
-	*simplifyAST = true
-}
diff --git a/gofmt.go b/gofmt.go
index ed81704..98be0d4 100644
--- a/gofmt.go
+++ b/gofmt.go
@@ -30,15 +30,18 @@ import (
 
 var (
 	// main operation modes
-	list        = flag.Bool("l", false, "list files whose formatting differs from gofumpt's")
-	write       = flag.Bool("w", false, "write result to (source) file instead of stdout")
-	rewriteRule = flag.String("r", "", "rewrite rule (e.g., 'a[b:len(a)] -> a[b:]')")
-	simplifyAST = flag.Bool("s", false, "simplify code")
-	doDiff      = flag.Bool("d", false, "display diffs instead of rewriting files")
-	allErrors   = flag.Bool("e", false, "report all errors (not just the first 10 on different lines)")
+	list      = flag.Bool("l", false, "list files whose formatting differs from gofumpt's")
+	write     = flag.Bool("w", false, "write result to (source) file instead of stdout")
+	doDiff    = flag.Bool("d", false, "display diffs instead of rewriting files")
+	allErrors = flag.Bool("e", false, "report all errors (not just the first 10 on different lines)")
 
 	// debugging
 	cpuprofile = flag.String("cpuprofile", "", "write cpu profile to this file")
+
+	// gofumpt's own flags
+	langVersion = flag.String("lang", "", "target Go version in the form 1.X (default from go.mod)")
+	extraRules  = flag.Bool("extra", false, "enable extra rules which should be vetted by a human")
+	showVersion = flag.Bool("version", false, "show version and exit")
 )
 
 // Keep these in sync with go/format/format.go.
@@ -56,7 +59,6 @@ const (
 var (
 	fileSet    = token.NewFileSet() // per process FileSet
 	exitCode   = 0
-	rewrite    func(*ast.File) *ast.File
 	parserMode parser.Mode
 
 	// walkingVendorDir is true if we are explicitly walking a vendor directory.
@@ -113,19 +115,9 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error
 		return err
 	}
 
-	if rewrite != nil {
-		if sourceAdj == nil {
-			file = rewrite(file)
-		} else {
-			fmt.Fprintf(os.Stderr, "warning: rewrite ignored for incomplete programs\n")
-		}
-	}
-
 	ast.SortImports(fileSet, file)
 
-	if *simplifyAST {
-		simplify(file)
-	}
+	simplify(file)
 
 	// Apply gofumpt's changes before we print the code in gofumpt's format.
 
@@ -229,7 +221,6 @@ func gofumptMain() {
 	}
 
 	initParserMode()
-	initRewrite()
 
 	args := flag.Args()
 	if len(args) == 0 {
diff --git a/rewrite.go b/rewrite.go
index bab22e0..deae0b6 100644
--- a/rewrite.go
+++ b/rewrite.go
@@ -5,150 +5,21 @@
 package main
 
 import (
-	"fmt"
 	"go/ast"
-	"go/parser"
 	"go/token"
-	"os"
 	"reflect"
-	"strings"
 	"unicode"
 	"unicode/utf8"
 )
 
-func initRewrite() {
-	if *rewriteRule == "" {
-		rewrite = nil // disable any previous rewrite
-		return
-	}
-	f := strings.Split(*rewriteRule, "->")
-	if len(f) != 2 {
-		fmt.Fprintf(os.Stderr, "rewrite rule must be of the form 'pattern -> replacement'\n")
-		os.Exit(2)
-	}
-	pattern := parseExpr(f[0], "pattern")
-	replace := parseExpr(f[1], "replacement")
-	rewrite = func(p *ast.File) *ast.File { return rewriteFile(pattern, replace, p) }
-}
-
-// parseExpr parses s as an expression.
-// It might make sense to expand this to allow statement patterns,
-// but there are problems with preserving formatting and also
-// with what a wildcard for a statement looks like.
-func parseExpr(s, what string) ast.Expr {
-	x, err := parser.ParseExpr(s)
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "parsing %s %s at %s\n", what, s, err)
-		os.Exit(2)
-	}
-	return x
-}
-
-// Keep this function for debugging.
-/*
-func dump(msg string, val reflect.Value) {
-	fmt.Printf("%s:\n", msg)
-	ast.Print(fileSet, val.Interface())
-	fmt.Println()
-}
-*/
-
-// rewriteFile applies the rewrite rule 'pattern -> replace' to an entire file.
-func rewriteFile(pattern, replace ast.Expr, p *ast.File) *ast.File {
-	cmap := ast.NewCommentMap(fileSet, p, p.Comments)
-	m := make(map[string]reflect.Value)
-	pat := reflect.ValueOf(pattern)
-	repl := reflect.ValueOf(replace)
-
-	var rewriteVal func(val reflect.Value) reflect.Value
-	rewriteVal = func(val reflect.Value) reflect.Value {
-		// don't bother if val is invalid to start with
-		if !val.IsValid() {
-			return reflect.Value{}
-		}
-		val = apply(rewriteVal, val)
-		for k := range m {
-			delete(m, k)
-		}
-		if match(m, pat, val) {
-			val = subst(m, repl, reflect.ValueOf(val.Interface().(ast.Node).Pos()))
-		}
-		return val
-	}
-
-	r := apply(rewriteVal, reflect.ValueOf(p)).Interface().(*ast.File)
-	r.Comments = cmap.Filter(r).Comments() // recreate comments list
-	return r
-}
-
-// set is a wrapper for x.Set(y); it protects the caller from panics if x cannot be changed to y.
-func set(x, y reflect.Value) {
-	// don't bother if x cannot be set or y is invalid
-	if !x.CanSet() || !y.IsValid() {
-		return
-	}
-	defer func() {
-		if x := recover(); x != nil {
-			if s, ok := x.(string); ok &&
-				(strings.Contains(s, "type mismatch") || strings.Contains(s, "not assignable")) {
-				// x cannot be set to y - ignore this rewrite
-				return
-			}
-			panic(x)
-		}
-	}()
-	x.Set(y)
-}
-
 // Values/types for special cases.
 var (
-	objectPtrNil = reflect.ValueOf((*ast.Object)(nil))
-	scopePtrNil  = reflect.ValueOf((*ast.Scope)(nil))
-
 	identType     = reflect.TypeOf((*ast.Ident)(nil))
 	objectPtrType = reflect.TypeOf((*ast.Object)(nil))
 	positionType  = reflect.TypeOf(token.NoPos)
 	callExprType  = reflect.TypeOf((*ast.CallExpr)(nil))
-	scopePtrType  = reflect.TypeOf((*ast.Scope)(nil))
 )
 
-// apply replaces each AST field x in val with f(x), returning val.
-// To avoid extra conversions, f operates on the reflect.Value form.
-func apply(f func(reflect.Value) reflect.Value, val reflect.Value) reflect.Value {
-	if !val.IsValid() {
-		return reflect.Value{}
-	}
-
-	// *ast.Objects introduce cycles and are likely incorrect after
-	// rewrite; don't follow them but replace with nil instead
-	if val.Type() == objectPtrType {
-		return objectPtrNil
-	}
-
-	// similarly for scopes: they are likely incorrect after a rewrite;
-	// replace them with nil
-	if val.Type() == scopePtrType {
-		return scopePtrNil
-	}
-
-	switch v := reflect.Indirect(val); v.Kind() {
-	case reflect.Slice:
-		for i := 0; i < v.Len(); i++ {
-			e := v.Index(i)
-			set(e, f(e))
-		}
-	case reflect.Struct:
-		for i := 0; i < v.NumField(); i++ {
-			e := v.Field(i)
-			set(e, f(e))
-		}
-	case reflect.Interface:
-		e := v.Elem()
-		set(v, f(e))
-	}
-	return val
-}
-
 func isWildcard(s string) bool {
 	rune, size := utf8.DecodeRuneInString(s)
 	return size == len(s) && unicode.IsLower(rune)
@@ -240,70 +111,3 @@ func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {
 	// Handle token integers, etc.
 	return p.Interface() == v.Interface()
 }
-
-// subst returns a copy of pattern with values from m substituted in place
-// of wildcards and pos used as the position of tokens from the pattern.
-// if m == nil, subst returns a copy of pattern and doesn't change the line
-// number information.
-func subst(m map[string]reflect.Value, pattern reflect.Value, pos reflect.Value) reflect.Value {
-	if !pattern.IsValid() {
-		return reflect.Value{}
-	}
-
-	// Wildcard gets replaced with map value.
-	if m != nil && pattern.Type() == identType {
-		name := pattern.Interface().(*ast.Ident).Name
-		if isWildcard(name) {
-			if old, ok := m[name]; ok {
-				return subst(nil, old, reflect.Value{})
-			}
-		}
-	}
-
-	if pos.IsValid() && pattern.Type() == positionType {
-		// use new position only if old position was valid in the first place
-		if old := pattern.Interface().(token.Pos); !old.IsValid() {
-			return pattern
-		}
-		return pos
-	}
-
-	// Otherwise copy.
-	switch p := pattern; p.Kind() {
-	case reflect.Slice:
-		if p.IsNil() {
-			// Do not turn nil slices into empty slices. go/ast
-			// guarantees that certain lists will be nil if not
-			// populated.
-			return reflect.Zero(p.Type())
-		}
-		v := reflect.MakeSlice(p.Type(), p.Len(), p.Len())
-		for i := 0; i < p.Len(); i++ {
-			v.Index(i).Set(subst(m, p.Index(i), pos))
-		}
-		return v
-
-	case reflect.Struct:
-		v := reflect.New(p.Type()).Elem()
-		for i := 0; i < p.NumField(); i++ {
-			v.Field(i).Set(subst(m, p.Field(i), pos))
-		}
-		return v
-
-	case reflect.Ptr:
-		v := reflect.New(p.Type()).Elem()
-		if elem := p.Elem(); elem.IsValid() {
-			v.Set(subst(m, elem, pos).Addr())
-		}
-		return v
-
-	case reflect.Interface:
-		v := reflect.New(p.Type()).Elem()
-		if elem := p.Elem(); elem.IsValid() {
-			v.Set(subst(m, elem, pos))
-		}
-		return v
-	}
-
-	return pattern
-}
