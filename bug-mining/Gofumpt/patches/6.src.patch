diff --git a/README.md b/README.md
index e79d993..8408dce 100644
--- a/README.md
+++ b/README.md
@@ -54,6 +54,27 @@ if err != nil {
 
 </details>
 
+No empty lines before a simple error check
+
+<details><summary>example</summary>
+
+```
+foo, err := processFoo()
+
+if err != nil {
+	return err
+}
+```
+
+```
+foo, err := processFoo()
+if err != nil {
+	return err
+}
+```
+
+</details>
+
 Composite literals with elements in separate lines must also separate both braces
 
 <details><summary>example</summary>
diff --git a/internal/gofumpt.go b/internal/gofumpt.go
index 959d017..1be8ee7 100644
--- a/internal/gofumpt.go
+++ b/internal/gofumpt.go
@@ -51,6 +51,14 @@ func Gofumpt(fset *token.FileSet, file *ast.File) {
 		}
 		f.visit(node)
 		f.stack = append(f.stack, node)
+		switch node := node.(type) {
+		case *ast.BlockStmt:
+			f.visit(node.List)
+		case *ast.CaseClause:
+			f.visit(node.Body)
+		case *ast.CommClause:
+			f.visit(node.Body)
+		}
 		return true
 	})
 }
@@ -175,7 +183,8 @@ func (f *fumpter) printLength(node ast.Node) int {
 //   //sys(nb)?   | syscall function wrapper prototypes
 var rxCommentDirective = regexp.MustCompile(`^([a-z]+:|line\b|export\b|sys(nb)?\b)`)
 
-func (f *fumpter) visit(node ast.Node) {
+// visit takes either an ast.Node or a []ast.Stmt.
+func (f *fumpter) visit(node interface{}) {
 	switch node := node.(type) {
 	case *ast.File:
 		var lastMulti bool
@@ -275,6 +284,28 @@ func (f *fumpter) visit(node ast.Node) {
 		f.removeLinesBetween(node.Lbrace, bodyPos)
 		f.removeLinesBetween(bodyEnd, node.Rbrace)
 
+	case []ast.Stmt:
+		for i, stmt := range node {
+			ifs, ok := stmt.(*ast.IfStmt)
+			if !ok || i < 1 {
+				continue // not an if following another statement
+			}
+			as, ok := node[i-1].(*ast.AssignStmt)
+			if !ok || as.Tok != token.DEFINE ||
+				!identEqual(as.Lhs[len(as.Lhs)-1], "err") {
+				continue // not "..., err := ..."
+			}
+			be, ok := ifs.Cond.(*ast.BinaryExpr)
+			if !ok || ifs.Init != nil || ifs.Else != nil {
+				continue // complex if
+			}
+			if be.Op != token.NEQ || !identEqual(be.X, "err") ||
+				!identEqual(be.Y, "nil") {
+				continue // not "err != nil"
+			}
+			f.removeLinesBetween(as.End(), ifs.Pos())
+		}
+
 	case *ast.CompositeLit:
 		if len(node.Elts) == 0 {
 			// doesn't have elements
@@ -334,6 +365,11 @@ func (f *fumpter) visit(node ast.Node) {
 	}
 }
 
+func identEqual(expr ast.Expr, name string) bool {
+	id, ok := expr.(*ast.Ident)
+	return ok && id.Name == name
+}
+
 // joinStdImports ensures that all standard library imports are together and at
 // the top of the imports list.
 func (f *fumpter) joinStdImports(d *ast.GenDecl) {
diff --git a/testdata/scripts/newline-errcheck.txt b/testdata/scripts/newline-errcheck.txt
new file mode 100644
index 0000000..4f96b3f
--- /dev/null
+++ b/testdata/scripts/newline-errcheck.txt
@@ -0,0 +1,101 @@
+gofumpt -w foo.go .
+cmp foo.go foo.go.golden
+
+-- foo.go --
+package p
+
+var Do1 func() error
+
+var Do2 func() (int, error)
+
+func f() {
+	n1, err := Do2()
+	if err != nil {
+		panic(err)
+	}
+
+	if n2, err := Do2(); err != nil {
+		panic(err)
+	}
+
+	n3, err := Do2()
+
+	if err != nil {
+		panic(err)
+	}
+
+	select {
+	default:
+		err := Do1()
+
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	n4, err := Do2()
+
+	if err != nil && err.Error() == "complex condition" {
+		panic(err)
+	}
+
+	err1 := Do1()
+
+	if err != nil {
+		panic(err)
+	}
+
+	{
+		if err != nil {
+			panic(err)
+		}
+	}
+}
+-- foo.go.golden --
+package p
+
+var Do1 func() error
+
+var Do2 func() (int, error)
+
+func f() {
+	n1, err := Do2()
+	if err != nil {
+		panic(err)
+	}
+
+	if n2, err := Do2(); err != nil {
+		panic(err)
+	}
+
+	n3, err := Do2()
+	if err != nil {
+		panic(err)
+	}
+
+	select {
+	default:
+		err := Do1()
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	n4, err := Do2()
+
+	if err != nil && err.Error() == "complex condition" {
+		panic(err)
+	}
+
+	err1 := Do1()
+
+	if err != nil {
+		panic(err)
+	}
+
+	{
+		if err != nil {
+			panic(err)
+		}
+	}
+}
