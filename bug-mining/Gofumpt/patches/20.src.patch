diff --git a/internal/gofumpt.go b/internal/gofumpt.go
index bc0f099..787b387 100644
--- a/internal/gofumpt.go
+++ b/internal/gofumpt.go
@@ -427,6 +427,15 @@ func (f *fumpter) applyPre(c *astutil.Cursor) {
 
 	case *ast.CommClause:
 		f.stmts(node.Body)
+
+	case *ast.FieldList:
+		switch c.Parent().(type) {
+		case *ast.FuncDecl, *ast.FuncType, *ast.InterfaceType:
+			node.List = f.mergeAdjacentFields(node.List)
+			c.Replace(node)
+		case *ast.StructType:
+			// Do not merge adjacent fields in structs.
+		}
 	}
 }
 
@@ -516,6 +525,59 @@ func (f *fumpter) joinStdImports(d *ast.GenDecl) {
 	}
 }
 
+// mergeAdjacentFields mutates fieldList to merge adjacent fields if possible
+// and returns fieldList.
+func (f *fumpter) mergeAdjacentFields(fields []*ast.Field) []*ast.Field {
+	// If there are less than two fields then there is nothing to merge.
+	if len(fields) < 2 {
+		return fields
+	}
+
+	// Otherwise, iterate over adjacent pairs of fields, merging if possible,
+	// and building a new list. Elements of fieldList.List may be mutated (if
+	// merged with following fields), discarded (if merged with a preceeding
+	// field), or left unchanged.
+	lastField := fields[0]
+	newFields := []*ast.Field{lastField}
+	for i := 1; i < len(fields); i++ {
+		field := fields[i]
+		if f.shouldMergeAdjacentFields(field, lastField) {
+			lastField.Names = append(lastField.Names, field.Names...)
+		} else {
+			newFields = append(newFields, field)
+			lastField = field
+		}
+	}
+	return newFields
+}
+
+func (f *fumpter) shouldMergeAdjacentFields(f1, f2 *ast.Field) bool {
+	// Do not merge if either field has doc, comments, no names, or the fields
+	// are not on the same line.
+	if f1.Doc != nil || f2.Doc != nil ||
+		f1.Comment != nil || f2.Comment != nil ||
+		len(f1.Names) == 0 || len(f2.Names) == 0 ||
+		f.Line(f1.Pos()) != f.Line(f2.Pos()) {
+		return false
+	}
+
+	// Only merge if the types are equal.
+	return typeEqual(f1.Type, f2.Type)
+}
+
+func typeEqual(t1, t2 ast.Expr) bool {
+	// FIXME the following only works for identified types, extend it to work for anonymous types
+	ident1, ok := t1.(*ast.Ident)
+	if !ok {
+		return false
+	}
+	ident2, ok := t2.(*ast.Ident)
+	if !ok {
+		return false
+	}
+	return ident1.Name == ident2.Name
+}
+
 var posType = reflect.TypeOf(token.NoPos)
 
 // setPos recursively sets all position fields in the node v to pos.
diff --git a/testdata/scripts/comment-spaced.txt b/testdata/scripts/comment-spaced.txt
index 7c44f74..a5b096f 100644
--- a/testdata/scripts/comment-spaced.txt
+++ b/testdata/scripts/comment-spaced.txt
@@ -67,7 +67,7 @@ package p
 //export CgoFunc
 
 //extern open
-func c_open(name *byte, mode int, perm int) int
+func c_open(name *byte, mode, perm int) int
 
 //line 123
 
diff --git a/testdata/scripts/func-merge-parameters.txt b/testdata/scripts/func-merge-parameters.txt
new file mode 100644
index 0000000..95031af
--- /dev/null
+++ b/testdata/scripts/func-merge-parameters.txt
@@ -0,0 +1,87 @@
+gofumpt -w .
+cmp foo.go foo.go.golden
+
+-- foo.go --
+package p
+
+type f func(x int, y int) int
+
+type i interface {
+	add(x int, y int)
+}
+
+type s struct {
+	x int
+	y int
+}
+
+func mergeAdjacent(x int, y int) {}
+
+func mergeThreeAdjacent(x int, y int, z int) {}
+
+func mergeOneWithTwo(x, y int, z int) {}
+
+func mergeTwoWithOne(x int, y, z int) {}
+
+func mergeWithComment(
+	x int, y int, // comment
+)
+
+func dontMergeAnonymousParams(int, int) {}
+
+func dontMergeComplexTypes(x struct{ V int }, y struct{ V int }) {}
+
+func dontMergeMultipleLines(
+	x int,
+	y int,
+) {
+}
+
+func dontMergeMultipleLines2(
+	x,
+	y int,
+	z int,
+) {
+}
+-- foo.go.golden --
+package p
+
+type f func(x, y int) int
+
+type i interface {
+	add(x, y int)
+}
+
+type s struct {
+	x int
+	y int
+}
+
+func mergeAdjacent(x, y int) {}
+
+func mergeThreeAdjacent(x, y, z int) {}
+
+func mergeOneWithTwo(x, y, z int) {}
+
+func mergeTwoWithOne(x, y, z int) {}
+
+func mergeWithComment(
+	x, y int, // comment
+)
+
+func dontMergeAnonymousParams(int, int) {}
+
+func dontMergeComplexTypes(x struct{ V int }, y struct{ V int }) {}
+
+func dontMergeMultipleLines(
+	x int,
+	y int,
+) {
+}
+
+func dontMergeMultipleLines2(
+	x,
+	y int,
+	z int,
+) {
+}
\ No newline at end of file
